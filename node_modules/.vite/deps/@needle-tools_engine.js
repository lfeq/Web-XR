import {
  $physicsKey,
  ActionBuilder,
  ActionCollection,
  ActionModel,
  Addressables,
  AlignmentConstraint,
  AmbientMode,
  Animation,
  AnimationCurve,
  AnimationExtension,
  AnimationTrackHandler,
  AnimationUtils,
  Animator,
  AnimatorConditionMode,
  AnimatorController,
  AnimatorControllerParameterType,
  AnimatorStateInfo,
  Antialiasing,
  Application,
  ApplicationEvents,
  AssetDatabase,
  AssetReference,
  AudioExtension,
  AudioListener,
  AudioSource,
  AudioTrackHandler,
  Avatar,
  AvatarBlink_Simple,
  AvatarEyeLook_Rotation,
  AvatarLoader,
  AvatarMarker,
  AvatarModel,
  Avatar_Brain_LookAt,
  Avatar_MouthShapes,
  Avatar_MustacheShake,
  Avatar_POI,
  Axes,
  AxesHelper,
  BUILD_TIME,
  BaseUIComponent,
  BasicIKConstraint,
  BehaviorExtension,
  BehaviorModel,
  BlobStorage,
  BloomEffect,
  BoxCollider,
  BoxGizmo,
  BoxHelperComponent,
  Button,
  ButtonsFactory,
  CallDirection,
  CallInfo,
  Camera,
  CameraTargetReachedEvent,
  Canvas,
  CanvasGroup,
  CapsuleCollider,
  ChangeMaterialOnClick,
  ChangeTransformOnClick,
  CharacterController,
  CharacterControllerInput,
  ChromaticAberration,
  CircularBuffer,
  ClearFlags,
  ClipExtrapolation,
  Collider,
  Collision,
  CollisionDetectionMode,
  ColorAdjustments,
  ColorBySpeedModule,
  ColorOverLifetimeModule,
  Component,
  ComponentLifecycleEvents,
  Component_exports,
  ConnectionEvents,
  ContactPoint,
  ContactShadows,
  Context,
  ContextArgs,
  ContextEvent,
  ContextRegistry,
  ControlTrackHandler,
  CustomBranding,
  CustomShader,
  DefaultReflectionMode,
  Deletable,
  DeleteBox,
  DepthOfField,
  DeviceFlag,
  DeviceUtilities,
  DocumentExtension,
  DragControls,
  DragMode,
  DropListener,
  DropListenerAddedEvent,
  Duplicatable,
  EffectWrapper,
  EmissionModule,
  EmphasizeOnClick,
  EngineLoadingView,
  EventList,
  EventListEvent,
  EventSystem,
  EventTrigger,
  FieldWithDefault,
  FileReference,
  FileReferenceSerializer,
  FileSpawnModel,
  File_Event,
  FixedJoint,
  FlyControls,
  Fog,
  FrameEvent,
  GENERATOR,
  GLTFExporter,
  GLTFMeshGPUInstancingExtension,
  GameObject,
  Gizmos,
  GltfExport,
  GltfExportBox,
  GltfLoadEvent,
  GltfLoadEventType,
  Gradient,
  Graphic,
  GraphicRaycaster,
  Graphics,
  GridHelper,
  GridLayoutGroup,
  GroundProjectedEnv,
  GroupActionModel,
  HideFlags,
  HideOnStart,
  HingeJoint,
  HorizontalLayoutGroup,
  HostData,
  Image,
  ImageReference,
  ImageReferenceSerializer,
  InheritVelocityModule,
  Input,
  InputEventQueue,
  InputEvents,
  InputField,
  InstanceHandle,
  InstancingHandler,
  InstancingUtil,
  InstantiateEvent,
  InstantiateIdProvider,
  InstantiateOptions,
  Interactable,
  InternalScreenshotUtils,
  JoinedRoomResponse,
  KeyEventArgs,
  Keyframe,
  LODGroup,
  LODModel,
  LeftRoomResponse,
  Light,
  LightData,
  LimitVelocityOverLifetimeModule,
  LoadingElementOptions,
  LogStats,
  LogType,
  LookAt,
  LookAtConstraint,
  MainModule,
  MarkerType,
  MaskableGraphic,
  Mathf,
  MeshCollider,
  MeshRenderer,
  MinMaxCurve,
  MinMaxGradient,
  NEEDLE_progressive,
  NEKeyboardEvent,
  NEPointerEvent,
  NeedleEngineHTMLElement,
  NeedleLoader,
  NeedleMenu,
  NeedlePatchesKey,
  NeedleXRController,
  NeedleXRSession,
  NeedleXRSync,
  NeedleXRUtils,
  NestedGltf,
  NetworkConnection,
  NetworkedStreamEvents,
  NetworkedStreams,
  Networking,
  NewInstanceModel,
  NoiseModule,
  ObjectRaycaster,
  ObjectUtils,
  OffsetConstraint,
  OneEuroFilter,
  OneEuroFilterXYZ,
  OpenURL,
  OrbitControls,
  OrbitControls2,
  Outline,
  OwnershipEvent,
  OwnershipModel,
  PUBLIC_KEY,
  Padding,
  ParticleBurst,
  ParticleSubEmitter,
  ParticleSystem,
  ParticleSystemBaseBehaviour,
  ParticleSystemRenderer,
  ParticleSystemShapeType,
  PeerHandle,
  PeerNetworking,
  Physics,
  PhysicsExtension,
  PhysicsMaterialCombine,
  PixelationEffect,
  PlayAnimationOnClick,
  PlayAudioOnClick,
  PlayableDirector,
  PlayerColor,
  PlayerState,
  PlayerStateEvent,
  PlayerSync,
  PlayerView,
  PlayerViewManager,
  PointerEventData,
  PointerType,
  PostProcessingEffect,
  PostProcessingHandler,
  PreliminaryAction,
  PreliminaryTrigger,
  PreviewHelper,
  PrimitiveType,
  Progress,
  PromiseAllWithErrors,
  PromiseErrorResult,
  RGBAColor,
  RawImage,
  RaycastOptions,
  Rect,
  RectTransform,
  ReflectionProbe,
  RegisteredAnimationInfo,
  RemoteSkybox,
  RenderTexture,
  RenderTextureSerializer,
  Renderer,
  RendererData,
  RendererLightmap,
  Rigidbody,
  RigidbodyConstraints,
  RoomEvents,
  RotationBySpeedModule,
  RotationOverLifetimeModule,
  SceneLightSettings,
  SceneSwitcher,
  ScreenCapture,
  ScreenSpaceAmbientOcclusion,
  ScreenSpaceAmbientOcclusionN8,
  SendQueue,
  SerializationContext,
  SetActiveOnClick,
  ShadowCatcher,
  ShapeModule,
  SharpeningEffect,
  SignalAsset,
  SignalReceiver,
  SignalReceiverEvent,
  SignalTrackHandler,
  Size,
  SizeBySpeedModule,
  SizeOverLifetimeModule,
  SkinnedMeshRenderer,
  SmoothFollow,
  SpatialGrabRaycaster,
  SpatialHtml,
  SpatialTrigger,
  SpatialTriggerReceiver,
  SpectatorCamera,
  SphereCollider,
  SphereIntersection,
  SphereOverlapResult,
  Sprite,
  SpriteData,
  SpriteRenderer,
  SpriteSheet,
  StateMachineBehaviour,
  StreamEndedEvent,
  StreamReceivedEvent,
  SubEmitterSystem,
  SyncedCamera,
  SyncedRoom,
  SyncedTransform,
  TapGestureTrigger,
  TeleportTarget,
  TestRunner,
  TestSimulateUserData,
  Text,
  TextBuilder,
  TextExtension,
  TextureSheetAnimationModule,
  TiltShiftEffect,
  Time,
  ToneMappingEffect,
  TrackHandler,
  TrackType,
  TrailModule,
  TransformData,
  TransformGizmo,
  TriggerBuilder,
  TriggerModel,
  TypeStore,
  UIRaycastUtils,
  UIRootComponent,
  USDDocument,
  USDObject,
  USDWriter,
  USDZExporter,
  USDZExporter2,
  USDZText,
  USDZUIExtension,
  UriSerializer,
  UsageMarker,
  UserJoinedOrLeftRoomModel,
  VERSION,
  VariantAction,
  VelocityOverLifetimeModule,
  VerticalLayoutGroup,
  VideoPlayer,
  ViewDevice,
  Vignette,
  VisibilityAction,
  Voip,
  Volume,
  VolumeParameter,
  VolumeProfile,
  WaitForFrames,
  WaitForPromise,
  WaitForSeconds,
  Watch,
  WebARCameraBackground,
  WebARSessionRoot,
  WebXR,
  WebXRButtonFactory,
  WebXRImageTracking,
  WebXRImageTrackingModel,
  WebXRPlaneTracking,
  WebXRTrackedImage,
  XRControllerFollow,
  XRControllerModel,
  XRControllerMovement,
  XRFlag,
  XRRig,
  XRState,
  XRStateFlag,
  __Ignore,
  __internalNotifyObjectDestroyed,
  activeInHierarchyFieldName,
  addAttributeChangeCallback,
  addComponent,
  addCustomExtensionPlugin,
  addGltfLoadEventListener,
  addLog,
  addNewComponent,
  addPatch,
  addScriptToArrays,
  apply,
  applyPrototypeExtensions,
  beginListenDestroy,
  beginListenInstantiate,
  binaryIdentifierCasts,
  build_scene_functions,
  builtinComponentKeyName,
  calculateProgress01,
  clearMessages,
  colorSerializer,
  compareAssociation,
  componentSerializer,
  components_exports,
  copyTexture,
  createFlatTexture,
  createLoader,
  createMotion,
  debugNet,
  debugOwner,
  deepClone,
  delay,
  delayForFrames,
  deserializeObject,
  destroy,
  destroyComponentInstance,
  disposeObjectResources,
  disposeStream,
  editorGuidKeyName,
  effectsOrder,
  enableSpatialConsole,
  euler,
  eventListSerializer,
  findByGuid,
  findObjectOfType,
  findObjectsOfType,
  findResourceUsers,
  fitObjectIntoVolume,
  foreachComponent,
  foreachComponentEnumerator,
  forward,
  generateQRCode,
  generateSeed,
  getBoundingBox,
  getCameraController,
  getComponent,
  getComponentInChildren,
  getComponentInParent,
  getComponents,
  getComponentsInChildren,
  getComponentsInParent,
  getFormattedDate,
  getIconElement,
  getIconTexture,
  getIp,
  getIpAndLocation,
  getIpCloudflare,
  getLoader,
  getOrAddComponent,
  getParam,
  getParentHierarchyPath,
  getPath,
  getPeerOptions,
  getPeerjsInstance,
  getResourceUserCount,
  getTempColor,
  getTempQuaternion,
  getTempVector,
  getUrlParams,
  getVisibleInCustomShadowRendering,
  getWorldDirection,
  getWorldEuler,
  getWorldPosition,
  getWorldQuaternion,
  getWorldRotation,
  getWorldScale,
  hasCommercialLicense,
  hasIndieLicense,
  hasPointerEventComponent,
  hasProLicense,
  hideDebugConsole,
  iconFontUrl,
  imageToCanvas,
  instantiate,
  invokeAfterImportPluginHooks,
  invokeXRSessionEnd,
  invokeXRSessionStart,
  isActiveInHierarchy,
  isActiveSelf,
  isAndroidDevice,
  isAnimationAction,
  isComponent,
  isDebugMode,
  isDesktop,
  isDestroyed,
  isDevEnvironment,
  isDisposed,
  isHostedOnGlitch,
  isIPad,
  isIconElement,
  isLocalNetwork,
  isMacOS,
  isMobileDevice,
  isMozillaXR,
  isQuest,
  isResourceTrackingEnabled,
  isSafari,
  isUsingInstancing,
  isiOS,
  isiPad,
  loadFont,
  loadSync,
  logHierarchy,
  lookAtInverse,
  lookAtObject,
  makeId,
  makeIdFromRandomWords,
  makeNameSafe,
  markAsInstancedRendered,
  mergeVertices,
  microphonePermissionsGranted,
  nameof,
  nameofFactory,
  objectSerializer,
  offXRSessionEnd,
  offXRSessionStart,
  onAfterRender,
  onBeforeRender,
  onClear,
  onDestroy,
  onInitialized,
  onStart,
  onUpdate,
  onXRSessionEnd,
  onXRSessionStart,
  parseSync,
  placeOnSurface,
  postprocessFBXMaterials,
  prefix,
  pushState,
  randomNumber,
  registerBinaryType,
  registerComponent,
  registerComponentExtension,
  registerCustomEffectType,
  registerExportExtensions,
  registerExtensions,
  registerLoader,
  registerPrefabProvider,
  registerPrototypeExtensions,
  registerType,
  relativePathPrefix,
  removeAttributeChangeCallback,
  removeComponent,
  removeCustomImportExtensionType,
  removeGltfLoadEventListener,
  removePatch,
  removeScriptFromContext,
  resolveUrl,
  sanitizeString,
  saveImage,
  screenshot,
  screenshot2,
  sendDestroyed,
  serializable,
  serializeObject,
  serializeable,
  setActive,
  setAllowBalloonMessages,
  setAllowOverlayMessages,
  setAutoFitEnabled,
  setCameraController,
  setDestroyed,
  setDevEnvironment,
  setDisposable,
  setDontDestroy,
  setOrAddParamsToUrl,
  setParam,
  setParamWithoutReload,
  setPeerOptions,
  setResourceTrackingEnabled,
  setState,
  setVisibleInCustomShadowRendering,
  setWorldEuler,
  setWorldPosition,
  setWorldPositionXYZ,
  setWorldQuaternion,
  setWorldQuaternionXYZW,
  setWorldRotation,
  setWorldRotationXYZ,
  setWorldScale,
  showBalloonError,
  showBalloonMessage,
  showBalloonWarning,
  showDebugConsole,
  slerp,
  syncDestroy,
  syncField,
  syncInstantiate,
  textureToCanvas,
  tryCastBinary,
  tryDetermineFileTypeFromBinary,
  tryDetermineFileTypeFromURL,
  tryFindObject,
  tryGetGuid,
  unwatchWrite,
  useForAutoFit,
  validate,
  watchWrite
} from "./chunk-CZCIBHHP.js";
import {
  AI,
  EI,
  Mg,
  Rg,
  ag,
  cI,
  gI,
  oI,
  sg,
  uI,
  vA,
  wI,
  xI
} from "./chunk-SKW7VZKG.js";
import "./chunk-GTWKTLO2.js";
import "./chunk-EPW5EEUB.js";
import "./chunk-DFYYBEIV.js";
import {
  AudioContext,
  BufferAttribute,
  BufferGeometry,
  EquirectangularReflectionMapping,
  InterleavedBufferAttribute,
  LineBasicMaterial,
  LineSegments,
  Matrix4,
  Object3D,
  PerspectiveCamera,
  Quaternion,
  Scene,
  Vector3,
  three_module_exports
} from "./chunk-3GUWUI4A.js";
import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField
} from "./chunk-4RACSZOF.js";

// node_modules/@needle-tools/engine/lib/engine/engine_audio.js
function ensureAudioContextIsResumed() {
  Application.registerWaitForInteraction(() => {
    const ctx = AudioContext.getContext();
    ctx.addEventListener("statechange", () => {
      setTimeout(() => {
        const state = ctx.state;
        if (state === "suspended" || state === "interrupted") {
          ctx.resume().then(() => {
            console.log("AudioContext resumed successfully");
          }).catch((e) => {
            console.log("Failed to resume AudioContext: " + e);
          });
        }
      }, 500);
    });
  });
}
setTimeout(ensureAudioContextIsResumed, 1e3);

// node_modules/@needle-tools/engine/lib/engine/engine_hot_reload.js
var debug = getParam("debughotreload");
if (import.meta.hot) {
  import.meta.hot.on("vite:beforeUpdate", (cb) => {
    if (debug)
      console.log(cb);
    for (const update of cb.updates) {
      console.log("[Needle Engine] Hot reloading " + update.path);
    }
  });
}
var isApplyingChanges = false;
var instances = /* @__PURE__ */ new Map();
function isHotReloading() {
  return isApplyingChanges;
}
function registerHotReloadType(instance) {
  var _a;
  if (isApplyingChanges)
    return;
  const type = instance.constructor;
  const name = type.name;
  if (!instances.has(name)) {
    instances.set(name, [instance]);
  } else {
    (_a = instances.get(name)) == null ? void 0 : _a.push(instance);
  }
}
function unregisterHotReloadType(instance) {
  if (isApplyingChanges)
    return;
  const type = instance.constructor;
  const name = type.name;
  const instancesOfType = instances.get(name);
  if (!instancesOfType)
    return;
  const idx = instancesOfType.indexOf(instance);
  if (idx === -1)
    return;
  instancesOfType.splice(idx, 1);
}
var didRegisterUnhandledExceptionListener = false;
function reloadPageOnHotReloadError() {
  if (debug)
    return;
  if (didRegisterUnhandledExceptionListener)
    return;
  didRegisterUnhandledExceptionListener = true;
  const error = console.error;
  console.error = (...args) => {
    if (args.length) {
      const arg = args[0];
      if (typeof arg === "string" && arg.includes("[hmr] Failed to reload ")) {
        console.log("[Needle Engine] Hot reloading failed");
        window.location.reload();
        return;
      }
    }
    error.apply(console, args);
  };
}
function applyHMRChanges(newModule) {
  if (debug)
    console.log("[HMR] Apply changes", newModule, Object.keys(newModule));
  reloadPageOnHotReloadError();
  for (const key of Object.keys(newModule)) {
    try {
      isApplyingChanges = true;
      const typeToUpdate = TypeStore.get(key);
      if (!typeToUpdate) {
        if (debug)
          console.log("[HMR] Type not found: " + key);
        continue;
      }
      const newType = newModule[key];
      const instancesOfType = instances.get(newType.name);
      let hotReloadMessage = "[Needle Engine] Updating type: " + key;
      const typesCount = (instancesOfType == null ? void 0 : instancesOfType.length) ?? -1;
      if (typesCount > 0)
        hotReloadMessage += " x" + typesCount;
      else
        hotReloadMessage += " - no instances";
      console.log(hotReloadMessage);
      const previousMethods = Object.getOwnPropertyNames(typeToUpdate.prototype);
      const methodsAndProperties = Object.getOwnPropertyDescriptors(newType.prototype);
      for (const typeKey in methodsAndProperties) {
        const desc = methodsAndProperties[typeKey];
        if (!desc.writable)
          continue;
        typeToUpdate.prototype[typeKey] = newModule[key].prototype[typeKey];
      }
      for (const typeKey of previousMethods) {
        if (!methodsAndProperties[typeKey]) {
          delete typeToUpdate.prototype[typeKey];
        }
      }
      if (instancesOfType) {
        const newTypeInstance = new newType();
        const keys = Object.getOwnPropertyDescriptors(newTypeInstance);
        for (const inst of instancesOfType) {
          const componentInstance = inst;
          const isComponent2 = componentInstance.isComponent === true;
          const active = isComponent2 ? componentInstance.activeAndEnabled : true;
          const context = isComponent2 ? componentInstance.context : void 0;
          try {
            if (isComponent2 && context) {
              removeScriptFromContext(componentInstance, context);
            }
            if (isComponent2 && active) {
              componentInstance.enabled = false;
            }
            if (inst["onBeforeHotReloadFields"]) {
              const res = inst["onBeforeHotReloadFields"]();
              if (res === false)
                continue;
            }
            for (const key2 in keys) {
              const desc = keys[key2];
              if (!desc.writable)
                continue;
              if (inst[key2] === void 0) {
                inst[key2] = newTypeInstance[key2];
              } else if (typeof inst[key2] === "function" && !inst[key2].prototype) {
                const boundMethod = inst[key2];
                const targetMethodName = boundMethod.name;
                const prefix2 = "bound ";
                if (targetMethodName === prefix2)
                  continue;
                const name = boundMethod.name.substring(prefix2.length);
                const newTarget = newType.prototype[name];
                if (newTarget)
                  inst[key2] = newTarget.bind(inst);
              }
            }
            if (inst["onAfterHotReloadFields"])
              inst["onAfterHotReloadFields"]();
          } finally {
            if (isComponent2 && context) {
              addScriptToArrays(componentInstance, context);
            }
            if (isComponent2 && active) {
              componentInstance.enabled = true;
            }
          }
        }
      }
    } catch (err) {
      if (debug)
        console.error(err);
      else
        return false;
    } finally {
      isApplyingChanges = false;
      addLog(LogType.Log, "Script changes applied (HMR)");
    }
  }
  return true;
}

// node_modules/@needle-tools/engine/lib/engine/engine_physics_rapier.js
var debugPhysics = getParam("debugphysics");
var debugColliderPlacement = getParam("debugcolliderplacement");
var debugCollisions = getParam("debugcollisions");
var showColliders = getParam("showcolliders");
var showPhysicsRaycasts = getParam("debugraycasts");
var $componentKey = Symbol("needle component");
var $bodyKey = Symbol("physics body");
var $colliderRigidbody = Symbol("rigidbody");
var RAPIER = void 0;
globalThis["NEEDLE_USE_RAPIER"] = globalThis["NEEDLE_USE_RAPIER"] !== void 0 ? globalThis["NEEDLE_USE_RAPIER"] : true;
if (debugPhysics)
  console.log("Use Rapier", NEEDLE_USE_RAPIER, globalThis["NEEDLE_USE_RAPIER"]);
if (NEEDLE_USE_RAPIER) {
  ContextRegistry.registerCallback(ContextEvent.ContextCreationStart, (evt) => {
    if (debugPhysics)
      console.log("Register rapier physics backend");
    evt.context.physics.engine = new RapierPhysics();
    if (NEEDLE_USE_RAPIER) {
      evt.context.physics.engine.initialize(evt.context);
    }
  });
}
var _RapierPhysics = class {
  constructor() {
    __publicField(this, "debugRenderColliders", false);
    __publicField(this, "debugRenderRaycasts", false);
    __publicField(this, "context");
    __publicField(this, "_initializePromise");
    __publicField(this, "_isInitialized", false);
    __publicField(this, "rapierRay", new xI({ x: 0, y: 0, z: 0 }, { x: 0, y: 0, z: 1 }));
    __publicField(this, "raycastVectorsBuffer", new CircularBuffer(() => new Vector3(), 10));
    __publicField(this, "rapierSphere", null);
    __publicField(this, "rapierColliderArray", []);
    __publicField(this, "rapierIdentityRotation", { x: 0, y: 0, z: 0, w: 1 });
    __publicField(this, "rapierForwardVector", { x: 0, y: 0, z: 1 });
    // physics simulation
    __publicField(this, "enabled", false);
    __publicField(this, "_tempPosition", new Vector3());
    __publicField(this, "_tempQuaternion", new Quaternion());
    __publicField(this, "_tempScale", new Vector3());
    __publicField(this, "_tempMatrix", new Matrix4());
    __publicField(this, "_isUpdatingPhysicsWorld", false);
    __publicField(this, "_world");
    __publicField(this, "_hasCreatedWorld", false);
    __publicField(this, "eventQueue");
    __publicField(this, "collisionHandler");
    __publicField(this, "objects", []);
    __publicField(this, "bodies", []);
    __publicField(this, "_meshCache", /* @__PURE__ */ new Map());
    __publicField(this, "_gravity", { x: 0, y: -9.81, z: 0 });
    // private _lastStepTime: number | undefined = 0;
    __publicField(this, "lines");
    __publicField(this, "_tempCenterPos", new Vector3());
    __publicField(this, "_tempCenterVec", new Vector3());
    __publicField(this, "_tempCenterQuaternion", new Quaternion());
  }
  removeBody(obj) {
    var _a, _b, _c;
    if (!obj)
      return;
    this.validate();
    const body = obj[$bodyKey];
    obj[$bodyKey] = null;
    if (body && this.world) {
      const index = this.objects.findIndex((o) => o === obj);
      if (index >= 0) {
        const rapierBody = this.bodies[index];
        this.bodies.splice(index, 1);
        this.objects.splice(index, 1);
        if (rapierBody instanceof sg) {
          const rapierCollider = rapierBody;
          (_a = this.world) == null ? void 0 : _a.removeCollider(rapierCollider, true);
          const rapierRigidbody = rapierCollider.parent();
          if (rapierRigidbody && rapierRigidbody.numColliders() <= 0) {
            const rigidbody = rapierRigidbody[$componentKey];
            if (rigidbody) {
            } else {
              (_b = this.world) == null ? void 0 : _b.removeRigidBody(rapierRigidbody);
            }
          }
        } else if (rapierBody instanceof wI) {
          if (rapierBody.numColliders() <= 0) {
            (_c = this.world) == null ? void 0 : _c.removeRigidBody(rapierBody);
          } else {
            if (isDevEnvironment()) {
              if (!rapierBody["did_log_removing"]) {
                setTimeout(() => {
                  if (rapierBody.numColliders() > 0) {
                    rapierBody["did_log_removing"] = true;
                    console.warn("RapierPhysics: removing rigidbody with colliders from the physics world is not possible right now, please remove the colliders first");
                  }
                }, 1);
              }
            }
          }
        }
      }
    }
  }
  updateBody(comp, translation, rotation) {
    this.validate();
    if (!this.enabled)
      return;
    if (comp.destroyed || !comp.gameObject)
      return;
    if (!translation && !rotation)
      return;
    if (comp.isCollider === true) {
      console.warn("TODO: implement updating collider position");
    } else {
      const rigidbody = comp;
      const body = rigidbody[$bodyKey];
      if (body) {
        this.syncPhysicsBody(rigidbody.gameObject, body, translation, rotation);
      }
    }
  }
  updateProperties(obj) {
    this.validate();
    if (obj.isCollider) {
      const col = obj;
      const body = col[$bodyKey];
      if (body) {
        this.internalUpdateColliderProperties(col, body);
        if (col.sharedMaterial)
          this.updatePhysicsMaterial(col);
      }
    } else {
      const rb = obj;
      const physicsBody = this.internal_getRigidbody(rb);
      if (physicsBody) {
        this.internalUpdateRigidbodyProperties(rb, physicsBody);
      }
    }
  }
  addForce(rigidbody, force, wakeup) {
    this.validate();
    const body = this.internal_getRigidbody(rigidbody);
    if (body)
      body.addForce(force, wakeup);
    else
      console.warn("Rigidbody doesn't exist: can not apply force (does your object with the Rigidbody have a collider?)");
  }
  addImpulse(rigidbody, force, wakeup) {
    this.validate();
    const body = this.internal_getRigidbody(rigidbody);
    if (body)
      body.applyImpulse(force, wakeup);
    else
      console.warn("Rigidbody doesn't exist: can not apply impulse (does your object with the Rigidbody have a collider?)");
  }
  getLinearVelocity(comp) {
    this.validate();
    const body = this.internal_getRigidbody(comp);
    if (body) {
      const vel = body.linvel();
      return vel;
    }
    return null;
  }
  getAngularVelocity(rb) {
    this.validate();
    const body = this.internal_getRigidbody(rb);
    if (body) {
      const vel = body.angvel();
      return vel;
    }
    return null;
  }
  resetForces(rb, wakeup) {
    this.validate();
    const body = this.internal_getRigidbody(rb);
    body == null ? void 0 : body.resetForces(wakeup);
  }
  resetTorques(rb, wakeup) {
    this.validate();
    const body = this.internal_getRigidbody(rb);
    body == null ? void 0 : body.resetTorques(wakeup);
  }
  applyImpulse(rb, vec, wakeup) {
    this.validate();
    const body = this.internal_getRigidbody(rb);
    if (body)
      body.applyImpulse(vec, wakeup);
    else
      console.warn("Rigidbody doesn't exist: can not apply impulse (does your object with the Rigidbody have a collider?)");
  }
  wakeup(rb) {
    this.validate();
    const body = this.internal_getRigidbody(rb);
    if (body)
      body.wakeUp();
    else
      console.warn("Rigidbody doesn't exist: can not wake up (does your object with the Rigidbody have a collider?)");
  }
  isSleeping(rb) {
    this.validate();
    const body = this.internal_getRigidbody(rb);
    return body == null ? void 0 : body.isSleeping();
  }
  setAngularVelocity(rb, vec, wakeup) {
    this.validate();
    const body = this.internal_getRigidbody(rb);
    if (body)
      body.setAngvel(vec, wakeup);
    else
      console.warn("Rigidbody doesn't exist: can not set angular velocity (does your object with the Rigidbody have a collider?)");
  }
  setLinearVelocity(rb, vec, wakeup) {
    this.validate();
    const body = this.internal_getRigidbody(rb);
    if (body)
      body.setLinvel(vec, wakeup);
    else
      console.warn("Rigidbody doesn't exist: can not set linear velocity (does your object with the Rigidbody have a collider?)");
  }
  async initialize(context) {
    this.context = context;
    if (!this._initializePromise)
      this._initializePromise = this.internalInitialization();
    return this._initializePromise;
  }
  async internalInitialization() {
    if (debugPhysics)
      console.log("Initialize rapier physics engine");
    if ("env" in import.meta && import.meta.env.VITE_NEEDLE_USE_RAPIER === "false") {
      if (debugPhysics)
        console.log("Rapier disabled");
      return false;
    }
    if (!NEEDLE_USE_RAPIER)
      return false;
    if (this._hasCreatedWorld) {
      console.error("Invalid call to create physics world: world is already created");
      return true;
    }
    this._hasCreatedWorld = true;
    if (RAPIER === void 0) {
      if (debugPhysics)
        console.log("Import Rapier");
      const _rapier = await import("./rapier.es-H55EMKSA.js");
      if (debugPhysics)
        console.log("Init Rapier");
      await _rapier.init();
      RAPIER = _rapier;
    }
    if (debugPhysics)
      console.log("Physics engine initialized, creating world...");
    this._world = new Mg(this._gravity);
    this.enabled = true;
    this._isInitialized = true;
    if (debugPhysics)
      console.log("Physics world created");
    return true;
  }
  /** Check is the physics engine has been initialized and the call can be made */
  validate() {
    if (!this._isInitialized) {
      if (debugPhysics) {
        this["_lastWarnTime"] = this["_lastWarnTime"] ?? 0;
        if (Date.now() - this["_lastWarnTime"] > 1e3) {
          this["_lastWarnTime"] = Date.now();
          console.warn("Physics engine is not initialized");
        }
      }
    }
  }
  raycast(origin, direction, options) {
    var _a;
    let maxDistance = options == null ? void 0 : options.maxDistance;
    let solid = options == null ? void 0 : options.solid;
    if (maxDistance === void 0)
      maxDistance = Infinity;
    if (solid === void 0)
      solid = true;
    const ray = this.getPhysicsRay(this.rapierRay, origin, direction);
    if (!ray)
      return null;
    if (this.debugRenderRaycasts || showPhysicsRaycasts)
      Gizmos.DrawRay(ray.origin, ray.dir, 255, 1);
    const hit = (_a = this.world) == null ? void 0 : _a.castRay(ray, maxDistance, solid, options == null ? void 0 : options.queryFilterFlags, options == null ? void 0 : options.filterGroups, void 0, void 0, (c) => {
      const component = c[$componentKey];
      if (options == null ? void 0 : options.filterPredicate)
        return options.filterPredicate(component);
      if ((options == null ? void 0 : options.useIgnoreRaycastLayer) !== false) {
        return !(component == null ? void 0 : component.gameObject.layers.isEnabled(2));
      }
      return true;
    });
    if (hit) {
      const point = ray.pointAt(hit.timeOfImpact);
      const vec = this.raycastVectorsBuffer.get();
      vec.set(point.x, point.y, point.z);
      return { point: vec, collider: hit.collider[$componentKey] };
    }
    return null;
  }
  raycastAndGetNormal(origin, direction, options) {
    var _a;
    let maxDistance = options == null ? void 0 : options.maxDistance;
    let solid = options == null ? void 0 : options.solid;
    if (maxDistance === void 0)
      maxDistance = Infinity;
    if (solid === void 0)
      solid = true;
    const ray = this.getPhysicsRay(this.rapierRay, origin, direction);
    if (!ray)
      return null;
    if (this.debugRenderRaycasts || showPhysicsRaycasts)
      Gizmos.DrawRay(ray.origin, ray.dir, 255, 1);
    const hit = (_a = this.world) == null ? void 0 : _a.castRayAndGetNormal(ray, maxDistance, solid, options == null ? void 0 : options.queryFilterFlags, options == null ? void 0 : options.filterGroups, void 0, void 0, (c) => {
      const component = c[$componentKey];
      if (options == null ? void 0 : options.filterPredicate)
        return options.filterPredicate(component);
      if ((options == null ? void 0 : options.useIgnoreRaycastLayer) !== false) {
        return !(component == null ? void 0 : component.gameObject.layers.isEnabled(2));
      }
      return true;
    });
    if (hit) {
      const point = ray.pointAt(hit.timeOfImpact);
      const normal = hit.normal;
      const vec = this.raycastVectorsBuffer.get();
      const nor = this.raycastVectorsBuffer.get();
      vec.set(point.x, point.y, point.z);
      nor.set(normal.x, normal.y, normal.z);
      return { point: vec, normal: nor, collider: hit.collider[$componentKey] };
    }
    return null;
  }
  getPhysicsRay(ray, origin, direction) {
    var _a, _b, _c;
    const cam = (_a = this.context) == null ? void 0 : _a.mainCamera;
    if (origin === void 0) {
      const pos = (_b = this.context) == null ? void 0 : _b.input.getPointerPosition(0);
      if (pos)
        origin = pos;
      else
        return null;
    }
    if (origin["z"] === void 0) {
      if (!cam) {
        console.error("Can not perform raycast from 2d point - no main camera found");
        return null;
      }
      const vec3 = this.raycastVectorsBuffer.get();
      vec3.x = origin.x;
      vec3.y = origin.y;
      vec3.z = 0;
      if (vec3.x > 1 || vec3.y > 1 || vec3.y < -1 || vec3.x < -1) {
        if (debugPhysics)
          console.warn("Converting screenspace to raycast space", vec3);
        (_c = this.context) == null ? void 0 : _c.input.convertScreenspaceToRaycastSpace(vec3);
      }
      vec3.unproject(cam);
      origin = vec3;
    }
    const o = origin;
    ray.origin.x = o.x;
    ray.origin.y = o.y;
    ray.origin.z = o.z;
    const vec = this.raycastVectorsBuffer.get();
    if (direction)
      vec.set(direction.x, direction.y, direction.z);
    else {
      if (!cam) {
        console.error("Can not perform raycast - no camera found");
        return null;
      }
      vec.set(ray.origin.x, ray.origin.y, ray.origin.z);
      const camPosition = getWorldPosition(cam);
      vec.sub(camPosition);
    }
    vec.normalize();
    ray.dir.x = vec.x;
    ray.dir.y = vec.y;
    ray.dir.z = vec.z;
    return ray;
  }
  /** Precice sphere overlap detection using rapier against colliders
   * @param point center of the sphere in worldspace
   * @param radius radius of the sphere
   * @returns array of colliders that overlap with the sphere. Note: they currently only contain the collider and the gameobject
   */
  sphereOverlap(point, radius) {
    this.rapierColliderArray.length = 0;
    if (!this.world)
      return this.rapierColliderArray;
    if (!this.rapierSphere)
      this.rapierSphere = new uI(radius);
    this.rapierSphere.radius = radius;
    if (this.debugRenderRaycasts || showPhysicsRaycasts)
      Gizmos.DrawWireSphere(point, radius, 3359999, 1);
    this.world.intersectionsWithShape(
      point,
      this.rapierIdentityRotation,
      this.rapierSphere,
      (col) => {
        const collider = col[$componentKey];
        const intersection = new SphereOverlapResult(collider.gameObject, collider);
        this.rapierColliderArray.push(intersection);
        return true;
      },
      // TODO: it seems as QueryFilterFlags.EXCLUDE_SENSORS also excludes DYNAMIC Rigidbodies (only if they're set to kinematic)
      void 0,
      // QueryFilterFlags.EXCLUDE_SENSORS, 
      void 0,
      void 0,
      void 0,
      (col) => {
        if (col.isSensor())
          return false;
        const collider = col[$componentKey];
        return collider.gameObject.layers.isEnabled(2) == false;
      }
    );
    return this.rapierColliderArray;
  }
  /** Get access to the rapier world */
  get world() {
    return this._world;
  }
  get isUpdating() {
    return this._isUpdatingPhysicsWorld;
  }
  get gravity() {
    var _a;
    return ((_a = this.world) == null ? void 0 : _a.gravity) ?? this._gravity;
  }
  set gravity(value) {
    if (this.world) {
      this.world.gravity = value;
    } else {
      this._gravity = value;
    }
  }
  clearCaches() {
    var _a, _b, _c, _d;
    this._meshCache.clear();
    if ((_a = this.eventQueue) == null ? void 0 : _a.raw)
      (_b = this.eventQueue) == null ? void 0 : _b.free();
    if ((_c = this.world) == null ? void 0 : _c.bodies)
      (_d = this.world) == null ? void 0 : _d.free();
  }
  async addBoxCollider(collider, size) {
    if (!this._isInitialized)
      await this.initialize(collider.context);
    if (!collider.activeAndEnabled)
      return;
    if (!this.enabled) {
      if (debugPhysics)
        console.warn("Physics are disabled");
      return;
    }
    const obj = collider.gameObject;
    const scale = getWorldScale(obj, this._tempPosition).multiply(size);
    scale.multiplyScalar(0.5);
    if (scale.x < 0)
      scale.x = Math.abs(scale.x);
    if (scale.y < 0)
      scale.y = Math.abs(scale.y);
    if (scale.z < 0)
      scale.z = Math.abs(scale.z);
    if (scale.x == 0)
      scale.x = 1e-7;
    if (scale.y == 0)
      scale.y = 1e-7;
    if (scale.z == 0)
      scale.z = 1e-7;
    const desc = Rg.cuboid(scale.x, scale.y, scale.z);
    this.createCollider(collider, desc);
  }
  async addSphereCollider(collider) {
    if (!this._isInitialized)
      await this.initialize(collider.context);
    if (!collider.activeAndEnabled)
      return;
    if (!this.enabled) {
      if (debugPhysics)
        console.warn("Physics are disabled");
      return;
    }
    const desc = Rg.ball(0.5);
    this.createCollider(collider, desc);
    this.updateProperties(collider);
  }
  async addCapsuleCollider(collider, height, radius) {
    if (!this._isInitialized)
      await this.initialize(collider.context);
    if (!collider.activeAndEnabled)
      return;
    if (!this.enabled) {
      if (debugPhysics)
        console.warn("Physics are disabled");
      return;
    }
    const obj = collider.gameObject;
    const scale = getWorldScale(obj, this._tempPosition);
    scale.x = Math.abs(scale.x);
    scale.y = Math.abs(scale.y);
    const finalRadius = radius * scale.x;
    height = Math.max(height, finalRadius * 2);
    const hh = Mathf.clamp(height * 0.5 * scale.y - radius * scale.x, 0, Number.MAX_SAFE_INTEGER);
    const desc = Rg.capsule(hh, finalRadius);
    this.createCollider(collider, desc);
  }
  async addMeshCollider(collider, mesh, convex, scale) {
    var _a, _b, _c;
    if (!this._isInitialized)
      await this.initialize(collider.context);
    if (!collider.activeAndEnabled)
      return;
    if (!this.enabled) {
      if (debugPhysics)
        console.warn("Physics are disabled");
      return;
    }
    let geo = mesh.geometry;
    if (!geo) {
      if (debugPhysics)
        console.warn("Missing mesh geometry", mesh.name);
      return;
    }
    if (!((_b = (_a = geo.index) == null ? void 0 : _a.array) == null ? void 0 : _b.length)) {
      console.warn(`Your MeshCollider is missing vertices or indices in the assined mesh "${mesh.name}". Consider providing an indexed geometry.`);
      geo = mergeVertices(geo);
    }
    let positions = null;
    const positionAttribute = geo.getAttribute("position");
    if (positionAttribute instanceof InterleavedBufferAttribute) {
      const count = positionAttribute.count;
      positions = new Float32Array(count * 3);
      for (let i = 0; i < count; i++) {
        const x = positionAttribute.getX(i);
        const y = positionAttribute.getY(i);
        const z = positionAttribute.getZ(i);
        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;
      }
    } else {
      positions = positionAttribute.array;
    }
    const indices = (_c = geo.index) == null ? void 0 : _c.array;
    if (Math.abs(scale.x - 1) > 1e-4 || Math.abs(scale.y - 1) > 1e-4 || Math.abs(scale.z - 1) > 1e-4) {
      const key = geo.uuid + "_" + scale.x + "_" + scale.y + "_" + scale.z + "_" + convex;
      if (this._meshCache.has(key)) {
        if (debugPhysics)
          console.warn("Use cached mesh collider");
        positions = this._meshCache.get(key);
      } else {
        if (debugPhysics || isDevEnvironment())
          console.warn(`Your MeshCollider "${collider.name}" is scaled: consider applying the scale to the collider mesh instead (${scale.x}, ${scale.y}, ${scale.z})`);
        const scaledPositions = new Float32Array(positions.length);
        for (let i = 0; i < positions.length; i += 3) {
          scaledPositions[i] = positions[i] * scale.x;
          scaledPositions[i + 1] = positions[i + 1] * scale.y;
          scaledPositions[i + 2] = positions[i + 2] * scale.z;
        }
        positions = scaledPositions;
        this._meshCache.set(key, scaledPositions);
      }
    }
    const desc = convex ? Rg.convexHull(positions) : Rg.trimesh(positions, indices);
    if (desc) {
      this.createCollider(collider, desc);
    }
  }
  updatePhysicsMaterial(col) {
    if (!col)
      return;
    const physicsMaterial = col.sharedMaterial;
    const rapier_collider = col[$bodyKey];
    if (!rapier_collider)
      return;
    if (physicsMaterial) {
      if (physicsMaterial.bounciness !== void 0)
        rapier_collider.setRestitution(physicsMaterial.bounciness);
      if (physicsMaterial.bounceCombine !== void 0) {
        switch (physicsMaterial.bounceCombine) {
          case PhysicsMaterialCombine.Average:
            rapier_collider.setRestitutionCombineRule(AI.Average);
            break;
          case PhysicsMaterialCombine.Maximum:
            rapier_collider.setRestitutionCombineRule(AI.Max);
            break;
          case PhysicsMaterialCombine.Minimum:
            rapier_collider.setRestitutionCombineRule(AI.Min);
            break;
          case PhysicsMaterialCombine.Multiply:
            rapier_collider.setRestitutionCombineRule(AI.Multiply);
            break;
        }
      }
      if (physicsMaterial.dynamicFriction !== void 0)
        rapier_collider.setFriction(physicsMaterial.dynamicFriction);
      if (physicsMaterial.frictionCombine !== void 0) {
        switch (physicsMaterial.frictionCombine) {
          case PhysicsMaterialCombine.Average:
            rapier_collider.setFrictionCombineRule(AI.Average);
            break;
          case PhysicsMaterialCombine.Maximum:
            rapier_collider.setFrictionCombineRule(AI.Max);
            break;
          case PhysicsMaterialCombine.Minimum:
            rapier_collider.setFrictionCombineRule(AI.Min);
            break;
          case PhysicsMaterialCombine.Multiply:
            rapier_collider.setFrictionCombineRule(AI.Multiply);
            break;
        }
      }
    }
  }
  /** Get the rapier body for a Needle component */
  getBody(obj) {
    if (!obj)
      return null;
    const body = obj[$bodyKey];
    return body;
  }
  /** Get the Needle Engine component for a rapier object */
  getComponent(rapierObject) {
    if (!rapierObject)
      return null;
    const component = rapierObject[$componentKey];
    return component;
  }
  createCollider(collider, desc) {
    var _a;
    if (!this.world)
      throw new Error("Physics world not initialized");
    const matrix = this._tempMatrix;
    let rigidBody = void 0;
    if (!collider.attachedRigidbody) {
      if (debugPhysics)
        console.log("Create collider without rigidbody", collider.name);
      matrix.makeRotationFromQuaternion(getWorldQuaternion(collider.gameObject));
      matrix.setPosition(getWorldPosition(collider.gameObject));
    } else {
      rigidBody = this.getRigidbody(collider, this._tempMatrix);
    }
    matrix.decompose(this._tempPosition, this._tempQuaternion, this._tempScale);
    this.tryApplyCenter(collider, this._tempPosition);
    desc.setTranslation(this._tempPosition.x, this._tempPosition.y, this._tempPosition.z);
    desc.setRotation(this._tempQuaternion);
    desc.setSensor(collider.isTrigger);
    const physicsMaterial = collider.sharedMaterial;
    if (physicsMaterial) {
      if (physicsMaterial.bounciness !== void 0)
        desc.setRestitution(physicsMaterial.bounciness);
      if (physicsMaterial.bounceCombine !== void 0) {
        switch (physicsMaterial.bounceCombine) {
          case PhysicsMaterialCombine.Average:
            desc.setRestitutionCombineRule(AI.Average);
            break;
          case PhysicsMaterialCombine.Maximum:
            desc.setRestitutionCombineRule(AI.Max);
            break;
          case PhysicsMaterialCombine.Minimum:
            desc.setRestitutionCombineRule(AI.Min);
            break;
          case PhysicsMaterialCombine.Multiply:
            desc.setRestitutionCombineRule(AI.Multiply);
            break;
        }
      }
      if (physicsMaterial.dynamicFriction !== void 0)
        desc.setFriction(physicsMaterial.dynamicFriction);
      if (physicsMaterial.frictionCombine !== void 0) {
        switch (physicsMaterial.frictionCombine) {
          case PhysicsMaterialCombine.Average:
            desc.setFrictionCombineRule(AI.Average);
            break;
          case PhysicsMaterialCombine.Maximum:
            desc.setFrictionCombineRule(AI.Max);
            break;
          case PhysicsMaterialCombine.Minimum:
            desc.setFrictionCombineRule(AI.Min);
            break;
          case PhysicsMaterialCombine.Multiply:
            desc.setFrictionCombineRule(AI.Multiply);
            break;
        }
      }
    }
    if (((_a = collider.attachedRigidbody) == null ? void 0 : _a.autoMass) === false) {
      desc.setDensity(1e-6);
      desc.setMass(1e-6);
    }
    try {
      const col = this.world.createCollider(desc, rigidBody);
      col[$componentKey] = collider;
      collider[$bodyKey] = col;
      col.setActiveEvents(EI.COLLISION_EVENTS);
      col.setActiveCollisionTypes(oI.ALL);
      this.objects.push(collider);
      this.bodies.push(col);
      this.updateColliderCollisionGroups(collider);
      return col;
    } catch (e) {
      console.error('Error creating collider "' + collider.name + '"\nError:', e);
      return null;
    }
  }
  /**
   * Updates the collision groups of a collider.
   *
   * @param collider - The collider to update.
   */
  updateColliderCollisionGroups(collider) {
    const body = collider[$bodyKey];
    const members = collider.membership;
    let memberMask = 0;
    if (members == void 0) {
      memberMask = 65535;
    } else {
      for (let i = 0; i < members.length; i++) {
        const member = members[i];
        if (member > 31)
          console.error(`Rapier only supports 32 layers, layer ${member} is not supported`);
        else
          memberMask |= 1 << Math.floor(member);
      }
    }
    const mask = collider.filter;
    let filterMask = 0;
    if (mask == void 0) {
      filterMask = 65535;
    } else {
      for (let i = 0; i < mask.length; i++) {
        const member = mask[i];
        if (member > 31)
          console.error(`Rapier only supports 32 layers, layer ${member} is not supported`);
        else
          filterMask |= 1 << Math.floor(member);
      }
    }
    body.setCollisionGroups(memberMask << 16 | filterMask);
  }
  getRigidbody(collider, _matrix) {
    if (!this.world)
      throw new Error("Physics world not initialized");
    let rigidBody = null;
    if (collider.attachedRigidbody) {
      const rb = collider.attachedRigidbody;
      rigidBody = rb[$bodyKey];
      if (!rigidBody) {
        const kinematic = rb.isKinematic && !debugColliderPlacement;
        if (debugPhysics)
          console.log("Create rigidbody", kinematic);
        const rigidBodyDesc = kinematic ? RAPIER.RigidBodyDesc.kinematicPositionBased() : RAPIER.RigidBodyDesc.dynamic();
        const pos = getWorldPosition(collider.attachedRigidbody.gameObject);
        rigidBodyDesc.setTranslation(pos.x, pos.y, pos.z);
        rigidBodyDesc.setRotation(getWorldQuaternion(collider.attachedRigidbody.gameObject));
        rigidBodyDesc.centerOfMass = new RAPIER.Vector3(rb.centerOfMass.x, rb.centerOfMass.y, rb.centerOfMass.z);
        rigidBody = this.world.createRigidBody(rigidBodyDesc);
        this.bodies.push(rigidBody);
        this.objects.push(rb);
      }
      rigidBody[$componentKey] = rb;
      rb[$bodyKey] = rigidBody;
      this.internalUpdateRigidbodyProperties(rb, rigidBody);
      this.getRigidbodyRelativeMatrix(collider.gameObject, rb.gameObject, _matrix);
      collider[$colliderRigidbody] = rigidBody;
    } else {
      const rigidBodyDesc = RAPIER.RigidBodyDesc.kinematicPositionBased();
      const pos = getWorldPosition(collider.gameObject);
      rigidBodyDesc.setTranslation(pos.x, pos.y, pos.z);
      rigidBodyDesc.setRotation(getWorldQuaternion(collider.gameObject));
      rigidBody = this.world.createRigidBody(rigidBodyDesc);
      _matrix.identity();
      rigidBody[$componentKey] = null;
    }
    return rigidBody;
  }
  internal_getRigidbody(rb) {
    if (rb.isCollider === true)
      return rb[$colliderRigidbody];
    return rb[$bodyKey];
  }
  internalUpdateColliderProperties(col, collider) {
    const shape = collider.shape;
    let sizeHasChanged = false;
    switch (shape.type) {
      case gI.Ball: {
        const ball = shape;
        const sc2 = col;
        const obj2 = col.gameObject;
        const scale2 = getWorldScale(obj2, this._tempPosition);
        const radius = Math.abs(sc2.radius * scale2.x);
        sizeHasChanged = ball.radius !== radius;
        ball.radius = radius;
        if (sizeHasChanged) {
          collider.setShape(ball);
        }
        break;
      }
      case gI.Cuboid:
        const cuboid = shape;
        const sc = col;
        const obj = col.gameObject;
        const scale = getWorldScale(obj, this._tempPosition);
        const newX = sc.size.x * 0.5 * scale.x;
        const newY = sc.size.y * 0.5 * scale.y;
        const newZ = sc.size.z * 0.5 * scale.z;
        sizeHasChanged = cuboid.halfExtents.x !== newX || cuboid.halfExtents.y !== newY || cuboid.halfExtents.z !== newZ;
        cuboid.halfExtents.x = newX;
        cuboid.halfExtents.y = newY;
        cuboid.halfExtents.z = newZ;
        if (sizeHasChanged) {
          collider.setShape(cuboid);
        }
        break;
    }
    if (sizeHasChanged) {
      const rb = col.attachedRigidbody;
      if (rb == null ? void 0 : rb.autoMass) {
        const ph = this.getBody(rb);
        ph == null ? void 0 : ph.recomputeMassPropertiesFromColliders();
      }
    }
    this.updateColliderCollisionGroups(col);
    if (col.isTrigger !== collider.isSensor())
      collider.setSensor(col.isTrigger);
  }
  internalUpdateRigidbodyProperties(rb, rigidbody) {
    rigidbody.enableCcd(rb.collisionDetectionMode !== CollisionDetectionMode.Discrete);
    rigidbody.setLinearDamping(rb.drag);
    rigidbody.setAngularDamping(rb.angularDrag);
    rigidbody.setGravityScale(rb.useGravity ? rb.gravityScale : 0, true);
    if (rb.dominanceGroup <= 127 && rb.dominanceGroup >= -127)
      rigidbody.setDominanceGroup(Math.floor(rb.dominanceGroup));
    else
      rigidbody.setDominanceGroup(0);
    if (rb.autoMass) {
      rigidbody.setAdditionalMass(0, false);
      for (let i = 0; i < rigidbody.numColliders(); i++) {
        const col = rigidbody.collider(i);
        col.setDensity(1);
      }
      rigidbody.recomputeMassPropertiesFromColliders();
    } else {
      rigidbody.setAdditionalMass(rb.mass, false);
      for (let i = 0; i < rigidbody.numColliders(); i++) {
        const col = rigidbody.collider(i);
        col.setDensity(1e-7);
      }
      rigidbody.recomputeMassPropertiesFromColliders();
    }
    rigidbody.setEnabledRotations(!rb.lockRotationX, !rb.lockRotationY, !rb.lockRotationZ, false);
    rigidbody.setEnabledTranslations(!rb.lockPositionX, !rb.lockPositionY, !rb.lockPositionZ, false);
    if (rb.isKinematic) {
      rigidbody.setBodyType(RAPIER.RigidBodyType.KinematicPositionBased, false);
    } else {
      rigidbody.setBodyType(RAPIER.RigidBodyType.Dynamic, false);
    }
  }
  step(dt) {
    if (!this.world)
      return;
    if (!this.enabled)
      return;
    this._isUpdatingPhysicsWorld = true;
    if (!this.eventQueue) {
      this.eventQueue = new ag(false);
    }
    if (dt === void 0 || dt <= 0) {
      this._isUpdatingPhysicsWorld = false;
      return;
    } else if (dt !== void 0) {
      this.world.timestep = Mathf.lerp(this.world.timestep, dt, 0.8);
    }
    try {
      this.world.step(this.eventQueue);
    } catch (e) {
      console.warn("Error running physics step", e);
    }
    this._isUpdatingPhysicsWorld = false;
  }
  postStep() {
    if (!this.world)
      return;
    if (!this.enabled)
      return;
    this._isUpdatingPhysicsWorld = true;
    this.syncObjects();
    this._isUpdatingPhysicsWorld = false;
    if (this.eventQueue && !this.collisionHandler) {
      this.collisionHandler = new PhysicsCollisionHandler(this.world, this.eventQueue);
    }
    if (this.collisionHandler) {
      this.collisionHandler.handleCollisionEvents();
      this.collisionHandler.update();
    }
    this.updateDebugRendering(this.world);
  }
  updateDebugRendering(world) {
    var _a, _b, _c, _d;
    if (debugPhysics || debugColliderPlacement || showColliders || this.debugRenderColliders === true) {
      if (!this.lines) {
        const material = new LineBasicMaterial({
          color: 7855479,
          fog: false
          // vertexColors: VertexColors
        });
        const geometry = new BufferGeometry();
        this.lines = new LineSegments(geometry, material);
        this.lines.layers.disableAll();
        this.lines.layers.enable(2);
      }
      if (this.lines.parent !== ((_a = this.context) == null ? void 0 : _a.scene))
        (_b = this.context) == null ? void 0 : _b.scene.add(this.lines);
      const buffers = world.debugRender();
      this.lines.geometry.setAttribute("position", new BufferAttribute(buffers.vertices, 3));
      this.lines.geometry.setAttribute("color", new BufferAttribute(buffers.colors, 4));
      if (this.context.time.frame % 30 === 0 || ((_c = this.lines.geometry.boundingSphere) == null ? void 0 : _c.radius) === 0) {
        this.lines.geometry.computeBoundingSphere();
      }
    } else {
      if (this.lines) {
        (_d = this.context) == null ? void 0 : _d.scene.remove(this.lines);
      }
    }
  }
  /** sync rendered objects with physics world (except for colliders without rigidbody) */
  syncObjects() {
    if (debugColliderPlacement)
      return;
    for (let i = 0; i < this.bodies.length; i++) {
      const obj = this.objects[i];
      const body = this.bodies[i];
      const col = obj;
      if ((col == null ? void 0 : col.isCollider) === true && !col.attachedRigidbody) {
        const rigidbody = body.parent();
        if (rigidbody)
          this.syncPhysicsBody(obj.gameObject, rigidbody, true, true);
        else
          this.syncPhysicsBody(obj.gameObject, body, true, true);
        continue;
      }
      const pos = body.translation();
      const rot = body.rotation();
      if (Number.isNaN(pos.x) || Number.isNaN(rot.x)) {
        if (!col["__COLLIDER_NAN"] && isDevEnvironment()) {
          console.warn("Collider has NaN values", col.name, col.gameObject, body);
          col["__COLLIDER_NAN"] = true;
        }
        continue;
      }
      const center = obj["center"];
      if (center && center.isVector3) {
        this._tempQuaternion.set(rot.x, rot.y, rot.z, rot.w);
        const offset = this._tempPosition.copy(center).applyQuaternion(this._tempQuaternion);
        const scale = getWorldScale(obj.gameObject);
        offset.multiply(scale);
        pos.x -= offset.x;
        pos.y -= offset.y;
        pos.z -= offset.z;
      }
      setWorldPositionXYZ(obj.gameObject, pos.x, pos.y, pos.z);
      setWorldQuaternionXYZW(obj.gameObject, rot.x, rot.y, rot.z, rot.w);
    }
  }
  syncPhysicsBody(obj, body, translation, rotation) {
    if (body instanceof wI) {
      const worldPosition = getWorldPosition(obj, this._tempPosition);
      const worldQuaternion = getWorldQuaternion(obj, this._tempQuaternion);
      const type = body.bodyType();
      switch (type) {
        case vA.Fixed:
        case vA.KinematicPositionBased:
        case vA.KinematicVelocityBased:
          if (translation)
            body.setNextKinematicTranslation(worldPosition);
          if (rotation)
            body.setNextKinematicRotation(worldQuaternion);
          break;
        default:
          if (translation)
            body.setTranslation(worldPosition, false);
          if (rotation)
            body.setRotation(worldQuaternion, false);
          break;
      }
    } else if (body instanceof sg) {
      if (obj.matrixWorldNeedsUpdate) {
        obj.updateWorldMatrix(true, false);
      }
      obj.matrixWorld.decompose(this._tempPosition, this._tempQuaternion, this._tempScale);
      const wp = this._tempPosition;
      const wq = this._tempQuaternion;
      const collider = body[$componentKey];
      this.tryApplyCenter(collider, wp);
      if (translation) {
        const ct = body.translation();
        if (ct.x !== wp.x || ct.y !== wp.y || ct.z !== wp.z)
          body.setTranslation(wp);
      }
      if (rotation) {
        const cr = body.rotation();
        if (cr.x !== wq.x || cr.y !== wq.y || cr.z !== wq.z || cr.w !== wq.w)
          body.setRotation(wq);
      }
    }
  }
  tryApplyCenter(collider, targetVector) {
    const center = collider.center;
    if (center && collider.gameObject) {
      if (center.x !== 0 || center.y !== 0 || center.z !== 0) {
        this._tempCenterPos.x = center.x;
        this._tempCenterPos.y = center.y;
        this._tempCenterPos.z = center.z;
        getWorldScale(collider.gameObject, this._tempCenterVec);
        this._tempCenterPos.multiply(this._tempCenterVec);
        if (!collider.attachedRigidbody) {
          getWorldQuaternion(collider.gameObject, this._tempCenterQuaternion);
          this._tempCenterPos.applyQuaternion(this._tempCenterQuaternion);
        } else {
          this._tempCenterPos.applyQuaternion(collider.gameObject.quaternion);
        }
        targetVector.x += this._tempCenterPos.x;
        targetVector.y += this._tempCenterPos.y;
        targetVector.z += this._tempCenterPos.z;
      }
    }
  }
  getRigidbodyRelativeMatrix(comp, rigidbody, mat, matrices) {
    if (matrices === void 0) {
      matrices = _RapierPhysics._matricesBuffer;
      matrices.length = 0;
    }
    if (comp === rigidbody) {
      const scale = getWorldScale(comp, this._tempPosition);
      mat.makeScale(scale.x, scale.y, scale.z);
      for (let i = matrices.length - 1; i >= 0; i--) {
        mat.multiply(matrices[i]);
      }
      return mat;
    }
    matrices.push(comp.matrix);
    if (comp.parent) {
      this.getRigidbodyRelativeMatrix(comp.parent, rigidbody, mat, matrices);
    }
    return mat;
  }
  addFixedJoint(body1, body2) {
    if (!this.world) {
      console.error("Physics world not initialized");
      return;
    }
    const b1 = body1[$bodyKey];
    const b2 = body2[$bodyKey];
    this.calculateJointRelativeMatrices(body1.gameObject, body2.gameObject, this._tempMatrix);
    this._tempMatrix.decompose(this._tempPosition, this._tempQuaternion, this._tempScale);
    const params = cI.fixed(_RapierPhysics.centerConnectionPos, _RapierPhysics.centerConnectionRot, this._tempPosition, this._tempQuaternion);
    const joint = this.world.createImpulseJoint(params, b1, b2, true);
    if (debugPhysics)
      console.log("ADD FIXED JOINT", joint);
  }
  /** The joint prevents any relative movement between two rigid-bodies, except for relative rotations along one axis. This is typically used to simulate wheels, fans, etc. They are characterized by one local anchor as well as one local axis on each rigid-body. */
  addHingeJoint(body1, body2, anchor, axis) {
    if (!this.world) {
      console.error("Physics world not initialized");
      return;
    }
    const b1 = body1[$bodyKey];
    const b2 = body2[$bodyKey];
    this.calculateJointRelativeMatrices(body1.gameObject, body2.gameObject, this._tempMatrix);
    this._tempMatrix.decompose(this._tempPosition, this._tempQuaternion, this._tempScale);
    const params = RAPIER.JointData.revolute(anchor, this._tempPosition, axis);
    const joint = this.world.createImpulseJoint(params, b1, b2, true);
    if (debugPhysics)
      console.log("ADD HINGE JOINT", joint);
  }
  calculateJointRelativeMatrices(body1, body2, mat) {
    body1.updateWorldMatrix(true, false);
    body2.updateWorldMatrix(true, false);
    const world1 = body1.matrixWorld;
    const world2 = body2.matrixWorld;
    world1.elements[0] = 1;
    world1.elements[5] = 1;
    world1.elements[10] = 1;
    world2.elements[0] = 1;
    world2.elements[5] = 1;
    world2.elements[10] = 1;
    mat.copy(world2).premultiply(world1.invert()).invert();
  }
};
var RapierPhysics = _RapierPhysics;
__publicField(RapierPhysics, "_didLoadPhysicsEngine", false);
__publicField(RapierPhysics, "_matricesBuffer", []);
__publicField(RapierPhysics, "centerConnectionPos", { x: 0, y: 0, z: 0 });
__publicField(RapierPhysics, "centerConnectionRot", { x: 0, y: 0, z: 0, w: 1 });
var PhysicsCollisionHandler = class {
  constructor(world, eventQueue) {
    __publicField(this, "world");
    __publicField(this, "eventQueue");
    __publicField(this, "activeCollisions", []);
    __publicField(this, "activeCollisionsStay", []);
    __publicField(this, "activeTriggers", []);
    this.world = world;
    this.eventQueue = eventQueue;
  }
  handleCollisionEvents() {
    if (!this.eventQueue)
      return;
    if (!this.world)
      return;
    this.eventQueue.drainCollisionEvents((handle1, handle2, started) => {
      const col1 = this.world.getCollider(handle1);
      const col2 = this.world.getCollider(handle2);
      if (!col1 || !col2)
        return;
      const colliderComponent1 = col1[$componentKey];
      const colliderComponent2 = col2[$componentKey];
      if (debugCollisions)
        console.log("EVT", colliderComponent1.name, colliderComponent2.name, started, col1, col2);
      if (colliderComponent1 && colliderComponent2) {
        if (started) {
          this.onCollisionStarted(colliderComponent1, col1, colliderComponent2, col2);
          this.onCollisionStarted(colliderComponent2, col2, colliderComponent1, col1);
        } else {
          this.onCollisionEnded(colliderComponent1, colliderComponent2);
          this.onCollisionEnded(colliderComponent2, colliderComponent1);
        }
      }
    });
  }
  update() {
    this.onHandleCollisionStay();
  }
  onCollisionStarted(self, selfBody, other, otherBody) {
    let collision = null;
    if (self.isTrigger || other.isTrigger) {
      foreachComponent(self.gameObject, (c) => {
        if (c.onTriggerEnter && !c.destroyed) {
          c.onTriggerEnter(other);
        }
        this.activeTriggers.push({ collider: self, component: c, otherCollider: other });
      });
    } else {
      const object = self.gameObject;
      this.world.contactPair(selfBody, otherBody, (manifold, _flipped) => {
        foreachComponent(object, (c) => {
          var _a;
          if (c.destroyed)
            return;
          const hasDeclaredEventMethod = c.onCollisionEnter || c.onCollisionStay || c.onCollisionExit;
          if (hasDeclaredEventMethod || debugCollisions) {
            if (!collision) {
              const contacts = [];
              const normal = manifold.normal();
              for (let i = 0; i < manifold.numSolverContacts(); i++) {
                const pt = manifold.solverContactPoint(i);
                const impulse = manifold.contactImpulse(i);
                if (pt) {
                  const dist = manifold.contactDist(i);
                  const friction = manifold.solverContactFriction(i);
                  const tangentVelocity = manifold.solverContactTangentVelocity(i);
                  const contact = new ContactPoint(pt, dist, normal, impulse, friction, tangentVelocity);
                  contacts.push(contact);
                  if (debugCollisions) {
                    Gizmos.DrawDirection(pt, normal, 16711680, 3, true);
                  }
                }
              }
              collision = new Collision(object, other, contacts);
            }
            if (hasDeclaredEventMethod) {
              const info = { collider: self, component: c, collision };
              this.activeCollisions.push(info);
              if (c.onCollisionStay) {
                this.activeCollisionsStay.push(info);
              }
              (_a = c.onCollisionEnter) == null ? void 0 : _a.call(c, collision);
            }
          }
        });
      });
    }
  }
  onHandleCollisionStay() {
    for (const active of this.activeCollisionsStay) {
      const c = active.component;
      if (c.destroyed)
        continue;
      if (c.activeAndEnabled && c.onCollisionStay) {
        if (active.collision.collider.destroyed)
          continue;
        const arg = active.collision;
        c.onCollisionStay(arg);
      }
    }
    for (const active of this.activeTriggers) {
      const c = active.component;
      if (c.destroyed)
        continue;
      if (c.activeAndEnabled && c.onTriggerStay) {
        const arg = active.otherCollider;
        if (arg.destroyed)
          continue;
        c.onTriggerStay(arg);
      }
    }
  }
  onCollisionEnded(self, other) {
    if (self.destroyed || other.destroyed)
      return;
    for (let i = 0; i < this.activeCollisions.length; i++) {
      const active = this.activeCollisions[i];
      const collider = active.collider;
      if (collider.destroyed || active.collision.collider.destroyed) {
        this.activeCollisions.splice(i, 1);
        i--;
        continue;
      }
      if (collider === self && active.collision.collider === other) {
        const c = active.component;
        this.activeCollisions.splice(i, 1);
        i--;
        if (c.activeAndEnabled && c.onCollisionExit) {
          const collision = active.collision;
          c.onCollisionExit(collision);
        }
      }
    }
    for (let i = 0; i < this.activeCollisionsStay.length; i++) {
      const active = this.activeCollisionsStay[i];
      const collider = active.collider;
      if (collider.destroyed || active.collision.collider.destroyed) {
        this.activeCollisionsStay.splice(i, 1);
        i--;
        continue;
      }
      if (collider === self && active.collision.collider === other) {
        const c = active.component;
        this.activeCollisionsStay.splice(i, 1);
        i--;
        if (c.activeAndEnabled && c.onCollisionExit) {
          const collision = active.collision;
          c.onCollisionExit(collision);
        }
      }
    }
    for (let i = 0; i < this.activeTriggers.length; i++) {
      const active = this.activeTriggers[i];
      const collider = active.collider;
      if (collider.destroyed || active.otherCollider.destroyed) {
        this.activeTriggers.splice(i, 1);
        i--;
        continue;
      }
      if (collider === self && active.otherCollider === other) {
        const c = active.component;
        this.activeTriggers.splice(i, 1);
        i--;
        if (c.activeAndEnabled && c.onTriggerExit) {
          const collision = active.otherCollider;
          c.onTriggerExit(collision);
        }
      }
    }
  }
};

// node_modules/@needle-tools/engine/lib/engine/engine_test_utils.js
var TestSceneUtils = class {
  /**
   * Use this method to quickly setup a scene to compare multiple models.
   * @example
   * ```ts
   * const files = [
   *    "https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb",
   *   "https://threejs.org/examples/models/gltf/Lantern/glTF-Binary/Lantern.glb",
   * ];
   * const { scene, camera } = await TestUtils.createComparisonScene({ files });
   * // this could now be assigned to the Needle Engine Context
   * context.scene = scene;
   * context.mainCamera = camera;
   * ```
   */
  static async createComparisonScene(opts) {
    const { files } = opts;
    const promises = Promise.all(files.map((file) => new AssetReference(file).loadAssetAsync()));
    const results = await promises;
    const scene = new Scene();
    let offset = 0;
    for (const result of results) {
      if (result instanceof Object3D) {
        result.position.y = offset;
        scene.add(result);
        const box2 = getBoundingBox([result]);
        offset += box2.getSize(new Vector3()).y;
        offset += 0.1;
      }
    }
    const camera = new PerspectiveCamera(20);
    scene.add(camera);
    const environmentUrl = opts.environment || "https://dl.polyhaven.org/file/ph-assets/HDRIs/exr/1k/studio_small_09_1k.exr";
    if (environmentUrl) {
      let loader = null;
      if (environmentUrl.endsWith(".hdr")) {
        const RGBELoader = (await import("./RGBELoader-QUO2ECSR.js")).RGBELoader;
        loader = new RGBELoader();
      } else if (environmentUrl.endsWith(".exr")) {
        const EXRLoader = (await import("./EXRLoader-65H5VFQ3.js")).EXRLoader;
        loader = new EXRLoader();
      }
      if (loader) {
        const envmap = await loader.loadAsync(environmentUrl).catch((e) => {
          console.error(e);
          return null;
        });
        if (envmap) {
          envmap.mapping = EquirectangularReflectionMapping;
          envmap.needsUpdate = true;
          scene.background = envmap;
          scene.environment = envmap;
          scene.backgroundBlurriness = 0.75;
        }
      } else
        console.warn("Unsupported environment map format", environmentUrl);
    }
    const box = getBoundingBox(scene.children);
    const center = box.getCenter(new Vector3());
    const size = box.getSize(new Vector3());
    const max = Math.max(size.x, size.y, size.z);
    const distance = max / (2 * Math.tan(Math.PI * camera.fov / 360));
    camera.position.set(center.x, center.y, distance);
    camera.lookAt(center);
    const orbit = new OrbitControls(camera, opts.domElement || document.body);
    orbit.target = center;
    orbit.update();
    const element = (opts.domElement || document.body).getBoundingClientRect();
    camera.aspect = element.width / element.height;
    camera.updateProjectionMatrix();
    return {
      scene,
      camera
    };
  }
};

// node_modules/@needle-tools/engine/lib/engine/export/state.js
var exportingStack = 0;
function __isExporting(state) {
  if (state) {
    exportingStack++;
  } else {
    exportingStack--;
  }
}
function isExporting() {
  return exportingStack > 0;
}

// node_modules/@needle-tools/engine/lib/engine/export/gltf/Writers.js
var BaseWriter = class {
  constructor(writer) {
    __publicField(this, "writer");
    this.writer = writer;
  }
  writeNode(_node) {
  }
};
var GizmoWriter = class extends BaseWriter {
  beforeWriteNode(node, args) {
    if (Gizmos.isGizmo(node)) {
      args.keep = false;
    }
  }
};
var RenderTextureWriter = class extends BaseWriter {
  beforeWriteTexture(texture, args) {
    if (texture.isRenderTargetTexture) {
      args.newTexture = createFlatTexture(new RGBAColor(1, 1, 1, 0));
    }
  }
};

// node_modules/@needle-tools/engine/lib/engine/export/gltf/index.js
var DEFAULT_OPTIONS = {
  binary: true,
  animations: true
};
async function exportAsGLTF(_opts) {
  if (!_opts.context) {
    throw new Error("No context provided to exportAsGLTF");
  }
  if (!_opts.scene) {
    _opts.scene = _opts.context.scene;
  }
  const opts = {
    ...DEFAULT_OPTIONS,
    ..._opts
  };
  const { context } = opts;
  const exporter = new GLTFExporter();
  exporter.register((writer) => new GLTFMeshGPUInstancingExtension(writer));
  exporter.register((writer) => new GizmoWriter(writer));
  exporter.register((writer) => new RenderTextureWriter(writer));
  registerExportExtensions(exporter, opts.context);
  const exporterOptions = {
    binary: opts.binary,
    animations: collectAnimations(context, opts.scene, [])
  };
  const state = new ExporterState();
  console.log("Exporting GLTF", exporterOptions);
  state.onBeforeExport(opts);
  __isExporting(true);
  const res = await exporter.parseAsync(opts.scene, exporterOptions).catch((e) => {
    console.error(e);
    return null;
  });
  __isExporting(false);
  state.onAfterExport(opts);
  if (!res) {
    throw new Error("Failed to export GLTF");
  }
  if (opts.downloadAs != void 0) {
    let blob = null;
    if (res instanceof ArrayBuffer) {
      blob = new Blob([res], { type: "application/octet-stream" });
    } else {
      console.error("Can not download GLTF as a blob", res);
    }
    if (blob) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      let name = opts.downloadAs;
      if (!name.endsWith(".glb") && !name.endsWith(".gltf")) {
        name += opts.binary ? ".glb" : ".gltf";
      }
      a.download = name;
      a.click();
    }
  }
  return res;
}
var ACTIONS_WEIGHT_KEY = Symbol("needle:weight");
var ExporterState = class {
  constructor() {
    __publicField(this, "_undo", []);
  }
  onBeforeExport(opts) {
    opts.context.animations.mixers.forEach((mixer) => {
      const actions = AnimationUtils.tryGetActionsFromMixer(mixer);
      if (actions) {
        for (let i = 0; i < actions.length; i++) {
          const action = actions[i];
          action[ACTIONS_WEIGHT_KEY] = action.weight;
          action.weight = 0;
          this._undo.push(() => {
            action.weight = action[ACTIONS_WEIGHT_KEY];
          });
        }
      }
      mixer.update(0);
    });
  }
  onAfterExport(_opts) {
    this._undo.forEach((fn) => fn());
    this._undo.length = 0;
  }
};
function collectAnimations(context, scene, clips) {
  context.animations.mixers.forEach((mixer) => {
    const actions = AnimationUtils.tryGetActionsFromMixer(mixer);
    if (actions) {
      for (let i = 0; i < actions.length; i++) {
        const action = actions[i];
        const clip = action.getClip();
        clips.push(clip);
      }
    }
  });
  if (!Array.isArray(scene))
    scene = [scene];
  for (const obj of scene) {
    AnimationUtils.tryGetAnimationClipsFromObjectHierarchy(obj, clips);
  }
  const uniqueClips = new Set(clips);
  return Array.from(uniqueClips);
}

// node_modules/@needle-tools/engine/lib/engine/webcomponents/needle-button.js
var htmlTagName = "needle-button";
var isDev = isDevEnvironment();
var _root, _slot, _styles, _button, _webxrfactory, _observer, _update, update_fn, _updateVisibility, updateVisibility_fn, _onclick;
var NeedleButtonElement = class extends HTMLElement {
  constructor() {
    super();
    __privateAdd(this, _update);
    __privateAdd(this, _updateVisibility);
    __privateAdd(this, _root, void 0);
    __privateAdd(this, _slot, void 0);
    /** These are the default styles that can be overridden by the user from the outside by styling <needle-button> */
    __privateAdd(this, _styles, void 0);
    /** This is the button that was generated using one of the factories */
    __privateAdd(this, _button, void 0);
    /** If AR or VR is requested we create and use the webxr button factory to create a button with default behaviour */
    __privateAdd(this, _webxrfactory, void 0);
    __privateAdd(this, _observer, void 0);
    __privateAdd(this, _onclick, (_ev) => {
      if (isDev) {
        console.log("Needle Button clicked");
      }
      if (_ev.defaultPrevented)
        return;
      if (__privateGet(this, _button)) {
        __privateGet(this, _button).click();
      }
    });
    this.removeEventListener("click", __privateGet(this, _onclick));
    this.addEventListener("click", __privateGet(this, _onclick));
  }
  attributeChangedCallback(_name, _oldValue, _newValue) {
    __privateMethod(this, _update, update_fn).call(this);
  }
};
_root = new WeakMap();
_slot = new WeakMap();
_styles = new WeakMap();
_button = new WeakMap();
_webxrfactory = new WeakMap();
_observer = new WeakMap();
_update = new WeakSet();
update_fn = function() {
  var _a, _b;
  (_a = __privateGet(this, _button)) == null ? void 0 : _a.remove();
  if (this.getAttribute("ar") != null) {
    __privateGet(this, _webxrfactory) ?? __privateSet(this, _webxrfactory, new WebXRButtonFactory());
    __privateSet(this, _button, __privateGet(this, _webxrfactory).createARButton());
  } else if (this.getAttribute("vr") != null) {
    __privateGet(this, _webxrfactory) ?? __privateSet(this, _webxrfactory, new WebXRButtonFactory());
    __privateSet(this, _button, __privateGet(this, _webxrfactory).createVRButton());
  } else if (this.getAttribute("quicklook") != null) {
    __privateGet(this, _webxrfactory) ?? __privateSet(this, _webxrfactory, new WebXRButtonFactory());
    __privateSet(this, _button, __privateGet(this, _webxrfactory).createQuicklookButton());
  } else {
    if (isDev) {
      console.warn("No button type specified for <needle-button>. Use either ar, vr or quicklook attribute.");
    } else {
      console.debug("No button type specified for <needle-button>. Use either ar, vr or quicklook attribute.");
    }
    return;
  }
  __privateGet(this, _root) ?? __privateSet(this, _root, this.attachShadow({ mode: "open" }));
  __privateGet(this, _slot) ?? __privateSet(this, _slot, document.createElement("slot"));
  __privateGet(this, _styles) ?? __privateSet(this, _styles, document.createElement("style"));
  __privateGet(this, _styles).innerHTML = `
            button {
                all: initial;
                cursor: inherit;
                color: inherit;
                font-family: inherit;
                gap: inherit;
                white-space: nowrap;
            }
        `;
  const hasUnstyledAttribute = this.getAttribute("unstyled") != void 0;
  if (!hasUnstyledAttribute) {
    __privateGet(this, _styles).innerHTML += `
            :host {
                display: inline-block;
                background: rgba(255, 255, 255, .8);
                backdrop-filter: blur(10px);
                width: fit-content;
                transition: background .2s;

                cursor: pointer;
                padding: 0.4rem .5rem;
                border-radius: 0.8rem;
                color: black;
                background: rgba(245, 245, 245, .8);
                outline: rgba(0,0,0,.05) 1px solid;
            }
            :host(:hover) {
                background: rgba(255, 255, 255, 1);
                transition: background .2s;
            }
            slot {
                display: flex;
                align-items: center;
                justify-content: center;
                gap: .5rem;
            }
`;
  }
  __privateGet(this, _slot).innerHTML = __privateGet(this, _button).innerHTML;
  __privateGet(this, _slot).style.cssText = `display: flex; align-items: center; justify-content: center;`;
  __privateGet(this, _button).innerHTML = __privateGet(this, _slot).outerHTML;
  __privateGet(this, _root).innerHTML = __privateGet(this, _button).outerHTML;
  __privateGet(this, _root).prepend(__privateGet(this, _styles));
  loadFont(iconFontUrl, { element: __privateGet(this, _root) });
  (_b = __privateGet(this, _observer)) == null ? void 0 : _b.disconnect();
  __privateGet(this, _observer) ?? __privateSet(this, _observer, new MutationObserver(() => __privateMethod(this, _updateVisibility, updateVisibility_fn).call(this)));
  __privateGet(this, _observer).observe(__privateGet(this, _button), { attributes: true });
  if (isDev) {
    console.log("Needle Button updated");
  }
};
_updateVisibility = new WeakSet();
updateVisibility_fn = function() {
  if (__privateGet(this, _button)) {
    if (__privateGet(this, _button).style.display === "none") {
      this.style.display = "none";
    } else if (this.style.display === "none") {
      this.style.display = "";
    }
  }
};
_onclick = new WeakMap();
__publicField(NeedleButtonElement, "observedAttributes", ["ar", "vr", "quicklook"]);
if (typeof window !== "undefined" && !window.customElements.get(htmlTagName))
  window.customElements.define(htmlTagName, NeedleButtonElement);

// node_modules/@needle-tools/engine/lib/engine-components/CameraUtils.js
var debug2 = getParam("debugmissingcamera");
ContextRegistry.registerCallback(ContextEvent.MissingCamera, (evt) => {
  var _a, _b, _c;
  if (debug2)
    console.warn("Creating missing camera");
  const scene = evt.context.scene;
  const cameraObject = new PerspectiveCamera();
  cameraObject.name = "Default Fallback Camera";
  scene.add(cameraObject);
  const camInstance = new Camera();
  camInstance.sourceId = ((_b = (_a = evt.files) == null ? void 0 : _a[0]) == null ? void 0 : _b.src) ?? "unknown";
  if (((_c = evt.context.domElement.getAttribute("skybox-image")) == null ? void 0 : _c.length) || 0 > 0 || evt.context.lightmaps.tryGetSkybox(camInstance.sourceId))
    camInstance.clearFlags = ClearFlags.Skybox;
  else
    camInstance.clearFlags = ClearFlags.SolidColor;
  camInstance.backgroundColor = new RGBAColor(0.5, 0.5, 0.5, 1);
  camInstance.fieldOfView = 35;
  const transparentAttribute = evt.context.domElement.getAttribute("transparent");
  if (transparentAttribute != void 0) {
    camInstance.clearFlags = ClearFlags.Uninitialized;
  }
  camInstance.backgroundBlurriness = 0.2;
  const cam = addNewComponent(cameraObject, camInstance, true);
  cameraObject.position.x = 0;
  cameraObject.position.y = 1;
  cameraObject.position.z = 2;
  const engineElement = evt.context.domElement;
  if ((engineElement == null ? void 0 : engineElement.cameraControls) != false) {
    createDefaultCameraControls(evt.context, cam);
  }
  return cam;
});
ContextRegistry.registerCallback(ContextEvent.ContextCreated, (evt) => {
  if (!evt.context.mainCamera) {
    if (debug2)
      console.log("Will not auto-fit because a default camera exists");
    return;
  }
  const engineElement = evt.context.domElement;
  if ((engineElement == null ? void 0 : engineElement.cameraControls) == true) {
    const existing = getCameraController(evt.context.mainCamera);
    if ((existing == null ? void 0 : existing.isCameraController) == true) {
      if (debug2)
        console.log("Will not auto-fit because a camera controller exists");
      return;
    }
    createDefaultCameraControls(evt.context);
  }
});
function createDefaultCameraControls(context, cam) {
  cam = cam ?? context.mainCameraComponent;
  const cameraObject = cam == null ? void 0 : cam.gameObject;
  if (debug2)
    console.log("Creating default camera controls", cam == null ? void 0 : cam.name);
  if (cameraObject) {
    const orbit = getOrAddComponent(cameraObject, OrbitControls2);
    orbit.sourceId = (cam == null ? void 0 : cam.sourceId) ?? "unknown";
    const autoRotate = context.domElement.getAttribute("auto-rotate");
    orbit.autoRotate = autoRotate !== void 0 && autoRotate !== null && (autoRotate != "0" && (autoRotate == null ? void 0 : autoRotate.toLowerCase()) != "false");
    orbit.autoRotateSpeed = 0.5;
    orbit.autoFit = true;
    if (orbit.autoRotate && autoRotate) {
      const autoRotateValue = parseFloat(autoRotate);
      if (!isNaN(autoRotateValue)) {
        orbit.autoRotateSpeed = autoRotateValue;
      }
    }
  } else {
    console.warn("Missing camera object, can not add orbit controls");
  }
}

// node_modules/@needle-tools/engine/lib/engine-components/AnimationUtilsAutoplay.js
ContextRegistry.registerCallback(ContextEvent.ContextCreated, (args) => {
  const autoplay = args.context.domElement.getAttribute("autoplay");
  if (autoplay !== void 0 && (autoplay === "" || autoplay === "true" || autoplay === "1")) {
    if (args.files) {
      for (const file of args.files) {
        const hasAnimation = GameObject.foreachComponent(file.file.scene, (comp) => {
          if (comp.enabled === false)
            return void 0;
          if (comp instanceof Animation && comp.playAutomatically || comp instanceof Animator || comp instanceof PlayableDirector && comp.playOnAwake === true) {
            return true;
          } else if (comp instanceof Animation) {
            comp.playAutomatically = true;
            return true;
          } else if (comp instanceof PlayableDirector) {
            comp.playOnAwake = true;
            return true;
          }
          return void 0;
        }, true);
        if (hasAnimation !== true) {
          AnimationUtils.assignAnimationsFromFile(file.file, {
            createAnimationComponent: (obj, _clip) => {
              return addComponent(obj, Animation);
            }
          });
        }
      }
    }
  }
});

// node_modules/@needle-tools/engine/lib/needle-engine.js
var Needle = {
  Context,
  glTF: {
    loadFromURL: loadSync
  }
};
if (globalThis["Needle"] !== void 0) {
  console.warn("Needle Engine is already imported");
}
globalThis["Needle"] = Needle;
function registerGlobal(obj) {
  for (const key in obj) {
    Needle[key] = obj[key];
  }
}
registerGlobal(Component_exports);
registerGlobal(components_exports);
Needle["onStart"] = onStart;
Needle["onUpdate"] = onUpdate;
Needle["onBeforeRender"] = onBeforeRender;
Needle["NeedleXRSession"] = NeedleXRSession;
for (const method of Object.getOwnPropertyNames(GameObject)) {
  switch (method) {
    case "prototype":
    case "constructor":
    case "length":
    case "name":
      continue;
    default:
      Needle[method] = GameObject[method];
      break;
  }
}
if (!globalThis["THREE"]) {
  globalThis["THREE"] = three_module_exports;
} else
  console.warn("Threejs is already imported");
export {
  $physicsKey,
  ActionBuilder,
  ActionCollection,
  ActionModel,
  Addressables,
  AlignmentConstraint,
  AmbientMode,
  Animation,
  AnimationCurve,
  AnimationExtension,
  AnimationTrackHandler,
  AnimationUtils,
  Animator,
  AnimatorConditionMode,
  AnimatorController,
  AnimatorControllerParameterType,
  AnimatorStateInfo,
  Antialiasing,
  Application,
  ApplicationEvents,
  AssetDatabase,
  AssetReference,
  AudioExtension,
  AudioListener,
  AudioSource,
  AudioTrackHandler,
  Avatar,
  AvatarBlink_Simple,
  AvatarEyeLook_Rotation,
  AvatarLoader,
  AvatarMarker,
  AvatarModel,
  Avatar_Brain_LookAt,
  Avatar_MouthShapes,
  Avatar_MustacheShake,
  Avatar_POI,
  Axes,
  AxesHelper,
  BUILD_TIME,
  BaseUIComponent,
  BasicIKConstraint,
  BehaviorExtension,
  BehaviorModel,
  Component as Behaviour,
  BlobStorage,
  BloomEffect,
  BoxCollider,
  BoxGizmo,
  BoxHelperComponent,
  Button,
  ButtonsFactory,
  CallDirection,
  CallInfo,
  Camera,
  CameraTargetReachedEvent,
  Canvas,
  CanvasGroup,
  CapsuleCollider,
  ChangeMaterialOnClick,
  ChangeTransformOnClick,
  CharacterController,
  CharacterControllerInput,
  ChromaticAberration,
  CircularBuffer,
  ClearFlags,
  ClipExtrapolation,
  Collider,
  Collision,
  CollisionDetectionMode,
  ColorAdjustments,
  ColorBySpeedModule,
  ColorOverLifetimeModule,
  Component,
  ComponentLifecycleEvents,
  ConnectionEvents,
  ContactPoint,
  ContactShadows,
  Context,
  ContextArgs,
  ContextEvent,
  ContextRegistry,
  ControlTrackHandler,
  CustomBranding,
  CustomShader,
  DefaultReflectionMode,
  Deletable,
  DeleteBox,
  DepthOfField,
  DeviceFlag,
  DeviceUtilities,
  DocumentExtension,
  DragControls,
  DragMode,
  DropListener,
  DropListenerAddedEvent,
  Duplicatable,
  EffectWrapper,
  EmissionModule,
  EmphasizeOnClick,
  EngineLoadingView,
  EventList,
  EventListEvent,
  EventSystem,
  EventTrigger,
  FieldWithDefault,
  FileReference,
  FileReferenceSerializer,
  FileSpawnModel,
  File_Event,
  FixedJoint,
  FlyControls,
  Fog,
  FrameEvent,
  GENERATOR,
  GameObject,
  Gizmos,
  GltfExport,
  GltfExportBox,
  GltfLoadEvent,
  GltfLoadEventType,
  Gradient,
  Graphic,
  GraphicRaycaster,
  Graphics,
  GridHelper,
  GridLayoutGroup,
  GroundProjectedEnv,
  GroupActionModel,
  HideFlags,
  HideOnStart,
  HingeJoint,
  HorizontalLayoutGroup,
  HostData,
  Image,
  ImageReference,
  ImageReferenceSerializer,
  InheritVelocityModule,
  Input,
  InputEventQueue,
  InputEvents,
  InputField,
  InstanceHandle,
  InstancingHandler,
  InstancingUtil,
  InstantiateEvent,
  InstantiateIdProvider,
  InstantiateOptions,
  Interactable,
  InternalScreenshotUtils,
  JoinedRoomResponse,
  KeyEventArgs,
  Keyframe,
  LODGroup,
  LODModel,
  LeftRoomResponse,
  Light,
  LightData,
  LimitVelocityOverLifetimeModule,
  LoadingElementOptions,
  LogStats,
  LogType,
  LookAt,
  LookAtConstraint,
  MainModule,
  MarkerType,
  MaskableGraphic,
  Mathf,
  MeshCollider,
  MeshRenderer,
  MinMaxCurve,
  MinMaxGradient,
  NEEDLE_progressive,
  NEKeyboardEvent,
  NEPointerEvent,
  NeedleButtonElement,
  ContextRegistry as NeedleEngine,
  NeedleEngineHTMLElement,
  NeedleLoader,
  NeedleMenu,
  NeedlePatchesKey,
  USDZExporter as NeedleUSDZExporter,
  NeedleXRController,
  NeedleXRSession,
  NeedleXRSync,
  NeedleXRUtils,
  NestedGltf,
  NetworkConnection,
  NetworkedStreamEvents,
  NetworkedStreams,
  Networking,
  NewInstanceModel,
  NoiseModule,
  ObjectRaycaster,
  ObjectUtils,
  OffsetConstraint,
  OneEuroFilter,
  OneEuroFilterXYZ,
  OpenURL,
  OrbitControls2 as OrbitControls,
  Outline,
  OwnershipEvent,
  OwnershipModel,
  PUBLIC_KEY,
  Padding,
  ParticleBurst,
  ParticleSubEmitter,
  ParticleSystem,
  ParticleSystemBaseBehaviour,
  ParticleSystemRenderer,
  ParticleSystemShapeType,
  PeerHandle,
  PeerNetworking,
  Physics,
  PhysicsExtension,
  PhysicsMaterialCombine,
  PixelationEffect,
  PlayAnimationOnClick,
  PlayAudioOnClick,
  PlayableDirector,
  PlayerColor,
  PlayerState,
  PlayerStateEvent,
  PlayerSync,
  PlayerView,
  PlayerViewManager,
  PointerEventData,
  PointerType,
  PostProcessingEffect,
  PostProcessingHandler,
  Volume as PostProcessingManager,
  PreliminaryAction,
  PreliminaryTrigger,
  PreviewHelper,
  PrimitiveType,
  Progress,
  PromiseAllWithErrors,
  PromiseErrorResult,
  RGBAColor,
  RapierPhysics,
  RawImage,
  RaycastOptions,
  Rect,
  RectTransform,
  ReflectionProbe,
  RegisteredAnimationInfo,
  RemoteSkybox,
  RenderTexture,
  RenderTextureSerializer,
  Renderer,
  RendererData,
  RendererLightmap,
  Rigidbody,
  RigidbodyConstraints,
  RoomEvents,
  RotationBySpeedModule,
  RotationOverLifetimeModule,
  SceneLightSettings,
  SceneSwitcher,
  ScreenCapture,
  ScreenSpaceAmbientOcclusion,
  ScreenSpaceAmbientOcclusionN8,
  SendQueue,
  SerializationContext,
  SetActiveOnClick,
  ShadowCatcher,
  ShapeModule,
  SharpeningEffect,
  SignalAsset,
  SignalReceiver,
  SignalReceiverEvent,
  SignalTrackHandler,
  Size,
  SizeBySpeedModule,
  SizeOverLifetimeModule,
  SkinnedMeshRenderer,
  SmoothFollow,
  SpatialGrabRaycaster,
  SpatialHtml,
  SpatialTrigger,
  SpatialTriggerReceiver,
  SpectatorCamera,
  SphereCollider,
  SphereIntersection,
  SphereOverlapResult,
  Sprite,
  SpriteData,
  SpriteRenderer,
  SpriteSheet,
  StateMachineBehaviour,
  StreamEndedEvent,
  StreamReceivedEvent,
  SubEmitterSystem,
  SyncedCamera,
  SyncedRoom,
  SyncedTransform,
  TapGestureTrigger,
  TeleportTarget,
  TestRunner,
  TestSceneUtils,
  TestSimulateUserData,
  Text,
  TextBuilder,
  TextExtension,
  TextureSheetAnimationModule,
  TiltShiftEffect,
  Time,
  ToneMappingEffect,
  TrackHandler,
  TrackType,
  TrailModule,
  TransformData,
  TransformGizmo,
  TriggerBuilder,
  TriggerModel,
  TypeStore,
  UIRaycastUtils,
  UIRootComponent,
  USDDocument,
  USDObject,
  USDWriter,
  USDZExporter2 as USDZExporter,
  USDZText,
  USDZUIExtension,
  UriSerializer,
  UsageMarker,
  UserJoinedOrLeftRoomModel,
  VERSION,
  VariantAction,
  VelocityOverLifetimeModule,
  VerticalLayoutGroup,
  VideoPlayer,
  ViewDevice,
  Vignette,
  VisibilityAction,
  Voip,
  Volume,
  VolumeParameter,
  VolumeProfile,
  WaitForFrames,
  WaitForPromise,
  WaitForSeconds,
  Watch,
  WebARCameraBackground,
  WebARSessionRoot,
  WebXR,
  WebXRButtonFactory,
  WebXRImageTracking,
  WebXRImageTrackingModel,
  WebXRPlaneTracking,
  WebXRTrackedImage,
  XRControllerFollow,
  XRControllerModel,
  XRControllerMovement,
  XRFlag,
  XRRig,
  XRState,
  XRStateFlag,
  __Ignore,
  __internalNotifyObjectDestroyed,
  activeInHierarchyFieldName,
  addAttributeChangeCallback,
  addComponent,
  addCustomExtensionPlugin,
  addGltfLoadEventListener,
  addNewComponent,
  addPatch,
  apply,
  applyHMRChanges,
  applyPrototypeExtensions,
  beginListenDestroy,
  beginListenInstantiate,
  binaryIdentifierCasts,
  build_scene_functions,
  builtinComponentKeyName,
  calculateProgress01,
  clearMessages as clearBalloonMessages,
  clearMessages as clearOverlayMessages,
  colorSerializer,
  compareAssociation,
  componentSerializer,
  copyTexture,
  createLoader,
  createMotion,
  debugNet,
  debugOwner,
  deepClone,
  delay,
  delayForFrames,
  deserializeObject,
  destroy,
  destroyComponentInstance,
  disposeObjectResources,
  disposeStream,
  editorGuidKeyName,
  effectsOrder,
  enableSpatialConsole,
  euler,
  eventListSerializer,
  exportAsGLTF,
  findByGuid,
  findObjectOfType,
  findObjectsOfType,
  findResourceUsers,
  fitObjectIntoVolume,
  foreachComponent,
  foreachComponentEnumerator,
  forward,
  generateQRCode,
  generateSeed,
  getBoundingBox,
  getCameraController,
  getComponent,
  getComponentInChildren,
  getComponentInParent,
  getComponents,
  getComponentsInChildren,
  getComponentsInParent,
  getFormattedDate,
  getIconElement,
  getIconTexture,
  getIp,
  getIpAndLocation,
  getIpCloudflare,
  getLoader,
  getOrAddComponent,
  getParam,
  getParentHierarchyPath,
  getPath,
  getPeerOptions,
  getPeerjsInstance,
  getResourceUserCount,
  getTempColor,
  getTempQuaternion,
  getTempVector,
  getUrlParams,
  getVisibleInCustomShadowRendering,
  getWorldDirection,
  getWorldEuler,
  getWorldPosition,
  getWorldQuaternion,
  getWorldRotation,
  getWorldScale,
  hasCommercialLicense,
  hasIndieLicense,
  hasPointerEventComponent,
  hasProLicense,
  hideDebugConsole,
  imageToCanvas,
  instantiate,
  invokeAfterImportPluginHooks,
  invokeXRSessionEnd,
  invokeXRSessionStart,
  isActiveInHierarchy,
  isActiveSelf,
  isAndroidDevice,
  isAnimationAction,
  isComponent,
  isDebugMode,
  isDesktop,
  isDestroyed,
  isDevEnvironment,
  isDisposed,
  isExporting,
  isHostedOnGlitch,
  isHotReloading,
  isIPad,
  isIconElement,
  isLocalNetwork,
  isMacOS,
  isMobileDevice,
  isMozillaXR,
  isQuest,
  isResourceTrackingEnabled,
  isSafari,
  isUsingInstancing,
  isiOS,
  isiPad,
  loadSync,
  logHierarchy,
  lookAtInverse,
  lookAtObject,
  makeId,
  makeIdFromRandomWords,
  makeNameSafe as makeNameSafeForUSD,
  markAsInstancedRendered,
  microphonePermissionsGranted,
  nameof,
  nameofFactory,
  objectSerializer,
  offXRSessionEnd,
  offXRSessionStart,
  onAfterRender,
  onBeforeRender,
  onClear,
  onDestroy,
  onInitialized,
  onStart,
  onUpdate,
  onXRSessionEnd,
  onXRSessionStart,
  parseSync,
  placeOnSurface,
  postprocessFBXMaterials,
  prefix,
  pushState,
  randomNumber,
  registerBinaryType,
  registerComponent,
  registerComponentExtension,
  registerCustomEffectType,
  registerExportExtensions,
  registerExtensions,
  registerHotReloadType,
  registerLoader,
  registerPrefabProvider,
  registerPrototypeExtensions,
  registerType,
  relativePathPrefix,
  removeAttributeChangeCallback,
  removeComponent,
  removeCustomImportExtensionType,
  removeGltfLoadEventListener,
  removePatch,
  resolveUrl,
  sanitizeString,
  saveImage,
  screenshot,
  screenshot2,
  sendDestroyed,
  serializable,
  serializeObject,
  serializeable,
  setActive,
  setAllowBalloonMessages,
  setAllowOverlayMessages,
  setAutoFitEnabled,
  setCameraController,
  setDestroyed,
  setDevEnvironment,
  setDisposable,
  setDontDestroy,
  setOrAddParamsToUrl,
  setParam,
  setParamWithoutReload,
  setPeerOptions,
  setResourceTrackingEnabled,
  setState,
  setVisibleInCustomShadowRendering,
  setWorldEuler,
  setWorldPosition,
  setWorldPositionXYZ,
  setWorldQuaternion,
  setWorldQuaternionXYZW,
  setWorldRotation,
  setWorldRotationXYZ,
  setWorldScale,
  showBalloonError,
  showBalloonMessage,
  showBalloonWarning,
  showDebugConsole,
  slerp,
  syncDestroy,
  syncField,
  syncInstantiate,
  textureToCanvas,
  tryCastBinary,
  tryDetermineFileTypeFromBinary,
  tryDetermineFileTypeFromURL,
  tryFindObject,
  tryGetGuid,
  unregisterHotReloadType,
  unwatchWrite,
  useForAutoFit,
  validate,
  watchWrite
};
//# sourceMappingURL=@needle-tools_engine.js.map
