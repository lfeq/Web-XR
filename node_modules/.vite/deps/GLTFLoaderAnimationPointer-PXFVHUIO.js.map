{
  "version": 3,
  "sources": ["../../three/examples/jsm/loaders/GLTFLoaderAnimationPointer.js"],
  "sourcesContent": ["import {\r\n\tAnimationClip,\r\n\tColorKeyframeTrack,\r\n\tInterpolateDiscrete,\r\n\tInterpolateLinear,\r\n\tNumberKeyframeTrack,\r\n\tPropertyBinding,\r\n\tQuaternionKeyframeTrack,\r\n\tVectorKeyframeTrack,\r\n\tSkinnedMesh\r\n} from 'three';\r\n\r\n// DUPLICATED from GLTFLoader.js\r\nconst ANIMATION_TARGET_TYPE = {\r\n\tnode: 'node',\r\n\tmaterial: 'material',\r\n\tcamera: 'camera',\r\n\tlight: 'light',\r\n};\r\n\r\nconst KHR_ANIMATION_POINTER = 'KHR_animation_pointer';\r\n\r\n// DUPLICATED from GLTFLoader.js\r\nconst INTERPOLATION = {\r\n\t// We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\r\n\t// keyframe track will be initialized with a default interpolation type, then modified.\r\n\tCUBICSPLINE: undefined,\r\n\tLINEAR: InterpolateLinear,\r\n\tSTEP: InterpolateDiscrete\r\n};\r\n\r\n// HACK monkey patching findNode to ensure we can map to other types required by KHR_animation_pointer.\r\nconst find = PropertyBinding.findNode;\r\nconst _animationPointerDebug = false;\r\nlet _havePatchedPropertyBindings = false;\r\n\r\n/**\r\n * Animation Pointer Extension\r\n *\r\n * Draft Specification: https://github.com/ux3d/glTF/tree/extensions/KHR_animation_pointer/extensions/2.0/Khronos/KHR_animation_pointer\r\n */\r\nclass GLTFAnimationPointerExtension {\r\n\r\n\tconstructor( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = KHR_ANIMATION_POINTER;\r\n\t\tthis.animationPointerResolver = null;\r\n\r\n\t}\r\n\r\n\tsetAnimationPointerResolver( animationPointerResolver ) {\r\n\r\n\t\tthis.animationPointerResolver = animationPointerResolver;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t_patchPropertyBindingFindNode() {\r\n\r\n\t\tif ( _havePatchedPropertyBindings ) return;\r\n\t\t_havePatchedPropertyBindings = true;\r\n\r\n\t\t// \"node\" is the Animator component in our case\r\n\t\t// \"path\" is the animated property path, just with translated material names.\r\n\t\tPropertyBinding.findNode = function ( node, path ) {\r\n\r\n\t\t\tif ( path.startsWith( '.materials.' ) ) {\r\n\r\n\t\t\t\tif ( _animationPointerDebug ) console.log( 'FIND', path );\r\n\r\n\t\t\t\tconst remainingPath = path.substring( '.materials.'.length ).substring( path.indexOf( '.' ) );\r\n\t\t\t\tconst nextIndex = remainingPath.indexOf( '.' );\r\n\t\t\t\tconst uuid = nextIndex < 0 ? remainingPath : remainingPath.substring( 0, nextIndex );\r\n\t\t\t\tlet res = null;\r\n\t\t\t\tnode.traverse( x => {\r\n\r\n\t\t\t\t\tif ( res !== null || ( x.type !== 'Mesh' && x.type !== 'SkinnedMesh' ) ) return;\r\n\t\t\t\t\tif ( x[ 'material' ] && ( x[ 'material' ].uuid === uuid || x[ 'material' ].name === uuid ) ) {\r\n\r\n\t\t\t\t\t\tres = x[ 'material' ];\r\n\t\t\t\t\t\tif ( _animationPointerDebug ) console.log( res, remainingPath );\r\n\t\t\t\t\t\tif ( res !== null ) {\r\n\r\n\t\t\t\t\t\t\tif ( remainingPath.endsWith( '.map' ) )\r\n\t\t\t\t\t\t\t\tres = res[ 'map' ];\r\n\t\t\t\t\t\t\telse if ( remainingPath.endsWith( '.emissiveMap' ) )\r\n\t\t\t\t\t\t\t\tres = res[ 'emissiveMap' ];\r\n\r\n\t\t\t\t\t\t\t// TODO other texture slots only make sense if three.js actually supports them\r\n\t\t\t\t\t\t\t// (currently only .map can have repeat/offset)\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t\treturn res;\r\n\r\n\t\t\t} else if ( path.startsWith( '.nodes.' ) || path.startsWith( '.lights.' ) || path.startsWith( '.cameras.' ) ) {\r\n\r\n\t\t\t\tconst sections = path.split( '.' );\r\n\t\t\t\tlet currentTarget = undefined;\r\n\t\t\t\tfor ( let i = 1; i < sections.length; i ++ ) {\r\n\r\n\t\t\t\t\tconst val = sections[ i ];\r\n\t\t\t\t\tconst isUUID = val.length == 36;\r\n\t\t\t\t\tif ( isUUID ) {\r\n\r\n\t\t\t\t\t\t// access by UUID\r\n\t\t\t\t\t\tcurrentTarget = node.getObjectByProperty( 'uuid', val );\r\n\r\n\t\t\t\t\t} else if ( currentTarget && currentTarget[ val ] ) {\r\n\r\n\t\t\t\t\t\t// access by index\r\n\t\t\t\t\t\tconst index = Number.parseInt( val );\r\n\t\t\t\t\t\tlet key = val;\r\n\t\t\t\t\t\tif ( index >= 0 ) key = index;\r\n\t\t\t\t\t\tcurrentTarget = currentTarget[ key ];\r\n\t\t\t\t\t\tif ( _animationPointerDebug )\r\n\t\t\t\t\t\t\tconsole.log( currentTarget );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// access by node name\r\n\t\t\t\t\t\tconst foundNode = node.getObjectByName( val );\r\n\r\n\t\t\t\t\t\tif ( foundNode )\r\n\t\t\t\t\t\t\tcurrentTarget = foundNode;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( ! currentTarget ) {\r\n\r\n\t\t\t\t\tconst originalFindResult = find( node, sections[ 2 ] );\r\n\r\n\t\t\t\t\tif ( ! originalFindResult )\r\n\t\t\t\t\t\tconsole.warn( KHR_ANIMATION_POINTER + ': Property binding not found', path, node, node.name, sections );\r\n\r\n\t\t\t\t\treturn originalFindResult;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( _animationPointerDebug )\r\n\t\t\t\t\tconsole.log( 'NODE', path, currentTarget );\r\n\r\n\t\t\t\treturn currentTarget;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn find( node, path );\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n\t/* DUPLICATE of functionality in GLTFLoader */\r\n\tloadAnimationTargetFromChannel( animationChannel ) {\r\n\r\n\t\tconst target = animationChannel.target;\r\n\t\tconst name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\r\n\t\treturn this.parser.getDependency( 'node', name );\r\n\r\n\t}\r\n\r\n\tloadAnimationTargetFromChannelWithAnimationPointer( animationChannel ) {\r\n\r\n\t\tif ( ! this._havePatchedPropertyBindings )\r\n\t\t\tthis._patchPropertyBindingFindNode();\r\n\r\n\t\tconst target = animationChannel.target;\r\n\t\tconst useExtension = target.extensions && target.extensions[ KHR_ANIMATION_POINTER ] && target.path && target.path === 'pointer';\r\n\t\tif ( ! useExtension ) return null;\r\n\r\n\t\tlet targetProperty = undefined;\r\n\r\n\t\t// check if this is a extension animation\r\n\t\tlet type = ANIMATION_TARGET_TYPE.node;\r\n\t\tlet targetId = undefined;\r\n\r\n\t\tif ( useExtension ) {\r\n\r\n\t\t\tconst ext = target.extensions[ KHR_ANIMATION_POINTER ];\r\n\t\t\tlet path = ext.pointer;\r\n\t\t\tif ( _animationPointerDebug )\r\n\t\t\t\tconsole.log( 'Original path: ' + path, target );\r\n\r\n\t\t\tif ( ! path ) {\r\n\r\n\t\t\t\tconsole.warn( 'Invalid path', ext, target );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( path.startsWith( '/materials/' ) )\r\n\t\t\t\ttype = ANIMATION_TARGET_TYPE.material;\r\n\t\t\telse if ( path.startsWith( '/extensions/KHR_lights_punctual/lights/' ) )\r\n\t\t\t\ttype = ANIMATION_TARGET_TYPE.light;\r\n\t\t\telse if ( path.startsWith( '/cameras/' ) )\r\n\t\t\t\ttype = ANIMATION_TARGET_TYPE.camera;\r\n\r\n\t\t\ttargetId = this._tryResolveTargetId( path, type );\r\n\t\t\tif ( targetId === null || isNaN( targetId ) ) {\r\n\r\n\t\t\t\tconsole.warn( 'Failed resolving animation node id: ' + targetId, path );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( _animationPointerDebug ) console.log( 'Resolved node ID for ' + type, targetId );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// TODO could be parsed better\r\n\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\tcase ANIMATION_TARGET_TYPE.material:\r\n\t\t\t\t\tconst pathIndex = ( '/materials/' + targetId.toString() + '/' ).length;\r\n\t\t\t\t\tconst pathStart = path.substring( 0, pathIndex );\r\n\t\t\t\t\ttargetProperty = path.substring( pathIndex );\r\n\r\n\t\t\t\t\tswitch ( targetProperty ) {\r\n\r\n\t\t\t\t\t\t// Core Spec PBR Properties\r\n\t\t\t\t\t\tcase 'pbrMetallicRoughness/baseColorFactor':\r\n\t\t\t\t\t\t\ttargetProperty = 'color';\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'pbrMetallicRoughness/roughnessFactor':\r\n\t\t\t\t\t\t\ttargetProperty = 'roughness';\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'pbrMetallicRoughness/metallicFactor':\r\n\t\t\t\t\t\t\ttargetProperty = 'metalness';\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'emissiveFactor':\r\n\t\t\t\t\t\t\ttargetProperty = 'emissive';\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'alphaCutoff':\r\n\t\t\t\t\t\t\ttargetProperty = 'alphaTest';\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'occlusionTexture/strength':\r\n\t\t\t\t\t\t\ttargetProperty = 'aoMapIntensity';\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'normalTexture/scale':\r\n\t\t\t\t\t\t\ttargetProperty = 'normalScale';\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t// Core Spec + KHR_texture_transform\r\n\t\t\t\t\t\tcase 'pbrMetallicRoughness/baseColorTexture/extensions/KHR_texture_transform/scale':\r\n\t\t\t\t\t\t\ttargetProperty = 'map/repeat';\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'pbrMetallicRoughness/baseColorTexture/extensions/KHR_texture_transform/offset':\r\n\t\t\t\t\t\t\ttargetProperty = 'map/offset';\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t// UV transforms for anything but map doesn't seem to currently be supported in three.js\r\n\t\t\t\t\t\tcase 'emissiveTexture/extensions/KHR_texture_transform/scale':\r\n\t\t\t\t\t\t\ttargetProperty = 'emissiveMap/repeat';\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'emissiveTexture/extensions/KHR_texture_transform/offset':\r\n\t\t\t\t\t\t\ttargetProperty = 'emissiveMap/offset';\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t// KHR_materials_emissive_strength\r\n\t\t\t\t\t\tcase 'extensions/KHR_materials_emissive_strength/emissiveStrength':\r\n\t\t\t\t\t\t\ttargetProperty = 'emissiveIntensity';\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t// KHR_materials_transmission\r\n\t\t\t\t\t\tcase 'extensions/KHR_materials_transmission/transmissionFactor':\r\n\t\t\t\t\t\t\ttargetProperty = 'transmission';\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t// KHR_materials_ior\r\n\t\t\t\t\t\tcase 'extensions/KHR_materials_ior/ior':\r\n\t\t\t\t\t\t\ttargetProperty = 'ior';\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t// KHR_materials_volume\r\n\t\t\t\t\t\tcase 'extensions/KHR_materials_volume/thicknessFactor':\r\n\t\t\t\t\t\t\ttargetProperty = 'thickness';\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'extensions/KHR_materials_volume/attenuationColor':\r\n\t\t\t\t\t\t\ttargetProperty = 'attenuationColor';\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'extensions/KHR_materials_volume/attenuationDistance':\r\n\t\t\t\t\t\t\ttargetProperty = 'attenuationDistance';\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t// KHR_materials_iridescence\r\n\t\t\t\t\t\tcase 'extensions/KHR_materials_iridescence/iridescenceFactor':\r\n\t\t\t\t\t\t\ttargetProperty = 'iridescence';\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'extensions/KHR_materials_iridescence/iridescenceIor':\r\n\t\t\t\t\t\t\ttargetProperty = 'iridescenceIOR';\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'extensions/KHR_materials_iridescence/iridescenceThicknessMinimum':\r\n\t\t\t\t\t\t\ttargetProperty = 'iridescenceThicknessRange[0]';\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'extensions/KHR_materials_iridescence/iridescenceThicknessMaximum':\r\n\t\t\t\t\t\t\ttargetProperty = 'iridescenceThicknessRange[1]';\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t// KHR_materials_clearcoat\r\n\t\t\t\t\t\tcase 'extensions/KHR_materials_clearcoat/clearcoatFactor':\r\n\t\t\t\t\t\t\ttargetProperty = 'clearcoat';\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'extensions/KHR_materials_clearcoat/clearcoatRoughnessFactor':\r\n\t\t\t\t\t\t\ttargetProperty = 'clearcoatRoughness';\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t// KHR_materials_sheen\r\n\t\t\t\t\t\tcase 'extensions/KHR_materials_sheen/sheenColorFactor':\r\n\t\t\t\t\t\t\ttargetProperty = 'sheenColor';\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'extensions/KHR_materials_sheen/sheenRoughnessFactor':\r\n\t\t\t\t\t\t\ttargetProperty = 'sheenRoughness';\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t// KHR_materials_specular\r\n\t\t\t\t\t\tcase 'extensions/KHR_materials_specular/specularFactor':\r\n\t\t\t\t\t\t\ttargetProperty = 'specularIntensity';\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'extensions/KHR_materials_specular/specularColorFactor':\r\n\t\t\t\t\t\t\ttargetProperty = 'specularColor';\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tpath = pathStart + targetProperty;\r\n\t\t\t\t\tif ( _animationPointerDebug ) console.log( 'PROPERTY PATH', pathStart, targetProperty, path );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase ANIMATION_TARGET_TYPE.node:\r\n\t\t\t\t\tconst pathIndexNode = ( '/nodes/' + targetId.toString() + '/' ).length;\r\n\t\t\t\t\tconst pathStartNode = path.substring( 0, pathIndexNode );\r\n\t\t\t\t\ttargetProperty = path.substring( pathIndexNode );\r\n\r\n\t\t\t\t\tswitch ( targetProperty ) {\r\n\r\n\t\t\t\t\t\tcase 'translation':\r\n\t\t\t\t\t\t\ttargetProperty = 'position';\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'rotation':\r\n\t\t\t\t\t\t\ttargetProperty = 'quaternion';\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'scale':\r\n\t\t\t\t\t\t\ttargetProperty = 'scale';\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'weights':\r\n\t\t\t\t\t\t\ttargetProperty = 'morphTargetInfluences';\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tpath = pathStartNode + targetProperty;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase ANIMATION_TARGET_TYPE.light:\r\n\t\t\t\t\tconst pathIndexLight = ( '/extensions/KHR_lights_punctual/lights/' + targetId.toString() + '/' ).length;\r\n\t\t\t\t\ttargetProperty = path.substring( pathIndexLight );\r\n\r\n\t\t\t\t\tswitch ( targetProperty ) {\r\n\r\n\t\t\t\t\t\tcase 'color':\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'intensity':\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'spot/innerConeAngle':\r\n\t\t\t\t\t\t\t// TODO would need to set .penumbra, but requires calculations on every animation change (?)\r\n\t\t\t\t\t\t\ttargetProperty = 'penumbra';\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'spot/outerConeAngle':\r\n\t\t\t\t\t\t\ttargetProperty = 'angle';\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'range':\r\n\t\t\t\t\t\t\ttargetProperty = 'distance';\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tpath = '/lights/' + targetId.toString() + '/' + targetProperty;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase ANIMATION_TARGET_TYPE.camera:\r\n\t\t\t\t\tconst pathIndexCamera = ( '/cameras/' + targetId.toString() + '/' ).length;\r\n\t\t\t\t\tconst pathStartCamera = path.substring( 0, pathIndexCamera );\r\n\t\t\t\t\ttargetProperty = path.substring( pathIndexCamera );\r\n\r\n\t\t\t\t\tswitch ( targetProperty ) {\r\n\r\n\t\t\t\t\t\tcase 'perspective/yfov':\r\n\t\t\t\t\t\t\ttargetProperty = 'fov';\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'perspective/znear':\r\n\t\t\t\t\t\tcase 'orthographic/znear':\r\n\t\t\t\t\t\t\ttargetProperty = 'near';\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'perspective/zfar':\r\n\t\t\t\t\t\tcase 'orthographic/zfar':\r\n\t\t\t\t\t\t\ttargetProperty = 'far';\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'perspective/aspect':\r\n\t\t\t\t\t\t\ttargetProperty = 'aspect';\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t// these two write to the same target property since three.js orthographic camera only supports 'zoom'.\r\n\t\t\t\t\t\t// TODO should there be a warning for either of them? E.g. a warning for \"xmag\" so that \"yfov\" + \"ymag\" work by default?\r\n\t\t\t\t\t\tcase 'orthographic/xmag':\r\n\t\t\t\t\t\t\ttargetProperty = 'zoom';\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'orthographic/ymag':\r\n\t\t\t\t\t\t\ttargetProperty = 'zoom';\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tpath = pathStartCamera + targetProperty;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst pointerResolver = this.animationPointerResolver;\r\n\t\t\tif ( pointerResolver && pointerResolver.resolvePath ) {\r\n\r\n\t\t\t\tpath = pointerResolver.resolvePath( path );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttarget.extensions[ KHR_ANIMATION_POINTER ].pointer = path;\r\n\r\n\t\t}\r\n\r\n\t\tif ( targetId === null || isNaN( targetId ) ) {\r\n\r\n\t\t\tconsole.warn( 'Failed resolving animation node id: ' + targetId, target );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tlet depPromise;\r\n\r\n\t\tif ( type === ANIMATION_TARGET_TYPE.node )\r\n\t\t\tdepPromise = this.parser.getDependency( 'node', targetId );\r\n\t\telse if ( type === ANIMATION_TARGET_TYPE.material )\r\n\t\t\tdepPromise = this.parser.getDependency( 'material', targetId );\r\n\t\telse if ( type === ANIMATION_TARGET_TYPE.light )\r\n\t\t\tdepPromise = this.parser.getDependency( 'light', targetId );\r\n\t\telse if ( type === ANIMATION_TARGET_TYPE.camera )\r\n\t\t\tdepPromise = this.parser.getDependency( 'camera', targetId );\r\n\t\telse\r\n\t\t\tconsole.error( 'Unhandled type', type );\r\n\r\n\t\treturn depPromise;\r\n\r\n\t}\r\n\r\n\tcreateAnimationTracksWithAnimationPointer( node, inputAccessor, outputAccessor, sampler, target ) {\r\n\r\n\t\tconst useExtension = target.extensions && target.extensions[ KHR_ANIMATION_POINTER ] && target.path && target.path === 'pointer';\r\n\t\tif ( ! useExtension ) return null;\r\n\r\n\t\tlet animationPointerPropertyPath = target.extensions[ KHR_ANIMATION_POINTER ].pointer;\r\n\t\tif ( ! animationPointerPropertyPath ) return null;\r\n\r\n\t\tconst tracks = [];\r\n\r\n\t\tanimationPointerPropertyPath = animationPointerPropertyPath.replaceAll( '/', '.' );\r\n\t\t// replace node/material/camera/light ID by UUID\r\n\t\tconst parts = animationPointerPropertyPath.split( '.' );\r\n\t\tconst hasName = node.name !== undefined && node.name !== null;\r\n\t\tvar nodeTargetName = hasName ? node.name : node.uuid;\r\n\t\tparts[ 2 ] = nodeTargetName;\r\n\r\n\t\t// specially handle the morphTargetInfluences property for multi-material meshes\r\n\t\t// in which case the target object is a Group and the children are the actual targets\r\n\t\t// see NE-3311\r\n\t\tif ( parts[ 3 ] === 'morphTargetInfluences' ) {\r\n\r\n\t\t\tif ( node.type === 'Group' ) {\r\n\r\n\t\t\t\tif ( _animationPointerDebug )\r\n\t\t\t\t\tconsole.log( 'Detected multi-material skinnedMesh export', animationPointerPropertyPath, node );\r\n\r\n\t\t\t\t// We assume the children are skinned meshes\r\n\t\t\t\tfor ( const ch of node.children ) {\r\n\r\n\t\t\t\t\tif ( ch instanceof SkinnedMesh && ch.morphTargetInfluences ) {\r\n\r\n\t\t\t\t\t\tparts[ 3 ] = ch.name;\r\n\t\t\t\t\t\tparts[ 4 ] = 'morphTargetInfluences';\r\n\t\t\t\t\t\t__createTrack( this.parser );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn tracks;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// default\r\n\t\t__createTrack( this.parser );\r\n\r\n\t\t/** Create a new track using the current parts array */\r\n\t\tfunction __createTrack( parser ) {\r\n\r\n\t\t\tanimationPointerPropertyPath = parts.join( '.' );\r\n\r\n\t\t\tif ( _animationPointerDebug )\r\n\t\t\t\tconsole.log( node, inputAccessor, outputAccessor, target, animationPointerPropertyPath );\r\n\r\n\t\t\tlet TypedKeyframeTrack;\r\n\r\n\t\t\tswitch ( outputAccessor.itemSize ) {\r\n\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\tTypedKeyframeTrack = NumberKeyframeTrack;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 2:\r\n\t\t\t\tcase 3:\r\n\t\t\t\t\tTypedKeyframeTrack = VectorKeyframeTrack;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 4:\r\n\r\n\t\t\t\t\tif ( animationPointerPropertyPath.endsWith( '.quaternion' ) )\r\n\t\t\t\t\t\tTypedKeyframeTrack = QuaternionKeyframeTrack;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tTypedKeyframeTrack = ColorKeyframeTrack;\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;\r\n\r\n\t\t\tlet outputArray = parser._getArrayFromAccessor( outputAccessor );\r\n\r\n\t\t\t// convert fov values from radians to degrees\r\n\t\t\tif ( animationPointerPropertyPath.endsWith( '.fov' ) ) {\r\n\r\n\t\t\t\toutputArray = outputArray.map( value => value / Math.PI * 180 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst track = new TypedKeyframeTrack(\r\n\t\t\t\tanimationPointerPropertyPath,\r\n\t\t\t\tinputAccessor.array,\r\n\t\t\t\toutputArray,\r\n\t\t\t\tinterpolation\r\n\t\t\t);\r\n\r\n\t\t\t// Override interpolation with custom factory method.\r\n\t\t\tif ( interpolation === 'CUBICSPLINE' ) {\r\n\r\n\t\t\t\tparser._createCubicSplineTrackInterpolant( track );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttracks.push( track );\r\n\r\n\t\t\t// glTF has opacity animation as last component of baseColorFactor,\r\n\t\t\t// so we need to split that up here and create a separate opacity track if that is animated.\r\n\t\t\tif ( animationPointerPropertyPath && outputAccessor.itemSize === 4 &&\r\n\t\t\t\tanimationPointerPropertyPath.startsWith( '.materials.' ) && animationPointerPropertyPath.endsWith( '.color' ) ) {\r\n\r\n\t\t\t\tconst opacityArray = new Float32Array( outputArray.length / 4 );\r\n\r\n\t\t\t\tfor ( let j = 0, jl = outputArray.length / 4; j < jl; j += 1 ) {\r\n\r\n\t\t\t\t\topacityArray[ j ] = outputArray[ j * 4 + 3 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst opacityTrack = new TypedKeyframeTrack(\r\n\t\t\t\t\tanimationPointerPropertyPath.replace( '.color', '.opacity' ),\r\n\t\t\t\t\tinputAccessor.array,\r\n\t\t\t\t\topacityArray,\r\n\t\t\t\t\tinterpolation\r\n\t\t\t\t);\r\n\r\n\t\t\t\t// Override interpolation with custom factory method.\r\n\t\t\t\tif ( interpolation === 'CUBICSPLINE' ) {\r\n\r\n\t\t\t\t\tparser._createCubicSplineTrackInterpolant( track );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttracks.push( opacityTrack );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn tracks;\r\n\r\n\t}\r\n\r\n\t_tryResolveTargetId( path, type ) {\r\n\r\n\t\tlet name = '';\r\n\t\tif ( type === 'node' ) {\r\n\r\n\t\t\tname = path.substring( '/nodes/'.length );\r\n\r\n\t\t} else if ( type === 'material' ) {\r\n\r\n\t\t\tname = path.substring( '/materials/'.length );\r\n\r\n\t\t} else if ( type === 'light' ) {\r\n\r\n\t\t\tname = path.substring( '/extensions/KHR_lights_punctual/lights/'.length );\r\n\r\n\t\t} else if ( type === 'camera' ) {\r\n\r\n\t\t\tname = path.substring( '/cameras/'.length );\r\n\r\n\t\t}\r\n\r\n\t\tname = name.substring( 0, name.indexOf( '/' ) );\r\n\t\tconst index = Number.parseInt( name );\r\n\t\treturn index;\r\n\r\n\t}\r\n\r\n\t/* MOSTLY DUPLICATE of GLTFLoader.loadAnimation, but also tries to resolve KHR_animation_pointer. */\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\r\n\t * @param {number} animationIndex\r\n\t * @return {Promise<AnimationClip>}\r\n\t */\r\n\tloadAnimation( animationIndex ) {\r\n\r\n\t\tconst me = this;\r\n\t\tconst json = this.parser.json;\r\n\t\tconst parser = this.parser;\r\n\r\n\t\tconst animationDef = json.animations[ animationIndex ];\r\n\t\tconst animationName = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\r\n\r\n\t\tconst pendingNodes = [];\r\n\t\tconst pendingInputAccessors = [];\r\n\t\tconst pendingOutputAccessors = [];\r\n\t\tconst pendingSamplers = [];\r\n\t\tconst pendingTargets = [];\r\n\r\n\t\tfor ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {\r\n\r\n\t\t\tconst channel = animationDef.channels[ i ];\r\n\t\t\tconst sampler = animationDef.samplers[ channel.sampler ];\r\n\t\t\tconst target = channel.target;\r\n\t\t\tconst input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;\r\n\t\t\tconst output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;\r\n\r\n\t\t\tlet nodeDependency = me.loadAnimationTargetFromChannelWithAnimationPointer( channel );\r\n\t\t\tif ( ! nodeDependency )\r\n\t\t\t\tnodeDependency = me.loadAnimationTargetFromChannel( channel );\r\n\r\n\t\t\tpendingNodes.push( nodeDependency );\r\n\t\t\tpendingInputAccessors.push( parser.getDependency( 'accessor', input ) );\r\n\t\t\tpendingOutputAccessors.push( parser.getDependency( 'accessor', output ) );\r\n\t\t\tpendingSamplers.push( sampler );\r\n\t\t\tpendingTargets.push( target );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( [\r\n\r\n\t\t\tPromise.all( pendingNodes ),\r\n\t\t\tPromise.all( pendingInputAccessors ),\r\n\t\t\tPromise.all( pendingOutputAccessors ),\r\n\t\t\tPromise.all( pendingSamplers ),\r\n\t\t\tPromise.all( pendingTargets )\r\n\r\n\t\t] ).then( function ( dependencies ) {\r\n\r\n\t\t\tconst nodes = dependencies[ 0 ];\r\n\t\t\tconst inputAccessors = dependencies[ 1 ];\r\n\t\t\tconst outputAccessors = dependencies[ 2 ];\r\n\t\t\tconst samplers = dependencies[ 3 ];\r\n\t\t\tconst targets = dependencies[ 4 ];\r\n\r\n\t\t\tconst tracks = [];\r\n\r\n\t\t\tfor ( let i = 0, il = nodes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tconst node = nodes[ i ];\r\n\t\t\t\tconst inputAccessor = inputAccessors[ i ];\r\n\t\t\t\tconst outputAccessor = outputAccessors[ i ];\r\n\t\t\t\tconst sampler = samplers[ i ];\r\n\t\t\t\tconst target = targets[ i ];\r\n\r\n\t\t\t\tif ( node === undefined ) continue;\r\n\r\n\t\t\t\tif ( node.updateMatrix ) {\r\n\r\n\t\t\t\t\tnode.updateMatrix();\r\n\t\t\t\t\tnode.matrixAutoUpdate = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet createdTracks = me.createAnimationTracksWithAnimationPointer( node, inputAccessor, outputAccessor, sampler, target );\r\n\t\t\t\tif ( ! createdTracks )\r\n\t\t\t\t\tcreatedTracks = parser._createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target );\r\n\r\n\t\t\t\tif ( createdTracks ) {\r\n\r\n\t\t\t\t\tfor ( let k = 0; k < createdTracks.length; k ++ ) {\r\n\r\n\t\t\t\t\t\ttracks.push( createdTracks[ k ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn new AnimationClip( animationName, undefined, tracks );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { GLTFAnimationPointerExtension };\r\n"],
  "mappings": "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",
  "names": []
}
