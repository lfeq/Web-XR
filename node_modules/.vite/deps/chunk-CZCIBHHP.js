import {
  $70d766613f57b014$export$2e2bcd8739ae039
} from "./chunk-GTWKTLO2.js";
import {
  EXRLoader,
  strToU8,
  unzlibSync,
  zipSync
} from "./chunk-EPW5EEUB.js";
import {
  RGBELoader
} from "./chunk-DFYYBEIV.js";
import {
  ACESFilmicToneMapping,
  AdditiveBlending,
  AgXToneMapping,
  AlwaysDepth,
  AlwaysStencilFunc,
  AmbientLight,
  AnimationClip,
  AnimationMixer,
  ArrayCamera,
  Audio as Audio2,
  AudioListener,
  AudioLoader,
  AxesHelper,
  BackSide,
  BasicDepthPacking,
  BasicNodeLibrary,
  BatchedMesh,
  Bone,
  Box3,
  Box3Helper,
  BoxGeometry,
  BoxHelper,
  BufferAttribute as BufferAttribute2,
  BufferGeometry,
  Camera,
  CameraHelper,
  CanvasTexture,
  ClampToEdgeWrapping,
  Clock,
  Color,
  ColorManagement,
  CompressedArrayTexture,
  CompressedCubeTexture,
  CompressedTexture,
  Controls,
  CubeCamera,
  CubeTexture,
  Curve,
  CustomBlending,
  CylinderGeometry,
  Data3DTexture,
  DataTexture,
  DecrementStencilOp,
  DecrementWrapStencilOp,
  DefaultLoadingManager,
  DepthStencilFormat,
  DepthTexture,
  DirectionalLight,
  DirectionalLightHelper,
  DisplayP3ColorSpace,
  DoubleSide,
  DynamicDrawUsage,
  EdgesGeometry,
  EqualDepth,
  EqualStencilFunc,
  EquirectangularReflectionMapping,
  EquirectangularRefractionMapping,
  Euler,
  EventDispatcher,
  ExtrudeGeometry,
  FileLoader,
  Float32BufferAttribute as Float32BufferAttribute2,
  FloatType,
  Fog,
  FrontSide,
  Frustum,
  GLSL3,
  GreaterDepth,
  GreaterEqualDepth,
  GreaterEqualStencilFunc,
  GreaterStencilFunc,
  GridHelper,
  Group,
  HalfFloatType,
  HemisphereLight,
  ImageBitmapLoader,
  IncrementStencilOp,
  IncrementWrapStencilOp,
  InstancedBufferAttribute as InstancedBufferAttribute2,
  InstancedBufferGeometry,
  InstancedInterleavedBuffer,
  InstancedMesh,
  InterleavedBuffer as InterleavedBuffer2,
  InterleavedBufferAttribute as InterleavedBufferAttribute2,
  Interpolant,
  InterpolateDiscrete,
  InterpolateLinear,
  InvertStencilOp,
  KeepStencilOp,
  LOD,
  Layers,
  LessDepth,
  LessEqualDepth,
  LessEqualStencilFunc,
  LessStencilFunc,
  Line,
  Line3,
  LineBasicMaterial,
  LineLoop,
  LineSegments,
  LinearDisplayP3ColorSpace,
  LinearFilter,
  LinearMipmapLinearFilter,
  LinearMipmapNearestFilter,
  LinearSRGBColorSpace,
  LinearToneMapping,
  Loader,
  LoaderUtils,
  LoadingManager,
  LoopOnce,
  LoopRepeat,
  LuminanceFormat,
  MOUSE,
  Material,
  MathUtils,
  Matrix3,
  Matrix4,
  MaxEquation,
  Mesh,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshLambertMaterial,
  MeshNormalMaterial,
  MeshPhongMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MirroredRepeatWrapping,
  NearestFilter,
  NearestMipmapLinearFilter,
  NearestMipmapNearestFilter,
  NeutralToneMapping,
  NeverDepth,
  NeverStencilFunc,
  NoBlending,
  NoColorSpace,
  NoToneMapping,
  NodeFrame,
  NormalBlending,
  NotEqualDepth,
  NotEqualStencilFunc,
  NumberKeyframeTrack,
  Object3D,
  OctahedronGeometry,
  OrthographicCamera,
  PCFSoftShadowMap$1,
  PerspectiveCamera,
  Plane,
  PlaneGeometry,
  PointLight,
  Points,
  PointsMaterial,
  PositionalAudio,
  PropertyBinding,
  Quaternion,
  QuaternionKeyframeTrack,
  REVISION,
  RGBADepthPacking,
  RGBAFormat,
  RGBA_ASTC_4x4_Format,
  RGBA_ASTC_6x6_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT1_Format,
  RGBA_S3TC_DXT5_Format,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGFormat,
  RawShaderMaterial,
  Ray,
  Raycaster,
  RedFormat,
  ReinhardToneMapping,
  RepeatWrapping,
  ReplaceStencilOp,
  RingGeometry,
  SRGBColorSpace,
  Scene,
  ShaderChunk,
  ShaderLib,
  ShaderMaterial,
  ShadowMaterial,
  Shape,
  ShapePath,
  ShapeUtils,
  Skeleton,
  SkinnedMesh,
  Source,
  Sphere,
  SphereGeometry,
  Spherical,
  SpotLight,
  Sprite,
  SpriteMaterial,
  TOUCH,
  Texture,
  TextureLoader,
  TorusGeometry,
  Triangle,
  TriangleFanDrawMode as TriangleFanDrawMode2,
  TriangleStripDrawMode as TriangleStripDrawMode2,
  TrianglesDrawMode as TrianglesDrawMode2,
  Uint16BufferAttribute,
  Uniform$1,
  UniformsLib,
  UniformsUtils,
  UnsignedByteType,
  UnsignedInt248Type,
  UnsignedIntType,
  Vector2,
  Vector3 as Vector32,
  Vector4,
  VectorKeyframeTrack,
  VideoTexture,
  WebGLCubeRenderTarget,
  WebGLRenderTarget,
  WebGLRenderer,
  WireframeGeometry,
  ZeroStencilOp
} from "./chunk-3GUWUI4A.js";
import {
  __commonJS,
  __export,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField,
  __toESM
} from "./chunk-4RACSZOF.js";

// node_modules/crypt/crypt.js
var require_crypt = __commonJS({
  "node_modules/crypt/crypt.js"(exports, module) {
    (function() {
      var base64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", crypt = {
        // Bit-wise rotation left
        rotl: function(n2, b) {
          return n2 << b | n2 >>> 32 - b;
        },
        // Bit-wise rotation right
        rotr: function(n2, b) {
          return n2 << 32 - b | n2 >>> b;
        },
        // Swap big-endian to little-endian and vice versa
        endian: function(n2) {
          if (n2.constructor == Number) {
            return crypt.rotl(n2, 8) & 16711935 | crypt.rotl(n2, 24) & 4278255360;
          }
          for (var i = 0; i < n2.length; i++)
            n2[i] = crypt.endian(n2[i]);
          return n2;
        },
        // Generate an array of any length of random bytes
        randomBytes: function(n2) {
          for (var bytes = []; n2 > 0; n2--)
            bytes.push(Math.floor(Math.random() * 256));
          return bytes;
        },
        // Convert a byte array to big-endian 32-bit words
        bytesToWords: function(bytes) {
          for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
            words[b >>> 5] |= bytes[i] << 24 - b % 32;
          return words;
        },
        // Convert big-endian 32-bit words to a byte array
        wordsToBytes: function(words) {
          for (var bytes = [], b = 0; b < words.length * 32; b += 8)
            bytes.push(words[b >>> 5] >>> 24 - b % 32 & 255);
          return bytes;
        },
        // Convert a byte array to a hex string
        bytesToHex: function(bytes) {
          for (var hex = [], i = 0; i < bytes.length; i++) {
            hex.push((bytes[i] >>> 4).toString(16));
            hex.push((bytes[i] & 15).toString(16));
          }
          return hex.join("");
        },
        // Convert a hex string to a byte array
        hexToBytes: function(hex) {
          for (var bytes = [], c2 = 0; c2 < hex.length; c2 += 2)
            bytes.push(parseInt(hex.substr(c2, 2), 16));
          return bytes;
        },
        // Convert a byte array to a base-64 string
        bytesToBase64: function(bytes) {
          for (var base64 = [], i = 0; i < bytes.length; i += 3) {
            var triplet = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];
            for (var j = 0; j < 4; j++)
              if (i * 8 + j * 6 <= bytes.length * 8)
                base64.push(base64map.charAt(triplet >>> 6 * (3 - j) & 63));
              else
                base64.push("=");
          }
          return base64.join("");
        },
        // Convert a base-64 string to a byte array
        base64ToBytes: function(base64) {
          base64 = base64.replace(/[^A-Z0-9+\/]/ig, "");
          for (var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4) {
            if (imod4 == 0)
              continue;
            bytes.push((base64map.indexOf(base64.charAt(i - 1)) & Math.pow(2, -2 * imod4 + 8) - 1) << imod4 * 2 | base64map.indexOf(base64.charAt(i)) >>> 6 - imod4 * 2);
          }
          return bytes;
        }
      };
      module.exports = crypt;
    })();
  }
});

// node_modules/charenc/charenc.js
var require_charenc = __commonJS({
  "node_modules/charenc/charenc.js"(exports, module) {
    var charenc = {
      // UTF-8 encoding
      utf8: {
        // Convert a string to a byte array
        stringToBytes: function(str) {
          return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
        },
        // Convert a byte array to a string
        bytesToString: function(bytes) {
          return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
        }
      },
      // Binary encoding
      bin: {
        // Convert a string to a byte array
        stringToBytes: function(str) {
          for (var bytes = [], i = 0; i < str.length; i++)
            bytes.push(str.charCodeAt(i) & 255);
          return bytes;
        },
        // Convert a byte array to a string
        bytesToString: function(bytes) {
          for (var str = [], i = 0; i < bytes.length; i++)
            str.push(String.fromCharCode(bytes[i]));
          return str.join("");
        }
      }
    };
    module.exports = charenc;
  }
});

// node_modules/is-buffer/index.js
var require_is_buffer = __commonJS({
  "node_modules/is-buffer/index.js"(exports, module) {
    module.exports = function(obj) {
      return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
    };
    function isBuffer(obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    }
    function isSlowBuffer(obj) {
      return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
    }
  }
});

// node_modules/md5/md5.js
var require_md5 = __commonJS({
  "node_modules/md5/md5.js"(exports, module) {
    (function() {
      var crypt = require_crypt(), utf8 = require_charenc().utf8, isBuffer = require_is_buffer(), bin = require_charenc().bin, md53 = function(message, options) {
        if (message.constructor == String)
          if (options && options.encoding === "binary")
            message = bin.stringToBytes(message);
          else
            message = utf8.stringToBytes(message);
        else if (isBuffer(message))
          message = Array.prototype.slice.call(message, 0);
        else if (!Array.isArray(message) && message.constructor !== Uint8Array)
          message = message.toString();
        var m2 = crypt.bytesToWords(message), l = message.length * 8, a = 1732584193, b = -271733879, c2 = -1732584194, d = 271733878;
        for (var i = 0; i < m2.length; i++) {
          m2[i] = (m2[i] << 8 | m2[i] >>> 24) & 16711935 | (m2[i] << 24 | m2[i] >>> 8) & 4278255360;
        }
        m2[l >>> 5] |= 128 << l % 32;
        m2[(l + 64 >>> 9 << 4) + 14] = l;
        var FF = md53._ff, GG = md53._gg, HH = md53._hh, II = md53._ii;
        for (var i = 0; i < m2.length; i += 16) {
          var aa = a, bb = b, cc = c2, dd = d;
          a = FF(a, b, c2, d, m2[i + 0], 7, -680876936);
          d = FF(d, a, b, c2, m2[i + 1], 12, -389564586);
          c2 = FF(c2, d, a, b, m2[i + 2], 17, 606105819);
          b = FF(b, c2, d, a, m2[i + 3], 22, -1044525330);
          a = FF(a, b, c2, d, m2[i + 4], 7, -176418897);
          d = FF(d, a, b, c2, m2[i + 5], 12, 1200080426);
          c2 = FF(c2, d, a, b, m2[i + 6], 17, -1473231341);
          b = FF(b, c2, d, a, m2[i + 7], 22, -45705983);
          a = FF(a, b, c2, d, m2[i + 8], 7, 1770035416);
          d = FF(d, a, b, c2, m2[i + 9], 12, -1958414417);
          c2 = FF(c2, d, a, b, m2[i + 10], 17, -42063);
          b = FF(b, c2, d, a, m2[i + 11], 22, -1990404162);
          a = FF(a, b, c2, d, m2[i + 12], 7, 1804603682);
          d = FF(d, a, b, c2, m2[i + 13], 12, -40341101);
          c2 = FF(c2, d, a, b, m2[i + 14], 17, -1502002290);
          b = FF(b, c2, d, a, m2[i + 15], 22, 1236535329);
          a = GG(a, b, c2, d, m2[i + 1], 5, -165796510);
          d = GG(d, a, b, c2, m2[i + 6], 9, -1069501632);
          c2 = GG(c2, d, a, b, m2[i + 11], 14, 643717713);
          b = GG(b, c2, d, a, m2[i + 0], 20, -373897302);
          a = GG(a, b, c2, d, m2[i + 5], 5, -701558691);
          d = GG(d, a, b, c2, m2[i + 10], 9, 38016083);
          c2 = GG(c2, d, a, b, m2[i + 15], 14, -660478335);
          b = GG(b, c2, d, a, m2[i + 4], 20, -405537848);
          a = GG(a, b, c2, d, m2[i + 9], 5, 568446438);
          d = GG(d, a, b, c2, m2[i + 14], 9, -1019803690);
          c2 = GG(c2, d, a, b, m2[i + 3], 14, -187363961);
          b = GG(b, c2, d, a, m2[i + 8], 20, 1163531501);
          a = GG(a, b, c2, d, m2[i + 13], 5, -1444681467);
          d = GG(d, a, b, c2, m2[i + 2], 9, -51403784);
          c2 = GG(c2, d, a, b, m2[i + 7], 14, 1735328473);
          b = GG(b, c2, d, a, m2[i + 12], 20, -1926607734);
          a = HH(a, b, c2, d, m2[i + 5], 4, -378558);
          d = HH(d, a, b, c2, m2[i + 8], 11, -2022574463);
          c2 = HH(c2, d, a, b, m2[i + 11], 16, 1839030562);
          b = HH(b, c2, d, a, m2[i + 14], 23, -35309556);
          a = HH(a, b, c2, d, m2[i + 1], 4, -1530992060);
          d = HH(d, a, b, c2, m2[i + 4], 11, 1272893353);
          c2 = HH(c2, d, a, b, m2[i + 7], 16, -155497632);
          b = HH(b, c2, d, a, m2[i + 10], 23, -1094730640);
          a = HH(a, b, c2, d, m2[i + 13], 4, 681279174);
          d = HH(d, a, b, c2, m2[i + 0], 11, -358537222);
          c2 = HH(c2, d, a, b, m2[i + 3], 16, -722521979);
          b = HH(b, c2, d, a, m2[i + 6], 23, 76029189);
          a = HH(a, b, c2, d, m2[i + 9], 4, -640364487);
          d = HH(d, a, b, c2, m2[i + 12], 11, -421815835);
          c2 = HH(c2, d, a, b, m2[i + 15], 16, 530742520);
          b = HH(b, c2, d, a, m2[i + 2], 23, -995338651);
          a = II(a, b, c2, d, m2[i + 0], 6, -198630844);
          d = II(d, a, b, c2, m2[i + 7], 10, 1126891415);
          c2 = II(c2, d, a, b, m2[i + 14], 15, -1416354905);
          b = II(b, c2, d, a, m2[i + 5], 21, -57434055);
          a = II(a, b, c2, d, m2[i + 12], 6, 1700485571);
          d = II(d, a, b, c2, m2[i + 3], 10, -1894986606);
          c2 = II(c2, d, a, b, m2[i + 10], 15, -1051523);
          b = II(b, c2, d, a, m2[i + 1], 21, -2054922799);
          a = II(a, b, c2, d, m2[i + 8], 6, 1873313359);
          d = II(d, a, b, c2, m2[i + 15], 10, -30611744);
          c2 = II(c2, d, a, b, m2[i + 6], 15, -1560198380);
          b = II(b, c2, d, a, m2[i + 13], 21, 1309151649);
          a = II(a, b, c2, d, m2[i + 4], 6, -145523070);
          d = II(d, a, b, c2, m2[i + 11], 10, -1120210379);
          c2 = II(c2, d, a, b, m2[i + 2], 15, 718787259);
          b = II(b, c2, d, a, m2[i + 9], 21, -343485551);
          a = a + aa >>> 0;
          b = b + bb >>> 0;
          c2 = c2 + cc >>> 0;
          d = d + dd >>> 0;
        }
        return crypt.endian([a, b, c2, d]);
      };
      md53._ff = function(a, b, c2, d, x2, s, t2) {
        var n2 = a + (b & c2 | ~b & d) + (x2 >>> 0) + t2;
        return (n2 << s | n2 >>> 32 - s) + b;
      };
      md53._gg = function(a, b, c2, d, x2, s, t2) {
        var n2 = a + (b & d | c2 & ~d) + (x2 >>> 0) + t2;
        return (n2 << s | n2 >>> 32 - s) + b;
      };
      md53._hh = function(a, b, c2, d, x2, s, t2) {
        var n2 = a + (b ^ c2 ^ d) + (x2 >>> 0) + t2;
        return (n2 << s | n2 >>> 32 - s) + b;
      };
      md53._ii = function(a, b, c2, d, x2, s, t2) {
        var n2 = a + (c2 ^ (b | ~d)) + (x2 >>> 0) + t2;
        return (n2 << s | n2 >>> 32 - s) + b;
      };
      md53._blocksize = 16;
      md53._digestsize = 16;
      module.exports = function(message, options) {
        if (message === void 0 || message === null)
          throw new Error("Illegal argument " + message);
        var digestbytes = crypt.wordsToBytes(md53(message, options));
        return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt.bytesToHex(digestbytes);
      };
    })();
  }
});

// node_modules/@needle-tools/engine/lib/engine/engine_gltf.js
var gltfLoader;
var gltfLoaderType = null;
function getLoader() {
  return gltfLoader;
}
function registerLoader(loader2) {
  if (loader2 === null || loader2 === void 0) {
    console.warn("Oh no: someone tried registering a non-existend gltf-loader. When you see this log it might mean that needle-engine is being imported multiple times. Please check your project setup.");
    return;
  }
  if (gltfLoaderType !== loader2) {
    gltfLoaderType = loader2;
    gltfLoader = new loader2();
  }
}

// node_modules/@needle-tools/engine/lib/engine/engine_networking_utils.js
var localNetworkResults = /* @__PURE__ */ new Map();
function isLocalNetwork(hostname = ((_a2) => (_a2 = globalThis.location) == null ? void 0 : _a2.hostname)()) {
  if (localNetworkResults.has(hostname))
    return localNetworkResults.get(hostname);
  const isLocalNetwork2 = /(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})|localhost/.test(hostname);
  localNetworkResults.set(hostname, isLocalNetwork2);
  if (isLocalNetwork2 === true)
    return true;
  return false;
}
function isHostedOnGlitch() {
  return window.location.hostname.includes("glitch.me");
}

// node_modules/@needle-tools/engine/lib/engine/engine_context_registry.js
var ContextEvent;
(function(ContextEvent2) {
  ContextEvent2["ContextRegistered"] = "ContextRegistered";
  ContextEvent2["ContextCreationStart"] = "ContextCreationStart";
  ContextEvent2["ContextCreated"] = "ContextCreated";
  ContextEvent2["ContextFirstFrameRendered"] = "ContextFirstFrameRendered";
  ContextEvent2["ContextDestroying"] = "ContextDestroying";
  ContextEvent2["ContextDestroyed"] = "ContextDestroyed";
  ContextEvent2["MissingCamera"] = "MissingCamera";
  ContextEvent2["ContextClearing"] = "ContextClearing";
  ContextEvent2["ContextCleared"] = "ContextCleared";
})(ContextEvent || (ContextEvent = {}));
var ContextRegistry = class {
  /** The currently active (rendering) Needle Engine context */
  static get Current() {
    return globalThis["NeedleEngine.Context.Current"];
  }
  /** @internal */
  static set Current(ctx) {
    globalThis["NeedleEngine.Context.Current"] = ctx;
  }
  /** Returns the array of all registered Needle Engine contexts. Do not modify */
  static get All() {
    return this.Registered;
  }
  /** @internal Internal use only */
  static register(ctx) {
    this.Registered.push(ctx);
    this.dispatchCallback(ContextEvent.ContextRegistered, ctx);
  }
  /** @internal Internal use only */
  static unregister(ctx) {
    const index = this.Registered.indexOf(ctx);
    if (index === -1)
      return;
    this.Registered.splice(index, 1);
  }
  /**
   * Register a callback to be called when the given event occurs
   */
  static registerCallback(evt, callback) {
    if (!this._callbacks[evt])
      this._callbacks[evt] = [];
    this._callbacks[evt].push(callback);
  }
  /** Unregister a callback */
  static unregisterCallback(evt, callback) {
    if (!this._callbacks[evt])
      return;
    const index = this._callbacks[evt].indexOf(callback);
    if (index === -1)
      return;
    this._callbacks[evt].splice(index, 1);
  }
  /** @internal */
  static dispatchCallback(evt, context, extras) {
    if (!this._callbacks[evt])
      return true;
    const cbArgs = { event: evt, context };
    if (extras) {
      for (const key in extras) {
        cbArgs[key] = extras[key];
      }
    }
    const promises = new Array();
    this._callbacks[evt].forEach((cb) => {
      const res = cb(cbArgs);
      if (res instanceof Promise)
        promises.push(res);
    });
    return Promise.all(promises);
  }
  /**
   * Register a callback to be called when a context is created
   */
  static addContextCreatedCallback(callback) {
    this.registerCallback(ContextEvent.ContextCreated, callback);
  }
  /**
   * Register a callback to be called when a context is registered
   */
  static addContextDestroyedCallback(callback) {
    this.registerCallback(ContextEvent.ContextDestroyed, callback);
  }
};
/** All currently registered Needle Engine contexts. Do not modify */
__publicField(ContextRegistry, "Registered", []);
__publicField(ContextRegistry, "_callbacks", {});

// node_modules/@needle-tools/engine/lib/engine/engine_utils.js
var nameofFactory = () => (name) => name;
function nameof(name) {
  return nameofFactory()(name);
}
function isDebugMode() {
  return getParam("debug") ? true : false;
}
var CircularBuffer = class {
  constructor(factory, maxSize) {
    __publicField(this, "_factory");
    __publicField(this, "_cache", []);
    __publicField(this, "_maxSize");
    __publicField(this, "_index", 0);
    this._factory = factory;
    this._maxSize = maxSize;
  }
  get() {
    const i = this._index % this._maxSize;
    this._index++;
    if (this._cache.length <= i) {
      this._cache[i] = this._factory();
    }
    return this._cache[i];
  }
};
var showHelp = false;
var requestedParams = new Array();
if (typeof window !== "undefined") {
  setTimeout(() => {
    if (showHelp) {
      const params = {};
      const url = new URL(window.location.href);
      const exampleUrl = new URL(url);
      exampleUrl.searchParams.append("console", "");
      const exampleUrlStr = exampleUrl.toString().replace(/=$|=(?=&)/g, "");
      for (const param of requestedParams) {
        const url2 = new URL(url);
        url2.searchParams.append(param, "");
        params[param] = url2.toString().replace(/=$|=(?=&)/g, "");
      }
      console.log(`🌵 ?help: Debug Options for Needle Engine.
Append any of these parameters to the URL to enable specific debug options.
Example: ${exampleUrlStr} will show an onscreen console window.`);
      const postfix = showHelp === true ? "" : ` (containing "${showHelp}")`;
      console.group("Available URL parameters:" + postfix);
      for (const key of Object.keys(params).sort()) {
        if (typeof showHelp === "string") {
          if (!key.toLowerCase().includes(showHelp.toLowerCase()))
            continue;
        }
        console.groupCollapsed(key);
        console.log("Reload with this flag enabled:");
        console.log(params[key]);
        console.groupEnd();
      }
      console.groupEnd();
    }
  }, 100);
}
function getUrlParams() {
  var _a2;
  return new URLSearchParams((_a2 = globalThis.location) == null ? void 0 : _a2.search);
}
function getParam(paramName) {
  if (showHelp && !requestedParams.includes(paramName))
    requestedParams.push(paramName);
  const urlParams = getUrlParams();
  if (urlParams.has(paramName)) {
    const val = urlParams.get(paramName);
    if (val) {
      const num = Number(val);
      if (!isNaN(num))
        return num;
      return val;
    } else
      return true;
  }
  return false;
}
showHelp = getParam("help");
function setParam(paramName, paramValue) {
  const urlParams = getUrlParams();
  if (urlParams.has(paramName)) {
    urlParams.set(paramName, paramValue);
  } else
    urlParams.append(paramName, paramValue);
  document.location.search = urlParams.toString();
}
function setParamWithoutReload(paramName, paramValue, appendHistory = true) {
  const urlParams = getUrlParams();
  if (urlParams.has(paramName)) {
    if (paramValue === null)
      urlParams.delete(paramName);
    else
      urlParams.set(paramName, paramValue);
  } else if (paramValue !== null)
    urlParams.append(paramName, paramValue);
  if (appendHistory)
    pushState(paramName, urlParams);
  else
    setState(paramName, urlParams);
}
function setOrAddParamsToUrl(url, paramName, paramValue) {
  if (url.has(paramName)) {
    url.set(paramName, paramValue.toString());
  } else
    url.append(paramName, paramValue.toString());
}
function pushState(title, urlParams, state) {
  window.history.pushState(state, title, "?" + urlParams.toString());
}
function setState(title, urlParams, state) {
  window.history.replaceState(state, title, "?" + urlParams.toString());
}
function makeId(length) {
  var result = "";
  var characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  var charactersLength = characters.length;
  for (var i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }
  return result;
}
function randomNumber(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
var adjectives = ["smol", "tiny", "giant", "interesting", "smart", "bright", "dull", "extreme", "beautiful", "pretty", "dark", "epic", "salty", "silly", "funny", "lame", "lazy", "loud", "lucky", "mad", "mean", "mighty", "mysterious", "nasty", "odd", "old", "powerful", "quiet", "rapid", "scary", "shiny", "shy", "silly", "smooth", "sour", "spicy", "stupid", "sweet", "tasty", "terrible", "ugly", "unusual", "vast", "wet", "wild", "witty", "wrong", "zany", "zealous", "zippy", "zombie", "zorro"];
var nouns = ["cat", "dog", "mouse", "pig", "cow", "horse", "sheep", "chicken", "duck", "goat", "panda", "tiger", "lion", "elephant", "monkey", "bird", "fish", "snake", "frog", "turtle", "hamster", "penguin", "kangaroo", "whale", "dolphin", "crocodile", "snail", "ant", "bee", "beetle", "butterfly", "dragon", "eagle", "fish", "giraffe", "lizard", "panda", "penguin", "rabbit", "snake", "spider", "tiger", "zebra"];
function makeIdFromRandomWords() {
  const randomAdjective = adjectives[Math.floor(Math.random() * adjectives.length)];
  const randomNoun = nouns[Math.floor(Math.random() * nouns.length)];
  return randomAdjective + "_" + randomNoun;
}
function sanitizeString(str) {
  str = str.replace(/[^a-z0-9áéíóúñü \.,_-]/gim, "");
  return str.trim();
}
function tryFindObject(globalObjectIdentifier, obj, recursive = true, searchComponents = false) {
  var _a2;
  if (obj === void 0 || obj === null)
    return null;
  if (obj.userData && obj.userData.guid === globalObjectIdentifier)
    return obj;
  else if (obj.guid == globalObjectIdentifier)
    return obj;
  if (searchComponents) {
    if ((_a2 = obj.userData) == null ? void 0 : _a2.components) {
      for (const comp of obj.userData.components) {
        if (comp.guid === globalObjectIdentifier)
          return comp;
      }
    }
  }
  if (recursive) {
    if (obj.scenes) {
      for (const i in obj.scenes) {
        const scene = obj.scenes[i];
        const found = tryFindObject(globalObjectIdentifier, scene, recursive, searchComponents);
        if (found)
          return found;
      }
    }
    if (obj.children) {
      for (const i in obj.children) {
        const child = obj.children[i];
        const found = tryFindObject(globalObjectIdentifier, child, recursive, searchComponents);
        if (found)
          return found;
      }
    }
  }
}
function deepClone(obj, predicate) {
  if (obj !== null && obj !== void 0 && typeof obj === "object") {
    let clone;
    if (Array.isArray(obj))
      clone = [];
    else {
      clone = Object.create(obj);
      Object.assign(clone, obj);
    }
    for (const key of Object.keys(obj)) {
      const val = obj[key];
      if (predicate && !predicate(obj, key, val)) {
        clone[key] = val;
      } else if ((val == null ? void 0 : val.clone) !== void 0 && typeof val.clone === "function")
        clone[key] = val.clone();
      else
        clone[key] = deepClone(val, predicate);
    }
    return clone;
  }
  return obj;
}
function delay(milliseconds) {
  return new Promise((resolve2, _reject) => {
    setTimeout(resolve2, milliseconds);
  });
}
function delayForFrames(frameCount, context) {
  if (frameCount <= 0)
    return Promise.resolve();
  if (!context)
    context = ContextRegistry.Current;
  if (!context)
    return Promise.reject("No context");
  const endFrame = context.time.frameCount + frameCount;
  return new Promise((resolve2, reject) => {
    if (!context)
      return reject("No context");
    const cb = () => {
      if (context.time.frameCount >= endFrame) {
        context.pre_update_callbacks.splice(context.pre_update_callbacks.indexOf(cb), 1);
        resolve2();
      }
    };
    context.pre_update_callbacks.push(cb);
  });
}
var debugGetPath = getParam("debugresolveurl");
var relativePathPrefix = "rel:";
function getPath(source, uri) {
  return resolveUrl(source, uri);
}
function resolveUrl(source, uri) {
  if (uri === void 0) {
    if (debugGetPath)
      console.warn("getPath: uri is undefined, returning uri", uri);
    return uri;
  }
  if (uri.startsWith("./")) {
    return uri;
  }
  if (uri.startsWith("http")) {
    if (debugGetPath)
      console.warn("getPath: uri is absolute, returning uri", uri);
    return uri;
  }
  if (source === void 0) {
    if (debugGetPath)
      console.warn("getPath: source is undefined, returning uri", uri);
    return uri;
  }
  if (uri.startsWith(relativePathPrefix)) {
    uri = uri.substring(4);
  }
  const pathIndex = source.lastIndexOf("/");
  if (pathIndex >= 0) {
    const basePath = source.substring(0, pathIndex + 1);
    while (basePath.endsWith("/") && uri.startsWith("/"))
      uri = uri.substring(1);
    const newUri = basePath + uri;
    if (debugGetPath)
      console.log("source:", source, "changed uri \nfrom", uri, "\nto ", newUri, "\nbasePath: " + basePath);
    return newUri;
  }
  return uri;
}
var WatchImpl = class {
  constructor(object, prop) {
    __publicField(this, "writeCallbacks", []);
    __publicField(this, "_applied", false);
    __publicField(this, "_object");
    __publicField(this, "_prop");
    __publicField(this, "_wrapperProp");
    this._object = object;
    this._prop = prop;
    this._wrapperProp = Symbol("$" + prop);
    this.apply();
  }
  subscribeWrite(callback) {
    this.writeCallbacks.push(callback);
  }
  unsubscribeWrite(callback) {
    const i = this.writeCallbacks.indexOf(callback);
    if (i === -1)
      return;
    this.writeCallbacks.splice(i, 1);
  }
  apply() {
    if (this._applied)
      return;
    if (!this._object)
      return;
    const object = this._object;
    const prop = this._prop;
    if (object[prop] === void 0)
      return;
    this._applied = true;
    if (object[this._wrapperProp] !== void 0) {
      console.warn("Watcher is being applied to an object that already has a wrapper property. This is not (yet) supported");
    }
    const current = object[prop];
    object[this._wrapperProp] = current;
    const getter = () => {
      return object[this._wrapperProp];
    };
    const setter = (value) => {
      object[this._wrapperProp] = value;
      for (const write of this.writeCallbacks) {
        write(value, this._prop);
      }
    };
    Object.defineProperty(object, prop, {
      get: getter,
      set: setter
    });
  }
  revoke() {
    if (!this._applied)
      return;
    if (!this._object)
      return;
    this._applied = false;
    const object = this._object;
    const prop = this._prop;
    Reflect.deleteProperty(object, prop);
    const current = object[this._wrapperProp];
    object[prop] = current;
    Reflect.deleteProperty(object, this._wrapperProp);
  }
  dispose() {
    this.revoke();
    this.writeCallbacks.length = 0;
    this._object = null;
  }
};
var Watch = class {
  constructor(object, str) {
    __publicField(this, "_watches", []);
    if (Array.isArray(str)) {
      for (const s of str) {
        this._watches.push(new Watch(object, s));
      }
    } else {
      this._watches.push(new WatchImpl(object, str));
    }
  }
  subscribeWrite(callback) {
    for (const w of this._watches) {
      w.subscribeWrite(callback);
    }
  }
  unsubscribeWrite(callback) {
    for (const w of this._watches) {
      w.unsubscribeWrite(callback);
    }
  }
  apply() {
    for (const w of this._watches) {
      w.apply();
    }
  }
  revoke() {
    for (const w of this._watches) {
      w.revoke();
    }
  }
  dispose() {
    for (const w of this._watches) {
      w.dispose();
    }
    this._watches.length = 0;
  }
};
var watchesKey = Symbol("needle:watches");
function watchWrite(vec2, cb) {
  if (!vec2[watchesKey]) {
    if (vec2 instanceof Vector2) {
      vec2[watchesKey] = new Watch(vec2, ["x", "y"]);
    } else if (vec2 instanceof Vector32) {
      vec2[watchesKey] = new Watch(vec2, ["x", "y", "z"]);
    } else if (vec2 instanceof Vector4 || vec2 instanceof Quaternion) {
      vec2[watchesKey] = new Watch(vec2, ["x", "y", "z", "w"]);
    } else {
      return false;
    }
  }
  vec2[watchesKey].subscribeWrite(cb);
  return true;
}
function unwatchWrite(vec2, cb) {
  if (!vec2)
    return;
  const watch = vec2[watchesKey];
  if (!watch)
    return;
  watch.unsubscribeWrite(cb);
}
var DeviceUtilities;
(function(DeviceUtilities2) {
  let _isDesktop;
  function isDesktop2() {
    if (_isDesktop !== void 0)
      return _isDesktop;
    const ua = window.navigator.userAgent;
    const standalone = /Windows|MacOS|Mac OS/.test(ua);
    const isHololens = /Windows NT/.test(ua) && /Edg/.test(ua) && !/Win64/.test(ua);
    return _isDesktop = standalone && !isHololens && !isiOS2();
  }
  DeviceUtilities2.isDesktop = isDesktop2;
  let _ismobile2;
  function isMobileDevice3() {
    if (_ismobile2 !== void 0)
      return _ismobile2;
    if (typeof window.orientation !== "undefined" || navigator.userAgent.indexOf("IEMobile") !== -1) {
      return _ismobile2 = true;
    }
    return _ismobile2 = /iPhone|iPad|iPod|Android|IEMobile/i.test(navigator.userAgent);
  }
  DeviceUtilities2.isMobileDevice = isMobileDevice3;
  function isIPad2() {
    return isiPad2();
  }
  DeviceUtilities2.isIPad = isIPad2;
  let __isiPad;
  function isiPad2() {
    if (__isiPad !== void 0)
      return __isiPad;
    return __isiPad = /iPad/.test(navigator.userAgent);
  }
  DeviceUtilities2.isiPad = isiPad2;
  let __isAndroidDevice;
  function isAndroidDevice2() {
    if (__isAndroidDevice !== void 0)
      return __isAndroidDevice;
    return __isAndroidDevice = /Android/.test(navigator.userAgent);
  }
  DeviceUtilities2.isAndroidDevice = isAndroidDevice2;
  let __isMozillaXR;
  function isMozillaXR2() {
    if (__isMozillaXR !== void 0)
      return __isMozillaXR;
    return __isMozillaXR = /WebXRViewer\//i.test(navigator.userAgent);
  }
  DeviceUtilities2.isMozillaXR = isMozillaXR2;
  let __isMacOS;
  function isMacOS2() {
    if (__isMacOS !== void 0)
      return __isMacOS;
    if (navigator.userAgentData) {
      return __isMacOS = navigator.userAgentData.platform === "macOS";
    } else {
      const userAgent = navigator.userAgent.toLowerCase();
      return __isMacOS = userAgent.includes("mac os x") || userAgent.includes("macintosh");
    }
  }
  DeviceUtilities2.isMacOS = isMacOS2;
  let __isiOS;
  const iosDevices = ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"];
  function isiOS2() {
    if (__isiOS !== void 0)
      return __isiOS;
    return __isiOS = iosDevices.includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
  }
  DeviceUtilities2.isiOS = isiOS2;
  let __isSafari;
  function isSafari2() {
    if (__isSafari !== void 0)
      return __isSafari;
    __isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    return __isSafari;
  }
  DeviceUtilities2.isSafari = isSafari2;
  let __isQuest;
  function isQuest2() {
    if (__isQuest !== void 0)
      return __isQuest;
    return __isQuest = navigator.userAgent.includes("OculusBrowser");
  }
  DeviceUtilities2.isQuest = isQuest2;
  let __supportsQuickLookAR;
  function supportsQuickLookAR() {
    if (__supportsQuickLookAR !== void 0)
      return __supportsQuickLookAR;
    const a = document.createElement("a");
    __supportsQuickLookAR = a.relList.supports("ar");
    return __supportsQuickLookAR;
  }
  DeviceUtilities2.supportsQuickLookAR = supportsQuickLookAR;
  async function microphonePermissionsGranted2() {
    try {
      const res = await navigator.permissions.query({ name: "microphone" });
      if (res.state === "denied") {
        return false;
      }
      return true;
    } catch (err) {
      console.error("Error querying `microphone` permissions.", err);
      return false;
    }
  }
  DeviceUtilities2.microphonePermissionsGranted = microphonePermissionsGranted2;
  let __iOSVersion;
  function getiOSVersion() {
    if (__iOSVersion !== void 0)
      return __iOSVersion;
    const match = navigator.userAgent.match(/iPhone OS (\d+_\d+)/);
    if (match)
      __iOSVersion = match[1].replace("_", ".");
    if (!__iOSVersion) {
      const match2 = navigator.userAgent.match(/(?:\(Macintosh;|iPhone;|iPad;).*Version\/(\d+\.\d+)/);
      if (match2)
        __iOSVersion = match2[1];
    }
    if (!__iOSVersion) {
      __iOSVersion = null;
    }
    return __iOSVersion;
  }
  DeviceUtilities2.getiOSVersion = getiOSVersion;
  let __chromeVersion;
  function getChromeVersion() {
    if (__chromeVersion !== void 0)
      return __chromeVersion;
    const match = navigator.userAgent.match(/(?:CriOS|Chrome)\/(\d+\.\d+\.\d+\.\d+)/);
    if (match) {
      const result = match[1].replace("_", ".");
      __chromeVersion = result;
    } else
      __chromeVersion = null;
    return __chromeVersion;
  }
  DeviceUtilities2.getChromeVersion = getChromeVersion;
})(DeviceUtilities || (DeviceUtilities = {}));
function isDesktop() {
  return DeviceUtilities.isDesktop();
}
function isMobileDevice() {
  return DeviceUtilities.isMobileDevice();
}
function isIPad() {
  return DeviceUtilities.isiPad();
}
function isiPad() {
  return DeviceUtilities.isiPad();
}
function isAndroidDevice() {
  return DeviceUtilities.isAndroidDevice();
}
function isMozillaXR() {
  return DeviceUtilities.isMozillaXR();
}
function isMacOS() {
  return DeviceUtilities.isMacOS();
}
function isiOS() {
  return DeviceUtilities.isiOS();
}
function isSafari() {
  return DeviceUtilities.isSafari();
}
function isQuest() {
  return DeviceUtilities.isQuest();
}
async function microphonePermissionsGranted() {
  return DeviceUtilities.microphonePermissionsGranted();
}
var cloudflareIPRegex = /ip=(?<ip>.+?)\n/s;
async function getIpCloudflare() {
  const data = await fetch("https://www.cloudflare.com/cdn-cgi/trace");
  const body = await data.text();
  const match = cloudflareIPRegex.exec(body);
  if (match)
    return match[1];
  return null;
}
async function getIp() {
  const res = await fetch("https://api.db-ip.com/v2/free/self").catch(() => null);
  if (!res)
    return void 0;
  const json = await res.json();
  return json.ipAddress;
}
async function getIpAndLocation() {
  const res = await fetch("https://api.db-ip.com/v2/free/self").catch(() => null);
  if (!res)
    return void 0;
  const json = await res.json();
  return json;
}
var mutationObserverMap = /* @__PURE__ */ new WeakMap();
function addAttributeChangeCallback(domElement, name, callback) {
  if (!mutationObserverMap.get(domElement)) {
    const observer = new MutationObserver((mutations) => {
      handleMutations(domElement, mutations);
    });
    mutationObserverMap.set(domElement, {
      observer,
      attributeChangedListeners: /* @__PURE__ */ new Map()
    });
    observer.observe(domElement, { attributes: true });
  }
  const listeners = mutationObserverMap.get(domElement).attributeChangedListeners;
  if (!listeners.has(name)) {
    listeners.set(name, []);
  }
  listeners.get(name).push(callback);
}
function removeAttributeChangeCallback(domElement, name, callback) {
  if (!mutationObserverMap.get(domElement))
    return;
  const listeners = mutationObserverMap.get(domElement).attributeChangedListeners;
  if (!listeners.has(name))
    return;
  const arr = listeners.get(name);
  const index = arr.indexOf(callback);
  if (index === -1)
    return;
  arr.splice(index, 1);
  if (arr.length <= 0) {
    listeners.delete(name);
    const entry = mutationObserverMap.get(domElement);
    entry == null ? void 0 : entry.observer.disconnect();
    mutationObserverMap.delete(domElement);
  }
}
function handleMutations(domElement, mutations) {
  const listeners = mutationObserverMap.get(domElement).attributeChangedListeners;
  for (const mut of mutations) {
    if (mut.type === "attributes") {
      const name = mut.attributeName;
      const value = domElement.getAttribute(name);
      if (listeners.has(name)) {
        for (const listener of listeners.get(name)) {
          listener(value);
        }
      }
    }
  }
}
var PromiseErrorResult = class {
  constructor(reason) {
    __publicField(this, "reason");
    this.reason = reason;
  }
};
async function PromiseAllWithErrors(promise) {
  const results = await Promise.allSettled(promise).catch((err) => {
    return [
      new PromiseErrorResult(err.message)
    ];
  });
  let anyFailed = false;
  const res = results.map((x2) => {
    if ("value" in x2)
      return x2.value;
    anyFailed = true;
    return new PromiseErrorResult(x2.reason);
  });
  return {
    anyFailed,
    results: res
  };
}
async function generateQRCode(args) {
  if (!globalThis["QRCode"]) {
    const url = "https://cdn.rawgit.com/davidshimjs/qrcodejs/gh-pages/qrcode.min.js";
    let script = document.head.querySelector(`script[src="${url}"]`);
    if (!script) {
      script = document.createElement("script");
      script.src = url;
      document.head.appendChild(script);
    }
    await new Promise((resolve2, _reject) => {
      script.addEventListener("load", () => {
        resolve2(true);
      });
    });
  }
  const QRCODE = globalThis["QRCode"];
  const target = args.domElement ?? document.createElement("div");
  new QRCODE(target, {
    width: args.width ?? 256,
    height: args.height ?? 256,
    colorDark: "#000000",
    colorLight: "#ffffff",
    correctLevel: QRCODE.CorrectLevel.M,
    ...args
  });
  return target;
}

// node_modules/@needle-tools/engine/lib/engine/debug/debug_overlay.js
var debug = getParam("debugdebug");
var hide = false;
if (getParam("noerrors") || getParam("nooverlaymessages"))
  hide = true;
var globalErrorContainerKey = "needle_engine_global_error_container";
var LogType;
(function(LogType2) {
  LogType2[LogType2["Log"] = 0] = "Log";
  LogType2[LogType2["Warn"] = 1] = "Warn";
  LogType2[LogType2["Error"] = 2] = "Error";
})(LogType || (LogType = {}));
function getErrorCount() {
  return _errorCount;
}
var _errorListeners = new Array();
function onError(cb) {
  _errorListeners.push(cb);
}
var isInvokingErrorListeners = false;
function invokeErrorListeners(...args) {
  if (isInvokingErrorListeners)
    return;
  isInvokingErrorListeners = true;
  try {
    for (let i = 0; i < _errorListeners.length; i++) {
      _errorListeners[i](...args);
    }
  } catch (e) {
    console.error(e);
  }
  isInvokingErrorListeners = false;
}
var originalConsoleError = console.error;
var patchedConsoleError = function(...args) {
  originalConsoleError.apply(console, args);
  onParseError(args);
  addLog(LogType.Error, args, null, null);
  onReceivedError(...args);
};
function setAllowBalloonMessages(allow) {
  hide = !allow;
  if (allow)
    console.error = patchedConsoleError;
  else
    console.error = originalConsoleError;
}
function setAllowOverlayMessages(allow) {
  return setAllowBalloonMessages(allow);
}
function makeErrorsVisibleForDevelopment() {
  if (hide)
    return;
  if (debug)
    console.warn("Patch console", window.location.hostname);
  console.error = patchedConsoleError;
  window.addEventListener("error", (event) => {
    if (!event)
      return;
    const message = event.error;
    if (message === void 0) {
      if (isLocalNetwork())
        console.warn("Received unknown error", event, event.target);
      return;
    }
    addLog(LogType.Error, message, event.filename, event.lineno);
    onReceivedError(event);
  }, true);
  window.addEventListener("unhandledrejection", (event) => {
    if (hide)
      return;
    if (!event)
      return;
    if (event.reason)
      addLog(LogType.Error, event.reason.message, event.reason.stack);
    else
      addLog(LogType.Error, "unhandled rejection");
    onReceivedError(event);
  });
}
var _errorCount = 0;
function onReceivedError(...args) {
  _errorCount += 1;
  invokeErrorListeners(...args);
}
function onParseError(args) {
  if (Array.isArray(args)) {
    for (let i = 0; i < args.length; i++) {
      const arg = args[i];
      if (typeof arg === "string" && arg.startsWith("THREE.PropertyBinding: Trying to update node for track:")) {
        args[i] = "Some animated objects couldn't be found: see console for details";
      }
    }
  }
}
function addLog(type, message, _file, _line2) {
  if (hide)
    return;
  const context = ContextRegistry.Current;
  const domElement = (context == null ? void 0 : context.domElement) ?? document.querySelector("needle-engine");
  if (!domElement)
    return;
  if (Array.isArray(message)) {
    let newMessage = "";
    for (let i = 0; i < message.length; i++) {
      let msg = message[i];
      if (msg instanceof Error) {
        msg = msg.message;
      }
      if (typeof msg === "object")
        continue;
      if (i > 0)
        newMessage += " ";
      newMessage += msg;
    }
    message = newMessage;
  }
  if (!message || message.length <= 0)
    return;
  showMessage(type, domElement, message);
}
var currentMessages = /* @__PURE__ */ new Map();
function showMessage(type, element, msg) {
  if (msg === null || msg === void 0)
    return;
  const container = getLogsContainer(element);
  if (container.childElementCount >= 20) {
    const last = container.lastElementChild;
    returnMessageContainer(last);
  }
  if (msg.length > 400)
    msg = msg.substring(0, 400) + "...";
  const key = msg;
  if (currentMessages.has(key)) {
    return;
  }
  const msgcontainer = getMessageContainer(type, msg);
  container.prepend(msgcontainer);
  const removeFunction = () => {
    currentMessages.delete(key);
    returnMessageContainer(msgcontainer);
  };
  currentMessages.set(key, removeFunction);
  setTimeout(removeFunction, 1e4);
}
function clearMessages() {
  if (debug)
    console.log("Clearing messages");
  for (const cur of currentMessages.values()) {
    cur == null ? void 0 : cur.call(cur);
  }
  currentMessages.clear();
}
var logsContainerStyles = `

@import url('https://fonts.googleapis.com/css2?family=Roboto+Flex:opsz,wght@8..144,100..1000&display=swap');

div[data-needle_engine_debug_overlay] {
    font-family: 'Roboto Flex', sans-serif;
    font-weight: 400;
    font-size: 16px;
}

div[data-needle_engine_debug_overlay] strong {
    font-weight: 700;
}

div[data-needle_engine_debug_overlay] a {
    color: white;
    text-decoration: none;
    border-bottom: 1px solid rgba(255, 255, 255, 0.3);
}

div[data-needle_engine_debug_overlay] a:hover {
    text-decoration: none;
    border: none;
}

div[data-needle_engine_debug_overlay] .log strong {
    color: rgba(200,200,200,.9);
}

div[data-needle_engine_debug_overlay] .warn strong {
    color: rgba(255,255,230, 1);
}

div[data-needle_engine_debug_overlay] .error strong {
    color: rgba(255,100,120, 1);
}
`;
function getLogsContainer(domElement) {
  if (!globalThis[globalErrorContainerKey]) {
    globalThis[globalErrorContainerKey] = /* @__PURE__ */ new Map();
  }
  const errorsMap = globalThis[globalErrorContainerKey];
  if (errorsMap.has(domElement)) {
    return errorsMap.get(domElement);
  } else {
    const container = document.createElement("div");
    errorsMap.set(domElement, container);
    container.setAttribute("data-needle_engine_debug_overlay", "");
    container.classList.add("debug-container");
    container.style.cssText = `
            position: absolute;
            top: 0;
            right: 5px;
            padding-top: 0px;
            max-width: 70%;
            max-height: calc(100% - 5px);
            z-index: 9999999999;
            pointer-events: scroll;
            display: flex;
            align-items: end;
            flex-direction: column;
            color: white;
            overflow: auto;
            word-break: break-word;
        `;
    if (domElement.shadowRoot)
      domElement.shadowRoot.appendChild(container);
    else
      domElement.appendChild(container);
    const style = document.createElement("style");
    style.innerHTML = logsContainerStyles;
    container.appendChild(style);
    return container;
  }
}
var typeSymbol = Symbol("logtype");
var containerCache = /* @__PURE__ */ new Map();
function returnMessageContainer(container) {
  container.remove();
  const type = container[typeSymbol];
  const containers = containerCache.get(type) ?? [];
  containers.push(container);
  containerCache.set(type, containers);
}
function getMessageContainer(type, msg) {
  if (containerCache.has(type)) {
    const containers = containerCache.get(type);
    if (containers.length > 0) {
      const container = containers.pop();
      container.innerHTML = msg;
      return container;
    }
  }
  const element = document.createElement("div");
  element.setAttribute("data-id", "__needle_engine_debug_overlay");
  element.style.marginRight = "5px";
  element.style.padding = ".5em";
  element.style.backgroundColor = "rgba(0,0,0,.9)";
  element.style.marginTop = "5px";
  element.style.marginBottom = "3px";
  element.style.borderRadius = "8px";
  element.style.pointerEvents = "all";
  element.style.userSelect = "text";
  element.style.maxWidth = "250px";
  element.style.whiteSpace = "pre-wrap";
  element.style["backdrop-filter"] = "blur(10px)";
  element.style["-webkit-backdrop-filter"] = "blur(10px)";
  element.style.backgroundColor = "rgba(20,20,20,.8)";
  element.style.boxShadow = "inset 0 0 80px rgba(0,0,0,.2), 0 0 5px rgba(0,0,0,.2)";
  element.style.border = "1px solid rgba(160,160,160,.2)";
  element[typeSymbol] = type;
  switch (type) {
    case LogType.Log:
      element.classList.add("log");
      element.style.color = "rgba(200,200,200,.7)";
      element.style.backgroundColor = "rgba(40,40,40,.7)";
      break;
    case LogType.Warn:
      element.classList.add("warn");
      element.style.color = "rgb(255, 255, 150)";
      element.style.backgroundColor = "rgba(50,50,20,.8)";
      break;
    case LogType.Error:
      element.classList.add("error");
      element.style.color = "rgb(255, 50, 50";
      element.style.backgroundColor = "rgba(50,20,20,.8)";
      break;
  }
  element.title = "Open the browser console (F12) for more information";
  element.innerHTML = msg;
  return element;
}

// node_modules/three-mesh-ui/build/three-mesh-ui.module.js
var three_mesh_ui_module_exports = {};
__export(three_mesh_ui_module_exports, {
  BaseProperty: () => __webpack_exports__BaseProperty,
  Behavior: () => __webpack_exports__Behavior,
  Block: () => __webpack_exports__Block,
  DefaultValues: () => __webpack_exports__DefaultValues,
  FontLibrary: () => __webpack_exports__FontLibrary,
  FontVariant: () => __webpack_exports__FontVariant,
  InheritableProperty: () => __webpack_exports__InheritableProperty,
  Inline: () => __webpack_exports__Inline,
  InlineBlock: () => __webpack_exports__InlineBlock,
  InlineGlyph: () => __webpack_exports__InlineGlyph,
  MSDFFontMaterialUtils: () => __webpack_exports__MSDFFontMaterialUtils,
  MaterialTransformers: () => __webpack_exports__MaterialTransformers,
  MeshUIBaseElement: () => __webpack_exports__MeshUIBaseElement,
  ShaderChunkUI: () => __webpack_exports__ShaderChunkUI,
  Text: () => __webpack_exports__Text,
  TypographicFont: () => __webpack_exports__TypographicFont,
  TypographicGlyph: () => __webpack_exports__TypographicGlyph,
  default: () => __webpack_exports__default,
  update: () => __webpack_exports__update
});
var __webpack_require__ = {};
(() => {
  __webpack_require__.d = (exports, definition) => {
    for (var key in definition) {
      if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
        Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
      }
    }
  };
})();
(() => {
  __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
})();
(() => {
  __webpack_require__.r = (exports) => {
    if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
      Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    }
    Object.defineProperty(exports, "__esModule", { value: true });
  };
})();
var __webpack_exports__ = {};
__webpack_require__.d(__webpack_exports__, {
  ti: () => (
    /* reexport */
    BaseProperty
  ),
  nS: () => (
    /* reexport */
    Behavior
  ),
  eB: () => (
    /* reexport */
    BlockElement
  ),
  Yp: () => (
    /* reexport */
    DefaultValues_namespaceObject
  ),
  VB: () => (
    /* reexport */
    font_FontLibrary
  ),
  BC: () => (
    /* reexport */
    font_FontVariant
  ),
  zN: () => (
    /* reexport */
    InheritableProperty
  ),
  cV: () => (
    /* reexport */
    InlineElement
  ),
  hW: () => (
    /* reexport */
    InlineBlockElement
  ),
  k2: () => (
    /* reexport */
    InlineGlyph
  ),
  K6: () => (
    /* reexport */
    MSDFFontMaterialUtils
  ),
  M7: () => (
    /* reexport */
    MaterialTransformers_namespaceObject
  ),
  ls: () => (
    /* reexport */
    MeshUIBaseElement
  ),
  Hi: () => (
    /* reexport */
    ShaderChunkUI
  ),
  EY: () => (
    /* reexport */
    TextElement
  ),
  MR: () => (
    /* reexport */
    TypographicFont
  ),
  zf: () => (
    /* reexport */
    TypographicGlyph
  ),
  Ay: () => (
    /* binding */
    three_mesh_ui
  ),
  yo: () => (
    /* binding */
    update
  )
});
var DefaultValues_namespaceObject = {};
__webpack_require__.r(DefaultValues_namespaceObject);
__webpack_require__.d(DefaultValues_namespaceObject, {
  get: () => get,
  set: () => set
});
var MaterialTransformers_namespaceObject = {};
__webpack_require__.r(MaterialTransformers_namespaceObject);
__webpack_require__.d(MaterialTransformers_namespaceObject, {
  alphaTestTransformer: () => alphaTestTransformer,
  asPreprocessorValueTransformer: () => asPreprocessorValueTransformer,
  toPreprocessorTriggerTransformer: () => toPreprocessorTriggerTransformer,
  toUserDataTransformer: () => toUserDataTransformer,
  uniformOrUserDataTransformer: () => uniformOrUserDataTransformer
});
var _values = {
  fontFamily: null,
  fontSize: 0.05,
  fontKerning: "auto",
  fontStyle: "normal",
  fontWeight: "normal",
  offset: 5e-3,
  lineHeight: 1.2,
  lineBreak: "- ,.:?!\n",
  // added '\n' to also acts as friendly breaks when white-space:normal
  whiteSpace: "pre-line",
  flexDirection: "column",
  justifyContent: "start",
  alignItems: "start",
  backgroundImage: null,
  textAlign: "left",
  boxSizing: "content-box",
  position: "static",
  color: 16777215,
  fontColor: 16777215,
  fontOpacity: 1,
  opacity: 1,
  fontPXRange: 4,
  fontSupersampling: true,
  fontSmooth: "antialiased",
  borderRadius: 0,
  borderWidth: 0,
  borderColor: "black",
  borderOpacity: 1,
  backgroundSize: "cover",
  backgroundColor: 0,
  backgroundOpacity: 0,
  overflow: "visible",
  letterSpacing: 0,
  invertAlpha: false,
  segments: 1
};
var set = function(overrideProperties) {
  for (const property in overrideProperties) {
    _values[property] = overrideProperties[property];
  }
};
var get = function(property) {
  if (!Object.prototype.hasOwnProperty.call(_values, property)) {
    console.warn(`ThreeMeshUI::DefaultValues is trying to retrieve non-existing property '${property}'`);
  }
  return _values[property];
};
var BaseProperty = class {
  /**
   *
   * @param {string} propertyId
   * @param {any} [value=null]
   * @param primitive
   */
  constructor(propertyId, value = null, primitive = true) {
    this._id = propertyId;
    this._value = value;
    this._needsUpdate = true;
    this._needsProcess = false;
    this._needsRender = false;
    this._isPrimitive = primitive;
  }
  /**
   *
   * @return {string}
   */
  get id() {
    return this._id;
  }
  /**
   *
   * @return {any}
   */
  get value() {
    return this._value;
  }
  /**
   *
   * @param {any} value
   */
  set value(value) {
    if (!this.isValid(value))
      return;
    if (this._value !== value) {
      this._value = value;
      this._needsUpdate = true;
    }
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @param element
   * @param {Object.<string,any>} out
   */
  update(element, out) {
    this.output(out);
  }
  /* eslint-disable no-unused-vars */
  /**
   * Output this property in a dictionnary
   * @param {Object.<string,any>} out
   */
  output(out) {
  }
  /**
   *
   * @param {Out} out
   */
  _outputValue(out) {
    out[this._id] = this._value;
  }
  /* eslint-disable no-unused-vars */
  /**
   * Execute additional process after all properties have been updated
   * @param {MeshUIBaseElement} element
   */
  process(element) {
  }
  /* eslint-disable no-unused-vars */
  /**
   * Execute additional process after all properties have been updated
   * @param {MeshUIBaseElement} element
   */
  render(element) {
  }
  /**
   *
   * @param {MeshUIBaseElement} element
   */
  getInheritedInput(element) {
    if (this._value !== "inherit")
      return this._value;
    const parent = element._parent._value;
    if (parent && parent[`_${this._id}`]) {
      return parent[`_${this._id}`].getInheritedInput(parent);
    }
    return this.getDefaultValue();
  }
  /**
   *
   * @return {any}
   */
  getDefaultValue() {
    return get(this._id);
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @param {any} value
   * @return {boolean}
   */
  isValid(value) {
    return true;
  }
  /**
   *
   */
  emptyStrategyLogic() {
    throw new Error(`ThreeMeshUI::${this.constructor.name} has empty strategy. Update has not been processed.`);
  }
  requestUpdate() {
    this._needsUpdate = true;
  }
  requestProcess() {
    this._needsProcess = false;
  }
  requestRender() {
    this._needsRender = false;
  }
};
var RenderOrderProperty = class extends BaseProperty {
  constructor() {
    super("renderOrder", "auto", true);
    this.output = this._outputValue;
    this._actualValue = 0;
  }
  /**
   *
   * @param {number} value
   */
  set value(value) {
    if (!this.isValid(value))
      return;
    this._value = value;
    this._needsUpdate = true;
  }
  update(element, out) {
    if (this._value !== "auto") {
      this._actualValue = this._value;
    } else {
      const parent = element._parent._value;
      if (parent !== null) {
        const parentIndex = parent._renderOrder._actualValue;
        const positionInParent = 1 + parent._children._uis.indexOf(element);
        this._actualValue = parentIndex + positionInParent;
      }
    }
    for (const childUIElement of element._children._uis) {
      const property = childUIElement[`_renderOrder`];
      if (property._value === "auto")
        childUIElement[`_renderOrder`]._needsUpdate = true;
    }
    this._outputValue(out);
  }
  _outputValue(out) {
    out[this._id] = this._actualValue;
  }
  /**
   *
   * @return {number}
   */
  get value() {
    return this._value;
  }
};
var InheritableProperty = class extends BaseProperty {
  /**
   *
   * @param {string} propertyId
   * @param {any} [value=null]
   * @param primitive
   */
  constructor(propertyId, value = null, primitive = true) {
    super(propertyId, value, primitive);
    this.output = this._outputValue;
    this._notInheritedValue = null;
  }
  update(element, out) {
    this._notInheritedValue = this._value;
    if (this._notInheritedValue === "inherit") {
      this._notInheritedValue = this.getInheritedInput(element);
    }
    this.propagate(element);
    this._outputValue(out);
  }
  propagate(element) {
    for (const childUIElement of element._children._uis) {
      const property = childUIElement[`_${this._id}`];
      if (property !== void 0 && property._value === "inherit") {
        childUIElement[`_${this._id}`]._needsUpdate = true;
      }
    }
  }
  /**
   * Output this property in a dictionnary
   * @override
   */
  _outputValue(out) {
    out[this._id] = this._notInheritedValue;
  }
  set value(value) {
    if (!this.isValid(value))
      return;
    if (this._value !== value) {
      this._value = value;
      this._needsUpdate = true;
    }
  }
  /**
   *
   * @override
   * @return {any|"inherit"}
   */
  get value() {
    if (this._value === "inherit")
      return this._notInheritedValue;
    return this._value;
  }
};
var OffsetProperty = class extends InheritableProperty {
  constructor() {
    super("offset", "inherit", false);
  }
  /* eslint-disable no-unused-vars */
  update(element, out) {
    super.update(element, out);
    if (element._parent._value !== null)
      element.position.z = this._notInheritedValue;
  }
};
var FontSmoothProperty = class extends InheritableProperty {
  constructor() {
    super("fontSmooth", "inherit", true);
    this._needsUpdate = false;
    this.isValid = _isValid;
    this.output = this._outputValue;
  }
};
var AVAILABLE_VALUES = ["inherit", "none", "antialiased"];
function _isValid(value) {
  if (AVAILABLE_VALUES.indexOf(value) === -1) {
    console.warn(`.fontSmoothing value '${value}' is not valid. Aborted`);
    return false;
  }
  return true;
}
var x = (y) => {
  var x2 = {};
  __webpack_require__.d(x2, y);
  return x2;
};
var external_three_namespaceObject = x({ ["BackSide"]: () => BackSide, ["BufferAttribute"]: () => BufferAttribute2, ["BufferGeometry"]: () => BufferGeometry, ["Color"]: () => Color, ["DoubleSide"]: () => DoubleSide, ["EventDispatcher"]: () => EventDispatcher, ["FileLoader"]: () => FileLoader, ["FrontSide"]: () => FrontSide, ["LinearFilter"]: () => LinearFilter, ["Mesh"]: () => Mesh, ["MeshBasicMaterial"]: () => MeshBasicMaterial, ["Object3D"]: () => Object3D, ["Plane"]: () => Plane, ["PlaneGeometry"]: () => PlaneGeometry, ["ShaderMaterial"]: () => ShaderMaterial, ["Texture"]: () => Texture, ["TextureLoader"]: () => TextureLoader, ["Vector2"]: () => Vector2, ["Vector3"]: () => Vector32, ["Vector4"]: () => Vector4 });
var SubStyleProperty = class extends BaseProperty {
  /**
   *
   * @param {string} propertyId
   * @param {boolean} [primitive=true]
   * @param {any} defaultValue
   */
  constructor(propertyId, defaultValue, primitive = true) {
    super(propertyId, "unset", primitive);
    this._input = "inherit";
    this._allowsInherit = true;
    this._inheritedInput = void 0;
    this._inline = void 0;
  }
  /**
   *
   * @param {MeshUIBaseElement} element
   * @param {Object.<string,any> } out
   */
  update(element, out) {
    if (!this._allowsInherit) {
      this._inheritedInput = this.getInheritedInput(element);
    }
    this.computeOutputValue(element);
    for (const childUIElement of element._children._uis) {
      const property = childUIElement[`_${this._id}`];
      const target = property._input ? property._input : property._value;
      if (target === "inherit")
        childUIElement[`_${this._id}`]._needsUpdate = true;
    }
    this.output(out);
  }
  /**
   *
   * @param {MeshUIBaseElement} element
   */
  computeOutputValue(element) {
    this._value = this._input;
  }
  /**
   *
   * @param {MeshUIBaseElement} element
   */
  _computeFromInherited(element) {
    this._value = this._inheritedInput;
  }
  /**
   * @override
   * @deprecated
   * @param {any} v
   */
  set value(v4) {
    console.warn(".(style) sub-property cannot be directly set. It must comes from inline or computed setter.");
  }
  /**
   *
   * @param {any} value
   */
  set inline(value) {
    if (!this.isValidValue(value))
      return;
    if (value === this._inline) {
      return;
    }
    this._input = this._inline = value;
    this._needsUpdate = true;
  }
  /**
   *
   * @return {any}
   */
  get inline() {
    return this._inline;
  }
  /**
   *
   * @param {any} value
   * @return {boolean}
   */
  isValidValue(value) {
    return true;
  }
  /**
   * @param {MeshUIBaseElement} element
   */
  getInheritedInput(element) {
    if (this._input !== "inherit")
      return this._input;
    const parent = element._parent._value;
    if (parent) {
      return parent[`_${this._id}`].getInheritedInput(parent);
    }
    return this.getDefaultValue();
  }
};
var StyleVector4Property = class extends SubStyleProperty {
  constructor(propertyId, defaultValue) {
    super(propertyId, defaultValue, false);
    this._input = new external_three_namespaceObject.Vector4(0, 0, 0, 0);
    this._inline = null;
    this._value = new external_three_namespaceObject.Vector4(0, 0, 0, 0);
  }
  /**
   * @override
   * @return {Vector4}
   */
  get value() {
    return this._value;
  }
  /* eslint-disable no-unused-vars */
  /**
   * @override
   */
  computeOutputValue(element) {
    this._vector4ValueSetter(this._value, this._input);
  }
  set inline(value) {
    this._vector4ValueSetter(this._input, value);
    if (this._input.equals(this._value))
      return;
    this._needsUpdate = true;
  }
  /**
   *
   * @param {Number} v
   */
  set top(v4) {
    if (this._input.x === v4)
      return;
    this._input.x = v4;
    this._needsUpdate = true;
  }
  /**
   *
   * @returns {number}
   */
  get top() {
    return this._input.x;
  }
  /**
   *
   * @param {Number} v
   */
  set right(v4) {
    if (this._input.y === v4)
      return;
    this._input.y = v4;
    this._needsUpdate = true;
  }
  /**
   *
   * @returns {number}
   */
  get right() {
    return this._input.y;
  }
  /**
   *
   * @param {Number} v
   */
  set bottom(v4) {
    if (this._input.z === v4)
      return;
    this._input.z = v4;
    this._needsUpdate = true;
  }
  /**
   *
   * @returns {number}
   */
  get bottom() {
    return this._input.z;
  }
  /**
   *
   * @param {Number} v
   */
  set left(v4) {
    if (this._input.w === v4)
      return;
    this._input.w = v4;
    this._needsUpdate = true;
  }
  /**
   *
   * @returns {number}
   */
  get left() {
    return this._input.w;
  }
  dispose() {
    this._computed = null;
    this._inline = null;
    this._input = null;
    this._output = null;
  }
  /**
   *
   * @param {Vector4} vector4
   * @param {Vector4|Array.<Number>|Number|String} value
   * @protected
   */
  _vector4ValueSetter(vector4, value) {
    if (value instanceof external_three_namespaceObject.Vector4) {
      vector4.copy(value);
      return;
    }
    if (typeof value === "string" || value instanceof String) {
      value = value.split(" ");
    }
    if (Array.isArray(value)) {
      value = value.map((v4) => parseFloat(v4));
      switch (value.length) {
        case 1:
          vector4.setScalar(value[0]);
          return;
        case 2:
          vector4.x = vector4.z = value[0];
          vector4.y = vector4.w = value[1];
          return;
        case 3:
          vector4.x = value[0];
          vector4.y = value[1];
          vector4.z = value[2];
          return;
        case 4:
          vector4.x = value[0];
          vector4.y = value[1];
          vector4.z = value[2];
          vector4.w = value[3];
          return;
        default:
          console.error("StyleVector4Property::set() Four Dimension property had more than four values");
          return;
      }
    }
    if (!isNaN(value)) {
      vector4.setScalar(value);
    }
  }
};
var PaddingProperty = class extends StyleVector4Property {
  constructor() {
    super("padding", new external_three_namespaceObject.Vector4(0, 0, 0, 0));
  }
  computeOutputValue(element) {
    super.computeOutputValue(element);
    element._bounds._needsUpdate = true;
    element._bounds._needsRender = true;
    element._layouter._needsProcess = true;
    element._renderer._needsRender = true;
    if (element._parent._value) {
      element._parent._value._layouter._needsProcess = true;
    }
  }
};
var MarginProperty = class extends StyleVector4Property {
  constructor() {
    super("margin", new external_three_namespaceObject.Vector4(0, 0, 0, 0));
  }
  computeOutputValue(element) {
    super.computeOutputValue(element);
    element._renderer._needsRender = true;
    if (element._parent._value) {
      element._parent._value._flexDirection._needsProcess = true;
    }
  }
};
var directTransfer = function(target, targetProperty, value) {
  target[targetProperty] = value;
};
var directTransferNotNull = function(target, targetProperty, value) {
  if (value === null)
    return;
  target[targetProperty] = value;
};
var Mediator = class {
  /**
   * @constructor
   * @param {MediationDefinition} definition
   */
  constructor(definition) {
    this._definition = definition;
  }
  /**
   *
   * @param {MediationDefinition} value
   */
  set definition(value) {
    this._definition = value;
  }
  /**
   *
   * @param {MeshUIBaseElement} subject
   * @param {any} target
   * @param {Object.<(string|number), any>} options
   * @param {any} [secondTarget=null]
   */
  mediate(subject, target, options, secondTarget = null) {
    for (const subjectProperty in this._definition) {
      const mediationDefinition = this._definition[subjectProperty];
      if (options[subjectProperty] !== void 0) {
        const mediationTransformer = mediationDefinition.t ? mediationDefinition.t : directTransfer;
        mediationTransformer(target, mediationDefinition.m, options[subjectProperty]);
        if (secondTarget) {
          mediationTransformer(secondTarget, mediationDefinition.m, options[subjectProperty]);
        }
      }
    }
  }
  /***********************************************************************************************************************
   * STATIC
   **********************************************************************************************************************/
  /**
   *
   * @param {MeshUIComponent} subject
   * @param {any} target
   * @param {Object.<(string|number), any>} options
   * @param {Object.<{subjectProperty:string, t?:(target:any, targetProperty:string, value:any) => void}>} mediationDefinitions
   * @param {any} [secondTarget=null]
   */
  static mediate(subject, target, options, mediationDefinitions2, secondTarget = null) {
    if (!target)
      return;
    for (const subjectProperty in mediationDefinitions2) {
      const definition = mediationDefinitions2[subjectProperty];
      if (options[subjectProperty] !== void 0) {
        const mediationTransformer = definition.t ? definition.t : directTransfer;
        mediationTransformer(target, definition.m, options[subjectProperty]);
        if (secondTarget) {
          mediationTransformer(secondTarget, definition.m, options[subjectProperty]);
        }
      }
    }
  }
};
var ParentProperty = class extends BaseProperty {
  constructor() {
    super("parent", null, false);
  }
  /* eslint-disable no-unused-vars */
  /**
   * Update when :
   * 		- element has been added
   * 		- element has been removed
   *
   * @param element
   * @param out
   */
  update(element, out) {
    if (element.parent && element.parent.isUI) {
      this._value = element.parent;
    } else {
      this._value = null;
    }
  }
  set value(value) {
    console.warn("ParentProperty is readonly");
  }
  /**
   *
   * @return {MeshUIBaseElement}
   */
  get value() {
    return this._value;
  }
  /**
   *
   * @param {(p:Object3D)=>boolean } conditionCallback
   */
  find(conditionCallback) {
    if (this._value) {
      if (conditionCallback(this._value)) {
        return this._value;
      }
      return this._value._parent.find(conditionCallback);
    }
    return null;
  }
  /**
   *
   */
  dispose() {
    this._value = null;
  }
};
var numberEquals = function(numA, numB, precision = 6) {
  return numA.toFixed(precision) === numB.toFixed(precision);
};
var NumberProperty = class extends BaseProperty {
  /**
   *
   * @param {string} propertyId
   * @param {number} [value]
   */
  constructor(propertyId, value) {
    super(propertyId, value, true);
    this.output = this._outputValue;
  }
  /**
   *
   * @param {number} value
   */
  set value(value) {
    if (!this.isValid(value))
      return;
    if (numberEquals(this._value, value))
      return;
    this._value = value;
    this._needsUpdate = true;
  }
  /**
   *
   * @return {number}
   */
  get value() {
    return this._value;
  }
};
var SideProperty = class extends InheritableProperty {
  /**
   *
   * @param {string} propertyId
   */
  constructor(propertyId) {
    super(propertyId, "inherit", true);
    this.isValid = SideProperty_isValid;
  }
};
var SideProperty_AVAILABLE_VALUES = [external_three_namespaceObject.FrontSide, external_three_namespaceObject.BackSide, external_three_namespaceObject.DoubleSide];
function SideProperty_isValid(value) {
  if (SideProperty_AVAILABLE_VALUES.indexOf(value) === -1) {
    console.warn(`SideProperty value '${value}' is not valid. Abort`);
    return false;
  }
  return true;
}
var Inline = class {
  constructor() {
    this._offsetX = 0;
    this._offsetY = 0;
    this._lineBreak = null;
    this._kerning = 0;
    this._fontFactor = 1;
    this._fontSize = 0;
    this._cumulativeWidth = 0;
    this._paddingLeft = 0;
    this._paddingRight = 0;
    this._marginLeft = 0;
    this._marginRight = 0;
  }
  /**
   * @returns {void}
   */
  resetOffsets() {
    this._offsetX = this._offsetY = 0;
    this._cumulativeWidth = 0;
  }
  /**
   * The horizontal distance this inline fills
   * @returns {number}
   */
  get xadvance() {
    return 0;
  }
  /**
   * The offset x of this inline in a line
   * @returns {number}
   */
  get xoffset() {
    return 0;
  }
  /**
   * The offset y of this inline in a line
   * @returns {number}
   */
  get yoffset() {
    return 0;
  }
  /**
   *
   * @returns {number}
   */
  get width() {
    return 0;
  }
  /**
   *
   * @returns {number}
   */
  get height() {
    return 0;
  }
  /**
   *
   * @param {string|null} value
   */
  set lineBreak(value) {
    this._lineBreak = value;
  }
  /**
   *
   * @returns {string|null}
   */
  get lineBreak() {
    return this._lineBreak;
  }
  /**
   *
   * @returns {number}
   */
  get anchor() {
    return 0;
  }
  /**
   *
   * @returns {number}
   */
  get kerning() {
    return this._kerning * this._fontFactor;
  }
  /**
   *
   * @param {number} value
   */
  set kerning(value) {
    this._kerning = value;
  }
  /**
   *
   * @returns {number}
   */
  get fontSize() {
    return this._fontSize;
  }
  /**
   *
   * @param {number} value
   */
  set fontSize(value) {
    this._fontSize = value;
  }
  /**
   *
   * @returns {number}
   */
  get lineHeight() {
    return 0;
  }
  /**
   *
   * @returns {number}
   */
  get offsetX() {
    return this._offsetX;
  }
  /**
   *
   * @param value
   */
  set offsetX(value) {
    this._offsetX = value;
  }
  /**
   *
   * @returns {number}
   */
  get offsetY() {
    return this._offsetY;
  }
  /**
   *
   * @param {number} value
   */
  set offsetY(value) {
    this._offsetY = value;
  }
  /**
   *
   * @return {number}
   */
  get cumulativeWidth() {
    return this._cumulativeWidth;
  }
  /**
   *
   * @param {number} value
   */
  set cumulativeWidth(value) {
    this._cumulativeWidth = value;
  }
  /**
   *
   * @return {number}
   */
  get marginLeft() {
    return this._marginLeft;
  }
  /**
   *
   * @param {number} value
   */
  set marginLeft(value) {
    this._marginLeft = value;
  }
  /**
   *
   * @return {number}
   */
  get marginRight() {
    return this._marginRight;
  }
  /**
   *
   * @param {number} value
   */
  set marginRight(value) {
    this._marginRight = value;
  }
  /**
   *
   * @return {number}
   */
  get paddingLeft() {
    return this._paddingLeft;
  }
  /**
   *
   * @param {number} value
   */
  set paddingLeft(value) {
    this._paddingLeft = value;
  }
  /**
   *
   * @return {number}
   */
  get paddingRight() {
    return this._paddingRight;
  }
  /**
   *
   * @param {number} value
   */
  set paddingRight(value) {
    this._paddingRight = value;
  }
  /**
   *
   * @returns {number}
   */
  get lineBase() {
    return 0;
  }
  /**
   *
   * @param {number} value
   */
  set fontFactor(value) {
    this._fontFactor = value;
  }
  /**
   *
   * @returns {number}
   */
  get fontFactor() {
    return this._fontFactor;
  }
};
var TypographicGlyph = class {
  /**
   *
   * @param {TypographicFont} typographicFont
   */
  constructor(typographicFont) {
    this._char = "";
    this._width = 1;
    this._heigth = 1;
    this._xadvance = 1;
    this._xoffset = 0;
    this._yoffset = 0;
    this._font = typographicFont;
  }
  /**
   *
   * @returns {TypographicFont}
   */
  get font() {
    return this._font;
  }
  /**
   *
   * @return {string}
   */
  get char() {
    return this._char;
  }
  /**
   *
   * @returns {number}
   */
  get width() {
    return this._width;
  }
  /**
   *
   * @returns {number}
   */
  get height() {
    return this._heigth;
  }
  /**
   *
   * @returns {number}
   */
  get xadvance() {
    return this._xadvance;
  }
  /**
   *
   * @returns {number}
   */
  get xoffset() {
    return this._xoffset;
  }
  /**
   *
   * @returns {number}
   */
  get yoffset() {
    return this._yoffset;
  }
  /**
   *
   * @param value
   */
  set yoffset(value) {
    this._yoffset = value;
  }
  /**
   *
   * @abstract
   * @param {string} otherChar
   * @returns {TypographicGlyph}
   */
  /* eslint-disable no-unused-vars */
  clone(otherChar) {
    throw new Error("Abstract... Need to be implemented");
  }
  /**
   *
   * @abstract
   * @returns {InlineGlyph}
   */
  asInlineGlyph() {
    throw new Error("Abstract... Need to be implemented");
  }
};
var InlineGlyph = class extends Inline {
  /**
   *
   * @param {TypographicGlyph} characterDesc
   */
  constructor(characterDesc) {
    super();
    this._typographic = characterDesc;
  }
  /**
   *
   * @returns {TypographicGlyph}
   */
  get typographic() {
    return this._typographic;
  }
  /*********************************************************************************************************************
   * GETTERS FROM CHARACTER DESCRIPTION
   ********************************************************************************************************************/
  /**
   * @override
   * @returns {number}
   */
  get xadvance() {
    return this._typographic.xadvance * this._fontFactor;
  }
  /**
   * @override
   * @returns {number}
   */
  get xoffset() {
    return this._typographic.xoffset * this._fontFactor;
  }
  /**
   * @override
   * @returns {number}
   */
  get yoffset() {
    return this._typographic.yoffset * this._fontFactor;
  }
  /**
   * @override
   * @returns {number}
   */
  get width() {
    return this._typographic.width * this._fontFactor;
  }
  /**
   * @override
   * @returns {number}
   */
  get height() {
    return this._typographic.height * this._fontFactor;
  }
  /**
   *
   * @return {string}
   */
  get char() {
    return this._typographic.char;
  }
  /**
   * @override
   * @returns {number}
   */
  get anchor() {
    return this.yoffset;
  }
  /**
   * @override
   * @returns {number}
   */
  get lineHeight() {
    return this._typographic.font.lineHeight * this._fontFactor;
  }
  /**
   * @override
   * @returns {number}
   */
  get lineBase() {
    return this._typographic.font.lineBase * this._fontFactor;
  }
};
var FONT_WEIGHT_LOOK_UP_TABLE = {
  "light": "100",
  "normal": "400",
  "bold": "700",
  "bolder": "900"
};
function uniformizeFontWeight(weight) {
  if (!isNaN(weight))
    return weight.toString();
  const converted = FONT_WEIGHT_LOOK_UP_TABLE[weight];
  if (converted)
    return converted;
  return weight;
}
var FontVariant = class extends external_three_namespaceObject.EventDispatcher {
  /**
   *
   * @param {import('./../core/elements/MeshUIBaseElement').FontWeightFormat} weight
   * @param {"normal"|"italic"} style
   */
  constructor(weight, style) {
    super();
    this._isReady = false;
    this._weight = uniformizeFontWeight(weight);
    this._style = style;
    this._size = 42;
    this._lineHeight = 42;
    this._lineBase = 42;
    this._font = null;
  }
  /**
   *
   * @returns {TypographicFont}
   */
  get typographic() {
    return this._font;
  }
  /**
   *
   * @returns {boolean}
   */
  get isReady() {
    return this._isReady;
  }
  /**
   *
   * @returns {string}
   */
  get weight() {
    return this._weight;
  }
  /**
   *
   * @returns {string}
   */
  get style() {
    return this._style;
  }
  /**
   *
   * @returns {Texture}
   */
  get texture() {
    return this._texture;
  }
  /**
   * @param {Function.<ShaderMaterial|Material>} v
   * @abstract
   */
  set fontMaterial(v4) {
    throw Error(`FontVariant('${this.id}')::fontMaterial - is abstract.`);
  }
  /**
   * @return {Function.<ShaderMaterial|Material>}
   * @abstract
   */
  get fontMaterial() {
    throw Error(`FontVariant('${this.id}')::fontMaterial - is abstract.`);
  }
  /**
   *
   * @returns {string}
   */
  get id() {
    return `${this._name}(w:${this.weight},s:${this.style})`;
  }
  /**
   *
   * @param {string} character
   * @returns {TypographicGlyph}
   */
  getTypographicGlyph(character) {
    let typographicGlyph = this._chars[character];
    if (typographicGlyph)
      return typographicGlyph;
    if (character.match(/\s/))
      return this._chars[" "];
    const fallbackCharacter = this._getFallbackCharacter(character);
    if (fallbackCharacter) {
      typographicGlyph = this._chars[fallbackCharacter];
      if (typographicGlyph)
        return typographicGlyph;
    }
    throw Error(`FontVariant('${this.id}')::getTypographicGlyph() - character('${character}') and/or fallback character were not found in provided msdf charset.`);
  }
  /* eslint-disable no-unused-vars */
  /**
   * @abstract
   * @protected
   * @param {string} missingChar
   * @returns {string|null}
   */
  _getFallbackCharacter(missingChar) {
    throw new Error(`FontVariant(${typeof this})::_getFallbackCharacter() is abstract and should therefore be overridden.`);
  }
  /* eslint-disable no-unused-vars */
  /**
   * Convert an InlineCharacter to a geometry
   *
   * @abstract
   * @param {InlineGlyph} inline
   * @param {MeshUIBaseElement} element
   * @returns {BufferGeometry|Array.<BufferGeometry>}
   */
  getGeometricGlyph(inline, element) {
    throw new Error(`FontVariant(${typeof this})::getGeometryCharacter() is abstract and should therefore be overridden.`);
  }
  /* eslint-enable no-unused-vars */
  /**
   * Obtain the kerning amount of a glyphPair
   * @param {string} glyphPair
   * @returns {number}
   */
  getKerningAmount(glyphPair) {
    return this._kernings[glyphPair] ? this._kernings[glyphPair] : 0;
  }
  /**
   * Perform some changes on the character description of this font
   * @param {Object.<string,Object.<string,number|string>>} adjustmentObject
   */
  adjustTypographicGlyphs(adjustmentObject) {
    for (const char in adjustmentObject) {
      const typographicGlyph = this.getTypographicGlyph(char);
      const glyphAdjustment = adjustmentObject[char];
      for (const propertyToAdjust in glyphAdjustment) {
        typographicGlyph["_" + propertyToAdjust] = adjustmentObject[char][propertyToAdjust];
      }
    }
  }
  /**
   *
   * @private
   */
  _checkReadiness() {
    if (this._readyCondition()) {
      _setReady(this);
    }
  }
  /* eslint-disable no-unused-vars */
  /**
   * @abstract
   * @param element
   * @internal
   */
  _alterElementProperties(element) {
    throw new Error(`FontVariant(${typeof this})::_alterElementProperties() is abstract and should therefore be overridden.`);
  }
  /**
   *
   * @abstract
   * @returns {boolean}
   * @protected
   */
  _readyCondition() {
    throw new Error(`FontVariant(${typeof this})::_readyCondition() is abstract and should therefore be overridden.`);
  }
};
var _readyEvent = { type: "ready" };
function _setReady(fontVariant) {
  fontVariant._isReady = true;
  fontVariant.dispatchEvent(_readyEvent);
}
var font_FontVariant = FontVariant;
var FontProperty = class extends BaseProperty {
  /**
   *
   * @param {FontVariant} [value=null]
   */
  constructor(value = null) {
    super("font", value, false);
    this._needsUpdate = false;
    this._fontVariant = null;
    this._handleFontReadyClosure = null;
    this.isValid = FontProperty_isValid;
  }
  output(out) {
    out[this._id] = this._fontVariant;
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @override
   */
  update(element, out) {
    if (this._fontVariant && !this._fontVariant.isReady) {
      this._fontVariant.removeEventListener("ready", this._handleFontReadyClosure);
    }
    if (this._value && this._value instanceof font_FontVariant) {
      this._fontVariant = this._value;
    } else {
      const fontFamily = element._fontFamily._value;
      if (fontFamily) {
        this._fontVariant = fontFamily.getVariant(
          element._fontWeight._value,
          element._fontStyle._value
        );
      }
    }
    if (!this._fontVariant)
      return;
    this._fontVariant._alterElementProperties(element);
    this._handleFontReadyClosure = _readyClosure(element, this);
    if (!this._fontVariant.isReady) {
      this._fontVariant.addEventListener("ready", this._handleFontReadyClosure);
    } else {
      this._handleFontReadyClosure();
    }
    if (!element._fontMaterial._defaultMaterial || !(element._fontMaterial._defaultMaterial instanceof this._fontVariant.fontMaterial)) {
      element._fontMaterial._defaultMaterial = new this._fontVariant.fontMaterial();
      element._fontMaterial._needsUpdate = true;
    }
  }
  /**
   * @override
   * @param {FontVariant} value
   */
  set value(value) {
    if (!this.isValid(value))
      return;
    if (this._value !== value) {
      this._value = value;
      this._needsUpdate = true;
    }
  }
  /**
   *
   * @return {FontVariant}
   */
  get value() {
    return this._value;
  }
  /**
   *
   * @return {FontVariant|null}
   */
  get fontVariant() {
    return this._fontVariant;
  }
  /**
   *
   */
  dispose() {
    if (this._handleFontReadyClosure) {
      this._fontVariant.removeEventListener("ready", this._handleFontReadyClosure);
      this._handleFontReadyClosure = null;
    }
    this._value = null;
    this._fontVariant = null;
  }
};
function FontProperty_isValid(value) {
  if (!(value instanceof font_FontVariant)) {
    console.warn(`.font value '${value}' is not valid. It requires a FontVariant instance. Aborted`);
    return false;
  }
  return true;
}
function _readyClosure(element, fontProperty) {
  return function() {
    fontProperty._needsUpdate = true;
    element._glyphs._needsProcess = true;
    fontProperty._fontVariant.removeEventListener("ready", fontProperty._handleFontReadyClosure);
    fontProperty._handleFontReadyClosure = null;
  };
}
var Display = class extends SubStyleProperty {
  constructor(defaultValue) {
    super("display", defaultValue);
    this._value = "flex";
    this._allowsInherit = false;
    this._needsUpdate = false;
    this.isValidValue = Display_isValid;
  }
  computeOutputValue(element) {
    element._visible._value = this._output !== "none";
  }
};
var Display_AVAILABLE_VALUES = ["none", "flex"];
function Display_isValid(value) {
  if (Display_AVAILABLE_VALUES.indexOf(value) === -1) {
    console.warn(`(.style) display value '${value}' is not valid. Aborted`);
    return false;
  }
  return true;
}
var BoxSizing = class extends SubStyleProperty {
  constructor(defaultValue) {
    super("boxSizing", defaultValue);
    this._allowsInherit = false;
    this.isValidValue = BoxSizing_isValid;
  }
  computeOutputValue(element) {
    this._value = this._inheritedInput;
    element._bounds._needsUpdate = true;
  }
};
var BoxSizing_AVAILABLE_VALUES = ["border-box", "content-box"];
function BoxSizing_isValid(value) {
  if (BoxSizing_AVAILABLE_VALUES.indexOf(value) === -1) {
    console.warn(`(.style) boxSizing value '${value}' is not valid. Aborted`);
    return false;
  }
  return true;
}
var StyleColorProperty = class extends SubStyleProperty {
  constructor(propertyId, defaultValue) {
    super(propertyId, defaultValue, false);
    this._value = new external_three_namespaceObject.Color();
    this.output = this._outputValue;
  }
  /* eslint-disable no-unused-vars */
  /**
   * @override
   */
  computeOutputValue(element) {
    if (this._input !== "inherit") {
      this._value.set(this._input);
    }
  }
  set inline(value) {
    this._input = this._inline = value;
    this._needsUpdate = true;
  }
};
var StyleFactorProperty = class extends SubStyleProperty {
  /**
   *
   * @param {string} propertyId
   * @param {any} defaultValue
   */
  constructor(propertyId, defaultValue) {
    super(propertyId, defaultValue, true);
    this.isValidValue = StyleFactorProperty_isValid;
    this._allowsInherit = false;
    this._input = defaultValue;
    this._value = defaultValue;
    this.output = this._outputValue;
    this.computeOutputValue = this._computeFromInherited;
  }
  _outputValue(out) {
    out[this._id] = this._inheritedInput;
  }
};
function StyleFactorProperty_isValid(value) {
  if (value < 0 && value > 1) {
    console.warn(`(.style) styleFactorProperty('${this.id}') value '${value}' is not valid)`);
    return false;
  }
  return true;
}
var BackgroundImage = class extends SubStyleProperty {
  constructor(defaultValue) {
    super("backgroundImage", defaultValue, true);
    this._input = null;
    this._allowsInherit = false;
    this._textureSize = new external_three_namespaceObject.Vector2(1, 1);
    this.isValidValue = BackgroundImage_isValid;
  }
  /**
   * @override
   * @return {any|Texture|null}
   */
  get value() {
    return this._value;
  }
  output(out) {
    out[this._id] = this._value;
    out["tSize"] = this._textureSize;
  }
  /* eslint-disable no-unused-vars */
  computeOutputValue(element) {
    this._value = this._inheritedInput;
    if (this._value instanceof external_three_namespaceObject.Texture && !this._value.image) {
      console.warn(`ThreeMeshUI - .backgroundImage :: Please provide preloaded texture in order to have accurate sizing.`);
      return;
    }
    this._needsProcess = true;
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @param element
   */
  process(element) {
    if (this._value) {
      this._textureSize.set(this._value.image.width, this._value.image.height);
    } else {
      this._textureSize.set(1, 1);
    }
  }
};
function BackgroundImage_isValid(value) {
  return true;
}
var BackgroundSize = class extends SubStyleProperty {
  constructor(defaultValue) {
    super("backgroundSize", defaultValue, true);
    this.isValidValue = BackgroundSize_isValid;
    this.output = this._outputValue;
  }
};
var BackgroundSize_AVAILABLE_VALUES = ["cover", "contain", "stretch"];
function BackgroundSize_isValid(value) {
  if (BackgroundSize_AVAILABLE_VALUES.indexOf(value) === -1) {
    console.warn(`(.style) backgroundSize value '${value}' is not valid. Aborted`);
    return false;
  }
  return true;
}
var Overflow = class extends SubStyleProperty {
  constructor(defaultValue) {
    super("overflow", defaultValue, true);
    this.isValidValue = Overflow_isValid;
    this._clippingPlanes = null;
    this._renderStrategy = this._emptyRender;
  }
  /**
   * Update of overflow is a bit different, as parent may trigger changes on it
   * @override
   */
  update(element, out) {
    if (this._inline !== void 0 && this._inline !== "unset") {
      this._input = this._inline;
    } else if (this._computed !== void 0) {
      this._input = this._computed;
    }
    if (!this._allowsInherit) {
      this._inheritedInput = this.getInheritedInput(element);
    }
    this.computeOutputValue(element);
    for (const childUIElement of element._children._uis) {
      childUIElement[`_overflow`]._needsUpdate = true;
    }
    this.output(out);
  }
  output(out) {
    out["clippingPlanes"] = this._clippingPlanes;
  }
  computeOutputValue(element) {
    super.computeOutputValue(element);
    if (this._value === "hidden") {
      this._renderStrategy = this._propagateRender;
    } else {
      this._renderStrategy = this._emptyRender;
      this._clippingPlanes = null;
    }
    const parent = element._parent._value;
    if (parent !== null) {
      const overflowParent = parent._overflow;
      if ((overflowParent._value === "hidden" || overflowParent._clippingPlanes !== null) && !this._clippingPlanes) {
        this._clippingPlanes = [
          // top
          new external_three_namespaceObject.Plane(new external_three_namespaceObject.Vector3(0, -1, 0), 1),
          // right
          new external_three_namespaceObject.Plane(new external_three_namespaceObject.Vector3(-1, 0, 0), 1),
          // bottom
          new external_three_namespaceObject.Plane(new external_three_namespaceObject.Vector3(0, 1, 0), 1),
          // left
          new external_three_namespaceObject.Plane(new external_three_namespaceObject.Vector3(1, 0, 0), 1)
        ];
        for (let i = 0; i < this._clippingPlanes.length; i++) {
          this._clippingPlanes[i].parent = parent;
        }
        if (overflowParent._clippingPlanes !== null) {
          this._clippingPlanes.push(...overflowParent._clippingPlanes);
        }
        this._renderStrategy = this._hiddenRender;
        this._needsRender = true;
      } else if ((overflowParent._value === "visible" || overflowParent._clippingPlanes === null) && this._clippingPlanes !== null) {
        this._clippingPlanes = null;
        this._renderStrategy = this._emptyRender;
        this._needsRender = true;
      }
    }
  }
  render(element) {
    this._renderStrategy(element);
  }
  /* eslint-disable no-unused-vars */
  _emptyRender(element) {
  }
  _hiddenRender(element) {
    const parentUI = element._parent._value;
    const yLimit = parentUI._bounds._offsetHeight;
    const xLimit = parentUI._bounds._offsetWidth;
    const padding = parentUI._padding._value;
    const border = parentUI._borderWidth._value;
    for (let i = 0; i < 4 && i < this._clippingPlanes.length; i++) {
      const clippingPlane = this._clippingPlanes[i];
      switch (i % 4) {
        case 0:
          clippingPlane.constant = yLimit / 2 - (padding.x + border.x);
          break;
        case 1:
          clippingPlane.constant = xLimit / 2 - (padding.y + border.y);
          break;
        case 2:
          clippingPlane.constant = yLimit / 2 - (padding.z + border.z);
          break;
        case 3:
          clippingPlane.constant = xLimit / 2 - (padding.w + border.w);
          break;
      }
      clippingPlane.applyMatrix4(parentUI.matrixWorld);
    }
    for (let i = 0; i < element._children._uis.length; i++) {
      const ui = element._children._uis[i];
      ui._overflow._needsRender = true;
    }
  }
  _propagateRender(element) {
    for (let i = 0; i < element._children._uis.length; i++) {
      const ui = element._children._uis[i];
      ui._overflow._needsRender = true;
    }
  }
};
var Overflow_AVAILABLE_VALUES = ["visible", "hidden"];
function Overflow_isValid(value) {
  if (Overflow_AVAILABLE_VALUES.indexOf(value) === -1) {
    console.warn(`(.style) overflow value '${value}' is not valid. Aborted`);
    return false;
  }
  return true;
}
var WORLD_UNITS = "rem";
var UV = "em";
var PERCENT = "%";
var availableUnits = [WORLD_UNITS, UV, PERCENT];
var validateUnits = function(requestedUnits) {
  if (availableUnits.indexOf(requestedUnits) === -1)
    return WORLD_UNITS;
  return requestedUnits;
};
var BorderRadius = class extends StyleVector4Property {
  /**
   *
   * @param {Vector4} defaultValue
   */
  constructor(defaultValue) {
    super("borderRadius", defaultValue);
    this._valueUV = this._value.clone();
    this._input = new external_three_namespaceObject.Vector4(0, 0, 0, 0);
    this._mediation = true;
    this._cornerTL = new external_three_namespaceObject.Vector2(0, 1);
    this._cornerTR = new external_three_namespaceObject.Vector2(1, 1);
    this._cornerBR = new external_three_namespaceObject.Vector2(1, 0);
    this._cornerBL = new external_three_namespaceObject.Vector2(0, 0);
    const mediationTop = new BorderRadiusMediator(this._valueUV, ["x", "y"]);
    const mediationBottom = new BorderRadiusMediator(this._valueUV, ["z", "w"]);
    const mediationLeft = new BorderRadiusMediator(this._valueUV, ["x", "w"]);
    const mediationRight = new BorderRadiusMediator(this._valueUV, ["y", "z"]);
    mediationTop.complementaryMediation = mediationBottom;
    mediationBottom.complementaryMediation = mediationTop;
    mediationLeft.complementaryMediation = mediationRight;
    mediationRight.complementaryMediation = mediationLeft;
    this._sideMediators = [mediationTop, mediationBottom, mediationLeft, mediationRight];
    this._units = WORLD_UNITS;
  }
  /**
   *
   * @param {string} units
   */
  set units(units) {
    this._units = validateUnits(units);
    this._needsProcess = true;
  }
  /**
   *
   * @returns {string}
   */
  get units() {
    return this._units;
  }
  /**
   *
   * @param {boolean} v
   */
  set mediation(v4) {
    if (v4 !== this._mediation) {
      this._mediation = v4;
      this._needsUpdate = true;
    }
  }
  /**
   *
   * @returns {boolean}
   */
  get mediation() {
    return this._mediation;
  }
  /**
   *
   * @param {Object.<string,any>} out
   */
  output(out) {
    out["cornerTL"] = this._cornerTL;
    out["cornerTR"] = this._cornerTR;
    out["cornerBR"] = this._cornerBR;
    out["cornerBL"] = this._cornerBL;
  }
  /**
   *
   * @override
   */
  /* eslint-disable no-unused-vars */
  computeOutputValue(element) {
    this._vector4ValueSetter(this._value, this._input);
    this._needsProcess = true;
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @override
   */
  process(element) {
    this._needsRender = true;
  }
  /**
   *
   * @override
   */
  render(element) {
    this._valueUV.copy(this._value);
    const elementWidth = element._bounds._offsetWidth;
    const elementHeight = element._bounds._offsetHeight;
    if (this._units === PERCENT) {
      this._valueUV.divideScalar(100);
    }
    if (this._units === WORLD_UNITS) {
      this._valueUV.divideScalar(Math.min(elementWidth, elementHeight));
    }
    if (this._mediation) {
      do {
        this._sideMediators.forEach((srm) => srm.computeValue());
        this._sideMediators.sort((a, b) => {
          return a.value < b.value ? 1 : -1;
        });
        if (this._sideMediators[0].value > 1) {
          this._sideMediators[0].mediate();
        }
      } while (this._sideMediators[0].value > 1);
    }
    let sX = elementWidth > elementHeight ? elementHeight / elementWidth : 1;
    let sY = elementWidth < elementHeight ? elementWidth / elementHeight : 1;
    if (this._units === PERCENT) {
      sX = sY = 1;
    }
    this._cornerTL.x = this._valueUV.x * sX;
    this._cornerTL.y = 1 - this._valueUV.x * sY;
    this._cornerTR.x = 1 - this._valueUV.y * sX;
    this._cornerTR.y = 1 - this._valueUV.y * sY;
    this._cornerBR.x = 1 - this._valueUV.z * sX;
    this._cornerBR.y = this._valueUV.z * sY;
    this._cornerBL.x = this._valueUV.w * sX;
    this._cornerBL.y = this._valueUV.w * sY;
  }
  /**
   *
   */
  dispose() {
    for (const sideMediator of this._sideMediators) {
      sideMediator.dispose();
    }
    this._sideMediators = null;
    this._cornerTL = null;
    this._cornerTR = null;
    this._cornerBR = null;
    this._cornerBL = null;
    super.dispose();
  }
  /**
   *
   * @param {Number} v
   */
  set topLeft(v4) {
    if (this._input.x === v4)
      return;
    this._input.x = v4;
    this._needsUpdate = true;
  }
  /**
   *
   * @returns {number}
   */
  get topLeft() {
    return this._input.x;
  }
  /**
   *
   * @param {Number} v
   */
  set topRight(v4) {
    if (this._input.y === v4)
      return;
    this._input.y = v4;
    this._needsUpdate = true;
  }
  /**
   *
   * @returns {number}
   */
  get topRight() {
    return this._input.y;
  }
  /**
   *
   * @param {Number} v
   */
  set bottomRight(v4) {
    if (this._input.z === v4)
      return;
    this._input.z = v4;
    this._needsUpdate = true;
  }
  /**
   *
   * @returns {number}
   */
  get bottomRight() {
    return this._input.z;
  }
  /**
   *
   * @param {Number} v
   */
  set bottomLeft(v4) {
    if (this._input.w === v4)
      return;
    this._input.w = v4;
    this._needsUpdate = true;
  }
  /**
   *
   * @returns {number}
   */
  get bottomLeft() {
    return this._input.w;
  }
  /**
   * @override
   * @param {Number} v
   */
  set top(v4) {
    if (this._input.x === v4 && this._input.y === v4)
      return;
    this._input.x = this._input.y = v4;
    this._needsUpdate = true;
  }
  /**
   * @override
   * @returns {number}
   */
  get top() {
    return (this._input.x + this._input.y) / 2;
  }
  /**
   * @override
   * @param {Number} v
   */
  set right(v4) {
    if (this._input.y === v4 && this._input.z === v4)
      return;
    this._input.y = this._input.z = v4;
    this._needsUpdate = true;
  }
  /**
   * @override
   * @returns {number}
   */
  get right() {
    return (this._input.y + this._input.z) / 2;
  }
  /**
   * @override
   * @param {Number} v
   */
  set bottom(v4) {
    if (this._input.z === v4 && this._input.w === v4)
      return;
    this._input.z = this._input.w = v4;
    this._needsUpdate = true;
  }
  /**
   * @override
   * @returns {number}
   */
  get bottom() {
    return (this._input.z + this._input.w) / 2;
  }
  /**
   * @override
   * @param {Number} v
   */
  set left(v4) {
    if (this._input.w === v4 && this._input.x === v4)
      return;
    this._input.w = this._input.x = v4;
    this._needsUpdate = true;
  }
  /**
   * @override
   * @returns {number}
   */
  get left() {
    return (this._input.w + this._input.x) / 2;
  }
};
var BorderRadiusMediator = class {
  /**
   *
   * @param {Vector4} borderRadiuses
   * @param {Array.<string>} sideProperties
   */
  constructor(borderRadiuses, sideProperties) {
    this._borderRadiuses = borderRadiuses;
    this._sideProperties = sideProperties;
    this._complementaryMediation = null;
    this._value = 0;
  }
  /**
   * The sum of the border radius of that side
   * @returns {number}
   */
  get value() {
    return this._value;
  }
  /**
   * A complementary side mediation ie: For top, complementary is bottom
   * @param {BorderRadiusMediator} brm
   */
  set complementaryMediation(brm) {
    this._complementaryMediation = brm;
  }
  /**
   * Adds all side property to compute the value of that side
   */
  computeValue() {
    let totalRadius = 0;
    for (const radius of this._sideProperties) {
      totalRadius += this._borderRadiuses[radius];
    }
    this._value = totalRadius;
  }
  /**
   *
   * @param {boolean} [mediateOpposite=true]
   */
  mediate(mediateOpposite = true) {
    if (this._value < 1)
      return;
    for (const radius of this._sideProperties) {
      this._borderRadiuses[radius] /= this._value;
    }
    if (mediateOpposite) {
      this._complementaryMediation.mediate(false);
    }
  }
  /**
   *
   */
  dispose() {
    this._complementaryMediation = null;
    this._borderRadiuses = null;
  }
};
var BorderWidth = class extends StyleVector4Property {
  /**
   *
   * @param defaultValue
   */
  constructor(defaultValue) {
    super("borderWidth", defaultValue, false);
    this._valueUV = this._value.clone();
    this.output = this._outputValue;
    this._units = WORLD_UNITS;
  }
  /**
   *
   * @param {string} units
   */
  set units(units) {
    this._units = validateUnits(units);
    this._needsUpdate = true;
  }
  /**
   *
   * @returns {string}
   */
  get units() {
    return this._units;
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @override
   */
  computeOutputValue(element) {
    this._vector4ValueSetter(this._value, this._input);
    this._needsProcess = true;
    element._bounds._needsUpdate = true;
    element._layouter._needsUpdate = true;
  }
  _outputValue(out) {
    out[this._id] = this._valueUV;
  }
  /**
   *
   * @override
   */
  process(element) {
    this._needsRender = true;
    element._borderRadius._needsRender = true;
  }
  /**
   * @override
   */
  render(element) {
    this._valueUV.copy(this._value);
    const offsetWidth = element._bounds._offsetWidth;
    const offsetHeight = element._bounds._offsetHeight;
    if (this._units === PERCENT) {
      console.log("Percent");
      console.log(this._valueUV);
    }
    if (this._units === WORLD_UNITS) {
      if (offsetWidth !== 0) {
        this._valueUV.w /= offsetWidth;
        this._valueUV.y /= offsetWidth;
      }
      if (offsetHeight !== 0) {
        this._valueUV.x /= offsetHeight;
        this._valueUV.z /= offsetHeight;
      }
    } else if (this._units === UV) {
      if (offsetWidth !== 0) {
        const sX = offsetWidth > offsetHeight ? offsetHeight / offsetWidth : 1;
        this._valueUV.y *= sX;
        this._valueUV.w *= sX;
      }
      if (offsetHeight !== 0) {
        const sY = offsetWidth < offsetHeight ? offsetWidth / offsetHeight : 1;
        this._valueUV.x *= sY;
        this._valueUV.z *= sY;
      }
    }
  }
};
var VisibleProperty = class extends BaseProperty {
  /**
   *
   * @param {string} propertyId
   * @param {any} [value=null]
   */
  constructor(propertyId, value = true) {
    super("visible", value, true);
    this._needsUpdate = false;
  }
  /* eslint-disable no-unused-vars */
  update(element, out) {
    element.visible = this._value;
    if (element._parent._value) {
      element._parent._value._children._needsUpdate = true;
    }
  }
  set value(value) {
    if (!this.isValid(value))
      return;
    if (this._value !== value) {
      this._value = value;
      this._needsUpdate = true;
    }
  }
  /**
   *
   * @return {boolean}
   */
  get value() {
    return this._value;
  }
};
var BackgroundColorProperty = class extends StyleColorProperty {
  constructor(defaultValue) {
    super("backgroundColor", defaultValue, false);
    this._input = "transparent";
    this._allowsInherit = false;
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @param {MeshUIBaseElement} element
   */
  computeOutputValue(element) {
    element._backgroundMesh.visible = !(this._input === "none" || this._input === "transparent");
    if (this._input === "inherit") {
      this._value.set(this.getInheritedInput(element));
    } else if (!(this._input === "transparent" || this._input === "none")) {
      this._value.set(this._input);
    }
  }
};
var EmptyProperty = class extends BaseProperty {
  /**
   *
   * @param {string} propertyId
   */
  constructor(propertyId = "untitled") {
    super(propertyId, void 0, false);
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @param element
   * @param {Object.<string,any>} out
   */
  update(element, out) {
  }
  /* eslint-disable no-unused-vars */
  /**
   * Output this property in a dictionnary
   * @param {Object.<string,any>} out
   */
  output(out) {
  }
};
var InlineJustificator = class extends BaseProperty {
  constructor() {
    super("inlineJustificator", null, false);
    this._value = null;
  }
  /* eslint-disable no-unused-vars */
  update(element, out) {
  }
  /**
   *
   * @override
   */
  process(element) {
    const INNER_HEIGHT = element._bounds._innerHeight;
    const lines = element._layouter._value;
    const textHeight = Math.abs(lines.height);
    let justificationOffset = (() => {
      switch (element._alignItems._value) {
        case "inherit":
        case "start":
          return INNER_HEIGHT / 2;
        case "end":
          return textHeight - INNER_HEIGHT / 2;
        case "stretch":
        case "center":
          return textHeight / 2;
      }
    })();
    const padding = element._padding._value;
    const border = element._borderWidth._value;
    justificationOffset += (-padding.x + padding.z) / 2 + (-border.x + border.z) / 2;
    lines.forEach((line) => {
      line.y += justificationOffset;
      line.forEach((inline) => {
        inline.offsetY += justificationOffset;
      });
    });
  }
};
var AlignItemsProperty_AVAILABLE_VALUES = ["start", "center", "end", "stretch"];
var AlignItemsProperty_isValid = function(value) {
  if (AlignItemsProperty_AVAILABLE_VALUES.indexOf(value) === -1) {
    console.warn(`(.style) alignItems value '${value}' is not valid. Aborted`);
    return false;
  }
  return true;
};
var AlignItemsProperty = class extends SubStyleProperty {
  constructor() {
    super("alignItems", "inherit", true);
    this.isValidValue = AlignItemsProperty_isValid;
  }
};
var TextAlignProperty = class extends SubStyleProperty {
  constructor() {
    super("textAlign", "inherit", true);
    this.isValidValue = TextAlignProperty_isValid;
  }
};
var TextAlignProperty_AVAILABLE_VALUES = ["left", "right", "center", "justify", "justify-left", "justify-right", "justify-center"];
var TextAlignProperty_isValid = function(value) {
  if (TextAlignProperty_AVAILABLE_VALUES.indexOf(value) === -1) {
    console.warn(`(.style) textAlign value '${value}' is not valid. Aborted`);
    return false;
  }
  return true;
};
var FlexDirectionProperty = class extends SubStyleProperty {
  constructor() {
    super("flexDirection", "inherit", true);
    this.isValid = FlexDirectionProperty_isValid;
  }
};
var FlexDirectionProperty_AVAILABLE_VALUES = ["row", "row-reverse", "column", "column-reverse"];
function FlexDirectionProperty_isValid(value) {
  if (FlexDirectionProperty_AVAILABLE_VALUES.indexOf(value) === -1) {
    console.warn(`(.style) flexDirection value '${value}' is not valid. Aborted`);
    return false;
  }
  return true;
}
var JustifyContentProperty = class extends SubStyleProperty {
  constructor() {
    super("justifyContent", "inherit", true);
    this.isValidValue = JustifyContentProperty_isValid;
  }
};
var JustifyContentProperty_AVAILABLE_VALUES = ["start", "center", "end", "space-between", "space-around", "space-evenly"];
function JustifyContentProperty_isValid(value) {
  if (JustifyContentProperty_AVAILABLE_VALUES.indexOf(value) === -1) {
    console.warn(`(.style) justifyContent value '${value}' is not valid. Aborted`);
    return false;
  }
  return true;
}
var OrderProperty = class extends SubStyleProperty {
  constructor() {
    super("order", 0, true);
    this._value = 0;
    this._input = 0;
    this._allowsInherit = false;
  }
  /* eslint-disable no-unused-vars */
  computeOutputValue(element) {
    this._value = this._inheritedInput;
    if (element._parent._value) {
      element._parent._value._children._needsProcess = true;
    }
  }
};
var PositionProperty = class extends SubStyleProperty {
  constructor() {
    super("position", "static", true);
    this._allowsInherit = false;
    this._value = "static";
    this._needsUpdate = false;
    this.computeOutputValue = this._computeFromInherited;
    this.isValidValue = PositionProperty_isValid;
  }
  _computeFromInherited(element) {
    super._computeFromInherited(element);
    if (element._parent._value)
      element._parent._value._children._needsProcess = true;
  }
};
var PositionProperty_AVAILABLE_VALUES = ["static", "absolute"];
function PositionProperty_isValid(value) {
  if (PositionProperty_AVAILABLE_VALUES.indexOf(value) === -1) {
    console.warn(`(.style) position value '${value}' is not valid. Aborted`);
    return false;
  }
  return true;
}
var StyleSideProperty = class extends SubStyleProperty {
  /**
   *
   * @param {string} propertyId
   * @param {number} defaultValue
   */
  constructor(propertyId, defaultValue = null) {
    super(propertyId, defaultValue, true);
    this._input = "auto";
    this._auto = true;
    this._relative = false;
    this._updateRequired = true;
  }
  /**
   *
   * @param {any} value
   */
  set inline(value) {
    if (!this.isValidValue(value))
      return;
    if (value === this._inline) {
      return;
    }
    this._inline = value;
    if (this._input === this._inline)
      return;
    this._parseInput();
  }
  get inline() {
    return this._inline;
  }
  _parseInput() {
    let updateRequired = true;
    if (this._inline !== void 0 && this._inline !== "unset") {
      this._input = this._inline;
    } else if (this._computed !== void 0) {
      if (this._computed === this._input)
        updateRequired = false;
      this._input = this._computed;
    } else {
      updateRequired = this._input === "inherit";
    }
    if (updateRequired) {
      this._auto = !this._input || this._input === "auto";
      if (!this._auto) {
        if ((typeof this._input === "string" || this._input instanceof String) && this._input.endsWith("%")) {
          this._relative = true;
          this._value = 0;
          const floatValue = parseFloat(this._input.replace("%", "").trim());
          if (!isNaN(floatValue)) {
            this._value = floatValue / 100;
          }
        } else {
          this._relative = false;
          this._value = this._input;
        }
      } else {
        this._relative = false;
      }
      this._needsUpdate = this._updateRequired = updateRequired;
    }
  }
  update(element, out) {
    if (this._updateRequired) {
      this._updateRequired = false;
      if (!this._allowsInherit) {
        this._inheritedInput = this.getInheritedInput(element);
      }
      this.computeOutputValue(element);
      for (const childUIElement of element._children._uis) {
        childUIElement[`_${this._id}`]._needsUpdate = true;
      }
      this.output(out);
      if (element._parent._value)
        element._parent._value._layouter._needsProcess = true;
    }
  }
  /* eslint-disable no-unused-vars */
  computeOutputValue(element) {
    element._bounds._needsUpdate = true;
    element._renderer._needsRender = true;
  }
  getInheritedInput(element) {
    if (this._input !== "inherit" && !this._auto)
      return this._input;
    const parent = element._parent._value;
    if (parent) {
      return parent[`_${this._id}`].getInheritedInput(parent);
    }
    return this.getDefaultValue();
  }
  getDefaultValue() {
    return 0;
  }
  /**
   *
   * @return {number}
   */
  get value() {
    return this._value;
  }
};
var WidthProperty = class extends StyleSideProperty {
  constructor() {
    super("width");
  }
};
var HeightProperty = class extends StyleSideProperty {
  constructor() {
    super("height");
  }
  computeOutputValue(element) {
    super.computeOutputValue(element);
  }
};
var TextContentEmpty = class extends EmptyProperty {
  constructor() {
    super("textContent");
    this._needsUpdate = false;
  }
  /* eslint-disable no-unused-vars */
  set value(v4) {
  }
  /* eslint-disable no-unused-vars */
  process(element) {
    let content = "";
    for (let i = 0; i < element.children.length; i++) {
      const child = element.children[i];
      if (child.isUI) {
        content += child.textContent;
      }
    }
    this._value = content;
  }
};
var FontStyleProperty = class extends SubStyleProperty {
  constructor(defaultValue) {
    super("fontStyle", defaultValue, true);
    this.isValidValue = FontStyleProperty_isValid;
  }
};
var FontStyleProperty_AVAILABLE_VALUES = ["normal", "italic"];
function FontStyleProperty_isValid(value) {
  if (FontStyleProperty_AVAILABLE_VALUES.indexOf(value) === -1) {
    console.warn(`(.style) fontStyle value '${value}' is not valid. Aborted`);
    return false;
  }
  return true;
}
var FontWeightProperty = class extends SubStyleProperty {
  constructor() {
    super("fontWeight", "inherit", true);
    this.isValid = FontWeightProperty_isValid;
  }
};
var FontWeightProperty_AVAILABLE_VALUES = ["100", "200", "300", "400", "500", "600", "700", "800", "900", "light", "normal", "bold", "bolder"];
function FontWeightProperty_isValid(value) {
  if (FontWeightProperty_AVAILABLE_VALUES.indexOf(value.toString()) === -1) {
    console.warn(`(.style) fontWeight value '${value}' is not valid. Aborted`);
    return false;
  }
  return true;
}
var TypographicFont = class {
  constructor() {
    this._size = 42;
    this._lineHeight = 42;
    this._lineBase = 38;
    this._name = "-";
    this._charset = "";
  }
  /**
   *
   * @returns {number}
   */
  get size() {
    return this._size;
  }
  /**
   *
   * @returns {number}
   */
  get lineHeight() {
    return this._lineHeight;
  }
  /**
   *
   * @returns {number}
   */
  get lineBase() {
    return this._lineBase;
  }
  /**
   *
   * @returns {string}
   */
  get name() {
    return this._name;
  }
  /**
   *
   * @returns {string}
   */
  get charset() {
    return this._charset;
  }
};
var MSDFTypographicFont = class extends TypographicFont {
  /**
   *
   * @param {import('./MSDFFontVariant').MSDFJson} json
   */
  constructor(json) {
    super();
    this._size = json.info.size;
    this._lineHeight = json.common.lineHeight;
    this._lineBase = json.common.base;
    this._name = json.info.face;
    this._textureWidth = json.common.scaleW;
    this._textureHeight = json.common.scaleH;
    this._charset = json.chars.map((char) => char.char).join("");
  }
  /**
   *
   * @returns {number}
   */
  get textureWidth() {
    return this._textureWidth;
  }
  /**
   *
   * @returns {number}
   */
  get textureHeight() {
    return this._textureHeight;
  }
};
var MSDFInlineGlyph = class extends InlineGlyph {
  /**
   *
   * @param {MSDFTypographicGlyph} characterDesc
   */
  constructor(characterDesc) {
    super(characterDesc);
  }
  /**
   *
   * @returns {{left:number, right:number, top:number, bottom:number}|null}
   */
  get uv() {
    return this.typographic.uv;
  }
};
var MSDFTypographicGlyph = class extends TypographicGlyph {
  /**
   * @param {MSDFTypographicFont} fontDescription
   * @param {import('./MSDFFontVariant').MSDFJsonChar} characterData
   */
  constructor(fontDescription, characterData) {
    super(fontDescription);
    this._char = characterData.char;
    this._width = characterData.width;
    this._heigth = characterData.height;
    this._xadvance = characterData.xadvance ? characterData.xadvance : this._width;
    this._xoffset = characterData.xoffset ? characterData.xoffset : 0;
    this._yoffset = characterData.yoffset ? characterData.yoffset : 0;
    this._uv = characterData.uv ? characterData.uv : null;
    if (!isNaN(characterData.x)) {
      this._uv = {
        left: characterData.x / fontDescription.textureWidth,
        right: (characterData.x + characterData.width) / fontDescription.textureWidth,
        top: 1 - (characterData.y + characterData.height) / fontDescription.textureHeight,
        bottom: 1 - characterData.y / fontDescription.textureHeight
      };
    }
  }
  /**
   *
   * @returns {{left: number, right: number, top: number, bottom: number}|null}
   */
  get uv() {
    return this._uv;
  }
  /**
   * @override
   * @param {string} otherChar
   * @returns {MSDFTypographicGlyph}
   */
  clone(otherChar) {
    return new MSDFTypographicGlyph(this._font, {
      char: otherChar,
      width: this._width,
      height: this._heigth,
      xadvance: this._xadvance,
      xoffset: this._xoffset,
      yoffset: this._yoffset,
      // Msdf requires uvs
      uv: null
    });
  }
  /**
   * @override
   * @returns {MSDFInlineGlyph}
   */
  asInlineGlyph() {
    return new MSDFInlineGlyph(this);
  }
};
var MSDFGeometricGlyph = class extends external_three_namespaceObject.PlaneGeometry {
  /**
   *
   * @param {MSDFInlineGlyph} inline
   * @param {MeshUIBaseElement} element
   */
  constructor(inline, element) {
    let wS = 1, hS = 1;
    const typographicFontSize = inline.typographic.font.size;
    const segments = element._segments.value;
    wS = Math.ceil(inline.typographic.width / typographicFontSize * segments);
    hS = Math.ceil(inline.typographic.height / typographicFontSize * segments);
    super(inline.width, inline.height, wS, hS);
    if (inline.uv) {
      this._mapUVs(inline);
      this._transformGeometry(inline);
    } else {
      this._nullifyUVs();
      this.scale(0, 0, 1);
      this.translate(0, inline.fontSize / 2, 0);
    }
    this.name = "GlyphGeometry";
  }
  /**
   * Compute the right UVs that will map the MSDF texture so that the passed character
   * will appear centered in full size
   * @param {MSDFInlineGlyph} inline
   * @private
   */
  _mapUVs(inline) {
    const width = inline.uv.right - inline.uv.left;
    const height = inline.uv.bottom - inline.uv.top;
    const originalUvArray = this.getAttribute("uv").array.slice();
    const uvGlyph = [];
    for (let i = 0; i < originalUvArray.length; i += 2) {
      const u2 = originalUvArray[i];
      const v4 = originalUvArray[i + 1];
      uvGlyph.push(inline.uv.left + width * u2);
      uvGlyph.push(inline.uv.top + height * v4);
    }
    this.setAttribute("uvG", new external_three_namespaceObject.BufferAttribute(new Float32Array(uvGlyph), 2));
  }
  /**
   * Set all UVs to 0, so that none of the glyphs on the texture will appear
   * @private
   * */
  _nullifyUVs() {
    const uvGlyph = [];
    const length = this.getAttribute("uv").array.length;
    for (let i = 0; i < length; i++) {
      uvGlyph.push(0);
    }
    this.setAttribute("uvG", new external_three_namespaceObject.BufferAttribute(new Float32Array(uvGlyph), 2));
  }
  /**
   *
   * @TODO: Apply pivot properties when splitText isset
   * Gives the previously computed scale and offset to the geometry
   * @param {MSDFInlineGlyph} inline
   * @private
   */
  _transformGeometry(inline) {
    this.translate(
      inline.width / 2,
      -inline.height / 2,
      0
    );
  }
};
var program = (
  /* glsl */
  `
attribute vec2 uvG;
varying vec2 vUvG;
`
);
var msdf_alphaglyph_pars_vertex_glsl = program;
var msdf_alphaglyph_vertex_glsl_program = (
  /* glsl */
  `
vUvG = uvG;
`
);
var msdf_alphaglyph_vertex_glsl = msdf_alphaglyph_vertex_glsl_program;
var msdf_offsetglyph_vertex_glsl_program = (
  /* glsl */
  `
gl_Position.z -= 0.00001;
`
);
var msdf_offsetglyph_vertex_glsl = msdf_offsetglyph_vertex_glsl_program;
var msdf_alphaglyph_pars_fragment_glsl_program = (
  /* glsl */
  `
varying vec2 vUvG;
uniform sampler2D glyphMap;
uniform vec2 unitRange;
// functions from the original msdf repo:
// https://github.com/Chlumsky/msdfgen#using-a-multi-channel-distance-field
float median(float r, float g, float b) {
	return max(min(r, g), min(max(r, g), b));
}
float screenPxRange() {

	// precomputed unitRange as recommended by Chlumsky
	// vec2 unitRange = vec2(pxRange)/vec2(textureSize(glyphMap, 0));
	vec2 screenTexSize = vec2(1.0)/fwidth(vUvG);
	return max(0.5*dot(unitRange, screenTexSize), 1.0);
}
float tap(vec2 offsetUV) {
	vec3 msd = texture( glyphMap, offsetUV ).rgb;
	float sd = median(msd.r, msd.g, msd.b);
	float screenPxDistance = screenPxRange() * (sd - 0.5);
	float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
	return alpha;
}
`
);
var msdf_alphaglyph_pars_fragment_glsl = msdf_alphaglyph_pars_fragment_glsl_program;
var msdf_alphaglyph_fragment_glsl_program = (
  /* glsl */
  `
	float alpha;
#ifdef NO_RGSS

	alpha = tap( vUvG );

#else

	// shader-based supersampling based on https://bgolus.medium.com/sharper-mipmapping-using-shader-based-supersampling-ed7aadb47bec
	// per pixel partial derivatives
	vec2 dx = dFdx(vUvG);
	vec2 dy = dFdy(vUvG);
	// rotated grid uv offsets
	vec2 uvOffsets = vec2(0.125, 0.375);
	vec2 offsetUV = vec2(0.0, 0.0);
	// supersampled using 2x2 rotated grid
	alpha = 0.0;
	offsetUV.xy = vUvG + uvOffsets.x * dx + uvOffsets.y * dy;
	alpha += tap(offsetUV);
	offsetUV.xy = vUvG - uvOffsets.x * dx - uvOffsets.y * dy;
	alpha += tap(offsetUV);
	offsetUV.xy = vUvG + uvOffsets.y * dx - uvOffsets.x * dy;
	alpha += tap(offsetUV);
	offsetUV.xy = vUvG - uvOffsets.y * dx + uvOffsets.x * dy;
	alpha += tap(offsetUV);
	alpha *= 0.25;

#endif

	alpha = clamp( alpha, 0.0, 1.0 );

#ifdef INVERT_ALPHA

	alpha = 1.0 - alpha;

#endif

	diffuseColor.a *= alpha;
`
);
var msdf_alphaglyph_fragment_glsl = msdf_alphaglyph_fragment_glsl_program;
var alphaTestTransformer = function(target, targetProperty, value) {
  target.alphaTest = value;
  toPreprocessorTriggerTransformer(target, "USE_ALPHATEST", value > 0);
};
var toPreprocessorTriggerTransformer = function(target, targetProperty, value) {
  if (!target.defines)
    return;
  if (value) {
    if (target.defines[targetProperty] === void 0) {
      target.defines[targetProperty] = "";
      target.needsUpdate = true;
    }
  } else if (target.defines[targetProperty] !== void 0) {
    delete target.defines[targetProperty];
    target.needsUpdate = true;
  }
};
var asPreprocessorValueTransformer = function(target, targetProperty, value) {
  if (target.defines[targetProperty] && target.defines[targetProperty] === value)
    return;
  target.defines[targetProperty] = value;
  target.needsUpdate = true;
};
var uniformOrUserDataTransformer = function(material, property, value) {
  if (material.userData[property]) {
    material.userData[property].value = value;
  } else {
    material.uniforms[property].value = value;
  }
};
var toUserDataTransformer = function(material, property, value) {
  material.userData[property].value = value;
};
var MSDFFontMaterialUtils = class {
  /**
   * Alter a material options with required fontMaterial options and or default values
   * @param {Object.<string,any>} materialOptions
   */
  static ensureMaterialOptions(materialOptions) {
    materialOptions.transparent = true;
    materialOptions.alphaTest = materialOptions.alphaTest || 0.02;
  }
  /**
   * As three-mesh-ui FontMaterial relies on webgl preprocessors,
   * lets force the material to have a proper defines object
   * @param {Material|ShaderMaterial} threeMaterial
   */
  static ensureDefines(threeMaterial) {
    if (!threeMaterial.defines) {
      threeMaterial.defines = {};
    }
  }
  /**
   *
   * @param {Material|ShaderMaterial} threeMaterial
   * @param {Object.<string,any>} materialOptions
   */
  static ensureUserData(threeMaterial, materialOptions) {
    threeMaterial.userData.glyphMap = { value: materialOptions.glyphMap };
    threeMaterial.userData.unitRange = { value: new external_three_namespaceObject.Vector2() };
  }
  /**
   *
   * @param {any} shader
   * @param {Material|ShaderMaterial} threeMaterial
   */
  static bindUniformsWithUserData(shader, threeMaterial) {
    shader.uniforms.glyphMap = threeMaterial.userData.glyphMap;
    shader.uniforms.unitRange = threeMaterial.userData.unitRange;
  }
  /**
   *
   * @param shader
   */
  static injectShaderChunks(shader) {
    MSDFFontMaterialUtils.injectVertexShaderChunks(shader);
    MSDFFontMaterialUtils.injectFragmentShaderChunks(shader);
  }
  /**
   *
   * @param shader
   */
  static injectVertexShaderChunks(shader) {
    shader.vertexShader = shader.vertexShader.replace(
      "#include <uv_pars_vertex>",
      "#include <uv_pars_vertex>\n" + msdf_alphaglyph_pars_vertex_glsl
    );
    shader.vertexShader = shader.vertexShader.replace(
      "#include <uv_vertex>",
      "#include <uv_vertex>\n" + msdf_alphaglyph_vertex_glsl
    );
    shader.vertexShader = shader.vertexShader.replace(
      "#include <project_vertex>",
      "#include <project_vertex>\n" + msdf_offsetglyph_vertex_glsl
    );
  }
  /**
   *
   * @param shader
   */
  static injectFragmentShaderChunks(shader) {
    shader.fragmentShader = shader.fragmentShader.replace(
      "#include <uv_pars_fragment>",
      "#include <uv_pars_fragment>\n" + msdf_alphaglyph_pars_fragment_glsl
    );
    shader.fragmentShader = shader.fragmentShader.replace(
      "#include <alphamap_fragment>",
      "#include <alphamap_fragment>\n" + msdf_alphaglyph_fragment_glsl
    );
  }
  /**
   * Mix a threejs Material into a three-mesh-ui FontMaterial
   * @param {typeof Material|ShaderMaterial} materialClass
   * @returns {typeof Material|ShaderMaterial}
   */
  static from(materialClass) {
    return class extends materialClass {
      constructor(options = {}) {
        MSDFFontMaterialUtils.ensureMaterialOptions(options);
        super(options);
        /**
         *
         * On before compile that first run three-mesh-ui fontMaterial
         * then user defined onBeforeCompile
         * @param shader
         * @private
         */
        __publicField(this, "_cumulativeOnBeforeCompile", (shader) => {
          MSDFFontMaterialUtils.bindUniformsWithUserData(shader, this);
          MSDFFontMaterialUtils.injectShaderChunks(shader);
          this._userDefinedOnBeforeCompile(shader);
        });
        MSDFFontMaterialUtils.ensureDefines(this);
        MSDFFontMaterialUtils.ensureUserData(this, options);
        this._userDefinedOnBeforeCompile = (shader) => {
        };
        this._onBeforeCompile = this._cumulativeOnBeforeCompile;
      }
      /**
       *
       * @abstract
       * @returns {Object.<{m:string, t?:(fontMaterial:Material|ShaderMaterial, materialProperty:string, value:any) => void}>}
       */
      static get fontMaterialProperties() {
        return MSDFFontMaterialUtils.mediation;
      }
      ////////////////////////////
      // OnBeforeCompile Override
      ///////////////////////////
      /**
       * Override the setter of onBeforeCompile in order to never overwrite
       * the three-mesh-ui fontMaterial onBeforeCompile
       * @param { (shader:any) => void }fct
       */
      set onBeforeCompile(fct) {
        this._userDefinedOnBeforeCompile = fct;
      }
      /**
       * Override the getter of onBeforeCompile in order to
       * always deliver the cumulativeCallbacks to threejs
       * @returns { (shader:any) => void }
       */
      get onBeforeCompile() {
        return this._onBeforeCompile;
      }
    };
  }
  /**
   *
   * @returns {Object<{m: string, t?: (function((Material|ShaderMaterial), string, *): void)}>}
   */
  static get mediation() {
    return mediationDefinitions;
  }
};
var _fontToGlyphMapTransformer = function(fontMaterial, materialProperty, value) {
  const texture = value ? value.texture : null;
  const unitRange = value ? value.unitRange : new external_three_namespaceObject.Vector2();
  if (fontMaterial[materialProperty] !== void 0) {
    fontMaterial.glyphMap = texture;
    fontMaterial.unitRange = unitRange;
    return;
  }
  if (fontMaterial.userData && fontMaterial.userData.glyphMap) {
    fontMaterial.userData.glyphMap.value = texture;
    fontMaterial.userData.unitRange.value = unitRange;
  }
};
var _RGSSTransformer = function(fontMaterial, materialProperty, value) {
  if (value && value !== "antialiased") {
    fontMaterial.defines["NO_RGSS"] = "";
  } else {
    delete fontMaterial.defines["NO_RGSS"];
  }
  fontMaterial.needsUpdate = true;
};
var mediationDefinitions = {
  clippingPlanes: { m: "clippingPlanes" },
  fontAlphaTest: { m: "alphaTest", t: alphaTestTransformer },
  fontSide: { m: "side" },
  font: { m: "glyphMap", t: _fontToGlyphMapTransformer },
  color: { m: "color" },
  fontOpacity: { m: "opacity" },
  fontSmooth: { m: "NO_RGSS", t: _RGSSTransformer },
  invertAlpha: { m: "INVERT_ALPHA", t: toPreprocessorTriggerTransformer }
};
var vertexShader = (
  /* glsl */
  `
${msdf_alphaglyph_pars_vertex_glsl}
#include <clipping_planes_pars_vertex>
void main() {
	${msdf_alphaglyph_vertex_glsl}
	#include <begin_vertex>
	#include <project_vertex>
	${msdf_offsetglyph_vertex_glsl}
	#include <clipping_planes_vertex>
}
`
);
var fragmentShader = (
  /* glsl */
  `
uniform vec3 diffuse;
uniform float opacity;
${msdf_alphaglyph_pars_fragment_glsl}
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	// instead of <color_fragment> : vec4 diffuseColor
	vec4 diffuseColor = vec4( diffuse, opacity );
	${msdf_alphaglyph_fragment_glsl}
	#include <alphatest_fragment>
	// instead of <output_fragment>
	gl_FragColor = diffuseColor;
	#include <clipping_planes_fragment>
}
`
);
var ALPHA_TEST = 0.02;
var MSDFFontMaterial = class extends external_three_namespaceObject.ShaderMaterial {
  /**
   * This static method is mandatory for extending ThreeMeshUI.MSDFFontMaterial
   * It will provide a transfer description for properties from ThreeMeshUI.Text to THREE.Material
   * @see {MSDFFontMaterialUtils.mediation}
   * @returns {Object.<{m:string, t?:(fontMaterial:Material|ShaderMaterial, materialProperty:string, value:any) => void}>}
   */
  static get mediation() {
    return MSDFFontMaterialUtils.mediation;
  }
  constructor(materialOptions = {}) {
    super({
      uniforms: {
        "glyphMap": { value: null },
        // texture
        "diffuse": { value: null },
        // vec3
        "opacity": { value: 1 },
        "unitRange": { value: new external_three_namespaceObject.Vector2(0, 0) },
        // vec2
        "alphaTest": { value: ALPHA_TEST }
      },
      transparent: true,
      clipping: true,
      vertexShader,
      fragmentShader,
      extensions: {
        derivatives: true
      }
    });
    this.defines["USE_ALPHATEST"] = "";
    this.needsUpdate = true;
    this.noRGSS = materialOptions.noRGSS || false;
  }
  /**
   * The color will be the diffuse uniform
   * @returns {Color}
   */
  get color() {
    return this.uniforms.diffuse.value;
  }
  /**
   *
   * @param {Color} v
   */
  set color(v4) {
    this.uniforms.diffuse.value = v4;
  }
  /**
   *
   * @param {number} v
   */
  set opacity(v4) {
    if (this.uniforms)
      this.uniforms.opacity.value = v4;
  }
  /**
   * The color will be the diffuse uniform
   * @returns {number}
   */
  get opacity() {
    return this.uniforms.opacity.value;
  }
  /**
   * The color will be the diffuse uniform
   * @returns {Vector2}
   */
  get unitRange() {
    return this.uniforms.unitRange.value;
  }
  /**
   *
   * @param {Vector2} v
   */
  set unitRange(v4) {
    this.uniforms.unitRange.value.copy(v4);
  }
  /**
   *
   * @returns {Texture}
   */
  get glyphMap() {
    return this.uniforms.glyphMap.value;
  }
  /**
   *
   * @param {Texture} v
   */
  set glyphMap(v4) {
    this.uniforms.glyphMap.value = v4;
  }
  /**
   * Is this a default fontMaterial instance
   * @returns {boolean}
   */
  get isDefault() {
    return this.constructor === MSDFFontMaterial;
  }
  /**
   *
   * @returns {number}
   */
  get alphaTest() {
    return this.uniforms.alphaTest.value;
  }
  /**
   *
   * @param {number} v
   */
  set alphaTest(v4) {
    this.uniforms.alphaTest.value = v4;
  }
};
var MSDFFontVariant = class extends font_FontVariant {
  constructor(weight, style, json, texture) {
    super(weight, style);
    this._unitRange = new external_three_namespaceObject.Vector2(1, 1);
    if (json.pages) {
      this._buildData(json);
    } else {
      _loadJson(this, json);
    }
    if (texture instanceof external_three_namespaceObject.Texture) {
      this._texture = texture;
      this._buildTexture(texture);
    } else if (typeof texture === "string" || texture instanceof String) {
      _loadTexture(this, texture);
    } else {
      throw new Error(`ThreeMeshUI::MSDFVariant provided 'texture' parameter is '${typeof texture}'. Only Texture and String allowed.`);
    }
    this._defaultMaterialClass = MSDFFontMaterial;
    this._checkReadiness();
  }
  get texture() {
    return this._texture;
  }
  get unitRange() {
    return this._unitRange;
  }
  /**
   * @param {Function.<Material|ShaderMaterial>} v
   * @override
   */
  set fontMaterial(v4) {
    this._defaultMaterialClass = v4;
  }
  /**
   *
   * @override
   * @returns {Function.<Material|ShaderMaterial>}
   */
  get fontMaterial() {
    return this._defaultMaterialClass;
  }
  /**
   *
   * @param {MSDFJson} json
   * @private
   */
  _buildData(json) {
    this._font = new MSDFTypographicFont(json);
    this._kernings = this._buildKerningPairs(json);
    this._chars = this._buildCharacters(json);
    this._chars[" "] = this._buildCharacterWhite(json);
    this._chars["\n"] = this._buildCharacterWhite(json, "\n", 1e-3, 1);
    this._chars["	"] = this._buildCharacterWhite(json, "	", 4, 1);
    this._size = json.info.size;
    this._lineHeight = json.common.lineHeight;
    this._lineBase = json.common.base;
    this._distanceRange = json.distanceField.distanceRange;
    this._unitRange = new external_three_namespaceObject.Vector2(this._distanceRange, this._distanceRange).divide(new external_three_namespaceObject.Vector2(json.common.scaleW, json.common.scaleH));
  }
  /**
   *
   * @param texture
   * @private
   */
  _buildTexture(texture) {
    texture.generateMipmaps = false;
    texture.minFilter = external_three_namespaceObject.LinearFilter;
    texture.magFilter = external_three_namespaceObject.LinearFilter;
    texture.needsUpdate = true;
  }
  /**
   * @abstract
   * @protected
   * @param {string} missingChar
   * @returns {string|null}
   */
  _getFallbackCharacter(missingChar) {
    return font_FontLibrary.missingCharacter(this, missingChar);
  }
  /**
   *
   * @override
   * @param {import('./../InlineGlyph').default|import('./MSDFInlineGlyph').default} inline
   * @param {import('./../../core/elements/MeshUIBaseElement').default} element
   * @returns {MSDFGeometricGlyph}
   */
  getGeometricGlyph(inline, element) {
    return new MSDFGeometricGlyph(inline, element);
  }
  /**
   * Abstraction implementation
   *
   * @returns {boolean}
   * @private
   */
  _readyCondition() {
    return this._chars && this._texture && this._texture.image;
  }
  /**
   * Ensure that each font variant has its kerning dictionary
   * @see src/font/msdf/FontVariantMSDF.js for an implementation
   *
   * @param {MSDFJson} json
   * @returns {import('../FontVariant').KerningPairs}
   * @private
   */
  _buildKerningPairs(json) {
    const friendlyKernings = {};
    for (let i = 0; i < json.kernings.length; i++) {
      const kerning = json.kernings[i];
      if (kerning.amount === 0)
        continue;
      const glyphPair = String.fromCharCode(kerning.first, kerning.second);
      friendlyKernings[glyphPair] = kerning.amount;
    }
    return friendlyKernings;
  }
  /**
   *
   * @param {MSDFJson} json
   * @private
   */
  _buildCharacters(json) {
    const friendlyChars = {};
    for (let i = 0; i < json.chars.length; i++) {
      const charOBJ = json.chars[i];
      friendlyChars[charOBJ.char] = new MSDFTypographicGlyph(this._font, charOBJ);
    }
    return friendlyChars;
  }
  /**
   *
   * @param {MSDFJson} json
   * @param char
   * @param scaleX
   * @param scaleY
   * @private
   */
  _buildCharacterWhite(json, char = " ", scaleX = 1, scaleY = 1) {
    return new MSDFTypographicGlyph(
      this._font,
      {
        char,
        width: json.info.size / 3 * scaleX,
        height: json.info.size * 0.7 * scaleY
      }
    );
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @param element
   * @private
   */
  _alterElementProperties(element) {
  }
};
function _loadJson(fontVariant, jsonUrl) {
  new external_three_namespaceObject.FileLoader().setResponseType("json").load(jsonUrl, (response) => {
    fontVariant._buildData(response);
    fontVariant._checkReadiness();
  });
}
function _loadTexture(fontVariant, textureUrl) {
  fontVariant._texture = new external_three_namespaceObject.TextureLoader().load(textureUrl, (texture) => {
    fontVariant._buildTexture(texture);
    fontVariant._checkReadiness();
  });
}
var FontFamily = class extends external_three_namespaceObject.EventDispatcher {
  /**
   *
   * @param {string} name
   */
  constructor(name) {
    super();
    __publicField(this, "_checkReadiness", () => {
      if (this._variants.every((v4) => v4.isReady)) {
        FontFamily_setReady(this);
      }
    });
    this._name = name;
    this._variants = [];
    this._isReady = false;
  }
  get isReady() {
    return this._isReady;
  }
  /**
   *
   * @param {string|number} weight
   * @param {string} style
   * @param {string|Object} json
   * @param {string|Texture} texture
   * @param {boolean} [override=false]
   */
  addVariant(weight, style, json, texture, override = false) {
    if (override || !this.getVariant(weight, style)) {
      this._isReady = false;
      const newVariant = new MSDFFontVariant(weight, style, json, texture);
      this._variants.push(newVariant);
      if (!newVariant.isReady) {
        newVariant.addEventListener("ready", this._checkReadiness);
      } else {
        this._checkReadiness();
      }
    } else {
      console.warn(`FontFamily('${this._name}')::addVariant() - Variant(${weight}, ${style}) already exists.`);
    }
    return this;
  }
  /**
   *
   * @param {FontVariant} variantImplementation
   * @param {boolean} [override=false]
   */
  addCustomImplementationVariant(variantImplementation, override = false) {
    if (override || !this.getVariant(variantImplementation.weight, variantImplementation.style)) {
      this._isReady = false;
      this._variants.push(variantImplementation);
      if (!variantImplementation.isReady) {
        variantImplementation.addEventListener("ready", this._checkReadiness);
      } else {
        this._checkReadiness();
      }
    } else {
      console.warn(`FontFamily('${this._name}')::addCustomImplementationVariant() - Variant(${variantImplementation.weight}, ${variantImplementation.style}) already exists.`);
    }
    return this;
  }
  /**
   *
   * @param {string|number} weight
   * @param {string} style
   * @returns {FontVariant|null}
   */
  getVariant(weight, style) {
    weight = uniformizeFontWeight(weight);
    return this._variants.find((fontVariant) => fontVariant.weight === weight && fontVariant.style === style);
  }
  /**
   *
   * @return {string}
   */
  get name() {
    return this._name;
  }
};
var FontFamily_readyEvent = { type: "ready" };
function FontFamily_setReady(fontFamily) {
  fontFamily._isReady = true;
  fontFamily.dispatchEvent(FontFamily_readyEvent);
}
var _fontFamilies = {};
var prepare = function(fontFamily) {
  const families = [...arguments];
  families.forEach((f2) => {
    if (!(f2 instanceof FontFamily)) {
      throw new Error(`FontLibrary::prepare() - One of the provided parameter is not a FontFamily. Instead ${typeof f2} given.`);
    }
  });
  const areAllLoaded = function() {
    return families.every((f2) => f2.isReady);
  };
  return new Promise((resolve2, reject) => {
    if (areAllLoaded()) {
      resolve2();
    } else {
      for (let i = 0; i < families.length; i++) {
        const family = families[i];
        if (!family.isReady) {
          family.addEventListener("ready", () => {
            if (areAllLoaded()) {
              resolve2();
            }
          });
        }
      }
    }
  });
};
var addFontFamily = function(name) {
  if (_fontFamilies[name]) {
    console.error(`FontLibrary::addFontFamily - Font('${name}') is already registered`);
  }
  _fontFamilies[name] = new FontFamily(name);
  return _fontFamilies[name];
};
var getFontFamily = function(name) {
  return _fontFamilies[name];
};
var setMissingCharacterHandler = function(handler) {
  _missingCharacterHandler = handler;
};
var _missingCharacterHandler = function(fontVariant, character) {
  console.error(`The character '${character}' is not included in the font characters set.`);
  return " ";
};
function missingCharacter(fontVariant, character) {
  return _missingCharacterHandler(fontVariant, character);
}
var FontLibrary = {
  addFontFamily,
  getFontFamily,
  prepare,
  setMissingCharacterHandler,
  missingCharacter
};
var font_FontLibrary = FontLibrary;
var FontFamilyProperty = class extends SubStyleProperty {
  constructor() {
    super("fontFamily", "inherit", true);
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @param element
   */
  computeOutputValue(element) {
    if (this._input instanceof FontFamily) {
      this._value = this._input;
    } else if (this._input === "inherit") {
    } else if (typeof this._input === "string") {
      const fontFamily = font_FontLibrary.getFontFamily(this._input);
      if (fontFamily) {
        this._value = fontFamily;
      } else {
        console.warn(`(.style) fontFamily, the font '${this._input}' is not registered. Aborted.`);
      }
    } else {
      console.warn(`(.style) fontFamily requires a registered fontFamily instance, or the id of a registered fontFamily.`);
      console.warn(`If you want to set a specific font, please use .font property instead.`);
    }
  }
  /**
   * @override
   * @return {any|FontFamily|null}
   */
  get value() {
    return this._value;
  }
  getInheritedInput(element) {
    if (this._input !== "inherit")
      return this._input;
    const parent = element._parent._value;
    if (parent) {
      return parent[`_${this._id}`].getInheritedInput(parent);
    }
    return this.getDefaultValue();
  }
};
var LineHeightProperty = class extends SubStyleProperty {
  /**
   *
   */
  constructor() {
    super("lineHeight", "inherit", true);
  }
  update(element, out) {
    super.update(element, out);
    element._layouter._needsProcess = true;
  }
};
var WhiteSpaceProperty = class extends SubStyleProperty {
  constructor() {
    super("whiteSpace", "inherit");
    this.isValidValue = WhiteSpaceProperty_isValid;
  }
};
var WhiteSpaceProperty_AVAILABLE_VALUES = ["normal", "nowrap", "pre", "pre-line", "pre-wrap"];
function WhiteSpaceProperty_isValid(value) {
  if (WhiteSpaceProperty_AVAILABLE_VALUES.indexOf(value) === -1) {
    console.warn(`(.style) whiteSpace value '${value}' is not valid. Aborted`);
    return false;
  }
  return true;
}
var LetterSpacingProperty = class extends SubStyleProperty {
  constructor() {
    super("letterSpacing", "inherit", true);
  }
};
var FontSizeProperty = class extends SubStyleProperty {
  constructor() {
    super("fontSize", "inherit", true);
  }
};
var SegmentsProperty = class extends BaseProperty {
  constructor() {
    super("segments", 1, false);
  }
};
var InvertAlphaProperty = class extends InheritableProperty {
  constructor() {
    super("invertAlpha", "inherit");
  }
};
var FontKerningProperty = class extends SubStyleProperty {
  constructor() {
    super("fontKerning", "inherit");
    this.isValidValue = FontKerningProperty_isValid;
  }
};
var FontKerningProperty_AVAILABLE_VALUES = ["normal", "none", "inherit"];
function FontKerningProperty_isValid(value) {
  if (FontKerningProperty_AVAILABLE_VALUES.indexOf(value) === -1) {
    console.warn(`(.style) fontKerning value '${value}' is not valid. Aborted`);
    return false;
  }
  return true;
}
var InheritableBooleanProperty = class extends InheritableProperty {
  /**
   *
   * @param {string} propertyId
   */
  constructor(propertyId) {
    super(propertyId, "inherit", true);
  }
};
var InheritableMaterialProperty = class extends InheritableProperty {
  /**
   *
   * @param {string} propertyId
   */
  constructor(propertyId) {
    super(propertyId, "inherit", false);
    this._mediation = {};
    this._defaultMaterial = null;
  }
  update(element, out) {
    this._notInheritedValue = this._value;
    if (this._notInheritedValue === "inherit") {
      this._notInheritedValue = this.getInheritedInput(element);
    } else {
      this.propagate(element);
    }
    if (!this._notInheritedValue) {
      this._mediation = {};
    } else if (this._notInheritedValue.constructor.mediation) {
      this._mediation = { ...this._notInheritedValue.constructor.mediation };
    } else {
      this._mediation = {
        clippingPlanes: { m: "clippingPlanes" },
        fontAlphaTest: { m: "alphaTest", t: alphaTestTransformer },
        fontSide: { m: "side" },
        color: { m: "color" },
        fontOpacity: { m: "opacity" }
      };
    }
    element._transferToFontMaterial();
    this._outputValue(out);
  }
  /**
   * @override
   */
  getInheritedInput(element) {
    if (this._value !== "inherit")
      return this._value;
    let recursiveParent = element;
    let inheritedValue = null;
    while (recursiveParent._parent._value) {
      recursiveParent = recursiveParent._parent._value;
      if (recursiveParent[`_${this._id}`]._value !== "inherit") {
        inheritedValue = recursiveParent[`_${this._id}`]._value;
        break;
      }
    }
    if (inheritedValue !== null) {
      return inheritedValue;
    }
    return this.getDefaultValue();
  }
  getDefaultValue() {
    return this._defaultMaterial;
  }
};
var renderOrderTransformer = function(target, targetProperty, value) {
  target.traverse((child) => {
    child.renderOrder = value;
  });
};
var MeshUIBaseElement = class extends external_three_namespaceObject.Object3D {
  /**
   *
   * @param {Properties} properties
   * @param {Options} values
   */
  constructor(properties, values) {
    super();
    /**
     * Try to retrieve parentUI after each structural change
     * @protected
     */
    __publicField(this, "_rebuildParentUI", () => {
      this._parent._needsUpdate = true;
      if (this.parent && !this.parent.isUI) {
        UpdateManager.register(this);
        this.activatePseudoState("root");
      } else {
        UpdateManager.remove(this);
        this.deactivatePseudoState("root");
      }
    });
    Object.defineProperties(
      this,
      {
        isUI: {
          configurable: false,
          enumerable: true,
          value: true
        }
      }
    );
    this._backgroundMesh = null;
    this._backgroundMaterial = null;
    this._backgroundCustomDepthMaterial = null;
    this._backgroundMaterialMediation = {};
    this._backgroundMeshMediation = {
      backgroundCastShadow: { m: "castShadow" },
      backgroundReceiveShadow: { m: "receiveShadow" },
      renderOrder: { m: "renderOrder", t: renderOrderTransformer }
    };
    this._fontMesh = null;
    this._fontMaterial = new InheritableMaterialProperty("fontMaterial");
    this._fontCustomDepthMaterial = new InheritableMaterialProperty("fontCustomDepthMaterial");
    this._fontMeshMediation = {
      fontMaterial: { m: "material" },
      fontCustomDepthMaterial: { m: "customDepthMaterial", t: directTransferNotNull },
      fontCastShadow: { m: "castShadow" },
      fontReceiveShadow: { m: "receiveShadow" },
      renderOrder: { m: "renderOrder" }
    };
    this._children = properties.children ? new properties.children() : new EmptyProperty("children");
    this._parent = new ParentProperty();
    this.addEventListener("added", this._rebuildParentUI);
    this.addEventListener("removed", this._rebuildParentUI);
    this._backgroundSide = new SideProperty("backgroundSide");
    this._fontSide = new SideProperty("fontSide");
    this._backgroundAlphaTest = new NumberProperty("backgroundAlphaTest", 0.02);
    this._fontAlphaTest = new NumberProperty("fontAlphaTest", 0.02);
    this._visible = new VisibleProperty("visible", true);
    this._backgroundCastShadow = new InheritableBooleanProperty("backgroundCastShadow");
    this._fontCastShadow = new InheritableBooleanProperty("fontCastShadow");
    this._backgroundReceiveShadow = new InheritableBooleanProperty("backgroundReceiveShadow");
    this._fontReceiveShadow = new InheritableBooleanProperty("fontReceiveShadow");
    this._renderOrder = new RenderOrderProperty();
    this._segments = properties.segments ? new properties.segments() : new SegmentsProperty();
    this._bounds = properties.bounds ? new properties.bounds() : new EmptyProperty("bounds");
    this._order = new OrderProperty();
    this._padding = new PaddingProperty();
    this._margin = new MarginProperty();
    this._position = new PositionProperty();
    this._flexDirection = properties.flexDirection ? new properties.flexDirection() : new FlexDirectionProperty();
    this._justifyContent = properties.justifyContent ? new properties.justifyContent() : new JustifyContentProperty();
    this._alignItems = properties.alignItems ? new properties.alignItems() : new AlignItemsProperty();
    this._display = new Display("flex");
    this._boxSizing = new BoxSizing("border-box");
    this._width = new WidthProperty();
    this._height = new HeightProperty();
    this._backgroundColor = properties.backgroundColor ? new properties.backgroundColor() : new BackgroundColorProperty();
    this._backgroundOpacity = new StyleFactorProperty("backgroundOpacity", 0.5);
    this._backgroundImage = new BackgroundImage();
    this._backgroundSize = new BackgroundSize("cover");
    this._color = properties.color ? new properties.color() : new StyleColorProperty("color", "inherit");
    this._fontOpacity = new StyleFactorProperty("fontOpacity", "inherit");
    this._whiteSpace = properties.whiteSpace ? new properties.whiteSpace() : new WhiteSpaceProperty();
    this._fontFamily = properties.fontFamily ? new properties.fontFamily() : new FontFamilyProperty();
    this._fontStyle = properties.fontStyle ? new properties.fontStyle() : new FontStyleProperty("normal");
    this._fontWeight = properties.fontWeight ? new properties.fontWeight() : new FontWeightProperty();
    this._fontSize = properties.fontSize ? new properties.fontSize() : new FontSizeProperty();
    this._lineHeight = properties.lineHeight ? new properties.lineHeight() : new LineHeightProperty();
    this._fontKerning = properties.fontKerning ? new properties.fontKerning() : new FontKerningProperty();
    this._letterSpacing = properties.letterSpacing ? new properties.letterSpacing() : new LetterSpacingProperty();
    this._overflow = new Overflow("visible");
    this._borderRadius = new BorderRadius(0);
    this._borderWidth = new BorderWidth(0);
    this._borderColor = new StyleColorProperty("borderColor", 16711935);
    this._borderOpacity = new StyleFactorProperty("borderOpacity", 1);
    this._font = new FontProperty();
    this._lineBreak = properties.lineBreak ? new properties.lineBreak() : new EmptyProperty("lineBreak");
    this._textContent = properties.textContent ? new properties.textContent() : new TextContentEmpty();
    this._glyphs = properties.glyphs ? new properties.glyphs() : new EmptyProperty("glyphs");
    this._inlines = properties.inlines ? new properties.inlines() : new EmptyProperty("inlines");
    this._layouter = properties.layouter ? new properties.layouter() : new EmptyProperty("layouter");
    this._inlineJustificator = new InlineJustificator();
    this._textAlign = properties.textAlign ? new properties.textAlign() : new TextAlignProperty();
    this._autoSize = properties.autoSize ? new properties.autoSize() : new EmptyProperty("autoSize");
    this._renderer = properties.renderer ? new properties.renderer() : new EmptyProperty("renderer");
    this._offset = new OffsetProperty();
    this._invertAlpha = new InvertAlphaProperty();
    this._fontSmooth = properties.fontSmooth ? new properties.fontSmooth() : new FontSmoothProperty();
    this._components = [
      this._textContent,
      this._children,
      this._parent,
      this._autoSize,
      this._fontFamily,
      this._fontStyle,
      this._fontWeight,
      this._font,
      this._whiteSpace,
      this._glyphs,
      this._inlines,
      this._visible,
      // Meshes interfaces
      this._backgroundSide,
      this._fontSide,
      this._backgroundAlphaTest,
      this._fontAlphaTest,
      this._backgroundCastShadow,
      this._fontCastShadow,
      this._backgroundReceiveShadow,
      this._fontReceiveShadow,
      this._renderOrder,
      this._segments,
      // styles ---;
      this._padding,
      this._margin,
      this._width,
      this._height,
      this._borderWidth,
      this._boxSizing,
      this._bounds,
      this._position,
      this._flexDirection,
      this._justifyContent,
      this._alignItems,
      this._order,
      this._display,
      this._backgroundColor,
      this._backgroundOpacity,
      this._backgroundImage,
      this._backgroundSize,
      this._fontOpacity,
      this._color,
      // font : update order : WhiteSpace > Glyph > Inlines > Kerning > newlineBreakability > LineBreak > FontSize
      // font : process order : ??
      // this._font,
      this._fontSize,
      this._lineHeight,
      this._fontKerning,
      this._letterSpacing,
      this._borderRadius,
      this._borderColor,
      this._borderOpacity,
      // this._styles,
      // styles ---;
      this._lineBreak,
      this._offset,
      this._layouter,
      this._inlineJustificator,
      this._textAlign,
      // !! this._renderer renderer MUST NOT BE in components !!
      this._invertAlpha,
      this._fontSmooth,
      this._fontMaterial,
      this._fontCustomDepthMaterial,
      this._overflow,
      this._renderer
    ];
    this._onAfterUpdates = [];
    if (!values.backgroundSide)
      values.backgroundSide = 0;
    if (values)
      this.set(values);
  }
  ///////////////
  ///  UPDATE
  ///////////////
  update() {
    const out = {};
    for (const component of this._components) {
      if (component._needsUpdate) {
        component.update(this, out);
        component._needsUpdate = false;
      }
    }
    this._transferToBackgroundMesh(out);
    this._transferToFontMesh(out);
    this._transferToBackgroundMaterial(out);
    this._transferToFontMaterial(out);
    for (const child of this._children._uis) {
      child.update();
    }
  }
  process() {
    for (const child of this._children._uis) {
      child.process();
    }
    for (const component of this._components) {
      if (component._needsProcess) {
        component.process(this);
        component._needsProcess = false;
      }
    }
  }
  render() {
    for (let i = 0; i < this._components.length; i++) {
      const component = this._components[i];
      if (component._needsRender) {
        component.render(this);
        component._needsRender = false;
      }
    }
    for (const child of this._children._uis) {
      child.render();
    }
  }
  /**
   *
   * @param {Options} options
   */
  set(options) {
    if (options.fontTexture) {
      console.warn("ThreeMeshUI::set( {fontTexture} ) is deprecated. Please use fontLibrary to register font families and variants.");
      if (options.fontFamily) {
        const fontName = options.fontFamily.pages ? options.fontFamily.info.face : options.fontFamily;
        let fontFamily = font_FontLibrary.getFontFamily(fontName);
        if (!fontFamily) {
          const fontStyle = options.fontStyle ? options.fontStyle : "normal";
          const fontWeight = options.fontWeight ? options.fontWeight : "400";
          fontFamily = font_FontLibrary.addFontFamily(fontName).addVariant(fontWeight, fontStyle, options.fontFamily, options.fontTexture);
        }
        options["fontFamily"] = fontFamily;
        delete options["fontTexture"];
      }
    }
    for (let prop of Object.keys(options)) {
      const value = options[prop];
      switch (prop) {
        case "contentDirection":
          console.warn("ThreeMeshUI v7xx: property `contentDirection` is deprecated and has been renamed as `flexDirection`");
          prop = "flexDirection";
          break;
        case "interLine":
          console.warn("ThreeMeshUI v7xx: property `interLine` is deprecated and has been renamed as `lineHeight`");
          prop = "lineHeight";
          break;
        case "content":
          console.warn("ThreeMeshUI v7xx: property `content` is deprecated and has been renamed as `textContent`");
          prop = "textContent";
          break;
        case "fontColor":
          console.warn("ThreeMeshUI v7xx: property `fontColor` is deprecated and has been renamed as `color`");
          prop = "color";
          break;
        case "hiddenOverflow":
          console.warn("ThreeMeshUI v7xx: property `hiddenOverflow` is deprecated and has been renamed as `overflow`");
          prop = "overflow";
          break;
        case "backgroundTexture":
          console.warn("ThreeMeshUI v7xx: property `backgroundTexture` is deprecated and has been renamed as `backgroundImage`");
          prop = "backgroundImage";
          break;
        case "alignContent":
          console.warn("ThreeMeshUI v7xx: property `alignContent` is deprecated and has been renamed as `alignItems`");
          prop = "alignItems";
          break;
        case "borderTopColor":
        case "borderBottomColor":
        case "borderLeftColor":
        case "borderRightColor":
          prop = "borderColor";
          break;
      }
      switch (prop) {
        case "fontSmooth":
        case "renderOrder":
        case "segments":
        case "visible":
        case "offset":
          this[`_${prop}`].value = value;
          break;
        case "flexDirection":
        case "justifyContent":
        case "alignItems":
        case "color":
        case "fontFamily":
        case "fontOpacity":
        case "fontKerning":
        case "fontSize":
        case "fontStyle":
        case "fontWeight":
        case "textAlign":
        case "letterSpacing":
        case "lineHeight":
        case "whiteSpace":
        case "breakOn":
        case "width":
        case "height":
        case "padding":
        case "margin":
        case "backgroundColor":
        case "backgroundOpacity":
        case "backgroundImage":
        case "backgroundSize":
        case "borderColor":
        case "borderOpacity":
        case "borderRadius":
        case "borderWidth":
        case "overflow":
        case "order":
        case "boxSizing":
          if (this[`_${prop}`]) {
            this[`_${prop}`].inline = value;
          }
          break;
        case "paddingTop":
          this._padding.top = value;
          break;
        case "paddingRight":
          this._padding.right = value;
          break;
        case "paddingBottom":
          this._padding.bottom = value;
          break;
        case "paddingLeft":
          this._padding.left = value;
          break;
        case "marginTop":
          this._margin.top = value;
          break;
        case "marginRight":
          this._margin.right = value;
          break;
        case "marginBottom":
          this._margin.bottom = value;
          break;
        case "marginLeft":
          this._margin.left = value;
          break;
        case "borderTopWidth":
          this._borderWidth.top = value;
          break;
        case "borderRightWidth":
          this._borderWidth.right = value;
          break;
        case "borderBottomWidth":
          this._borderWidth.bottom = value;
          break;
        case "borderLeftWidth":
          this._borderWidth.left = value;
          break;
        case "borderTopLeftRadius":
          this._borderRadius.topLeft = value;
          break;
        case "borderTopRightRadius":
          this._borderRadius.topRight = value;
          break;
        case "borderBottomRightRadius":
          this._borderRadius.bottomRight = value;
          break;
        case "borderBottomLeftRadius":
          this._borderRadius.bottomLeft = value;
          break;
        case "side":
        case "castShadow":
        case "receiveShadow":
          const upperCamelCaseProperty = prop.charAt(0).toUpperCase() + prop.substr(1);
          this[`_background${upperCamelCaseProperty}`].value = value;
          this[`_font${upperCamelCaseProperty}`].value = value;
          break;
        case "fontSide":
        case "backgroundSide":
        case "fontCastShadow":
        case "backgroundCastShadow":
        case "fontReceiveShadow":
        case "backgroundReceiveShadow":
        case "fontMaterial":
        case "fontCustomDepthMaterial":
          this[`_${prop}`].value = value;
          break;
        default:
          if (this[`_${prop}`] !== void 0) {
            this[`_${prop}`].value = value;
          } else {
            this[prop] = value;
          }
      }
    }
  }
  get(property) {
    switch (property) {
      case "overflow":
      case "width":
      case "height":
        return this[`_${property}`].inline;
    }
  }
  /**
   * Filters children in order to compute only one times children lists
   * @private
   */
  _rebuildChildrenLists() {
    this._children._needsUpdate = true;
  }
  /**
   * When the user calls component.add, it registers for updates,
   * then call THREE.Object3D.add.
   */
  /* eslint-disable no-unused-vars */
  /**
   *
   * @override
   * @param {...Object3D} object
   * @return {this}
   */
  add(object) {
    let addedUIChildren = false;
    for (let i = 0; i < arguments.length; i++) {
      super.add(arguments[i]);
      if (arguments[i].isUI) {
        addedUIChildren = true;
      }
    }
    if (addedUIChildren)
      this._rebuildChildrenLists();
    return this;
  }
  /**
   * When the user calls component.remove, it registers for updates,
   * then call THREE.Object3D.remove.
   * @override
   * @param {...Object3D} object
   * @return {this}
   */
  remove(object) {
    for (const id of Object.keys(arguments)) {
      if (arguments[id].isInline)
        this.update(null, true);
    }
    super.remove(...arguments);
    this._rebuildChildrenLists();
    return this;
  }
  /**
   *
   * @return {Object3D}
   */
  clear() {
    this.removeFromParent();
    this.traverse((obj) => {
      if (obj.material)
        obj.material.dispose();
      if (obj.geometry)
        obj.geometry.dispose();
    });
    super.clear();
    this._backgroundMesh = null;
    this._backgroundMaterial = null;
    this._backgroundMaterialMediation = null;
    this._backgroundMeshMediation = null;
    this._children.dispose();
    this._children = null;
    this._parent.dispose();
    this._parent = null;
    this._backgroundSide = null;
    this._backgroundAlphaTest = null;
    this._visible = null;
    this._backgroundCastShadow = null;
    this._backgroundReceiveShadow = null;
    this._renderOrder = null;
    this._segments = null;
    this._bounds = null;
    this._boxSizing = null;
    this._padding = null;
    this._margin = null;
    this._position = null;
    this._flexDirection = null;
    this._justifyContent = null;
    this._alignItems = null;
    this._display = null;
    this._backgroundColor = null;
    this._backgroundOpacity = null;
    this._backgroundSize = null;
    this._fontOpacity = null;
    this._color = null;
    this._whiteSpace = null;
    this._fontFamily = null;
    this._fontStyle = null;
    this._fontWeight = null;
    this._lineHeight = null;
    this._fontKerning = null;
    this._letterSpacing = null;
    this._overflow = null;
    this._textAlign = null;
    this._font = null;
    this._lineBreak = null;
    this._layouter = null;
    return this;
  }
  /**
   *
   * @return {string}
   */
  get textContent() {
    this._textContent.process(this);
    return this._textContent._value;
  }
  /***********************************************************************************************************************
   * TO MATERIAL HOLDER
   **********************************************************************************************************************/
  /**
   *
   * @returns {Material|ShaderMaterial}
   */
  get backgroundMaterial() {
    return this._backgroundMaterial;
  }
  /**
   *
   * @param {Material|ShaderMaterial} material
   */
  set backgroundMaterial(material) {
    this._backgroundMaterial = material;
    this._backgroundMaterialMediation = { ...material.constructor.mediation };
    this._transferToBackgroundMaterial();
    if (this._backgroundMesh) {
      this._backgroundMesh.material = this._backgroundMaterial;
      uniformOrUserDataTransformer(material, "frameSize", this._backgroundMesh.scale);
    }
  }
  /**
   *
   * @param {Material|null} material
   */
  set backgroundCustomDepthMaterial(material) {
    this._backgroundCustomDepthMaterial = material;
    this._transferToBackgroundMaterial();
    if (this._backgroundMesh) {
      this._backgroundMesh.customDepthMaterial = this._backgroundCustomDepthMaterial;
    }
  }
  /**
   *
   * @returns {Material|null}
   */
  get backgroundCustomDepthMaterial() {
    return this._backgroundCustomDepthMaterial;
  }
  /**
   * According to the list of materialProperties
   * some properties are sent to material
   * @param {Object} [options=null]
   * @private
   */
  _transferToBackgroundMaterial(options = null) {
    if (!options) {
      options = {};
      for (const component of this._components) {
        component.output(options);
      }
    }
    Mediator.mediate(this, this._backgroundMaterial, options, this._backgroundMaterialMediation, this._backgroundCustomDepthMaterial);
  }
  /**
   *
   * @param {number} value
   */
  set backgroundSide(value) {
    this._backgroundSide.value = value;
    if (this._backgroundMaterial)
      this._backgroundMaterial.side = value;
  }
  /**
   *
   * @return {number}
   */
  get backgroundSide() {
    return this._backgroundSide.value;
  }
  /**
   *
   * @param {number} value
   */
  set backgroundAlphaTest(value) {
    this._backgroundAlphaTest.value = value;
    if (this._backgroundMaterial)
      this._backgroundMaterial.alphaTest = value;
  }
  /**
   *
   * @return {number}
   */
  get backgroundAlphaTest() {
    return this._backgroundAlphaTest.value;
  }
  /** Font Material ----------------------------------------------------------*/
  /**
   *
   * @returns {Material|ShaderMaterial}
   */
  // get fontMaterial() { return this._fontMaterial__; }
  get fontMaterial() {
    return this._fontMaterial.value;
  }
  /**
   *
   * @param {Material|ShaderMaterial} material
   */
  set fontMaterial(material) {
    this._fontMaterial.value = material;
  }
  /**
   *
   * @param {Material|null} material
   */
  set fontCustomDepthMaterial(material) {
    this._fontCustomDepthMaterial.value = material;
  }
  /**
   *
   * @returns {Material|null}
   */
  get fontCustomDepthMaterial() {
    return this._fontCustomDepthMaterial.value;
  }
  /**
   * According to the list of materialProperties
   * some properties are sent to material
   * @param {Object} [options=null]
   * @private
   */
  _transferToFontMaterial(options = null) {
    const fontMat = this._fontMaterial.value;
    if (!fontMat)
      return;
    if (!options) {
      options = {};
      for (const component of this._components) {
        component.output(options);
      }
    }
    Mediator.mediate(this, fontMat, options, this._fontMaterial._mediation, this._fontCustomDepthMaterial.value);
  }
  /**
   *
   * @param {number} value
   */
  set fontSide(value) {
    this._fontSide.value = value;
  }
  /**
   *
   * @return {number}
   */
  get fontSide() {
    return this._fontSide.value;
  }
  /**
   *
   * @param {number} value
   */
  set fontAlphaTest(value) {
    this._fontAlphaTest.value = value;
  }
  /**
   *
   * @return {number}
   */
  get fontAlphaTest() {
    return this._fontAlphaTest.value;
  }
  /*********************************************************************************************************************
   * MESH MEDIATION
   ********************************************************************************************************************/
  /**
   * According to the list of meshProperties
   * some properties are sent to mesh
   * @param {Object} [options=null]
   * @private
   */
  _transferToBackgroundMesh(options = null) {
    if (!options) {
      options = {};
      for (const component of this._components) {
        component.output(options);
      }
    }
    Mediator.mediate(this, this._backgroundMesh, options, this._backgroundMeshMediation);
  }
  /**
   * @internal
   * @param {Mesh|Array.<Mesh>|null} mesh
   */
  setBackgroundMesh(mesh) {
    if (this._backgroundMesh) {
      this.remove(this._backgroundMesh);
      this.unbindBackgroundMeshProperties();
    }
    this._backgroundMesh = mesh;
    if (this._backgroundMesh) {
      this.bindBackgroundMeshProperties();
      if (this._backgroundCustomDepthMaterial) {
        this._backgroundMesh.customDepthMaterial = this._backgroundCustomDepthMaterial;
      }
      if (this._backgroundMaterial) {
        uniformOrUserDataTransformer(this._backgroundMaterial, "frameSize", this._backgroundMesh.scale);
      }
      this._transferToBackgroundMesh();
      this.add(this._backgroundMesh);
    }
  }
  /**
   *
   */
  bindBackgroundMeshProperties() {
  }
  /**
   *
   */
  unbindBackgroundMeshProperties() {
  }
  activatePseudoState(state) {
  }
  deactivatePseudoState(state) {
  }
  togglePseudoState(state) {
  }
  hasPseudoState(state) {
    return false;
  }
  set borderRadiusMediation(value) {
    this._borderRadius.mediation = value;
  }
  /**
   *
   * @param {boolean} value
   */
  set backgroundCastShadow(value) {
    if (this._backgroundCastShadow)
      this._backgroundCastShadow.value = value;
  }
  /**
   *
   * @return {boolean}
   */
  get backgroundCastShadow() {
    return this._backgroundCastShadow;
  }
  /**
   *
   * @param {boolean} value
   */
  set backgroundReceiveShadow(value) {
    if (this._backgroundReceiveShadow)
      this._backgroundReceiveShadow.value = value;
  }
  /**
   *
   * @return {boolean}
   */
  get backgroundReceiveShadow() {
    return this._backgroundReceiveShadow;
  }
  /**
   *
   * @param {number} value
   */
  set renderOrder(value) {
    if (this._renderOrder)
      this._renderOrder.value = value;
  }
  /**
   *
   * @return {number}
   */
  get renderOrder() {
    return this._renderOrder.value;
  }
  /** Font Mesh --------------------------------------------------------------*/
  /**
   * According to the list of meshProperties
   * some properties are sent to mesh
   * @param {Object} [options=null]
   * @private
   */
  _transferToFontMesh(options = null) {
    if (!this._fontMesh)
      return;
    if (!options) {
      options = {};
      for (const component of this._components) {
        component.output(options);
      }
    }
    Mediator.mediate(this, this._fontMesh, options, this._fontMeshMediation);
  }
  /**
   * @internal
   * @param {Mesh|Array.<Mesh>|null} mesh
   */
  setFontMesh(mesh) {
    if (this._fontMesh) {
      this.remove(this._fontMesh);
      if (this._fontMesh.material)
        this._fontMesh.material.dispose();
      if (this._fontMesh.geometry)
        this._fontMesh.geometry.dispose();
      this._fontMesh = null;
      this.unbindFontMeshProperties();
    }
    this._fontMesh = mesh;
    if (this._fontMesh) {
      this._fontMesh.raycast = () => {
      };
      this.bindFontMeshProperties();
      this._transferToFontMaterial();
      this._transferToFontMesh();
      this.add(this._fontMesh);
    }
  }
  /**
   *
   */
  bindFontMeshProperties() {
  }
  /**
   *
   */
  unbindFontMeshProperties() {
  }
  /**
   *
   * @param {boolean} value
   */
  set fontCastShadow(value) {
    if (this._fontCastShadow)
      this._fontCastShadow.value = value;
  }
  /**
   *
   * @return {boolean}
   */
  get fontCastShadow() {
    return this._fontCastShadow;
  }
  /**
   *
   * @param {boolean} value
   */
  set fontReceiveShadow(value) {
    if (this._fontReceiveShadow)
      this._fontReceiveShadow.value = value;
  }
  /**
   *
   * @return {boolean}
   */
  get fontReceiveShadow() {
    return this._fontReceiveShadow;
  }
  /***********************************************************************************************************************
   * GEOMETRY
   **********************************************************************************************************************/
  /**
   *
   * @param {Number} v
   */
  set segments(v4) {
    this._segments.value = v4;
  }
  /**
   *
   * @return {number}
   */
  get segments() {
    return this._segments.value;
  }
  /***********************************************************************************************************************
   * HOOKS & ALTERS
   **********************************************************************************************************************/
  /**
   *
   * @param {Function} func
   */
  set onAfterUpdate(func) {
    console.warn("ThreeMeshUI v7xx : `onAfterUpdate()` property has been deprecated, please rely on `addAfterUpdate` instead.");
    this.addAfterUpdate(func);
  }
  /**
   *
   * @param {Function} func
   */
  addAfterUpdate(func) {
    this._onAfterUpdates.push(func);
  }
  /**
   *
   * @param {Function} func
   */
  removeAfterUpdate(func) {
    const index = this._onAfterUpdates.indexOf(func);
    if (index !== -1) {
      this._onAfterUpdates.splice(index, 1);
    }
  }
  /**
   * @todo: afterUpdate not called anymore
   */
  performAfterUpdate() {
    for (let i = 0; i < this._onAfterUpdates.length; i++) {
      this._onAfterUpdates[i]();
    }
  }
  /**
   * Retrieve a property
   * @param propertyName
   * @return {BaseProperty|null}
   */
  getProperty(propertyName) {
    if (this[`_${propertyName}`]) {
      return this[`_${propertyName}`];
    }
    return null;
  }
  /**
   *
   * @param {string} name
   * @param {BaseProperty} instance
   * @returns {void}
   */
  appendProperty(name, instance) {
    this[`_${name}`] = instance;
    this._components.push(instance);
  }
  /**
   *
   * @param {string} name
   * @param {BaseProperty} instance
   * @returns {BaseProperty}
   */
  replaceProperty(name, instance) {
    const oldProperty = this[`_${name}`];
    const index = this._components.indexOf(oldProperty);
    this._components[index] = this[`_${name}`] = instance;
    instance.needsUpdate = true;
    return oldProperty;
  }
};
var UpdateManager = class {
  static register(component) {
    if (!this.elements.includes(component)) {
      this.elements.push(component);
    }
  }
  static remove(component) {
    const index = this.elements.indexOf(component);
    if (index !== -1) {
      this.elements.splice(index, 1);
    }
  }
  static update() {
    for (const UIElement of this.elements) {
      UIElement.update();
      UIElement.process();
      UIElement.process();
      UIElement.render();
    }
  }
};
UpdateManager.elements = [];
var frame_border_pars_vertex_glsl_program = (
  /* glsl */
  `

// FrameBorder vertex pars
attribute vec2 uvB;
varying vec2 vUvB;

`
);
var frame_border_pars_vertex_glsl = frame_border_pars_vertex_glsl_program;
var frame_border_vertex_glsl_program = (
  /* glsl */
  `

	// FrameBorder vertex shader
	vUvB = uvB;

`
);
var frame_border_vertex_glsl = frame_border_vertex_glsl_program;
var frame_border_pars_fragment_glsl_program = (
  /* glsl */
  `

// borders sequences are : x:TOP, y:RIGHT, z:BOTTOM, w:LEFT
uniform vec4 borderWidth;
uniform vec3 borderColor;
uniform float borderOpacity;
uniform vec4 borderRadius;

uniform vec2 cornerTL;
uniform vec2 cornerTR;
uniform vec2 cornerBR;
uniform vec2 cornerBL;

varying vec2 vUvB;

float getEllipticFactor( vec2 uv, vec2 center, float radiusX, float radiusY )
{

		float edx = uv.x - center.x;
		float edy = uv.y - center.y;

		float ddx = (edx * edx) / (radiusX * radiusX);
		float ddy = (edy * edy) / (radiusY * radiusY);

		return ddx + ddy;

}

`
);
var frame_border_pars_fragment_glsl = frame_border_pars_fragment_glsl_program;
var frame_border_fragment_glsl_program = (
  /* glsl */
  `

vec4 borderColor = vec4( borderColor, borderOpacity );

// This could be tweak to produce more smoothing
float mult = 1.0;

// Step 1 ----------------------------------------------
// Draw the four borders ( top - right - bottom - left )
// Without worrying about radiuses ( Straight boorders )

// Top
float topBorderUVy = 1.0 - borderWidth.x;
if( borderWidth.x > 0.0 && vUvB.y > topBorderUVy )
{

	float w = fwidth( 1.0 - vUvB.y ) * mult;
	float step = smoothstep( topBorderUVy , topBorderUVy + w , vUvB.y );
	diffuseColor = mix( diffuseColor, borderColor, step );

}

// Left
float leftBorderUVx = borderWidth.w;
if( borderWidth.w > 0.0 && vUvB.x < leftBorderUVx )
{

	float w = fwidth( vUvB.x ) * mult ;
	float step = smoothstep( leftBorderUVx , leftBorderUVx - w , vUvB.x );
	diffuseColor = mix( diffuseColor, borderColor, step );

}

// Bottom
float bottomBorderUVy = borderWidth.z;
if( borderWidth.z > 0.0 && vUvB.y < bottomBorderUVy )
{
	float w = fwidth( vUvB.y ) * mult;
	float step = smoothstep( bottomBorderUVy , bottomBorderUVy - w , vUvB.y );
	diffuseColor = mix( diffuseColor, borderColor, step );
}

// Right
float rightBorderUVx = 1.0 - borderWidth.y;
if( borderWidth.y > 0.0 && vUvB.x > rightBorderUVx )
{
	float w = fwidth( 1.0 - vUvB.x ) * mult;
	float step = smoothstep( rightBorderUVx , rightBorderUVx + w , vUvB.x );
	diffuseColor = mix( diffuseColor, borderColor, step );
}


// Step 2 ----------------------------------------------
// Process each corners ( topLeft, topRight, bottomRight, bottomLeft )
// To transparentize outside radiuses
// To draw ellipse border on the corner


// Top Left corner
if( vUvB.x < cornerTL.x && vUvB.y > cornerTL.y ) {

		// Only draw border if width is set
		if( borderWidth.w + borderWidth.x > 0.0 ){

			float borderFactor = getEllipticFactor( vUvB, cornerTL, cornerTL.x - borderWidth.w,  ( 1.0 - cornerTL.y ) - borderWidth.x );
			float step = smoothstep( 1.0, 1.0 + fwidth( borderFactor ) * mult, borderFactor );
			diffuseColor = mix( diffuseColor, borderColor, step );

		}

		// Then then radius
		float radiusFactor = getEllipticFactor( vUvB, cornerTL, cornerTL.x, 1.0 - cornerTL.y );
		float alphaStep = smoothstep( 1.0 , 1.0 + fwidth(radiusFactor) * mult , radiusFactor );
		diffuseColor.a = mix( diffuseColor.a, 0.0, alphaStep );

}
// Bottom Left
if( vUvB.x < cornerBL.x && vUvB.y < cornerBL.y ) {

		if( borderWidth.w + borderWidth.z > 0.0 ){

			float borderFactor = getEllipticFactor( vUvB, cornerBL, cornerBL.x - borderWidth.w,  cornerBL.y - borderWidth.z );
			float step = smoothstep( 1.0, 1.0 + fwidth( borderFactor ) * mult, borderFactor );
			diffuseColor = mix( diffuseColor, borderColor, step );

		}


		float radiusFactor = getEllipticFactor( vUvB, cornerBL, cornerBL.x, cornerBL.y );
		float alphaStep = smoothstep( 1.0 , 1.0 + fwidth(radiusFactor) * mult , radiusFactor );
		diffuseColor.a = mix( diffuseColor.a, 0.0, alphaStep );

}
// Top Right
if( vUvB.x > cornerTR.x && vUvB.y > cornerTR.y ) {

		if( borderWidth.y + borderWidth.x > 0.0 ){

			float borderFactor = getEllipticFactor( vUvB, cornerTR, ( 1.0 - cornerTR.x ) - borderWidth.y,  ( 1.0 - cornerTR.y ) - borderWidth.x );
			float step = smoothstep( 1.0, 1.0 + fwidth( borderFactor ) * mult, borderFactor );
			diffuseColor = mix( diffuseColor, borderColor, step );

		}

		float radiusFactor = getEllipticFactor( vUvB, cornerTR, 1.0 - cornerTR.x, 1.0 - cornerTR.y );
		float alphaStep = smoothstep( 1.0 , 1.0 + fwidth(radiusFactor) * mult , radiusFactor );
		diffuseColor.a = mix( diffuseColor.a, 0.0, alphaStep );

}
// Bottom Right
if( vUvB.x > cornerBR.x && vUvB.y < cornerBR.y ) {

		if( borderWidth.y + borderWidth.z > 0.0 ){

			float borderFactor = getEllipticFactor( vUvB, cornerBR, ( 1.0 - cornerBR.x ) - borderWidth.y,  cornerBR.y - borderWidth.z );
			float step = smoothstep( 1.0, 1.0 + fwidth( borderFactor ) * mult, borderFactor );
			diffuseColor = mix( diffuseColor, borderColor, step );

		}

		float radiusFactor = getEllipticFactor( vUvB, cornerBR, 1.0 - cornerBR.x, cornerBR.y );
		float alphaStep = smoothstep( 1.0 , 1.0 + fwidth(radiusFactor) * mult , radiusFactor );
		diffuseColor.a = mix( diffuseColor.a, 0.0, alphaStep );

}

`
);
var frame_border_fragment_glsl = frame_border_fragment_glsl_program;
var frame_common_pars_fragment_glsl_program = (
  /* glsl */
  `

// To be removed - required for both border and background
uniform vec3 frameSize;
uniform vec2 textureSize;

`
);
var frame_common_pars_fragment_glsl = frame_common_pars_fragment_glsl_program;
var frame_background_pars_fragment_glsl_program = (
  /* glsl */
  `

#ifdef USE_MAP

vec4 sampleTexture() {

	vec2 uv = vUv;

	// default stretch
	#if BACKGROUND_MAPPING != 0

	float textureRatio = textureSize.x / textureSize.y;
	float panelRatio = frameSize.x / frameSize.y;
	float ratio = panelRatio / textureRatio;
	float ratio2 = textureRatio / panelRatio;

		// contain
		#if BACKGROUND_MAPPING == 1
		if ( textureRatio < panelRatio ) { // repeat on X
			float newX = uv.x * ratio;
			newX += 0.5 - 0.5 * ratio;
			uv.x = newX;
		} else { // repeat on Y
			float newY = uv.y * ratio2;
			newY += 0.5 - 0.5 * ratio2;
			uv.y = newY;
		}
		#else
		// cover
		if ( textureRatio < panelRatio ) { // stretch on Y
			float newY = uv.y * ratio2;
			newY += 0.5 - 0.5 * ratio2;
			uv.y = newY;
		} else { // stretch on X
			float newX = uv.x * ratio;
			newX += 0.5 - 0.5 * ratio;
			uv.x = newX;
		}

		#endif

	#endif

	return texture2D( map, uv );

}
#endif
`
);
var frame_background_pars_fragment_glsl = frame_background_pars_fragment_glsl_program;
var frame_background_fragment_glsl_program = (
  /* glsl */
  `
#ifdef USE_MAP

	vec4 textureSample = sampleTexture();
	diffuseColor *= textureSample;

#endif
`
);
var frame_background_fragment_glsl = frame_background_fragment_glsl_program;
var ShaderChunkUI = {
  msdfAlphaglyphParsVertexGlsl: msdf_alphaglyph_pars_vertex_glsl,
  msdfAlphaglyphVertexGlsl: msdf_alphaglyph_vertex_glsl,
  msdfOffsetglyphVertexGlsl: msdf_offsetglyph_vertex_glsl,
  msdfAlphaglyphParsFragmentGlsl: msdf_alphaglyph_pars_fragment_glsl,
  msdfAlphaglyphFragmentGlsl: msdf_alphaglyph_fragment_glsl,
  frameBorderParsVertexGlsl: frame_border_pars_vertex_glsl,
  frameBorderVertexGlsl: frame_border_vertex_glsl,
  frameCommonParsFragmentGlsl: frame_common_pars_fragment_glsl,
  frameBorderParsFragmentGlsl: frame_border_pars_fragment_glsl,
  frameBorderFragmentGlsl: frame_border_fragment_glsl,
  frameBackgroundParsFragmentGlsl: frame_background_pars_fragment_glsl,
  frameBackgroundFragmentGlsl: frame_background_fragment_glsl
};
var framematerial_glsl_vertexShader = (
  /* glsl */
  `
// Would be automatic on three materials and from USE_UV
#ifdef USE_MAP
varying vec2 vUv;
#endif

${frame_border_pars_vertex_glsl}

#include <clipping_planes_pars_vertex>

void main() {

	#ifdef USE_MAP
	vUv = uv;
	#endif

	${frame_border_vertex_glsl}

	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
	gl_Position = projectionMatrix * mvPosition;

	#include <clipping_planes_vertex>

}
`
);
var framematerial_glsl_fragmentShader = (
  /* glsl */
  `

// Basic
uniform vec3 diffuse;
uniform float opacity;

#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif

${frame_common_pars_fragment_glsl}

${frame_border_pars_fragment_glsl}


#ifdef USE_MAP
varying vec2 vUv;
uniform sampler2D map;
#endif

${frame_background_pars_fragment_glsl}

#include <clipping_planes_pars_fragment>

void main() {

	vec4 diffuseColor = vec4( diffuse, opacity );

	// map
	${frame_background_fragment_glsl}

	${frame_border_fragment_glsl}

	#ifdef USE_ALPHATEST

	if ( diffuseColor.a < alphaTest ) discard;

	#endif

	// output
	gl_FragColor = diffuseColor;


	#include <clipping_planes_fragment>
}
`
);
var FrameMaterialUtils = class {
  /**
   *
   * @returns {Object<{m: string, t?: (function((Material|ShaderMaterial), string, *): void)}>}
   */
  static get mediation() {
    return _mediationDefinitions;
  }
  /**
   * Alter a material options with required fontMaterial options and or default values
   * @param {Object.<string,any>} materialOptions
   */
  static ensureMaterialOptions(materialOptions) {
    materialOptions.transparent = true;
    materialOptions.alphaTest = materialOptions.alphaTest || 0.02;
  }
  /**
   * As three-mesh-ui FontMaterial relies on webgl preprocessors,
   * lets force the material to have a proper defines object
   * @param {Material|ShaderMaterial} threeMaterial
   */
  static ensureDefines(threeMaterial) {
    if (!threeMaterial.defines) {
      threeMaterial.defines = {};
    }
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @param {Material|ShaderMaterial} threeMaterial
   * @param {Object.<string,any>} materialOptions
   */
  static ensureUserData(threeMaterial, materialOptions) {
    threeMaterial.userData.borderColor = { value: null };
    threeMaterial.userData.borderRadius = { value: new external_three_namespaceObject.Vector4(0, 0, 0, 0) };
    threeMaterial.userData.cornerTL = { value: new external_three_namespaceObject.Vector2(0, 1) };
    threeMaterial.userData.cornerTR = { value: new external_three_namespaceObject.Vector2(1, 1) };
    threeMaterial.userData.cornerBR = { value: new external_three_namespaceObject.Vector2(1, 0) };
    threeMaterial.userData.cornerBL = { value: new external_three_namespaceObject.Vector2(0, 0) };
    threeMaterial.userData.borderWidth = { value: new external_three_namespaceObject.Vector4(0, 0, 0, 0) };
    threeMaterial.userData.borderOpacity = { value: null };
    threeMaterial.userData.frameSize = { value: new external_three_namespaceObject.Vector3(1, 1, 1) };
    threeMaterial.userData.textureSize = { value: new external_three_namespaceObject.Vector2(1, 1) };
  }
  /* eslint-enable no-unused-vars */
  /**
   *
   * @param {any} shader
   * @param {Material|ShaderMaterial} threeMaterial
   */
  static bindUniformsWithUserData(shader, threeMaterial) {
    shader.uniforms.borderColor = threeMaterial.userData.borderColor;
    shader.uniforms.borderRadius = threeMaterial.userData.borderRadius;
    shader.uniforms.cornerTL = threeMaterial.userData.cornerTL;
    shader.uniforms.cornerTR = threeMaterial.userData.cornerTR;
    shader.uniforms.cornerBR = threeMaterial.userData.cornerBR;
    shader.uniforms.cornerBL = threeMaterial.userData.cornerBL;
    shader.uniforms.borderWidth = threeMaterial.userData.borderWidth;
    shader.uniforms.borderOpacity = threeMaterial.userData.borderOpacity;
    shader.uniforms.frameSize = threeMaterial.userData.frameSize;
    shader.uniforms.textureSize = threeMaterial.userData.textureSize;
  }
  /**
   *
   * @param shader
   */
  static injectShaderChunks(shader) {
    FrameMaterialUtils.injectVertexShaderChunks(shader);
    FrameMaterialUtils.injectFragmentShaderChunks(shader);
  }
  /**
   *
   * @param shader
   */
  static injectVertexShaderChunks(shader) {
    shader.vertexShader = shader.vertexShader.replace(
      "#include <uv_pars_vertex>",
      "#include <uv_pars_vertex>\n" + frame_border_pars_vertex_glsl
    );
    shader.vertexShader = shader.vertexShader.replace(
      "#include <uv_vertex>",
      "#include <uv_vertex>\n" + frame_border_vertex_glsl
    );
  }
  /**
   *
   * @param shader
   */
  static injectFragmentShaderChunks(shader) {
    shader.fragmentShader = shader.fragmentShader.replace(
      "#include <map_pars_fragment>",
      "#include <map_pars_fragment>\n" + frame_background_pars_fragment_glsl
    );
    shader.fragmentShader = shader.fragmentShader.replace(
      "#include <map_pars_fragment>",
      "#include <map_pars_fragment>\n" + frame_border_pars_fragment_glsl
    );
    shader.fragmentShader = shader.fragmentShader.replace(
      "#include <map_pars_fragment>",
      "#include <map_pars_fragment>\n" + frame_common_pars_fragment_glsl
    );
    shader.fragmentShader = shader.fragmentShader.replace(
      "#include <map_fragment>",
      frame_background_fragment_glsl
    );
    shader.fragmentShader = shader.fragmentShader.replace(
      "#include <alphamap_fragment>",
      frame_border_fragment_glsl + "\n#include <alphamap_fragment>"
    );
  }
};
var _backgroundSizeTransformer = function(target, property, value) {
  value = ["stretch", "contain", "cover"].indexOf(value);
  asPreprocessorValueTransformer(target, "BACKGROUND_MAPPING", value);
};
var _mediationDefinitions = {
  clippingPlanes: { m: "clippingPlanes" },
  backgroundAlphaTest: { m: "alphaTest", t: alphaTestTransformer },
  backgroundSide: { m: "side" },
  // backgroundTexture: { m: 'map' },
  backgroundImage: { m: "map" },
  backgroundColor: { m: "color" },
  backgroundOpacity: { m: "opacity" },
  backgroundSize: { m: "computedBackgroundSize", t: _backgroundSizeTransformer },
  borderWidth: { m: "borderWidth", t: uniformOrUserDataTransformer },
  borderColor: { m: "borderColor", t: uniformOrUserDataTransformer },
  cornerTL: { m: "cornerTL", t: uniformOrUserDataTransformer },
  cornerTR: { m: "cornerTR", t: uniformOrUserDataTransformer },
  cornerBR: { m: "cornerBR", t: uniformOrUserDataTransformer },
  cornerBL: { m: "cornerBL", t: uniformOrUserDataTransformer },
  borderOpacity: { m: "borderOpacity", t: uniformOrUserDataTransformer },
  size: { m: "frameSize", t: uniformOrUserDataTransformer },
  tSize: { m: "textureSize", t: uniformOrUserDataTransformer }
};
var FrameMaterial = class extends external_three_namespaceObject.ShaderMaterial {
  /**
   * This static method is mandatory for extending ThreeMeshUI.FrameMaterial
   * It will provide a transfer description for properties from ThreeMeshUI.Text to THREE.Material
   * @see {FrameMaterialUtils.mediation}
   * @returns {Object.<{m:string, t?:(frameMaterial:Material|ShaderMaterial, materialProperty:string, value:any) => void}>}
   */
  static get mediation() {
    return FrameMaterialUtils.mediation;
  }
  constructor() {
    super({
      uniforms: {
        alphaTest: { value: 0.02 },
        map: { value: null },
        diffuse: { value: new external_three_namespaceObject.Color(16777215) },
        opacity: { value: 1 },
        borderColor: { value: new external_three_namespaceObject.Color(0) },
        borderOpacity: { value: 0 },
        borderRadius: { value: new external_three_namespaceObject.Vector4(0, 0, 0, 0) },
        // Corners for customized radius not all starting on center [0.5,0.5];
        // Corners will be generated from borderRadiuses
        cornerTL: { value: new external_three_namespaceObject.Vector2(0, 1) },
        cornerTR: { value: new external_three_namespaceObject.Vector2(1, 1) },
        cornerBR: { value: new external_three_namespaceObject.Vector2(1, 0) },
        cornerBL: { value: new external_three_namespaceObject.Vector2(0, 0) },
        borderWidth: { value: new external_three_namespaceObject.Vector4(0, 0, 0, 0) },
        frameSize: { value: new external_three_namespaceObject.Vector3(1, 1, 1) },
        textureSize: { value: new external_three_namespaceObject.Vector2(1, 1) }
      },
      side: external_three_namespaceObject.FrontSide,
      transparent: true,
      clipping: true,
      vertexShader: framematerial_glsl_vertexShader,
      fragmentShader: framematerial_glsl_fragmentShader,
      extensions: {
        derivatives: true
      }
    });
    this.defines["USE_ALPHATEST"] = "";
    this.needsUpdate = true;
  }
  set map(value) {
    this.uniforms.map.value = value;
    if (!value) {
      if (this.defines["USE_UV"] !== void 0) {
        delete this.defines["USE_UV"];
        this.needsUpdate = true;
      }
    } else if (this.defines["USE_UV"] === void 0) {
      this.defines["USE_UV"] = "";
      this.needsUpdate = true;
    }
    this.needsUpdate = true;
  }
  get map() {
    return this.uniforms.map.value;
  }
  /**
   *
   * @returns {number}
   */
  get alphaTest() {
    return this.uniforms.alphaTest.value;
  }
  /**
   *
   * @param {number} v
   */
  set alphaTest(v4) {
    this.uniforms.alphaTest.value = v4;
  }
  /**
   *
   * @param {number} v
   */
  set opacity(v4) {
    if (this.uniforms)
      this.uniforms.opacity.value = v4;
  }
  /**
   * The color will be the diffuse uniform
   * @returns {number}
   */
  get opacity() {
    return this.uniforms.opacity.value;
  }
  /**
   * The color will be the diffuse uniform
   * @returns {Color}
   */
  get color() {
    return this.uniforms.diffuse.value;
  }
  /**
   *
   * @param {Color} v
   */
  set color(v4) {
    this.uniforms.diffuse.value = v4;
  }
};
var ChildrenBox = class extends BaseProperty {
  constructor() {
    super("children", null, false);
    /**
     *
     * Sort children according to their .style.order property or fallback on children index
     *
     * @param {HTMLElementVR} a
     * @param {HTMLElementVR} b
     * @return {number}
     * @private
     */
    __publicField(this, "_sortOrder", (a, b) => {
      if (a._order._value < b._order._value)
        return -1;
      if (a._order._value > b._order._value)
        return 1;
      if (this._uis.indexOf(a) < this._uis.indexOf(b)) {
        return -1;
      }
      return 1;
    });
    this._uis = [];
    this._boxes = [];
  }
  /* eslint-disable no-unused-vars */
  /**
   * Update requested when :
   * 		- New child has been added
   * 		- Existing child has been removed
   *
   * @param element
   * @param out
   */
  update(element, out) {
    this._compute(element);
    element._layouter._needsUpdate = true;
    element._renderOrder._needsUpdate = true;
  }
  /**
   * Process when :
   * 		- Existing child visibility changed
   *
   * @param element
   */
  process(element) {
    this._compute(element);
    element._flexDirection._needsProcess = true;
    element._layouter._needsProcess = true;
    element._overflow._needsRender = true;
  }
  _compute(element) {
    this._uis = element.children.filter((child) => child.visible && child.isUI);
    this._boxes = this._uis.filter((child) => child.isBox).sort(this._sortOrder);
  }
  /**
   *
   */
  dispose() {
    this._uis = null;
    this._boxes = null;
  }
};
var BoundsBox = class extends BaseProperty {
  constructor() {
    super("bounds", null, false);
    this._size = new external_three_namespaceObject.Vector3(1, 1, 1);
    this._offsetWidth = 0;
    this._offsetHeight = 0;
    this._innerWidth = 0;
    this._innerHeight = 0;
    this._centerX = 0.5;
    this._centerY = 0.5;
    this._needsProcess = true;
  }
  /**
   * Set the value of the width 100%
   * @param element
   * @param value
   */
  setReferenceWidth(element, value) {
    const width = element._width;
    const padding = element._padding._value;
    const borderWidth = element._borderWidth._value;
    const margin = element._margin._value;
    const factor = width._auto ? 1 : width._value;
    const newOffsetWidth = value * factor - (margin.y + margin.w);
    if (numberEquals(newOffsetWidth, this._offsetWidth))
      return;
    this._offsetWidth = newOffsetWidth;
    this._innerWidth = this._offsetWidth - (padding.y + padding.w + borderWidth.y + borderWidth.w);
    this._centerX = _computeCenterX(element);
    this._propagateWidth(element);
    this._triggerCascadingDependencies(element);
  }
  /**
   * Set the value of the height 100%
   * @param element
   * @param value
   */
  setReferenceHeight(element, value) {
    const height = element._height;
    const padding = element._padding._value;
    const borderWidth = element._borderWidth._value;
    const margin = element._margin._value;
    const factor = height._auto ? 1 : height._value;
    const newOffsetHeight = value * factor - (margin.x + margin.z);
    if (numberEquals(newOffsetHeight, this._offsetHeight))
      return;
    this._offsetHeight = newOffsetHeight;
    this._innerHeight = this._offsetHeight - (padding.x + padding.z + borderWidth.x + borderWidth.z);
    this._centerY = _computeCenterY(element);
    this._propagateHeight(element);
    this._triggerCascadingDependencies(element);
  }
  setChildrenWidth(element, value) {
    const padding = element._padding._value;
    const border = element._borderWidth._value;
    this._innerWidth = value;
    this._offsetWidth = this._innerWidth + (padding.y + padding.w + border.y + border.w);
    this._centerX = _computeCenterX(element);
    this._propagateWidth(element);
    this._triggerCascadingDependencies(element);
  }
  setChildrenHeight(element, value) {
    const padding = element._padding._value;
    const border = element._borderWidth._value;
    this._innerHeight = value;
    this._offsetHeight = this._innerHeight + (padding.x + padding.z + border.x + border.z);
    this._centerY = _computeCenterY(element);
    this._propagateHeight(element);
    this._triggerCascadingDependencies(element);
  }
  /* eslint-disable no-unused-vars */
  update(element, out) {
    const padding = element._padding._value;
    const border = element._borderWidth._value;
    const width = element._width;
    if (!width._auto && !width._relative) {
      if (element._boxSizing._value === "content-box") {
        this._innerWidth = width._value;
        this._offsetWidth = this._innerWidth + padding.y + padding.w + border.y + border.w;
      } else {
        this._offsetWidth = width._value;
        this._innerWidth = this._offsetWidth - (padding.y + padding.w + border.y + border.w);
      }
      this._centerX = _computeCenterX(element);
      this._needsProcess = true;
      this._propagateWidth(element);
      this._triggerCascadingDependencies(element);
    }
    const height = element._height;
    if (!height._auto && !height._relative) {
      if (element._boxSizing._value === "content-box") {
        this._innerHeight = height._value;
        this._offsetHeight = this._innerHeight + padding.x + padding.z + border.x + border.z;
      } else {
        this._offsetHeight = height._value;
        this._innerHeight = this._offsetHeight - (padding.x + padding.z + border.x + border.z);
      }
      this._centerY = _computeCenterY(element);
      this._needsProcess = true;
      this._propagateHeight(element);
      this._triggerCascadingDependencies(element);
    }
  }
  /* eslint-disable no-unused-vars */
  render(element) {
    this._size.x = this._offsetWidth;
    this._size.y = this._offsetHeight;
    if (element._backgroundMesh) {
      element._backgroundMesh.updateScale();
    }
    element._renderer._needsRender = true;
  }
  /**
   *
   * @param {Object.<string,any>} out
   */
  output(out) {
    out["size"] = this._size;
  }
  /* eslint-disable no-unused-vars */
  /**
   * @override
   */
  process(element) {
    element._overflow._needsRender = true;
  }
  /**
   *
   * @param element
   * @internal
   */
  _computeChildrenSideWidth(element) {
    return _computeChildrenSideWidth(element);
  }
  /**
   *
   * @param element
   * @internal
   */
  _computeChildrenSideHeight(element) {
    return _computeChildrenSideHeight(element);
  }
  _propagateWidth(element) {
    for (let i = 0; i < element._children._boxes.length; i++) {
      const box2 = element._children._boxes[i];
      const width = box2._width;
      if (width._relative)
        box2._bounds.setReferenceWidth(box2, this._innerWidth);
    }
  }
  _propagateHeight(element) {
    for (let i = 0; i < element._children._boxes.length; i++) {
      const box2 = element._children._boxes[i];
      const height = box2._height;
      if (height._relative)
        box2._bounds.setReferenceHeight(box2, this._innerHeight);
    }
  }
  _triggerCascadingDependencies(element) {
    if (element._parent._value) {
      element._parent._value._autoSize._needsProcess = true;
    }
    element._flexDirection._needsProcess = true;
    element._fontSize._needsProcess = true;
    element._layouter._needsProcess = true;
    this._needsRender = true;
    element._borderWidth._needsRender = true;
    element._borderRadius._needsRender = true;
    element._overflow._needsRender = true;
  }
};
function _computeCenterX(element) {
  const padding = element._padding._value;
  const borderWidth = element._borderWidth._value;
  const leftSide = padding.w + borderWidth.w;
  const rightSide = padding.y + borderWidth.y;
  return (leftSide - rightSide) / 2;
}
function _computeCenterY(element) {
  const padding = element._padding._value;
  const borderWidth = element._borderWidth._value;
  const topSide = padding.x + borderWidth.x;
  const bottomSide = padding.z + borderWidth.z;
  return (bottomSide - topSide) / 2;
}
function _computeChildrenSideWidth(element) {
  return element._children._boxes.reduce((accu, child) => {
    const margin = child._margin._value;
    const CHILD_SIZE = child._bounds._offsetWidth + margin.y + margin.w;
    return accu + CHILD_SIZE;
  }, 0);
}
function _computeChildrenSideHeight(element) {
  return element._children._boxes.reduce((accu, child) => {
    const margin = child._margin._value;
    const CHILD_SIZE = child._bounds._offsetHeight + margin.x + margin.z;
    return accu + CHILD_SIZE;
  }, 0);
}
var AlignItemsPropertyBox = class extends AlignItemsProperty {
  constructor() {
    super();
    this._allowsInherit = false;
    this._needsUpdate = true;
    this._process = this.emptyStrategyLogic;
    this._childAlign = this.emptyStrategyLogic;
  }
  /**
   *
   * @param {MeshUIBaseElement} element
   */
  computeOutputValue(element) {
    this._value = this._inheritedInput;
    switch (element._flexDirection._value) {
      case "row":
      case "row-reverse":
        this._process = _processRow;
        switch (this._value) {
          case "start":
            this._childAlign = _alignChildRowStart;
            break;
          case "end":
            this._childAlign = _alignChildRowEnd;
            break;
          default:
            this._childAlign = _alignChild;
        }
        break;
      case "column":
      case "column-reverse":
        this._process = _processColumn;
        switch (this._value) {
          case "start":
            this._childAlign = _alignChildColumnStart;
            break;
          case "end":
            this._childAlign = _alignChildColumnEnd;
            break;
          default:
            this._childAlign = _alignChild;
        }
        break;
    }
    this._needsProcess = true;
    element._autoSize._needsProcess = true;
    element._flexDirection._needsProcess = true;
    element._justifyContent._needsProcess = true;
    this._needsProcess = true;
    element._fontSize._needsProcess = true;
    element._layouter._needsProcess = true;
  }
  /**
   *
   * @param element
   */
  process(element) {
    this._process(element, this._childAlign);
    let snap = "center";
    let snapXon = "center";
    let snapYon = "center";
    const padding = element._padding._value;
    const border = element._borderWidth._value;
    if (element._flexDirection._value.indexOf("column") !== -1) {
      if (this._value === "start") {
        snap = snapXon = "left";
      } else if (this._value === "end") {
        snap = snapXon = "right";
      } else {
        snap = "centerX";
      }
    } else {
      if (this._value === "start") {
        snap = snapYon = "top";
      } else if (this._value === "end") {
        snap = snapYon = "bottom";
      } else {
        snap = "centerY";
      }
    }
    let y = -(padding.x - padding.z) / 2 - (border.x - border.z) / 2;
    let x2 = -(padding.y - padding.w) / 2 - (border.y - border.w) / 2;
    if (snapXon === "left") {
      x2 = (padding.w - padding.y) / 2 + (border.w - border.y) / 2;
    } else if (snapXon === "right") {
      x2 = -(padding.y - padding.w) / 2 - (border.y - border.w) / 2;
    }
    if (snapYon === "top") {
      y = -(padding.x - padding.z) / 2 - (border.x - border.z) / 2;
    } else if (snapYon === "bottom") {
      y = (padding.z - padding.x) / 2 + (border.z - border.x) / 2;
    }
    element._children._boxes.forEach((child) => {
      let marginX = 0;
      let marginY = 0;
      if (snap === "top") {
        marginY = -child._margin._value.x;
      } else if (snap === "bottom") {
        marginY = child._margin._value.z;
      } else if (snap === "left") {
        marginX = child._margin._value.w;
      } else if (snap === "right") {
        marginX = -child._margin._value.y;
      } else if (snap === "centerX") {
        marginX = (child._margin._value.w - child._margin._value.y) / 2;
      } else if (snap === "centerY") {
        marginY = (-child._margin._value.x + child._margin._value.z) / 2;
      }
      element._layouter._childrenPos[child.id].x += x2 + marginX;
      element._layouter._childrenPos[child.id].y += y + marginY;
    });
  }
};
function _alignChild() {
  return 0;
}
function _alignChildRowEnd(child, parentOffset) {
  return -parentOffset + child._bounds._offsetHeight / 2;
}
function _alignChildRowStart(child, parentOffset) {
  return parentOffset - child._bounds._offsetHeight / 2;
}
function _alignChildColumnEnd(child, parentOffset) {
  return parentOffset - child._bounds._offsetWidth / 2;
}
function _alignChildColumnStart(child, parentOffset) {
  return -parentOffset + child._bounds._offsetWidth / 2;
}
function _processColumn(element, childAligner) {
  const AXIS_TARGET = element._bounds._innerWidth / 2;
  element._children._boxes.forEach((child) => {
    element._layouter._childrenPos[child.id].x = childAligner(child, AXIS_TARGET);
  });
}
function _processRow(element, childAligner) {
  const AXIS_TARGET = element._bounds._innerHeight / 2;
  element._children._boxes.forEach((child) => {
    element._layouter._childrenPos[child.id].y = childAligner(child, AXIS_TARGET);
  });
}
var FlexDirectionPropertyBox = class extends FlexDirectionProperty {
  constructor() {
    super();
    this._allowsInherit = false;
    this._needsUpdate = true;
    this._offset = 0;
    this._reverse = 1;
    this._process = this.emptyStrategyLogic;
  }
  computeOutputValue(element) {
    this._value = this._inheritedInput;
    switch (this._value) {
      case "row":
        this._process = FlexDirectionPropertyBox_processRow;
        break;
      case "row-reverse":
        this._process = _processRowReverse;
        break;
      case "column":
        this._process = FlexDirectionPropertyBox_processColumn;
        break;
      case "column-reverse":
        this._process = _processColumnReverse;
        break;
    }
    if (!element._justifyContent._needsUpdate)
      element._justifyContent.computeOutputValue(element);
    if (!element._alignItems._needsUpdate)
      element._alignItems.computeOutputValue(element);
    this._needsProcess = true;
  }
  process(element) {
    switch (this._value) {
      case "row":
        this._offset = -element._bounds._innerWidth / 2;
        break;
      case "row-reverse":
        this._offset = element._bounds._innerWidth / 2;
        break;
      case "column":
        this._offset = element._bounds._innerHeight / 2;
        break;
      case "column-reverse":
        this._offset = -element._bounds._innerHeight / 2;
        break;
    }
    this._reverse = -Math.sign(this._offset);
    if (this._reverse === 0) {
      this._reverse = 1;
    }
    this._process(element);
    element._justifyContent._needsProcess = true;
    element._layouter._needsProcess = true;
  }
};
function FlexDirectionPropertyBox_processRow(element) {
  let accu = element._flexDirection._offset;
  const REVERSE = element._flexDirection._reverse;
  const boxes = element._children._boxes;
  for (let i = 0; i < boxes.length; i++) {
    const child = boxes[i];
    const CHILD_ID = child.id;
    const CHILD_SIZE = child._bounds._offsetWidth;
    accu += child._margin._value.w * REVERSE;
    const position = element._layouter._childrenPos[CHILD_ID];
    position.x = accu + CHILD_SIZE / 2 * REVERSE;
    position.y = 0;
    accu += REVERSE * (CHILD_SIZE + child._margin._value.y);
  }
}
function _processRowReverse(element) {
  let accu = element._flexDirection._offset;
  const REVERSE = element._flexDirection._reverse;
  const boxes = element._children._boxes;
  for (let i = 0; i < boxes.length; i++) {
    const child = boxes[i];
    const CHILD_ID = child.id;
    const CHILD_SIZE = child._bounds._offsetWidth;
    accu += child._margin._value.y * REVERSE;
    const position = element._layouter._childrenPos[CHILD_ID];
    position.x = accu + CHILD_SIZE / 2 * REVERSE;
    position.y = 0;
    accu += (CHILD_SIZE + child._margin._value.w) * REVERSE;
  }
}
function FlexDirectionPropertyBox_processColumn(element) {
  let accu = element._flexDirection._offset;
  const REVERSE = element._flexDirection._reverse;
  const boxes = element._children._boxes;
  for (let i = 0; i < boxes.length; i++) {
    const child = boxes[i];
    const CHILD_ID = child.id;
    const CHILD_SIZE = child._bounds._offsetHeight;
    accu += child._margin._value.x * REVERSE;
    const position = element._layouter._childrenPos[CHILD_ID];
    position.x = 0;
    position.y = accu + CHILD_SIZE / 2 * REVERSE;
    accu += (CHILD_SIZE + child._margin._value.z) * REVERSE;
  }
}
function _processColumnReverse(element) {
  let accu = element._flexDirection._offset;
  const REVERSE = element._flexDirection._reverse;
  const boxes = element._children._boxes;
  for (let i = 0; i < boxes.length; i++) {
    const child = boxes[i];
    const CHILD_ID = child.id;
    const CHILD_SIZE = child._bounds._offsetHeight;
    accu += child._margin._value.z * REVERSE;
    const position = element._layouter._childrenPos[CHILD_ID];
    position.x = 0;
    position.y = accu + CHILD_SIZE / 2 * REVERSE;
    accu += (CHILD_SIZE + child._margin._value.x) * REVERSE;
  }
}
var JustifyContentPropertyBox = class extends JustifyContentProperty {
  constructor(defaultValue) {
    super("justifyContent", defaultValue, true);
    this._allowsInherit = false;
    this._needsUpdate = true;
    this._computeOffset = this.emptyStrategyLogic;
    this._computeMargin = this.emptyStrategyLogic;
    this._process = this.emptyStrategyLogic;
  }
  computeOutputValue(element) {
    this._value = this._inheritedInput;
    switch (element._flexDirection._value) {
      case "column-reverse":
      case "column":
        this._process = _column.bind(this);
        break;
      case "row-reverse":
      case "row":
        this._process = _row.bind(this);
        break;
    }
    switch (this._value) {
      case "end":
        this._computeOffset = _justificationOffsetEnd;
        this._computeMargin = _justificationMargin;
        break;
      case "center":
        this._computeOffset = _justificationOffsetCenter;
        this._computeMargin = _justificationMargin;
        break;
      case "start":
        this._computeOffset = _justificationOffset;
        this._computeMargin = _justificationMargin;
        break;
      case "space-between":
        this._computeOffset = _justificationOffset;
        this._computeMargin = _justificationMarginSpaceBetween;
        break;
      case "space-around":
        this._computeOffset = _justificationOffset;
        this._computeMargin = _justificationMarginSpaceAround;
        break;
      case "space-evenly":
        this._computeOffset = _justificationOffset;
        this._computeMargin = _justificationMarginSpaceEvenly;
        break;
    }
    element._flexDirection._needsProcess = true;
  }
  process(element) {
    this._process(element);
    element._alignItems._needsProcess = true;
  }
};
function _row(element) {
  const startPos = element._flexDirection._offset;
  const { usedDirectionSpace, remainingSpace } = _rowRemainingSpace(element);
  const axisOffset = startPos * 2 - usedDirectionSpace * Math.sign(startPos);
  const justificationOffset = this._computeOffset(axisOffset);
  const justificationMargins = this._computeMargin(element, remainingSpace, element._flexDirection._reverse);
  element._children._boxes.forEach((child, childIndex) => {
    element._layouter._childrenPos[child.id].x -= justificationOffset - justificationMargins[childIndex];
  });
}
function _column(element) {
  const startPos = element._flexDirection._offset;
  const { usedDirectionSpace, remainingSpace } = _columnRemainingSpace(element);
  const axisOffset = startPos * 2 - usedDirectionSpace * Math.sign(startPos);
  const justificationOffset = this._computeOffset(axisOffset);
  const justificationMargins = this._computeMargin(element, remainingSpace, element._flexDirection._reverse);
  element._children._boxes.forEach((child, childIndex) => {
    element._layouter._childrenPos[child.id].y -= justificationOffset - justificationMargins[childIndex];
  });
}
function _rowRemainingSpace(element) {
  const usedDirectionSpace = element._bounds._computeChildrenSideWidth(element);
  return { usedDirectionSpace, remainingSpace: element._bounds._innerWidth - usedDirectionSpace };
}
function _columnRemainingSpace(element) {
  const usedDirectionSpace = element._bounds._computeChildrenSideHeight(element);
  return { usedDirectionSpace, remainingSpace: element._bounds._innerHeight - usedDirectionSpace };
}
function _justificationOffset(axisOffset) {
  return 0;
}
function _justificationOffsetEnd(axisOffset) {
  return axisOffset;
}
function _justificationOffsetCenter(axisOffset) {
  return axisOffset / 2;
}
function _justificationMargin(element, availableSpace = 0, reverse = 1) {
  return Array(element._children._boxes.length).fill(0);
}
function _justificationMarginSpaceBetween(element, availableSpace = 0, reverse = 1) {
  const boxes = element._children._boxes;
  const length = boxes.length;
  const justificationMargins = Array(length).fill(0);
  if (availableSpace > 0) {
    if (length > 1) {
      const margin = availableSpace / (length - 1) * reverse;
      justificationMargins[0] = 0;
      for (let i = 1; i < length; i++) {
        justificationMargins[i] = margin * i;
      }
    }
  }
  return justificationMargins;
}
function _justificationMarginSpaceEvenly(element, availableSpace = 0, reverse = 1) {
  const boxes = element._children._boxes;
  const length = boxes.length;
  const justificationMargins = Array(length).fill(0);
  if (availableSpace > 0) {
    const margin = availableSpace / (length + 1) * reverse;
    for (let i = 0; i < length; i++) {
      justificationMargins[i] = margin * (i + 1);
    }
  }
  return justificationMargins;
}
function _justificationMarginSpaceAround(element, availableSpace = 0, reverse = 1) {
  const boxes = element._children._boxes;
  const length = boxes.length;
  const justificationMargins = Array(length).fill(0);
  if (availableSpace > 0) {
    const margin = availableSpace / length * reverse;
    const start = margin / 2;
    justificationMargins[0] = start;
    for (let i = 1; i < length; i++) {
      justificationMargins[i] = start + margin * i;
    }
  }
  return justificationMargins;
}
var _hiddenMaterial;
var Frame = class extends external_three_namespaceObject.Mesh {
  /**
   *
   * @param {MeshUIBaseElement} element
   */
  constructor(element) {
    const slice2 = element.slice;
    const slices = {};
    let w = 1, h = 1;
    if (slice2) {
      const segments = 1;
      w = slice2.width ? slice2.width : 1;
      h = slice2.height ? slice2.height : 1;
      if (slice2.top) {
        if (slice2.left) {
          const topLeftGeometry = new external_three_namespaceObject.PlaneGeometry(slice2.left * w, slice2.top * h, segments, segments);
          _sliceUV(topLeftGeometry, 0, slice2.left, 1 - slice2.top, 1);
          topLeftGeometry.translate(slice2.left * w / 2, -slice2.top * h / 2, 0);
          slices.topLeft = topLeftGeometry;
        }
        const topGeometry = new external_three_namespaceObject.PlaneGeometry(1, slice2.top * h, segments, segments);
        _sliceUV(topGeometry, slice2.left, 1 - slice2.right, 1 - slice2.top, 1);
        topGeometry.translate(0, -slice2.top * h / 2, 0);
        slices.top = topGeometry;
        if (slice2.right) {
          const topRightGeometry = new external_three_namespaceObject.PlaneGeometry(slice2.right * w, slice2.top * h, segments, segments);
          _sliceUV(topRightGeometry, 1 - slice2.right, 1, 1 - slice2.top, 1);
          topRightGeometry.translate(-slice2.right * w / 2, -slice2.top * h / 2, 0);
          slices.topRight = topRightGeometry;
        }
      }
      if (slice2.left) {
        const leftGeometry = new external_three_namespaceObject.PlaneGeometry(slice2.left * w, 1, segments, segments);
        _sliceUV(leftGeometry, 0, slice2.left, slice2.bottom, 1 - slice2.top);
        leftGeometry.translate(slice2.left * w / 2, 0, 0);
        slices.left = leftGeometry;
      }
      const center = new external_three_namespaceObject.PlaneGeometry(1, 1, segments, segments);
      _sliceUV(center, slice2.left, 1 - slice2.right, slice2.bottom, 1 - slice2.top);
      slices.middle = center;
      if (slice2.right) {
        const rightGeometry = new external_three_namespaceObject.PlaneGeometry(slice2.right * w, 1, segments, segments);
        _sliceUV(rightGeometry, 1 - slice2.right, 1, slice2.bottom, 1 - slice2.top);
        rightGeometry.translate(-slice2.right * w / 2, 0, 0);
        slices.right = rightGeometry;
      }
      if (slice2.bottom) {
        if (slice2.left) {
          const bottomLeftGeometry = new external_three_namespaceObject.PlaneGeometry(slice2.left * w, slice2.bottom * h, segments, segments);
          _sliceUV(bottomLeftGeometry, 0, slice2.left, 0, slice2.bottom);
          bottomLeftGeometry.translate(slice2.left * w / 2, slice2.bottom * h / 2, 0);
          slices.bottomLeft = bottomLeftGeometry;
        }
        const bottomGeometry = new external_three_namespaceObject.PlaneGeometry(1, slice2.bottom * h, segments, segments);
        _sliceUV(bottomGeometry, slice2.left, 1 - slice2.right, 0, slice2.bottom);
        bottomGeometry.translate(0, slice2.bottom * h / 2, 0);
        slices.bottom = bottomGeometry;
        if (slice2.right) {
          const bottomRightGeometry = new external_three_namespaceObject.PlaneGeometry(slice2.right * w, slice2.bottom * h, segments, segments);
          _sliceUV(bottomRightGeometry, 1 - slice2.right, 1, 0, slice2.bottom);
          bottomRightGeometry.translate(-slice2.right * w / 2, slice2.bottom * h / 2, 0);
          slices.bottomRight = bottomRightGeometry;
        }
      }
    }
    let material = element.backgroundMaterial;
    if (slice2) {
      if (!_hiddenMaterial)
        _hiddenMaterial = new external_three_namespaceObject.MeshBasicMaterial({ alphaTest: 1.1 });
      material = _hiddenMaterial;
    }
    const geometry = new external_three_namespaceObject.PlaneGeometry(1, 1, element._segments.value, element._segments.value);
    const uvB = new external_three_namespaceObject.BufferAttribute(new Float32Array(geometry.getAttribute("uv").array), 2);
    geometry.setAttribute("uvB", uvB).name = "uvB";
    super(geometry, material);
    this.name = "UIBackgroundBox";
    if (slice2) {
      this.slice = slice2;
      this.sliceSize = new external_three_namespaceObject.Vector3(1 - (slice2.left + slice2.right), 1 - (slice2.bottom + slice2.top), 1);
      this.sliceScale = new external_three_namespaceObject.Vector3(w, h, 1);
      for (const sliceSide in slices) {
        const slice3 = new external_three_namespaceObject.Mesh(slices[sliceSide], element.backgroundMaterial);
        this.add(slice3);
        slices[sliceSide] = slice3;
      }
      this.updateScale = this.updateScaleSlice;
      this.slices = slices;
    }
  }
  updateScale() {
  }
  updateScaleSlice() {
    const s = new external_three_namespaceObject.Vector3(1, 1, 1);
    if (this.scale.x < (this.slice.left + this.slice.right) * this.sliceScale.x) {
      s.x = this.scale.x / ((this.slice.left + this.slice.right) * this.sliceScale.x);
    }
    if (this.scale.y < (this.slice.bottom + this.slice.top) * this.sliceScale.y) {
      s.y = this.scale.y / ((this.slice.bottom + this.slice.top) * this.sliceScale.y);
    }
    for (const sliceSide in this.slices) {
      const slice2 = this.slices[sliceSide];
      slice2.scale.set(1 / this.scale.x, 1 / this.scale.y, this.scale.y);
      const offset = _slicePositions[sliceSide];
      for (const offsetAxis in offset) {
        slice2.position[offsetAxis] = this.scale[offsetAxis] * offset[offsetAxis] * slice2.scale[offsetAxis];
      }
      const scale = _sliceScales[sliceSide];
      if (scale) {
        if (scale.x) {
          slice2.position.x = this.sliceScale.x * 0.5 * (this.slice.left - this.slice.right) * (1 / this.scale.x);
        }
        if (scale.y) {
          slice2.position.y = this.sliceScale.y * 0.5 * (this.slice.bottom - this.slice.top) * (1 / this.scale.y);
        }
        for (const scaleAxis in scale) {
          const natural = this.scale[scaleAxis] - (1 - this.sliceSize[scaleAxis]) * this.sliceScale[scaleAxis];
          slice2.scale[scaleAxis] = Math.max(0, natural * (1 / this.scale[scaleAxis]));
        }
      }
    }
    if (s.x !== 1) {
      this.slices.left.scale.x *= s.x;
      this.slices.topLeft.scale.x *= s.x;
      this.slices.bottomLeft.scale.x *= s.x;
      this.slices.right.scale.x *= s.x;
      this.slices.topRight.scale.x *= s.x;
      this.slices.bottomRight.scale.x *= s.x;
    }
    if (s.y !== 1) {
      this.slices.top.scale.y *= s.y;
      this.slices.topLeft.scale.y *= s.y;
      this.slices.topRight.scale.y *= s.y;
      this.slices.bottom.scale.y *= s.y;
      this.slices.bottomLeft.scale.y *= s.y;
      this.slices.bottomRight.scale.y *= s.y;
    }
  }
};
var _slicePositions = {
  topLeft: { x: -0.5, y: 0.5 },
  top: { y: 0.5 },
  topRight: { x: 0.5, y: 0.5 },
  left: { x: -0.5 },
  right: { x: 0.5 },
  bottomLeft: { x: -0.5, y: -0.5 },
  bottom: { y: -0.5 },
  bottomRight: { x: 0.5, y: -0.5 }
};
var _sliceScales = {
  top: { x: 1 },
  left: { y: 1 },
  right: { y: 1 },
  bottom: { x: 1 },
  middle: { x: 1, y: 1 }
};
function _sliceUV(geometry, uMin, uMax, vMin, vMax) {
  const uLength = uMax - uMin;
  const vLength = vMax - vMin;
  const uvAttribute = geometry.attributes.uv;
  for (let i = 0; i < uvAttribute.count; i++) {
    const u2 = uvAttribute.getX(i);
    const v4 = uvAttribute.getY(i);
    uvAttribute.setXY(i, uMin + u2 * uLength, vMin + v4 * vLength);
  }
  const uvB = new external_three_namespaceObject.BufferAttribute(new Float32Array(geometry.getAttribute("uv").array), 2);
  geometry.setAttribute("uvB", uvB).name = "uvB";
}
var RendererPropertyBox = class extends BaseProperty {
  constructor() {
    super("renderer");
  }
  render(element) {
    if (!element._backgroundMesh) {
      element.setBackgroundMesh(new Frame(element));
    }
    element.performAfterUpdate();
  }
};
var PositionPropertyBox = class extends PositionProperty {
  constructor() {
    super("position");
  }
  update(element, out) {
    super.update(element, out);
    this._needsProcess = true;
  }
};
var AutoSizePropertyBox = class extends BaseProperty {
  constructor() {
    super("autosize");
    this._needsProcess = true;
  }
  process(element) {
    if (element._width._auto)
      _processAutoWidth(element);
    if (element._height._auto)
      _processAutoHeight(element);
    const stretch = element._alignItems._value === "stretch";
    const stretchChildrenWidth = stretch && element._flexDirection._value.indexOf("column") !== -1;
    const stretchChildrenHeight = stretch && !stretchChildrenWidth;
    for (const box2 of element._children._boxes) {
      if (box2._width._auto && stretchChildrenWidth || box2._width._relative) {
        box2._bounds.setReferenceWidth(box2, element._bounds._innerWidth);
      }
      if (box2._height._auto && stretchChildrenHeight || box2._height._relative) {
        box2._bounds.setReferenceHeight(box2, element._bounds._innerHeight);
      }
    }
  }
};
function _processAutoWidth(element) {
  element._bounds.setChildrenWidth(element, _computeAutoWidth(element));
}
function _processAutoHeight(element) {
  element._bounds.setChildrenHeight(element, _computeAutoHeight(element));
}
function _computeAutoHeight(element) {
  switch (element._flexDirection._value) {
    case "row":
    case "row-reverse":
      return _computeHighestChildHeight(element);
    case "column":
    case "column-reverse":
      return AutoSizePropertyBox_computeChildrenSideHeight(element);
  }
}
function _computeAutoWidth(element) {
  switch (element._flexDirection._value) {
    case "row":
    case "row-reverse":
      return AutoSizePropertyBox_computeChildrenSideWidth(element);
    case "column":
    case "column-reverse":
      return _computeHighestChildWidth(element);
  }
}
function AutoSizePropertyBox_computeChildrenSideWidth(element) {
  let sumWidth = 0;
  for (const box2 of element._children._boxes) {
    if (box2._position._value !== "static")
      continue;
    const margin = box2._margin._value;
    const width = box2._bounds._offsetWidth + margin.y + margin.w;
    sumWidth += width;
  }
  return sumWidth;
}
function AutoSizePropertyBox_computeChildrenSideHeight(element) {
  let sumHeight = 0;
  for (const box2 of element._children._boxes) {
    if (box2._position._value !== "static")
      continue;
    const margin = box2._margin._value;
    const height = box2._bounds._offsetHeight + margin.x + margin.z;
    sumHeight += height;
  }
  return sumHeight;
}
function _computeHighestChildWidth(element) {
  let maxWidth = 0;
  for (const box2 of element._children._boxes) {
    if (box2._position._value !== "static")
      continue;
    const margin = box2._margin._value;
    const width = box2._bounds._offsetWidth + margin.y + margin.w;
    if (width > maxWidth)
      maxWidth = width;
  }
  return maxWidth;
}
function _computeHighestChildHeight(element) {
  let maxHeight = 0;
  for (const box2 of element._children._boxes) {
    if (box2._position._value !== "static")
      continue;
    const margin = box2._margin._value;
    const height = box2._bounds._offsetHeight + margin.x + margin.z;
    if (height > maxHeight)
      maxHeight = height;
  }
  return maxHeight;
}
var BoxElement = class extends MeshUIBaseElement {
  /**
   *
   * @param {import('./../../core/elements/MeshUIBaseElement').Properties} properties
   * @param {import('./../../core/elements/MeshUIBaseElement').Options} values
   */
  constructor(properties, values) {
    BoxElement.definePropertiesValues(properties, values);
    super(properties, values);
    BoxElement.init(this);
  }
  /**
   * When the backgroundMesh has been set, bind properties
   * @override
   */
  bindBackgroundMeshProperties() {
    this._bounds._size = this._backgroundMesh.scale;
    this._bounds._needsProcess = true;
  }
  /**
   * When the backgroundMesh has been unset, unbind properties
   * @override
   */
  unbindBackgroundMeshProperties() {
    this._bounds._size = new external_three_namespaceObject.Vector3(1, 1, 1);
    this._bounds._needsProcess = true;
  }
  /**
   *
   * @param {import('./../../core/elements/MeshUIBaseElement').Properties} properties
   * @param {import('./../../core/elements/MeshUIBaseElement').Options} values
   */
  static definePropertiesValues(properties, values) {
    if (!properties.children)
      properties.children = ChildrenBox;
    if (!properties.bounds)
      properties.bounds = BoundsBox;
    if (!properties.flexDirection)
      properties.flexDirection = FlexDirectionPropertyBox;
    if (!properties.justifyContent)
      properties.justifyContent = JustifyContentPropertyBox;
    if (!properties.alignItems)
      properties.alignItems = AlignItemsPropertyBox;
    if (!properties.position)
      properties.position = PositionPropertyBox;
    if (!properties.autoSize)
      properties.autoSize = AutoSizePropertyBox;
    if (!properties.renderer)
      properties.renderer = RendererPropertyBox;
    if (!values.fontSide)
      values.fontSide = 0;
    if (!values.invertAlpha)
      values.invertAlpha = false;
    if (!values.fontCastShadow)
      values.fontCastShadow = false;
    if (!values.fontReceiveShadow)
      values.fontReceiveShadow = false;
    if (!values.backgroundCastShadow)
      values.backgroundCastShadow = false;
    if (!values.backgroundReceiveShadow)
      values.backgroundReceiveShadow = false;
  }
  /**
   *
   * @param {MeshUIBaseElement} element
   */
  static init(element) {
    Object.defineProperties(
      element,
      {
        isBox: {
          configurable: false,
          enumerable: true,
          value: true
        }
      }
    );
    element.backgroundMaterial = new FrameMaterial();
    element._renderer.render(element);
    element._backgroundMesh.visible = false;
  }
};
var Line2 = class extends Array {
  /**
   *
   * @param {Inline[]} items
   */
  constructor(...items) {
    super(...items);
    this.width = 0;
    this.lineBase = 0;
    this.lineHeight = 0;
    this.y = 0;
  }
};
var BoxLayouter = class extends BaseProperty {
  constructor() {
    super("layouter", null, false);
    this._needsUpdate = true;
    this._childrenPos = {};
  }
  /* eslint-disable no-unused-vars */
  /**
   * Updated when :
   * 	- New child added
   * 	- Child removed
   * 	- Child position changed
   * 	- Child visibility changed
   * 	- ...?
   * 	@override
   */
  update(element, out) {
    this._childrenPos = {};
    for (const uiBoxElement of element._children._boxes) {
      if (uiBoxElement._position._value === "static") {
        this._childrenPos[uiBoxElement.id] = uiBoxElement.position;
      }
    }
  }
  /**
   *
   * @override
   */
  /* eslint-disable no-unused-vars */
  process(element) {
  }
};
var BlockElement = class extends BoxElement {
  /**
   *
   * @param {import('./../../core/elements/MeshUIBaseElement').Options} [values={}]
   */
  constructor(values = {}) {
    const properties = {};
    BlockElement.definePropertiesValues(properties, values);
    super(properties, values);
    BlockElement.init(this);
  }
  /* eslint-disable no-unused-vars */
  /**
   * A Block Element can only contains box elements
   * @override
   * @param {...Object3D} object
   * @return {this}
   */
  add(object) {
    const validChildren = [];
    for (let i = 0; i < arguments.length; i++) {
      const argument = arguments[i];
      if (!argument.isUI || argument.isBox) {
        validChildren.push(argument);
      } else {
        console.warn("Block element can only contain Box elements.", argument);
      }
    }
    return super.add(...validChildren);
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @param {import('./../../core/elements/MeshUIBaseElement').Properties} properties
   * @param {import('./../../core/elements/MeshUIBaseElement').Options} values
   */
  static definePropertiesValues(properties, values) {
    properties.layouter = BoxLayouter;
  }
  /**
   *
   * @param {MeshUIBaseElement} element
   */
  static init(element) {
    Object.defineProperties(
      element,
      {
        isBlock: {
          configurable: false,
          enumerable: true,
          value: true
        }
      }
    );
  }
};
var TextContentInline = class extends BaseProperty {
  constructor() {
    super("textContent", null, false);
  }
  /* eslint-disable no-unused-vars */
  update(element, out) {
    element._glyphs._needsUpdate = true;
    element._whiteSpace._needsProcess = true;
  }
};
var InlinesProperty = class extends BaseProperty {
  constructor() {
    super("inlines", null, false);
    this._value = null;
  }
  process(element) {
    this._value = element._glyphs._value.map((glyphBox) => glyphBox.asInlineGlyph());
    if (this._value.length) {
      this._value[0].paddingLeft = element._padding._value.w;
      this._value[0].marginLeft = element._margin._value.w;
      const lastIndex = this._value.length - 1;
      this._value[lastIndex].paddingRight = element._padding._value.y;
      this._value[lastIndex].marginRight = element._margin._value.y;
    }
    element._fontSize._needsProcess = true;
    element._lineBreak._needsProcess = true;
    element._fontKerning._needsProcess = true;
    element._layouter._needsProcess = true;
  }
  /**
   *
   * @return {Array.<Inline>}
   */
  get value() {
    return this._value;
  }
};
var GlyphsProperty = class extends BaseProperty {
  constructor() {
    super("glyphs", null, false);
    this._needsUpdate = false;
    this._value = null;
  }
  process(element) {
    if (!element._font._fontVariant)
      return;
    if (!element._font._fontVariant.isReady)
      return;
    this._value = element._whiteSpace._whiteSpacedContent.split("").map((char) => element._font._fontVariant.getTypographicGlyph(char));
    if (this._value)
      element._inlines._needsProcess = true;
  }
  /**
   *
   * @return {Array.<TypographicGlyph>}
   */
  get value() {
    return this._value;
  }
};
var ColorProperty = class extends StyleColorProperty {
  constructor() {
    super("color", "inherit", false);
    this.output = this._outputValue;
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @param {MeshUIBaseElement} element
   */
  computeOutputValue(element) {
    if (this._input === "inherit") {
      this._value.set(this.getInheritedInput(element));
    } else {
      this._value.set(this._input);
    }
  }
};
var LineBreakProperty = class extends BaseProperty {
  constructor(defaultValue = "- ,.:?!\n") {
    super("lineBreak", defaultValue, true);
    this._newLineBreakability = null;
  }
  /* eslint-disable no-unused-vars */
  update(element, out) {
    this._needsProcess = true;
  }
  process(element) {
    const newLineBreakability = element._whiteSpace._newLineBreakability;
    if (!element._inlines._value)
      return;
    for (let i = 0; i < element._inlines._value.length; i++) {
      const inline = element._inlines._value[i];
      const char = inline.char;
      let lineBreak = null;
      if (char !== void 0) {
        if (newLineBreakability !== "nowrap") {
          if (this._value.includes(char) || char.match(/\s/g))
            lineBreak = "possible";
        }
        if (char.match(/\n/g)) {
          lineBreak = newLineBreakability;
        }
      }
      inline.lineBreak = lineBreak;
    }
  }
  /**
   * @override
   * @return {string}
   */
  get value() {
    return this._value;
  }
};
var InlineLayouter = class extends BaseProperty {
  constructor() {
    super("layouter", null, false);
    this._value = null;
  }
  /* eslint-disable no-unused-vars */
  update(element, out) {
    this._value = element._parent.find((p) => {
      return p.isUI && p.isText;
    });
    this._needsProcess = true;
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @override
   */
  process(element) {
    if (this._value) {
      this._value._layouter._needsProcess = true;
    }
  }
};
var BackgroundColorPropertyInline = class extends StyleColorProperty {
  constructor(defaultValue) {
    super("backgroundColor", defaultValue, false);
    this._allowsInherit = false;
    this._input = 0;
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @param {MeshUIBaseElement} element
   */
  computeOutputValue(element) {
    if (this._input === "inherit") {
      this._value.set(this.getInheritedInput(element));
    } else {
      this._value.set(this._input);
    }
  }
};
var FontStylePropertyInline = class extends FontStyleProperty {
  constructor() {
    super();
    this._allowsInherit = false;
    this.computeOutputValue = this._computeFromInherited;
  }
};
var FontWeightPropertyInline = class extends FontWeightProperty {
  constructor() {
    super();
  }
  computeOutputValue(element) {
    this._value = uniformizeFontWeight(this.getInheritedInput(element));
  }
};
var FontFamilyPropertyInline = class extends FontFamilyProperty {
  constructor() {
    super("fontFamily", "inherit", true);
    this._input = "inherit";
    this._needsUpdate = true;
    this._allowsInherit = false;
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @param element
   */
  computeOutputValue(element) {
    let abstractedInput = this._inheritedInput;
    if (abstractedInput === "inherit") {
      abstractedInput = this.getInheritedInput(element);
    }
    if (abstractedInput instanceof FontFamily) {
      this._value = abstractedInput;
      element._font._needsUpdate = true;
    } else if (typeof abstractedInput === "string") {
      const fontFamily = font_FontLibrary.getFontFamily(abstractedInput);
      if (fontFamily) {
        this._value = fontFamily;
        element._font._needsUpdate = true;
      } else {
        console.warn(`(.style) fontFamily, the font '${abstractedInput}' is not registered. Aborted.`);
      }
    } else {
      console.warn(`(.style) fontFamily requires a registered fontFamily instance, or the id of a registered fontFamily.`);
      console.warn(`If you want to set a specific font, please use .font property instead.`);
    }
  }
  /**
   * @override
   * @return {any|FontFamilyPropertyInline|null}
   */
  get value() {
    return this._value;
  }
};
var WhiteSpacePropertyInline = class extends WhiteSpaceProperty {
  constructor() {
    super();
    this._allowsInherit = false;
    this.computeOutputValue = this._computeFromInherited;
    this._whiteSpacedContent = "";
    this._stringCollapser = this.emptyStrategyLogic;
    this._inlineCollapser = this.emptyStrategyLogic;
    this._inlineWrapper = this.emptyStrategyLogic;
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @param element
   * @private
   */
  _computeFromInherited(element) {
    super._computeFromInherited(element);
    this._newLineBreakability = _newlineBreakability(this._value);
    switch (this._value) {
      case "nowrap":
      case "normal":
        this._stringCollapser = _stringCollapseNewLine;
        break;
      case "pre-line":
        this._stringCollapser = _stringCollapseMultipleSpace;
        break;
      default:
        this._stringCollapser = _stringCollapseNothing;
    }
    switch (this._value) {
      case "pre-line":
      case "nowrap":
      case "normal":
        this._inlineCollapser = _inlineCollapseMultiple;
        break;
      case "pre-wrap":
        this._inlineCollapser = _inlineCollapseSingle;
        break;
      default:
        this._inlineCollapser = _inlineCollapseNothing;
    }
    switch (this._value) {
      case "pre-line":
      case "pre-wrap":
      case "normal":
        this._inlineWrapper = _lineBreakerWrapText;
        break;
      case "pre":
        this._inlineWrapper = _lineBreakerLineBreakOnly;
        break;
      default:
        this._inlineWrapper = _lineBreakerNoWrap;
    }
    this._needsProcess = true;
  }
  process(element) {
    if (element.isInline && !element.isInlineBlock) {
      this._whiteSpacedContent = this._stringCollapser(element._textContent._value);
      element._glyphs._needsProcess = true;
    }
  }
};
var WHITE_CHARS = { "	": "	", "\n": "\n", "\r": "\r", " ": " " };
var _newlineBreakability = function(whiteSpace) {
  switch (whiteSpace) {
    case "pre":
    case "pre-wrap":
    case "pre-line":
      return "mandatory";
  }
  return null;
};
function _stringCollapseNewLine(textContentValue) {
  return _stringCollapseMultipleSpace(textContentValue.replace(/\n/g, " "));
}
function _stringCollapseMultipleSpace(textContentValue) {
  return textContentValue.replace(/[ ]{2,}/g, " ");
}
function _stringCollapseNothing(textContentValue) {
  return textContentValue;
}
function _lineBreakerWrapText(inlines, i, lastInlineOffset, options) {
  const inline = inlines[i];
  if (inline.lineBreak === "mandatory")
    return true;
  if (lastInlineOffset + inline.xadvance + inline.xoffset + inline.kerning > options.INNER_WIDTH)
    return true;
  const nextBreak = _distanceToNextBreak(inlines, i, options);
  return _shouldFriendlyBreak(inlines[i - 1], lastInlineOffset, nextBreak, options);
}
function _lineBreakerLineBreakOnly(inlines, i, lastInlineOffset, options) {
  return inlines[i].lineBreak === "mandatory";
}
function _lineBreakerNoWrap() {
  return false;
}
function _inlineCollapseSingle(line) {
  if (!line[0])
    return 0;
  const firstInline = line[0];
  const lastInline = line[line.length - 1];
  if (firstInline.char && firstInline.char === "\n" && line.length > 1) {
    _collapseLeftInlines([firstInline], line[1]);
  }
  if (lastInline.char && lastInline.char === "\n" && line.length > 1) {
    _collapseRightInlines([lastInline], line[line.length - 2]);
  }
  return firstInline.offsetX;
}
function _inlineCollapseMultiple(line) {
  if (!line[0])
    return 0;
  let inlinesToCollapse = [];
  let collapsingTarget;
  for (let i = 0; i < line.length; i++) {
    const inline = line[i];
    if (inline.char && WHITE_CHARS[inline.char] && line.length > i) {
      inlinesToCollapse.push(inline);
      collapsingTarget = line[i + 1];
      continue;
    }
    break;
  }
  _collapseLeftInlines(inlinesToCollapse, collapsingTarget);
  inlinesToCollapse = [];
  collapsingTarget = null;
  for (let i = line.length - 1; i > 0; i--) {
    const inline = line[i];
    if (inline.char && WHITE_CHARS[inline.char] && i > 0) {
      inlinesToCollapse.push(inline);
      collapsingTarget = line[i - 1];
      continue;
    }
    break;
  }
  _collapseRightInlines(inlinesToCollapse, collapsingTarget);
  return line[0].offsetX;
}
function _inlineCollapseNothing(line) {
  if (!line[0])
    return 0;
  return line[0].offsetX;
}
function _collapseRightInlines(inlines, targetInline) {
  if (!targetInline)
    return;
  for (let i = 0; i < inlines.length; i++) {
    const inline = inlines[i];
    inline.fontFactor = 0;
    inline.offsetX = targetInline.offsetX + targetInline.cumulativeWidth;
    inline.cumulativeWidth = 0;
  }
}
function _collapseLeftInlines(inlines, targetInline) {
  if (!targetInline)
    return;
  for (let i = 0; i < inlines.length; i++) {
    const inline = inlines[i];
    inline.fontFactor = 0;
    inline.offsetX = targetInline.offsetX;
    inline.cumulativeWidth = 0;
  }
}
function _distanceToNextBreak(inlines, currentIdx, options, accu) {
  accu = accu || 0;
  if (!inlines[currentIdx])
    return accu;
  const inline = inlines[currentIdx];
  if (inline.lineBreak)
    return accu + inline.xadvance;
  return _distanceToNextBreak(
    inlines,
    currentIdx + 1,
    options,
    accu + inline.xadvance + inline.xoffset + inline.kerning + options.LETTERSPACING
  );
}
function _shouldFriendlyBreak(prevChar, lastInlineOffset, nextBreak, options) {
  if (!prevChar || !prevChar.char)
    return false;
  if (lastInlineOffset + nextBreak < options.INNER_WIDTH)
    return false;
  return options.BREAKON.indexOf(prevChar.char) > -1;
}
var LetterSpacingPropertyInline = class extends LetterSpacingProperty {
  constructor() {
    super();
    this._input = "inherit";
    this._allowsInherit = false;
    this.computeOutputValue = this._computeFromInherited;
  }
  _computeFromInherited(element) {
    super._computeFromInherited(element);
    element._fontSize._needsProcess = true;
    element._layouter._needsProcess = true;
  }
};
var FontSizePropertyInline = class extends SubStyleProperty {
  constructor() {
    super("fontSize", "inherit", true);
    this._allowsInherit = false;
  }
  computeOutputValue(element) {
    this._value = this._inheritedInput;
    if (element._font._fontVariant) {
      element._bounds._needsProcess = true;
      element._layouter._needsProcess = true;
    }
  }
  process(element) {
    if (!element._font._fontVariant || !element._font._fontVariant.isReady)
      return;
    const SCALE_MULT = this._value / element._font._fontVariant.typographic.size;
    const inlines = element._inlines._value;
    for (let i = 0; i < inlines.length; i++) {
      const inline = inlines[i];
      inline.resetOffsets();
      inline.fontSize = this._value;
      inline.fontFactor = SCALE_MULT;
    }
  }
  /**
   *
   * @return {number}
   */
  get value() {
    return this._value;
  }
};
var SegmentsPropertyText = class extends SegmentsProperty {
  constructor() {
    super("segments", 1, false);
    this._notInheritedValue = void 0;
  }
  /* eslint-disable no-unused-vars */
  update(element, out) {
    this._notInheritedValue = this._value;
    if (this._notInheritedValue === "inherit") {
      this._notInheritedValue = this.getInheritedInput(element);
    }
    element._layouter._needsUpdate = true;
  }
  /**
   *
   * @param {number|"inherit"} v
   */
  set value(v4) {
    if (this._value === v4)
      return;
    this._value = v4;
    this._needsUpdate = true;
  }
  /**
   *
   * @override
   * @return {number}
   */
  get value() {
    if (this._value === "inherit")
      return this._notInheritedValue;
    return this._value;
  }
};
var SegmentsPropertyInline = class extends SegmentsPropertyText {
  constructor() {
    super();
    this._value = "inherit";
  }
};
var FontKerningPropertyInline = class extends FontKerningProperty {
  constructor() {
    super();
    this._allowsInherit = false;
    this.computeOutputValue = this._computeFromInherited;
  }
  _computeFromInherited(element) {
    super._computeFromInherited(element);
    element._parent._value._layouter._needsProcess = false;
  }
  process(element) {
    if (this._value !== "none") {
      const whiteSpacedContent = element._whiteSpace._whiteSpacedContent;
      const inlines = element._inlines._value;
      for (let i = 1; i < inlines.length; i++) {
        const glyphPair = whiteSpacedContent[i - 1] + whiteSpacedContent[i];
        inlines[i].kerning = element._font._fontVariant.getKerningAmount(glyphPair);
      }
    }
  }
};
var ChildrenInline = class extends BaseProperty {
  constructor() {
    super("children", null, false);
    this._uis = [];
  }
  /* eslint-disable no-unused-vars */
  /**
   * Update requested when :
   * 		- New child has been added
   * 		- Existing child has been removed
   *
   * @param element
   * @param out
   */
  update(element, out) {
  }
  /* eslint-disable no-unused-vars */
  /**
   * Process when :
   * 		- Existing child visibility changed
   *
   * @param element
   */
  process(element) {
  }
  /* eslint-disable no-unused-vars */
  _compute(element) {
  }
  /**
   *
   */
  dispose() {
  }
};
function mergeGeometries(geometries, useGroups = false) {
  const isIndexed = geometries[0].index !== null;
  const attributesUsed = new Set(Object.keys(geometries[0].attributes));
  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));
  const attributes = {};
  const morphAttributes = {};
  const morphTargetsRelative = geometries[0].morphTargetsRelative;
  const mergedGeometry = new external_three_namespaceObject.BufferGeometry();
  let offset = 0;
  for (let i = 0; i < geometries.length; ++i) {
    const geometry = geometries[i];
    let attributesCount = 0;
    if (isIndexed !== (geometry.index !== null)) {
      console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");
      return null;
    }
    for (const name in geometry.attributes) {
      if (!attributesUsed.has(name)) {
        console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + '. All geometries must have compatible attributes; make sure "' + name + '" attribute exists among all geometries, or in none of them.');
        return null;
      }
      if (attributes[name] === void 0)
        attributes[name] = [];
      attributes[name].push(geometry.attributes[name]);
      attributesCount++;
    }
    if (attributesCount !== attributesUsed.size) {
      console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". Make sure all geometries have the same number of attributes.");
      return null;
    }
    if (morphTargetsRelative !== geometry.morphTargetsRelative) {
      console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". .morphTargetsRelative must be consistent throughout all geometries.");
      return null;
    }
    for (const name in geometry.morphAttributes) {
      if (!morphAttributesUsed.has(name)) {
        console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ".  .morphAttributes must be consistent throughout all geometries.");
        return null;
      }
      if (morphAttributes[name] === void 0)
        morphAttributes[name] = [];
      morphAttributes[name].push(geometry.morphAttributes[name]);
    }
    if (useGroups) {
      let count;
      if (isIndexed) {
        count = geometry.index.count;
      } else if (geometry.attributes.position !== void 0) {
        count = geometry.attributes.position.count;
      } else {
        console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". The geometry must have either an index or a position attribute");
        return null;
      }
      mergedGeometry.addGroup(offset, count, i);
      offset += count;
    }
  }
  if (isIndexed) {
    let indexOffset = 0;
    const mergedIndex = [];
    for (let i = 0; i < geometries.length; ++i) {
      const index = geometries[i].index;
      for (let j = 0; j < index.count; ++j) {
        mergedIndex.push(index.getX(j) + indexOffset);
      }
      indexOffset += geometries[i].attributes.position.count;
    }
    mergedGeometry.setIndex(mergedIndex);
  }
  for (const name in attributes) {
    const mergedAttribute = mergeAttributes(attributes[name]);
    if (!mergedAttribute) {
      console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + name + " attribute.");
      return null;
    }
    mergedGeometry.setAttribute(name, mergedAttribute);
  }
  for (const name in morphAttributes) {
    const numMorphTargets = morphAttributes[name][0].length;
    if (numMorphTargets === 0)
      break;
    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};
    mergedGeometry.morphAttributes[name] = [];
    for (let i = 0; i < numMorphTargets; ++i) {
      const morphAttributesToMerge = [];
      for (let j = 0; j < morphAttributes[name].length; ++j) {
        morphAttributesToMerge.push(morphAttributes[name][j][i]);
      }
      const mergedMorphAttribute = mergeAttributes(morphAttributesToMerge);
      if (!mergedMorphAttribute) {
        console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + name + " morphAttribute.");
        return null;
      }
      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);
    }
  }
  return mergedGeometry;
}
function mergeAttributes(attributes) {
  let TypedArray;
  let itemSize;
  let normalized;
  let gpuType = -1;
  let arrayLength = 0;
  for (let i = 0; i < attributes.length; ++i) {
    const attribute = attributes[i];
    if (TypedArray === void 0)
      TypedArray = attribute.array.constructor;
    if (TypedArray !== attribute.array.constructor) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.");
      return null;
    }
    if (itemSize === void 0)
      itemSize = attribute.itemSize;
    if (itemSize !== attribute.itemSize) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.");
      return null;
    }
    if (normalized === void 0)
      normalized = attribute.normalized;
    if (normalized !== attribute.normalized) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.");
      return null;
    }
    if (gpuType === -1)
      gpuType = attribute.gpuType;
    if (gpuType !== attribute.gpuType) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.");
      return null;
    }
    arrayLength += attribute.count * itemSize;
  }
  const array = new TypedArray(arrayLength);
  const result = new external_three_namespaceObject.BufferAttribute(array, itemSize, normalized);
  let offset = 0;
  for (let i = 0; i < attributes.length; ++i) {
    const attribute = attributes[i];
    if (attribute.isInterleavedBufferAttribute) {
      const tupleOffset = offset / itemSize;
      for (let j = 0, l = attribute.count; j < l; j++) {
        for (let c2 = 0; c2 < itemSize; c2++) {
          const value = attribute.getComponent(j, c2);
          result.setComponent(j + tupleOffset, c2, value);
        }
      }
    } else {
      array.set(attribute.array, offset);
    }
    offset += attribute.count * itemSize;
  }
  if (gpuType !== void 0) {
    result.gpuType = gpuType;
  }
  return result;
}
var RendererPropertyInline = class extends BaseProperty {
  constructor() {
    super("renderer");
  }
  render(element) {
    if (!element._inlines._value || !element._inlines._value.length)
      return;
    const charactersAsGeometries = element._inlines._value.map(
      (inline) => element._font._fontVariant.getGeometricGlyph(inline, element).translate(inline.offsetX, inline.offsetY, 0)
    );
    const mergedGeom = mergeGeometries(charactersAsGeometries);
    element.setFontMesh(new external_three_namespaceObject.Mesh(mergedGeom, element.fontMaterial));
    element._fontMesh.renderOrder = Infinity;
  }
};
var TextAlignPropertyInline = class extends TextAlignProperty {
  constructor() {
    super();
    this._allowsInherit = false;
    this._needsUpdate = false;
  }
  /* eslint-disable no-unused-vars */
  computeOutputValue(element) {
    this._value = this._inheritedInput;
    element._layouter._needsProcess = true;
  }
};
var InlineElement = class extends MeshUIBaseElement {
  /**
   *
   * @param {import('./../../core/elements/MeshUIBaseElement').Options} [values={}]
   */
  constructor(values = {}) {
    const properties = {};
    InlineElement.definePropertiesValues(properties, values);
    super(properties, values);
    __publicField(this, "_rebuildParentUI", () => {
      super._rebuildParentUI();
      this._layouter._needsUpdate = true;
    });
    InlineElement.init(this);
  }
  /* eslint-disable no-unused-vars */
  /**
   * A Text Element can only contains inline elements
   * @override
   * @param {...Object3D} object
   * @return {this}
   */
  add(object) {
    const validChildren = [];
    for (let i = 0; i < arguments.length; i++) {
      const argument = arguments[i];
      if (!argument.isUI || argument.isInline) {
        validChildren.push(argument);
        argument.position.z = 5e-3;
      } else {
        console.warn("Block element can only contain Box elements.", argument);
      }
    }
    return super.add(...validChildren);
  }
  set textContent(value) {
    this._textContent.value = value;
  }
  get textContent() {
    return this._textContent._value;
  }
  set invertAlpha(value) {
    this._invertAlpha.value = value;
  }
  get invertAlpha() {
    return this._invertAlpha._value;
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @param {import('./../../core/elements/MeshUIBaseElement').Properties} properties
   * @param {import('./../../core/elements/MeshUIBaseElement').Options} values
   */
  static definePropertiesValues(properties, values) {
    if (!properties.children)
      properties.children = ChildrenInline;
    if (!properties.textContent)
      properties.textContent = TextContentInline;
    if (!properties.glyphs)
      properties.glyphs = GlyphsProperty;
    if (!properties.inlines)
      properties.inlines = InlinesProperty;
    if (!properties.layouter)
      properties.layouter = InlineLayouter;
    if (!properties.renderer)
      properties.renderer = RendererPropertyInline;
    if (!properties.fontFamily)
      properties.fontFamily = FontFamilyPropertyInline;
    if (!properties.fontWeight)
      properties.fontWeight = FontWeightPropertyInline;
    if (!properties.fontStyle)
      properties.fontStyle = FontStylePropertyInline;
    if (!properties.fontSize)
      properties.fontSize = FontSizePropertyInline;
    if (!properties.color)
      properties.color = ColorProperty;
    if (!properties.backgroundColor)
      properties.backgroundColor = BackgroundColorPropertyInline;
    if (!properties.lineBreak)
      properties.lineBreak = LineBreakProperty;
    if (!properties.letterSpacing)
      properties.letterSpacing = LetterSpacingPropertyInline;
    if (!properties.whiteSpace)
      properties.whiteSpace = WhiteSpacePropertyInline;
    if (!properties.segments)
      properties.segments = SegmentsPropertyInline;
    if (!properties.textAlign)
      properties.textAlign = TextAlignPropertyInline;
    if (!properties.fontKerning)
      properties.fontKerning = FontKerningPropertyInline;
  }
  /**
   *
   * @param {MeshUIBaseElement} element
   */
  static init(element) {
    Object.defineProperties(
      element,
      {
        isInline: {
          configurable: false,
          enumerable: true,
          value: true
        }
      }
    );
  }
};
var TextContentText = class extends TextContentEmpty {
  constructor() {
    super("textContent", null, false);
    this._needsUpdate = false;
  }
  set value(value) {
    if (this._value !== value) {
      this._value = value;
      this._needsUpdate = true;
    }
  }
  /* eslint-disable no-unused-vars */
  update(element, out) {
    this._needsUpdate = false;
    for (let i = element.children.length - 1; i >= 0; i--) {
      const child = element.children[i];
      if (child.isUI) {
        element.remove(child);
        child.clear();
      }
    }
    element._children._uis = [];
    if (this._value)
      element.add(new InlineElement({ name: "anonymousInline", textContent: this._value }));
  }
};
var Lines = class extends Array {
  /**
   *
   * @param {Line} items
   */
  constructor(...items) {
    super(...items);
    this.width = 0;
    this.height = 0;
  }
};
var TextLayouter = class extends BaseProperty {
  constructor() {
    super("layouter", null, false);
    this._value = null;
  }
  /* eslint-disable no-unused-vars */
  update(element, out) {
  }
  /**
   *
   * @override
   */
  process(element) {
    let INNER_WIDTH = element._width._value;
    if (element._width._auto) {
      INNER_WIDTH = Infinity;
    } else {
      INNER_WIDTH = element._bounds._innerWidth;
    }
    const INTERLINE = element._lineHeight._value;
    const lines = new Lines(new Line2());
    let lastInlineOffset = 0;
    element._children._inlines.forEach((inlineElement) => {
      if (!inlineElement._inlines.value)
        return;
      this._resetInlines(inlineElement);
      const FONTSIZE = inlineElement._fontSize._value;
      const LETTERSPACING = inlineElement._letterSpacing._value * FONTSIZE;
      const WHITESPACE = inlineElement._whiteSpace._value;
      const BREAKON = inlineElement._lineBreak._value;
      const whiteSpaceOptions = {
        WHITESPACE,
        LETTERSPACING,
        BREAKON,
        INNER_WIDTH
      };
      const inlineWrapper = inlineElement._whiteSpace._inlineWrapper;
      lastInlineOffset += inlineElement._margin._value.w + inlineElement._padding._value.w;
      inlineElement._inlines.value.forEach((inline, i, inlines) => {
        const line = lines[lines.length - 1];
        const shouldBreak = inlineWrapper(inlines, i, lastInlineOffset, whiteSpaceOptions);
        if (shouldBreak) {
          lines.push(new Line2(inline));
          inline.offsetX = inline.xoffset;
          if (inline.width === 0) {
            lastInlineOffset = 0;
            return;
          }
          inline.cumulativeWidth = inline.xadvance + LETTERSPACING;
          lastInlineOffset = inline.cumulativeWidth;
          return;
        }
        lines[lines.length - 1].push(inline);
        inline.offsetX = lastInlineOffset + inline.xoffset + inline.kerning;
        inline.cumulativeWidth = inline.xadvance + inline.kerning + LETTERSPACING;
        lastInlineOffset += inline.cumulativeWidth;
        if (line.length - 1 === 1) {
          if (line[line.length - 2].width === 0) {
            inline.offsetX -= inline.xoffset;
            lastInlineOffset -= inline.xoffset;
          }
        }
      });
      lastInlineOffset += inlineElement._margin._value.y + inlineElement._padding._value.y;
    });
    const inlineCollapser = element._whiteSpace._inlineCollapser;
    let width = 0, height = 0, lineOffsetY = 0;
    lines.forEach((line, i) => {
      const whiteSpaceOffset = inlineCollapser(line);
      let lineHeight = 0;
      let lineBase = 0;
      line.forEach((inline) => {
        lineHeight = Math.max(lineHeight, inline.lineHeight);
        lineBase = Math.max(lineBase, inline.lineBase);
        inline.offsetX -= whiteSpaceOffset;
      });
      line.lineHeight = lineHeight;
      line.lineBase = lineBase;
      if (i === 0) {
        lineOffsetY = -(lineHeight * INTERLINE - lineHeight) * 0.5;
      } else {
        lineOffsetY -= lines[i - 1].lineHeight * INTERLINE;
      }
      line.y = lineOffsetY;
      line.x = 0;
      line.forEach((inline) => {
        inline.offsetY = lineOffsetY - inline.anchor;
        if (inline.lineHeight < line.lineHeight) {
          inline.offsetY -= line.lineBase - inline.lineBase;
        }
      });
      height += line.lineHeight * INTERLINE;
      line.width = 0;
      if (line[0]) {
        const lastInline = line[line.length - 1];
        line.width = lastInline.offsetX + lastInline.cumulativeWidth + lastInline.paddingRight + lastInline.marginRight + line[0].offsetX;
        width = Math.max(width, line.width);
      }
    });
    lines.height = height;
    lines.width = width;
    this._value = lines;
    if (INNER_WIDTH === Infinity) {
      element._bounds.setChildrenWidth(element, lines.width);
    }
    if (element._height._auto) {
      element._bounds.setChildrenHeight(element, lines.height);
    }
    const parent = element._parent._value;
    if (parent) {
      parent._autoSize._needsProcess = true;
      parent._flexDirection._needsProcess = true;
    }
    element._inlineJustificator._needsProcess = true;
    element._textAlign._needsProcess = true;
    element._overflow._needsUpdate = true;
  }
  /**
   *
   * @param inlineElement
   * @protected
   */
  _resetInlines(inlineElement) {
    inlineElement._fontSize.process(inlineElement);
  }
};
var TextAlignPropertyText = class extends TextAlignProperty {
  constructor() {
    super();
    this._allowsInherit = false;
    this._needsUpdate = true;
  }
  /* eslint-disable no-unused-vars */
  computeOutputValue(element) {
    this._value = this._inheritedInput;
    this._needsProcess = true;
  }
  process(element) {
    _process(element);
    element._renderer._needsRender = true;
  }
};
function _process(element) {
  const lines = element._layouter._value;
  const ALIGNMENT = element._textAlign._value;
  const INNER_WIDTH = element._bounds._innerWidth;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const offsetX = _computeLineOffset(element, line, i === lines.length - 1);
    const padding = element._padding._value;
    const border = element._borderWidth._value;
    const paddingAmount = (-padding.w + padding.y) / 2 + (-border.w + border.y) / 2;
    line.x += offsetX;
    for (let j = 0; j < line.length; j++) {
      line[j].offsetX += offsetX - paddingAmount;
    }
  }
  if (ALIGNMENT.indexOf("justify") === 0) {
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (ALIGNMENT.indexOf("-") !== -1 && i === lines.length - 1)
        return;
      const REMAINING_SPACE = INNER_WIDTH - line.width;
      if (REMAINING_SPACE <= 0)
        return;
      let validSpaces = 0;
      for (let j = 1; j < line.length - 1; j++) {
        validSpaces += line[j].char === " " ? 1 : 0;
      }
      const additionalSpace = REMAINING_SPACE / validSpaces;
      let inverter = 1;
      if (ALIGNMENT === "justify-right") {
        line.reverse();
        inverter = -1;
      }
      let incrementalOffsetX = 0;
      for (let j = 1; j <= line.length - 1; j++) {
        const inlineCharacter = line[j];
        inlineCharacter.offsetX += incrementalOffsetX * inverter;
        incrementalOffsetX += inlineCharacter.char === " " ? additionalSpace : 0;
      }
      if (ALIGNMENT === "justify-right") {
        line.reverse();
      }
    }
  }
}
function _computeLineOffset(element, line, lastLine) {
  switch (element._textAlign._value) {
    case "justify-left":
    case "justify":
    case "left":
      return -element._bounds._innerWidth / 2;
    case "justify-right":
    case "right":
      return -line.width + element._bounds._innerWidth / 2;
    case "center":
      return -line.width / 2;
    case "justify-center":
      if (lastLine) {
        return -line.width / 2;
      }
      return -element._bounds._innerWidth / 2;
    default:
      console.warn(`textAlign: '${element._textAlign._value}' is not valid`);
  }
}
var FlexDirectionPropertyText = class extends FlexDirectionProperty {
  constructor() {
    super();
    this._value = this._input = "column";
    this._allowsInherit = false;
    this._needsUpdate = true;
  }
  /* eslint-disable no-unused-vars */
  computeOutputValue(element) {
    this._value = this._inheritedInput;
  }
};
var LineHeightPropertyInline = class extends LineHeightProperty {
  /**
   *
   */
  constructor() {
    super();
    this._allowsInherit = false;
    this.computeOutputValue = this._computeFromInherited;
  }
};
var FontKerningPropertyText = class extends FontKerningProperty {
  constructor() {
    super();
    this._value = this._input = this.getDefaultValue();
    this._allowsInherit = false;
    this.computeOutputValue = this._computeFromInherited;
  }
  _computeFromInherited(element) {
    super._computeFromInherited(element);
  }
};
var BoundsText = class extends BoundsBox {
  constructor() {
    super();
    this._innerWidth = Infinity;
    this._innerHeight = 0;
  }
};
var ChildrenText = class extends BaseProperty {
  constructor() {
    super("children", null, false);
    /**
     *
     * Sort children according to their .style.order property or fallback on children index
     *
     * @param {HTMLElementVR} a
     * @param {HTMLElementVR} b
     * @return {number}
     * @private
     */
    __publicField(this, "_sortOrder", (a, b) => {
      if (a._order._value < b._order._value)
        return -1;
      if (a._order._value > b._order._value)
        return 1;
      if (this._uis.indexOf(a) < this._uis.indexOf(b)) {
        return -1;
      }
      return 1;
    });
    this._uis = [];
    this._inlines = [];
    this._boxes = [];
  }
  /* eslint-disable no-unused-vars */
  /**
   * Update requested when :
   * 		- New child has been added
   * 		- Existing child has been removed
   *
   * @param element
   * @param out
   */
  update(element, out) {
    this._compute(element);
    this._needsProcess = true;
  }
  /**
   * Process when :
   * 		- Existing child visibility changed
   *
   * @param element
   */
  process(element) {
    this._compute(element);
    element._overflow._needsRender = true;
  }
  _compute(element) {
    this._uis = element.children.filter((child) => child.visible && child.isUI);
    this._inlines = this._uis.filter((child) => child.isInline).sort(this._sortOrder);
  }
  /**
   *
   */
  dispose() {
    this._inlines = null;
  }
};
var AutoSizePropertyText = class extends BaseProperty {
  constructor() {
    super("autosize");
  }
  process(element) {
    if (element._layouter._value && element._layouter._value.length) {
      const lines = element._layouter._value;
      const padding = element._padding._value;
      const border = element._borderWidth._value;
      if (element._width._auto) {
        element._bounds.setOffsetWidth(element, lines.width + padding.w + padding.y + border.w + border.y);
      }
      if (element._height._auto) {
        element._bounds.setOffsetHeight(element, lines.height + padding.x + padding.z + border.x + border.z);
      }
    }
  }
};
var RendererPropertyText = class extends RendererPropertyBox {
  constructor() {
    super("renderer");
    this._needsUpdate = false;
  }
  render(element) {
    super.render(element);
    for (const inlineElement of element._children._inlines) {
      inlineElement._renderer.render(inlineElement);
    }
    element.performAfterUpdate();
  }
};
var TextElement = class extends BoxElement {
  /**
   *
   * @param {import('./../../core/elements/MeshUIBaseElement').Options} [values={}]
   * @param [properties={}]
   */
  constructor(values = {}, properties = {}) {
    TextElement.definePropertiesValues(properties, values);
    super(properties, values);
    TextElement.init(this);
  }
  /* eslint-disable no-unused-vars */
  /**
   * A Text Element can only contains inline elements
   * @override
   * @param {...Object3D} object
   * @return {this}
   */
  add(object) {
    const validChildren = [];
    let updateLayout = false;
    for (let i = 0; i < arguments.length; i++) {
      const argument = arguments[i];
      if (!argument.isUI || argument.isInline) {
        if (argument.isInline) {
          updateLayout = true;
        }
        validChildren.push(argument);
      } else {
        console.warn("Block element can only contain Box elements.", argument);
      }
    }
    if (validChildren.length > 0) {
      super.add(...validChildren);
    }
    if (updateLayout) {
      this._children._needsUpdate = true;
      this._layouter._needsProcess = true;
    }
    return this;
  }
  set textContent(value) {
    this._textContent.value = value;
  }
  // Must redefine getter also, or issue.
  get textContent() {
    return super.textContent;
  }
  set invertAlpha(value) {
    this._invertAlpha.value = value;
  }
  get invertAlpha() {
    return this._invertAlpha._value;
  }
  get lines() {
    return this._layouter._value;
  }
  /**
   *
   * @param {import('./../../core/elements/MeshUIBaseElement').Properties} properties
   * @param {import('./../../core/elements/MeshUIBaseElement').Options} values
   */
  static definePropertiesValues(properties, values) {
    properties.flexDirection = FlexDirectionPropertyText;
    properties.justifyContent = JustifyContentProperty;
    properties.alignItems = AlignItemsProperty;
    properties.bounds = BoundsText;
    properties.autoSize = AutoSizePropertyText;
    properties.renderer = RendererPropertyText;
    if (!properties.children)
      properties.children = ChildrenText;
    if (!properties.textContent)
      properties.textContent = TextContentText;
    if (!properties.layouter)
      properties.layouter = TextLayouter;
    if (!properties.lineHeight)
      properties.lineHeight = LineHeightPropertyInline;
    if (!properties.textAlign)
      properties.textAlign = TextAlignPropertyText;
    if (!properties.whiteSpace)
      properties.whiteSpace = WhiteSpacePropertyInline;
    if (!properties.fontKerning)
      properties.fontKerning = FontKerningPropertyText;
    if (!properties.segments)
      properties.segments = SegmentsPropertyText;
    if (!values.width)
      values.width = "100%";
    if (!values.fontSide)
      values.fontSide = 0;
  }
  /**
   *
   * @param {MeshUIBaseElement} element
   */
  static init(element) {
    Object.defineProperties(
      element,
      {
        isText: {
          configurable: false,
          enumerable: true,
          value: true
        }
      }
    );
  }
};
var InlinesPropertyInlineBlock = class extends BaseProperty {
  constructor() {
    super("inlines", null, false);
    this._value = [];
  }
  process(element) {
    this._value[0].paddingLeft = element._padding._value.w;
    this._value[0].marginLeft = element._margin._value.w;
    const lastIndex = this._value.length - 1;
    this._value[lastIndex].paddingRight = element._padding._value.y;
    this._value[lastIndex].marginRight = element._margin._value.y;
  }
};
var RendererPropertyInlineBox = class extends BaseProperty {
  constructor() {
    super("renderer");
  }
  render(element) {
    if (!element._backgroundMesh) {
      element.setBackgroundMesh(new Frame(element));
    }
    element._backgroundMesh.position.x = element._inlines._value[0].offsetX + element._inlines._value[0].width / 2;
    element._backgroundMesh.position.y = element._inlines._value[0].offsetY + element._inlines._value[0].lineBase / 2;
    element._bounds.render(element);
  }
};
var BoundsInlineBlock = class extends BaseProperty {
  constructor() {
    super("bounds", null, false);
    this._size = new external_three_namespaceObject.Vector3(1, 1, 1);
    this._offsetWidth = 0;
    this._offsetHeight = 0;
    this._innerWidth = 0;
    this._innerHeight = 0;
  }
  /* eslint-disable no-unused-vars */
  update(element, out) {
    this.output(out);
    this._needsProcess = true;
  }
  process(element) {
    this._offsetWidth = this._innerWidth = element._inlines._value[0].width;
    this._offsetHeight = this._innerHeight = element._inlines._value[0].height;
    this._needsRender = true;
    element._borderWidth._needsRender = true;
    element._borderRadius._needsRender = true;
  }
  /* eslint-disable no-unused-vars */
  render(element) {
    this._size.x = this._offsetWidth;
    this._size.y = this._offsetHeight;
  }
  /**
   *
   * @param {Object.<string,any>} out
   */
  output(out) {
    out["size"] = this._size;
  }
};
var InlineBlockElement = class extends MeshUIBaseElement {
  /**
   *
   * @param {import('./../../core/elements/MeshUIBaseElement').Options} [values={}]
   */
  constructor(values = {}) {
    const properties = {};
    InlineBlockElement.definePropertiesValues(properties, values);
    super(properties, values);
    InlineBlockElement.init(this);
  }
  clear() {
    for (const inline of this._inlines._value) {
      inline.clear();
    }
    return super.clear();
  }
  /**
   * When the backgroundMesh has been set, bind properties
   * @override
   */
  bindBackgroundMeshProperties() {
    this._backgroundMesh.raycast = () => {
    };
    this._bounds._size = this._backgroundMesh.scale;
    this._bounds._needsUpdate = true;
  }
  /**
   * When the backgroundMesh has been unset, unbind properties
   * @override
   */
  unbindBackgroundMeshProperties() {
    this._bounds._size = new external_three_namespaceObject.Vector3(1, 1, 1);
    this._bounds._needsUpdate = true;
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @override
   * @param {...Object3D} object
   * @return {this}
   */
  add(object) {
    const validChildren = [];
    for (let i = 0; i < arguments.length; i++) {
      const argument = arguments[i];
      if (!argument.isUI) {
        validChildren.push(argument);
        argument.position.z = 5e-3;
      } else {
        console.warn("ThreeMeshUI::InlineBlockElement cannot contains UI Elements.", argument);
      }
    }
    return super.add(...validChildren);
  }
  /**
   *
   * @param {import('./../../core/elements/MeshUIBaseElement').Properties} properties
   * @param {import('./../../core/elements/MeshUIBaseElement').Options} values
   */
  static definePropertiesValues(properties, values) {
    if (!properties.children)
      properties.children = ChildrenInline;
    if (!properties.bounds)
      properties.bounds = BoundsInlineBlock;
    if (!properties.inlines)
      properties.inlines = InlinesPropertyInlineBlock;
    if (!properties.layouter)
      properties.layouter = InlineLayouter;
    if (!properties.renderer)
      properties.renderer = RendererPropertyInlineBox;
    if (!properties.fontFamily)
      properties.fontFamily = FontFamilyPropertyInline;
    if (!properties.fontWeight)
      properties.fontWeight = FontWeightPropertyInline;
    if (!properties.fontStyle)
      properties.fontStyle = FontStylePropertyInline;
    if (!properties.fontSize)
      properties.fontSize = FontSizePropertyInline;
    if (!properties.backgroundColor)
      properties.backgroundColor = BackgroundColorProperty;
    if (!properties.lineBreak)
      properties.lineBreak = LineBreakProperty;
    if (!properties.letterSpacing)
      properties.letterSpacing = LetterSpacingPropertyInline;
    if (!properties.whiteSpace)
      properties.whiteSpace = WhiteSpacePropertyInline;
    if (!properties.fontKerning)
      properties.fontKerning = FontKerningProperty;
    if (!values.backgroundSize)
      values.backgroundSize = "cover";
    if (!values.width)
      values.width = "100%";
    if (!values.height)
      values.height = "100%";
    if (!values.boxSizing)
      values.boxSizing = "border-box";
  }
  /**
   *
   * @param {MeshUIBaseElement} element
   */
  static init(element) {
    Object.defineProperties(
      element,
      {
        isInline: {
          configurable: false,
          enumerable: true,
          value: true
        },
        isInlineBlock: {
          configurable: false,
          enumerable: true,
          value: true
        }
      }
    );
    element._inlines._value = [new InlineBlockInline(element)];
    element.backgroundMaterial = new FrameMaterial();
    element._renderer.render(element);
  }
};
var InlineBlockInline = class extends Inline {
  /**
   *
   * @param {InlineBlockElement} parent
   */
  constructor(parent) {
    super();
    this._uiElement = parent;
  }
  /**
   * Rely on the parent for size computation
   * @override
   * @returns {number}
   */
  get xadvance() {
    const padding = this._uiElement._padding._value;
    const width = this._uiElement._width;
    if (width._relative) {
      return width._value * this._uiElement._fontSize.getInheritedInput(this._uiElement);
    }
    return padding.w + padding.y + width.value;
  }
  /**
   * Rely on the parent for size computation
   * @override
   * @returns {number}
   */
  get width() {
    const width = this._uiElement._width;
    if (width._relative) {
      return width._value * this._uiElement._fontSize.getInheritedInput(this._uiElement);
    }
    return width.value;
  }
  /**
   * Rely on the parent for size computation
   * @override
   * @returns {number}
   */
  get height() {
    const height = this._uiElement._height;
    if (height._relative) {
      return height._value * this._uiElement._fontSize.getInheritedInput(this._uiElement);
    }
    return height.value;
  }
  get anchor() {
    return this.height;
  }
  /**
   * Rely on the parent for size computation
   * @override
   * @returns {number}
   */
  get lineHeight() {
    const height = this._uiElement._height;
    if (height._relative) {
      return height._value * this._uiElement._fontSize.getInheritedInput(this._uiElement);
    }
    return height.value;
  }
  /**
   * Rely on the parent for size computation
   * @override
   * @returns {number}
   */
  get lineBase() {
    const height = this._uiElement._height;
    if (height._relative) {
      return height._value * this._uiElement._fontSize.getInheritedInput(this._uiElement);
    }
    return height.value;
  }
  /**
   *
   */
  clear() {
    this._uiElement = null;
  }
};
var Behavior = class {
  /**
   *
   * @param {MeshUIBaseElement} subject
   */
  constructor(subject) {
    this._subject = subject;
  }
  /**
   * @abstract
   */
  attach() {
    console.error(`Behavior::attach() - Is abstract and therefore should be overridden in ${this.constructor.name}`);
  }
  /**
   * @abstract
   * @returns {void}
   */
  act() {
    throw new Error(`Behavior::act() - Is abstract and therefore should be overridden in ${this.constructor.name}`);
  }
  /**
   * @abstract
   */
  detach() {
    console.error(`Behavior::detach() - Is abstract and therefore should be overridden in ${this.constructor.name}`);
  }
  /**
   *
   */
  clear() {
  }
};
var update = () => UpdateManager.update();
var ThreeMeshUI = {
  BaseProperty,
  Block: BlockElement,
  Text: TextElement,
  Inline: InlineElement,
  InlineBlock: InlineBlockElement,
  // Keyboard : KeyboardElement,
  MeshUIBaseElement,
  FontLibrary: font_FontLibrary,
  update,
  MSDFFontMaterialUtils,
  ShaderChunkUI,
  Behavior,
  FontVariant: font_FontVariant
};
if (typeof global !== "undefined")
  global.ThreeMeshUI = ThreeMeshUI;
var three_mesh_ui = ThreeMeshUI;
var __webpack_exports__BaseProperty = __webpack_exports__.ti;
var __webpack_exports__Behavior = __webpack_exports__.nS;
var __webpack_exports__Block = __webpack_exports__.eB;
var __webpack_exports__DefaultValues = __webpack_exports__.Yp;
var __webpack_exports__FontLibrary = __webpack_exports__.VB;
var __webpack_exports__FontVariant = __webpack_exports__.BC;
var __webpack_exports__InheritableProperty = __webpack_exports__.zN;
var __webpack_exports__Inline = __webpack_exports__.cV;
var __webpack_exports__InlineBlock = __webpack_exports__.hW;
var __webpack_exports__InlineGlyph = __webpack_exports__.k2;
var __webpack_exports__MSDFFontMaterialUtils = __webpack_exports__.K6;
var __webpack_exports__MaterialTransformers = __webpack_exports__.M7;
var __webpack_exports__MeshUIBaseElement = __webpack_exports__.ls;
var __webpack_exports__ShaderChunkUI = __webpack_exports__.Hi;
var __webpack_exports__Text = __webpack_exports__.EY;
var __webpack_exports__TypographicFont = __webpack_exports__.MR;
var __webpack_exports__TypographicGlyph = __webpack_exports__.zf;
var __webpack_exports__default = __webpack_exports__.Ay;
var __webpack_exports__update = __webpack_exports__.yo;

// node_modules/@needle-tools/engine/lib/engine/engine_math.js
var MathHelper = class {
  constructor() {
    __publicField(this, "Rad2Deg", 180 / Math.PI);
    __publicField(this, "Deg2Rad", Math.PI / 180);
    __publicField(this, "Epsilon", 1e-5);
  }
  random(arrayOrMin, max) {
    if (Array.isArray(arrayOrMin)) {
      if (arrayOrMin.length <= 0)
        return null;
      return arrayOrMin[Math.floor(Math.random() * arrayOrMin.length)];
    } else {
      if (arrayOrMin !== void 0 && max !== void 0) {
        return Math.random() * (max - arrayOrMin) + arrayOrMin;
      }
    }
    return Math.random();
  }
  randomVector3(target, min = 0, max = 1) {
    target.x = this.random(min, max);
    target.y = this.random(min, max);
    target.z = this.random(min, max);
  }
  clamp(value, min, max) {
    if (value < min) {
      return min;
    } else if (value > max) {
      return max;
    }
    return value;
  }
  clamp01(value) {
    return this.clamp(value, 0, 1);
  }
  lerp(value1, value2, t2) {
    t2 = t2 < 0 ? 0 : t2;
    t2 = t2 > 1 ? 1 : t2;
    return value1 + (value2 - value1) * t2;
  }
  inverseLerp(value1, value2, t2) {
    return (t2 - value1) / (value2 - value1);
  }
  remap(value, min1, max1, min2, max2) {
    return min2 + (max2 - min2) * (value - min1) / (max1 - min1);
  }
  moveTowards(value1, value2, amount) {
    value1 += amount;
    if (amount < 0 && value1 < value2)
      value1 = value2;
    else if (amount > 0 && value1 > value2)
      value1 = value2;
    return value1;
  }
  toDegrees(radians) {
    return radians * 180 / Math.PI;
  }
  toRadians(degrees) {
    return degrees * Math.PI / 180;
  }
  tan(radians) {
    return Math.tan(radians);
  }
  gammaToLinear(gamma) {
    return Math.pow(gamma, 2.2);
  }
  linearToGamma(linear) {
    return Math.pow(linear, 1 / 2.2);
  }
  approximately(v1, v22, epsilon = Number.EPSILON) {
    for (const key of vectorKeys) {
      const a = v1[key];
      const b = v22[key];
      if (a === void 0 || b === void 0)
        break;
      const diff = Math.abs(a - b);
      if (diff > epsilon) {
        return false;
      }
    }
    return true;
  }
  easeInOutCubic(x2) {
    return x2 < 0.5 ? 4 * x2 * x2 * x2 : 1 - Math.pow(-2 * x2 + 2, 3) / 2;
  }
};
var vectorKeys = ["x", "y", "z", "w"];
var Mathf = new MathHelper();
var LowPassFilter = class {
  constructor(alpha) {
    __publicField(this, "y");
    __publicField(this, "s");
    __publicField(this, "alpha", 0);
    this.setAlpha(alpha);
    this.y = null;
    this.s = null;
  }
  setAlpha(alpha) {
    if (alpha <= 0 || alpha > 1) {
      throw new Error();
    }
    this.alpha = alpha;
  }
  filter(value, alpha) {
    if (alpha) {
      this.setAlpha(alpha);
    }
    let s;
    if (!this.y) {
      s = value;
    } else {
      s = this.alpha * value + (1 - this.alpha) * this.s;
    }
    this.y = value;
    this.s = s;
    return s;
  }
  lastValue() {
    return this.y;
  }
  reset(value) {
    this.y = value;
    this.s = value;
  }
};
var OneEuroFilter = class {
  /** Create a new OneEuroFilter
   * @param freq - An estimate of the frequency in Hz of the signal (> 0), if timestamps are not available.
   * @param minCutOff - Min cutoff frequency in Hz (> 0). Lower values allow to remove more jitter.
   * @param beta - Parameter to reduce latency (> 0). Higher values make the filter react faster to changes.
   * @param dCutOff - Used to filter the derivates. 1 Hz by default. Change this parameter if you know what you are doing.
   */
  constructor(freq, minCutOff = 1, beta = 0, dCutOff = 1) {
    /**
     * An estimate of the frequency in Hz of the signal (> 0), if timestamps are not available.
     */
    __publicField(this, "freq");
    /**
     * Min cutoff frequency in Hz (> 0). Lower values allow to remove more jitter.
     */
    __publicField(this, "minCutOff");
    /**
     * Parameter to reduce latency (> 0). Higher values make the filter react faster to changes.
     */
    __publicField(this, "beta");
    /**
     * Used to filter the derivates. 1 Hz by default. Change this parameter if you know what you are doing.
     */
    __publicField(this, "dCutOff");
    /**
     * The low-pass filter for the signal.
     */
    __publicField(this, "x");
    /**
     * The low-pass filter for the derivates.
     */
    __publicField(this, "dx");
    /**
     * The last time the filter was called.
     */
    __publicField(this, "lasttime");
    if (freq <= 0 || minCutOff <= 0 || dCutOff <= 0) {
      throw new Error();
    }
    this.freq = freq;
    this.minCutOff = minCutOff;
    this.beta = beta;
    this.dCutOff = dCutOff;
    this.x = new LowPassFilter(this.alpha(this.minCutOff));
    this.dx = new LowPassFilter(this.alpha(this.dCutOff));
    this.lasttime = null;
  }
  alpha(cutOff) {
    const te2 = 1 / this.freq;
    const tau = 1 / (2 * Math.PI * cutOff);
    return 1 / (1 + tau / te2);
  }
  /** Filter your value: call with your value and the current timestamp (e.g. from this.context.time.time) */
  filter(x2, time = null) {
    if (this.lasttime && time) {
      this.freq = 1 / (time - this.lasttime);
    }
    this.lasttime = time;
    const prevX = this.x.lastValue();
    const dx = !prevX ? 0 : (x2 - prevX) * this.freq;
    const edx = this.dx.filter(dx, this.alpha(this.dCutOff));
    const cutOff = this.minCutOff + this.beta * Math.abs(edx);
    return this.x.filter(x2, this.alpha(cutOff));
  }
  reset(x2) {
    if (x2 != void 0)
      this.x.reset(x2);
    this.x.alpha = this.alpha(this.minCutOff);
    this.dx.alpha = this.alpha(this.dCutOff);
    this.lasttime = null;
  }
};
var OneEuroFilterXYZ = class {
  /** Create a new OneEuroFilter
   * @param freq - An estimate of the frequency in Hz of the signal (> 0), if timestamps are not available.
   * @param minCutOff - Min cutoff frequency in Hz (> 0). Lower values allow to remove more jitter.
   * @param beta - Parameter to reduce latency (> 0). Higher values make the filter react faster to changes.
   * @param dCutOff - Used to filter the derivates. 1 Hz by default. Change this parameter if you know what you are doing.
   */
  constructor(freq, minCutOff = 1, beta = 0, dCutOff = 1) {
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "z");
    this.x = new OneEuroFilter(freq, minCutOff, beta, dCutOff);
    this.y = new OneEuroFilter(freq, minCutOff, beta, dCutOff);
    this.z = new OneEuroFilter(freq, minCutOff, beta, dCutOff);
  }
  filter(value, target, time = null) {
    target.x = this.x.filter(value.x, time);
    target.y = this.y.filter(value.y, time);
    target.z = this.z.filter(value.z, time);
  }
  reset(value) {
    this.x.reset(value == null ? void 0 : value.x);
    this.y.reset(value == null ? void 0 : value.y);
    this.z.reset(value == null ? void 0 : value.z);
  }
};

// node_modules/three/examples/jsm/objects/GroundedSkybox.js
var GroundedSkybox = class extends Mesh {
  constructor(map, height, radius, resolution = 128) {
    if (height <= 0 || radius <= 0 || resolution <= 0) {
      throw new Error("GroundedSkybox height, radius, and resolution must be positive.");
    }
    const geometry = new SphereGeometry(radius, 2 * resolution, resolution);
    geometry.scale(1, 1, -1);
    const pos = geometry.getAttribute("position");
    const tmp = new Vector32();
    for (let i = 0; i < pos.count; ++i) {
      tmp.fromBufferAttribute(pos, i);
      if (tmp.y < 0) {
        const y1 = -height * 3 / 2;
        const f2 = tmp.y < y1 ? -height / tmp.y : 1 - tmp.y * tmp.y / (3 * y1 * y1);
        tmp.multiplyScalar(f2);
        tmp.toArray(pos.array, 3 * i);
      }
    }
    pos.needsUpdate = true;
    super(geometry, new MeshBasicMaterial({ map, depthWrite: false }));
  }
};

// node_modules/@needle-tools/engine/lib/engine/engine_camera.js
var $cameraController = "needle:cameraController";
function getCameraController(cam) {
  return cam[$cameraController];
}
function setCameraController(cam, cameraController, active) {
  if (active)
    cam[$cameraController] = cameraController;
  else {
    if (cam[$cameraController] === cameraController)
      cam[$cameraController] = null;
  }
}
var autofit = "needle:autofit";
function useForAutoFit(obj) {
  if (obj[autofit] === void 0)
    return true;
  return obj[autofit] !== false;
}
function setAutoFitEnabled(obj, enabled) {
  obj[autofit] = enabled;
}

// node_modules/@needle-tools/engine/lib/engine/engine_three_utils.js
function slerp(vec2, end, t2) {
  const len1 = vec2.length();
  const len2 = end.length();
  const targetLen = Mathf.lerp(len1, len2, t2);
  return vec2.lerp(end, t2).normalize().multiplyScalar(targetLen);
}
var _tempQuat = new Quaternion();
var flipYQuat = new Quaternion().setFromAxisAngle(new Vector32(0, 1, 0), Math.PI);
function lookAtInverse(obj, target) {
  obj.lookAt(target);
  obj.quaternion.multiply(flipYQuat);
}
function lookAtObject(object, target, keepUpDirection = true, copyTargetRotation = false) {
  if (object === target)
    return;
  _tempQuat.copy(object.quaternion);
  const lookTarget = getWorldPosition(target);
  const lookFrom = getWorldPosition(object);
  if (copyTargetRotation) {
    setWorldQuaternion(object, getWorldQuaternion(target));
    if (keepUpDirection) {
      const ypos = lookFrom.y;
      const forwardPoint = lookFrom.sub(getWorldDirection(object));
      forwardPoint.y = ypos;
      object.lookAt(forwardPoint);
      object.quaternion.multiply(flipYQuat);
    }
    if (Number.isNaN(object.quaternion.x)) {
      object.quaternion.copy(_tempQuat);
    }
    return;
  }
  if (keepUpDirection) {
    lookTarget.y = lookFrom.y;
  }
  object.lookAt(lookTarget);
  if (Number.isNaN(object.quaternion.x)) {
    object.quaternion.copy(_tempQuat);
  }
}
var _tempVecs = new CircularBuffer(() => new Vector32(), 100);
function getTempVector(vecOrX, y, z) {
  const vec2 = _tempVecs.get();
  vec2.set(0, 0, 0);
  if (vecOrX instanceof Vector32)
    vec2.copy(vecOrX);
  else if (Array.isArray(vecOrX))
    vec2.set(vecOrX[0], vecOrX[1], vecOrX[2]);
  else if (vecOrX instanceof DOMPointReadOnly)
    vec2.set(vecOrX.x, vecOrX.y, vecOrX.z);
  else {
    if (typeof vecOrX === "number") {
      vec2.x = vecOrX;
      vec2.y = y !== void 0 ? y : vec2.x;
      vec2.z = z !== void 0 ? z : vec2.x;
    } else if (typeof vecOrX === "object") {
      vec2.x = vecOrX.x;
      vec2.y = vecOrX.y;
      vec2.z = vecOrX.z;
    }
  }
  return vec2;
}
var _tempColors = new CircularBuffer(() => new Color(), 30);
function getTempColor(color2) {
  const col2 = _tempColors.get();
  if (color2)
    col2.copy(color2);
  else {
    col2.set(0, 0, 0);
  }
  return col2;
}
var _tempQuats = new CircularBuffer(() => new Quaternion(), 100);
function getTempQuaternion(value) {
  const val = _tempQuats.get();
  val.identity();
  if (value instanceof Quaternion)
    val.copy(value);
  else if (value instanceof DOMPointReadOnly)
    val.set(value.x, value.y, value.z, value.w);
  return val;
}
var _worldPositions = new CircularBuffer(() => new Vector32(), 100);
var _lastMatrixWorldUpdateKey = Symbol("lastMatrixWorldUpdateKey");
function getWorldPosition(obj, vec2 = null, updateParents = true) {
  const wp = vec2 ?? _worldPositions.get();
  if (!obj)
    return wp.set(0, 0, 0);
  if (!obj.parent)
    return wp.copy(obj.position);
  if (updateParents)
    obj.updateWorldMatrix(true, false);
  if (obj.matrixWorldNeedsUpdate && obj[_lastMatrixWorldUpdateKey] !== Date.now()) {
    obj[_lastMatrixWorldUpdateKey] = Date.now();
    obj.updateMatrixWorld();
  }
  wp.setFromMatrixPosition(obj.matrixWorld);
  return wp;
}
function setWorldPosition(obj, val) {
  if (!obj)
    return obj;
  const wp = _worldPositions.get();
  if (val !== wp)
    wp.copy(val);
  const obj2 = (obj == null ? void 0 : obj.parent) ?? obj;
  obj2.worldToLocal(wp);
  obj.position.set(wp.x, wp.y, wp.z);
  return obj;
}
function setWorldPositionXYZ(obj, x2, y, z) {
  const wp = _worldPositions.get();
  wp.set(x2, y, z);
  setWorldPosition(obj, wp);
  return obj;
}
var _worldQuaternions = new CircularBuffer(() => new Quaternion(), 100);
var _worldQuaternionBuffer = new Quaternion();
var _tempQuaternionBuffer2 = new Quaternion();
function getWorldQuaternion(obj, target = null) {
  if (!obj)
    return _worldQuaternions.get().identity();
  const quat = target ?? _worldQuaternions.get();
  if (!obj.parent)
    return quat.copy(obj.quaternion);
  obj.getWorldQuaternion(quat);
  return quat;
}
function setWorldQuaternion(obj, val) {
  if (!obj)
    return;
  if (val !== _worldQuaternionBuffer)
    _worldQuaternionBuffer.copy(val);
  const tempVec4 = _worldQuaternionBuffer;
  const parent = obj == null ? void 0 : obj.parent;
  parent == null ? void 0 : parent.getWorldQuaternion(_tempQuaternionBuffer2);
  _tempQuaternionBuffer2.invert();
  const q = _tempQuaternionBuffer2.multiply(tempVec4);
  obj.quaternion.set(q.x, q.y, q.z, q.w);
}
function setWorldQuaternionXYZW(obj, x2, y, z, w) {
  _worldQuaternionBuffer.set(x2, y, z, w);
  setWorldQuaternion(obj, _worldQuaternionBuffer);
}
var _worldScaleBuffer = new CircularBuffer(() => new Vector32(), 100);
var _worldScale = new Vector32();
function getWorldScale(obj, vec2 = null) {
  if (!vec2)
    vec2 = _worldScaleBuffer.get();
  if (!obj)
    return vec2.set(0, 0, 0);
  if (!obj.parent)
    return vec2.copy(obj.scale);
  obj.getWorldScale(vec2);
  return vec2;
}
function setWorldScale(obj, vec2) {
  if (!obj)
    return;
  if (!obj.parent) {
    obj.scale.copy(vec2);
    return;
  }
  const tempVec4 = _worldScale;
  const obj2 = obj.parent;
  obj2.getWorldScale(tempVec4);
  obj.scale.copy(vec2);
  obj.scale.divide(tempVec4);
}
var _forward = new Vector32();
var _forwardQuat = new Quaternion();
function forward(obj) {
  getWorldQuaternion(obj, _forwardQuat);
  return _forward.set(0, 0, 1).applyQuaternion(_forwardQuat);
}
var _worldDirectionBuffer = new CircularBuffer(() => new Vector32(), 100);
var _worldDirectionQuat = new Quaternion();
function getWorldDirection(obj, dir) {
  if (!dir)
    dir = _worldDirectionBuffer.get().set(0, 0, 1);
  getWorldQuaternion(obj, _worldDirectionQuat);
  return dir.applyQuaternion(_worldDirectionQuat);
}
var _worldEulerBuffer = new Euler();
var _worldEuler = new Euler();
var _worldRotation = new Vector32();
function getWorldEuler(obj) {
  const quat = _worldQuaternions.get();
  obj.getWorldQuaternion(quat);
  _worldEuler.setFromQuaternion(quat);
  return _worldEuler;
}
function setWorldEuler(obj, val) {
  const quat = _worldQuaternions.get();
  setWorldQuaternion(obj, quat.setFromEuler(val));
  ;
}
function getWorldRotation(obj) {
  const rot = getWorldEuler(obj);
  const wr = _worldRotation;
  wr.set(rot.x, rot.y, rot.z);
  wr.x = Mathf.toDegrees(wr.x);
  wr.y = Mathf.toDegrees(wr.y);
  wr.z = Mathf.toDegrees(wr.z);
  return wr;
}
function setWorldRotation(obj, val) {
  setWorldRotationXYZ(obj, val.x, val.y, val.z, true);
}
function setWorldRotationXYZ(obj, x2, y, z, degrees = true) {
  if (degrees) {
    x2 = Mathf.toRadians(x2);
    y = Mathf.toRadians(y);
    z = Mathf.toRadians(z);
  }
  _worldEulerBuffer.set(x2, y, z);
  _worldQuaternionBuffer.setFromEuler(_worldEulerBuffer);
  setWorldQuaternion(obj, _worldQuaternionBuffer);
}
function logHierarchy(root, collapsible = true) {
  if (!root)
    return;
  if (collapsible) {
    (function printGraph(obj) {
      console.groupCollapsed((obj.name ? obj.name : "(no name : " + obj.type + ")") + " %o", obj);
      obj.children.forEach(printGraph);
      console.groupEnd();
    })(root);
  } else {
    root.traverse(function(obj) {
      var s = "|___";
      var obj2 = obj;
      while (obj2.parent !== null) {
        s = "	" + s;
        obj2 = obj2.parent;
      }
      console.log(s + obj.name + " <" + obj.type + ">");
    });
  }
  ;
}
function getParentHierarchyPath(obj) {
  let path = (obj == null ? void 0 : obj.name) || "";
  if (!obj)
    return path;
  let parent = obj.parent;
  while (parent) {
    path = parent.name + "/" + path;
    parent = parent.parent;
  }
  return path;
}
function isAnimationAction(obj) {
  if (obj) {
    const act = obj;
    return act.blendMode !== void 0 && act.clampWhenFinished !== void 0 && act.enabled !== void 0 && act.fadeIn !== void 0 && act.getClip !== void 0;
  }
  return false;
}
var Graphics = class {
  /**
   * Create a blit material for copying textures
   */
  static createBlitMaterial(fragment) {
    return new ShaderMaterial({
      uniforms: { map: new Uniform$1(null) },
      vertexShader: this.vertex,
      fragmentShader: fragment
    });
  }
  /**
   * Copy a texture to a new texture
   * @param texture the texture to copy
   * @param blitMaterial the material to use for copying (optional)
   * @returns the newly created, copied texture
  */
  static copyTexture(texture, blitMaterial) {
    const material = blitMaterial ?? this.blipMaterial;
    material.uniforms.map.value = texture;
    material.needsUpdate = true;
    material.uniformsNeedUpdate = true;
    if (!this.blipMaterial) {
      this.blipMaterial = new ShaderMaterial({
        uniforms: { map: new Uniform$1(null) },
        vertexShader: this.vertex,
        fragmentShader: this.fragment
      });
    }
    const origVertexShader = material.vertexShader;
    material.vertexShader = this.vertex;
    if (!this.mesh)
      this.mesh = new Mesh(this.planeGeometry, this.blipMaterial);
    const mesh = this.mesh;
    mesh.material = material;
    mesh.frustumCulled = false;
    this.scene.children.length = 0;
    this.scene.add(mesh);
    if (!this.renderer)
      this.renderer = new WebGLRenderer({ antialias: false });
    this.renderer.setSize(texture.image.width, texture.image.height);
    this.renderer.clear();
    this.renderer.render(this.scene, this.perspectiveCam);
    const tex = new Texture(this.renderer.domElement);
    tex.name = "Copy";
    tex.needsUpdate = true;
    material.vertexShader = origVertexShader;
    return tex;
  }
  // static blit(src: Texture, target: Texture, blitMaterial?: ShaderMaterial) {
  //     let material = blitMaterial ?? this.blipMaterial;
  //     material.uniforms.map.value = src;
  //     this.mesh.material = material;
  //     this.mesh.frustumCulled = false;
  //     this.mesh.matrix.identity();
  //     this.scene.children.length = 0;
  //     this.scene.add(this.mesh);
  //     this.renderer.setSize(src.image.width, src.image.height);
  //     this.renderer.clear();
  //     this.renderer.render(this.scene, this.perspectiveCam);
  //     return new Texture(this.renderer.domElement);
  // }
  static textureToCanvas(texture, force) {
    if (!texture)
      return null;
    if (force === true || texture["isCompressedTexture"] === true) {
      texture = copyTexture(texture);
    }
    const image = texture.image;
    if (isImageBitmap(image)) {
      const canvas = document.createElement("canvas");
      canvas.width = image.width;
      canvas.height = image.height;
      const context = canvas.getContext("2d");
      if (!context) {
        console.error("Failed getting canvas 2d context");
        return null;
      }
      context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
      return canvas;
    }
    return null;
  }
};
__publicField(Graphics, "planeGeometry", new PlaneGeometry(2, 2, 1, 1));
__publicField(Graphics, "renderer");
__publicField(Graphics, "perspectiveCam", new PerspectiveCamera());
__publicField(Graphics, "scene", new Scene());
__publicField(Graphics, "vertex", `
    varying vec2 vUv;
    void main(){
        vUv = uv;
        gl_Position = vec4(position.xy * 1.0,0.,.999999);
    }`);
__publicField(Graphics, "fragment", `
    uniform sampler2D map; 
    varying vec2 vUv;
    void main(){ 
        vec2 uv = vUv;
        uv.y = 1.0 - uv.y;
        gl_FragColor = texture2D( map, uv);
        // gl_FragColor = vec4(uv.xy, 0, 1);
    }`);
__publicField(Graphics, "blipMaterial");
__publicField(Graphics, "mesh");
function copyTexture(texture) {
  return Graphics.copyTexture(texture);
}
function textureToCanvas(texture, force = false) {
  return Graphics.textureToCanvas(texture, force);
}
function isImageBitmap(image) {
  return typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== "undefined" && image instanceof OffscreenCanvas || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap;
}
function isMesh(obj) {
  const type = obj.type;
  return type === "Mesh" || type === "SkinnedMesh";
}
function setVisibleInCustomShadowRendering(obj, enabled) {
  if (enabled)
    obj["needle:rendercustomshadow"] = true;
  else {
    obj["needle:rendercustomshadow"] = false;
  }
}
function getVisibleInCustomShadowRendering(obj) {
  if (obj) {
    if (obj["needle:rendercustomshadow"] === true) {
      return true;
    } else if (obj["needle:rendercustomshadow"] == void 0) {
      return true;
    }
  }
  return false;
}
function getBoundingBox(objects, ignore = void 0, layers = void 0, result = void 0) {
  const box2 = result || new Box3();
  box2.makeEmpty();
  const emptyChildren = [];
  function expandByObjectRecursive(obj) {
    let allowExpanding = true;
    if (!obj.visible)
      return;
    if (useForAutoFit(obj) === false)
      return;
    if (obj.type === "TransformControlsGizmo" || obj.type === "TransformControlsPlane")
      return;
    if (obj instanceof Box3Helper)
      allowExpanding = false;
    if (obj instanceof GridHelper)
      allowExpanding = false;
    if (obj instanceof GroundedSkybox)
      allowExpanding = false;
    if (obj.isGizmo === true)
      allowExpanding = false;
    if (obj.material instanceof ShadowMaterial)
      allowExpanding = false;
    if (!isMesh(obj))
      allowExpanding = false;
    if (layers && obj.layers.test(layers) === false)
      allowExpanding = false;
    if (allowExpanding) {
      if (ignore && Array.isArray(ignore) && (ignore == null ? void 0 : ignore.includes(obj)))
        return;
      else if (typeof ignore === "function") {
        if (ignore(obj) === true)
          return;
      }
    }
    if (obj["isUI"] === true)
      return;
    if (allowExpanding) {
      const children = obj.children;
      obj.children = emptyChildren;
      const pos = obj.position;
      const scale = obj.scale;
      if (Number.isNaN(pos.x) || Number.isNaN(pos.y) || Number.isNaN(pos.z)) {
        console.warn(`Object "${obj.name}" has NaN values in position or scale.... will ignore it`, pos, scale);
        return;
      }
      box2.expandByObject(obj, true);
      obj.children = children;
    }
    for (const child of obj.children) {
      expandByObjectRecursive(child);
    }
  }
  let hasAnyObject = false;
  for (const object of objects) {
    if (!object)
      continue;
    hasAnyObject = true;
    object.updateMatrixWorld();
    expandByObjectRecursive(object);
  }
  if (!hasAnyObject) {
    console.warn("No objects to fit camera to...");
    return box2;
  }
  return box2;
}
function fitObjectIntoVolume(obj, volume, opts) {
  const box2 = getBoundingBox([obj], opts == null ? void 0 : opts.ignore);
  const boundsSize = new Vector32();
  box2.getSize(boundsSize);
  const boundsCenter = new Vector32();
  box2.getCenter(boundsCenter);
  const targetSize = new Vector32();
  volume.getSize(targetSize);
  const targetCenter = new Vector32();
  volume.getCenter(targetCenter);
  const scale = new Vector32();
  scale.set(targetSize.x / boundsSize.x, targetSize.y / boundsSize.y, targetSize.z / boundsSize.z);
  const minScale = Math.min(scale.x, scale.y, scale.z);
  const useScale = (opts == null ? void 0 : opts.scale) !== false;
  if (useScale) {
    setWorldScale(obj, getWorldScale(obj).multiplyScalar(minScale));
  }
  if ((opts == null ? void 0 : opts.position) !== false) {
    const boundsBottomPosition = new Vector32();
    box2.getCenter(boundsBottomPosition);
    boundsBottomPosition.y = box2.min.y;
    const targetBottomPosition = new Vector32();
    volume.getCenter(targetBottomPosition);
    targetBottomPosition.y = volume.min.y;
    const offset = targetBottomPosition.clone().sub(boundsBottomPosition);
    if (useScale)
      offset.multiplyScalar(minScale);
    setWorldPosition(obj, getWorldPosition(obj).add(offset));
  }
  return {
    boundsBefore: box2,
    scale
  };
}
function placeOnSurface(obj, point) {
  const bounds = getBoundingBox([obj]);
  const center = new Vector32();
  bounds.getCenter(center);
  center.y = bounds.min.y;
  const offset = point.clone().sub(center);
  const worldPos = getWorldPosition(obj);
  setWorldPosition(obj, worldPos.add(offset));
  return {
    offset,
    bounds
  };
}
function postprocessFBXMaterials(obj, material, index, array) {
  if (Array.isArray(material)) {
    let success = true;
    for (let i = 0; i < material.length; i++) {
      const res = postprocessFBXMaterials(obj, material[i], i, material);
      if (!res)
        success = false;
    }
    return success;
  }
  if (material.type === "MeshStandardMaterial") {
    return false;
  } else if (material["material:fbx"] != void 0) {
    return true;
  }
  const newMaterial = new MeshStandardMaterial();
  newMaterial["material:fbx"] = material;
  const oldMaterial = material;
  if (oldMaterial) {
    if (!oldMaterial.map)
      newMaterial.color.copyLinearToSRGB(oldMaterial.color);
    else
      newMaterial.color.set(1, 1, 1);
    newMaterial.emissive.copyLinearToSRGB(oldMaterial.emissive);
    newMaterial.emissiveIntensity = oldMaterial.emissiveIntensity;
    newMaterial.opacity = oldMaterial.opacity;
    newMaterial.displacementScale = oldMaterial.displacementScale;
    newMaterial.transparent = oldMaterial.transparent;
    newMaterial.bumpMap = oldMaterial.bumpMap;
    newMaterial.aoMap = oldMaterial.aoMap;
    newMaterial.map = oldMaterial.map;
    newMaterial.displacementMap = oldMaterial.displacementMap;
    newMaterial.emissiveMap = oldMaterial.emissiveMap;
    newMaterial.normalMap = oldMaterial.normalMap;
    newMaterial.envMap = oldMaterial.envMap;
    newMaterial.alphaMap = oldMaterial.alphaMap;
    newMaterial.metalness = oldMaterial.reflectivity;
    if (oldMaterial.shininess) {
      newMaterial.roughness = 1 - Math.sqrt(oldMaterial.shininess) / 10;
    }
    newMaterial.needsUpdate = true;
  }
  if (index === void 0) {
    obj.material = newMaterial;
  } else {
    array[index] = newMaterial;
  }
  return true;
}

// node_modules/@needle-tools/engine/lib/engine/debug/debug_spatial_console.js
var _isActive = false;
onError((...args) => {
  var _a2;
  if (isDevEnvironment() && ((_a2 = ContextRegistry.Current) == null ? void 0 : _a2.isInXR)) {
    enableSpatialConsole(true);
    onLog("error", ...args);
  }
});
function enableSpatialConsole(active) {
  if (active) {
    if (_isActive)
      return;
    _isActive = true;
    onEnable();
  } else {
    if (!_isActive)
      return;
    _isActive = false;
    onDisable();
  }
}
var originalConsoleMethods = {
  "log": void 0,
  "warn": void 0,
  "error": void 0
};
var SpatialMessagesHandler = class {
  constructor() {
    __publicField(this, "familyName", "needle-xr");
    __publicField(this, "root", null);
    __publicField(this, "context", null);
    __publicField(this, "defaultFontSize", 0.06);
    __publicField(this, "targetObject", new Object3D());
    /** this is a point in forward view of the user */
    __publicField(this, "userForwardViewPoint", new Vector32());
    __publicField(this, "oneEuroFilter", new OneEuroFilterXYZ(90, 0.8));
    __publicField(this, "_lastElementRemoveTime", 0);
    __publicField(this, "onBeforeRender", () => {
      var _a2, _b;
      const cam = (_a2 = this.context) == null ? void 0 : _a2.mainCamera;
      if (this.context && cam instanceof PerspectiveCamera) {
        const root = this.getRoot();
        if (Number.isNaN(root.position.x))
          root.position.set(0, 0, 0);
        if (Number.isNaN(root.quaternion.x))
          root.quaternion.set(0, 0, 0, 1);
        this.context.scene.add(this.targetObject);
        const rigScale = ((_b = this.context.xr) == null ? void 0 : _b.rigScale) ?? 1;
        const dist = 3.5 * rigScale;
        const forward2 = cam.worldForward;
        forward2.y = 0;
        forward2.normalize().multiplyScalar(dist);
        this.userForwardViewPoint.copy(cam.worldPosition).sub(forward2);
        const distFromForwardView = this.targetObject.position.distanceTo(this.userForwardViewPoint);
        if (distFromForwardView > 2 * rigScale) {
          this.targetObject.position.copy(this.userForwardViewPoint);
          lookAtObject(this.targetObject, cam, true, true);
          this.targetObject.rotateY(Math.PI);
        }
        this.oneEuroFilter.filter(this.targetObject.position, root.position, this.context.time.time);
        const step = this.context.time.deltaTime;
        root.quaternion.slerp(this.targetObject.quaternion, step * 5);
        root.scale.setScalar(rigScale);
        this.targetObject.removeFromParent();
        this.context.scene.add(root);
        if (this.context.time.time - this._lastElementRemoveTime > 0.1) {
          this._lastElementRemoveTime = this.context.time.time;
          const now = Date.now();
          for (let i = 0; i < this._activeTexts.length; i++) {
            const el = this._activeTexts[i];
            if (el instanceof __webpack_exports__default.Text && now - el["_activatedTime"] > 2e4) {
              el.removeFromParent();
              this._textBuffer.push(el);
              this._activeTexts.splice(i, 1);
              break;
            }
          }
        }
      }
    });
    __publicField(this, "textOptions", {
      fontSize: this.defaultFontSize,
      fontFamily: this.familyName,
      padding: 0.03,
      margin: 5e-3,
      color: 0,
      backgroundColor: 16777215,
      backgroundOpacity: 0.4,
      borderRadius: 0.03,
      offset: 0.025
    });
    __publicField(this, "_textBuffer", []);
    __publicField(this, "_activeTexts", []);
    this.ensureFont();
  }
  onEnable() {
    this.context = ContextRegistry.Current || ContextRegistry.All[0];
    this.context.pre_render_callbacks.push(this.onBeforeRender);
  }
  onDisable() {
    var _a2, _b, _c;
    (_b = this.context) == null ? void 0 : _b.pre_render_callbacks.splice((_a2 = this.context) == null ? void 0 : _a2.pre_render_callbacks.indexOf(this.onBeforeRender), 1);
    (_c = this.root) == null ? void 0 : _c.removeFromParent();
  }
  addLog(type, message) {
    const root = this.getRoot();
    const text = this.getText();
    let backgroundColor = 16777215;
    let fontColor = 0;
    switch (type) {
      case "log":
        backgroundColor = 16777215;
        fontColor = 0;
        break;
      case "warn":
        backgroundColor = 16772761;
        fontColor = 4465152;
        break;
      case "error":
        backgroundColor = 16755370;
        fontColor = 7798784;
        break;
    }
    if (message.length > 1e3)
      message = message.substring(0, 1e3) + "...";
    const minuteSecondMilliSecond = (/* @__PURE__ */ new Date()).toISOString().split("T")[1].split(".")[0];
    text.textContent = "[" + minuteSecondMilliSecond + "] " + message;
    text.visible = true;
    text["_activatedTime"] = Date.now();
    root.add(text);
    this._activeTexts.push(text);
    if (this.context)
      this.context.scene.add(root);
    text.set({
      backgroundColor,
      color: fontColor
    });
    __webpack_exports__default.update();
  }
  ensureFont() {
    let fontFamily = __webpack_exports__default.FontLibrary.getFontFamily(this.familyName);
    if (!fontFamily) {
      fontFamily = __webpack_exports__default.FontLibrary.addFontFamily(this.familyName);
      const variant = fontFamily.addVariant("normal", "normal", "./include/needle/arial-msdf.json", "./include/needle/arial.png");
      variant == null ? void 0 : variant.addEventListener("ready", () => {
        __webpack_exports__default.update();
      });
    }
  }
  getText() {
    const root = this.getRoot();
    if (this._textBuffer.length > 0) {
      const text = this._textBuffer.pop();
      text.visible = true;
      setTimeout(() => this.disableDepthTestRecursive(text), 100);
      return text;
    }
    if (root.children.length > 20 && this._activeTexts.length > 0) {
      const active = this._activeTexts.shift();
      return active;
    }
    const newText = new __webpack_exports__default.Text(this.textOptions);
    setTimeout(() => this.disableDepthTestRecursive(newText), 500);
    setTimeout(() => this.disableDepthTestRecursive(newText), 1500);
    return newText;
  }
  disableDepthTestRecursive(obj, level = 0) {
    for (let i = 0; i < obj.children.length; i++) {
      const child = obj.children[i];
      if (child instanceof Object3D) {
        this.disableDepthTestRecursive(child, level + 1);
      }
    }
    obj.renderOrder = 10 * level;
    obj.layers.set(2);
    const mat = obj.material;
    if (mat) {
      mat.depthWrite = false;
      mat.depthTest = false;
      mat.transparent = true;
    }
    if (level === 0)
      __webpack_exports__default.update();
  }
  getRoot() {
    if (this.root) {
      return this.root;
    }
    const fontSize = this.defaultFontSize;
    const defaultOptions = {
      boxSizing: "border-box",
      fontFamily: this.familyName,
      width: "2.6",
      fontSize,
      color: 0,
      lineHeight: 1,
      backgroundColor: 16777215,
      backgroundOpacity: 0,
      // borderColor: 0xffffff,
      // borderOpacity: .5,
      // borderWidth: 0.01,
      // padding: 0.01,
      whiteSpace: "pre-wrap",
      flexDirection: "column-reverse"
    };
    this.root = new __webpack_exports__default.Block(defaultOptions);
    return this.root;
  }
};
var messagesHandler = null;
function onEnable() {
  if (!messagesHandler)
    messagesHandler = new SpatialMessagesHandler();
  messagesHandler.onEnable();
  for (const key in originalConsoleMethods) {
    originalConsoleMethods[key] = console[key];
    let isLogging = false;
    console[key] = function() {
      var _a2;
      (_a2 = originalConsoleMethods[key]) == null ? void 0 : _a2.apply(console, arguments);
      if (isLogging)
        return;
      try {
        isLogging = true;
        onLog(key, ...arguments);
      } finally {
        isLogging = false;
      }
    };
  }
}
function onDisable() {
  messagesHandler == null ? void 0 : messagesHandler.onDisable();
  for (const key in originalConsoleMethods) {
    console[key] = originalConsoleMethods[key];
  }
}
var seen = /* @__PURE__ */ new Map();
function onLog(key, ...args) {
  try {
    seen.clear();
    switch (key) {
      case "log":
        messagesHandler == null ? void 0 : messagesHandler.addLog("log", getLogString());
        break;
      case "warn":
        messagesHandler == null ? void 0 : messagesHandler.addLog("warn", getLogString());
        break;
      case "error":
        messagesHandler == null ? void 0 : messagesHandler.addLog("error", getLogString());
        break;
    }
  } catch (err) {
    console.error("Error in spatial console", err);
  } finally {
    seen.clear();
  }
  function getLogString() {
    let str = "";
    for (let i = 0; i < args.length; i++) {
      const el = args[i];
      str += serialize(el);
      if (i < args.length - 1)
        str += ", ";
    }
    return str;
  }
  function serialize(value, level = 0) {
    if (typeof value === "string") {
      return '"' + value + '"';
    } else if (typeof value === "number") {
      const hasDecimal = value % 1 !== 0;
      if (hasDecimal) {
        const str = value.toFixed(5);
        const dotIndex = str.indexOf(".");
        let i = str.length - 1;
        while (i > dotIndex && str[i] === "0")
          i--;
        return str.substring(0, i + 1);
      }
      return value.toString();
    } else if (Array.isArray(value)) {
      let res = "[";
      for (let i = 0; i < value.length; i++) {
        const val = value[i];
        res += serialize(val, level + 1);
        if (i < value.length - 1)
          res += ", ";
      }
      res += "]";
      return res;
    } else if (value === null) {
      return "null";
    } else if (value === void 0) {
      return "undefined";
    } else if (typeof value === "function") {
      return value.name + "()";
    }
    if (value instanceof Vector2)
      return `(${serialize(value.x)}, ${serialize(value.y)})`;
    if (value instanceof Vector32)
      return `(${serialize(value.x)}, ${serialize(value.y)}, ${serialize(value.z)})`;
    if (value instanceof Vector4)
      return `(${serialize(value.x)}, ${serialize(value.y)}, ${serialize(value.z)}, ${serialize(value.w)})`;
    if (value instanceof Quaternion)
      return `(${serialize(value.x)}, ${serialize(value.y)}, ${serialize(value.z)}, ${serialize(value.w)})`;
    if (value instanceof Material)
      return value.name;
    if (value instanceof Texture)
      return value.name;
    if (value instanceof Matrix3)
      return `[${value.elements.join(", ")}]`;
    if (value instanceof Matrix4)
      return `[${value.elements.join(", ")}]`;
    if (value instanceof Layers)
      return value.mask.toString();
    if (typeof value === "object") {
      if (seen.has(value))
        return "*";
      let res = "{\n";
      res += pad(level);
      const keys = Object.keys(value);
      let line = "";
      for (let i = 0; i < keys.length; i++) {
        const key2 = keys[i];
        const val = value[key2];
        if (seen.has(val)) {
          line += "";
          continue;
        }
        seen.set(val, true);
        line += key2 + ":" + serialize(val, level + 1);
        if (i < keys.length - 1)
          line += ", ";
        if (line.length >= 60) {
          line += "\n";
          line += pad(level);
          res += line;
          line = "";
        }
      }
      res += line;
      res += "\n}";
      return res;
    }
    return value;
  }
  function pad(spaces) {
    let res = "";
    for (let i = 0; i < spaces; i++) {
      res += " ";
    }
    return res;
  }
}

// node_modules/@needle-tools/engine/lib/engine/debug/debug.js
var noDevLogs = getParam("nodevlogs");
function showBalloonMessage(text, logType = LogType.Log) {
  addLog(logType, text);
}
function showBalloonWarning(text) {
  showBalloonMessage(text, LogType.Warn);
}
function showBalloonError(text) {
  showBalloonMessage(text, LogType.Error);
}
var _manuallySetDevEnvironment;
var _cachedDevEnvironment;
function isDevEnvironment() {
  if (noDevLogs)
    return false;
  if (_manuallySetDevEnvironment !== void 0)
    return _manuallySetDevEnvironment;
  if (_cachedDevEnvironment !== void 0)
    return _cachedDevEnvironment;
  let res = isLocalNetwork();
  if (!res) {
    res = window.location.hostname.endsWith(".local-credentialless.webcontainer.io");
  }
  _cachedDevEnvironment = res;
  return res;
}
function setDevEnvironment(val) {
  _manuallySetDevEnvironment = val;
}

// node_modules/@needle-tools/engine/lib/engine/debug/debug_console.js
var consoleInstance = void 0;
var consoleHtmlElement = null;
var consoleSwitchButton = null;
var isLoading = false;
var isVisible = false;
var watchInterval = null;
var defaultButtonIcon = "terminal";
var showConsole = getParam("console");
var suppressConsole = getParam("noerrors") || getParam("noconsole") || window.crossOriginIsolated;
if (showConsole) {
  showDebugConsole();
}
if (!suppressConsole && (showConsole || isLocalNetwork())) {
  if (isLocalNetwork() && !showConsole) {
    const consoleUrl = new URL(window.location.href);
    consoleUrl.searchParams.set("console", "1");
    console.log('🌵 Tip: You can add the "?console" query parameter to the url to show the debug console (on mobile it will automatically open in the bottom right corner when your get errors during development. In VR a spatial console will appear.)', "\nOpen this page to get the console: " + consoleUrl.toString());
  }
  const enableConsole = DeviceUtilities.isMobileDevice() || DeviceUtilities.isQuest() && isDevEnvironment();
  if (enableConsole || showConsole) {
    makeErrorsVisibleForDevelopment();
    beginWatchingLogs();
    createConsole(true);
    if (enableConsole) {
      const engineElement = document.querySelector("needle-engine");
      engineElement == null ? void 0 : engineElement.addEventListener("enter-ar", () => {
        if (showConsole || consoleInstance || getErrorCount() > 0) {
          if (getParam("noerrors"))
            return;
        }
      });
      engineElement == null ? void 0 : engineElement.addEventListener("exit-ar", () => {
        onResetConsoleElementToDefaultParent();
      });
    }
  }
}
var $defaultConsoleParent = Symbol("consoleParent");
function showDebugConsole() {
  if (consoleInstance) {
    isVisible = true;
    consoleInstance.showSwitch();
    return;
  }
  createConsole();
}
function hideDebugConsole() {
  if (!consoleInstance)
    return;
  isVisible = false;
  consoleInstance.hide();
  consoleInstance.hideSwitch();
}
function beginWatchingLogs() {
  if (watchInterval)
    return;
  watchInterval = setInterval(consoleElementUpdateInterval, 500);
}
var lastErrorCount = 0;
function consoleElementUpdateInterval() {
  const currentCount = getErrorCount();
  const receivedNewErrors = currentCount !== lastErrorCount;
  lastErrorCount = currentCount;
  if (receivedNewErrors) {
    onNewConsoleErrors();
  }
}
function onNewConsoleErrors() {
  showDebugConsole();
  if (consoleSwitchButton) {
    consoleSwitchButton.setAttribute("error", "true");
    consoleSwitchButton.innerText = "🤬";
  }
}
function onConsoleSwitchButtonClicked() {
  if (consoleSwitchButton) {
    consoleSwitchButton.removeAttribute("error");
    consoleSwitchButton.innerText = defaultButtonIcon;
  }
}
function onResetConsoleElementToDefaultParent() {
  if (consoleHtmlElement && consoleHtmlElement[$defaultConsoleParent]) {
    consoleHtmlElement[$defaultConsoleParent].appendChild(consoleHtmlElement);
  }
}
function createConsole(startHidden = false) {
  if (consoleInstance !== void 0)
    return;
  if (isLoading)
    return;
  isLoading = true;
  const script = document.createElement("script");
  script.onload = () => {
    if (!globalThis.VConsole) {
      console.warn("🌵 Debug console failed to load.");
      isLoading = false;
      consoleInstance = null;
      return;
    }
    isLoading = false;
    isVisible = true;
    beginWatchingLogs();
    consoleInstance = new VConsole({
      // defaultPlugins: ['system', 'network'],
      pluginOrder: ["default", "needle-console"]
    });
    const files = globalThis["needle:codegen_files"];
    if (files && files.length > 0) {
      consoleInstance.addPlugin(createInspectPlugin());
    }
    consoleHtmlElement = getConsoleElement();
    if (consoleHtmlElement) {
      consoleHtmlElement[$defaultConsoleParent] = consoleHtmlElement.parentElement;
      consoleHtmlElement.style.position = "absolute";
      consoleHtmlElement.style.zIndex = Number.MAX_SAFE_INTEGER.toString();
    }
    consoleInstance.setSwitchPosition(20, 30);
    consoleSwitchButton = getConsoleSwitchButton();
    if (consoleSwitchButton) {
      consoleSwitchButton.innerText = defaultButtonIcon;
      consoleSwitchButton.addEventListener("click", onConsoleSwitchButtonClicked);
      const styles = document.createElement("style");
      const size = 40;
      styles.innerHTML = `
                #__vconsole .vc-switch {
                    border: 1px solid rgba(255, 255, 255, .1);
                    border-radius: 50%;
                    width: ${size}px;
                    height: ${size}px;
                    padding: 0;
                    line-height: ${size}px;
                    font-size: ${size * 0.4}px;
                    text-align: center;
                    background: #ffffff5c;
                    backdrop-filter: blur(16px);
                    -webkit-backdrop-filter: blur(16px);
                    user-select: none;
                    pointer-events: auto;
                    transition: transform .2s ease-in-out;
                    box-shadow: 0px 7px 0.5rem 0px rgb(0 0 0 / 6%), inset 0px 0px 1.3rem rgba(0,0,0,.05);

                    font-family: 'Material Symbols Outlined';
                    color: black;
                    font-size: 2.3em;
                    font-weight: 100;
                }
                #__vconsole .vc-switch:hover {
                    cursor: pointer;
                    transform: scale(1.1);
                    transition: transform .1s ease-in-out, background .1s linear;
                    background: rgba(245, 245, 245, .8);
                    outline: rgba(0, 0, 0, .05) 1px solid;
                }
                #__vconsole .vc-switch[error] {
                    background: rgba(255,0,0,.2);
                    animation: vconsole-notify 1s ease-in-out;
                    line-height: 35px;
                }
                @keyframes vconsole-notify {
                    from {
                        transform: scale(1, 1);
                    }
                    10% {
                        transform: scale(1.3, 1.3);
                    }
                    70% {
                        transform: scale(1.4, 1.4);
                    }
                    to {
                        transform: scale(1, 1);
                    }
                }
                #__vconsole .vc-panel {
                    font-family: monospace;
                    font-size: 11px;
                }
                #__vconsole .vc-plugin-box.vc-actived {
                    height: 100%;
                }
                #__vconsole .vc-mask {
                    overflow: hidden;
                }
            `;
      consoleHtmlElement == null ? void 0 : consoleHtmlElement.prepend(styles);
      if (startHidden === true && getErrorCount() <= 0)
        hideDebugConsole();
      console.log("🌵 Debug console has loaded");
    }
  };
  script.onerror = () => {
    console.warn("🌵 Debug console failed to load." + (window.crossOriginIsolated ? "This page is using cross-origin isolation, so external scripts can't be loaded." : ""));
    isLoading = false;
    consoleInstance = null;
  };
  script.src = "https://unpkg.com/vconsole@latest/dist/vconsole.min.js";
  document.body.appendChild(script);
}
function createInspectPlugin() {
  if (!globalThis.VConsole)
    return;
  const plugin = new VConsole.VConsolePlugin("needle-console", "🌵 Inspect glTF");
  const getIframe = () => {
    return document.querySelector("#__vc_plug_" + plugin._id + " iframe");
  };
  plugin.on("renderTab", function(callback) {
    const files = globalThis["needle:codegen_files"];
    if (!files || files.length === 0)
      return;
    let query = globalThis["needle:codegen_files"][0];
    const index = query.indexOf("?");
    if (index > -1)
      query = query.substring(0, index);
    const currentAbsolutePath = location.protocol + "//" + location.host + location.pathname;
    const currentPath = currentAbsolutePath + "/" + query;
    const urlEncoded = encodeURIComponent(currentPath);
    plugin.fullUrl = "https://viewer.needle.tools?inspect&file=" + urlEncoded;
    var html = `<iframe src="" style="width: 100%; height: 99%; border: none;"></iframe>`;
    callback(html);
  });
  plugin.on("show", function() {
    const elem = getIframe();
    if (elem && elem.src !== plugin.fullUrl)
      elem.src = plugin.fullUrl;
  });
  plugin.on("hide", function() {
    const elem = getIframe();
    if (elem)
      elem.src = "";
  });
  plugin.on("addTopBar", function(callback) {
    var btnList = new Array();
    btnList.push({
      name: "Open in new window ↗",
      onClick: function(_event2) {
        window.open(plugin.fullUrl, "_blank");
        consoleInstance == null ? void 0 : consoleInstance.hide();
      }
    });
    btnList.push({
      name: "Reload",
      onClick: function(_event2) {
        const iframe = getIframe();
        if (iframe)
          iframe.src = plugin.fullUrl;
      }
    });
    btnList.push({
      name: "Fullscreen",
      onClick: function(_event2) {
        const iframe = getIframe();
        if (iframe.requestFullscreen) {
          iframe.requestFullscreen();
        } else if (iframe["webkitRequestFullscreen"] instanceof Function) {
          iframe["webkitRequestFullscreen"]();
        }
      }
    });
    callback(btnList);
  });
  return plugin;
}
function getConsoleSwitchButton() {
  const el = document.querySelector("#__vconsole .vc-switch");
  if (el)
    return el;
  return null;
}
function getConsoleElement() {
  const el = document.querySelector("#__vconsole");
  if (el)
    return el;
  return null;
}

// node_modules/@needle-tools/engine/lib/engine/engine_constants.js
var debug2 = getParam("debugdefines");
tryEval(`if(!globalThis["NEEDLE_ENGINE_VERSION"]) globalThis["NEEDLE_ENGINE_VERSION"] = "0.0.0";`);
tryEval(`if(!globalThis["NEEDLE_ENGINE_GENERATOR"]) globalThis["NEEDLE_ENGINE_GENERATOR"] = "unknown";`);
tryEval(`if(!globalThis["NEEDLE_PROJECT_BUILD_TIME"]) globalThis["NEEDLE_PROJECT_BUILD_TIME"] = "unknown";`);
tryEval(`if(!globalThis["NEEDLE_PUBLIC_KEY"]) globalThis["NEEDLE_PUBLIC_KEY"] = "unknown";`);
tryEval(`globalThis["__NEEDLE_ENGINE_VERSION__"] = "` + NEEDLE_ENGINE_VERSION + `";`);
tryEval(`globalThis["__NEEDLE_ENGINE_GENERATOR__"] = "` + NEEDLE_ENGINE_GENERATOR + `";`);
tryEval(`globalThis["__NEEDLE_PROJECT_BUILD_TIME__"] = "` + NEEDLE_PROJECT_BUILD_TIME + `";`);
tryEval(`globalThis["__NEEDLE_PUBLIC_KEY__"] = "` + NEEDLE_PUBLIC_KEY + `";`);
var VERSION = NEEDLE_ENGINE_VERSION;
var GENERATOR = NEEDLE_ENGINE_GENERATOR;
var BUILD_TIME = NEEDLE_PROJECT_BUILD_TIME;
if (debug2)
  console.log(`Engine version: ${VERSION} (generator: ${GENERATOR})
Project built at ${BUILD_TIME}`);
var PUBLIC_KEY = NEEDLE_PUBLIC_KEY;
var activeInHierarchyFieldName = "needle_isActiveInHierarchy";
var builtinComponentKeyName = "builtin_components";
var editorGuidKeyName = "needle_editor_guid";
function tryEval(str) {
  try {
    (0, eval)(str);
  } catch (err) {
    if (debug2)
      console.error(err);
  }
}

// node_modules/@needle-tools/engine/lib/engine/assets/index.js
var logoSvgString = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 160 187.74"><defs><linearGradient id="a" x1="89.64" y1="184.81" x2="90.48" y2="21.85" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#62d399"/><stop offset=".51" stop-color="#acd842"/><stop offset=".9" stop-color="#d7db0a"/></linearGradient><linearGradient id="b" x1="69.68" y1="178.9" x2="68.08" y2="16.77" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#0ba398"/><stop offset=".5" stop-color="#4ca352"/><stop offset="1" stop-color="#76a30a"/></linearGradient><linearGradient id="c" x1="36.6" y1="152.17" x2="34.7" y2="84.19" gradientUnits="userSpaceOnUse"><stop offset=".19" stop-color="#36a382"/><stop offset=".54" stop-color="#49a459"/><stop offset="1" stop-color="#76a30b"/></linearGradient><linearGradient id="d" x1="15.82" y1="153.24" x2="18" y2="90.86" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#267880"/><stop offset=".51" stop-color="#457a5c"/><stop offset="1" stop-color="#717516"/></linearGradient><linearGradient id="e" x1="135.08" y1="135.43" x2="148.93" y2="63.47" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#b0d939"/><stop offset="1" stop-color="#eadb04"/></linearGradient><linearGradient id="f" x1="-4163.25" y1="2285.12" x2="-4160.81" y2="2215.34" gradientTransform="rotate(20 4088.49 13316.712)" gradientUnits="userSpaceOnUse"><stop offset=".17" stop-color="#74af52"/><stop offset=".48" stop-color="#99be32"/><stop offset="1" stop-color="#c0c40a"/></linearGradient><symbol id="g" viewBox="0 0 160 187.74"><path style="fill:url(#a)" d="M79.32 36.98v150.76L95 174.54l6.59-156.31-22.27 18.75z"/><path style="fill:url(#b)" d="M79.32 36.98 57.05 18.23l6.59 156.31 15.68 13.2V36.98z"/><path style="fill:url(#c)" d="m25.19 104.83 8.63 49.04 12.5-14.95-2.46-56.42-18.67 22.33z"/><path style="fill:url(#d)" d="M25.19 104.83 0 90.24l16.97 53.86 16.85 9.77-8.63-49.04z"/><path style="fill:#9c3" d="M43.86 82.5 18.69 67.98 0 90.24l25.18 14.59L43.86 82.5z"/><path style="fill:url(#e)" d="m134.82 78.69-9.97 56.5 15.58-9.04L160 64.1l-25.18 14.59z"/><path style="fill:url(#f)" d="m134.82 78.69-18.68-22.33-2.86 65 11.57 13.83 9.97-56.5z"/><path style="fill:#ffe113" d="m160 64.1-18.69-22.26-25.17 14.52 18.67 22.33L160 64.1z"/><path style="fill:#f3e600" d="M101.59 18.23 79.32 0 57.05 18.23l22.27 18.75 22.27-18.75z"/></symbol></defs><use width="160" height="187.74" xlink:href="#g"/></svg>`;
var logoSvgBlob = btoa(logoSvgString);
var logoSvgUrl = "data:image/svg+xml;base64," + logoSvgBlob;
var needleLogoOnlySVG = logoSvgUrl;
var madeWithNeedleSvgString = `<?xml version="1.0" encoding="UTF-8"?> <!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'> <svg clip-rule="evenodd" fill-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="2" version="1.1" viewBox="0 0 1014 282" xml:space="preserve" xmlns="http://www.w3.org/2000/svg"> <g transform="matrix(1.008 0 0 1.008 -2.239 .61874)"> <path d="m665.95 132.73v44.88l-10.56-8.4c-0.8-0.64-1.2-1.44-1.2-2.4v-32.4c0-6.48-4.12-9.72-12.36-9.72-2.16 0-4.18 0.4-6.06 1.2s-3.54 1.8-4.98 3-2.56 2.5-3.36 3.9-1.2 2.7-1.2 3.9v40.92l-10.68-8.4c-0.72-0.64-1.08-1.44-1.08-2.4v-53.76l10.92 8.52c0.32 0.24 0.56 0.44 0.72 0.6s0.36 0.32 0.6 0.48c0.96-1.2 2.14-2.28 3.54-3.24s2.92-1.76 4.56-2.4 3.34-1.14 5.1-1.5 3.44-0.54 5.04-0.54c1.44 0 2.92 0.04 4.44 0.12s2.84 0.28 3.96 0.6c4.56 1.12 7.8 3.12 9.72 6s2.88 6.56 2.88 11.04z" fill-rule="nonzero"/> </g> <g transform="matrix(1.008 0 0 1.008 -2.239 .61874)"> <path d="m732.38 146.05c0 0.88 0.02 1.5 0.06 1.86s-0.02 0.98-0.18 1.86h-7.08c-2.08 0-4.44-0.02-7.08-0.06s-5.36-0.06-8.16-0.06h-22.08c0 2.88 0.56 5.36 1.68 7.44s2.6 3.8 4.44 5.16 3.94 2.36 6.3 3 4.74 0.96 7.14 0.96c3.04 0 5.9-0.76 8.58-2.28s4.94-3.52 6.78-6c0.64 0.56 1.54 1.48 2.7 2.76s2.94 3.2 5.34 5.76c-2.8 3.36-6.22 6.02-10.26 7.98s-8.42 2.94-13.14 2.94-8.92-0.64-12.84-1.92-7.32-3.24-10.2-5.88-5.12-5.98-6.72-10.02-2.4-8.82-2.4-14.34c0-4.96 0.66-9.42 1.98-13.38s3.22-7.32 5.7-10.08 5.44-4.9 8.88-6.42 7.32-2.28 11.64-2.28c5.76 0 10.52 0.88 14.28 2.64s6.72 4.16 8.88 7.2 3.66 6.54 4.5 10.5 1.26 8.18 1.26 12.66zm-29.4-22.8c-2.16 0.16-4.16 0.72-6 1.68s-3.42 2.2-4.74 3.72-2.36 3.28-3.12 5.28-1.14 4.12-1.14 6.36h33.12c0-2-0.22-4.06-0.66-6.18s-1.3-4.02-2.58-5.7-3.1-3.02-5.46-4.02-5.5-1.38-9.42-1.14z" fill-rule="nonzero"/> </g> <g transform="matrix(1.008 0 0 1.008 -2.239 .61874)"> <path d="m795.93 146.05c0 0.88 0.02 1.5 0.06 1.86s-0.02 0.98-0.18 1.86h-7.08c-2.08 0-4.44-0.02-7.08-0.06s-5.36-0.06-8.16-0.06h-22.08c0 2.88 0.56 5.36 1.68 7.44s2.6 3.8 4.44 5.16 3.94 2.36 6.3 3 4.74 0.96 7.14 0.96c3.04 0 5.9-0.76 8.58-2.28s4.94-3.52 6.78-6c0.64 0.56 1.54 1.48 2.7 2.76s2.94 3.2 5.34 5.76c-2.8 3.36-6.22 6.02-10.26 7.98s-8.42 2.94-13.14 2.94-8.92-0.64-12.84-1.92-7.32-3.24-10.2-5.88-5.12-5.98-6.72-10.02-2.4-8.82-2.4-14.34c0-4.96 0.66-9.42 1.98-13.38s3.22-7.32 5.7-10.08 5.44-4.9 8.88-6.42 7.32-2.28 11.64-2.28c5.76 0 10.52 0.88 14.28 2.64s6.72 4.16 8.88 7.2 3.66 6.54 4.5 10.5 1.26 8.18 1.26 12.66zm-29.4-22.8c-2.16 0.16-4.16 0.72-6 1.68s-3.42 2.2-4.74 3.72-2.36 3.28-3.12 5.28-1.14 4.12-1.14 6.36h33.12c0-2-0.22-4.06-0.66-6.18s-1.3-4.02-2.58-5.7-3.1-3.02-5.46-4.02-5.5-1.38-9.42-1.14z" fill-rule="nonzero"/> </g> <g transform="matrix(1.008 0 0 1.008 -2.239 .61874)"> <path d="m858.57 97.21c0.64 0.48 0.96 1.16 0.96 2.04v74.88c-0.08 1.04-0.12 2.12-0.12 3.24-1.84-1.52-3.56-2.92-5.16-4.2-1.36-1.12-2.66-2.18-3.9-3.18s-2.06-1.66-2.46-1.98c-1.76 2.48-4.26 4.44-7.5 5.88s-7.02 2.16-11.34 2.16c-3.84 0-7.4-0.7-10.68-2.1s-6.14-3.44-8.58-6.12-4.34-5.94-5.7-9.78-2.04-8.16-2.04-12.96c0-4.32 0.78-8.34 2.34-12.06s3.6-6.92 6.12-9.6 5.38-4.78 8.58-6.3 6.48-2.28 9.84-2.28c2.56 0 4.82 0.22 6.78 0.66s3.68 1.06 5.16 1.86 2.78 1.74 3.9 2.82 2.16 2.22 3.12 3.42v-35.04l10.68 8.64zm-27.96 67.92c3.6 0 6.52-0.68 8.76-2.04s3.98-3.06 5.22-5.1 2.1-4.22 2.58-6.54 0.72-4.44 0.72-6.36v-1.2c0-1.12-0.22-2.7-0.66-4.74s-1.28-4.06-2.52-6.06-3-3.7-5.28-5.1-5.22-2.02-8.82-1.86c-3.44 0-6.26 0.74-8.46 2.22s-3.96 3.26-5.28 5.34-2.24 4.2-2.76 6.36-0.78 3.92-0.78 5.28c0 1.84 0.24 3.92 0.72 6.24s1.36 4.48 2.64 6.48 3.04 3.68 5.28 5.04 5.12 2.04 8.64 2.04z" fill-rule="nonzero"/> </g> <g transform="matrix(1.008 0 0 1.008 -2.239 .61874)"> <path d="m882.81 97.09c0.64 0.48 0.96 1.12 0.96 1.92l-0.12 41.04v37.08l-10.56-8.4c-0.72-0.64-1.08-1.44-1.08-2.4v-77.88l10.8 8.64z" fill-rule="nonzero"/> </g> <g transform="matrix(1.008 0 0 1.008 -2.239 .61874)"> <path d="m950.36 146.05c0 0.88 0.02 1.5 0.06 1.86s-0.02 0.98-0.18 1.86h-7.08c-2.08 0-4.44-0.02-7.08-0.06s-5.36-0.06-8.16-0.06h-22.08c0 2.88 0.56 5.36 1.68 7.44s2.6 3.8 4.44 5.16 3.94 2.36 6.3 3 4.74 0.96 7.14 0.96c3.04 0 5.9-0.76 8.58-2.28s4.94-3.52 6.78-6c0.64 0.56 1.54 1.48 2.7 2.76s2.94 3.2 5.34 5.76c-2.8 3.36-6.22 6.02-10.26 7.98s-8.42 2.94-13.14 2.94-8.92-0.64-12.84-1.92-7.32-3.24-10.2-5.88-5.12-5.98-6.72-10.02-2.4-8.82-2.4-14.34c0-4.96 0.66-9.42 1.98-13.38s3.22-7.32 5.7-10.08 5.44-4.9 8.88-6.42 7.32-2.28 11.64-2.28c5.76 0 10.52 0.88 14.28 2.64s6.72 4.16 8.88 7.2 3.66 6.54 4.5 10.5 1.26 8.18 1.26 12.66zm-29.4-22.8c-2.16 0.16-4.16 0.72-6 1.68s-3.42 2.2-4.74 3.72-2.36 3.28-3.12 5.28-1.14 4.12-1.14 6.36h33.12c0-2-0.22-4.06-0.66-6.18s-1.3-4.02-2.58-5.7-3.1-3.02-5.46-4.02-5.5-1.38-9.42-1.14z" fill-rule="nonzero"/> </g> <g transform="matrix(1.8559 0 0 .7642 45.348 36.475)"> <g transform="translate(2.7114)"> <path d="m3.935 173.02c-0.331 0-0.497-0.402-0.497-1.207v-51.002c0-0.738 0.138-1.107 0.414-1.107h1.781c0.277 0 0.415 0.335 0.415 1.006v5.935c0 0.336 0.027 0.553 0.083 0.654 0.055 0.101 0.151-0.017 0.289-0.352 0.912-1.744 1.754-3.236 2.527-4.477 0.773-1.24 1.554-2.179 2.341-2.816s1.65-0.956 2.588-0.956c1.685 0 3.011 0.922 3.977 2.766 0.967 1.845 1.602 3.84 1.905 5.986 0.056 0.268 0.139 0.369 0.249 0.302s0.221-0.235 0.331-0.503c0.939-1.811 1.802-3.353 2.589-4.628 0.787-1.274 1.581-2.246 2.382-2.917s1.671-1.006 2.61-1.006c2.016 0 3.569 1.392 4.66 4.175 1.09 2.783 1.636 6.421 1.636 10.915v37.925c0 0.871-0.18 1.307-0.539 1.307h-1.739c-0.138 0-0.249-0.1-0.332-0.301-0.083-0.202-0.124-0.503-0.124-0.906v-36.315c0-3.555-0.338-6.321-1.015-8.3-0.676-1.978-1.76-2.967-3.251-2.967-0.884 0-1.726 0.386-2.527 1.157s-1.519 1.727-2.154 2.867-1.201 2.213-1.699 3.219c-0.248 0.469-0.421 0.905-0.517 1.308-0.097 0.402-0.145 0.972-0.145 1.71v37.221c0 0.871-0.166 1.307-0.497 1.307h-1.74c-0.166 0-0.29-0.1-0.373-0.301-0.083-0.202-0.124-0.503-0.124-0.906v-36.315c0-3.555-0.332-6.321-0.994-8.3-0.663-1.978-1.754-2.967-3.273-2.967-1.242 0-2.375 0.704-3.396 2.112-1.022 1.409-2.223 3.555-3.604 6.439v39.031c0 0.805-0.18 1.207-0.539 1.207h-1.698z" fill-rule="nonzero" stroke="#000" stroke-width=".7px"/> </g> <g transform="translate(2.7114)"> <path d="m53.642 166.28c-1.077 2.549-2.237 4.477-3.479 5.785-1.243 1.307-2.61 1.961-4.101 1.961-2.154 0-3.853-1.324-5.095-3.973-1.243-2.649-1.864-6.187-1.864-10.613 0-3.488 0.4-6.489 1.201-9.004s1.988-4.51 3.562-5.985c1.574-1.476 3.521-2.414 5.841-2.817l3.686-0.704c0.221-0.067 0.394-0.218 0.518-0.453 0.124-0.234 0.187-0.587 0.187-1.056v-2.917c0-3.89-0.504-6.975-1.512-9.255s-2.354-3.42-4.039-3.42c-1.298 0-2.472 0.72-3.521 2.162s-2.002 3.572-2.858 6.388c-0.083 0.268-0.159 0.453-0.228 0.554-0.069 0.1-0.172 0.083-0.311-0.051l-1.698-1.71c-0.083-0.134-0.138-0.285-0.166-0.453-0.027-0.167 0.014-0.452 0.125-0.855 0.856-3.353 2.009-6.052 3.459-8.098 1.449-2.045 3.224-3.068 5.322-3.068 1.74 0 3.211 0.687 4.412 2.062s2.112 3.37 2.734 5.986c0.621 2.615 0.932 5.7 0.932 9.255v35.712c0 0.536-0.035 0.888-0.104 1.056s-0.2 0.251-0.393 0.251h-1.533c-0.166 0-0.29-0.117-0.373-0.352-0.083-0.234-0.124-0.553-0.124-0.955l-0.083-5.231c-0.055-0.939-0.221-1.006-0.497-0.202zm0.456-19.314c0-1.14-0.194-1.643-0.58-1.509l-3.107 0.603c-1.436 0.202-2.686 0.638-3.749 1.308-1.063 0.671-1.953 1.543-2.671 2.616s-1.257 2.33-1.616 3.772-0.538 3.102-0.538 4.98c0 3.152 0.455 5.616 1.367 7.393 0.911 1.778 2.14 2.666 3.686 2.666 0.939 0 1.85-0.419 2.734-1.257s1.671-1.895 2.361-3.169c0.663-1.408 1.181-2.85 1.553-4.326 0.373-1.475 0.56-2.883 0.56-4.225v-8.852z" fill-rule="nonzero" stroke="#000" stroke-width=".7px"/> </g> <g transform="translate(2.7114)"> <path d="m79.034 173.02c-0.166 0-0.297-0.117-0.394-0.352-0.096-0.234-0.145-0.553-0.145-0.955v-4.628c0-0.536-0.041-0.838-0.124-0.905s-0.207 0.1-0.373 0.503c-0.276 0.67-0.69 1.593-1.242 2.766-0.553 1.174-1.271 2.23-2.154 3.169-0.884 0.939-1.961 1.408-3.231 1.408-1.74 0-3.314-0.989-4.722-2.967-1.409-1.979-2.534-4.963-3.376-8.953-0.843-3.991-1.264-8.937-1.264-14.838 0-5.701 0.415-10.68 1.243-14.939s1.988-7.595 3.479-10.009c1.492-2.415 3.204-3.622 5.137-3.622 1.436 0 2.616 0.57 3.541 1.71 0.926 1.14 1.719 2.381 2.382 3.722 0.249 0.47 0.414 0.637 0.497 0.503s0.125-0.536 0.125-1.207v-23.841c0-0.805 0.151-1.208 0.455-1.208h1.864c0.276 0 0.414 0.369 0.414 1.107v72.128c0 0.537-0.041 0.905-0.124 1.107-0.083 0.201-0.235 0.301-0.455 0.301h-1.533zm-0.621-42.049c-0.939-2.213-1.885-3.94-2.838-5.181s-2.009-1.861-3.169-1.861c-1.463 0-2.768 0.889-3.914 2.666s-2.044 4.376-2.693 7.796-0.973 7.578-0.973 12.474c0 5.097 0.338 9.272 1.015 12.524 0.676 3.253 1.567 5.651 2.672 7.193 1.104 1.543 2.305 2.314 3.603 2.314 1.188 0 2.258-0.704 3.211-2.113 0.952-1.408 1.705-3.118 2.257-5.13s0.829-3.957 0.829-5.835v-24.847z" fill-rule="nonzero" stroke="#000" stroke-width=".7px"/> </g> <g transform="translate(2.7114)"> <path d="m89.514 149.38c0 3.42 0.345 6.606 1.035 9.557 0.691 2.951 1.609 5.315 2.755 7.092s2.437 2.666 3.873 2.666c1.519 0 2.837-0.738 3.956-2.213 1.118-1.476 2.064-3.655 2.837-6.539 0.083-0.336 0.166-0.52 0.249-0.554 0.083-0.033 0.179 0.017 0.29 0.151l1.408 1.912c0.221 0.268 0.235 0.67 0.041 1.207-0.69 2.548-1.47 4.661-2.34 6.337-0.87 1.677-1.857 2.935-2.962 3.773-1.104 0.838-2.319 1.257-3.645 1.257-2.043 0-3.838-1.14-5.385-3.42-1.546-2.28-2.761-5.482-3.645-9.607-0.884-4.124-1.325-8.836-1.325-14.134 0-5.901 0.455-10.931 1.367-15.089 0.911-4.158 2.14-7.377 3.686-9.658 1.547-2.28 3.3-3.42 5.261-3.42 1.988 0 3.714 1.073 5.178 3.219 1.463 2.146 2.595 5.231 3.396 9.255s1.201 8.886 1.201 14.587c0 0.469-0.02 0.939-0.062 1.408-0.041 0.469-0.214 0.704-0.517 0.704h-16.362c-0.083 0-0.152 0.151-0.207 0.453-0.056 0.302-0.083 0.654-0.083 1.056zm13.752-6.237c0.304 0 0.497-0.1 0.58-0.302 0.083-0.201 0.124-0.57 0.124-1.106 0-3.219-0.283-6.187-0.849-8.903s-1.367-4.896-2.402-6.539c-1.036-1.643-2.272-2.464-3.708-2.464-1.629 0-2.996 0.955-4.101 2.867-1.104 1.911-1.94 4.342-2.506 7.293s-0.849 6.002-0.849 9.154h13.711z" fill-rule="nonzero" stroke="#000" stroke-width=".7px"/> </g> <g transform="translate(2.7114)"> <path d="m148.54 119.7c0.165 0 0.283 0.117 0.352 0.352s0.076 0.52 0.02 0.855l-6.254 50.902c-0.028 0.47-0.104 0.788-0.228 0.956s-0.297 0.251-0.518 0.251h-1.615c-0.442 0-0.718-0.402-0.829-1.207l-5.26-40.138c-0.111-0.604-0.201-0.905-0.27-0.905s-0.131 0.301-0.186 0.905l-5.012 40.138c-0.028 0.47-0.097 0.788-0.207 0.956-0.111 0.168-0.277 0.251-0.497 0.251h-1.74c-0.442 0-0.718-0.402-0.829-1.207l-6.503-50.801c-0.055-0.403-0.048-0.721 0.021-0.956s0.2-0.352 0.393-0.352h1.823c0.166 0 0.297 0.067 0.393 0.201 0.097 0.134 0.159 0.403 0.187 0.805l5.302 41.848c0.083 0.671 0.179 0.989 0.29 0.956 0.11-0.034 0.207-0.386 0.29-1.056l5.219-41.949c0.055-0.268 0.124-0.47 0.207-0.604s0.193-0.201 0.331-0.201h1.533c0.138 0 0.262 0.067 0.373 0.201 0.11 0.134 0.179 0.403 0.207 0.805l5.468 41.848c0.083 0.671 0.179 0.989 0.29 0.956 0.11-0.034 0.207-0.386 0.29-1.056l5.053-41.849c0.055-0.335 0.138-0.57 0.249-0.704 0.11-0.134 0.234-0.201 0.373-0.201h1.284z" fill-rule="nonzero" stroke="#000" stroke-width=".7px"/> </g> <g transform="translate(2.7114)"> <path d="m156.49 171.51c0 0.604-0.042 1.006-0.125 1.208-0.082 0.201-0.262 0.301-0.538 0.301h-1.533c-0.221 0-0.366-0.083-0.435-0.251s-0.103-0.486-0.103-0.956v-50.902c0-0.805 0.152-1.207 0.456-1.207h1.822c0.304 0 0.456 0.402 0.456 1.207v50.6zm0.165-63.979c0 1.207-0.207 1.811-0.621 1.811h-1.905c-0.221 0-0.366-0.135-0.435-0.403s-0.104-0.67-0.104-1.207v-7.847c0-1.006 0.18-1.509 0.539-1.509h1.988c0.359 0 0.538 0.47 0.538 1.409v7.746z" fill-rule="nonzero" stroke="#000" stroke-width=".7px"/> </g> <g transform="translate(2.7114)"> <path d="m168.3 124.83c-0.221 0-0.331 0.269-0.331 0.805v33.801c0 3.42 0.221 5.667 0.663 6.74 0.441 1.073 1.09 1.609 1.946 1.609h3.024c0.138 0 0.242 0.084 0.311 0.252 0.069 0.167 0.103 0.419 0.103 0.754v2.716c0 0.537-0.138 0.906-0.414 1.107-0.248 0.067-0.614 0.134-1.098 0.201-0.483 0.067-0.959 0.118-1.429 0.151-0.469 0.034-0.828 0.05-1.077 0.05-1.712 0-2.934-0.955-3.665-2.867-0.732-1.911-1.098-5.013-1.098-9.305v-35.108c0-0.604-0.124-0.906-0.373-0.906h-3.521c-0.248 0-0.373-0.268-0.373-0.804v-3.521c0-0.537 0.111-0.805 0.332-0.805h3.686c0.166 0 0.263-0.268 0.29-0.805l0.415-16.095c0-0.805 0.124-1.207 0.372-1.207h1.492c0.303 0 0.455 0.436 0.455 1.307v15.995c0 0.537 0.097 0.805 0.29 0.805h5.468c0.221 0 0.331 0.268 0.331 0.805v3.521c0 0.536-0.124 0.804-0.373 0.804h-5.426z" fill-rule="nonzero" stroke="#000" stroke-width=".7px"/> </g> <g transform="translate(2.7114)"> <path d="m179.4 173.02c-0.331 0-0.497-0.402-0.497-1.207v-72.329c0-0.738 0.138-1.107 0.414-1.107h1.782c0.276 0 0.414 0.336 0.414 1.006v27.162c0 0.335 0.034 0.536 0.103 0.603s0.159-0.033 0.27-0.302c0.994-1.81 1.898-3.319 2.713-4.526 0.814-1.208 1.629-2.113 2.444-2.717 0.814-0.603 1.691-0.905 2.63-0.905 2.182 0 3.839 1.375 4.971 4.125 1.132 2.749 1.698 6.404 1.698 10.965v37.925c0 0.871-0.166 1.307-0.497 1.307h-1.74c-0.165 0-0.29-0.1-0.373-0.301-0.082-0.202-0.124-0.503-0.124-0.906v-36.315c0-3.555-0.366-6.321-1.097-8.3-0.732-1.978-1.899-2.967-3.501-2.967-0.883 0-1.705 0.318-2.464 0.956-0.76 0.637-1.526 1.576-2.299 2.816-0.773 1.241-1.643 2.834-2.61 4.779v39.031c0 0.805-0.179 1.207-0.538 1.207h-1.699z" fill-rule="nonzero" stroke="#000" stroke-width=".7px"/> </g> </g> <g transform="matrix(.80638 0 0 .80638 452.53 65.421)" fill-rule="nonzero"> <path d="m79.32 36.98v150.76l15.68-13.2 6.59-156.31-22.27 18.75z" fill="url(#f)"/> <path d="m79.32 36.98-22.27-18.75 6.59 156.31 15.68 13.2v-150.76z" fill="url(#e)"/> <path d="m25.19 104.83 8.63 49.04 12.5-14.95-2.46-56.42-18.67 22.33z" fill="url(#d)"/> <path d="m25.19 104.83-25.19-14.59 16.97 53.86 16.85 9.77-8.63-49.04z" fill="url(#c)"/> <path d="M43.86,82.5L18.69,67.98L0,90.24L25.18,104.83L43.86,82.5Z" fill="#9c3"/> <path d="m134.82 78.69-9.97 56.5 15.58-9.04 19.57-62.05-25.18 14.59z" fill="url(#b)"/> <path d="m134.82 78.69-18.68-22.33-2.86 65 11.57 13.83 9.97-56.5z" fill="url(#a)"/> <path d="m160 64.1-18.69-22.26-25.17 14.52 18.67 22.33 25.19-14.59z" fill="#ffe113"/> <path d="M101.59,18.23L79.32,0L57.05,18.23L79.32,36.98L101.59,18.23Z" fill="#f3e600"/> </g> <defs> <linearGradient id="f" x2="1" gradientTransform="matrix(.84 -162.96 162.96 .84 89.64 184.81)" gradientUnits="userSpaceOnUse"><stop stop-color="#62d399" offset="0"/><stop stop-color="#acd842" offset=".51"/><stop stop-color="#d7db0a" offset=".9"/><stop stop-color="#d7db0a" offset="1"/></linearGradient> <linearGradient id="e" x2="1" gradientTransform="matrix(-1.6,-162.13,162.13,-1.6,69.68,178.9)" gradientUnits="userSpaceOnUse"><stop stop-color="#0ba398" offset="0"/><stop stop-color="#4ca352" offset=".5"/><stop stop-color="#76a30a" offset="1"/></linearGradient> <linearGradient id="d" x2="1" gradientTransform="matrix(-1.9,-67.98,67.98,-1.9,36.6,152.17)" gradientUnits="userSpaceOnUse"><stop stop-color="#36a382" offset="0"/><stop stop-color="#36a382" offset=".19"/><stop stop-color="#49a459" offset=".54"/><stop stop-color="#76a30b" offset="1"/></linearGradient> <linearGradient id="c" x2="1" gradientTransform="matrix(2.18,-62.38,62.38,2.18,15.82,153.24)" gradientUnits="userSpaceOnUse"><stop stop-color="#267880" offset="0"/><stop stop-color="#457a5c" offset=".51"/><stop stop-color="#717516" offset="1"/></linearGradient> <linearGradient id="b" x2="1" gradientTransform="matrix(13.85,-71.96,71.96,13.85,135.08,135.43)" gradientUnits="userSpaceOnUse"><stop stop-color="#b0d939" offset="0"/><stop stop-color="#eadb04" offset="1"/></linearGradient> <linearGradient id="a" x2="1" gradientTransform="matrix(26.159 -64.737 64.737 26.159 107.42 128.14)" gradientUnits="userSpaceOnUse"><stop stop-color="#74af52" offset="0"/><stop stop-color="#74af52" offset=".17"/><stop stop-color="#99be32" offset=".48"/><stop stop-color="#c0c40a" offset="1"/></linearGradient> </defs> </svg>`;
var madeWithNeedleBlob = btoa(madeWithNeedleSvgString);
var madeWithNeedleUrl = "data:image/svg+xml;charset=utf-8;base64," + madeWithNeedleBlob;
var needleLogoSvgString = `<svg viewBox="0 0 509 154" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2"><path d="M665.95 132.73v44.88l-10.56-8.4c-.8-.64-1.2-1.44-1.2-2.4v-32.4c0-6.48-4.12-9.72-12.36-9.72-2.16 0-4.18.4-6.06 1.2-1.88.8-3.54 1.8-4.98 3-1.44 1.2-2.56 2.5-3.36 3.9-.8 1.4-1.2 2.7-1.2 3.9v40.92l-10.68-8.4c-.72-.64-1.08-1.44-1.08-2.4v-53.76l10.92 8.52c.32.24.56.44.72.6.16.16.36.32.6.48.96-1.2 2.14-2.28 3.54-3.24 1.4-.96 2.92-1.76 4.56-2.4 1.64-.64 3.34-1.14 5.1-1.5 1.76-.36 3.44-.54 5.04-.54 1.44 0 2.92.04 4.44.12 1.52.08 2.84.28 3.96.6 4.56 1.12 7.8 3.12 9.72 6 1.92 2.88 2.88 6.56 2.88 11.04ZM732.38 146.05c0 .88.02 1.5.06 1.86.04.36-.02.98-.18 1.86h-7.08c-2.08 0-4.44-.02-7.08-.06-2.64-.04-5.36-.06-8.16-.06h-22.08c0 2.88.56 5.36 1.68 7.44 1.12 2.08 2.6 3.8 4.44 5.16 1.84 1.36 3.94 2.36 6.3 3 2.36.64 4.74.96 7.14.96 3.04 0 5.9-.76 8.58-2.28 2.68-1.52 4.94-3.52 6.78-6 .64.56 1.54 1.48 2.7 2.76 1.16 1.28 2.94 3.2 5.34 5.76-2.8 3.36-6.22 6.02-10.26 7.98-4.04 1.96-8.42 2.94-13.14 2.94-4.72 0-8.92-.64-12.84-1.92-3.92-1.28-7.32-3.24-10.2-5.88-2.88-2.64-5.12-5.98-6.72-10.02-1.6-4.04-2.4-8.82-2.4-14.34 0-4.96.66-9.42 1.98-13.38 1.32-3.96 3.22-7.32 5.7-10.08s5.44-4.9 8.88-6.42c3.44-1.52 7.32-2.28 11.64-2.28 5.76 0 10.52.88 14.28 2.64 3.76 1.76 6.72 4.16 8.88 7.2 2.16 3.04 3.66 6.54 4.5 10.5.84 3.96 1.26 8.18 1.26 12.66Zm-29.4-22.8c-2.16.16-4.16.72-6 1.68-1.84.96-3.42 2.2-4.74 3.72-1.32 1.52-2.36 3.28-3.12 5.28-.76 2-1.14 4.12-1.14 6.36h33.12c0-2-.22-4.06-.66-6.18-.44-2.12-1.3-4.02-2.58-5.7-1.28-1.68-3.1-3.02-5.46-4.02-2.36-1-5.5-1.38-9.42-1.14ZM795.93 146.05c0 .88.02 1.5.06 1.86.04.36-.02.98-.18 1.86h-7.08c-2.08 0-4.44-.02-7.08-.06-2.64-.04-5.36-.06-8.16-.06h-22.08c0 2.88.56 5.36 1.68 7.44 1.12 2.08 2.6 3.8 4.44 5.16 1.84 1.36 3.94 2.36 6.3 3 2.36.64 4.74.96 7.14.96 3.04 0 5.9-.76 8.58-2.28 2.68-1.52 4.94-3.52 6.78-6 .64.56 1.54 1.48 2.7 2.76 1.16 1.28 2.94 3.2 5.34 5.76-2.8 3.36-6.22 6.02-10.26 7.98-4.04 1.96-8.42 2.94-13.14 2.94-4.72 0-8.92-.64-12.84-1.92-3.92-1.28-7.32-3.24-10.2-5.88-2.88-2.64-5.12-5.98-6.72-10.02-1.6-4.04-2.4-8.82-2.4-14.34 0-4.96.66-9.42 1.98-13.38 1.32-3.96 3.22-7.32 5.7-10.08s5.44-4.9 8.88-6.42c3.44-1.52 7.32-2.28 11.64-2.28 5.76 0 10.52.88 14.28 2.64 3.76 1.76 6.72 4.16 8.88 7.2 2.16 3.04 3.66 6.54 4.5 10.5.84 3.96 1.26 8.18 1.26 12.66Zm-29.4-22.8c-2.16.16-4.16.72-6 1.68-1.84.96-3.42 2.2-4.74 3.72-1.32 1.52-2.36 3.28-3.12 5.28-.76 2-1.14 4.12-1.14 6.36h33.12c0-2-.22-4.06-.66-6.18-.44-2.12-1.3-4.02-2.58-5.7-1.28-1.68-3.1-3.02-5.46-4.02-2.36-1-5.5-1.38-9.42-1.14ZM858.57 97.21c.64.48.96 1.16.96 2.04v74.88c-.08 1.04-.12 2.12-.12 3.24-1.84-1.52-3.56-2.92-5.16-4.2-1.36-1.12-2.66-2.18-3.9-3.18-1.24-1-2.06-1.66-2.46-1.98-1.76 2.48-4.26 4.44-7.5 5.88-3.24 1.44-7.02 2.16-11.34 2.16-3.84 0-7.4-.7-10.68-2.1-3.28-1.4-6.14-3.44-8.58-6.12-2.44-2.68-4.34-5.94-5.7-9.78-1.36-3.84-2.04-8.16-2.04-12.96 0-4.32.78-8.34 2.34-12.06 1.56-3.72 3.6-6.92 6.12-9.6 2.52-2.68 5.38-4.78 8.58-6.3 3.2-1.52 6.48-2.28 9.84-2.28 2.56 0 4.82.22 6.78.66 1.96.44 3.68 1.06 5.16 1.86s2.78 1.74 3.9 2.82a35.92 35.92 0 0 1 3.12 3.42V88.57l10.68 8.64Zm-27.96 67.92c3.6 0 6.52-.68 8.76-2.04 2.24-1.36 3.98-3.06 5.22-5.1a20.5 20.5 0 0 0 2.58-6.54c.48-2.32.72-4.44.72-6.36v-1.2c0-1.12-.22-2.7-.66-4.74-.44-2.04-1.28-4.06-2.52-6.06s-3-3.7-5.28-5.1c-2.28-1.4-5.22-2.02-8.82-1.86-3.44 0-6.26.74-8.46 2.22-2.2 1.48-3.96 3.26-5.28 5.34-1.32 2.08-2.24 4.2-2.76 6.36-.52 2.16-.78 3.92-.78 5.28 0 1.84.24 3.92.72 6.24.48 2.32 1.36 4.48 2.64 6.48s3.04 3.68 5.28 5.04c2.24 1.36 5.12 2.04 8.64 2.04ZM882.81 97.09c.64.48.96 1.12.96 1.92l-.12 41.04v37.08l-10.56-8.4c-.72-.64-1.08-1.44-1.08-2.4V88.45l10.8 8.64ZM950.36 146.05c0 .88.02 1.5.06 1.86.04.36-.02.98-.18 1.86h-7.08c-2.08 0-4.44-.02-7.08-.06-2.64-.04-5.36-.06-8.16-.06h-22.08c0 2.88.56 5.36 1.68 7.44 1.12 2.08 2.6 3.8 4.44 5.16 1.84 1.36 3.94 2.36 6.3 3 2.36.64 4.74.96 7.14.96 3.04 0 5.9-.76 8.58-2.28 2.68-1.52 4.94-3.52 6.78-6 .64.56 1.54 1.48 2.7 2.76 1.16 1.28 2.94 3.2 5.34 5.76-2.8 3.36-6.22 6.02-10.26 7.98-4.04 1.96-8.42 2.94-13.14 2.94-4.72 0-8.92-.64-12.84-1.92-3.92-1.28-7.32-3.24-10.2-5.88-2.88-2.64-5.12-5.98-6.72-10.02-1.6-4.04-2.4-8.82-2.4-14.34 0-4.96.66-9.42 1.98-13.38 1.32-3.96 3.22-7.32 5.7-10.08s5.44-4.9 8.88-6.42c3.44-1.52 7.32-2.28 11.64-2.28 5.76 0 10.52.88 14.28 2.64 3.76 1.76 6.72 4.16 8.88 7.2 2.16 3.04 3.66 6.54 4.5 10.5.84 3.96 1.26 8.18 1.26 12.66Zm-29.4-22.8c-2.16.16-4.16.72-6 1.68-1.84.96-3.42 2.2-4.74 3.72-1.32 1.52-2.36 3.28-3.12 5.28-.76 2-1.14 4.12-1.14 6.36h33.12c0-2-.22-4.06-.66-6.18-.44-2.12-1.3-4.02-2.58-5.7-1.28-1.68-3.1-3.02-5.46-4.02-2.36-1-5.5-1.38-9.42-1.14Z" style="fill-rule:nonzero" transform="translate(-452.406 -63.709) scale(1.00797)"/><path d="M79.32 36.98v150.76L95 174.54l6.59-156.31-22.27 18.75Z" style="fill:url(#a);fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><path d="M79.32 36.98 57.05 18.23l6.59 156.31 15.68 13.2V36.98Z" style="fill:url(#b);fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><path d="m25.19 104.83 8.63 49.04 12.5-14.95-2.46-56.42-18.67 22.33Z" style="fill:url(#c);fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><path d="M25.19 104.83 0 90.24l16.97 53.86 16.85 9.77-8.63-49.04Z" style="fill:url(#d);fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><path d="M43.86 82.5 18.69 67.98 0 90.24l25.18 14.59L43.86 82.5Z" style="fill:#9c3;fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><path d="m134.82 78.69-9.97 56.5 15.58-9.04L160 64.1l-25.18 14.59Z" style="fill:url(#e);fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><path d="m134.82 78.69-18.68-22.33-2.86 65 11.57 13.83 9.97-56.5Z" style="fill:url(#f);fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><path d="m160 64.1-18.69-22.26-25.17 14.52 18.67 22.33L160 64.1Z" style="fill:#ffe113;fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><path d="M101.59 18.23 79.32 0 57.05 18.23l22.27 18.75 22.27-18.75Z" style="fill:#f3e600;fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><defs><linearGradient id="a" x1="0" y1="0" x2="1" y2="0" gradientUnits="userSpaceOnUse" gradientTransform="matrix(.84 -162.96 162.96 .84 89.64 184.81)"><stop offset="0" style="stop-color:#62d399;stop-opacity:1"/><stop offset=".51" style="stop-color:#acd842;stop-opacity:1"/><stop offset=".9" style="stop-color:#d7db0a;stop-opacity:1"/><stop offset="1" style="stop-color:#d7db0a;stop-opacity:1"/></linearGradient><linearGradient id="b" x1="0" y1="0" x2="1" y2="0" gradientUnits="userSpaceOnUse" gradientTransform="rotate(-90.565 123.412 54.953) scale(162.14)"><stop offset="0" style="stop-color:#0ba398;stop-opacity:1"/><stop offset=".5" style="stop-color:#4ca352;stop-opacity:1"/><stop offset="1" style="stop-color:#76a30a;stop-opacity:1"/></linearGradient><linearGradient id="c" x1="0" y1="0" x2="1" y2="0" gradientUnits="userSpaceOnUse" gradientTransform="scale(-68) rotate(88.4 .881 -1.396)"><stop offset="0" style="stop-color:#36a382;stop-opacity:1"/><stop offset=".19" style="stop-color:#36a382;stop-opacity:1"/><stop offset=".54" style="stop-color:#49a459;stop-opacity:1"/><stop offset="1" style="stop-color:#76a30b;stop-opacity:1"/></linearGradient><linearGradient id="d" x1="0" y1="0" x2="1" y2="0" gradientUnits="userSpaceOnUse" gradientTransform="rotate(-88 87.255 68.431) scale(62.42)"><stop offset="0" style="stop-color:#267880;stop-opacity:1"/><stop offset=".51" style="stop-color:#457a5c;stop-opacity:1"/><stop offset="1" style="stop-color:#717516;stop-opacity:1"/></linearGradient><linearGradient id="e" x1="0" y1="0" x2="1" y2="0" gradientUnits="userSpaceOnUse" gradientTransform="rotate(-79.1 149.53 -14.065) scale(73.28)"><stop offset="0" style="stop-color:#b0d939;stop-opacity:1"/><stop offset="1" style="stop-color:#eadb04;stop-opacity:1"/></linearGradient><linearGradient id="f" x1="0" y1="0" x2="1" y2="0" gradientUnits="userSpaceOnUse" gradientTransform="rotate(-67.997 148.705 -15.558) scale(69.8226)"><stop offset="0" style="stop-color:#74af52;stop-opacity:1"/><stop offset=".17" style="stop-color:#74af52;stop-opacity:1"/><stop offset=".48" style="stop-color:#99be32;stop-opacity:1"/><stop offset="1" style="stop-color:#c0c40a;stop-opacity:1"/></linearGradient></defs></svg>`;
var needleLogoBlob = btoa(needleLogoSvgString);
var needleLogoUrl = "data:image/svg+xml;charset=utf-8;base64," + needleLogoBlob;
var needleLogoSVG = needleLogoUrl;

// node_modules/postprocessing/build/index.js
var MILLISECONDS_TO_SECONDS = 1 / 1e3;
var SECONDS_TO_MILLISECONDS = 1e3;
var Timer = class {
  /**
   * Constructs a new timer.
   */
  constructor() {
    this.startTime = performance.now();
    this.previousTime = 0;
    this.currentTime = 0;
    this._delta = 0;
    this._elapsed = 0;
    this._fixedDelta = 1e3 / 60;
    this.timescale = 1;
    this.useFixedDelta = false;
    this._autoReset = false;
  }
  /**
   * Enables or disables auto reset based on page visibility.
   *
   * If enabled, the timer will be reset when the page becomes visible. This effectively pauses the timer when the page
   * is hidden. Has no effect if the API is not supported.
   *
   * @type {Boolean}
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API
   */
  get autoReset() {
    return this._autoReset;
  }
  set autoReset(value) {
    if (typeof document !== "undefined" && document.hidden !== void 0) {
      if (value) {
        document.addEventListener("visibilitychange", this);
      } else {
        document.removeEventListener("visibilitychange", this);
      }
      this._autoReset = value;
    }
  }
  get delta() {
    return this._delta * MILLISECONDS_TO_SECONDS;
  }
  get fixedDelta() {
    return this._fixedDelta * MILLISECONDS_TO_SECONDS;
  }
  set fixedDelta(value) {
    this._fixedDelta = value * SECONDS_TO_MILLISECONDS;
  }
  get elapsed() {
    return this._elapsed * MILLISECONDS_TO_SECONDS;
  }
  /**
   * Updates this timer.
   *
   * @param {Boolean} [timestamp] - The current time in milliseconds.
   */
  update(timestamp) {
    if (this.useFixedDelta) {
      this._delta = this.fixedDelta;
    } else {
      this.previousTime = this.currentTime;
      this.currentTime = (timestamp !== void 0 ? timestamp : performance.now()) - this.startTime;
      this._delta = this.currentTime - this.previousTime;
    }
    this._delta *= this.timescale;
    this._elapsed += this._delta;
  }
  /**
   * Resets this timer.
   */
  reset() {
    this._delta = 0;
    this._elapsed = 0;
    this.currentTime = performance.now() - this.startTime;
  }
  getDelta() {
    return this.delta;
  }
  getElapsed() {
    return this.elapsed;
  }
  handleEvent(e) {
    if (!document.hidden) {
      this.currentTime = performance.now() - this.startTime;
    }
  }
  dispose() {
    this.autoReset = false;
  }
};
var fullscreenGeometry = (() => {
  const vertices = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]);
  const uvs = new Float32Array([0, 0, 2, 0, 0, 2]);
  const geometry = new BufferGeometry();
  geometry.setAttribute("position", new BufferAttribute2(vertices, 3));
  geometry.setAttribute("uv", new BufferAttribute2(uvs, 2));
  return geometry;
})();
var Pass = class _Pass {
  /**
   * A shared fullscreen triangle.
   *
   * The screen size is 2x2 units (NDC). A triangle needs to be 4x4 units to fill the screen.
   * @see https://michaldrobot.com/2014/04/01/gcn-execution-patterns-in-full-screen-passes/
   * @type {BufferGeometry}
   * @internal
   */
  static get fullscreenGeometry() {
    return fullscreenGeometry;
  }
  /**
   * Constructs a new pass.
   *
   * @param {String} [name] - The name of this pass. Does not have to be unique.
   * @param {Scene} [scene] - The scene to render. The default scene contains a single mesh that fills the screen.
   * @param {Camera} [camera] - A camera. Fullscreen effect passes don't require a camera.
   */
  constructor(name = "Pass", scene = new Scene(), camera = new Camera()) {
    this.name = name;
    this.renderer = null;
    this.scene = scene;
    this.camera = camera;
    this.screen = null;
    this.rtt = true;
    this.needsSwap = true;
    this.needsDepthTexture = false;
    this.enabled = true;
  }
  /**
   * Sets the render to screen flag.
   *
   * If this flag is changed, the fullscreen material will be updated as well.
   *
   * @type {Boolean}
   */
  get renderToScreen() {
    return !this.rtt;
  }
  set renderToScreen(value) {
    if (this.rtt === value) {
      const material = this.fullscreenMaterial;
      if (material !== null) {
        material.needsUpdate = true;
      }
      this.rtt = !value;
    }
  }
  /**
   * Sets the main scene.
   *
   * @type {Scene}
   */
  set mainScene(value) {
  }
  /**
   * Sets the main camera.
   *
   * @type {Camera}
   */
  set mainCamera(value) {
  }
  /**
   * Sets the renderer
   *
   * @deprecated
   * @param {WebGLRenderer} renderer - The renderer.
   */
  setRenderer(renderer) {
    this.renderer = renderer;
  }
  /**
   * Indicates whether this pass is enabled.
   *
   * @deprecated Use enabled instead.
   * @return {Boolean} Whether this pass is enabled.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Enables or disables this pass.
   *
   * @deprecated Use enabled instead.
   * @param {Boolean} value - Whether the pass should be enabled.
   */
  setEnabled(value) {
    this.enabled = value;
  }
  /**
   * The fullscreen material.
   *
   * @type {Material}
   */
  get fullscreenMaterial() {
    return this.screen !== null ? this.screen.material : null;
  }
  set fullscreenMaterial(value) {
    let screen2 = this.screen;
    if (screen2 !== null) {
      screen2.material = value;
    } else {
      screen2 = new Mesh(_Pass.fullscreenGeometry, value);
      screen2.frustumCulled = false;
      if (this.scene === null) {
        this.scene = new Scene();
      }
      this.scene.add(screen2);
      this.screen = screen2;
    }
  }
  /**
   * Returns the current fullscreen material.
   *
   * @deprecated Use fullscreenMaterial instead.
   * @return {Material} The current fullscreen material, or null if there is none.
   */
  getFullscreenMaterial() {
    return this.fullscreenMaterial;
  }
  /**
   * Sets the fullscreen material.
   *
   * @deprecated Use fullscreenMaterial instead.
   * @protected
   * @param {Material} value - A fullscreen material.
   */
  setFullscreenMaterial(value) {
    this.fullscreenMaterial = value;
  }
  /**
   * Returns the current depth texture.
   *
   * @return {Texture} The current depth texture, or null if there is none.
   */
  getDepthTexture() {
    return null;
  }
  /**
   * Sets the depth texture.
   *
   * This method will be called automatically by the {@link EffectComposer}.
   * You may override this method if your pass relies on the depth information of a preceding {@link RenderPass}.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategy} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
  }
  /**
   * Renders this pass.
   *
   * This is an abstract method that must be overridden.
   *
   * @abstract
   * @throws {Error} An error is thrown if the method is not overridden.
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    throw new Error("Render method not implemented!");
  }
  /**
   * Sets the size.
   *
   * You may override this method if you want to be informed about the size of the backbuffer/canvas.
   * This method is called before {@link initialize} and every time the size of the {@link EffectComposer} changes.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
  }
  /**
   * Performs initialization tasks.
   *
   * This method is called when this pass is added to an {@link EffectComposer}.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
  }
  /**
   * Performs a shallow search for disposable properties and deletes them.
   *
   * The {@link EffectComposer} calls this method when it is being destroyed. You can use it independently to free
   * memory when you're certain that you don't need this pass anymore.
   */
  dispose() {
    for (const key of Object.keys(this)) {
      const property = this[key];
      const isDisposable = property instanceof WebGLRenderTarget || property instanceof Material || property instanceof Texture || property instanceof _Pass;
      if (isDisposable) {
        this[key].dispose();
      }
    }
    if (this.fullscreenMaterial !== null) {
      this.fullscreenMaterial.dispose();
    }
  }
};
var ClearMaskPass = class extends Pass {
  /**
   * Constructs a new clear mask pass.
   */
  constructor() {
    super("ClearMaskPass", null, null);
    this.needsSwap = false;
  }
  /**
   * Disables the global stencil test.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const stencil = renderer.state.buffers.stencil;
    stencil.setLocked(false);
    stencil.setTest(false);
  }
};
var copy_default = "#include <common>\n#include <dithering_pars_fragment>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;\n#include <colorspace_fragment>\n#include <dithering_fragment>\n}";
var common_default = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}";
var CopyMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new copy material.
   */
  constructor() {
    super({
      name: "CopyMaterial",
      uniforms: {
        inputBuffer: new Uniform$1(null),
        opacity: new Uniform$1(1)
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: copy_default,
      vertexShader: common_default
    });
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Number} value - The buffer.
   */
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Returns the opacity.
   *
   * @deprecated Use opacity instead.
   * @return {Number} The opacity.
   */
  getOpacity(value) {
    return this.uniforms.opacity.value;
  }
  /**
   * Sets the opacity.
   *
   * @deprecated Use opacity instead.
   * @param {Number} value - The opacity.
   */
  setOpacity(value) {
    this.uniforms.opacity.value = value;
  }
};
var CopyPass = class extends Pass {
  /**
   * Constructs a new save pass.
   *
   * @param {WebGLRenderTarget} [renderTarget] - A render target.
   * @param {Boolean} [autoResize=true] - Whether the render target size should be updated automatically.
   */
  constructor(renderTarget2, autoResize = true) {
    super("CopyPass");
    this.fullscreenMaterial = new CopyMaterial();
    this.needsSwap = false;
    this.renderTarget = renderTarget2;
    if (renderTarget2 === void 0) {
      this.renderTarget = new WebGLRenderTarget(1, 1, {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        stencilBuffer: false,
        depthBuffer: false
      });
      this.renderTarget.texture.name = "CopyPass.Target";
    }
    this.autoResize = autoResize;
  }
  /**
   * Enables or disables auto resizing of the render target.
   *
   * @deprecated Use autoResize instead.
   * @type {Boolean}
   */
  get resize() {
    return this.autoResize;
  }
  set resize(value) {
    this.autoResize = value;
  }
  /**
   * The output texture.
   *
   * @type {Texture}
   */
  get texture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the output texture.
   *
   * @deprecated Use texture instead.
   * @return {Texture} The texture.
   */
  getTexture() {
    return this.renderTarget.texture;
  }
  /**
   * Enables or disables auto resizing of the render target.
   *
   * @deprecated Use autoResize instead.
   * @param {Boolean} value - Whether the render target size should be updated automatically.
   */
  setAutoResizeEnabled(value) {
    this.autoResize = value;
  }
  /**
   * Saves the input buffer.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    this.fullscreenMaterial.inputBuffer = inputBuffer.texture;
    renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);
    renderer.render(this.scene, this.camera);
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    if (this.autoResize) {
      this.renderTarget.setSize(width, height);
    }
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - A renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0) {
      this.renderTarget.texture.type = frameBufferType;
      if (frameBufferType !== UnsignedByteType) {
        this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
      } else if (renderer !== null && renderer.outputColorSpace === SRGBColorSpace) {
        this.renderTarget.texture.colorSpace = SRGBColorSpace;
      }
    }
  }
};
var color = new Color();
var ClearPass = class extends Pass {
  /**
   * Constructs a new clear pass.
   *
   * @param {Boolean} [color=true] - Determines whether the color buffer should be cleared.
   * @param {Boolean} [depth=true] - Determines whether the depth buffer should be cleared.
   * @param {Boolean} [stencil=false] - Determines whether the stencil buffer should be cleared.
   */
  constructor(color2 = true, depth = true, stencil = false) {
    super("ClearPass", null, null);
    this.needsSwap = false;
    this.color = color2;
    this.depth = depth;
    this.stencil = stencil;
    this.overrideClearColor = null;
    this.overrideClearAlpha = -1;
  }
  /**
   * Sets the clear flags.
   *
   * @param {Boolean} color - Whether the color buffer should be cleared.
   * @param {Boolean} depth - Whether the depth buffer should be cleared.
   * @param {Boolean} stencil - Whether the stencil buffer should be cleared.
   */
  setClearFlags(color2, depth, stencil) {
    this.color = color2;
    this.depth = depth;
    this.stencil = stencil;
  }
  /**
   * Returns the override clear color. Default is null.
   *
   * @deprecated Use overrideClearColor instead.
   * @return {Color} The clear color.
   */
  getOverrideClearColor() {
    return this.overrideClearColor;
  }
  /**
   * Sets the override clear color.
   *
   * @deprecated Use overrideClearColor instead.
   * @param {Color} value - The clear color.
   */
  setOverrideClearColor(value) {
    this.overrideClearColor = value;
  }
  /**
   * Returns the override clear alpha. Default is -1.
   *
   * @deprecated Use overrideClearAlpha instead.
   * @return {Number} The clear alpha.
   */
  getOverrideClearAlpha() {
    return this.overrideClearAlpha;
  }
  /**
   * Sets the override clear alpha.
   *
   * @deprecated Use overrideClearAlpha instead.
   * @param {Number} value - The clear alpha.
   */
  setOverrideClearAlpha(value) {
    this.overrideClearAlpha = value;
  }
  /**
   * Clears the input buffer or the screen.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const overrideClearColor = this.overrideClearColor;
    const overrideClearAlpha = this.overrideClearAlpha;
    const clearAlpha = renderer.getClearAlpha();
    const hasOverrideClearColor = overrideClearColor !== null;
    const hasOverrideClearAlpha = overrideClearAlpha >= 0;
    if (hasOverrideClearColor) {
      renderer.getClearColor(color);
      renderer.setClearColor(overrideClearColor, hasOverrideClearAlpha ? overrideClearAlpha : clearAlpha);
    } else if (hasOverrideClearAlpha) {
      renderer.setClearAlpha(overrideClearAlpha);
    }
    renderer.setRenderTarget(this.renderToScreen ? null : inputBuffer);
    renderer.clear(this.color, this.depth, this.stencil);
    if (hasOverrideClearColor) {
      renderer.setClearColor(color, clearAlpha);
    } else if (hasOverrideClearAlpha) {
      renderer.setClearAlpha(clearAlpha);
    }
  }
};
var MaskPass = class extends Pass {
  /**
   * Constructs a new mask pass.
   *
   * @param {Scene} scene - The scene to render.
   * @param {Camera} camera - The camera to use.
   */
  constructor(scene, camera) {
    super("MaskPass", scene, camera);
    this.needsSwap = false;
    this.clearPass = new ClearPass(false, false, true);
    this.inverse = false;
  }
  set mainScene(value) {
    this.scene = value;
  }
  set mainCamera(value) {
    this.camera = value;
  }
  /**
   * Indicates whether the mask should be inverted.
   *
   * @type {Boolean}
   */
  get inverted() {
    return this.inverse;
  }
  set inverted(value) {
    this.inverse = value;
  }
  /**
   * Indicates whether this pass should clear the stencil buffer.
   *
   * @type {Boolean}
   * @deprecated Use clearPass.enabled instead.
   */
  get clear() {
    return this.clearPass.enabled;
  }
  set clear(value) {
    this.clearPass.enabled = value;
  }
  /**
   * Returns the internal clear pass.
   *
   * @deprecated Use clearPass.enabled instead.
   * @return {ClearPass} The clear pass.
   */
  getClearPass() {
    return this.clearPass;
  }
  /**
   * Indicates whether the mask is inverted.
   *
   * @deprecated Use inverted instead.
   * @return {Boolean} Whether the mask is inverted.
   */
  isInverted() {
    return this.inverted;
  }
  /**
   * Enables or disable mask inversion.
   *
   * @deprecated Use inverted instead.
   * @param {Boolean} value - Whether the mask should be inverted.
   */
  setInverted(value) {
    this.inverted = value;
  }
  /**
   * Renders the effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const context = renderer.getContext();
    const buffers = renderer.state.buffers;
    const scene = this.scene;
    const camera = this.camera;
    const clearPass = this.clearPass;
    const writeValue = this.inverted ? 0 : 1;
    const clearValue = 1 - writeValue;
    buffers.color.setMask(false);
    buffers.depth.setMask(false);
    buffers.color.setLocked(true);
    buffers.depth.setLocked(true);
    buffers.stencil.setTest(true);
    buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
    buffers.stencil.setFunc(context.ALWAYS, writeValue, 4294967295);
    buffers.stencil.setClear(clearValue);
    buffers.stencil.setLocked(true);
    if (this.clearPass.enabled) {
      if (this.renderToScreen) {
        clearPass.render(renderer, null);
      } else {
        clearPass.render(renderer, inputBuffer);
        clearPass.render(renderer, outputBuffer);
      }
    }
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      renderer.render(scene, camera);
    } else {
      renderer.setRenderTarget(inputBuffer);
      renderer.render(scene, camera);
      renderer.setRenderTarget(outputBuffer);
      renderer.render(scene, camera);
    }
    buffers.color.setLocked(false);
    buffers.depth.setLocked(false);
    buffers.stencil.setLocked(false);
    buffers.stencil.setFunc(context.EQUAL, 1, 4294967295);
    buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
    buffers.stencil.setLocked(true);
  }
};
var EffectComposer = class {
  /**
   * Constructs a new effect composer.
   *
   * @param {WebGLRenderer} renderer - The renderer that should be used.
   * @param {Object} [options] - The options.
   * @param {Boolean} [options.depthBuffer=true] - Whether the main render targets should have a depth buffer.
   * @param {Boolean} [options.stencilBuffer=false] - Whether the main render targets should have a stencil buffer.
   * @param {Boolean} [options.alpha] - Deprecated. Buffers are always RGBA since three r137.
   * @param {Number} [options.multisampling=0] - The number of samples used for multisample antialiasing. Requires WebGL 2.
   * @param {Number} [options.frameBufferType] - The type of the internal frame buffers. It's recommended to use HalfFloatType if possible.
   */
  constructor(renderer = null, {
    depthBuffer = true,
    stencilBuffer = false,
    multisampling = 0,
    frameBufferType
  } = {}) {
    this.renderer = null;
    this.inputBuffer = this.createBuffer(depthBuffer, stencilBuffer, frameBufferType, multisampling);
    this.outputBuffer = this.inputBuffer.clone();
    this.copyPass = new CopyPass();
    this.depthTexture = null;
    this.passes = [];
    this.timer = new Timer();
    this.autoRenderToScreen = true;
    this.setRenderer(renderer);
  }
  /**
   * The current amount of samples used for multisample anti-aliasing.
   *
   * @type {Number}
   */
  get multisampling() {
    return this.inputBuffer.samples || 0;
  }
  /**
   * Sets the amount of MSAA samples.
   *
   * Requires WebGL 2. Set to zero to disable multisampling.
   *
   * @type {Number}
   */
  set multisampling(value) {
    const buffer2 = this.inputBuffer;
    const multisampling = this.multisampling;
    if (multisampling > 0 && value > 0) {
      this.inputBuffer.samples = value;
      this.outputBuffer.samples = value;
      this.inputBuffer.dispose();
      this.outputBuffer.dispose();
    } else if (multisampling !== value) {
      this.inputBuffer.dispose();
      this.outputBuffer.dispose();
      this.inputBuffer = this.createBuffer(
        buffer2.depthBuffer,
        buffer2.stencilBuffer,
        buffer2.texture.type,
        value
      );
      this.inputBuffer.depthTexture = this.depthTexture;
      this.outputBuffer = this.inputBuffer.clone();
    }
  }
  /**
   * Returns the internal timer.
   *
   * @return {Timer} The timer.
   */
  getTimer() {
    return this.timer;
  }
  /**
   * Returns the renderer.
   *
   * @return {WebGLRenderer} The renderer.
   */
  getRenderer() {
    return this.renderer;
  }
  /**
   * Sets the renderer.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   */
  setRenderer(renderer) {
    this.renderer = renderer;
    if (renderer !== null) {
      const size = renderer.getSize(new Vector2());
      const alpha = renderer.getContext().getContextAttributes().alpha;
      const frameBufferType = this.inputBuffer.texture.type;
      if (frameBufferType === UnsignedByteType && renderer.outputColorSpace === SRGBColorSpace) {
        this.inputBuffer.texture.colorSpace = SRGBColorSpace;
        this.outputBuffer.texture.colorSpace = SRGBColorSpace;
        this.inputBuffer.dispose();
        this.outputBuffer.dispose();
      }
      renderer.autoClear = false;
      this.setSize(size.width, size.height);
      for (const pass of this.passes) {
        pass.initialize(renderer, alpha, frameBufferType);
      }
    }
  }
  /**
   * Replaces the current renderer with the given one.
   *
   * The auto clear mechanism of the provided renderer will be disabled. If the new render size differs from the
   * previous one, all passes will be updated.
   *
   * By default, the DOM element of the current renderer will automatically be removed from its parent node and the DOM
   * element of the new renderer will take its place.
   *
   * @deprecated Use setRenderer instead.
   * @param {WebGLRenderer} renderer - The new renderer.
   * @param {Boolean} updateDOM - Indicates whether the old canvas should be replaced by the new one in the DOM.
   * @return {WebGLRenderer} The old renderer.
   */
  replaceRenderer(renderer, updateDOM = true) {
    const oldRenderer = this.renderer;
    const parent = oldRenderer.domElement.parentNode;
    this.setRenderer(renderer);
    if (updateDOM && parent !== null) {
      parent.removeChild(oldRenderer.domElement);
      parent.appendChild(renderer.domElement);
    }
    return oldRenderer;
  }
  /**
   * Creates a depth texture attachment that will be provided to all passes.
   *
   * Note: When a shader reads from a depth texture and writes to a render target that uses the same depth texture
   * attachment, the depth information will be lost. This happens even if `depthWrite` is disabled.
   *
   * @private
   * @return {DepthTexture} The depth texture.
   */
  createDepthTexture() {
    const depthTexture = this.depthTexture = new DepthTexture();
    this.inputBuffer.depthTexture = depthTexture;
    this.inputBuffer.dispose();
    if (this.inputBuffer.stencilBuffer) {
      depthTexture.format = DepthStencilFormat;
      depthTexture.type = UnsignedInt248Type;
    } else {
      depthTexture.type = UnsignedIntType;
    }
    return depthTexture;
  }
  /**
   * Deletes the current depth texture.
   *
   * @private
   */
  deleteDepthTexture() {
    if (this.depthTexture !== null) {
      this.depthTexture.dispose();
      this.depthTexture = null;
      this.inputBuffer.depthTexture = null;
      this.inputBuffer.dispose();
      for (const pass of this.passes) {
        pass.setDepthTexture(null);
      }
    }
  }
  /**
   * Creates a new render target.
   *
   * @deprecated Create buffers manually via WebGLRenderTarget instead.
   * @param {Boolean} depthBuffer - Whether the render target should have a depth buffer.
   * @param {Boolean} stencilBuffer - Whether the render target should have a stencil buffer.
   * @param {Number} type - The frame buffer type.
   * @param {Number} multisampling - The number of samples to use for antialiasing.
   * @return {WebGLRenderTarget} A new render target that equals the renderer's canvas.
   */
  createBuffer(depthBuffer, stencilBuffer, type, multisampling) {
    const renderer = this.renderer;
    const size = renderer === null ? new Vector2() : renderer.getDrawingBufferSize(new Vector2());
    const options = {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      stencilBuffer,
      depthBuffer,
      type
    };
    const renderTarget2 = new WebGLRenderTarget(size.width, size.height, options);
    if (multisampling > 0) {
      renderTarget2.ignoreDepthForMultisampleCopy = false;
      renderTarget2.samples = multisampling;
    }
    if (type === UnsignedByteType && renderer !== null && renderer.outputColorSpace === SRGBColorSpace) {
      renderTarget2.texture.colorSpace = SRGBColorSpace;
    }
    renderTarget2.texture.name = "EffectComposer.Buffer";
    renderTarget2.texture.generateMipmaps = false;
    return renderTarget2;
  }
  /**
   * Can be used to change the main scene for all registered passes and effects.
   *
   * @param {Scene} scene - The scene.
   */
  setMainScene(scene) {
    for (const pass of this.passes) {
      pass.mainScene = scene;
    }
  }
  /**
   * Can be used to change the main camera for all registered passes and effects.
   *
   * @param {Camera} camera - The camera.
   */
  setMainCamera(camera) {
    for (const pass of this.passes) {
      pass.mainCamera = camera;
    }
  }
  /**
   * Adds a pass, optionally at a specific index.
   *
   * @param {Pass} pass - A new pass.
   * @param {Number} [index] - An index at which the pass should be inserted.
   */
  addPass(pass, index) {
    const passes = this.passes;
    const renderer = this.renderer;
    const drawingBufferSize = renderer.getDrawingBufferSize(new Vector2());
    const alpha = renderer.getContext().getContextAttributes().alpha;
    const frameBufferType = this.inputBuffer.texture.type;
    pass.setRenderer(renderer);
    pass.setSize(drawingBufferSize.width, drawingBufferSize.height);
    pass.initialize(renderer, alpha, frameBufferType);
    if (this.autoRenderToScreen) {
      if (passes.length > 0) {
        passes[passes.length - 1].renderToScreen = false;
      }
      if (pass.renderToScreen) {
        this.autoRenderToScreen = false;
      }
    }
    if (index !== void 0) {
      passes.splice(index, 0, pass);
    } else {
      passes.push(pass);
    }
    if (this.autoRenderToScreen) {
      passes[passes.length - 1].renderToScreen = true;
    }
    if (pass.needsDepthTexture || this.depthTexture !== null) {
      if (this.depthTexture === null) {
        const depthTexture = this.createDepthTexture();
        for (pass of passes) {
          pass.setDepthTexture(depthTexture);
        }
      } else {
        pass.setDepthTexture(this.depthTexture);
      }
    }
  }
  /**
   * Removes a pass.
   *
   * @param {Pass} pass - The pass.
   */
  removePass(pass) {
    const passes = this.passes;
    const index = passes.indexOf(pass);
    const exists = index !== -1;
    const removed = exists && passes.splice(index, 1).length > 0;
    if (removed) {
      if (this.depthTexture !== null) {
        const reducer = (a, b) => a || b.needsDepthTexture;
        const depthTextureRequired = passes.reduce(reducer, false);
        if (!depthTextureRequired) {
          if (pass.getDepthTexture() === this.depthTexture) {
            pass.setDepthTexture(null);
          }
          this.deleteDepthTexture();
        }
      }
      if (this.autoRenderToScreen) {
        if (index === passes.length) {
          pass.renderToScreen = false;
          if (passes.length > 0) {
            passes[passes.length - 1].renderToScreen = true;
          }
        }
      }
    }
  }
  /**
   * Removes all passes.
   */
  removeAllPasses() {
    const passes = this.passes;
    this.deleteDepthTexture();
    if (passes.length > 0) {
      if (this.autoRenderToScreen) {
        passes[passes.length - 1].renderToScreen = false;
      }
      this.passes = [];
    }
  }
  /**
   * Renders all enabled passes in the order in which they were added.
   *
   * @param {Number} [deltaTime] - The time since the last frame in seconds.
   */
  render(deltaTime) {
    const renderer = this.renderer;
    const copyPass = this.copyPass;
    let inputBuffer = this.inputBuffer;
    let outputBuffer = this.outputBuffer;
    let stencilTest = false;
    let context, stencil, buffer2;
    if (deltaTime === void 0) {
      this.timer.update();
      deltaTime = this.timer.getDelta();
    }
    for (const pass of this.passes) {
      if (pass.enabled) {
        pass.render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest);
        if (pass.needsSwap) {
          if (stencilTest) {
            copyPass.renderToScreen = pass.renderToScreen;
            context = renderer.getContext();
            stencil = renderer.state.buffers.stencil;
            stencil.setFunc(context.NOTEQUAL, 1, 4294967295);
            copyPass.render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest);
            stencil.setFunc(context.EQUAL, 1, 4294967295);
          }
          buffer2 = inputBuffer;
          inputBuffer = outputBuffer;
          outputBuffer = buffer2;
        }
        if (pass instanceof MaskPass) {
          stencilTest = true;
        } else if (pass instanceof ClearMaskPass) {
          stencilTest = false;
        }
      }
    }
  }
  /**
   * Sets the size of the buffers, passes and the renderer.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   * @param {Boolean} [updateStyle] - Determines whether the style of the canvas should be updated.
   */
  setSize(width, height, updateStyle) {
    const renderer = this.renderer;
    const currentSize = renderer.getSize(new Vector2());
    if (width === void 0 || height === void 0) {
      width = currentSize.width;
      height = currentSize.height;
    }
    if (currentSize.width !== width || currentSize.height !== height) {
      renderer.setSize(width, height, updateStyle);
    }
    const drawingBufferSize = renderer.getDrawingBufferSize(new Vector2());
    this.inputBuffer.setSize(drawingBufferSize.width, drawingBufferSize.height);
    this.outputBuffer.setSize(drawingBufferSize.width, drawingBufferSize.height);
    for (const pass of this.passes) {
      pass.setSize(drawingBufferSize.width, drawingBufferSize.height);
    }
  }
  /**
   * Resets this composer by deleting all passes and creating new buffers.
   */
  reset() {
    this.dispose();
    this.autoRenderToScreen = true;
  }
  /**
   * Disposes this composer and all passes.
   */
  dispose() {
    for (const pass of this.passes) {
      pass.dispose();
    }
    this.passes = [];
    if (this.inputBuffer !== null) {
      this.inputBuffer.dispose();
    }
    if (this.outputBuffer !== null) {
      this.outputBuffer.dispose();
    }
    this.deleteDepthTexture();
    this.copyPass.dispose();
    this.timer.dispose();
    Pass.fullscreenGeometry.dispose();
  }
};
var EffectAttribute = {
  NONE: 0,
  DEPTH: 1,
  CONVOLUTION: 2
};
var EffectShaderSection = {
  FRAGMENT_HEAD: "FRAGMENT_HEAD",
  FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
  FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
  VERTEX_HEAD: "VERTEX_HEAD",
  VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT"
};
var EffectShaderData = class {
  /**
   * Constructs new shader data.
   */
  constructor() {
    this.shaderParts = /* @__PURE__ */ new Map([
      [EffectShaderSection.FRAGMENT_HEAD, null],
      [EffectShaderSection.FRAGMENT_MAIN_UV, null],
      [EffectShaderSection.FRAGMENT_MAIN_IMAGE, null],
      [EffectShaderSection.VERTEX_HEAD, null],
      [EffectShaderSection.VERTEX_MAIN_SUPPORT, null]
    ]);
    this.defines = /* @__PURE__ */ new Map();
    this.uniforms = /* @__PURE__ */ new Map();
    this.blendModes = /* @__PURE__ */ new Map();
    this.extensions = /* @__PURE__ */ new Set();
    this.attributes = EffectAttribute.NONE;
    this.varyings = /* @__PURE__ */ new Set();
    this.uvTransformation = false;
    this.readDepth = false;
    this.colorSpace = LinearSRGBColorSpace;
  }
};
var workaroundEnabled = false;
var OverrideMaterialManager = class {
  /**
   * Constructs a new override material manager.
   *
   * @param {Material} [material=null] - An override material.
   */
  constructor(material = null) {
    this.originalMaterials = /* @__PURE__ */ new Map();
    this.material = null;
    this.materials = null;
    this.materialsBackSide = null;
    this.materialsDoubleSide = null;
    this.materialsFlatShaded = null;
    this.materialsFlatShadedBackSide = null;
    this.materialsFlatShadedDoubleSide = null;
    this.setMaterial(material);
    this.meshCount = 0;
    this.replaceMaterial = (node) => {
      if (node.isMesh) {
        let materials;
        if (node.material.flatShading) {
          switch (node.material.side) {
            case DoubleSide:
              materials = this.materialsFlatShadedDoubleSide;
              break;
            case BackSide:
              materials = this.materialsFlatShadedBackSide;
              break;
            default:
              materials = this.materialsFlatShaded;
              break;
          }
        } else {
          switch (node.material.side) {
            case DoubleSide:
              materials = this.materialsDoubleSide;
              break;
            case BackSide:
              materials = this.materialsBackSide;
              break;
            default:
              materials = this.materials;
              break;
          }
        }
        this.originalMaterials.set(node, node.material);
        if (node.isSkinnedMesh) {
          node.material = materials[2];
        } else if (node.isInstancedMesh) {
          node.material = materials[1];
        } else {
          node.material = materials[0];
        }
        ++this.meshCount;
      }
    };
  }
  /**
   * Clones the given material.
   *
   * @private
   * @param {Material} material - The material.
   * @return {Material} The cloned material.
   */
  cloneMaterial(material) {
    if (!(material instanceof ShaderMaterial)) {
      return material.clone();
    }
    const uniforms = material.uniforms;
    const textureUniforms = /* @__PURE__ */ new Map();
    for (const key in uniforms) {
      const value = uniforms[key].value;
      if (value.isRenderTargetTexture) {
        uniforms[key].value = null;
        textureUniforms.set(key, value);
      }
    }
    const clone = material.clone();
    for (const entry of textureUniforms) {
      uniforms[entry[0]].value = entry[1];
      clone.uniforms[entry[0]].value = entry[1];
    }
    return clone;
  }
  /**
   * Sets the override material.
   *
   * @param {Material} material - The material.
   */
  setMaterial(material) {
    this.disposeMaterials();
    this.material = material;
    if (material !== null) {
      const materials = this.materials = [
        this.cloneMaterial(material),
        this.cloneMaterial(material),
        this.cloneMaterial(material)
      ];
      for (const m2 of materials) {
        m2.uniforms = Object.assign({}, material.uniforms);
        m2.side = FrontSide;
      }
      materials[2].skinning = true;
      this.materialsBackSide = materials.map((m2) => {
        const c2 = this.cloneMaterial(m2);
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.side = BackSide;
        return c2;
      });
      this.materialsDoubleSide = materials.map((m2) => {
        const c2 = this.cloneMaterial(m2);
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.side = DoubleSide;
        return c2;
      });
      this.materialsFlatShaded = materials.map((m2) => {
        const c2 = this.cloneMaterial(m2);
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.flatShading = true;
        return c2;
      });
      this.materialsFlatShadedBackSide = materials.map((m2) => {
        const c2 = this.cloneMaterial(m2);
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.flatShading = true;
        c2.side = BackSide;
        return c2;
      });
      this.materialsFlatShadedDoubleSide = materials.map((m2) => {
        const c2 = this.cloneMaterial(m2);
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.flatShading = true;
        c2.side = DoubleSide;
        return c2;
      });
    }
  }
  /**
   * Renders the scene with the override material.
   *
   * @private
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Scene} scene - A scene.
   * @param {Camera} camera - A camera.
   */
  render(renderer, scene, camera) {
    const shadowMapEnabled = renderer.shadowMap.enabled;
    renderer.shadowMap.enabled = false;
    if (workaroundEnabled) {
      const originalMaterials = this.originalMaterials;
      this.meshCount = 0;
      scene.traverse(this.replaceMaterial);
      renderer.render(scene, camera);
      for (const entry of originalMaterials) {
        entry[0].material = entry[1];
      }
      if (this.meshCount !== originalMaterials.size) {
        originalMaterials.clear();
      }
    } else {
      const overrideMaterial = scene.overrideMaterial;
      scene.overrideMaterial = this.material;
      renderer.render(scene, camera);
      scene.overrideMaterial = overrideMaterial;
    }
    renderer.shadowMap.enabled = shadowMapEnabled;
  }
  /**
   * Deletes cloned override materials.
   *
   * @private
   */
  disposeMaterials() {
    if (this.material !== null) {
      const materials = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);
      for (const m2 of materials) {
        m2.dispose();
      }
    }
  }
  /**
   * Performs cleanup tasks.
   */
  dispose() {
    this.originalMaterials.clear();
    this.disposeMaterials();
  }
  /**
   * Indicates whether the override material workaround is enabled.
   *
   * @type {Boolean}
   */
  static get workaroundEnabled() {
    return workaroundEnabled;
  }
  /**
   * Enables or disables the override material workaround globally.
   *
   * This only affects post processing passes and effects.
   *
   * @type {Boolean}
   */
  static set workaroundEnabled(value) {
    workaroundEnabled = value;
  }
};
var AUTO_SIZE = -1;
var Resolution = class extends EventDispatcher {
  /**
   * Constructs a new resolution.
   *
   * TODO Remove resizable param.
   * @param {Resizable} resizable - A resizable object.
   * @param {Number} [width=Resolution.AUTO_SIZE] - The preferred width.
   * @param {Number} [height=Resolution.AUTO_SIZE] - The preferred height.
   * @param {Number} [scale=1.0] - A resolution scale.
   */
  constructor(resizable, width = AUTO_SIZE, height = AUTO_SIZE, scale = 1) {
    super();
    this.resizable = resizable;
    this.baseSize = new Vector2(1, 1);
    this.preferredSize = new Vector2(width, height);
    this.target = this.preferredSize;
    this.s = scale;
    this.effectiveSize = new Vector2();
    this.addEventListener("change", () => this.updateEffectiveSize());
    this.updateEffectiveSize();
  }
  /**
   * Calculates the effective size.
   *
   * @private
   */
  updateEffectiveSize() {
    const base = this.baseSize;
    const preferred = this.preferredSize;
    const effective = this.effectiveSize;
    const scale = this.scale;
    if (preferred.width !== AUTO_SIZE) {
      effective.width = preferred.width;
    } else if (preferred.height !== AUTO_SIZE) {
      effective.width = Math.round(preferred.height * (base.width / Math.max(base.height, 1)));
    } else {
      effective.width = Math.round(base.width * scale);
    }
    if (preferred.height !== AUTO_SIZE) {
      effective.height = preferred.height;
    } else if (preferred.width !== AUTO_SIZE) {
      effective.height = Math.round(preferred.width / Math.max(base.width / Math.max(base.height, 1), 1));
    } else {
      effective.height = Math.round(base.height * scale);
    }
  }
  /**
   * The effective width.
   *
   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base width will be returned.
   *
   * @type {Number}
   */
  get width() {
    return this.effectiveSize.width;
  }
  set width(value) {
    this.preferredWidth = value;
  }
  /**
   * The effective height.
   *
   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base height will be returned.
   *
   * @type {Number}
   */
  get height() {
    return this.effectiveSize.height;
  }
  set height(value) {
    this.preferredHeight = value;
  }
  /**
   * Returns the effective width.
   *
   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base width will be returned.
   *
   * @deprecated Use width instead.
   * @return {Number} The effective width.
   */
  getWidth() {
    return this.width;
  }
  /**
   * Returns the effective height.
   *
   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base height will be returned.
   *
   * @deprecated Use height instead.
   * @return {Number} The effective height.
   */
  getHeight() {
    return this.height;
  }
  /**
   * The resolution scale.
   *
   * @type {Number}
   */
  get scale() {
    return this.s;
  }
  set scale(value) {
    if (this.s !== value) {
      this.s = value;
      this.preferredSize.setScalar(AUTO_SIZE);
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * Returns the current resolution scale.
   *
   * @deprecated Use scale instead.
   * @return {Number} The scale.
   */
  getScale() {
    return this.scale;
  }
  /**
   * Sets the resolution scale.
   *
   * Also sets the preferred resolution to {@link Resizer.AUTO_SIZE}.
   *
   * @deprecated Use scale instead.
   * @param {Number} value - The scale.
   */
  setScale(value) {
    this.scale = value;
  }
  /**
   * The base width.
   *
   * @type {Number}
   */
  get baseWidth() {
    return this.baseSize.width;
  }
  set baseWidth(value) {
    if (this.baseSize.width !== value) {
      this.baseSize.width = value;
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * Returns the base width.
   *
   * @deprecated Use baseWidth instead.
   * @return {Number} The base width.
   */
  getBaseWidth() {
    return this.baseWidth;
  }
  /**
   * Sets the base width.
   *
   * @deprecated Use baseWidth instead.
   * @param {Number} value - The width.
   */
  setBaseWidth(value) {
    this.baseWidth = value;
  }
  /**
   * The base height.
   *
   * @type {Number}
   */
  get baseHeight() {
    return this.baseSize.height;
  }
  set baseHeight(value) {
    if (this.baseSize.height !== value) {
      this.baseSize.height = value;
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * Returns the base height.
   *
   * @deprecated Use baseHeight instead.
   * @return {Number} The base height.
   */
  getBaseHeight() {
    return this.baseHeight;
  }
  /**
   * Sets the base height.
   *
   * @deprecated Use baseHeight instead.
   * @param {Number} value - The height.
   */
  setBaseHeight(value) {
    this.baseHeight = value;
  }
  /**
   * Sets the base size.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setBaseSize(width, height) {
    if (this.baseSize.width !== width || this.baseSize.height !== height) {
      this.baseSize.set(width, height);
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * The preferred width.
   *
   * @type {Number}
   */
  get preferredWidth() {
    return this.preferredSize.width;
  }
  set preferredWidth(value) {
    if (this.preferredSize.width !== value) {
      this.preferredSize.width = value;
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * Returns the preferred width.
   *
   * @deprecated Use preferredWidth instead.
   * @return {Number} The preferred width.
   */
  getPreferredWidth() {
    return this.preferredWidth;
  }
  /**
   * Sets the preferred width.
   *
   * Use {@link Resizer.AUTO_SIZE} to automatically calculate the width based on the height and aspect ratio.
   *
   * @deprecated Use preferredWidth instead.
   * @param {Number} value - The width.
   */
  setPreferredWidth(value) {
    this.preferredWidth = value;
  }
  /**
   * The preferred height.
   *
   * @type {Number}
   */
  get preferredHeight() {
    return this.preferredSize.height;
  }
  set preferredHeight(value) {
    if (this.preferredSize.height !== value) {
      this.preferredSize.height = value;
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * Returns the preferred height.
   *
   * @deprecated Use preferredHeight instead.
   * @return {Number} The preferred height.
   */
  getPreferredHeight() {
    return this.preferredHeight;
  }
  /**
   * Sets the preferred height.
   *
   * Use {@link Resizer.AUTO_SIZE} to automatically calculate the height based on the width and aspect ratio.
   *
   * @deprecated Use preferredHeight instead.
   * @param {Number} value - The height.
   */
  setPreferredHeight(value) {
    this.preferredHeight = value;
  }
  /**
   * Sets the preferred size.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setPreferredSize(width, height) {
    if (this.preferredSize.width !== width || this.preferredSize.height !== height) {
      this.preferredSize.set(width, height);
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * Copies the given resolution.
   *
   * @param {Resolution} resolution - The resolution.
   */
  copy(resolution) {
    this.s = resolution.scale;
    this.baseSize.set(resolution.baseWidth, resolution.baseHeight);
    this.preferredSize.set(resolution.preferredWidth, resolution.preferredHeight);
    this.dispatchEvent({ type: "change" });
    this.resizable.setSize(this.baseSize.width, this.baseSize.height);
  }
  /**
   * An auto sizing constant.
   *
   * Can be used to automatically calculate the width or height based on the original aspect ratio.
   *
   * @type {Number}
   */
  static get AUTO_SIZE() {
    return AUTO_SIZE;
  }
};
var IdManager = class {
  /**
   * Constructs a new ID manager.
   *
   * @param initialId - The first ID.
   */
  constructor(initialId = 0) {
    this.nextId = initialId;
  }
  /**
   * Returns the next unique ID.
   *
   * @return The ID.
   */
  getNextId() {
    return this.nextId++;
  }
  /**
   * Resets the ID counter.
   *
   * @param initialId - The first ID.
   * @return This manager.
   */
  reset(initialId = 0) {
    this.nextId = initialId;
    return this;
  }
};
var idManager = new IdManager(2);
var Selection = class extends Set {
  /**
   * Constructs a new selection.
   *
   * @param {Iterable<Object3D>} [iterable] - A collection of objects that should be added to this selection.
   * @param {Number} [layer] - A dedicated render layer for selected objects. Range is `[2, 31]`. Starts at 2 if omitted.
   */
  constructor(iterable, layer = idManager.getNextId()) {
    super();
    this.exclusive = false;
    this._layer = layer;
    if (this._layer < 1 || this._layer > 31) {
      console.warn("Layer out of range, resetting to 2");
      idManager.reset(2);
      this._layer = idManager.getNextId();
    }
    if (iterable !== void 0) {
      this.set(iterable);
    }
  }
  /**
   * The render layer for selected objects.
   *
   * @type {Number}
   */
  get layer() {
    return this._layer;
  }
  set layer(value) {
    const currentLayer = this._layer;
    for (const object of this) {
      object.layers.disable(currentLayer);
      object.layers.enable(value);
    }
    this._layer = value;
  }
  /**
   * Returns the current render layer for selected objects.
   *
   * The default layer is 2. If this collides with your own custom layers, please change it before rendering!
   *
   * @deprecated Use layer instead.
   * @return {Number} The layer.
   */
  getLayer() {
    return this.layer;
  }
  /**
   * Sets the render layer for selected objects.
   *
   * The current selection will be updated accordingly.
   *
   * @deprecated Use layer instead.
   * @param {Number} value - The layer. Range is [0, 31].
   */
  setLayer(value) {
    this.layer = value;
  }
  /**
   * Indicates whether objects that are added to this selection will be removed from all other layers.
   *
   * @deprecated Use exclusive instead.
   * @return {Number} Whether this selection is exclusive. Default is false.
   */
  isExclusive() {
    return this.exclusive;
  }
  /**
   * Controls whether objects that are added to this selection should be removed from all other layers.
   *
   * @deprecated Use exclusive instead.
   * @param {Number} value - Whether this selection should be exclusive.
   */
  setExclusive(value) {
    this.exclusive = value;
  }
  /**
   * Clears this selection.
   *
   * @return {Selection} This selection.
   */
  clear() {
    const layer = this.layer;
    for (const object of this) {
      object.layers.disable(layer);
    }
    return super.clear();
  }
  /**
   * Clears this selection and adds the given objects.
   *
   * @param {Iterable<Object3D>} objects - The objects that should be selected.
   * @return {Selection} This selection.
   */
  set(objects) {
    this.clear();
    for (const object of objects) {
      this.add(object);
    }
    return this;
  }
  /**
   * An alias for {@link has}.
   *
   * @param {Object3D} object - An object.
   * @return {Number} Returns 0 if the given object is currently selected, or -1 otherwise.
   * @deprecated Added for backward-compatibility.
   */
  indexOf(object) {
    return this.has(object) ? 0 : -1;
  }
  /**
   * Adds an object to this selection.
   *
   * If {@link exclusive} is set to `true`, the object will also be removed from all other layers.
   *
   * @param {Object3D} object - The object that should be selected.
   * @return {Selection} This selection.
   */
  add(object) {
    if (this.exclusive) {
      object.layers.set(this.layer);
    } else {
      object.layers.enable(this.layer);
    }
    return super.add(object);
  }
  /**
   * Removes an object from this selection.
   *
   * @param {Object3D} object - The object that should be deselected.
   * @return {Boolean} Returns true if an object has successfully been removed from this selection; otherwise false.
   */
  delete(object) {
    if (this.has(object)) {
      object.layers.disable(this.layer);
    }
    return super.delete(object);
  }
  /**
   * Removes an existing object from the selection. If the object doesn't exist it's added instead.
   *
   * @param {Object3D} object - The object.
   * @return {Boolean} Returns true if the object is added, false otherwise.
   */
  toggle(object) {
    let result;
    if (this.has(object)) {
      this.delete(object);
      result = false;
    } else {
      this.add(object);
      result = true;
    }
    return result;
  }
  /**
   * Sets the visibility of all selected objects.
   *
   * This method enables or disables render layer 0 of all selected objects.
   *
   * @param {Boolean} visible - Whether the selected objects should be visible.
   * @return {Selection} This selection.
   */
  setVisible(visible) {
    for (const object of this) {
      if (visible) {
        object.layers.enable(0);
      } else {
        object.layers.disable(0);
      }
    }
    return this;
  }
};
var BlendFunction = {
  SKIP: 9,
  SET: 30,
  ADD: 0,
  ALPHA: 1,
  AVERAGE: 2,
  COLOR: 3,
  COLOR_BURN: 4,
  COLOR_DODGE: 5,
  DARKEN: 6,
  DIFFERENCE: 7,
  DIVIDE: 8,
  DST: 9,
  EXCLUSION: 10,
  HARD_LIGHT: 11,
  HARD_MIX: 12,
  HUE: 13,
  INVERT: 14,
  INVERT_RGB: 15,
  LIGHTEN: 16,
  LINEAR_BURN: 17,
  LINEAR_DODGE: 18,
  LINEAR_LIGHT: 19,
  LUMINOSITY: 20,
  MULTIPLY: 21,
  NEGATION: 22,
  NORMAL: 23,
  OVERLAY: 24,
  PIN_LIGHT: 25,
  REFLECT: 26,
  SATURATION: 27,
  SCREEN: 28,
  SOFT_LIGHT: 29,
  SRC: 30,
  SUBTRACT: 31,
  VIVID_LIGHT: 32
};
var add_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}";
var alpha_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}";
var average_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}";
var color_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}";
var color_burn_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}";
var color_dodge_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}";
var darken_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}";
var difference_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}";
var divide_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}";
var exclusion_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}";
var hard_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}";
var hard_mix_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}";
var hue_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}";
var invert_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}";
var invert_rgb_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}";
var lighten_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}";
var linear_burn_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}";
var linear_dodge_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}";
var linear_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}";
var luminosity_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}";
var multiply_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}";
var negation_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}";
var normal_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}";
var overlay_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}";
var pin_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}";
var reflect_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}";
var saturation_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}";
var screen_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}";
var soft_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}";
var src_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}";
var subtract_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}";
var vivid_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}";
var blendFunctions = /* @__PURE__ */ new Map([
  [BlendFunction.ADD, add_default],
  [BlendFunction.ALPHA, alpha_default],
  [BlendFunction.AVERAGE, average_default],
  [BlendFunction.COLOR, color_default],
  [BlendFunction.COLOR_BURN, color_burn_default],
  [BlendFunction.COLOR_DODGE, color_dodge_default],
  [BlendFunction.DARKEN, darken_default],
  [BlendFunction.DIFFERENCE, difference_default],
  [BlendFunction.DIVIDE, divide_default],
  [BlendFunction.DST, null],
  [BlendFunction.EXCLUSION, exclusion_default],
  [BlendFunction.HARD_LIGHT, hard_light_default],
  [BlendFunction.HARD_MIX, hard_mix_default],
  [BlendFunction.HUE, hue_default],
  [BlendFunction.INVERT, invert_default],
  [BlendFunction.INVERT_RGB, invert_rgb_default],
  [BlendFunction.LIGHTEN, lighten_default],
  [BlendFunction.LINEAR_BURN, linear_burn_default],
  [BlendFunction.LINEAR_DODGE, linear_dodge_default],
  [BlendFunction.LINEAR_LIGHT, linear_light_default],
  [BlendFunction.LUMINOSITY, luminosity_default],
  [BlendFunction.MULTIPLY, multiply_default],
  [BlendFunction.NEGATION, negation_default],
  [BlendFunction.NORMAL, normal_default],
  [BlendFunction.OVERLAY, overlay_default],
  [BlendFunction.PIN_LIGHT, pin_light_default],
  [BlendFunction.REFLECT, reflect_default],
  [BlendFunction.SATURATION, saturation_default],
  [BlendFunction.SCREEN, screen_default],
  [BlendFunction.SOFT_LIGHT, soft_light_default],
  [BlendFunction.SRC, src_default],
  [BlendFunction.SUBTRACT, subtract_default],
  [BlendFunction.VIVID_LIGHT, vivid_light_default]
]);
var BlendMode = class extends EventDispatcher {
  /**
   * Constructs a new blend mode.
   *
   * @param {BlendFunction} blendFunction - The blend function.
   * @param {Number} opacity - The opacity of the color that will be blended with the base color.
   */
  constructor(blendFunction, opacity = 1) {
    super();
    this._blendFunction = blendFunction;
    this.opacity = new Uniform$1(opacity);
  }
  /**
   * Returns the opacity.
   *
   * @return {Number} The opacity.
   */
  getOpacity() {
    return this.opacity.value;
  }
  /**
   * Sets the opacity.
   *
   * @param {Number} value - The opacity.
   */
  setOpacity(value) {
    this.opacity.value = value;
  }
  /**
   * The blend function.
   *
   * @type {BlendFunction}
   */
  get blendFunction() {
    return this._blendFunction;
  }
  set blendFunction(value) {
    this._blendFunction = value;
    this.dispatchEvent({ type: "change" });
  }
  /**
   * Returns the blend function.
   *
   * @deprecated Use blendFunction instead.
   * @return {BlendFunction} The blend function.
   */
  getBlendFunction() {
    return this.blendFunction;
  }
  /**
   * Sets the blend function.
   *
   * @deprecated Use blendFunction instead.
   * @param {BlendFunction} value - The blend function.
   */
  setBlendFunction(value) {
    this.blendFunction = value;
  }
  /**
   * Returns the blend function shader code.
   *
   * @return {String} The blend function shader code.
   */
  getShaderCode() {
    return blendFunctions.get(this.blendFunction);
  }
};
var KernelSize = {
  VERY_SMALL: 0,
  SMALL: 1,
  MEDIUM: 2,
  LARGE: 3,
  VERY_LARGE: 4,
  HUGE: 5
};
var convolution_kawase_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;\n#include <colorspace_fragment>\n}";
var convolution_kawase_default2 = "uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}";
var kernelPresets = [
  new Float32Array([0, 0]),
  new Float32Array([0, 1, 1]),
  new Float32Array([0, 1, 1, 2]),
  new Float32Array([0, 1, 2, 2, 3]),
  new Float32Array([0, 1, 2, 3, 4, 4, 5]),
  new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])
];
var KawaseBlurMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new convolution material.
   *
   * TODO Remove texelSize param.
   * @param {Vector4} [texelSize] - Deprecated.
   */
  constructor(texelSize = new Vector4()) {
    super({
      name: "KawaseBlurMaterial",
      uniforms: {
        inputBuffer: new Uniform$1(null),
        texelSize: new Uniform$1(new Vector4()),
        scale: new Uniform$1(1),
        kernel: new Uniform$1(0)
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: convolution_kawase_default,
      vertexShader: convolution_kawase_default2
    });
    this.setTexelSize(texelSize.x, texelSize.y);
    this.kernelSize = KernelSize.MEDIUM;
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Texture} value - The input buffer.
   */
  setInputBuffer(value) {
    this.inputBuffer = value;
  }
  /**
   * The kernel sequence for the current kernel size.
   *
   * @type {Float32Array}
   */
  get kernelSequence() {
    return kernelPresets[this.kernelSize];
  }
  /**
   * The blur scale.
   *
   * @type {Number}
   */
  get scale() {
    return this.uniforms.scale.value;
  }
  set scale(value) {
    this.uniforms.scale.value = value;
  }
  /**
   * Returns the blur scale.
   *
   * @deprecated Use scale instead.
   * @return {Number} The scale.
   */
  getScale() {
    return this.uniforms.scale.value;
  }
  /**
   * Sets the blur scale.
   *
   * @deprecated Use scale instead.
   * @return {Number} value - The scale.
   */
  setScale(value) {
    this.uniforms.scale.value = value;
  }
  /**
   * Returns the kernel.
   *
   * @return {Float32Array} The kernel.
   * @deprecated Implementation detail, removed with no replacement.
   */
  getKernel() {
    return null;
  }
  /**
   * The current kernel.
   *
   * @type {Number}
   */
  get kernel() {
    return this.uniforms.kernel.value;
  }
  set kernel(value) {
    this.uniforms.kernel.value = value;
  }
  /**
   * Sets the current kernel.
   *
   * @deprecated Use kernel instead.
   * @param {Number} value - The kernel.
   */
  setKernel(value) {
    this.kernel = value;
  }
  /**
   * Sets the texel size.
   *
   * @deprecated Use setSize() instead.
   * @param {Number} x - The texel width.
   * @param {Number} y - The texel height.
   */
  setTexelSize(x2, y) {
    this.uniforms.texelSize.value.set(x2, y, x2 * 0.5, y * 0.5);
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const x2 = 1 / width, y = 1 / height;
    this.uniforms.texelSize.value.set(x2, y, x2 * 0.5, y * 0.5);
  }
};
var KawaseBlurPass = class extends Pass {
  /**
   * Constructs a new Kawase blur pass.
   *
   * @param {Object} [options] - The options.
   * @param {KernelSize} [options.kernelSize=KernelSize.MEDIUM] - The blur kernel size.
   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
   */
  constructor({
    kernelSize = KernelSize.MEDIUM,
    resolutionScale = 0.5,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("KawaseBlurPass");
    this.renderTargetA = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTargetA.texture.name = "Blur.Target.A";
    this.renderTargetB = this.renderTargetA.clone();
    this.renderTargetB.texture.name = "Blur.Target.B";
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
    this._blurMaterial = new KawaseBlurMaterial();
    this._blurMaterial.kernelSize = kernelSize;
    this.copyMaterial = new CopyMaterial();
  }
  /**
   * Returns the resolution settings.
   *
   * @deprecated Use resolution instead.
   * @return {Resolution} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * The blur material.
   *
   * @type {KawaseBlurMaterial}
   */
  get blurMaterial() {
    return this._blurMaterial;
  }
  /**
   * The blur material.
   *
   * @type {KawaseBlurMaterial}
   * @protected
   */
  set blurMaterial(value) {
    this._blurMaterial = value;
  }
  /**
   * Indicates whether dithering is enabled.
   *
   * @type {Boolean}
   * @deprecated Use copyMaterial.dithering instead.
   */
  get dithering() {
    return this.copyMaterial.dithering;
  }
  set dithering(value) {
    this.copyMaterial.dithering = value;
  }
  /**
   * The kernel size.
   *
   * @type {KernelSize}
   * @deprecated Use blurMaterial.kernelSize instead.
   */
  get kernelSize() {
    return this.blurMaterial.kernelSize;
  }
  set kernelSize(value) {
    this.blurMaterial.kernelSize = value;
  }
  /**
   * The current width of the internal render targets.
   *
   * @type {Number}
   * @deprecated Use resolution.width instead.
   */
  get width() {
    return this.resolution.width;
  }
  /**
   * Sets the render width.
   *
   * @type {Number}
   * @deprecated Use resolution.preferredWidth instead.
   */
  set width(value) {
    this.resolution.preferredWidth = value;
  }
  /**
   * The current height of the internal render targets.
   *
   * @type {Number}
   * @deprecated Use resolution.height instead.
   */
  get height() {
    return this.resolution.height;
  }
  /**
   * Sets the render height.
   *
   * @type {Number}
   * @deprecated Use resolution.preferredHeight instead.
   */
  set height(value) {
    this.resolution.preferredHeight = value;
  }
  /**
   * The current blur scale.
   *
   * @type {Number}
   * @deprecated Use blurMaterial.scale instead.
   */
  get scale() {
    return this.blurMaterial.scale;
  }
  set scale(value) {
    this.blurMaterial.scale = value;
  }
  /**
   * Returns the current blur scale.
   *
   * @deprecated Use blurMaterial.scale instead.
   * @return {Number} The scale.
   */
  getScale() {
    return this.blurMaterial.scale;
  }
  /**
   * Sets the blur scale.
   *
   * @deprecated Use blurMaterial.scale instead.
   * @param {Number} value - The scale.
   */
  setScale(value) {
    this.blurMaterial.scale = value;
  }
  /**
   * Returns the kernel size.
   *
   * @deprecated Use blurMaterial.kernelSize instead.
   * @return {KernelSize} The kernel size.
   */
  getKernelSize() {
    return this.kernelSize;
  }
  /**
   * Sets the kernel size.
   *
   * Larger kernels require more processing power but scale well with larger render resolutions.
   *
   * @deprecated Use blurMaterial.kernelSize instead.
   * @param {KernelSize} value - The kernel size.
   */
  setKernelSize(value) {
    this.kernelSize = value;
  }
  /**
   * Returns the current resolution scale.
   *
   * @return {Number} The resolution scale.
   * @deprecated Use resolution instead.
   */
  getResolutionScale() {
    return this.resolution.scale;
  }
  /**
   * Sets the resolution scale.
   *
   * @param {Number} scale - The new resolution scale.
   * @deprecated Use resolution instead.
   */
  setResolutionScale(scale) {
    this.resolution.scale = scale;
  }
  /**
   * Renders the blur.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const scene = this.scene;
    const camera = this.camera;
    const renderTargetA = this.renderTargetA;
    const renderTargetB = this.renderTargetB;
    const material = this.blurMaterial;
    const kernelSequence = material.kernelSequence;
    let previousBuffer = inputBuffer;
    this.fullscreenMaterial = material;
    for (let i = 0, l = kernelSequence.length; i < l; ++i) {
      const buffer2 = (i & 1) === 0 ? renderTargetA : renderTargetB;
      material.kernel = kernelSequence[i];
      material.inputBuffer = previousBuffer.texture;
      renderer.setRenderTarget(buffer2);
      renderer.render(scene, camera);
      previousBuffer = buffer2;
    }
    this.fullscreenMaterial = this.copyMaterial;
    this.copyMaterial.inputBuffer = previousBuffer.texture;
    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
    renderer.render(scene, camera);
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    const w = resolution.width, h = resolution.height;
    this.renderTargetA.setSize(w, h);
    this.renderTargetB.setSize(w, h);
    this.blurMaterial.setSize(width, height);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0) {
      this.renderTargetA.texture.type = frameBufferType;
      this.renderTargetB.texture.type = frameBufferType;
      if (frameBufferType !== UnsignedByteType) {
        this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
        this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
      } else if (renderer !== null && renderer.outputColorSpace === SRGBColorSpace) {
        this.renderTargetA.texture.colorSpace = SRGBColorSpace;
        this.renderTargetB.texture.colorSpace = SRGBColorSpace;
      }
    }
  }
  /**
   * An auto sizing flag.
   *
   * @type {Number}
   * @deprecated Use {@link Resolution.AUTO_SIZE} instead.
   */
  static get AUTO_SIZE() {
    return Resolution.AUTO_SIZE;
  }
};
var luminance_default = "#include <common>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef RANGE\nuniform vec2 range;\n#elif defined(THRESHOLD)\nuniform float threshold;uniform float smoothing;\n#endif\nvarying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);\n#ifdef RANGE\nfloat low=step(range.x,l);float high=step(l,range.y);l*=low*high;\n#elif defined(THRESHOLD)\nl=smoothstep(threshold,threshold+smoothing,l)*l;\n#endif\n#ifdef COLOR\ngl_FragColor=vec4(texel.rgb*clamp(l,0.0,1.0),l);\n#else\ngl_FragColor=vec4(l);\n#endif\n}";
var LuminanceMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new luminance material.
   *
   * @param {Boolean} [colorOutput=false] - Defines whether the shader should output colors scaled with their luminance value.
   * @param {Vector2} [luminanceRange] - If provided, the shader will mask out texels that aren't in the specified luminance range.
   */
  constructor(colorOutput = false, luminanceRange = null) {
    super({
      name: "LuminanceMaterial",
      defines: {
        THREE_REVISION: REVISION.replace(/\D+/g, "")
      },
      uniforms: {
        inputBuffer: new Uniform$1(null),
        threshold: new Uniform$1(0),
        smoothing: new Uniform$1(1),
        range: new Uniform$1(null)
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: luminance_default,
      vertexShader: common_default
    });
    this.colorOutput = colorOutput;
    this.luminanceRange = luminanceRange;
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Texture} value - The input buffer.
   */
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * The luminance threshold.
   *
   * @type {Number}
   */
  get threshold() {
    return this.uniforms.threshold.value;
  }
  set threshold(value) {
    if (this.smoothing > 0 || value > 0) {
      this.defines.THRESHOLD = "1";
    } else {
      delete this.defines.THRESHOLD;
    }
    this.uniforms.threshold.value = value;
  }
  /**
   * Returns the luminance threshold.
   *
   * @deprecated Use threshold instead.
   * @return {Number} The threshold.
   */
  getThreshold() {
    return this.threshold;
  }
  /**
   * Sets the luminance threshold.
   *
   * @deprecated Use threshold instead.
   * @param {Number} value - The threshold.
   */
  setThreshold(value) {
    this.threshold = value;
  }
  /**
   * The luminance threshold smoothing.
   *
   * @type {Number}
   */
  get smoothing() {
    return this.uniforms.smoothing.value;
  }
  set smoothing(value) {
    if (this.threshold > 0 || value > 0) {
      this.defines.THRESHOLD = "1";
    } else {
      delete this.defines.THRESHOLD;
    }
    this.uniforms.smoothing.value = value;
  }
  /**
   * Returns the luminance threshold smoothing factor.
   *
   * @deprecated Use smoothing instead.
   * @return {Number} The smoothing factor.
   */
  getSmoothingFactor() {
    return this.smoothing;
  }
  /**
   * Sets the luminance threshold smoothing factor.
   *
   * @deprecated Use smoothing instead.
   * @param {Number} value - The smoothing factor.
   */
  setSmoothingFactor(value) {
    this.smoothing = value;
  }
  /**
   * Indicates whether the luminance threshold is enabled.
   *
   * @type {Boolean}
   * @deprecated Adjust the threshold or smoothing factor instead.
   */
  get useThreshold() {
    return this.threshold > 0 || this.smoothing > 0;
  }
  set useThreshold(value) {
  }
  /**
   * Indicates whether color output is enabled.
   *
   * @type {Boolean}
   */
  get colorOutput() {
    return this.defines.COLOR !== void 0;
  }
  set colorOutput(value) {
    if (value) {
      this.defines.COLOR = "1";
    } else {
      delete this.defines.COLOR;
    }
    this.needsUpdate = true;
  }
  /**
   * Indicates whether color output is enabled.
   *
   * @deprecated Use colorOutput instead.
   * @return {Boolean} Whether color output is enabled.
   */
  isColorOutputEnabled(value) {
    return this.colorOutput;
  }
  /**
   * Enables or disables color output.
   *
   * @deprecated Use colorOutput instead.
   * @param {Boolean} value - Whether color output should be enabled.
   */
  setColorOutputEnabled(value) {
    this.colorOutput = value;
  }
  /**
   * Indicates whether luminance masking is enabled.
   *
   * @type {Boolean}
   * @deprecated
   */
  get useRange() {
    return this.luminanceRange !== null;
  }
  set useRange(value) {
    this.luminanceRange = null;
  }
  /**
   * The luminance range. Set to null to disable.
   *
   * @type {Boolean}
   */
  get luminanceRange() {
    return this.uniforms.range.value;
  }
  set luminanceRange(value) {
    if (value !== null) {
      this.defines.RANGE = "1";
    } else {
      delete this.defines.RANGE;
    }
    this.uniforms.range.value = value;
    this.needsUpdate = true;
  }
  /**
   * Returns the current luminance range.
   *
   * @deprecated Use luminanceRange instead.
   * @return {Vector2} The luminance range.
   */
  getLuminanceRange() {
    return this.luminanceRange;
  }
  /**
   * Sets a luminance range. Set to null to disable.
   *
   * @deprecated Use luminanceRange instead.
   * @param {Vector2} value - The luminance range.
   */
  setLuminanceRange(value) {
    this.luminanceRange = value;
  }
};
var LuminancePass = class extends Pass {
  /**
   * Constructs a new luminance pass.
   *
   * @param {Object} [options] - The options. See {@link LuminanceMaterial} for additional options.
   * @param {WebGLRenderTarget} [options.renderTarget] - A custom render target.
   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
   */
  constructor({
    renderTarget: renderTarget2,
    luminanceRange,
    colorOutput,
    resolutionScale = 1,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("LuminancePass");
    this.fullscreenMaterial = new LuminanceMaterial(colorOutput, luminanceRange);
    this.needsSwap = false;
    this.renderTarget = renderTarget2;
    if (this.renderTarget === void 0) {
      this.renderTarget = new WebGLRenderTarget(1, 1, { depthBuffer: false });
      this.renderTarget.texture.name = "LuminancePass.Target";
    }
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
  }
  /**
   * The luminance texture.
   *
   * @type {Texture}
   */
  get texture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the luminance texture.
   *
   * @deprecated Use texture instead.
   * @return {Texture} The texture.
   */
  getTexture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the resolution settings.
   *
   * @deprecated Use resolution instead.
   * @return {Resolution} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * Renders the luminance.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const material = this.fullscreenMaterial;
    material.inputBuffer = inputBuffer.texture;
    renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);
    renderer.render(this.scene, this.camera);
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    this.renderTarget.setSize(resolution.width, resolution.height);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - A renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0 && frameBufferType !== UnsignedByteType) {
      this.renderTarget.texture.type = frameBufferType;
      this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
    }
  }
};
var convolution_downsampling_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#define WEIGHT_INNER 0.125\n#define WEIGHT_OUTER 0.0555555\nvarying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;\n#include <colorspace_fragment>\n}";
var convolution_downsampling_default2 = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}";
var DownsamplingMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new downsampling material.
   */
  constructor() {
    super({
      name: "DownsamplingMaterial",
      uniforms: {
        inputBuffer: new Uniform$1(null),
        texelSize: new Uniform$1(new Vector2())
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: convolution_downsampling_default,
      vertexShader: convolution_downsampling_default2
    });
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.uniforms.texelSize.value.set(1 / width, 1 / height);
  }
};
var convolution_upsampling_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;\n#else\nuniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;\n#endif\nuniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);\n#include <colorspace_fragment>\n}";
var convolution_upsampling_default2 = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}";
var UpsamplingMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new upsampling material.
   */
  constructor() {
    super({
      name: "UpsamplingMaterial",
      uniforms: {
        inputBuffer: new Uniform$1(null),
        supportBuffer: new Uniform$1(null),
        texelSize: new Uniform$1(new Vector2()),
        radius: new Uniform$1(0.85)
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: convolution_upsampling_default,
      vertexShader: convolution_upsampling_default2
    });
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * A support buffer.
   *
   * @type {Texture}
   */
  set supportBuffer(value) {
    this.uniforms.supportBuffer.value = value;
  }
  /**
   * The blur radius.
   *
   * @type {Number}
   */
  get radius() {
    return this.uniforms.radius.value;
  }
  set radius(value) {
    this.uniforms.radius.value = value;
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.uniforms.texelSize.value.set(1 / width, 1 / height);
  }
};
var MipmapBlurPass = class extends Pass {
  /**
   * Constructs a new mipmap blur pass.
   *
   * @param {Object} [options] - The options.
   */
  constructor() {
    super("MipmapBlurPass");
    this.needsSwap = false;
    this.renderTarget = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTarget.texture.name = "Upsampling.Mipmap0";
    this.downsamplingMipmaps = [];
    this.upsamplingMipmaps = [];
    this.downsamplingMaterial = new DownsamplingMaterial();
    this.upsamplingMaterial = new UpsamplingMaterial();
    this.resolution = new Vector2();
  }
  /**
   * A texture that contains the blurred result.
   *
   * @type {Texture}
   */
  get texture() {
    return this.renderTarget.texture;
  }
  /**
   * The MIP levels. Default is 8.
   *
   * @type {Number}
   */
  get levels() {
    return this.downsamplingMipmaps.length;
  }
  set levels(value) {
    if (this.levels !== value) {
      const renderTarget2 = this.renderTarget;
      this.dispose();
      this.downsamplingMipmaps = [];
      this.upsamplingMipmaps = [];
      for (let i = 0; i < value; ++i) {
        const mipmap = renderTarget2.clone();
        mipmap.texture.name = "Downsampling.Mipmap" + i;
        this.downsamplingMipmaps.push(mipmap);
      }
      this.upsamplingMipmaps.push(renderTarget2);
      for (let i = 1, l = value - 1; i < l; ++i) {
        const mipmap = renderTarget2.clone();
        mipmap.texture.name = "Upsampling.Mipmap" + i;
        this.upsamplingMipmaps.push(mipmap);
      }
      this.setSize(this.resolution.x, this.resolution.y);
    }
  }
  /**
   * The blur radius.
   *
   * @type {Number}
   */
  get radius() {
    return this.upsamplingMaterial.radius;
  }
  set radius(value) {
    this.upsamplingMaterial.radius = value;
  }
  /**
   * Renders the blur.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const { scene, camera } = this;
    const { downsamplingMaterial, upsamplingMaterial } = this;
    const { downsamplingMipmaps, upsamplingMipmaps } = this;
    let previousBuffer = inputBuffer;
    this.fullscreenMaterial = downsamplingMaterial;
    for (let i = 0, l = downsamplingMipmaps.length; i < l; ++i) {
      const mipmap = downsamplingMipmaps[i];
      downsamplingMaterial.setSize(previousBuffer.width, previousBuffer.height);
      downsamplingMaterial.inputBuffer = previousBuffer.texture;
      renderer.setRenderTarget(mipmap);
      renderer.render(scene, camera);
      previousBuffer = mipmap;
    }
    this.fullscreenMaterial = upsamplingMaterial;
    for (let i = upsamplingMipmaps.length - 1; i >= 0; --i) {
      const mipmap = upsamplingMipmaps[i];
      upsamplingMaterial.setSize(previousBuffer.width, previousBuffer.height);
      upsamplingMaterial.inputBuffer = previousBuffer.texture;
      upsamplingMaterial.supportBuffer = downsamplingMipmaps[i].texture;
      renderer.setRenderTarget(mipmap);
      renderer.render(scene, camera);
      previousBuffer = mipmap;
    }
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.set(width, height);
    let w = resolution.width, h = resolution.height;
    for (let i = 0, l = this.downsamplingMipmaps.length; i < l; ++i) {
      w = Math.round(w * 0.5);
      h = Math.round(h * 0.5);
      this.downsamplingMipmaps[i].setSize(w, h);
      if (i < this.upsamplingMipmaps.length) {
        this.upsamplingMipmaps[i].setSize(w, h);
      }
    }
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0) {
      const mipmaps = this.downsamplingMipmaps.concat(this.upsamplingMipmaps);
      for (const mipmap of mipmaps) {
        mipmap.texture.type = frameBufferType;
      }
      if (frameBufferType !== UnsignedByteType) {
        this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
        this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
      } else if (renderer !== null && renderer.outputColorSpace === SRGBColorSpace) {
        for (const mipmap of mipmaps) {
          mipmap.texture.colorSpace = SRGBColorSpace;
        }
      }
    }
  }
  /**
   * Deletes internal render targets and textures.
   */
  dispose() {
    super.dispose();
    for (const mipmap of this.downsamplingMipmaps.concat(this.upsamplingMipmaps)) {
      mipmap.dispose();
    }
  }
};
var Effect = class extends EventDispatcher {
  /**
   * Constructs a new effect.
   *
   * @param {String} name - The name of this effect. Doesn't have to be unique.
   * @param {String} fragmentShader - The fragment shader. This shader is required.
   * @param {Object} [options] - Additional options.
   * @param {EffectAttribute} [options.attributes=EffectAttribute.NONE] - The effect attributes that determine the execution priority and resource requirements.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.NORMAL] - The blend function of this effect.
   * @param {Map<String, String>} [options.defines] - Custom preprocessor macro definitions. Keys are names and values are code.
   * @param {Map<String, Uniform>} [options.uniforms] - Custom shader uniforms. Keys are names and values are uniforms.
   * @param {Set<WebGLExtension>} [options.extensions] - WebGL extensions.
   * @param {String} [options.vertexShader=null] - The vertex shader. Most effects don't need one.
   */
  constructor(name, fragmentShader2, {
    attributes = EffectAttribute.NONE,
    blendFunction = BlendFunction.NORMAL,
    defines = /* @__PURE__ */ new Map(),
    uniforms = /* @__PURE__ */ new Map(),
    extensions = null,
    vertexShader: vertexShader2 = null
  } = {}) {
    super();
    this.name = name;
    this.renderer = null;
    this.attributes = attributes;
    this.fragmentShader = fragmentShader2;
    this.vertexShader = vertexShader2;
    this.defines = defines;
    this.uniforms = uniforms;
    this.extensions = extensions;
    this.blendMode = new BlendMode(blendFunction);
    this.blendMode.addEventListener("change", (event) => this.setChanged());
    this._inputColorSpace = LinearSRGBColorSpace;
    this._outputColorSpace = NoColorSpace;
  }
  /**
   * The input color space.
   *
   * @type {ColorSpace}
   * @experimental
   */
  get inputColorSpace() {
    return this._inputColorSpace;
  }
  /**
   * @type {ColorSpace}
   * @protected
   * @experimental
   */
  set inputColorSpace(value) {
    this._inputColorSpace = value;
    this.setChanged();
  }
  /**
   * The output color space.
   *
   * Should only be changed if this effect converts the input colors to a different color space.
   *
   * @type {ColorSpace}
   * @experimental
   */
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  /**
   * @type {ColorSpace}
   * @protected
   * @experimental
   */
  set outputColorSpace(value) {
    this._outputColorSpace = value;
    this.setChanged();
  }
  /**
   * Sets the main scene.
   *
   * @type {Scene}
   */
  set mainScene(value) {
  }
  /**
   * Sets the main camera.
   *
   * @type {Camera}
   */
  set mainCamera(value) {
  }
  /**
   * Returns the name of this effect.
   *
   * @deprecated Use name instead.
   * @return {String} The name.
   */
  getName() {
    return this.name;
  }
  /**
   * Sets the renderer.
   *
   * @deprecated
   * @param {WebGLRenderer} renderer - The renderer.
   */
  setRenderer(renderer) {
    this.renderer = renderer;
  }
  /**
   * Returns the preprocessor macro definitions.
   *
   * @deprecated Use defines instead.
   * @return {Map<String, String>} The extensions.
   */
  getDefines() {
    return this.defines;
  }
  /**
   * Returns the uniforms of this effect.
   *
   * @deprecated Use uniforms instead.
   * @return {Map<String, Uniform>} The extensions.
   */
  getUniforms() {
    return this.uniforms;
  }
  /**
   * Returns the WebGL extensions that are required by this effect.
   *
   * @deprecated Use extensions instead.
   * @return {Set<WebGLExtension>} The extensions.
   */
  getExtensions() {
    return this.extensions;
  }
  /**
   * Returns the blend mode.
   *
   * The result of this effect will be blended with the result of the previous effect using this blend mode.
   *
   * @deprecated Use blendMode instead.
   * @return {BlendMode} The blend mode.
   */
  getBlendMode() {
    return this.blendMode;
  }
  /**
   * Returns the effect attributes.
   *
   * @return {EffectAttribute} The attributes.
   */
  getAttributes() {
    return this.attributes;
  }
  /**
   * Sets the effect attributes.
   *
   * Effects that have the same attributes will be executed in the order in which they were registered. Some attributes
   * imply a higher priority.
   *
   * @protected
   * @param {EffectAttribute} attributes - The attributes.
   */
  setAttributes(attributes) {
    this.attributes = attributes;
    this.setChanged();
  }
  /**
   * Returns the fragment shader.
   *
   * @return {String} The fragment shader.
   */
  getFragmentShader() {
    return this.fragmentShader;
  }
  /**
   * Sets the fragment shader.
   *
   * @protected
   * @param {String} fragmentShader - The fragment shader.
   */
  setFragmentShader(fragmentShader2) {
    this.fragmentShader = fragmentShader2;
    this.setChanged();
  }
  /**
   * Returns the vertex shader.
   *
   * @return {String} The vertex shader.
   */
  getVertexShader() {
    return this.vertexShader;
  }
  /**
   * Sets the vertex shader.
   *
   * @protected
   * @param {String} vertexShader - The vertex shader.
   */
  setVertexShader(vertexShader2) {
    this.vertexShader = vertexShader2;
    this.setChanged();
  }
  /**
   * Informs the associated {@link EffectPass} that this effect requires a shader recompilation.
   *
   * Should be called after changing macros or extensions and after adding/removing uniforms.
   *
   * @protected
   */
  setChanged() {
    this.dispatchEvent({ type: "change" });
  }
  /**
   * Sets the depth texture.
   *
   * You may override this method if your effect requires direct access to the depth texture that is bound to the
   * associated {@link EffectPass}.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
  }
  /**
   * Updates this effect by performing supporting operations.
   *
   * This method is called by the {@link EffectPass} right before the main fullscreen render operation, even if the
   * blend function is set to `SKIP`.
   *
   * You may override this method if you need to update custom uniforms or render additional off-screen textures.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
  }
  /**
   * Updates the size of this effect.
   *
   * You may override this method if you want to be informed about the size of the backbuffer/canvas.
   * This method is called before {@link initialize} and every time the size of the {@link EffectComposer} changes.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
  }
  /**
   * Performs initialization tasks.
   *
   * This method is called when the associated {@link EffectPass} is added to an {@link EffectComposer}.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   * @example if(!alpha && frameBufferType === UnsignedByteType) { this.myRenderTarget.texture.format = RGBFormat; }
   */
  initialize(renderer, alpha, frameBufferType) {
  }
  /**
   * Performs a shallow search for properties that define a dispose method and deletes them.
   *
   * The {@link EffectComposer} calls this method when it is being destroyed.
   */
  dispose() {
    for (const key of Object.keys(this)) {
      const property = this[key];
      const isDisposable = property instanceof WebGLRenderTarget || property instanceof Material || property instanceof Texture || property instanceof Pass;
      if (isDisposable) {
        this[key].dispose();
      }
    }
  }
};
var bloom_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D map;\n#else\nuniform lowp sampler2D map;\n#endif\nuniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 texel=texture2D(map,uv);outputColor=vec4(texel.rgb*intensity,texel.a);}";
var BloomEffect = class extends Effect {
  /**
   * Constructs a new bloom effect.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.SCREEN] - The blend function of this effect.
   * @param {Number} [options.luminanceThreshold=0.9] - The luminance threshold. Raise this value to mask out darker elements in the scene.
   * @param {Number} [options.luminanceSmoothing=0.025] - Controls the smoothness of the luminance threshold.
   * @param {Boolean} [options.mipmapBlur=false] - Enables or disables mipmap blur.
   * @param {Number} [options.intensity=1.0] - The bloom intensity.
   * @param {Number} [options.radius=0.85] - The blur radius. Only applies to mipmap blur.
   * @param {Number} [options.levels=8] - The amount of MIP levels. Only applies to mipmap blur.
   * @param {KernelSize} [options.kernelSize=KernelSize.LARGE] - Deprecated. Use mipmapBlur instead.
   * @param {Number} [options.resolutionScale=0.5] - Deprecated. Use mipmapBlur instead.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.
   */
  constructor({
    blendFunction = BlendFunction.SCREEN,
    luminanceThreshold = 0.9,
    luminanceSmoothing = 0.025,
    mipmapBlur = false,
    intensity = 1,
    radius = 0.85,
    levels: levels2 = 8,
    kernelSize = KernelSize.LARGE,
    resolutionScale = 0.5,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("BloomEffect", bloom_default, {
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([
        ["map", new Uniform$1(null)],
        ["intensity", new Uniform$1(intensity)]
      ])
    });
    this.renderTarget = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTarget.texture.name = "Bloom.Target";
    this.blurPass = new KawaseBlurPass({ kernelSize });
    this.luminancePass = new LuminancePass({ colorOutput: true });
    this.luminanceMaterial.threshold = luminanceThreshold;
    this.luminanceMaterial.smoothing = luminanceSmoothing;
    this.mipmapBlurPass = new MipmapBlurPass();
    this.mipmapBlurPass.enabled = mipmapBlur;
    this.mipmapBlurPass.radius = radius;
    this.mipmapBlurPass.levels = levels2;
    this.uniforms.get("map").value = mipmapBlur ? this.mipmapBlurPass.texture : this.renderTarget.texture;
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
  }
  /**
   * A texture that contains the intermediate result of this effect.
   *
   * @type {Texture}
   */
  get texture() {
    return this.mipmapBlurPass.enabled ? this.mipmapBlurPass.texture : this.renderTarget.texture;
  }
  /**
   * Returns the generated bloom texture.
   *
   * @deprecated Use texture instead.
   * @return {Texture} The texture.
   */
  getTexture() {
    return this.texture;
  }
  /**
   * Returns the resolution settings.
   *
   * @deprecated Use resolution instead.
   * @return {Resolution} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * Returns the blur pass.
   *
   * @deprecated
   * @return {KawaseBlurPass} The blur pass.
   */
  getBlurPass() {
    return this.blurPass;
  }
  /**
   * Returns the luminance pass.
   *
   * @deprecated Use luminancePass instead.
   * @return {LuminancePass} The luminance pass.
   */
  getLuminancePass() {
    return this.luminancePass;
  }
  /**
   * The luminance material.
   *
   * @type {LuminanceMaterial}
   */
  get luminanceMaterial() {
    return this.luminancePass.fullscreenMaterial;
  }
  /**
   * Returns the luminance material.
   *
   * @deprecated Use luminanceMaterial instead.
   * @return {LuminanceMaterial} The material.
   */
  getLuminanceMaterial() {
    return this.luminancePass.fullscreenMaterial;
  }
  /**
   * The current width of the internal render targets.
   *
   * @type {Number}
   * @deprecated
   */
  get width() {
    return this.resolution.width;
  }
  set width(value) {
    this.resolution.preferredWidth = value;
  }
  /**
   * The current height of the internal render targets.
   *
   * @type {Number}
   * @deprecated
   */
  get height() {
    return this.resolution.height;
  }
  set height(value) {
    this.resolution.preferredHeight = value;
  }
  /**
   * Indicates whether dithering is enabled.
   *
   * @type {Boolean}
   * @deprecated Use EffectPass.dithering instead.
   */
  get dithering() {
    return this.blurPass.dithering;
  }
  set dithering(value) {
    this.blurPass.dithering = value;
  }
  /**
   * The blur kernel size.
   *
   * @type {KernelSize}
   * @deprecated
   */
  get kernelSize() {
    return this.blurPass.kernelSize;
  }
  set kernelSize(value) {
    this.blurPass.kernelSize = value;
  }
  /**
   * @type {Number}
   * @deprecated
   */
  get distinction() {
    console.warn(this.name, "distinction was removed");
    return 1;
  }
  set distinction(value) {
    console.warn(this.name, "distinction was removed");
  }
  /**
   * The bloom intensity.
   *
   * @type {Number}
   */
  get intensity() {
    return this.uniforms.get("intensity").value;
  }
  set intensity(value) {
    this.uniforms.get("intensity").value = value;
  }
  /**
   * The bloom intensity.
   *
   * @deprecated Use intensity instead.
   * @return {Number} The intensity.
   */
  getIntensity() {
    return this.intensity;
  }
  /**
   * Sets the bloom intensity.
   *
   * @deprecated Use intensity instead.
   * @param {Number} value - The intensity.
   */
  setIntensity(value) {
    this.intensity = value;
  }
  /**
   * Returns the current resolution scale.
   *
   * @return {Number} The resolution scale.
   * @deprecated
   */
  getResolutionScale() {
    return this.resolution.scale;
  }
  /**
   * Sets the resolution scale.
   *
   * @param {Number} scale - The new resolution scale.
   * @deprecated
   */
  setResolutionScale(scale) {
    this.resolution.scale = scale;
  }
  /**
   * Updates this effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
    const renderTarget2 = this.renderTarget;
    const luminancePass = this.luminancePass;
    if (luminancePass.enabled) {
      luminancePass.render(renderer, inputBuffer);
      if (this.mipmapBlurPass.enabled) {
        this.mipmapBlurPass.render(renderer, luminancePass.renderTarget);
      } else {
        this.blurPass.render(renderer, luminancePass.renderTarget, renderTarget2);
      }
    } else {
      if (this.mipmapBlurPass.enabled) {
        this.mipmapBlurPass.render(renderer, inputBuffer);
      } else {
        this.blurPass.render(renderer, inputBuffer, renderTarget2);
      }
    }
  }
  /**
   * Updates the size of internal render targets.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    this.renderTarget.setSize(resolution.width, resolution.height);
    this.blurPass.resolution.copy(resolution);
    this.luminancePass.setSize(width, height);
    this.mipmapBlurPass.setSize(width, height);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    this.blurPass.initialize(renderer, alpha, frameBufferType);
    this.luminancePass.initialize(renderer, alpha, frameBufferType);
    this.mipmapBlurPass.initialize(renderer, alpha, frameBufferType);
    if (frameBufferType !== void 0) {
      this.renderTarget.texture.type = frameBufferType;
      if (renderer !== null && renderer.outputColorSpace === SRGBColorSpace) {
        this.renderTarget.texture.colorSpace = SRGBColorSpace;
      }
    }
  }
};
var brightness_contrast_default = "uniform float brightness;uniform float contrast;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=inputColor.rgb+vec3(brightness-0.5);if(contrast>0.0){color/=vec3(1.0-contrast);}else{color*=vec3(1.0+contrast);}outputColor=vec4(color+vec3(0.5),inputColor.a);}";
var BrightnessContrastEffect = class extends Effect {
  /**
   * Constructs a new brightness/contrast effect.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.
   * @param {Number} [options.brightness=0.0] - The brightness factor, ranging from -1 to 1, where 0 means no change.
   * @param {Number} [options.contrast=0.0] - The contrast factor, ranging from -1 to 1, where 0 means no change.
   */
  constructor({ blendFunction = BlendFunction.SRC, brightness = 0, contrast = 0 } = {}) {
    super("BrightnessContrastEffect", brightness_contrast_default, {
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([
        ["brightness", new Uniform$1(brightness)],
        ["contrast", new Uniform$1(contrast)]
      ])
    });
    this.inputColorSpace = SRGBColorSpace;
  }
  /**
   * The brightness.
   *
   * @type {Number}
   */
  get brightness() {
    return this.uniforms.get("brightness").value;
  }
  set brightness(value) {
    this.uniforms.get("brightness").value = value;
  }
  /**
   * Returns the brightness.
   *
   * @deprecated Use brightness instead.
   * @return {Number} The brightness.
   */
  getBrightness() {
    return this.brightness;
  }
  /**
   * Sets the brightness.
   *
   * @deprecated Use brightness instead.
   * @param {Number} value - The brightness.
   */
  setBrightness(value) {
    this.brightness = value;
  }
  /**
   * The contrast.
   *
   * @type {Number}
   */
  get contrast() {
    return this.uniforms.get("contrast").value;
  }
  set contrast(value) {
    this.uniforms.get("contrast").value = value;
  }
  /**
   * Returns the contrast.
   *
   * @deprecated Use contrast instead.
   * @return {Number} The contrast.
   */
  getContrast() {
    return this.contrast;
  }
  /**
   * Sets the contrast.
   *
   * @deprecated Use contrast instead.
   * @param {Number} value - The contrast.
   */
  setContrast(value) {
    this.contrast = value;
  }
};
var chromatic_aberration_default = "#ifdef RADIAL_MODULATION\nuniform float modulationOffset;\n#endif\nvarying float vActive;varying vec2 vUvR;varying vec2 vUvB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 ra=inputColor.ra;vec2 ba=inputColor.ba;\n#ifdef RADIAL_MODULATION\nconst vec2 center=vec2(0.5);float d=distance(uv,center)*2.0;d=max(d-modulationOffset,0.0);if(vActive>0.0&&d>0.0){ra=texture2D(inputBuffer,mix(uv,vUvR,d)).ra;ba=texture2D(inputBuffer,mix(uv,vUvB,d)).ba;}\n#else\nif(vActive>0.0){ra=texture2D(inputBuffer,vUvR).ra;ba=texture2D(inputBuffer,vUvB).ba;}\n#endif\noutputColor=vec4(ra.x,inputColor.g,ba.x,max(max(ra.y,ba.y),inputColor.a));}";
var chromatic_aberration_default2 = "uniform vec2 offset;varying float vActive;varying vec2 vUvR;varying vec2 vUvB;void mainSupport(const in vec2 uv){vec2 shift=offset*vec2(1.0,aspect);vActive=(shift.x!=0.0||shift.y!=0.0)?1.0:0.0;vUvR=uv+shift;vUvB=uv-shift;}";
var ChromaticAberrationEffect = class extends Effect {
  /**
   * Constructs a new chromatic aberration effect.
   *
   * @param {Object} [options] - The options.
   * @param {Vector2} [options.offset] - The color offset.
   * @param {Boolean} [options.radialModulation=false] - Whether the effect should be modulated with a radial gradient.
   * @param {Number} [options.modulationOffset=0.15] - The modulation offset. Only applies if `radialModulation` is enabled.
   */
  constructor({
    offset = new Vector2(1e-3, 5e-4),
    radialModulation = false,
    modulationOffset = 0.15
  } = {}) {
    super("ChromaticAberrationEffect", chromatic_aberration_default, {
      vertexShader: chromatic_aberration_default2,
      attributes: EffectAttribute.CONVOLUTION,
      uniforms: /* @__PURE__ */ new Map([
        ["offset", new Uniform$1(offset)],
        ["modulationOffset", new Uniform$1(modulationOffset)]
      ])
    });
    this.radialModulation = radialModulation;
  }
  /**
   * The color offset.
   *
   * @type {Vector2}
   */
  get offset() {
    return this.uniforms.get("offset").value;
  }
  set offset(value) {
    this.uniforms.get("offset").value = value;
  }
  /**
   * Indicates whether radial modulation is enabled.
   *
   * When enabled, the effect will be weaker in the middle and stronger towards the screen edges.
   *
   * @type {Boolean}
   */
  get radialModulation() {
    return this.defines.has("RADIAL_MODULATION");
  }
  set radialModulation(value) {
    if (value) {
      this.defines.set("RADIAL_MODULATION", "1");
    } else {
      this.defines.delete("RADIAL_MODULATION");
    }
    this.setChanged();
  }
  /**
   * The modulation offset.
   *
   * @type {Number}
   */
  get modulationOffset() {
    return this.uniforms.get("modulationOffset").value;
  }
  set modulationOffset(value) {
    this.uniforms.get("modulationOffset").value = value;
  }
  /**
   * Returns the color offset vector.
   *
   * @deprecated Use offset instead.
   * @return {Vector2} The offset.
   */
  getOffset() {
    return this.offset;
  }
  /**
   * Sets the color offset vector.
   *
   * @deprecated Use offset instead.
   * @param {Vector2} value - The offset.
   */
  setOffset(value) {
    this.offset = value;
  }
};
var ColorChannel = {
  RED: 0,
  GREEN: 1,
  BLUE: 2,
  ALPHA: 3
};
var MaskFunction = {
  DISCARD: 0,
  MULTIPLY: 1,
  MULTIPLY_RGB_SET_ALPHA: 2,
  MULTIPLY_RGB: 3
};
var convolution_bokeh_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#if PASS == 1\nuniform vec4 kernel64[32];\n#else\nuniform vec4 kernel16[8];\n#endif\nuniform lowp sampler2D cocBuffer;uniform vec2 texelSize;uniform float scale;varying vec2 vUv;void main(){\n#ifdef FOREGROUND\nvec2 cocNearFar=texture2D(cocBuffer,vUv).rg*scale;float coc=cocNearFar.x;\n#else\nfloat coc=texture2D(cocBuffer,vUv).g*scale;\n#endif\nif(coc==0.0){gl_FragColor=texture2D(inputBuffer,vUv);}else{\n#ifdef FOREGROUND\nvec2 step=texelSize*max(cocNearFar.x,cocNearFar.y);\n#else\nvec2 step=texelSize*coc;\n#endif\n#if PASS == 1\nvec4 acc=vec4(0.0);for(int i=0;i<32;++i){vec4 kernel=kernel64[i];vec2 uv=step*kernel.xy+vUv;acc+=texture2D(inputBuffer,uv);uv=step*kernel.zw+vUv;acc+=texture2D(inputBuffer,uv);}gl_FragColor=acc/64.0;\n#else\nvec4 maxValue=texture2D(inputBuffer,vUv);for(int i=0;i<8;++i){vec4 kernel=kernel16[i];vec2 uv=step*kernel.xy+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);uv=step*kernel.zw+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);}gl_FragColor=maxValue;\n#endif\n}}";
var BokehMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new bokeh material.
   *
   * @param {Boolean} [fill=false] - Enables or disables the bokeh highlight fill mode.
   * @param {Boolean} [foreground=false] - Determines whether this material will be applied to foreground colors.
   */
  constructor(fill = false, foreground = false) {
    super({
      name: "BokehMaterial",
      defines: {
        PASS: fill ? "2" : "1"
      },
      uniforms: {
        inputBuffer: new Uniform$1(null),
        cocBuffer: new Uniform$1(null),
        texelSize: new Uniform$1(new Vector2()),
        kernel64: new Uniform$1(null),
        kernel16: new Uniform$1(null),
        scale: new Uniform$1(1)
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: convolution_bokeh_default,
      vertexShader: common_default
    });
    if (foreground) {
      this.defines.FOREGROUND = "1";
    }
    this.generateKernel();
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Texture} value - The buffer.
   */
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * The circle of confusion buffer.
   *
   * @type {Texture}
   */
  set cocBuffer(value) {
    this.uniforms.cocBuffer.value = value;
  }
  /**
   * Sets the circle of confusion buffer.
   *
   * @deprecated Use cocBuffer instead.
   * @param {Texture} value - The buffer.
   */
  setCoCBuffer(value) {
    this.uniforms.cocBuffer.value = value;
  }
  /**
   * The blur scale.
   *
   * @type {Number}
   */
  get scale() {
    return this.uniforms.scale.value;
  }
  set scale(value) {
    this.uniforms.scale.value = value;
  }
  /**
   * Returns the blur scale.
   *
   * @deprecated Use scale instead.
   * @return {Number} The scale.
   */
  getScale(value) {
    return this.scale;
  }
  /**
   * Sets the blur scale.
   *
   * @deprecated Use scale instead.
   * @param {Number} value - The scale.
   */
  setScale(value) {
    this.scale = value;
  }
  /**
   * Generates the blur kernel.
   *
   * @private
   */
  generateKernel() {
    const GOLDEN_ANGLE = 2.39996323;
    const points64 = new Float64Array(128);
    const points16 = new Float64Array(32);
    let i64 = 0, i16 = 0;
    for (let i = 0, sqrt80 = Math.sqrt(80); i < 80; ++i) {
      const theta = i * GOLDEN_ANGLE;
      const r = Math.sqrt(i) / sqrt80;
      const u2 = r * Math.cos(theta), v32 = r * Math.sin(theta);
      if (i % 5 === 0) {
        points16[i16++] = u2;
        points16[i16++] = v32;
      } else {
        points64[i64++] = u2;
        points64[i64++] = v32;
      }
    }
    this.uniforms.kernel64.value = points64;
    this.uniforms.kernel16.value = points16;
  }
  /**
   * Sets the texel size.
   *
   * @deprecated Use setSize() instead.
   * @param {Number} x - The texel width.
   * @param {Number} y - The texel height.
   */
  setTexelSize(x2, y) {
    this.uniforms.texelSize.value.set(x2, y);
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.uniforms.texelSize.value.set(1 / width, 1 / height);
  }
};
function orthographicDepthToViewZ(depth, near, far) {
  return depth * (near - far) - near;
}
function viewZToOrthographicDepth(viewZ, near, far) {
  return Math.min(Math.max((viewZ + near) / (near - far), 0), 1);
}
var circle_of_confusion_default = "#include <common>\n#include <packing>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform float focusDistance;uniform float focusRange;uniform float cameraNear;uniform float cameraFar;varying vec2 vUv;float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nfloat depth=unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nfloat depth=texture2D(depthBuffer,uv).r;\n#endif\n#ifdef LOG_DEPTH\nfloat d=pow(2.0,depth*log2(cameraFar+1.0))-1.0;float a=cameraFar/(cameraFar-cameraNear);float b=cameraFar*cameraNear/(cameraNear-cameraFar);depth=a+b/d;\n#endif\nreturn depth;}void main(){float depth=readDepth(vUv);\n#ifdef PERSPECTIVE_CAMERA\nfloat viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);\n#else\nfloat linearDepth=depth;\n#endif\nfloat signedDistance=linearDepth-focusDistance;float magnitude=smoothstep(0.0,focusRange,abs(signedDistance));gl_FragColor.rg=magnitude*vec2(step(signedDistance,0.0),step(0.0,signedDistance));}";
var CircleOfConfusionMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new CoC material.
   *
   * @param {Camera} camera - A camera.
   */
  constructor(camera) {
    super({
      name: "CircleOfConfusionMaterial",
      defines: {
        DEPTH_PACKING: "0"
      },
      uniforms: {
        depthBuffer: new Uniform$1(null),
        focusDistance: new Uniform$1(0),
        focusRange: new Uniform$1(0),
        cameraNear: new Uniform$1(0.3),
        cameraFar: new Uniform$1(1e3)
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: circle_of_confusion_default,
      vertexShader: common_default
    });
    this.uniforms.focalLength = this.uniforms.focusRange;
    this.copyCameraSettings(camera);
  }
  /**
   * The current near plane setting.
   *
   * @type {Number}
   * @private
   */
  get near() {
    return this.uniforms.cameraNear.value;
  }
  /**
   * The current far plane setting.
   *
   * @type {Number}
   * @private
   */
  get far() {
    return this.uniforms.cameraFar.value;
  }
  /**
   * The depth buffer.
   *
   * @type {Texture}
   */
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * The depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  set depthPacking(value) {
    this.defines.DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the depth buffer.
   *
   * @deprecated Use depthBuffer and depthPacking instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthBuffer(buffer2, depthPacking = BasicDepthPacking) {
    this.depthBuffer = buffer2;
    this.depthPacking = depthPacking;
  }
  /**
   * The focus distance. Range: [0.0, 1.0].
   *
   * @type {Number}
   */
  get focusDistance() {
    return this.uniforms.focusDistance.value;
  }
  set focusDistance(value) {
    this.uniforms.focusDistance.value = value;
  }
  /**
   * The focus distance in world units.
   *
   * @type {Number}
   */
  get worldFocusDistance() {
    return -orthographicDepthToViewZ(this.focusDistance, this.near, this.far);
  }
  set worldFocusDistance(value) {
    this.focusDistance = viewZToOrthographicDepth(-value, this.near, this.far);
  }
  /**
   * Returns the focus distance.
   *
   * @deprecated Use focusDistance instead.
   * @return {Number} The focus distance.
   */
  getFocusDistance(value) {
    this.uniforms.focusDistance.value = value;
  }
  /**
   * Sets the focus distance.
   *
   * @deprecated Use focusDistance instead.
   * @param {Number} value - The focus distance.
   */
  setFocusDistance(value) {
    this.uniforms.focusDistance.value = value;
  }
  /**
   * The focal length.
   *
   * @deprecated Renamed to focusRange.
   * @type {Number}
   */
  get focalLength() {
    return this.focusRange;
  }
  set focalLength(value) {
    this.focusRange = value;
  }
  /**
   * The focus range. Range: [0.0, 1.0].
   *
   * @type {Number}
   */
  get focusRange() {
    return this.uniforms.focusRange.value;
  }
  set focusRange(value) {
    this.uniforms.focusRange.value = value;
  }
  /**
   * The focus range in world units.
   *
   * @type {Number}
   */
  get worldFocusRange() {
    return -orthographicDepthToViewZ(this.focusRange, this.near, this.far);
  }
  set worldFocusRange(value) {
    this.focusRange = viewZToOrthographicDepth(-value, this.near, this.far);
  }
  /**
   * Returns the focal length.
   *
   * @deprecated Use focusRange instead.
   * @return {Number} The focal length.
   */
  getFocalLength(value) {
    return this.focusRange;
  }
  /**
   * Sets the focal length.
   *
   * @deprecated Use focusRange instead.
   * @param {Number} value - The focal length.
   */
  setFocalLength(value) {
    this.focusRange = value;
  }
  /**
   * Copies the settings of the given camera.
   *
   * @deprecated Use copyCameraSettings instead.
   * @param {Camera} camera - A camera.
   */
  adoptCameraSettings(camera) {
    this.copyCameraSettings(camera);
  }
  /**
   * Copies the settings of the given camera.
   *
   * @param {Camera} camera - A camera.
   */
  copyCameraSettings(camera) {
    if (camera) {
      this.uniforms.cameraNear.value = camera.near;
      this.uniforms.cameraFar.value = camera.far;
      if (camera instanceof PerspectiveCamera) {
        this.defines.PERSPECTIVE_CAMERA = "1";
      } else {
        delete this.defines.PERSPECTIVE_CAMERA;
      }
      this.needsUpdate = true;
    }
  }
};
var mask_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef MASK_PRECISION_HIGH\nuniform mediump sampler2D maskTexture;\n#else\nuniform lowp sampler2D maskTexture;\n#endif\n#if MASK_FUNCTION != 0\nuniform float strength;\n#endif\nvarying vec2 vUv;void main(){\n#if COLOR_CHANNEL == 0\nfloat mask=texture2D(maskTexture,vUv).r;\n#elif COLOR_CHANNEL == 1\nfloat mask=texture2D(maskTexture,vUv).g;\n#elif COLOR_CHANNEL == 2\nfloat mask=texture2D(maskTexture,vUv).b;\n#else\nfloat mask=texture2D(maskTexture,vUv).a;\n#endif\n#if MASK_FUNCTION == 0\n#ifdef INVERTED\nmask=step(mask,0.0);\n#else\nmask=1.0-step(mask,0.0);\n#endif\n#else\nmask=clamp(mask*strength,0.0,1.0);\n#ifdef INVERTED\nmask=1.0-mask;\n#endif\n#endif\n#if MASK_FUNCTION == 3\nvec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=vec4(mask*texel.rgb,texel.a);\n#elif MASK_FUNCTION == 2\ngl_FragColor=vec4(mask*texture2D(inputBuffer,vUv).rgb,mask);\n#else\ngl_FragColor=mask*texture2D(inputBuffer,vUv);\n#endif\n}";
var MaskMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new mask material.
   *
   * @param {Texture} [maskTexture] - The mask texture.
   */
  constructor(maskTexture = null) {
    super({
      name: "MaskMaterial",
      uniforms: {
        maskTexture: new Uniform$1(maskTexture),
        inputBuffer: new Uniform$1(null),
        strength: new Uniform$1(1)
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: mask_default,
      vertexShader: common_default
    });
    this.colorChannel = ColorChannel.RED;
    this.maskFunction = MaskFunction.DISCARD;
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Texture} value - The input buffer.
   */
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * The mask texture.
   *
   * @type {Texture}
   */
  set maskTexture(value) {
    this.uniforms.maskTexture.value = value;
    delete this.defines.MASK_PRECISION_HIGH;
    if (value.type !== UnsignedByteType) {
      this.defines.MASK_PRECISION_HIGH = "1";
    }
    this.needsUpdate = true;
  }
  /**
   * Sets the mask texture.
   *
   * @deprecated Use maskTexture instead.
   * @param {Texture} value - The texture.
   */
  setMaskTexture(value) {
    this.maskTexture = value;
  }
  /**
   * Sets the color channel to use for masking. Default is `ColorChannel.RED`.
   *
   * @type {ColorChannel}
   */
  set colorChannel(value) {
    this.defines.COLOR_CHANNEL = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the color channel to use for masking. Default is `ColorChannel.RED`.
   *
   * @deprecated Use colorChannel instead.
   * @param {ColorChannel} value - The channel.
   */
  setColorChannel(value) {
    this.colorChannel = value;
  }
  /**
   * The masking technique. Default is `MaskFunction.DISCARD`.
   *
   * @type {MaskFunction}
   */
  set maskFunction(value) {
    this.defines.MASK_FUNCTION = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the masking technique. Default is `MaskFunction.DISCARD`.
   *
   * @deprecated Use maskFunction instead.
   * @param {MaskFunction} value - The function.
   */
  setMaskFunction(value) {
    this.maskFunction = value;
  }
  /**
   * Indicates whether the masking is inverted.
   *
   * @type {Boolean}
   */
  get inverted() {
    return this.defines.INVERTED !== void 0;
  }
  set inverted(value) {
    if (this.inverted && !value) {
      delete this.defines.INVERTED;
    } else if (value) {
      this.defines.INVERTED = "1";
    }
    this.needsUpdate = true;
  }
  /**
   * Indicates whether the masking is inverted.
   *
   * @deprecated Use inverted instead.
   * @return {Boolean} Whether the masking is inverted.
   */
  isInverted() {
    return this.inverted;
  }
  /**
   * Determines whether the masking should be inverted.
   *
   * @deprecated Use inverted instead.
   * @param {Boolean} value - Whether the masking should be inverted.
   */
  setInverted(value) {
    this.inverted = value;
  }
  /**
   * The current mask strength.
   *
   * Individual mask values will be clamped to [0.0, 1.0]. Has no effect when the mask function is set to `DISCARD`.
   *
   * @type {Number}
   */
  get strength() {
    return this.uniforms.strength.value;
  }
  set strength(value) {
    this.uniforms.strength.value = value;
  }
  /**
   * Returns the current mask strength.
   *
   * @deprecated Use strength instead.
   * @return {Number} The mask strength.
   */
  getStrength() {
    return this.strength;
  }
  /**
   * Sets the mask strength.
   *
   * Has no effect when the mask function is set to `DISCARD`.
   *
   * @deprecated Use strength instead.
   * @param {Number} value - The mask strength.
   */
  setStrength(value) {
    this.strength = value;
  }
};
var ShaderPass = class extends Pass {
  /**
   * Constructs a new shader pass.
   *
   * @param {ShaderMaterial} material - A shader material.
   * @param {String} [input="inputBuffer"] - The name of the input buffer uniform.
   */
  constructor(material, input = "inputBuffer") {
    super("ShaderPass");
    this.fullscreenMaterial = material;
    this.input = input;
  }
  /**
   * Sets the name of the input buffer uniform.
   *
   * @param {String} input - The name of the input buffer uniform.
   * @deprecated Use input instead.
   */
  setInput(input) {
    this.input = input;
  }
  /**
   * Renders the effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const uniforms = this.fullscreenMaterial.uniforms;
    if (inputBuffer !== null && uniforms !== void 0 && uniforms[this.input] !== void 0) {
      uniforms[this.input].value = inputBuffer.texture;
    }
    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
    renderer.render(this.scene, this.camera);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - A renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0 && frameBufferType !== UnsignedByteType) {
      this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
    }
  }
};
var depth_of_field_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D nearColorBuffer;uniform mediump sampler2D farColorBuffer;\n#else\nuniform lowp sampler2D nearColorBuffer;uniform lowp sampler2D farColorBuffer;\n#endif\nuniform lowp sampler2D nearCoCBuffer;uniform lowp sampler2D farCoCBuffer;uniform float scale;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec4 colorNear=texture2D(nearColorBuffer,uv);vec4 colorFar=texture2D(farColorBuffer,uv);\n#if MASK_FUNCTION == 1\nvec2 cocNearFar=vec2(texture2D(nearCoCBuffer,uv).r,colorFar.a);cocNearFar.x=min(cocNearFar.x*scale,1.0);\n#else\nvec2 cocNearFar=vec2(texture2D(nearCoCBuffer,uv).r,texture2D(farCoCBuffer,uv).g);cocNearFar=min(cocNearFar*scale,1.0);\n#endif\nvec4 result=inputColor*(1.0-cocNearFar.y)+colorFar;result=mix(result,colorNear,cocNearFar.x);outputColor=result;}";
var DepthOfFieldEffect = class extends Effect {
  /**
   * Constructs a new depth of field effect.
   *
   * @param {Camera} camera - The main camera.
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.
   * @param {Number} [options.worldFocusDistance] - The focus distance in world units.
   * @param {Number} [options.worldFocusRange] - The focus distance in world units.
   * @param {Number} [options.focusDistance=0.0] - The normalized focus distance. Range is [0.0, 1.0].
   * @param {Number} [options.focusRange=0.1] - The focus range. Range is [0.0, 1.0].
   * @param {Number} [options.focalLength=0.1] - Deprecated.
   * @param {Number} [options.bokehScale=1.0] - The scale of the bokeh blur.
   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
   */
  constructor(camera, {
    blendFunction,
    worldFocusDistance,
    worldFocusRange,
    focusDistance = 0,
    focalLength = 0.1,
    focusRange = focalLength,
    bokehScale = 1,
    resolutionScale = 1,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("DepthOfFieldEffect", depth_of_field_default, {
      blendFunction,
      attributes: EffectAttribute.DEPTH,
      uniforms: /* @__PURE__ */ new Map([
        ["nearColorBuffer", new Uniform$1(null)],
        ["farColorBuffer", new Uniform$1(null)],
        ["nearCoCBuffer", new Uniform$1(null)],
        ["farCoCBuffer", new Uniform$1(null)],
        ["scale", new Uniform$1(1)]
      ])
    });
    this.camera = camera;
    this.renderTarget = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTarget.texture.name = "DoF.Intermediate";
    this.renderTargetMasked = this.renderTarget.clone();
    this.renderTargetMasked.texture.name = "DoF.Masked.Far";
    this.renderTargetNear = this.renderTarget.clone();
    this.renderTargetNear.texture.name = "DoF.Bokeh.Near";
    this.uniforms.get("nearColorBuffer").value = this.renderTargetNear.texture;
    this.renderTargetFar = this.renderTarget.clone();
    this.renderTargetFar.texture.name = "DoF.Bokeh.Far";
    this.uniforms.get("farColorBuffer").value = this.renderTargetFar.texture;
    this.renderTargetCoC = this.renderTarget.clone();
    this.renderTargetCoC.texture.name = "DoF.CoC";
    this.uniforms.get("farCoCBuffer").value = this.renderTargetCoC.texture;
    this.renderTargetCoCBlurred = this.renderTargetCoC.clone();
    this.renderTargetCoCBlurred.texture.name = "DoF.CoC.Blurred";
    this.uniforms.get("nearCoCBuffer").value = this.renderTargetCoCBlurred.texture;
    this.cocPass = new ShaderPass(new CircleOfConfusionMaterial(camera));
    const cocMaterial = this.cocMaterial;
    cocMaterial.focusDistance = focusDistance;
    cocMaterial.focusRange = focusRange;
    if (worldFocusDistance !== void 0) {
      cocMaterial.worldFocusDistance = worldFocusDistance;
    }
    if (worldFocusRange !== void 0) {
      cocMaterial.worldFocusRange = worldFocusRange;
    }
    this.blurPass = new KawaseBlurPass({ resolutionScale, resolutionX, resolutionY, kernelSize: KernelSize.MEDIUM });
    this.maskPass = new ShaderPass(new MaskMaterial(this.renderTargetCoC.texture));
    const maskMaterial = this.maskPass.fullscreenMaterial;
    maskMaterial.colorChannel = ColorChannel.GREEN;
    this.maskFunction = MaskFunction.MULTIPLY_RGB;
    this.bokehNearBasePass = new ShaderPass(new BokehMaterial(false, true));
    this.bokehNearBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture;
    this.bokehNearFillPass = new ShaderPass(new BokehMaterial(true, true));
    this.bokehNearFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture;
    this.bokehFarBasePass = new ShaderPass(new BokehMaterial(false, false));
    this.bokehFarBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture;
    this.bokehFarFillPass = new ShaderPass(new BokehMaterial(true, false));
    this.bokehFarFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture;
    this.target = null;
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
    this.bokehScale = bokehScale;
  }
  set mainCamera(value) {
    this.camera = value;
    this.cocMaterial.copyCameraSettings(value);
  }
  /**
   * The circle of confusion texture.
   *
   * @type {Texture}
   */
  get cocTexture() {
    return this.renderTargetCoC.texture;
  }
  /**
   * The mask function. Default is `MULTIPLY_RGB`.
   *
   * @type {MaskFunction}
   */
  get maskFunction() {
    return this.maskPass.fullscreenMaterial.maskFunction;
  }
  set maskFunction(value) {
    if (this.maskFunction !== value) {
      this.defines.set("MASK_FUNCTION", value.toFixed(0));
      this.maskPass.fullscreenMaterial.maskFunction = value;
      this.setChanged();
    }
  }
  /**
   * The circle of confusion material.
   *
   * @type {CircleOfConfusionMaterial}
   */
  get cocMaterial() {
    return this.cocPass.fullscreenMaterial;
  }
  /**
   * The circle of confusion material.
   *
   * @deprecated Use cocMaterial instead.
   * @type {CircleOfConfusionMaterial}
   */
  get circleOfConfusionMaterial() {
    return this.cocMaterial;
  }
  /**
   * Returns the circle of confusion material.
   *
   * @deprecated Use cocMaterial instead.
   * @return {CircleOfConfusionMaterial} The material.
   */
  getCircleOfConfusionMaterial() {
    return this.cocMaterial;
  }
  /**
   * Returns the pass that blurs the foreground CoC buffer to soften edges.
   *
   * @deprecated Use blurPass instead.
   * @return {KawaseBlurPass} The blur pass.
   */
  getBlurPass() {
    return this.blurPass;
  }
  /**
   * Returns the resolution settings.
   *
   * @deprecated Use resolution instead.
   * @return {Resolution} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * The current bokeh scale.
   *
   * @type {Number}
   */
  get bokehScale() {
    return this.uniforms.get("scale").value;
  }
  set bokehScale(value) {
    this.bokehNearBasePass.fullscreenMaterial.scale = value;
    this.bokehNearFillPass.fullscreenMaterial.scale = value;
    this.bokehFarBasePass.fullscreenMaterial.scale = value;
    this.bokehFarFillPass.fullscreenMaterial.scale = value;
    this.maskPass.fullscreenMaterial.strength = value;
    this.uniforms.get("scale").value = value;
  }
  /**
   * Returns the current bokeh scale.
   *
   * @deprecated Use bokehScale instead.
   * @return {Number} The scale.
   */
  getBokehScale() {
    return this.bokehScale;
  }
  /**
   * Sets the bokeh scale.
   *
   * @deprecated Use bokehScale instead.
   * @param {Number} value - The scale.
   */
  setBokehScale(value) {
    this.bokehScale = value;
  }
  /**
   * Returns the current auto focus target.
   *
   * @deprecated Use target instead.
   * @return {Vector3} The target.
   */
  getTarget() {
    return this.target;
  }
  /**
   * Sets the auto focus target.
   *
   * @deprecated Use target instead.
   * @param {Vector3} value - The target.
   */
  setTarget(value) {
    this.target = value;
  }
  /**
   * Calculates the focus distance from the camera to the given position.
   *
   * @param {Vector3} target - The target.
   * @return {Number} The normalized focus distance.
   */
  calculateFocusDistance(target) {
    const camera = this.camera;
    const distance = camera.position.distanceTo(target);
    return viewZToOrthographicDepth(-distance, camera.near, camera.far);
  }
  /**
   * Sets the depth texture.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
    this.cocMaterial.depthBuffer = depthTexture;
    this.cocMaterial.depthPacking = depthPacking;
  }
  /**
   * Updates this effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
    const renderTarget2 = this.renderTarget;
    const renderTargetCoC = this.renderTargetCoC;
    const renderTargetCoCBlurred = this.renderTargetCoCBlurred;
    const renderTargetMasked = this.renderTargetMasked;
    if (this.target !== null) {
      const distance = this.calculateFocusDistance(this.target);
      this.cocMaterial.focusDistance = distance;
    }
    this.cocPass.render(renderer, null, renderTargetCoC);
    this.blurPass.render(renderer, renderTargetCoC, renderTargetCoCBlurred);
    this.maskPass.render(renderer, inputBuffer, renderTargetMasked);
    this.bokehFarBasePass.render(renderer, renderTargetMasked, renderTarget2);
    this.bokehFarFillPass.render(renderer, renderTarget2, this.renderTargetFar);
    this.bokehNearBasePass.render(renderer, inputBuffer, renderTarget2);
    this.bokehNearFillPass.render(renderer, renderTarget2, this.renderTargetNear);
  }
  /**
   * Updates the size of internal render targets.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    const w = resolution.width, h = resolution.height;
    this.cocPass.setSize(width, height);
    this.blurPass.setSize(width, height);
    this.maskPass.setSize(width, height);
    this.renderTargetFar.setSize(width, height);
    this.renderTargetCoC.setSize(width, height);
    this.renderTargetMasked.setSize(width, height);
    this.renderTarget.setSize(w, h);
    this.renderTargetNear.setSize(w, h);
    this.renderTargetCoCBlurred.setSize(w, h);
    this.bokehNearBasePass.fullscreenMaterial.setSize(width, height);
    this.bokehNearFillPass.fullscreenMaterial.setSize(width, height);
    this.bokehFarBasePass.fullscreenMaterial.setSize(width, height);
    this.bokehFarFillPass.fullscreenMaterial.setSize(width, height);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    this.cocPass.initialize(renderer, alpha, frameBufferType);
    this.maskPass.initialize(renderer, alpha, frameBufferType);
    this.bokehNearBasePass.initialize(renderer, alpha, frameBufferType);
    this.bokehNearFillPass.initialize(renderer, alpha, frameBufferType);
    this.bokehFarBasePass.initialize(renderer, alpha, frameBufferType);
    this.bokehFarFillPass.initialize(renderer, alpha, frameBufferType);
    this.blurPass.initialize(renderer, alpha, UnsignedByteType);
    if (renderer.capabilities.logarithmicDepthBuffer) {
      this.cocPass.fullscreenMaterial.defines.LOG_DEPTH = "1";
    }
    if (frameBufferType !== void 0) {
      this.renderTarget.texture.type = frameBufferType;
      this.renderTargetNear.texture.type = frameBufferType;
      this.renderTargetFar.texture.type = frameBufferType;
      this.renderTargetMasked.texture.type = frameBufferType;
      if (renderer !== null && renderer.outputColorSpace === SRGBColorSpace) {
        this.renderTarget.texture.colorSpace = SRGBColorSpace;
        this.renderTargetNear.texture.colorSpace = SRGBColorSpace;
        this.renderTargetFar.texture.colorSpace = SRGBColorSpace;
        this.renderTargetMasked.texture.colorSpace = SRGBColorSpace;
      }
    }
  }
};
function getNoise(size, format, type) {
  const channels = /* @__PURE__ */ new Map([
    [LuminanceFormat, 1],
    [RedFormat, 1],
    [RGFormat, 2],
    [RGBAFormat, 4]
  ]);
  let data;
  if (!channels.has(format)) {
    console.error("Invalid noise texture format");
  }
  if (type === UnsignedByteType) {
    data = new Uint8Array(size * channels.get(format));
    for (let i = 0, l = data.length; i < l; ++i) {
      data[i] = Math.random() * 255 + 0.5;
    }
  } else {
    data = new Float32Array(size * channels.get(format));
    for (let i = 0, l = data.length; i < l; ++i) {
      data[i] = Math.random();
    }
  }
  return data;
}
var NoiseTexture = class extends DataTexture {
  /**
   * Constructs a new noise texture.
   *
   * The texture format can be either `LuminanceFormat` or `RGBAFormat`. Additionally, the formats `RedFormat` and
   * `RGFormat` can be used in a WebGL 2 context.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   * @param {Number} [format=LuminanceFormat] - The texture format.
   * @param {Number} [type=UnsignedByteType] - The texture type.
   */
  constructor(width, height, format = LuminanceFormat, type = UnsignedByteType) {
    super(getNoise(width * height, format, type), width, height, format, type);
    this.needsUpdate = true;
  }
};
var DepthTestStrategy = {
  DEFAULT: 0,
  KEEP_MAX_DEPTH: 1,
  DISCARD_MAX_DEPTH: 2
};
var depth_mask_default = "#include <common>\n#include <packing>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer0;uniform highp sampler2D depthBuffer1;\n#else\nuniform mediump sampler2D depthBuffer0;uniform mediump sampler2D depthBuffer1;\n#endif\nuniform sampler2D inputBuffer;uniform vec2 cameraNearFar;float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#endif\n}varying vec2 vUv;void main(){vec2 depth;\n#if DEPTH_PACKING_0 == 3201\ndepth.x=unpackRGBAToDepth(texture2D(depthBuffer0,vUv));\n#else\ndepth.x=texture2D(depthBuffer0,vUv).r;\n#ifdef LOG_DEPTH\nfloat d=pow(2.0,depth.x*log2(cameraNearFar.y+1.0))-1.0;float a=cameraNearFar.y/(cameraNearFar.y-cameraNearFar.x);float b=cameraNearFar.y*cameraNearFar.x/(cameraNearFar.x-cameraNearFar.y);depth.x=a+b/d;\n#endif\n#endif\n#if DEPTH_PACKING_1 == 3201\ndepth.y=unpackRGBAToDepth(texture2D(depthBuffer1,vUv));\n#else\ndepth.y=texture2D(depthBuffer1,vUv).r;\n#ifdef LOG_DEPTH\nfloat d=pow(2.0,depth.y*log2(cameraNearFar.y+1.0))-1.0;float a=cameraNearFar.y/(cameraNearFar.y-cameraNearFar.x);float b=cameraNearFar.y*cameraNearFar.x/(cameraNearFar.x-cameraNearFar.y);depth.y=a+b/d;\n#endif\n#endif\nbool isMaxDepth=(depth.x==1.0);\n#ifdef PERSPECTIVE_CAMERA\ndepth.x=viewZToOrthographicDepth(getViewZ(depth.x),cameraNearFar.x,cameraNearFar.y);depth.y=viewZToOrthographicDepth(getViewZ(depth.y),cameraNearFar.x,cameraNearFar.y);\n#endif\n#if DEPTH_TEST_STRATEGY == 0\nbool keep=depthTest(depth.x,depth.y);\n#elif DEPTH_TEST_STRATEGY == 1\nbool keep=isMaxDepth||depthTest(depth.x,depth.y);\n#else\nbool keep=!isMaxDepth&&depthTest(depth.x,depth.y);\n#endif\nif(keep){gl_FragColor=texture2D(inputBuffer,vUv);}else{discard;}}";
var DepthMaskMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new depth mask material.
   */
  constructor() {
    super({
      name: "DepthMaskMaterial",
      defines: {
        DEPTH_EPSILON: "0.0001",
        DEPTH_PACKING_0: "0",
        DEPTH_PACKING_1: "0",
        DEPTH_TEST_STRATEGY: DepthTestStrategy.KEEP_MAX_DEPTH
      },
      uniforms: {
        inputBuffer: new Uniform$1(null),
        depthBuffer0: new Uniform$1(null),
        depthBuffer1: new Uniform$1(null),
        cameraNearFar: new Uniform$1(new Vector2(1, 1))
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: depth_mask_default,
      vertexShader: common_default
    });
    this.depthMode = LessDepth;
  }
  /**
   * The primary depth buffer.
   *
   * @type {Texture}
   */
  set depthBuffer0(value) {
    this.uniforms.depthBuffer0.value = value;
  }
  /**
   * The primary depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  set depthPacking0(value) {
    this.defines.DEPTH_PACKING_0 = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the base depth buffer.
   *
   * @deprecated Use depthBuffer0 and depthPacking0 instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthBuffer0(buffer2, depthPacking = BasicDepthPacking) {
    this.depthBuffer0 = buffer2;
    this.depthPacking0 = depthPacking;
  }
  /**
   * The secondary depth buffer.
   *
   * @type {Texture}
   */
  set depthBuffer1(value) {
    this.uniforms.depthBuffer1.value = value;
  }
  /**
   * The secondary depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  set depthPacking1(value) {
    this.defines.DEPTH_PACKING_1 = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the depth buffer that will be compared with the base depth buffer.
   *
   * @deprecated Use depthBuffer1 and depthPacking1 instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthBuffer1(buffer2, depthPacking = BasicDepthPacking) {
    this.depthBuffer1 = buffer2;
    this.depthPacking1 = depthPacking;
  }
  /**
   * The strategy for handling maximum depth.
   *
   * @type {DepthTestStrategy}
   */
  get maxDepthStrategy() {
    return Number(this.defines.DEPTH_TEST_STRATEGY);
  }
  set maxDepthStrategy(value) {
    this.defines.DEPTH_TEST_STRATEGY = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Indicates whether maximum depth values should be preserved.
   *
   * @type {Boolean}
   * @deprecated Use maxDepthStrategy instead.
   */
  get keepFar() {
    return this.maxDepthStrategy;
  }
  set keepFar(value) {
    this.maxDepthStrategy = value ? DepthTestStrategy.KEEP_MAX_DEPTH : DepthTestStrategy.DISCARD_MAX_DEPTH;
  }
  /**
   * Returns the strategy for dealing with maximum depth values.
   *
   * @deprecated Use maxDepthStrategy instead.
   * @return {DepthTestStrategy} The strategy.
   */
  getMaxDepthStrategy() {
    return this.maxDepthStrategy;
  }
  /**
   * Sets the strategy for dealing with maximum depth values.
   *
   * @deprecated Use maxDepthStrategy instead.
   * @param {DepthTestStrategy} value - The strategy.
   */
  setMaxDepthStrategy(value) {
    this.maxDepthStrategy = value;
  }
  /**
   * A small error threshold that is used for `EqualDepth` and `NotEqualDepth` tests. Default is `1e-4`.
   *
   * @type {Number}
   */
  get epsilon() {
    return Number(this.defines.DEPTH_EPSILON);
  }
  set epsilon(value) {
    this.defines.DEPTH_EPSILON = value.toFixed(16);
    this.needsUpdate = true;
  }
  /**
   * Returns the current error threshold for depth comparisons.
   *
   * @deprecated Use epsilon instead.
   * @return {Number} The error threshold.
   */
  getEpsilon() {
    return this.epsilon;
  }
  /**
   * Sets the depth comparison error threshold.
   *
   * @deprecated Use epsilon instead.
   * @param {Number} value - The new error threshold.
   */
  setEpsilon(value) {
    this.epsilon = value;
  }
  /**
   * The depth mode.
   *
   * @see https://threejs.org/docs/#api/en/constants/Materials
   * @type {DepthModes}
   */
  get depthMode() {
    return Number(this.defines.DEPTH_MODE);
  }
  set depthMode(value) {
    let depthTest;
    switch (value) {
      case NeverDepth:
        depthTest = "false";
        break;
      case AlwaysDepth:
        depthTest = "true";
        break;
      case EqualDepth:
        depthTest = "abs(d1 - d0) <= DEPTH_EPSILON";
        break;
      case NotEqualDepth:
        depthTest = "abs(d1 - d0) > DEPTH_EPSILON";
        break;
      case LessDepth:
        depthTest = "d0 > d1";
        break;
      case LessEqualDepth:
        depthTest = "d0 >= d1";
        break;
      case GreaterEqualDepth:
        depthTest = "d0 <= d1";
        break;
      case GreaterDepth:
      default:
        depthTest = "d0 < d1";
        break;
    }
    this.defines.DEPTH_MODE = value.toFixed(0);
    this.defines["depthTest(d0, d1)"] = depthTest;
    this.needsUpdate = true;
  }
  /**
   * Returns the current depth mode.
   *
   * @deprecated Use depthMode instead.
   * @return {DepthModes} The depth mode. Default is `LessDepth`.
   */
  getDepthMode() {
    return this.depthMode;
  }
  /**
   * Sets the depth mode.
   *
   * @deprecated Use depthMode instead.
   * @param {DepthModes} mode - The depth mode.
   */
  setDepthMode(mode) {
    this.depthMode = mode;
  }
  /**
   * Copies the settings of the given camera.
   *
   * @deprecated Use copyCameraSettings instead.
   * @param {Camera} camera - A camera.
   */
  adoptCameraSettings(camera) {
    this.copyCameraSettings(camera);
  }
  /**
   * Copies the settings of the given camera.
   *
   * @param {Camera} camera - A camera.
   */
  copyCameraSettings(camera) {
    if (camera) {
      this.uniforms.cameraNearFar.value.set(camera.near, camera.far);
      if (camera instanceof PerspectiveCamera) {
        this.defines.PERSPECTIVE_CAMERA = "1";
      } else {
        delete this.defines.PERSPECTIVE_CAMERA;
      }
      this.needsUpdate = true;
    }
  }
};
var RenderPass = class extends Pass {
  /**
   * Constructs a new render pass.
   *
   * @param {Scene} scene - The scene to render.
   * @param {Camera} camera - The camera to use to render the scene.
   * @param {Material} [overrideMaterial=null] - An override material.
   */
  constructor(scene, camera, overrideMaterial = null) {
    super("RenderPass", scene, camera);
    this.needsSwap = false;
    this.clearPass = new ClearPass();
    this.overrideMaterialManager = overrideMaterial === null ? null : new OverrideMaterialManager(overrideMaterial);
    this.ignoreBackground = false;
    this.skipShadowMapUpdate = false;
    this.selection = null;
  }
  set mainScene(value) {
    this.scene = value;
  }
  set mainCamera(value) {
    this.camera = value;
  }
  get renderToScreen() {
    return super.renderToScreen;
  }
  set renderToScreen(value) {
    super.renderToScreen = value;
    this.clearPass.renderToScreen = value;
  }
  /**
   * The current override material.
   *
   * @type {Material}
   */
  get overrideMaterial() {
    const manager = this.overrideMaterialManager;
    return manager !== null ? manager.material : null;
  }
  set overrideMaterial(value) {
    const manager = this.overrideMaterialManager;
    if (value !== null) {
      if (manager !== null) {
        manager.setMaterial(value);
      } else {
        this.overrideMaterialManager = new OverrideMaterialManager(value);
      }
    } else if (manager !== null) {
      manager.dispose();
      this.overrideMaterialManager = null;
    }
  }
  /**
   * Returns the current override material.
   *
   * @deprecated Use overrideMaterial instead.
   * @return {Material} The material.
   */
  getOverrideMaterial() {
    return this.overrideMaterial;
  }
  /**
   * Sets the override material.
   *
   * @deprecated Use overrideMaterial instead.
   * @return {Material} value - The material.
   */
  setOverrideMaterial(value) {
    this.overrideMaterial = value;
  }
  /**
   * Indicates whether the target buffer should be cleared before rendering.
   *
   * @type {Boolean}
   * @deprecated Use clearPass.enabled instead.
   */
  get clear() {
    return this.clearPass.enabled;
  }
  set clear(value) {
    this.clearPass.enabled = value;
  }
  /**
   * Returns the selection. Default is `null` (no restriction).
   *
   * @deprecated Use selection instead.
   * @return {Selection} The selection.
   */
  getSelection() {
    return this.selection;
  }
  /**
   * Sets the selection. Set to `null` to disable.
   *
   * @deprecated Use selection instead.
   * @param {Selection} value - The selection.
   */
  setSelection(value) {
    this.selection = value;
  }
  /**
   * Indicates whether the scene background is disabled.
   *
   * @deprecated Use ignoreBackground instead.
   * @return {Boolean} Whether the scene background is disabled.
   */
  isBackgroundDisabled() {
    return this.ignoreBackground;
  }
  /**
   * Enables or disables the scene background.
   *
   * @deprecated Use ignoreBackground instead.
   * @param {Boolean} value - Whether the scene background should be disabled.
   */
  setBackgroundDisabled(value) {
    this.ignoreBackground = value;
  }
  /**
   * Indicates whether the shadow map auto update is disabled.
   *
   * @deprecated Use skipShadowMapUpdate instead.
   * @return {Boolean} Whether the shadow map update is disabled.
   */
  isShadowMapDisabled() {
    return this.skipShadowMapUpdate;
  }
  /**
   * Enables or disables the shadow map auto update.
   *
   * @deprecated Use skipShadowMapUpdate instead.
   * @param {Boolean} value - Whether the shadow map auto update should be disabled.
   */
  setShadowMapDisabled(value) {
    this.skipShadowMapUpdate = value;
  }
  /**
   * Returns the clear pass.
   *
   * @deprecated Use clearPass.enabled instead.
   * @return {ClearPass} The clear pass.
   */
  getClearPass() {
    return this.clearPass;
  }
  /**
   * Renders the scene.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const scene = this.scene;
    const camera = this.camera;
    const selection = this.selection;
    const mask = camera.layers.mask;
    const background = scene.background;
    const shadowMapAutoUpdate = renderer.shadowMap.autoUpdate;
    const renderTarget2 = this.renderToScreen ? null : inputBuffer;
    if (selection !== null) {
      camera.layers.set(selection.getLayer());
    }
    if (this.skipShadowMapUpdate) {
      renderer.shadowMap.autoUpdate = false;
    }
    if (this.ignoreBackground || this.clearPass.overrideClearColor !== null) {
      scene.background = null;
    }
    if (this.clearPass.enabled) {
      this.clearPass.render(renderer, inputBuffer);
    }
    renderer.setRenderTarget(renderTarget2);
    if (this.overrideMaterialManager !== null) {
      this.overrideMaterialManager.render(renderer, scene, camera);
    } else {
      renderer.render(scene, camera);
    }
    camera.layers.mask = mask;
    scene.background = background;
    renderer.shadowMap.autoUpdate = shadowMapAutoUpdate;
  }
};
var v = new Vector32();
var m = new Matrix4();
var hue_saturation_default = "uniform vec3 hue;uniform float saturation;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,hue.xyz),dot(inputColor.rgb,hue.zxy),dot(inputColor.rgb,hue.yzx));float average=(color.r+color.g+color.b)/3.0;vec3 diff=average-color;if(saturation>0.0){color+=diff*(1.0-1.0/(1.001-saturation));}else{color+=diff*-saturation;}outputColor=vec4(min(color,1.0),inputColor.a);}";
var HueSaturationEffect = class extends Effect {
  /**
   * Constructs a new hue/saturation effect.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.
   * @param {Number} [options.hue=0.0] - The hue in radians.
   * @param {Number} [options.saturation=0.0] - The saturation factor, ranging from -1 to 1, where 0 means no change.
   */
  constructor({ blendFunction = BlendFunction.SRC, hue = 0, saturation = 0 } = {}) {
    super("HueSaturationEffect", hue_saturation_default, {
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([
        ["hue", new Uniform$1(new Vector32())],
        ["saturation", new Uniform$1(saturation)]
      ])
    });
    this.hue = hue;
  }
  /**
   * The saturation.
   *
   * @type {Number}
   */
  get saturation() {
    return this.uniforms.get("saturation").value;
  }
  set saturation(value) {
    this.uniforms.get("saturation").value = value;
  }
  /**
   * Returns the saturation.
   *
   * @deprecated Use saturation instead.
   * @return {Number} The saturation.
   */
  getSaturation() {
    return this.saturation;
  }
  /**
   * Sets the saturation.
   *
   * @deprecated Use saturation instead.
   * @param {Number} value - The saturation.
   */
  setSaturation(value) {
    this.saturation = value;
  }
  /**
   * The hue.
   *
   * @type {Number}
   */
  get hue() {
    const hue = this.uniforms.get("hue").value;
    return Math.acos((hue.x * 3 - 1) / 2);
  }
  set hue(value) {
    const s = Math.sin(value), c2 = Math.cos(value);
    this.uniforms.get("hue").value.set(
      (2 * c2 + 1) / 3,
      (-Math.sqrt(3) * s - c2 + 1) / 3,
      (Math.sqrt(3) * s - c2 + 1) / 3
    );
  }
  /**
   * Returns the hue.
   *
   * @deprecated Use hue instead.
   * @return {Number} The hue in radians.
   */
  getHue() {
    return this.hue;
  }
  /**
   * Sets the hue.
   *
   * @deprecated Use hue instead.
   * @param {Number} value - The hue in radians.
   */
  setHue(value) {
    this.hue = value;
  }
};
var c = new Color();
var EdgeDetectionMode = {
  DEPTH: 0,
  LUMA: 1,
  COLOR: 2
};
var PredicationMode = {
  DISABLED: 0,
  DEPTH: 1,
  CUSTOM: 2
};
var SMAAPreset = {
  LOW: 0,
  MEDIUM: 1,
  HIGH: 2,
  ULTRA: 3
};
var ToneMappingMode = {
  LINEAR: 0,
  REINHARD: 1,
  REINHARD2: 2,
  REINHARD2_ADAPTIVE: 3,
  UNCHARTED2: 4,
  OPTIMIZED_CINEON: 5,
  CINEON: 5,
  ACES_FILMIC: 6,
  AGX: 7,
  NEUTRAL: 8
};
var VignetteTechnique = {
  DEFAULT: 0,
  ESKIL: 1
};
var DepthPass = class extends Pass {
  /**
   * Constructs a new depth pass.
   *
   * @param {Scene} scene - The scene to render.
   * @param {Camera} camera - The camera to use to render the scene.
   * @param {Object} [options] - The options.
   * @param {WebGLRenderTarget} [options.renderTarget] - A custom render target.
   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
   */
  constructor(scene, camera, {
    renderTarget: renderTarget2,
    resolutionScale = 1,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("DepthPass");
    this.needsSwap = false;
    this.renderPass = new RenderPass(scene, camera, new MeshDepthMaterial({
      depthPacking: RGBADepthPacking
    }));
    const renderPass = this.renderPass;
    renderPass.skipShadowMapUpdate = true;
    renderPass.ignoreBackground = true;
    const clearPass = renderPass.clearPass;
    clearPass.overrideClearColor = new Color(16777215);
    clearPass.overrideClearAlpha = 1;
    this.renderTarget = renderTarget2;
    if (this.renderTarget === void 0) {
      this.renderTarget = new WebGLRenderTarget(1, 1, {
        minFilter: NearestFilter,
        magFilter: NearestFilter
      });
      this.renderTarget.texture.name = "DepthPass.Target";
    }
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
  }
  set mainScene(value) {
    this.renderPass.mainScene = value;
  }
  set mainCamera(value) {
    this.renderPass.mainCamera = value;
  }
  /**
   * The depth texture.
   *
   * @type {Texture}
   */
  get texture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the depth texture.
   *
   * @deprecated Use texture instead.
   * @return {Texture} The texture.
   */
  getTexture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the resolution settings.
   *
   * @deprecated Use resolution instead.
   * @return {Resolution} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * Returns the current resolution scale.
   *
   * @return {Number} The resolution scale.
   * @deprecated Use resolution instead.
   */
  getResolutionScale() {
    return this.resolution.scale;
  }
  /**
   * Sets the resolution scale.
   *
   * @param {Number} scale - The new resolution scale.
   * @deprecated Use resolution instead.
   */
  setResolutionScale(scale) {
    this.resolution.scale = scale;
  }
  /**
   * Renders the scene depth.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const renderTarget2 = this.renderToScreen ? null : this.renderTarget;
    this.renderPass.render(renderer, renderTarget2);
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    this.renderTarget.setSize(resolution.width, resolution.height);
  }
};
var pixelation_default = "uniform bool active;uniform vec4 d;void mainUv(inout vec2 uv){if(active){uv=d.xy*(floor(uv*d.zw)+0.5);}}";
var PixelationEffect = class extends Effect {
  /**
   * Constructs a new pixelation effect.
   *
   * @param {Object} [granularity=30.0] - The pixel granularity.
   */
  constructor(granularity = 30) {
    super("PixelationEffect", pixelation_default, {
      uniforms: /* @__PURE__ */ new Map([
        ["active", new Uniform$1(false)],
        ["d", new Uniform$1(new Vector4())]
      ])
    });
    this.resolution = new Vector2();
    this._granularity = 0;
    this.granularity = granularity;
  }
  /**
   * The pixel granularity.
   *
   * A higher value yields coarser visuals.
   *
   * @type {Number}
   */
  get granularity() {
    return this._granularity;
  }
  set granularity(value) {
    let d = Math.floor(value);
    if (d % 2 > 0) {
      d += 1;
    }
    this._granularity = d;
    this.uniforms.get("active").value = d > 0;
    this.setSize(this.resolution.width, this.resolution.height);
  }
  /**
   * Returns the pixel granularity.
   *
   * @deprecated Use granularity instead.
   * @return {Number} The granularity.
   */
  getGranularity() {
    return this.granularity;
  }
  /**
   * Sets the pixel granularity.
   *
   * @deprecated Use granularity instead.
   * @param {Number} value - The new granularity.
   */
  setGranularity(value) {
    this.granularity = value;
  }
  /**
   * Updates the granularity.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.set(width, height);
    const d = this.granularity;
    const x2 = d / resolution.x;
    const y = d / resolution.y;
    this.uniforms.get("d").value.set(x2, y, 1 / x2, 1 / y);
  }
};
var HALF_PI = Math.PI * 0.5;
var v2 = new Vector32();
var ab = new Vector32();
var SelectiveBloomEffect = class extends BloomEffect {
  /**
   * Constructs a new selective bloom effect.
   *
   * @param {Scene} scene - The main scene.
   * @param {Camera} camera - The main camera.
   * @param {Object} [options] - The options. See {@link BloomEffect} for details.
   */
  constructor(scene, camera, options) {
    super(options);
    this.setAttributes(this.getAttributes() | EffectAttribute.DEPTH);
    this.camera = camera;
    this.depthPass = new DepthPass(scene, camera);
    this.clearPass = new ClearPass(true, false, false);
    this.clearPass.overrideClearColor = new Color(0);
    this.depthMaskPass = new ShaderPass(new DepthMaskMaterial());
    const depthMaskMaterial = this.depthMaskMaterial;
    depthMaskMaterial.copyCameraSettings(camera);
    depthMaskMaterial.depthBuffer1 = this.depthPass.texture;
    depthMaskMaterial.depthPacking1 = RGBADepthPacking;
    depthMaskMaterial.depthMode = EqualDepth;
    this.renderTargetMasked = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTargetMasked.texture.name = "Bloom.Masked";
    this.selection = new Selection();
    this._inverted = false;
    this._ignoreBackground = false;
  }
  set mainScene(value) {
    this.depthPass.mainScene = value;
  }
  set mainCamera(value) {
    this.camera = value;
    this.depthPass.mainCamera = value;
    this.depthMaskMaterial.copyCameraSettings(value);
  }
  /**
   * Returns the selection.
   *
   * @deprecated Use selection instead.
   * @return {Selection} The selection.
   */
  getSelection() {
    return this.selection;
  }
  /**
   * The depth mask material.
   *
   * @type {DepthMaskMaterial}
   * @private
   */
  get depthMaskMaterial() {
    return this.depthMaskPass.fullscreenMaterial;
  }
  /**
   * Indicates whether the selection should be considered inverted.
   *
   * @type {Boolean}
   */
  get inverted() {
    return this._inverted;
  }
  set inverted(value) {
    this._inverted = value;
    this.depthMaskMaterial.depthMode = value ? NotEqualDepth : EqualDepth;
  }
  /**
   * Indicates whether the mask is inverted.
   *
   * @deprecated Use inverted instead.
   * @return {Boolean} Whether the mask is inverted.
   */
  isInverted() {
    return this.inverted;
  }
  /**
   * Enables or disable mask inversion.
   *
   * @deprecated Use inverted instead.
   * @param {Boolean} value - Whether the mask should be inverted.
   */
  setInverted(value) {
    this.inverted = value;
  }
  /**
   * Indicates whether the background colors will be ignored.
   *
   * @type {Boolean}
   */
  get ignoreBackground() {
    return this._ignoreBackground;
  }
  set ignoreBackground(value) {
    this._ignoreBackground = value;
    this.depthMaskMaterial.maxDepthStrategy = value ? DepthTestStrategy.DISCARD_MAX_DEPTH : DepthTestStrategy.KEEP_MAX_DEPTH;
  }
  /**
   * Indicates whether the background is disabled.
   *
   * @deprecated Use ignoreBackground instead.
   * @return {Boolean} Whether the background is disabled.
   */
  isBackgroundDisabled() {
    return this.ignoreBackground;
  }
  /**
   * Enables or disables the background.
   *
   * @deprecated Use ignoreBackground instead.
   * @param {Boolean} value - Whether the background should be disabled.
   */
  setBackgroundDisabled(value) {
    this.ignoreBackground = value;
  }
  /**
   * Sets the depth texture.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
    this.depthMaskMaterial.depthBuffer0 = depthTexture;
    this.depthMaskMaterial.depthPacking0 = depthPacking;
  }
  /**
   * Updates this effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
    const camera = this.camera;
    const selection = this.selection;
    const inverted = this.inverted;
    let renderTarget2 = inputBuffer;
    if (this.ignoreBackground || !inverted || selection.size > 0) {
      const mask = camera.layers.mask;
      camera.layers.set(selection.layer);
      this.depthPass.render(renderer);
      camera.layers.mask = mask;
      renderTarget2 = this.renderTargetMasked;
      this.clearPass.render(renderer, renderTarget2);
      this.depthMaskPass.render(renderer, inputBuffer, renderTarget2);
    }
    super.update(renderer, renderTarget2, deltaTime);
  }
  /**
   * Updates the size of internal render targets.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    super.setSize(width, height);
    this.renderTargetMasked.setSize(width, height);
    this.depthPass.setSize(width, height);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    super.initialize(renderer, alpha, frameBufferType);
    this.clearPass.initialize(renderer, alpha, frameBufferType);
    this.depthPass.initialize(renderer, alpha, frameBufferType);
    this.depthMaskPass.initialize(renderer, alpha, frameBufferType);
    if (renderer !== null && renderer.capabilities.logarithmicDepthBuffer) {
      this.depthMaskPass.fullscreenMaterial.defines.LOG_DEPTH = "1";
    }
    if (frameBufferType !== void 0) {
      this.renderTargetMasked.texture.type = frameBufferType;
      if (renderer !== null && renderer.outputColorSpace === SRGBColorSpace) {
        this.renderTargetMasked.texture.colorSpace = SRGBColorSpace;
      }
    }
  }
};
var edge_detection_default = "varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\n#if EDGE_DETECTION_MODE == 1\n#include <common>\n#endif\n#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}\n#elif PREDICATION_MODE == 2\nuniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}\n#endif\n#if PREDICATION_MODE != 0\nvec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}\n#endif\n#if EDGE_DETECTION_MODE != 0\nuniform sampler2D inputBuffer;\n#endif\nvoid main(){\n#if EDGE_DETECTION_MODE == 0\nconst vec2 threshold=vec2(DEPTH_THRESHOLD);\n#elif PREDICATION_MODE != 0\nvec2 threshold=calculatePredicatedThreshold();\n#else\nconst vec2 threshold=vec2(EDGE_THRESHOLD);\n#endif\n#if EDGE_DETECTION_MODE == 0\nvec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 1\nfloat l=luminance(texture2D(inputBuffer,vUv).rgb);float lLeft=luminance(texture2D(inputBuffer,vUv0).rgb);float lTop=luminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=luminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=luminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=luminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=luminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 2\nvec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#endif\n}";
var edge_detection_default2 = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\nvoid main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);\n#if EDGE_DETECTION_MODE != 0\nvUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);\n#endif\ngl_Position=vec4(position.xy,1.0,1.0);}";
var EdgeDetectionMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new edge detection material.
   *
   * TODO Remove parameters.
   * @param {Vector2} [texelSize] - The screen texel size.
   * @param {EdgeDetectionMode} [mode=EdgeDetectionMode.COLOR] - The edge detection mode.
   */
  constructor(texelSize = new Vector2(), mode = EdgeDetectionMode.COLOR) {
    super({
      name: "EdgeDetectionMaterial",
      defines: {
        THREE_REVISION: REVISION.replace(/\D+/g, ""),
        LOCAL_CONTRAST_ADAPTATION_FACTOR: "2.0",
        EDGE_THRESHOLD: "0.1",
        DEPTH_THRESHOLD: "0.01",
        PREDICATION_MODE: "0",
        PREDICATION_THRESHOLD: "0.01",
        PREDICATION_SCALE: "2.0",
        PREDICATION_STRENGTH: "1.0",
        DEPTH_PACKING: "0"
      },
      uniforms: {
        inputBuffer: new Uniform$1(null),
        depthBuffer: new Uniform$1(null),
        predicationBuffer: new Uniform$1(null),
        texelSize: new Uniform$1(texelSize)
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: edge_detection_default,
      vertexShader: edge_detection_default2
    });
    this.edgeDetectionMode = mode;
  }
  /**
   * The depth buffer.
   *
   * @type {Texture}
   */
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * The depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  set depthPacking(value) {
    this.defines.DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the depth buffer.
   *
   * @deprecated Use depthBuffer and depthPacking instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthBuffer(buffer2, depthPacking = BasicDepthPacking) {
    this.depthBuffer = buffer2;
    this.depthPacking = depthPacking;
  }
  /**
   * The edge detection mode.
   *
   * @type {EdgeDetectionMode}
   */
  get edgeDetectionMode() {
    return Number(this.defines.EDGE_DETECTION_MODE);
  }
  set edgeDetectionMode(value) {
    this.defines.EDGE_DETECTION_MODE = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Returns the edge detection mode.
   *
   * @deprecated Use edgeDetectionMode instead.
   * @return {EdgeDetectionMode} The mode.
   */
  getEdgeDetectionMode() {
    return this.edgeDetectionMode;
  }
  /**
   * Sets the edge detection mode.
   *
   * @deprecated Use edgeDetectionMode instead.
   * @param {EdgeDetectionMode} value - The edge detection mode.
   */
  setEdgeDetectionMode(value) {
    this.edgeDetectionMode = value;
  }
  /**
   * The local contrast adaptation factor. Has no effect if the edge detection mode is set to DEPTH. Default is 2.0.
   *
   * If a neighbor edge has _factor_ times bigger contrast than the current edge, the edge will be discarded.
   *
   * This allows to eliminate spurious crossing edges and is based on the fact that if there is too much contrast in a
   * direction, the perceptual contrast in the other neighbors will be hidden.
   *
   * @type {Number}
   */
  get localContrastAdaptationFactor() {
    return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR);
  }
  set localContrastAdaptationFactor(value) {
    this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = value.toFixed("6");
    this.needsUpdate = true;
  }
  /**
   * Returns the local contrast adaptation factor.
   *
   * @deprecated Use localContrastAdaptationFactor instead.
   * @return {Number} The factor.
   */
  getLocalContrastAdaptationFactor() {
    return this.localContrastAdaptationFactor;
  }
  /**
   * Sets the local contrast adaptation factor. Has no effect if the edge detection mode is set to DEPTH.
   *
   * @deprecated Use localContrastAdaptationFactor instead.
   * @param {Number} value - The local contrast adaptation factor. Default is 2.0.
   */
  setLocalContrastAdaptationFactor(value) {
    this.localContrastAdaptationFactor = value;
  }
  /**
   * The edge detection threshold. Range: [0.0, 0.5].
   *
   * A lower value results in more edges being detected at the expense of performance.
   *
   * For luma- and chroma-based edge detection, 0.1 is a reasonable value and allows to catch most visible edges. 0.05
   * is a rather overkill value that allows to catch 'em all. Darker scenes may require an even lower threshold.
   *
   * If depth-based edge detection is used, the threshold will depend on the scene depth.
   *
   * @type {Number}
   */
  get edgeDetectionThreshold() {
    return Number(this.defines.EDGE_THRESHOLD);
  }
  set edgeDetectionThreshold(value) {
    this.defines.EDGE_THRESHOLD = value.toFixed("6");
    this.defines.DEPTH_THRESHOLD = (value * 0.1).toFixed("6");
    this.needsUpdate = true;
  }
  /**
   * Returns the edge detection threshold.
   *
   * @deprecated Use edgeDetectionThreshold instead.
   * @return {Number} The threshold.
   */
  getEdgeDetectionThreshold() {
    return this.edgeDetectionThreshold;
  }
  /**
   * Sets the edge detection threshold.
   *
   * @deprecated Use edgeDetectionThreshold instead.
   * @param {Number} value - The edge detection threshold. Range: [0.0, 0.5].
   */
  setEdgeDetectionThreshold(value) {
    this.edgeDetectionThreshold = value;
  }
  /**
   * The predication mode.
   *
   * Predicated thresholding allows to better preserve texture details and to improve edge detection using an additional
   * buffer such as a light accumulation or depth buffer.
   *
   * @type {PredicationMode}
   */
  get predicationMode() {
    return Number(this.defines.PREDICATION_MODE);
  }
  set predicationMode(value) {
    this.defines.PREDICATION_MODE = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Returns the predication mode.
   *
   * @deprecated Use predicationMode instead.
   * @return {PredicationMode} The mode.
   */
  getPredicationMode() {
    return this.predicationMode;
  }
  /**
   * Sets the predication mode.
   *
   * @deprecated Use predicationMode instead.
   * @param {PredicationMode} value - The predication mode.
   */
  setPredicationMode(value) {
    this.predicationMode = value;
  }
  /**
   * The predication buffer.
   *
   * @type {Texture}
   */
  set predicationBuffer(value) {
    this.uniforms.predicationBuffer.value = value;
  }
  /**
   * Sets a custom predication buffer.
   *
   * @deprecated Use predicationBuffer instead.
   * @param {Texture} value - The predication buffer.
   */
  setPredicationBuffer(value) {
    this.uniforms.predicationBuffer.value = value;
  }
  /**
   * The predication threshold.
   *
   * @type {Number}
   */
  get predicationThreshold() {
    return Number(this.defines.PREDICATION_THRESHOLD);
  }
  set predicationThreshold(value) {
    this.defines.PREDICATION_THRESHOLD = value.toFixed("6");
    this.needsUpdate = true;
  }
  /**
   * Returns the predication threshold.
   *
   * @deprecated Use predicationThreshold instead.
   * @return {Number} The threshold.
   */
  getPredicationThreshold() {
    return this.predicationThreshold;
  }
  /**
   * Sets the predication threshold.
   *
   * @deprecated Use predicationThreshold instead.
   * @param {Number} value - The threshold.
   */
  setPredicationThreshold(value) {
    this.predicationThreshold = value;
  }
  /**
   * The predication scale. Range: [1.0, 5.0].
   *
   * Determines how much the edge detection threshold should be scaled when using predication.
   *
   * @type {Boolean|Texture|Number}
   */
  get predicationScale() {
    return Number(this.defines.PREDICATION_SCALE);
  }
  set predicationScale(value) {
    this.defines.PREDICATION_SCALE = value.toFixed("6");
    this.needsUpdate = true;
  }
  /**
   * Returns the predication scale.
   *
   * @deprecated Use predicationScale instead.
   * @return {Number} The scale.
   */
  getPredicationScale() {
    return this.predicationScale;
  }
  /**
   * Sets the predication scale.
   *
   * @deprecated Use predicationScale instead.
   * @param {Number} value - The scale. Range: [1.0, 5.0].
   */
  setPredicationScale(value) {
    this.predicationScale = value;
  }
  /**
   * The predication strength. Range: [0.0, 1.0].
   *
   * Determines how much the edge detection threshold should be decreased locally when using predication.
   *
   * @type {Number}
   */
  get predicationStrength() {
    return Number(this.defines.PREDICATION_STRENGTH);
  }
  set predicationStrength(value) {
    this.defines.PREDICATION_STRENGTH = value.toFixed("6");
    this.needsUpdate = true;
  }
  /**
   * Returns the predication strength.
   *
   * @deprecated Use predicationStrength instead.
   * @return {Number} The strength.
   */
  getPredicationStrength() {
    return this.predicationStrength;
  }
  /**
   * Sets the predication strength.
   *
   * @deprecated Use predicationStrength instead.
   * @param {Number} value - The strength. Range: [0.0, 1.0].
   */
  setPredicationStrength(value) {
    this.predicationStrength = value;
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.uniforms.texelSize.value.set(1 / width, 1 / height);
  }
};
var smaa_weights_default = "#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)\n#if __VERSION__ < 300\n#define round(v) floor(v + 0.5)\n#endif\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);\n#endif\n}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);\n#endif\n}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){\n#if !defined(DISABLE_DIAG_DETECTION)\nweights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){\n#endif\nvec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);\n#if !defined(DISABLE_DIAG_DETECTION)\n}else{e.r=0.0;}\n#endif\n}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}";
var smaa_weights_default2 = "uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}";
var SMAAWeightsMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new SMAA weights material.
   *
   * @param {Vector2} [texelSize] - The absolute screen texel size.
   * @param {Vector2} [resolution] - The resolution.
   */
  constructor(texelSize = new Vector2(), resolution = new Vector2()) {
    super({
      name: "SMAAWeightsMaterial",
      defines: {
        // Configurable settings:
        MAX_SEARCH_STEPS_INT: "16",
        MAX_SEARCH_STEPS_FLOAT: "16.0",
        MAX_SEARCH_STEPS_DIAG_INT: "8",
        MAX_SEARCH_STEPS_DIAG_FLOAT: "8.0",
        CORNER_ROUNDING: "25",
        CORNER_ROUNDING_NORM: "0.25",
        // Non-configurable settings:
        AREATEX_MAX_DISTANCE: "16.0",
        AREATEX_MAX_DISTANCE_DIAG: "20.0",
        AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))",
        AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)",
        SEARCHTEX_SIZE: "vec2(66.0, 33.0)",
        SEARCHTEX_PACKED_SIZE: "vec2(64.0, 16.0)"
      },
      uniforms: {
        inputBuffer: new Uniform$1(null),
        searchTexture: new Uniform$1(null),
        areaTexture: new Uniform$1(null),
        resolution: new Uniform$1(resolution),
        texelSize: new Uniform$1(texelSize)
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: smaa_weights_default,
      vertexShader: smaa_weights_default2
    });
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Texture} value - The input buffer.
   */
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * The search lookup texture.
   *
   * @type {Texture}
   */
  get searchTexture() {
    return this.uniforms.searchTexture.value;
  }
  set searchTexture(value) {
    this.uniforms.searchTexture.value = value;
  }
  /**
   * The area lookup texture.
   *
   * @type {Texture}
   */
  get areaTexture() {
    return this.uniforms.areaTexture.value;
  }
  set areaTexture(value) {
    this.uniforms.areaTexture.value = value;
  }
  /**
   * Sets the search and area lookup textures.
   *
   * @deprecated Use searchTexture and areaTexture instead.
   * @param {Texture} search - The search lookup texture.
   * @param {Texture} area - The area lookup texture.
   */
  setLookupTextures(search, area2) {
    this.searchTexture = search;
    this.areaTexture = area2;
  }
  /**
   * The maximum amount of steps performed in the horizontal/vertical pattern searches, at each side of the pixel.
   * Range: [0, 112].
   *
   * In number of pixels, it's actually the double. So the maximum line length perfectly handled by, for example 16, is
   * 64 (perfectly means that longer lines won't look as good, but are still antialiased).
   *
   * @type {Number}
   */
  get orthogonalSearchSteps() {
    return Number(this.defines.MAX_SEARCH_STEPS_INT);
  }
  set orthogonalSearchSteps(value) {
    const s = Math.min(Math.max(value, 0), 112);
    this.defines.MAX_SEARCH_STEPS_INT = s.toFixed("0");
    this.defines.MAX_SEARCH_STEPS_FLOAT = s.toFixed("1");
    this.needsUpdate = true;
  }
  /**
   * Sets the maximum amount of steps performed in the horizontal/vertical pattern searches, at each side of the pixel.
   *
   * @deprecated Use orthogonalSearchSteps instead.
   * @param {Number} value - The search steps. Range: [0, 112].
   */
  setOrthogonalSearchSteps(value) {
    this.orthogonalSearchSteps = value;
  }
  /**
   * The maximum steps performed in the diagonal pattern searches, at each side of the pixel. This search
   * jumps one pixel at a time. Range: [0, 20].
   *
   * On high-end machines this search is cheap (between 0.8x and 0.9x slower for 16 steps), but it can have a
   * significant impact on older machines.
   *
   * @type {Number}
   */
  get diagonalSearchSteps() {
    return Number(this.defines.MAX_SEARCH_STEPS_DIAG_INT);
  }
  set diagonalSearchSteps(value) {
    const s = Math.min(Math.max(value, 0), 20);
    this.defines.MAX_SEARCH_STEPS_DIAG_INT = s.toFixed("0");
    this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = s.toFixed("1");
    this.needsUpdate = true;
  }
  /**
   * Specifies the maximum steps performed in the diagonal pattern searches, at each side of the pixel.
   *
   * @deprecated Use diagonalSearchSteps instead.
   * @param {Number} value - The search steps. Range: [0, 20].
   */
  setDiagonalSearchSteps(value) {
    this.diagonalSearchSteps = value;
  }
  /**
   * Indicates whether diagonal pattern detection is enabled.
   *
   * @type {Boolean}
   */
  get diagonalDetection() {
    return this.defines.DISABLE_DIAG_DETECTION === void 0;
  }
  set diagonalDetection(value) {
    if (value) {
      delete this.defines.DISABLE_DIAG_DETECTION;
    } else {
      this.defines.DISABLE_DIAG_DETECTION = "1";
    }
    this.needsUpdate = true;
  }
  /**
   * Indicates whether diagonal pattern detection is enabled.
   *
   * @deprecated Use diagonalDetection instead.
   * @return {Boolean} Whether diagonal pattern detection is enabled.
   */
  isDiagonalDetectionEnabled() {
    return this.diagonalDetection;
  }
  /**
   * Enables or disables diagonal pattern detection.
   *
   * @deprecated Use diagonalDetection instead.
   * @param {Boolean} value - Whether diagonal pattern detection should be enabled.
   */
  setDiagonalDetectionEnabled(value) {
    this.diagonalDetection = value;
  }
  /**
   * Specifies how much sharp corners will be rounded. Range: [0, 100].
   *
   * @type {Number}
   */
  get cornerRounding() {
    return Number(this.defines.CORNER_ROUNDING);
  }
  set cornerRounding(value) {
    const r = Math.min(Math.max(value, 0), 100);
    this.defines.CORNER_ROUNDING = r.toFixed("4");
    this.defines.CORNER_ROUNDING_NORM = (r / 100).toFixed("4");
    this.needsUpdate = true;
  }
  /**
   * Specifies how much sharp corners will be rounded.
   *
   * @deprecated Use cornerRounding instead.
   * @param {Number} value - The corner rounding amount. Range: [0, 100].
   */
  setCornerRounding(value) {
    this.cornerRounding = value;
  }
  /**
   * Indicates whether corner detection is enabled.
   *
   * @type {Number}
   */
  get cornerDetection() {
    return this.defines.DISABLE_CORNER_DETECTION === void 0;
  }
  set cornerDetection(value) {
    if (value) {
      delete this.defines.DISABLE_CORNER_DETECTION;
    } else {
      this.defines.DISABLE_CORNER_DETECTION = "1";
    }
    this.needsUpdate = true;
  }
  /**
   * Indicates whether corner rounding is enabled.
   *
   * @deprecated Use cornerDetection instead.
   * @return {Boolean} Whether corner rounding is enabled.
   */
  isCornerRoundingEnabled() {
    return this.cornerDetection;
  }
  /**
   * Enables or disables corner rounding.
   *
   * @deprecated Use cornerDetection instead.
   * @param {Boolean} value - Whether corner rounding should be enabled.
   */
  setCornerRoundingEnabled(value) {
    this.cornerDetection = value;
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const uniforms = this.uniforms;
    uniforms.texelSize.value.set(1 / width, 1 / height);
    uniforms.resolution.value.set(width, height);
  }
};
var searchImageDataURL_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC";
var areaImageDataURL_default = "data:image/png;base64,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";
var smaa_default = "uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}";
var smaa_default2 = "varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}";
var SMAAEffect = class extends Effect {
  /**
   * Constructs a new SMAA effect.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.
   * @param {SMAAPreset} [options.preset=SMAAPreset.MEDIUM] - The quality preset.
   * @param {EdgeDetectionMode} [options.edgeDetectionMode=EdgeDetectionMode.COLOR] - The edge detection mode.
   * @param {PredicationMode} [options.predicationMode=PredicationMode.DISABLED] - The predication mode.
   */
  constructor({
    blendFunction = BlendFunction.SRC,
    preset = SMAAPreset.MEDIUM,
    edgeDetectionMode = EdgeDetectionMode.COLOR,
    predicationMode = PredicationMode.DISABLED
  } = {}) {
    super("SMAAEffect", smaa_default, {
      vertexShader: smaa_default2,
      blendFunction,
      attributes: EffectAttribute.CONVOLUTION | EffectAttribute.DEPTH,
      uniforms: /* @__PURE__ */ new Map([
        ["weightMap", new Uniform$1(null)]
      ])
    });
    let searchImage, areaImage;
    if (arguments.length > 1) {
      searchImage = arguments[0];
      areaImage = arguments[1];
      if (arguments.length > 2) {
        preset = arguments[2];
      }
      if (arguments.length > 3) {
        edgeDetectionMode = arguments[3];
      }
    }
    this.renderTargetEdges = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTargetEdges.texture.name = "SMAA.Edges";
    this.renderTargetWeights = this.renderTargetEdges.clone();
    this.renderTargetWeights.texture.name = "SMAA.Weights";
    this.uniforms.get("weightMap").value = this.renderTargetWeights.texture;
    this.clearPass = new ClearPass(true, false, false);
    this.clearPass.overrideClearColor = new Color(0);
    this.clearPass.overrideClearAlpha = 1;
    this.edgeDetectionPass = new ShaderPass(new EdgeDetectionMaterial());
    this.edgeDetectionMaterial.edgeDetectionMode = edgeDetectionMode;
    this.edgeDetectionMaterial.predicationMode = predicationMode;
    this.weightsPass = new ShaderPass(new SMAAWeightsMaterial());
    const loadingManager = new LoadingManager();
    loadingManager.onLoad = () => {
      const searchTexture = new Texture(searchImage);
      searchTexture.name = "SMAA.Search";
      searchTexture.magFilter = NearestFilter;
      searchTexture.minFilter = NearestFilter;
      searchTexture.generateMipmaps = false;
      searchTexture.needsUpdate = true;
      searchTexture.flipY = true;
      this.weightsMaterial.searchTexture = searchTexture;
      const areaTexture = new Texture(areaImage);
      areaTexture.name = "SMAA.Area";
      areaTexture.magFilter = LinearFilter;
      areaTexture.minFilter = LinearFilter;
      areaTexture.generateMipmaps = false;
      areaTexture.needsUpdate = true;
      areaTexture.flipY = false;
      this.weightsMaterial.areaTexture = areaTexture;
      this.dispatchEvent({ type: "load" });
    };
    loadingManager.itemStart("search");
    loadingManager.itemStart("area");
    if (searchImage !== void 0 && areaImage !== void 0) {
      loadingManager.itemEnd("search");
      loadingManager.itemEnd("area");
    } else if (typeof Image !== "undefined") {
      searchImage = new Image();
      areaImage = new Image();
      searchImage.addEventListener("load", () => loadingManager.itemEnd("search"));
      areaImage.addEventListener("load", () => loadingManager.itemEnd("area"));
      searchImage.src = searchImageDataURL_default;
      areaImage.src = areaImageDataURL_default;
    }
    this.applyPreset(preset);
  }
  /**
   * The edges texture.
   *
   * @type {Texture}
   */
  get edgesTexture() {
    return this.renderTargetEdges.texture;
  }
  /**
   * Returns the edges texture.
   *
   * @deprecated Use edgesTexture instead.
   * @return {Texture} The texture.
   */
  getEdgesTexture() {
    return this.edgesTexture;
  }
  /**
   * The edge weights texture.
   *
   * @type {Texture}
   */
  get weightsTexture() {
    return this.renderTargetWeights.texture;
  }
  /**
   * Returns the edge weights texture.
   *
   * @deprecated Use weightsTexture instead.
   * @return {Texture} The texture.
   */
  getWeightsTexture() {
    return this.weightsTexture;
  }
  /**
   * The edge detection material.
   *
   * @type {EdgeDetectionMaterial}
   */
  get edgeDetectionMaterial() {
    return this.edgeDetectionPass.fullscreenMaterial;
  }
  /**
   * The edge detection material.
   *
   * @type {EdgeDetectionMaterial}
   * @deprecated Use edgeDetectionMaterial instead.
   */
  get colorEdgesMaterial() {
    return this.edgeDetectionMaterial;
  }
  /**
   * Returns the edge detection material.
   *
   * @deprecated Use edgeDetectionMaterial instead.
   * @return {EdgeDetectionMaterial} The material.
   */
  getEdgeDetectionMaterial() {
    return this.edgeDetectionMaterial;
  }
  /**
   * The edge weights material.
   *
   * @type {SMAAWeightsMaterial}
   */
  get weightsMaterial() {
    return this.weightsPass.fullscreenMaterial;
  }
  /**
   * Returns the edge weights material.
   *
   * @deprecated Use weightsMaterial instead.
   * @return {SMAAWeightsMaterial} The material.
   */
  getWeightsMaterial() {
    return this.weightsMaterial;
  }
  /**
   * Sets the edge detection sensitivity.
   *
   * See {@link EdgeDetectionMaterial#setEdgeDetectionThreshold} for more details.
   *
   * @deprecated Use edgeDetectionMaterial instead.
   * @param {Number} threshold - The edge detection sensitivity. Range: [0.05, 0.5].
   */
  setEdgeDetectionThreshold(threshold) {
    this.edgeDetectionMaterial.edgeDetectionThreshold = threshold;
  }
  /**
   * Sets the maximum amount of horizontal/vertical search steps.
   *
   * See {@link SMAAWeightsMaterial#setOrthogonalSearchSteps} for more details.
   *
   * @deprecated Use weightsMaterial instead.
   * @param {Number} steps - The search steps. Range: [0, 112].
   */
  setOrthogonalSearchSteps(steps) {
    this.weightsMaterial.orthogonalSearchSteps = steps;
  }
  /**
   * Applies the given quality preset.
   *
   * @param {SMAAPreset} preset - The preset.
   */
  applyPreset(preset) {
    const edgeDetectionMaterial = this.edgeDetectionMaterial;
    const weightsMaterial = this.weightsMaterial;
    switch (preset) {
      case SMAAPreset.LOW:
        edgeDetectionMaterial.edgeDetectionThreshold = 0.15;
        weightsMaterial.orthogonalSearchSteps = 4;
        weightsMaterial.diagonalDetection = false;
        weightsMaterial.cornerDetection = false;
        break;
      case SMAAPreset.MEDIUM:
        edgeDetectionMaterial.edgeDetectionThreshold = 0.1;
        weightsMaterial.orthogonalSearchSteps = 8;
        weightsMaterial.diagonalDetection = false;
        weightsMaterial.cornerDetection = false;
        break;
      case SMAAPreset.HIGH:
        edgeDetectionMaterial.edgeDetectionThreshold = 0.1;
        weightsMaterial.orthogonalSearchSteps = 16;
        weightsMaterial.diagonalSearchSteps = 8;
        weightsMaterial.cornerRounding = 25;
        weightsMaterial.diagonalDetection = true;
        weightsMaterial.cornerDetection = true;
        break;
      case SMAAPreset.ULTRA:
        edgeDetectionMaterial.edgeDetectionThreshold = 0.05;
        weightsMaterial.orthogonalSearchSteps = 32;
        weightsMaterial.diagonalSearchSteps = 16;
        weightsMaterial.cornerRounding = 25;
        weightsMaterial.diagonalDetection = true;
        weightsMaterial.cornerDetection = true;
        break;
    }
  }
  /**
   * Sets the depth texture.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
    this.edgeDetectionMaterial.depthBuffer = depthTexture;
    this.edgeDetectionMaterial.depthPacking = depthPacking;
  }
  /**
   * Updates this effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
    this.clearPass.render(renderer, this.renderTargetEdges);
    this.edgeDetectionPass.render(renderer, inputBuffer, this.renderTargetEdges);
    this.weightsPass.render(renderer, this.renderTargetEdges, this.renderTargetWeights);
  }
  /**
   * Updates the size of internal render targets.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.edgeDetectionMaterial.setSize(width, height);
    this.weightsMaterial.setSize(width, height);
    this.renderTargetEdges.setSize(width, height);
    this.renderTargetWeights.setSize(width, height);
  }
  /**
   * Deletes internal render targets and textures.
   */
  dispose() {
    const { searchTexture, areaTexture } = this.weightsMaterial;
    if (searchTexture !== null && areaTexture !== null) {
      searchTexture.dispose();
      areaTexture.dispose();
    }
    super.dispose();
  }
  /**
   * The SMAA search image, encoded as a base64 data URL.
   *
   * @type {String}
   * @deprecated
   */
  static get searchImageDataURL() {
    return searchImageDataURL_default;
  }
  /**
   * The SMAA area image, encoded as a base64 data URL.
   *
   * @type {String}
   * @deprecated
   */
  static get areaImageDataURL() {
    return areaImageDataURL_default;
  }
};
var ssao_default = "#include <common>\n#include <packing>\n#ifdef NORMAL_DEPTH\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D normalDepthBuffer;\n#else\nuniform mediump sampler2D normalDepthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){return texture2D(normalDepthBuffer,uv).a;}\n#else\nuniform lowp sampler2D normalBuffer;\n#if DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}\n#endif\nuniform lowp sampler2D noiseTexture;uniform mat4 inverseProjectionMatrix;uniform mat4 projectionMatrix;uniform vec2 texelSize;uniform vec2 cameraNearFar;uniform float intensity;uniform float minRadiusScale;uniform float fade;uniform float bias;uniform vec2 distanceCutoff;uniform vec2 proximityCutoff;varying vec2 vUv;varying vec2 vUv2;float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#endif\n}vec3 getViewPosition(const in vec2 screenPosition,const in float depth,const in float viewZ){vec4 clipPosition=vec4(vec3(screenPosition,depth)*2.0-1.0,1.0);float clipW=projectionMatrix[2][3]*viewZ+projectionMatrix[3][3];clipPosition*=clipW;return(inverseProjectionMatrix*clipPosition).xyz;}float getAmbientOcclusion(const in vec3 p,const in vec3 n,const in float depth,const in vec2 uv){float radiusScale=1.0-smoothstep(0.0,distanceCutoff.y,depth);radiusScale=radiusScale*(1.0-minRadiusScale)+minRadiusScale;float radius=RADIUS*radiusScale;float noise=texture2D(noiseTexture,vUv2).r;float baseAngle=noise*PI2;float rings=SPIRAL_TURNS*PI2;float occlusion=0.0;int taps=0;for(int i=0;i<SAMPLES_INT;++i){float alpha=(float(i)+0.5)*INV_SAMPLES_FLOAT;float angle=alpha*rings+baseAngle;vec2 rotation=vec2(cos(angle),sin(angle));vec2 coords=alpha*radius*rotation*texelSize+uv;if(coords.s<0.0||coords.s>1.0||coords.t<0.0||coords.t>1.0){continue;}float sampleDepth=readDepth(coords);float viewZ=getViewZ(sampleDepth);\n#ifdef PERSPECTIVE_CAMERA\nfloat linearSampleDepth=viewZToOrthographicDepth(viewZ,cameraNearFar.x,cameraNearFar.y);\n#else\nfloat linearSampleDepth=sampleDepth;\n#endif\nfloat proximity=abs(depth-linearSampleDepth);if(proximity<proximityCutoff.y){float falloff=1.0-smoothstep(proximityCutoff.x,proximityCutoff.y,proximity);vec3 Q=getViewPosition(coords,sampleDepth,viewZ);vec3 v=Q-p;float vv=dot(v,v);float vn=dot(v,n)-bias;float f=max(RADIUS_SQ-vv,0.0)/RADIUS_SQ;occlusion+=(f*f*f*max(vn/(fade+vv),0.0))*falloff;}++taps;}return occlusion/(4.0*max(float(taps),1.0));}void main(){\n#ifdef NORMAL_DEPTH\nvec4 normalDepth=texture2D(normalDepthBuffer,vUv);\n#else\nvec4 normalDepth=vec4(texture2D(normalBuffer,vUv).xyz,readDepth(vUv));\n#endif\nfloat ao=0.0;float depth=normalDepth.a;float viewZ=getViewZ(depth);\n#ifdef PERSPECTIVE_CAMERA\nfloat linearDepth=viewZToOrthographicDepth(viewZ,cameraNearFar.x,cameraNearFar.y);\n#else\nfloat linearDepth=depth;\n#endif\nif(linearDepth<distanceCutoff.y){vec3 viewPosition=getViewPosition(vUv,depth,viewZ);vec3 viewNormal=unpackRGBToNormal(normalDepth.rgb);ao+=getAmbientOcclusion(viewPosition,viewNormal,linearDepth,vUv);float d=smoothstep(distanceCutoff.x,distanceCutoff.y,linearDepth);ao=mix(ao,0.0,d);\n#ifdef LEGACY_INTENSITY\nao=clamp(1.0-pow(1.0-ao,abs(intensity)),0.0,1.0);\n#endif\n}gl_FragColor.r=ao;}";
var ssao_default2 = "uniform vec2 noiseScale;varying vec2 vUv;varying vec2 vUv2;void main(){vUv=position.xy*0.5+0.5;vUv2=vUv*noiseScale;gl_Position=vec4(position.xy,1.0,1.0);}";
var SSAOMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new SSAO material.
   *
   * @param {Camera} camera - A camera.
   */
  constructor(camera) {
    super({
      name: "SSAOMaterial",
      defines: {
        SAMPLES_INT: "0",
        INV_SAMPLES_FLOAT: "0.0",
        SPIRAL_TURNS: "0.0",
        RADIUS: "1.0",
        RADIUS_SQ: "1.0",
        DISTANCE_SCALING: "1",
        DEPTH_PACKING: "0"
      },
      uniforms: {
        depthBuffer: new Uniform$1(null),
        normalBuffer: new Uniform$1(null),
        normalDepthBuffer: new Uniform$1(null),
        noiseTexture: new Uniform$1(null),
        inverseProjectionMatrix: new Uniform$1(new Matrix4()),
        projectionMatrix: new Uniform$1(new Matrix4()),
        texelSize: new Uniform$1(new Vector2()),
        cameraNearFar: new Uniform$1(new Vector2()),
        distanceCutoff: new Uniform$1(new Vector2()),
        proximityCutoff: new Uniform$1(new Vector2()),
        noiseScale: new Uniform$1(new Vector2()),
        minRadiusScale: new Uniform$1(0.33),
        intensity: new Uniform$1(1),
        fade: new Uniform$1(0.01),
        bias: new Uniform$1(0)
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: ssao_default,
      vertexShader: ssao_default2
    });
    this.copyCameraSettings(camera);
    this.resolution = new Vector2();
    this.r = 1;
  }
  /**
   * The current near plane setting.
   *
   * @type {Number}
   * @private
   */
  get near() {
    return this.uniforms.cameraNearFar.value.x;
  }
  /**
   * The current far plane setting.
   *
   * @type {Number}
   * @private
   */
  get far() {
    return this.uniforms.cameraNearFar.value.y;
  }
  /**
   * A combined normal-depth buffer.
   *
   * @type {Texture}
   */
  set normalDepthBuffer(value) {
    this.uniforms.normalDepthBuffer.value = value;
    if (value !== null) {
      this.defines.NORMAL_DEPTH = "1";
    } else {
      delete this.defines.NORMAL_DEPTH;
    }
    this.needsUpdate = true;
  }
  /**
   * Sets the combined normal-depth buffer.
   *
   * @deprecated Use normalDepthBuffer instead.
   * @param {Number} value - The buffer.
   */
  setNormalDepthBuffer(value) {
    this.normalDepthBuffer = value;
  }
  /**
   * The normal buffer.
   *
   * @type {Texture}
   */
  set normalBuffer(value) {
    this.uniforms.normalBuffer.value = value;
  }
  /**
   * Sets the normal buffer.
   *
   * @deprecated Use normalBuffer instead.
   * @param {Number} value - The buffer.
   */
  setNormalBuffer(value) {
    this.uniforms.normalBuffer.value = value;
  }
  /**
   * The depth buffer.
   *
   * @type {Texture}
   */
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * The depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  set depthPacking(value) {
    this.defines.DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the depth buffer.
   *
   * @deprecated Use depthBuffer and depthPacking instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthBuffer(buffer2, depthPacking = BasicDepthPacking) {
    this.depthBuffer = buffer2;
    this.depthPacking = depthPacking;
  }
  /**
   * The noise texture.
   *
   * @type {Texture}
   */
  set noiseTexture(value) {
    this.uniforms.noiseTexture.value = value;
  }
  /**
   * Sets the noise texture.
   *
   * @deprecated Use noiseTexture instead.
   * @param {Number} value - The texture.
   */
  setNoiseTexture(value) {
    this.uniforms.noiseTexture.value = value;
  }
  /**
   * The sample count.
   *
   * @type {Number}
   */
  get samples() {
    return Number(this.defines.SAMPLES_INT);
  }
  set samples(value) {
    this.defines.SAMPLES_INT = value.toFixed(0);
    this.defines.INV_SAMPLES_FLOAT = (1 / value).toFixed(9);
    this.needsUpdate = true;
  }
  /**
   * Returns the amount of occlusion samples per pixel.
   *
   * @deprecated Use samples instead.
   * @return {Number} The sample count.
   */
  getSamples() {
    return this.samples;
  }
  /**
   * Sets the amount of occlusion samples per pixel.
   *
   * @deprecated Use samples instead.
   * @param {Number} value - The sample count.
   */
  setSamples(value) {
    this.samples = value;
  }
  /**
   * The sampling spiral ring count.
   *
   * @type {Number}
   */
  get rings() {
    return Number(this.defines.SPIRAL_TURNS);
  }
  set rings(value) {
    this.defines.SPIRAL_TURNS = value.toFixed(1);
    this.needsUpdate = true;
  }
  /**
   * Returns the amount of spiral turns in the occlusion sampling pattern.
   *
   * @deprecated Use rings instead.
   * @return {Number} The radius.
   */
  getRings() {
    return this.rings;
  }
  /**
   * Sets the amount of spiral turns in the occlusion sampling pattern.
   *
   * @deprecated Use rings instead.
   * @param {Number} value - The radius.
   */
  setRings(value) {
    this.rings = value;
  }
  /**
   * The intensity.
   *
   * @type {Number}
   * @deprecated Use SSAOEffect.intensity instead.
   */
  get intensity() {
    return this.uniforms.intensity.value;
  }
  set intensity(value) {
    this.uniforms.intensity.value = value;
    if (this.defines.LEGACY_INTENSITY === void 0) {
      this.defines.LEGACY_INTENSITY = "1";
      this.needsUpdate = true;
    }
  }
  /**
   * Returns the intensity.
   *
   * @deprecated Use SSAOEffect.intensity instead.
   * @return {Number} The intensity.
   */
  getIntensity() {
    return this.uniforms.intensity.value;
  }
  /**
   * Sets the intensity.
   *
   * @deprecated Use SSAOEffect.intensity instead.
   * @param {Number} value - The intensity.
   */
  setIntensity(value) {
    this.uniforms.intensity.value = value;
  }
  /**
   * The depth fade factor.
   *
   * @type {Number}
   */
  get fade() {
    return this.uniforms.fade.value;
  }
  set fade(value) {
    this.uniforms.fade.value = value;
  }
  /**
   * Returns the depth fade factor.
   *
   * @deprecated Use fade instead.
   * @return {Number} The fade factor.
   */
  getFade() {
    return this.uniforms.fade.value;
  }
  /**
   * Sets the depth fade factor.
   *
   * @deprecated Use fade instead.
   * @param {Number} value - The fade factor.
   */
  setFade(value) {
    this.uniforms.fade.value = value;
  }
  /**
   * The depth bias. Range: [0.0, 1.0].
   *
   * @type {Number}
   */
  get bias() {
    return this.uniforms.bias.value;
  }
  set bias(value) {
    this.uniforms.bias.value = value;
  }
  /**
   * Returns the depth bias.
   *
   * @deprecated Use bias instead.
   * @return {Number} The bias.
   */
  getBias() {
    return this.uniforms.bias.value;
  }
  /**
   * Sets the depth bias.
   *
   * @deprecated Use bias instead.
   * @param {Number} value - The bias.
   */
  setBias(value) {
    this.uniforms.bias.value = value;
  }
  /**
   * The minimum radius scale for distance scaling. Range: [0.0, 1.0].
   *
   * @type {Number}
   */
  get minRadiusScale() {
    return this.uniforms.minRadiusScale.value;
  }
  set minRadiusScale(value) {
    this.uniforms.minRadiusScale.value = value;
  }
  /**
   * Returns the minimum radius scale for distance scaling.
   *
   * @deprecated Use minRadiusScale instead.
   * @return {Number} The minimum radius scale.
   */
  getMinRadiusScale() {
    return this.uniforms.minRadiusScale.value;
  }
  /**
   * Sets the minimum radius scale for distance scaling.
   *
   * @deprecated Use minRadiusScale instead.
   * @param {Number} value - The minimum radius scale.
   */
  setMinRadiusScale(value) {
    this.uniforms.minRadiusScale.value = value;
  }
  /**
   * Updates the absolute radius.
   *
   * @private
   */
  updateRadius() {
    const radius = this.r * this.resolution.height;
    this.defines.RADIUS = radius.toFixed(11);
    this.defines.RADIUS_SQ = (radius * radius).toFixed(11);
    this.needsUpdate = true;
  }
  /**
   * The occlusion sampling radius. Range: [0.0, 1.0].
   *
   * @type {Number}
   */
  get radius() {
    return this.r;
  }
  set radius(value) {
    this.r = Math.min(Math.max(value, 1e-6), 1);
    this.updateRadius();
  }
  /**
   * Returns the occlusion sampling radius.
   *
   * @deprecated Use radius instead.
   * @return {Number} The radius.
   */
  getRadius() {
    return this.radius;
  }
  /**
   * Sets the occlusion sampling radius.
   *
   * @deprecated Use radius instead.
   * @param {Number} value - The radius. Range [1e-6, 1.0].
   */
  setRadius(value) {
    this.radius = value;
  }
  /**
   * Indicates whether distance-based radius scaling is enabled.
   *
   * @type {Boolean}
   * @deprecated
   */
  get distanceScaling() {
    return true;
  }
  set distanceScaling(value) {
  }
  /**
   * Indicates whether distance-based radius scaling is enabled.
   *
   * @deprecated
   * @return {Boolean} Whether distance scaling is enabled.
   */
  isDistanceScalingEnabled() {
    return this.distanceScaling;
  }
  /**
   * Enables or disables distance-based radius scaling.
   *
   * @deprecated
   * @param {Boolean} value - Whether distance scaling should be enabled.
   */
  setDistanceScalingEnabled(value) {
    this.distanceScaling = value;
  }
  /**
   * The occlusion distance threshold. Range: [0.0, 1.0].
   *
   * @type {Number}
   */
  get distanceThreshold() {
    return this.uniforms.distanceCutoff.value.x;
  }
  set distanceThreshold(value) {
    this.uniforms.distanceCutoff.value.set(
      Math.min(Math.max(value, 0), 1),
      Math.min(Math.max(value + this.distanceFalloff, 0), 1)
    );
  }
  /**
   * The occlusion distance threshold in world units.
   *
   * @type {Number}
   */
  get worldDistanceThreshold() {
    return -orthographicDepthToViewZ(this.distanceThreshold, this.near, this.far);
  }
  set worldDistanceThreshold(value) {
    this.distanceThreshold = viewZToOrthographicDepth(-value, this.near, this.far);
  }
  /**
   * The occlusion distance falloff. Range: [0.0, 1.0].
   *
   * @type {Number}
   */
  get distanceFalloff() {
    return this.uniforms.distanceCutoff.value.y - this.distanceThreshold;
  }
  set distanceFalloff(value) {
    this.uniforms.distanceCutoff.value.y = Math.min(Math.max(this.distanceThreshold + value, 0), 1);
  }
  /**
   * The occlusion distance falloff in world units.
   *
   * @type {Number}
   */
  get worldDistanceFalloff() {
    return -orthographicDepthToViewZ(this.distanceFalloff, this.near, this.far);
  }
  set worldDistanceFalloff(value) {
    this.distanceFalloff = viewZToOrthographicDepth(-value, this.near, this.far);
  }
  /**
   * Sets the occlusion distance cutoff.
   *
   * @deprecated Use distanceThreshold and distanceFalloff instead.
   * @param {Number} threshold - The distance threshold. Range [0.0, 1.0].
   * @param {Number} falloff - The falloff. Range [0.0, 1.0].
   */
  setDistanceCutoff(threshold, falloff) {
    this.uniforms.distanceCutoff.value.set(
      Math.min(Math.max(threshold, 0), 1),
      Math.min(Math.max(threshold + falloff, 0), 1)
    );
  }
  /**
   * The occlusion proximity threshold. Range: [0.0, 1.0].
   *
   * @type {Number}
   */
  get proximityThreshold() {
    return this.uniforms.proximityCutoff.value.x;
  }
  set proximityThreshold(value) {
    this.uniforms.proximityCutoff.value.set(
      Math.min(Math.max(value, 0), 1),
      Math.min(Math.max(value + this.proximityFalloff, 0), 1)
    );
  }
  /**
   * The occlusion proximity threshold in world units.
   *
   * @type {Number}
   */
  get worldProximityThreshold() {
    return -orthographicDepthToViewZ(this.proximityThreshold, this.near, this.far);
  }
  set worldProximityThreshold(value) {
    this.proximityThreshold = viewZToOrthographicDepth(-value, this.near, this.far);
  }
  /**
   * The occlusion proximity falloff. Range: [0.0, 1.0].
   *
   * @type {Number}
   */
  get proximityFalloff() {
    return this.uniforms.proximityCutoff.value.y - this.proximityThreshold;
  }
  set proximityFalloff(value) {
    this.uniforms.proximityCutoff.value.y = Math.min(Math.max(this.proximityThreshold + value, 0), 1);
  }
  /**
   * The occlusion proximity falloff in world units.
   *
   * @type {Number}
   */
  get worldProximityFalloff() {
    return -orthographicDepthToViewZ(this.proximityFalloff, this.near, this.far);
  }
  set worldProximityFalloff(value) {
    this.proximityFalloff = viewZToOrthographicDepth(-value, this.near, this.far);
  }
  /**
   * Sets the occlusion proximity cutoff.
   *
   * @deprecated Use proximityThreshold and proximityFalloff instead.
   * @param {Number} threshold - The range threshold. Range [0.0, 1.0].
   * @param {Number} falloff - The falloff. Range [0.0, 1.0].
   */
  setProximityCutoff(threshold, falloff) {
    this.uniforms.proximityCutoff.value.set(
      Math.min(Math.max(threshold, 0), 1),
      Math.min(Math.max(threshold + falloff, 0), 1)
    );
  }
  /**
   * Sets the texel size.
   *
   * @deprecated Use setSize() instead.
   * @param {Number} x - The texel width.
   * @param {Number} y - The texel height.
   */
  setTexelSize(x2, y) {
    this.uniforms.texelSize.value.set(x2, y);
  }
  /**
   * Copies the settings of the given camera.
   *
   * @deprecated Use copyCameraSettings instead.
   * @param {Camera} camera - A camera.
   */
  adoptCameraSettings(camera) {
    this.copyCameraSettings(camera);
  }
  /**
   * Copies the settings of the given camera.
   *
   * @param {Camera} camera - A camera.
   */
  copyCameraSettings(camera) {
    if (camera) {
      this.uniforms.cameraNearFar.value.set(camera.near, camera.far);
      this.uniforms.projectionMatrix.value.copy(camera.projectionMatrix);
      this.uniforms.inverseProjectionMatrix.value.copy(camera.projectionMatrix).invert();
      if (camera instanceof PerspectiveCamera) {
        this.defines.PERSPECTIVE_CAMERA = "1";
      } else {
        delete this.defines.PERSPECTIVE_CAMERA;
      }
      this.needsUpdate = true;
    }
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const uniforms = this.uniforms;
    const noiseTexture = uniforms.noiseTexture.value;
    if (noiseTexture !== null) {
      uniforms.noiseScale.value.set(
        width / noiseTexture.image.width,
        height / noiseTexture.image.height
      );
    }
    uniforms.texelSize.value.set(1 / width, 1 / height);
    this.resolution.set(width, height);
    this.updateRadius();
  }
};
var depth_downsampling_default = "#include <packing>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\n#ifdef DOWNSAMPLE_NORMALS\nuniform lowp sampler2D normalBuffer;\n#endif\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}int findBestDepth(const in float samples[4]){float c=(samples[0]+samples[1]+samples[2]+samples[3])*0.25;float distances[4];distances[0]=abs(c-samples[0]);distances[1]=abs(c-samples[1]);distances[2]=abs(c-samples[2]);distances[3]=abs(c-samples[3]);float maxDistance=max(max(distances[0],distances[1]),max(distances[2],distances[3]));int remaining[3];int rejected[3];int i,j,k;for(i=0,j=0,k=0;i<4;++i){if(distances[i]<maxDistance){remaining[j++]=i;}else{rejected[k++]=i;}}for(;j<3;++j){remaining[j]=rejected[--k];}vec3 s=vec3(samples[remaining[0]],samples[remaining[1]],samples[remaining[2]]);c=(s.x+s.y+s.z)/3.0;distances[0]=abs(c-s.x);distances[1]=abs(c-s.y);distances[2]=abs(c-s.z);float minDistance=min(distances[0],min(distances[1],distances[2]));for(i=0;i<3;++i){if(distances[i]==minDistance){break;}}return remaining[i];}void main(){float d[4];d[0]=readDepth(vUv0);d[1]=readDepth(vUv1);d[2]=readDepth(vUv2);d[3]=readDepth(vUv3);int index=findBestDepth(d);\n#ifdef DOWNSAMPLE_NORMALS\nvec3 n[4];n[0]=texture2D(normalBuffer,vUv0).rgb;n[1]=texture2D(normalBuffer,vUv1).rgb;n[2]=texture2D(normalBuffer,vUv2).rgb;n[3]=texture2D(normalBuffer,vUv3).rgb;\n#else\nvec3 n[4];n[0]=vec3(0.0);n[1]=vec3(0.0);n[2]=vec3(0.0);n[3]=vec3(0.0);\n#endif\ngl_FragColor=vec4(n[index],d[index]);}";
var depth_downsampling_default2 = "uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=uv;vUv1=vec2(uv.x,uv.y+texelSize.y);vUv2=vec2(uv.x+texelSize.x,uv.y);vUv3=uv+texelSize;gl_Position=vec4(position.xy,1.0,1.0);}";
var DepthDownsamplingMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new depth downsampling material.
   */
  constructor() {
    super({
      name: "DepthDownsamplingMaterial",
      defines: {
        DEPTH_PACKING: "0"
      },
      uniforms: {
        depthBuffer: new Uniform$1(null),
        normalBuffer: new Uniform$1(null),
        texelSize: new Uniform$1(new Vector2())
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: depth_downsampling_default,
      vertexShader: depth_downsampling_default2
    });
  }
  /**
   * The depth buffer.
   *
   * @type {Texture}
   */
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * The depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  set depthPacking(value) {
    this.defines.DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the depth buffer.
   *
   * @deprecated Use depthBuffer and depthPacking instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthBuffer(buffer2, depthPacking = BasicDepthPacking) {
    this.depthBuffer = buffer2;
    this.depthPacking = depthPacking;
  }
  /**
   * The normal buffer.
   *
   * @type {Texture}
   */
  set normalBuffer(value) {
    this.uniforms.normalBuffer.value = value;
    if (value !== null) {
      this.defines.DOWNSAMPLE_NORMALS = "1";
    } else {
      delete this.defines.DOWNSAMPLE_NORMALS;
    }
    this.needsUpdate = true;
  }
  /**
   * Sets the normal buffer.
   *
   * @deprecated Use normalBuffer instead.
   * @param {Texture} value - The normal buffer.
   */
  setNormalBuffer(value) {
    this.normalBuffer = value;
  }
  /**
   * Sets the texel size.
   *
   * @deprecated Use setSize() instead.
   * @param {Number} x - The texel width.
   * @param {Number} y - The texel height.
   */
  setTexelSize(x2, y) {
    this.uniforms.texelSize.value.set(x2, y);
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.uniforms.texelSize.value.set(1 / width, 1 / height);
  }
};
var DepthDownsamplingPass = class extends Pass {
  /**
   * Constructs a new depth downsampling pass.
   *
   * @param {Object} [options] - The options.
   * @param {Texture} [options.normalBuffer=null] - A texture that contains view space normals. See {@link NormalPass}.
   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
   */
  constructor({
    normalBuffer = null,
    resolutionScale = 0.5,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("DepthDownsamplingPass");
    const material = new DepthDownsamplingMaterial();
    material.normalBuffer = normalBuffer;
    this.fullscreenMaterial = material;
    this.needsDepthTexture = true;
    this.needsSwap = false;
    this.renderTarget = new WebGLRenderTarget(1, 1, {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      depthBuffer: false,
      type: FloatType
    });
    this.renderTarget.texture.name = "DepthDownsamplingPass.Target";
    this.renderTarget.texture.generateMipmaps = false;
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
  }
  /**
   * The normal(RGB) + depth(A) texture.
   *
   * @type {Texture}
   */
  get texture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the normal(RGB) + depth(A) texture.
   *
   * @deprecated Use texture instead.
   * @return {Texture} The texture.
   */
  getTexture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the resolution settings.
   *
   * @deprecated Use resolution instead.
   * @return {Resolution} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * Sets the depth texture.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
    this.fullscreenMaterial.depthBuffer = depthTexture;
    this.fullscreenMaterial.depthPacking = depthPacking;
  }
  /**
   * Downsamples depth and scene normals.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);
    renderer.render(this.scene, this.camera);
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    this.renderTarget.setSize(resolution.width, resolution.height);
    this.fullscreenMaterial.setSize(width, height);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    const gl = renderer.getContext();
    const renderable = gl.getExtension("EXT_color_buffer_float") || gl.getExtension("EXT_color_buffer_half_float");
    if (!renderable) {
      throw new Error("Rendering to float texture is not supported.");
    }
  }
};
var ssao_default3 = "uniform lowp sampler2D aoBuffer;uniform float luminanceInfluence;uniform float intensity;\n#if defined(DEPTH_AWARE_UPSAMPLING) && defined(NORMAL_DEPTH)\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D normalDepthBuffer;\n#else\nuniform mediump sampler2D normalDepthBuffer;\n#endif\n#endif\n#ifdef COLORIZE\nuniform vec3 color;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){float aoLinear=texture2D(aoBuffer,uv).r;\n#if defined(DEPTH_AWARE_UPSAMPLING) && defined(NORMAL_DEPTH) && __VERSION__ == 300\nvec4 normalDepth[4];normalDepth[0]=textureOffset(normalDepthBuffer,uv,ivec2(0,0));normalDepth[1]=textureOffset(normalDepthBuffer,uv,ivec2(0,1));normalDepth[2]=textureOffset(normalDepthBuffer,uv,ivec2(1,0));normalDepth[3]=textureOffset(normalDepthBuffer,uv,ivec2(1,1));float dot01=dot(normalDepth[0].rgb,normalDepth[1].rgb);float dot02=dot(normalDepth[0].rgb,normalDepth[2].rgb);float dot03=dot(normalDepth[0].rgb,normalDepth[3].rgb);float minDot=min(dot01,min(dot02,dot03));float s=step(THRESHOLD,minDot);float smallestDistance=1.0;int index;for(int i=0;i<4;++i){float distance=abs(depth-normalDepth[i].a);if(distance<smallestDistance){smallestDistance=distance;index=i;}}ivec2 offsets[4];offsets[0]=ivec2(0,0);offsets[1]=ivec2(0,1);offsets[2]=ivec2(1,0);offsets[3]=ivec2(1,1);ivec2 coord=ivec2(uv*vec2(textureSize(aoBuffer,0)))+offsets[index];float aoNearest=texelFetch(aoBuffer,coord,0).r;float ao=mix(aoNearest,aoLinear,s);\n#else\nfloat ao=aoLinear;\n#endif\nfloat l=luminance(inputColor.rgb);ao=mix(ao,0.0,l*luminanceInfluence);ao=clamp(ao*intensity,0.0,1.0);\n#ifdef COLORIZE\noutputColor=vec4(1.0-ao*(1.0-color),inputColor.a);\n#else\noutputColor=vec4(vec3(1.0-ao),inputColor.a);\n#endif\n}";
var NOISE_TEXTURE_SIZE = 64;
var SSAOEffect = class extends Effect {
  /**
   * Constructs a new SSAO effect.
   *
   * @todo Move normalBuffer to options.
   * @param {Camera} [camera] - The main camera.
   * @param {Texture} [normalBuffer] - A texture that contains the scene normals.
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.MULTIPLY] - The blend function of this effect.
   * @param {Boolean} [options.distanceScaling=true] - Deprecated.
   * @param {Boolean} [options.depthAwareUpsampling=true] - Enables or disables depth-aware upsampling. Has no effect if WebGL 2 is not supported.
   * @param {Texture} [options.normalDepthBuffer=null] - Deprecated.
   * @param {Number} [options.samples=9] - The amount of samples per pixel. Should not be a multiple of the ring count.
   * @param {Number} [options.rings=7] - The amount of spiral turns in the occlusion sampling pattern. Should be a prime number.
   * @param {Number} [options.worldDistanceThreshold] - The world distance threshold at which the occlusion effect starts to fade out.
   * @param {Number} [options.worldDistanceFalloff] - The world distance falloff. Influences the smoothness of the occlusion cutoff.
   * @param {Number} [options.worldProximityThreshold] - The world proximity threshold at which the occlusion starts to fade out.
   * @param {Number} [options.worldProximityFalloff] - The world proximity falloff. Influences the smoothness of the proximity cutoff.
   * @param {Number} [options.distanceThreshold=0.97] - Deprecated.
   * @param {Number} [options.distanceFalloff=0.03] - Deprecated.
   * @param {Number} [options.rangeThreshold=0.0005] - Deprecated.
   * @param {Number} [options.rangeFalloff=0.001] - Deprecated.
   * @param {Number} [options.minRadiusScale=0.1] - The minimum radius scale.
   * @param {Number} [options.luminanceInfluence=0.7] - Determines how much the luminance of the scene influences the ambient occlusion.
   * @param {Number} [options.radius=0.1825] - The occlusion sampling radius, expressed as a scale relative to the resolution. Range [1e-6, 1.0].
   * @param {Number} [options.intensity=1.0] - The intensity of the ambient occlusion.
   * @param {Number} [options.bias=0.025] - An occlusion bias. Eliminates artifacts caused by depth discontinuities.
   * @param {Number} [options.fade=0.01] - Influences the smoothness of the shadows. A lower value results in higher contrast.
   * @param {Color} [options.color=null] - The color of the ambient occlusion.
   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
   */
  constructor(camera, normalBuffer, {
    blendFunction = BlendFunction.MULTIPLY,
    samples = 9,
    rings = 7,
    normalDepthBuffer = null,
    depthAwareUpsampling = true,
    worldDistanceThreshold,
    worldDistanceFalloff,
    worldProximityThreshold,
    worldProximityFalloff,
    distanceThreshold = 0.97,
    distanceFalloff = 0.03,
    rangeThreshold = 5e-4,
    rangeFalloff = 1e-3,
    minRadiusScale = 0.1,
    luminanceInfluence = 0.7,
    radius = 0.1825,
    intensity = 1,
    bias = 0.025,
    fade = 0.01,
    color: color2 = null,
    resolutionScale = 1,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("SSAOEffect", ssao_default3, {
      blendFunction,
      attributes: EffectAttribute.DEPTH,
      defines: /* @__PURE__ */ new Map([
        ["THRESHOLD", "0.997"]
      ]),
      uniforms: /* @__PURE__ */ new Map([
        ["aoBuffer", new Uniform$1(null)],
        ["normalDepthBuffer", new Uniform$1(normalDepthBuffer)],
        ["luminanceInfluence", new Uniform$1(luminanceInfluence)],
        ["color", new Uniform$1(null)],
        ["intensity", new Uniform$1(intensity)],
        ["scale", new Uniform$1(0)]
        // Unused.
      ])
    });
    this.renderTarget = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTarget.texture.name = "AO.Target";
    this.uniforms.get("aoBuffer").value = this.renderTarget.texture;
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
    this.camera = camera;
    this.depthDownsamplingPass = new DepthDownsamplingPass({ normalBuffer, resolutionScale });
    this.depthDownsamplingPass.enabled = normalDepthBuffer === null;
    this.ssaoPass = new ShaderPass(new SSAOMaterial(camera));
    const noiseTexture = new NoiseTexture(NOISE_TEXTURE_SIZE, NOISE_TEXTURE_SIZE, RGBAFormat);
    noiseTexture.wrapS = noiseTexture.wrapT = RepeatWrapping;
    const ssaoMaterial = this.ssaoMaterial;
    ssaoMaterial.normalBuffer = normalBuffer;
    ssaoMaterial.noiseTexture = noiseTexture;
    ssaoMaterial.minRadiusScale = minRadiusScale;
    ssaoMaterial.samples = samples;
    ssaoMaterial.radius = radius;
    ssaoMaterial.rings = rings;
    ssaoMaterial.fade = fade;
    ssaoMaterial.bias = bias;
    ssaoMaterial.distanceThreshold = distanceThreshold;
    ssaoMaterial.distanceFalloff = distanceFalloff;
    ssaoMaterial.proximityThreshold = rangeThreshold;
    ssaoMaterial.proximityFalloff = rangeFalloff;
    if (worldDistanceThreshold !== void 0) {
      ssaoMaterial.worldDistanceThreshold = worldDistanceThreshold;
    }
    if (worldDistanceFalloff !== void 0) {
      ssaoMaterial.worldDistanceFalloff = worldDistanceFalloff;
    }
    if (worldProximityThreshold !== void 0) {
      ssaoMaterial.worldProximityThreshold = worldProximityThreshold;
    }
    if (worldProximityFalloff !== void 0) {
      ssaoMaterial.worldProximityFalloff = worldProximityFalloff;
    }
    if (normalDepthBuffer !== null) {
      this.ssaoMaterial.normalDepthBuffer = normalDepthBuffer;
      this.defines.set("NORMAL_DEPTH", "1");
    }
    this.depthAwareUpsampling = depthAwareUpsampling;
    this.color = color2;
  }
  set mainCamera(value) {
    this.camera = value;
    this.ssaoMaterial.copyCameraSettings(value);
  }
  /**
   * Sets the normal buffer.
   *
   * @type {Texture}
   */
  get normalBuffer() {
    return this.ssaoMaterial.normalBuffer;
  }
  set normalBuffer(value) {
    this.ssaoMaterial.normalBuffer = value;
    this.depthDownsamplingPass.fullscreenMaterial.normalBuffer = value;
  }
  /**
   * Returns the resolution settings.
   *
   * @deprecated Use resolution instead.
   * @return {Resolution} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * The SSAO material.
   *
   * @type {SSAOMaterial}
   */
  get ssaoMaterial() {
    return this.ssaoPass.fullscreenMaterial;
  }
  /**
   * Returns the SSAO material.
   *
   * @deprecated Use ssaoMaterial instead.
   * @return {SSAOMaterial} The material.
   */
  getSSAOMaterial() {
    return this.ssaoMaterial;
  }
  /**
   * The amount of occlusion samples per pixel.
   *
   * @type {Number}
   * @deprecated Use ssaoMaterial.samples instead.
   */
  get samples() {
    return this.ssaoMaterial.samples;
  }
  set samples(value) {
    this.ssaoMaterial.samples = value;
  }
  /**
   * The amount of spiral turns in the occlusion sampling pattern.
   *
   * @type {Number}
   * @deprecated Use ssaoMaterial.rings instead.
   */
  get rings() {
    return this.ssaoMaterial.rings;
  }
  set rings(value) {
    this.ssaoMaterial.rings = value;
  }
  /**
   * The occlusion sampling radius.
   *
   * @type {Number}
   * @deprecated Use ssaoMaterial.radius instead.
   */
  get radius() {
    return this.ssaoMaterial.radius;
  }
  set radius(value) {
    this.ssaoMaterial.radius = value;
  }
  /**
   * Indicates whether depth-aware upsampling is enabled.
   *
   * @type {Boolean}
   */
  get depthAwareUpsampling() {
    return this.defines.has("DEPTH_AWARE_UPSAMPLING");
  }
  set depthAwareUpsampling(value) {
    if (this.depthAwareUpsampling !== value) {
      if (value) {
        this.defines.set("DEPTH_AWARE_UPSAMPLING", "1");
      } else {
        this.defines.delete("DEPTH_AWARE_UPSAMPLING");
      }
      this.setChanged();
    }
  }
  /**
   * Indicates whether depth-aware upsampling is enabled.
   *
   * @deprecated Use depthAwareUpsampling instead.
   * @return {Boolean} Whether depth-aware upsampling is enabled.
   */
  isDepthAwareUpsamplingEnabled() {
    return this.depthAwareUpsampling;
  }
  /**
   * Enables or disables depth-aware upsampling.
   *
   * @deprecated Use depthAwareUpsampling instead.
   * @param {Boolean} value - Whether depth-aware upsampling should be enabled.
   */
  setDepthAwareUpsamplingEnabled(value) {
    this.depthAwareUpsampling = value;
  }
  /**
   * Indicates whether distance-based radius scaling is enabled.
   *
   * @type {Boolean}
   * @deprecated
   */
  get distanceScaling() {
    return true;
  }
  set distanceScaling(value) {
  }
  /**
   * The color of the ambient occlusion. Set to `null` to disable.
   *
   * @type {Color}
   */
  get color() {
    return this.uniforms.get("color").value;
  }
  set color(value) {
    const uniforms = this.uniforms;
    const defines = this.defines;
    if (value !== null) {
      if (defines.has("COLORIZE")) {
        uniforms.get("color").value.set(value);
      } else {
        defines.set("COLORIZE", "1");
        uniforms.get("color").value = new Color(value);
        this.setChanged();
      }
    } else if (defines.has("COLORIZE")) {
      defines.delete("COLORIZE");
      uniforms.get("color").value = null;
      this.setChanged();
    }
  }
  /**
   * The luminance influence factor. Range: [0.0, 1.0].
   *
   * @type {Boolean}
   */
  get luminanceInfluence() {
    return this.uniforms.get("luminanceInfluence").value;
  }
  set luminanceInfluence(value) {
    this.uniforms.get("luminanceInfluence").value = value;
  }
  /**
   * The intensity.
   *
   * @type {Number}
   */
  get intensity() {
    return this.uniforms.get("intensity").value;
  }
  set intensity(value) {
    this.uniforms.get("intensity").value = value;
  }
  /**
   * Returns the color of the ambient occlusion.
   *
   * @deprecated Use color instead.
   * @return {Color} The color.
   */
  getColor() {
    return this.color;
  }
  /**
   * Sets the color of the ambient occlusion. Set to `null` to disable colorization.
   *
   * @deprecated Use color instead.
   * @param {Color} value - The color.
   */
  setColor(value) {
    this.color = value;
  }
  /**
   * Sets the occlusion distance cutoff.
   *
   * @deprecated Use ssaoMaterial instead.
   * @param {Number} threshold - The distance threshold. Range [0.0, 1.0].
   * @param {Number} falloff - The falloff. Range [0.0, 1.0].
   */
  setDistanceCutoff(threshold, falloff) {
    this.ssaoMaterial.distanceThreshold = threshold;
    this.ssaoMaterial.distanceFalloff = falloff;
  }
  /**
   * Sets the occlusion proximity cutoff.
   *
   * @deprecated Use ssaoMaterial instead.
   * @param {Number} threshold - The proximity threshold. Range [0.0, 1.0].
   * @param {Number} falloff - The falloff. Range [0.0, 1.0].
   */
  setProximityCutoff(threshold, falloff) {
    this.ssaoMaterial.proximityThreshold = threshold;
    this.ssaoMaterial.proximityFalloff = falloff;
  }
  /**
   * Sets the depth texture.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
    this.depthDownsamplingPass.setDepthTexture(depthTexture, depthPacking);
    this.ssaoMaterial.depthBuffer = depthTexture;
    this.ssaoMaterial.depthPacking = depthPacking;
  }
  /**
   * Updates this effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
    const renderTarget2 = this.renderTarget;
    if (this.depthDownsamplingPass.enabled) {
      this.depthDownsamplingPass.render(renderer);
    }
    this.ssaoPass.render(renderer, null, renderTarget2);
  }
  /**
   * Sets the size.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    const w = resolution.width, h = resolution.height;
    this.ssaoMaterial.copyCameraSettings(this.camera);
    this.ssaoMaterial.setSize(w, h);
    this.renderTarget.setSize(w, h);
    this.depthDownsamplingPass.resolution.scale = resolution.scale;
    this.depthDownsamplingPass.setSize(width, height);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    try {
      let normalDepthBuffer = this.uniforms.get("normalDepthBuffer").value;
      if (normalDepthBuffer === null) {
        this.depthDownsamplingPass.initialize(renderer, alpha, frameBufferType);
        normalDepthBuffer = this.depthDownsamplingPass.texture;
        this.uniforms.get("normalDepthBuffer").value = normalDepthBuffer;
        this.ssaoMaterial.normalDepthBuffer = normalDepthBuffer;
        this.defines.set("NORMAL_DEPTH", "1");
      }
    } catch (e) {
      this.depthDownsamplingPass.enabled = false;
    }
  }
};
var convolution_tilt_shift_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform vec4 maskParams;varying vec2 vUv;varying vec2 vUv2;varying vec2 vOffset;float linearGradientMask(const in float x){return smoothstep(maskParams.x,maskParams.y,x)-smoothstep(maskParams.w,maskParams.z,x);}void main(){vec2 dUv=vOffset*(1.0-linearGradientMask(vUv2.y));vec4 sum=texture2D(inputBuffer,vec2(vUv.x-dUv.x,vUv.y+dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x+dUv.x,vUv.y+dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x+dUv.x,vUv.y-dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x-dUv.x,vUv.y-dUv.y));gl_FragColor=sum*0.25;\n#include <colorspace_fragment>\n}";
var convolution_tilt_shift_default2 = "uniform vec4 texelSize;uniform float kernel;uniform float scale;uniform float aspect;uniform vec2 rotation;varying vec2 vUv;varying vec2 vUv2;varying vec2 vOffset;void main(){vec2 uv=position.xy*0.5+0.5;vUv=uv;vUv2=(uv-0.5)*2.0*vec2(aspect,1.0);vUv2=vec2(dot(rotation,vUv2),dot(rotation,vec2(vUv2.y,-vUv2.x)));vOffset=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;gl_Position=vec4(position.xy,1.0,1.0);}";
var TiltShiftBlurMaterial = class extends KawaseBlurMaterial {
  /**
   * Constructs a new tilt shift blur material.
   *
   * @param {Object} [options] - The options.
   * @param {Number} [options.offset=0.0] - The relative offset of the focus area.
   * @param {Number} [options.rotation=0.0] - The rotation of the focus area in radians.
   * @param {Number} [options.focusArea=0.4] - The relative size of the focus area.
   * @param {Number} [options.feather=0.3] - The softness of the focus area edges.
   */
  constructor({
    kernelSize = KernelSize.MEDIUM,
    offset = 0,
    rotation = 0,
    focusArea = 0.4,
    feather = 0.3
  } = {}) {
    super();
    this.fragmentShader = convolution_tilt_shift_default;
    this.vertexShader = convolution_tilt_shift_default2;
    this.kernelSize = kernelSize;
    this.uniforms.aspect = new Uniform$1(1);
    this.uniforms.rotation = new Uniform$1(new Vector2());
    this.uniforms.maskParams = new Uniform$1(new Vector4());
    this._offset = offset;
    this._focusArea = focusArea;
    this._feather = feather;
    this.rotation = rotation;
    this.updateParams();
  }
  /**
   * The relative offset of the focus area.
   *
   * @private
   */
  updateParams() {
    const params = this.uniforms.maskParams.value;
    const a = Math.max(this.focusArea, 0);
    const b = Math.max(a - this.feather, 0);
    params.set(
      this.offset - a,
      this.offset - b,
      this.offset + a,
      this.offset + b
    );
  }
  /**
   * The rotation of the focus area in radians.
   *
   * @type {Number}
   */
  get rotation() {
    return Math.acos(this.uniforms.rotation.value.x);
  }
  set rotation(value) {
    this.uniforms.rotation.value.set(Math.cos(value), Math.sin(value));
  }
  /**
   * The relative offset of the focus area.
   *
   * @type {Number}
   */
  get offset() {
    return this._offset;
  }
  set offset(value) {
    this._offset = value;
    this.updateParams();
  }
  /**
   * The relative size of the focus area.
   *
   * @type {Number}
   */
  get focusArea() {
    return this._focusArea;
  }
  set focusArea(value) {
    this._focusArea = value;
    this.updateParams();
  }
  /**
   * The softness of the focus area edges.
   *
   * @type {Number}
   */
  get feather() {
    return this._feather;
  }
  set feather(value) {
    this._feather = value;
    this.updateParams();
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    super.setSize(width, height);
    this.uniforms.aspect.value = width / height;
  }
};
var TiltShiftBlurPass = class extends KawaseBlurPass {
  /**
   * Constructs a new Kawase blur pass.
   *
   * @param {Object} [options] - The options.
   * @param {Number} [options.offset=0.0] - The relative offset of the focus area.
   * @param {Number} [options.rotation=0.0] - The rotation of the focus area in radians.
   * @param {Number} [options.focusArea=0.4] - The relative size of the focus area.
   * @param {Number} [options.feather=0.3] - The softness of the focus area edges.
   * @param {KernelSize} [options.kernelSize=KernelSize.MEDIUM] - The blur kernel size.
   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   */
  constructor({
    offset = 0,
    rotation = 0,
    focusArea = 0.4,
    feather = 0.3,
    kernelSize = KernelSize.MEDIUM,
    resolutionScale = 0.5,
    resolutionX = Resolution.AUTO_SIZE,
    resolutionY = Resolution.AUTO_SIZE
  } = {}) {
    super({ kernelSize, resolutionScale, resolutionX, resolutionY });
    this.blurMaterial = new TiltShiftBlurMaterial({ kernelSize, offset, rotation, focusArea, feather });
  }
};
var tilt_shift_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D map;\n#else\nuniform lowp sampler2D map;\n#endif\nuniform vec2 maskParams;varying vec2 vUv2;float linearGradientMask(const in float x){return step(maskParams.x,x)-step(maskParams.y,x);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float mask=linearGradientMask(vUv2.y);vec4 texel=texture2D(map,uv);outputColor=mix(texel,inputColor,mask);}";
var tilt_shift_default2 = "uniform vec2 rotation;varying vec2 vUv2;void mainSupport(const in vec2 uv){vUv2=(uv-0.5)*2.0*vec2(aspect,1.0);vUv2=vec2(dot(rotation,vUv2),dot(rotation,vec2(vUv2.y,-vUv2.x)));}";
var TiltShiftEffect = class extends Effect {
  /**
   * Constructs a new tilt shift Effect
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.
   * @param {Number} [options.offset=0.0] - The relative offset of the focus area.
   * @param {Number} [options.rotation=0.0] - The rotation of the focus area in radians.
   * @param {Number} [options.focusArea=0.4] - The relative size of the focus area.
   * @param {Number} [options.feather=0.3] - The softness of the focus area edges.
   * @param {Number} [options.bias=0.06] - Deprecated.
   * @param {KernelSize} [options.kernelSize=KernelSize.MEDIUM] - The blur kernel size.
   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   */
  constructor({
    blendFunction,
    offset = 0,
    rotation = 0,
    focusArea = 0.4,
    feather = 0.3,
    kernelSize = KernelSize.MEDIUM,
    resolutionScale = 0.5,
    resolutionX = Resolution.AUTO_SIZE,
    resolutionY = Resolution.AUTO_SIZE
  } = {}) {
    super("TiltShiftEffect", tilt_shift_default, {
      vertexShader: tilt_shift_default2,
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([
        ["rotation", new Uniform$1(new Vector2())],
        ["maskParams", new Uniform$1(new Vector2())],
        ["map", new Uniform$1(null)]
      ])
    });
    this._offset = offset;
    this._focusArea = focusArea;
    this._feather = feather;
    this.renderTarget = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTarget.texture.name = "TiltShift.Target";
    this.uniforms.get("map").value = this.renderTarget.texture;
    this.blurPass = new TiltShiftBlurPass({
      kernelSize,
      resolutionScale,
      resolutionX,
      resolutionY,
      offset,
      rotation,
      focusArea,
      feather
    });
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
    this.rotation = rotation;
    this.updateParams();
  }
  /**
   * Updates the mask params.
   *
   * @private
   */
  updateParams() {
    const params = this.uniforms.get("maskParams").value;
    const x2 = Math.max(this.focusArea - this.feather, 0);
    params.set(this.offset - x2, this.offset + x2);
  }
  /**
   * The rotation of the focus area in radians.
   *
   * @type {Number}
   */
  get rotation() {
    return Math.acos(this.uniforms.get("rotation").value.x);
  }
  set rotation(value) {
    this.uniforms.get("rotation").value.set(Math.cos(value), Math.sin(value));
    this.blurPass.blurMaterial.rotation = value;
  }
  /**
   * The relative offset of the focus area.
   *
   * @type {Number}
   */
  get offset() {
    return this._offset;
  }
  set offset(value) {
    this._offset = value;
    this.blurPass.blurMaterial.offset = value;
    this.updateParams();
  }
  /**
   * The relative size of the focus area.
   *
   * @type {Number}
   */
  get focusArea() {
    return this._focusArea;
  }
  set focusArea(value) {
    this._focusArea = value;
    this.blurPass.blurMaterial.focusArea = value;
    this.updateParams();
  }
  /**
   * The softness of the focus area edges.
   *
   * @type {Number}
   */
  get feather() {
    return this._feather;
  }
  set feather(value) {
    this._feather = value;
    this.blurPass.blurMaterial.feather = value;
    this.updateParams();
  }
  /**
   * A blend bias.
   *
   * @type {Number}
   * @deprecated
   */
  get bias() {
    return 0;
  }
  set bias(value) {
  }
  /**
   * Updates this effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
    this.blurPass.render(renderer, inputBuffer, this.renderTarget);
  }
  /**
   * Updates the size of internal render targets.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    this.renderTarget.setSize(resolution.width, resolution.height);
    this.blurPass.resolution.copy(resolution);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    this.blurPass.initialize(renderer, alpha, frameBufferType);
    if (frameBufferType !== void 0) {
      this.renderTarget.texture.type = frameBufferType;
      if (renderer !== null && renderer.outputColorSpace === SRGBColorSpace) {
        this.renderTarget.texture.colorSpace = SRGBColorSpace;
      }
    }
  }
};
var adaptive_luminance_default = "#include <packing>\n#define packFloatToRGBA(v) packDepthToRGBA(v)\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\nuniform lowp sampler2D luminanceBuffer0;uniform lowp sampler2D luminanceBuffer1;uniform float minLuminance;uniform float deltaTime;uniform float tau;varying vec2 vUv;void main(){float l0=unpackRGBAToFloat(texture2D(luminanceBuffer0,vUv));\n#if __VERSION__ < 300\nfloat l1=texture2DLodEXT(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;\n#else\nfloat l1=textureLod(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;\n#endif\nl0=max(minLuminance,l0);l1=max(minLuminance,l1);float adaptedLum=l0+(l1-l0)*(1.0-exp(-deltaTime*tau));gl_FragColor=(adaptedLum==1.0)?vec4(1.0):packFloatToRGBA(adaptedLum);}";
var AdaptiveLuminanceMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new adaptive luminance material.
   */
  constructor() {
    super({
      name: "AdaptiveLuminanceMaterial",
      defines: {
        MIP_LEVEL_1X1: "0.0"
      },
      uniforms: {
        luminanceBuffer0: new Uniform$1(null),
        luminanceBuffer1: new Uniform$1(null),
        minLuminance: new Uniform$1(0.01),
        deltaTime: new Uniform$1(0),
        tau: new Uniform$1(1)
      },
      extensions: {
        shaderTextureLOD: true
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: adaptive_luminance_default,
      vertexShader: common_default
    });
  }
  /**
   * The primary luminance buffer that contains the downsampled average luminance.
   *
   * @type {Texture}
   */
  set luminanceBuffer0(value) {
    this.uniforms.luminanceBuffer0.value = value;
  }
  /**
   * Sets the primary luminance buffer that contains the downsampled average luminance.
   *
   * @deprecated Use luminanceBuffer0 instead.
   * @param {Texture} value - The buffer.
   */
  setLuminanceBuffer0(value) {
    this.uniforms.luminanceBuffer0.value = value;
  }
  /**
   * The secondary luminance buffer.
   *
   * @type {Texture}
   */
  set luminanceBuffer1(value) {
    this.uniforms.luminanceBuffer1.value = value;
  }
  /**
   * Sets the secondary luminance buffer.
   *
   * @deprecated Use luminanceBuffer1 instead.
   * @param {Texture} value - The buffer.
   */
  setLuminanceBuffer1(value) {
    this.uniforms.luminanceBuffer1.value = value;
  }
  /**
   * The 1x1 mipmap level.
   *
   * This level is used to identify the smallest mipmap of the primary luminance buffer.
   *
   * @type {Number}
   */
  set mipLevel1x1(value) {
    this.defines.MIP_LEVEL_1X1 = value.toFixed(1);
    this.needsUpdate = true;
  }
  /**
   * Sets the 1x1 mipmap level.
   *
   * @deprecated Use mipLevel1x1 instead.
   * @param {Number} value - The level.
   */
  setMipLevel1x1(value) {
    this.mipLevel1x1 = value;
  }
  /**
   * The delta time.
   *
   * @type {Number}
   */
  set deltaTime(value) {
    this.uniforms.deltaTime.value = value;
  }
  /**
   * Sets the delta time.
   *
   * @deprecated Use deltaTime instead.
   * @param {Number} value - The delta time.
   */
  setDeltaTime(value) {
    this.uniforms.deltaTime.value = value;
  }
  /**
   * The lowest possible luminance value.
   *
   * @type {Number}
   */
  get minLuminance() {
    return this.uniforms.minLuminance.value;
  }
  set minLuminance(value) {
    this.uniforms.minLuminance.value = value;
  }
  /**
   * Returns the lowest possible luminance value.
   *
   * @deprecated Use minLuminance instead.
   * @return {Number} The minimum luminance.
   */
  getMinLuminance() {
    return this.uniforms.minLuminance.value;
  }
  /**
   * Sets the minimum luminance.
   *
   * @deprecated Use minLuminance instead.
   * @param {Number} value - The minimum luminance.
   */
  setMinLuminance(value) {
    this.uniforms.minLuminance.value = value;
  }
  /**
   * The luminance adaptation rate.
   *
   * @type {Number}
   */
  get adaptationRate() {
    return this.uniforms.tau.value;
  }
  set adaptationRate(value) {
    this.uniforms.tau.value = value;
  }
  /**
   * Returns the luminance adaptation rate.
   *
   * @deprecated Use adaptationRate instead.
   * @return {Number} The adaptation rate.
   */
  getAdaptationRate() {
    return this.uniforms.tau.value;
  }
  /**
   * Sets the luminance adaptation rate.
   *
   * @deprecated Use adaptationRate instead.
   * @param {Number} value - The adaptation rate.
   */
  setAdaptationRate(value) {
    this.uniforms.tau.value = value;
  }
};
var AdaptiveLuminancePass = class extends Pass {
  /**
   * Constructs a new adaptive luminance pass.
   *
   * @param {Texture} luminanceBuffer - A buffer that contains the current scene luminance.
   * @param {Object} [options] - The options.
   * @param {Number} [options.minLuminance=0.01] - The minimum luminance.
   * @param {Number} [options.adaptationRate=1.0] - The luminance adaptation rate.
   */
  constructor(luminanceBuffer, { minLuminance = 0.01, adaptationRate = 1 } = {}) {
    super("AdaptiveLuminancePass");
    this.fullscreenMaterial = new AdaptiveLuminanceMaterial();
    this.needsSwap = false;
    this.renderTargetPrevious = new WebGLRenderTarget(1, 1, {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      depthBuffer: false
    });
    this.renderTargetPrevious.texture.name = "Luminance.Previous";
    const material = this.fullscreenMaterial;
    material.luminanceBuffer0 = this.renderTargetPrevious.texture;
    material.luminanceBuffer1 = luminanceBuffer;
    material.minLuminance = minLuminance;
    material.adaptationRate = adaptationRate;
    this.renderTargetAdapted = this.renderTargetPrevious.clone();
    this.renderTargetAdapted.texture.name = "Luminance.Adapted";
    this.copyPass = new CopyPass(this.renderTargetPrevious, false);
  }
  /**
   * The adaptive luminance texture.
   *
   * @type {Texture}
   */
  get texture() {
    return this.renderTargetAdapted.texture;
  }
  /**
   * Returns the adaptive 1x1 luminance texture.
   *
   * @deprecated Use texture instead.
   * @return {Texture} The texture.
   */
  getTexture() {
    return this.renderTargetAdapted.texture;
  }
  /**
   * Sets the 1x1 mipmap level.
   *
   * This level is used to identify the smallest mipmap of the main luminance texture which contains the downsampled
   * average scene luminance.
   *
   * @type {Number}
   * @deprecated Use fullscreenMaterial.mipLevel1x1 instead.
   */
  set mipLevel1x1(value) {
    this.fullscreenMaterial.mipLevel1x1 = value;
  }
  /**
   * The luminance adaptation rate.
   *
   * @type {Number}
   * @deprecated Use fullscreenMaterial.adaptationRate instead.
   */
  get adaptationRate() {
    return this.fullscreenMaterial.adaptationRate;
  }
  /**
   * @type {Number}
   * @deprecated Use fullscreenMaterial.adaptationRate instead.
   */
  set adaptationRate(value) {
    this.fullscreenMaterial.adaptationRate = value;
  }
  /**
   * Renders the scene normals.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    this.fullscreenMaterial.deltaTime = deltaTime;
    renderer.setRenderTarget(this.renderToScreen ? null : this.renderTargetAdapted);
    renderer.render(this.scene, this.camera);
    this.copyPass.render(renderer, this.renderTargetAdapted);
  }
};
var tone_mapping_default = "#include <tonemapping_pars_fragment>\nuniform float whitePoint;\n#if TONE_MAPPING_MODE == 2 || TONE_MAPPING_MODE == 3\nuniform float middleGrey;\n#if TONE_MAPPING_MODE == 3\nuniform lowp sampler2D luminanceBuffer;\n#else\nuniform float averageLuminance;\n#endif\nvec3 Reinhard2ToneMapping(vec3 color){color*=toneMappingExposure;float l=luminance(color);\n#if TONE_MAPPING_MODE == 3\nfloat lumAvg=unpackRGBAToFloat(texture2D(luminanceBuffer,vec2(0.5)));\n#else\nfloat lumAvg=averageLuminance;\n#endif\nfloat lumScaled=(l*middleGrey)/max(lumAvg,1e-6);float lumCompressed=lumScaled*(1.0+lumScaled/(whitePoint*whitePoint));lumCompressed/=(1.0+lumScaled);return clamp(lumCompressed*color,0.0,1.0);}\n#elif TONE_MAPPING_MODE == 4\n#define A 0.15\n#define B 0.50\n#define C 0.10\n#define D 0.20\n#define E 0.02\n#define F 0.30\nvec3 Uncharted2Helper(const in vec3 x){return((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}vec3 Uncharted2ToneMapping(vec3 color){color*=toneMappingExposure;return clamp(Uncharted2Helper(color)/Uncharted2Helper(vec3(whitePoint)),0.0,1.0);}\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){\n#if TONE_MAPPING_MODE == 2 || TONE_MAPPING_MODE == 3\noutputColor=vec4(Reinhard2ToneMapping(inputColor.rgb),inputColor.a);\n#elif TONE_MAPPING_MODE == 4\noutputColor=vec4(Uncharted2ToneMapping(inputColor.rgb),inputColor.a);\n#else\noutputColor=vec4(toneMapping(inputColor.rgb),inputColor.a);\n#endif\n}";
var ToneMappingEffect = class extends Effect {
  /**
   * Constructs a new tone mapping effect.
   *
   * The additional parameters only affect the Reinhard2 operator.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.
   * @param {Boolean} [options.adaptive=false] - Deprecated. Use mode instead.
   * @param {ToneMappingMode} [options.mode=ToneMappingMode.AGX] - The tone mapping mode.
   * @param {Number} [options.resolution=256] - The resolution of the luminance texture. Must be a power of two.
   * @param {Number} [options.maxLuminance=4.0] - Deprecated. Same as whitePoint.
   * @param {Number} [options.whitePoint=4.0] - The white point.
   * @param {Number} [options.middleGrey=0.6] - The middle grey factor.
   * @param {Number} [options.minLuminance=0.01] - The minimum luminance. Prevents very high exposure in dark scenes.
   * @param {Number} [options.averageLuminance=1.0] - The average luminance. Used for the non-adaptive Reinhard operator.
   * @param {Number} [options.adaptationRate=1.0] - The luminance adaptation rate.
   */
  constructor({
    blendFunction = BlendFunction.SRC,
    adaptive = false,
    mode = adaptive ? ToneMappingMode.REINHARD2_ADAPTIVE : ToneMappingMode.AGX,
    resolution = 256,
    maxLuminance = 4,
    whitePoint = maxLuminance,
    middleGrey = 0.6,
    minLuminance = 0.01,
    averageLuminance = 1,
    adaptationRate = 1
  } = {}) {
    super("ToneMappingEffect", tone_mapping_default, {
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([
        ["luminanceBuffer", new Uniform$1(null)],
        ["maxLuminance", new Uniform$1(maxLuminance)],
        // Unused
        ["whitePoint", new Uniform$1(whitePoint)],
        ["middleGrey", new Uniform$1(middleGrey)],
        ["averageLuminance", new Uniform$1(averageLuminance)]
      ])
    });
    this.renderTargetLuminance = new WebGLRenderTarget(1, 1, {
      minFilter: LinearMipmapLinearFilter,
      depthBuffer: false
    });
    this.renderTargetLuminance.texture.generateMipmaps = true;
    this.renderTargetLuminance.texture.name = "Luminance";
    this.luminancePass = new LuminancePass({
      renderTarget: this.renderTargetLuminance
    });
    this.adaptiveLuminancePass = new AdaptiveLuminancePass(this.luminancePass.texture, {
      minLuminance,
      adaptationRate
    });
    this.uniforms.get("luminanceBuffer").value = this.adaptiveLuminancePass.texture;
    this.resolution = resolution;
    this.mode = mode;
  }
  /**
   * The tone mapping mode.
   *
   * @type {ToneMappingMode}
   */
  get mode() {
    return Number(this.defines.get("TONE_MAPPING_MODE"));
  }
  set mode(value) {
    if (this.mode === value) {
      return;
    }
    const revision = REVISION.replace(/\D+/g, "");
    const cineonToneMapping = revision >= 168 ? "CineonToneMapping(texel)" : "OptimizedCineonToneMapping(texel)";
    this.defines.clear();
    this.defines.set("TONE_MAPPING_MODE", value.toFixed(0));
    switch (value) {
      case ToneMappingMode.LINEAR:
        this.defines.set("toneMapping(texel)", "LinearToneMapping(texel)");
        break;
      case ToneMappingMode.REINHARD:
        this.defines.set("toneMapping(texel)", "ReinhardToneMapping(texel)");
        break;
      case ToneMappingMode.CINEON:
      case ToneMappingMode.OPTIMIZED_CINEON:
        this.defines.set("toneMapping(texel)", cineonToneMapping);
        break;
      case ToneMappingMode.ACES_FILMIC:
        this.defines.set("toneMapping(texel)", "ACESFilmicToneMapping(texel)");
        break;
      case ToneMappingMode.AGX:
        this.defines.set("toneMapping(texel)", "AgXToneMapping(texel)");
        break;
      case ToneMappingMode.NEUTRAL:
        this.defines.set("toneMapping(texel)", "NeutralToneMapping(texel)");
        break;
      default:
        this.defines.set("toneMapping(texel)", "texel");
        break;
    }
    this.adaptiveLuminancePass.enabled = value === ToneMappingMode.REINHARD2_ADAPTIVE;
    this.setChanged();
  }
  /**
   * Returns the current tone mapping mode.
   *
   * @deprecated Use mode instead.
   * @return {ToneMappingMode} The tone mapping mode.
   */
  getMode() {
    return this.mode;
  }
  /**
   * Sets the tone mapping mode.
   *
   * @deprecated Use mode instead.
   * @param {ToneMappingMode} value - The tone mapping mode.
   */
  setMode(value) {
    this.mode = value;
  }
  /**
   * The white point. Default is `4.0`.
   *
   * Only applies to Reinhard2 (Modified & Adaptive).
   *
   * @type {Number}
   */
  get whitePoint() {
    return this.uniforms.get("whitePoint").value;
  }
  set whitePoint(value) {
    this.uniforms.get("whitePoint").value = value;
  }
  /**
   * The middle grey factor. Default is `0.6`.
   *
   * Only applies to Reinhard2 (Modified & Adaptive).
   *
   * @type {Number}
   */
  get middleGrey() {
    return this.uniforms.get("middleGrey").value;
  }
  set middleGrey(value) {
    this.uniforms.get("middleGrey").value = value;
  }
  /**
   * The average luminance.
   *
   * Only applies to Reinhard2 (Modified).
   *
   * @type {Number}
   */
  get averageLuminance() {
    return this.uniforms.get("averageLuminance").value;
  }
  set averageLuminance(value) {
    this.uniforms.get("averageLuminance").value = value;
  }
  /**
   * The adaptive luminance material.
   *
   * @type {AdaptiveLuminanceMaterial}
   */
  get adaptiveLuminanceMaterial() {
    return this.adaptiveLuminancePass.fullscreenMaterial;
  }
  /**
   * Returns the adaptive luminance material.
   *
   * @deprecated Use adaptiveLuminanceMaterial instead.
   * @return {AdaptiveLuminanceMaterial} The material.
   */
  getAdaptiveLuminanceMaterial() {
    return this.adaptiveLuminanceMaterial;
  }
  /**
   * The resolution of the luminance texture. Must be a power of two.
   *
   * @type {Number}
   */
  get resolution() {
    return this.luminancePass.resolution.width;
  }
  set resolution(value) {
    const exponent = Math.max(0, Math.ceil(Math.log2(value)));
    const size = Math.pow(2, exponent);
    this.luminancePass.resolution.setPreferredSize(size, size);
    this.adaptiveLuminanceMaterial.mipLevel1x1 = exponent;
  }
  /**
   * Returns the resolution of the luminance texture.
   *
   * @deprecated Use resolution instead.
   * @return {Number} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * Sets the resolution of the luminance texture. Must be a power of two.
   *
   * @deprecated Use resolution instead.
   * @param {Number} value - The resolution.
   */
  setResolution(value) {
    this.resolution = value;
  }
  /**
   * Indicates whether this pass uses adaptive luminance.
   *
   * @type {Boolean}
   * @deprecated Use mode instead.
   */
  get adaptive() {
    return this.mode === ToneMappingMode.REINHARD2_ADAPTIVE;
  }
  set adaptive(value) {
    this.mode = value ? ToneMappingMode.REINHARD2_ADAPTIVE : ToneMappingMode.REINHARD2;
  }
  /**
   * The luminance adaptation rate.
   *
   * @type {Number}
   * @deprecated Use adaptiveLuminanceMaterial.adaptationRate instead.
   */
  get adaptationRate() {
    return this.adaptiveLuminanceMaterial.adaptationRate;
  }
  set adaptationRate(value) {
    this.adaptiveLuminanceMaterial.adaptationRate = value;
  }
  /**
   * @type {Number}
   * @deprecated
   */
  get distinction() {
    console.warn(this.name, "distinction was removed.");
    return 1;
  }
  set distinction(value) {
    console.warn(this.name, "distinction was removed.");
  }
  /**
   * Updates this effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
    if (this.adaptiveLuminancePass.enabled) {
      this.luminancePass.render(renderer, inputBuffer);
      this.adaptiveLuminancePass.render(renderer, null, null, deltaTime);
    }
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    this.adaptiveLuminancePass.initialize(renderer, alpha, frameBufferType);
  }
};
var vignette_default = "uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;\n#if VIGNETTE_TECHNIQUE == 0\nfloat d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));\n#else\nvec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));\n#endif\noutputColor=vec4(color,inputColor.a);}";
var VignetteEffect = class extends Effect {
  /**
   * Constructs a new Vignette effect.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.
   * @param {VignetteTechnique} [options.technique=VignetteTechnique.DEFAULT] - The Vignette technique.
   * @param {Boolean} [options.eskil=false] - Deprecated. Use technique instead.
   * @param {Number} [options.offset=0.5] - The Vignette offset.
   * @param {Number} [options.darkness=0.5] - The Vignette darkness.
   */
  constructor({
    blendFunction,
    eskil = false,
    technique = eskil ? VignetteTechnique.ESKIL : VignetteTechnique.DEFAULT,
    offset = 0.5,
    darkness = 0.5
  } = {}) {
    super("VignetteEffect", vignette_default, {
      blendFunction,
      defines: /* @__PURE__ */ new Map([
        ["VIGNETTE_TECHNIQUE", technique.toFixed(0)]
      ]),
      uniforms: /* @__PURE__ */ new Map([
        ["offset", new Uniform$1(offset)],
        ["darkness", new Uniform$1(darkness)]
      ])
    });
  }
  /**
   * The Vignette technique.
   *
   * @type {VignetteTechnique}
   */
  get technique() {
    return Number(this.defines.get("VIGNETTE_TECHNIQUE"));
  }
  set technique(value) {
    if (this.technique !== value) {
      this.defines.set("VIGNETTE_TECHNIQUE", value.toFixed(0));
      this.setChanged();
    }
  }
  /**
   * Indicates whether Eskil's Vignette technique is enabled.
   *
   * @type {Boolean}
   * @deprecated Use technique instead.
   */
  get eskil() {
    return this.technique === VignetteTechnique.ESKIL;
  }
  /**
   * Indicates whether Eskil's Vignette technique is enabled.
   *
   * @type {Boolean}
   * @deprecated Use technique instead.
   */
  set eskil(value) {
    this.technique = value ? VignetteTechnique.ESKIL : VignetteTechnique.DEFAULT;
  }
  /**
   * Returns the Vignette technique.
   *
   * @deprecated Use technique instead.
   * @return {VignetteTechnique} The technique.
   */
  getTechnique() {
    return this.technique;
  }
  /**
   * Sets the Vignette technique.
   *
   * @deprecated Use technique instead.
   * @param {VignetteTechnique} value - The technique.
   */
  setTechnique(value) {
    this.technique = value;
  }
  /**
   * The Vignette offset.
   *
   * @type {Number}
   */
  get offset() {
    return this.uniforms.get("offset").value;
  }
  set offset(value) {
    this.uniforms.get("offset").value = value;
  }
  /**
   * Returns the Vignette offset.
   *
   * @deprecated Use offset instead.
   * @return {Number} The offset.
   */
  getOffset() {
    return this.offset;
  }
  /**
   * Sets the Vignette offset.
   *
   * @deprecated Use offset instead.
   * @param {Number} value - The offset.
   */
  setOffset(value) {
    this.offset = value;
  }
  /**
   * The Vignette darkness.
   *
   * @type {Number}
   */
  get darkness() {
    return this.uniforms.get("darkness").value;
  }
  set darkness(value) {
    this.uniforms.get("darkness").value = value;
  }
  /**
   * Returns the Vignette darkness.
   *
   * @deprecated Use darkness instead.
   * @return {Number} The darkness.
   */
  getDarkness() {
    return this.darkness;
  }
  /**
   * Sets the Vignette darkness.
   *
   * @deprecated Use darkness instead.
   * @param {Number} value - The darkness.
   */
  setDarkness(value) {
    this.darkness = value;
  }
};
var effect_default = "#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#define packFloatToRGBA(v) packDepthToRGBA(v)\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#if DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;\n#ifdef ENCODE_OUTPUT\n#include <colorspace_fragment>\n#endif\n#include <dithering_fragment>\n}";
var effect_default2 = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}";
var EffectMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new effect material.
   *
   * @param {Map<String, String>} [shaderParts] - Deprecated. Use setShaderData instead.
   * @param {Map<String, String>} [defines] - Deprecated. Use setShaderData instead.
   * @param {Map<String, Uniform>} [uniforms] - Deprecated. Use setShaderData instead.
   * @param {Camera} [camera] - A camera.
   * @param {Boolean} [dithering=false] - Deprecated.
   */
  constructor(shaderParts, defines, uniforms, camera, dithering = false) {
    super({
      name: "EffectMaterial",
      defines: {
        THREE_REVISION: REVISION.replace(/\D+/g, ""),
        DEPTH_PACKING: "0",
        ENCODE_OUTPUT: "1"
      },
      uniforms: {
        inputBuffer: new Uniform$1(null),
        depthBuffer: new Uniform$1(null),
        resolution: new Uniform$1(new Vector2()),
        texelSize: new Uniform$1(new Vector2()),
        cameraNear: new Uniform$1(0.3),
        cameraFar: new Uniform$1(1e3),
        aspect: new Uniform$1(1),
        time: new Uniform$1(0)
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      dithering
    });
    if (shaderParts) {
      this.setShaderParts(shaderParts);
    }
    if (defines) {
      this.setDefines(defines);
    }
    if (uniforms) {
      this.setUniforms(uniforms);
    }
    this.copyCameraSettings(camera);
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Texture} value - The input buffer.
   */
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * The depth buffer.
   *
   * @type {Texture}
   */
  get depthBuffer() {
    return this.uniforms.depthBuffer.value;
  }
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * The depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  get depthPacking() {
    return Number(this.defines.DEPTH_PACKING);
  }
  set depthPacking(value) {
    this.defines.DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the depth buffer.
   *
   * @deprecated Use depthBuffer and depthPacking instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthBuffer(buffer2, depthPacking = BasicDepthPacking) {
    this.depthBuffer = buffer2;
    this.depthPacking = depthPacking;
  }
  /**
   * Sets the shader data.
   *
   * @param {EffectShaderData} data - The shader data.
   * @return {EffectMaterial} This material.
   */
  setShaderData(data) {
    this.setShaderParts(data.shaderParts);
    this.setDefines(data.defines);
    this.setUniforms(data.uniforms);
    this.setExtensions(data.extensions);
  }
  /**
   * Sets the shader parts.
   *
   * @deprecated Use setShaderData instead.
   * @param {Map<String, String>} shaderParts - A collection of shader snippets. See {@link EffectShaderSection}.
   * @return {EffectMaterial} This material.
   */
  setShaderParts(shaderParts) {
    this.fragmentShader = effect_default.replace(EffectShaderSection.FRAGMENT_HEAD, shaderParts.get(EffectShaderSection.FRAGMENT_HEAD) || "").replace(EffectShaderSection.FRAGMENT_MAIN_UV, shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV) || "").replace(EffectShaderSection.FRAGMENT_MAIN_IMAGE, shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE) || "");
    this.vertexShader = effect_default2.replace(EffectShaderSection.VERTEX_HEAD, shaderParts.get(EffectShaderSection.VERTEX_HEAD) || "").replace(EffectShaderSection.VERTEX_MAIN_SUPPORT, shaderParts.get(EffectShaderSection.VERTEX_MAIN_SUPPORT) || "");
    this.needsUpdate = true;
    return this;
  }
  /**
   * Sets the shader macros.
   *
   * @deprecated Use setShaderData instead.
   * @param {Map<String, String>} defines - A collection of preprocessor macro definitions.
   * @return {EffectMaterial} This material.
   */
  setDefines(defines) {
    for (const entry of defines.entries()) {
      this.defines[entry[0]] = entry[1];
    }
    this.needsUpdate = true;
    return this;
  }
  /**
   * Sets the shader uniforms.
   *
   * @deprecated Use setShaderData instead.
   * @param {Map<String, Uniform>} uniforms - A collection of uniforms.
   * @return {EffectMaterial} This material.
   */
  setUniforms(uniforms) {
    for (const entry of uniforms.entries()) {
      this.uniforms[entry[0]] = entry[1];
    }
    return this;
  }
  /**
   * Sets the required shader extensions.
   *
   * @deprecated Use setShaderData instead.
   * @param {Set<WebGLExtension>} extensions - A collection of extensions.
   * @return {EffectMaterial} This material.
   */
  setExtensions(extensions) {
    this.extensions = {};
    for (const extension of extensions) {
      this.extensions[extension] = true;
    }
    return this;
  }
  /**
   * Indicates whether output encoding is enabled.
   *
   * @type {Boolean}
   */
  get encodeOutput() {
    return this.defines.ENCODE_OUTPUT !== void 0;
  }
  set encodeOutput(value) {
    if (this.encodeOutput !== value) {
      if (value) {
        this.defines.ENCODE_OUTPUT = "1";
      } else {
        delete this.defines.ENCODE_OUTPUT;
      }
      this.needsUpdate = true;
    }
  }
  /**
   * Indicates whether output encoding is enabled.
   *
   * @deprecated Use encodeOutput instead.
   * @return {Boolean} Whether output encoding is enabled.
   */
  isOutputEncodingEnabled(value) {
    return this.encodeOutput;
  }
  /**
   * Enables or disables output encoding.
   *
   * @deprecated Use encodeOutput instead.
   * @param {Boolean} value - Whether output encoding should be enabled.
   */
  setOutputEncodingEnabled(value) {
    this.encodeOutput = value;
  }
  /**
   * The time in seconds.
   *
   * @type {Number}
   */
  get time() {
    return this.uniforms.time.value;
  }
  set time(value) {
    this.uniforms.time.value = value;
  }
  /**
   * Sets the delta time.
   *
   * @deprecated Use time instead.
   * @param {Number} value - The delta time in seconds.
   */
  setDeltaTime(value) {
    this.uniforms.time.value += value;
  }
  /**
   * Copies the settings of the given camera.
   *
   * @deprecated Use copyCameraSettings instead.
   * @param {Camera} camera - A camera.
   */
  adoptCameraSettings(camera) {
    this.copyCameraSettings(camera);
  }
  /**
   * Copies the settings of the given camera.
   *
   * @param {Camera} camera - A camera.
   */
  copyCameraSettings(camera) {
    if (camera) {
      this.uniforms.cameraNear.value = camera.near;
      this.uniforms.cameraFar.value = camera.far;
      if (camera instanceof PerspectiveCamera) {
        this.defines.PERSPECTIVE_CAMERA = "1";
      } else {
        delete this.defines.PERSPECTIVE_CAMERA;
      }
      this.needsUpdate = true;
    }
  }
  /**
   * Sets the resolution.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const uniforms = this.uniforms;
    uniforms.resolution.value.set(width, height);
    uniforms.texelSize.value.set(1 / width, 1 / height);
    uniforms.aspect.value = width / height;
  }
  /**
   * An enumeration of shader code placeholders.
   *
   * @deprecated Use EffectShaderSection instead.
   * @type {Object}
   */
  static get Section() {
    return EffectShaderSection;
  }
};
var threeRevision = Number(REVISION.replace(/\D+/g, ""));
var unpackDownscale = 255 / 256;
var unpackFactorsLegacy = new Float32Array([
  unpackDownscale / 256 ** 3,
  unpackDownscale / 256 ** 2,
  unpackDownscale / 256,
  unpackDownscale
]);
var unpackFactors = new Float32Array([
  unpackDownscale,
  unpackDownscale / 256,
  unpackDownscale / 256 ** 2,
  1 / 256 ** 3
]);
function prefixSubstrings(prefix2, substrings, strings) {
  for (const substring of substrings) {
    const prefixed = "$1" + prefix2 + substring.charAt(0).toUpperCase() + substring.slice(1);
    const regExp = new RegExp("([^\\.])(\\b" + substring + "\\b)", "g");
    for (const entry of strings.entries()) {
      if (entry[1] !== null) {
        strings.set(entry[0], entry[1].replace(regExp, prefixed));
      }
    }
  }
}
function integrateEffect(prefix2, effect, data) {
  let fragmentShader2 = effect.getFragmentShader();
  let vertexShader2 = effect.getVertexShader();
  const mainImageExists = fragmentShader2 !== void 0 && /mainImage/.test(fragmentShader2);
  const mainUvExists = fragmentShader2 !== void 0 && /mainUv/.test(fragmentShader2);
  data.attributes |= effect.getAttributes();
  if (fragmentShader2 === void 0) {
    throw new Error(`Missing fragment shader (${effect.name})`);
  } else if (mainUvExists && (data.attributes & EffectAttribute.CONVOLUTION) !== 0) {
    throw new Error(`Effects that transform UVs are incompatible with convolution effects (${effect.name})`);
  } else if (!mainImageExists && !mainUvExists) {
    throw new Error(`Could not find mainImage or mainUv function (${effect.name})`);
  } else {
    const functionRegExp = /\w+\s+(\w+)\([\w\s,]*\)\s*{/g;
    const shaderParts = data.shaderParts;
    let fragmentHead = shaderParts.get(EffectShaderSection.FRAGMENT_HEAD) || "";
    let fragmentMainUv = shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV) || "";
    let fragmentMainImage = shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE) || "";
    let vertexHead = shaderParts.get(EffectShaderSection.VERTEX_HEAD) || "";
    let vertexMainSupport = shaderParts.get(EffectShaderSection.VERTEX_MAIN_SUPPORT) || "";
    const varyings = /* @__PURE__ */ new Set();
    const names = /* @__PURE__ */ new Set();
    if (mainUvExists) {
      fragmentMainUv += `	${prefix2}MainUv(UV);
`;
      data.uvTransformation = true;
    }
    if (vertexShader2 !== null && /mainSupport/.test(vertexShader2)) {
      const needsUv = /mainSupport *\([\w\s]*?uv\s*?\)/.test(vertexShader2);
      vertexMainSupport += `	${prefix2}MainSupport(`;
      vertexMainSupport += needsUv ? "vUv);\n" : ");\n";
      for (const m2 of vertexShader2.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g)) {
        for (const n2 of m2[1].split(/\s*,\s*/)) {
          data.varyings.add(n2);
          varyings.add(n2);
          names.add(n2);
        }
      }
      for (const m2 of vertexShader2.matchAll(functionRegExp)) {
        names.add(m2[1]);
      }
    }
    for (const m2 of fragmentShader2.matchAll(functionRegExp)) {
      names.add(m2[1]);
    }
    for (const d of effect.defines.keys()) {
      names.add(d.replace(/\([\w\s,]*\)/g, ""));
    }
    for (const u2 of effect.uniforms.keys()) {
      names.add(u2);
    }
    names.delete("while");
    names.delete("for");
    names.delete("if");
    effect.uniforms.forEach((val, key) => data.uniforms.set(prefix2 + key.charAt(0).toUpperCase() + key.slice(1), val));
    effect.defines.forEach((val, key) => data.defines.set(prefix2 + key.charAt(0).toUpperCase() + key.slice(1), val));
    const shaders = /* @__PURE__ */ new Map([["fragment", fragmentShader2], ["vertex", vertexShader2]]);
    prefixSubstrings(prefix2, names, data.defines);
    prefixSubstrings(prefix2, names, shaders);
    fragmentShader2 = shaders.get("fragment");
    vertexShader2 = shaders.get("vertex");
    const blendMode = effect.blendMode;
    data.blendModes.set(blendMode.blendFunction, blendMode);
    if (mainImageExists) {
      if (effect.inputColorSpace !== null && effect.inputColorSpace !== data.colorSpace) {
        fragmentMainImage += effect.inputColorSpace === SRGBColorSpace ? "color0 = sRGBTransferOETF(color0);\n	" : "color0 = sRGBToLinear(color0);\n	";
      }
      if (effect.outputColorSpace !== NoColorSpace) {
        data.colorSpace = effect.outputColorSpace;
      } else if (effect.inputColorSpace !== null) {
        data.colorSpace = effect.inputColorSpace;
      }
      const depthParamRegExp = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;
      fragmentMainImage += `${prefix2}MainImage(color0, UV, `;
      if ((data.attributes & EffectAttribute.DEPTH) !== 0 && depthParamRegExp.test(fragmentShader2)) {
        fragmentMainImage += "depth, ";
        data.readDepth = true;
      }
      fragmentMainImage += "color1);\n	";
      const blendOpacity = prefix2 + "BlendOpacity";
      data.uniforms.set(blendOpacity, blendMode.opacity);
      fragmentMainImage += `color0 = blend${blendMode.blendFunction}(color0, color1, ${blendOpacity});

	`;
      fragmentHead += `uniform float ${blendOpacity};

`;
    }
    fragmentHead += fragmentShader2 + "\n";
    if (vertexShader2 !== null) {
      vertexHead += vertexShader2 + "\n";
    }
    shaderParts.set(EffectShaderSection.FRAGMENT_HEAD, fragmentHead);
    shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_UV, fragmentMainUv);
    shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_IMAGE, fragmentMainImage);
    shaderParts.set(EffectShaderSection.VERTEX_HEAD, vertexHead);
    shaderParts.set(EffectShaderSection.VERTEX_MAIN_SUPPORT, vertexMainSupport);
    if (effect.extensions !== null) {
      for (const extension of effect.extensions) {
        data.extensions.add(extension);
      }
    }
  }
}
var EffectPass = class extends Pass {
  /**
   * Constructs a new effect pass.
   *
   * @param {Camera} camera - The main camera.
   * @param {...Effect} effects - The effects that will be rendered by this pass.
   */
  constructor(camera, ...effects) {
    super("EffectPass");
    this.fullscreenMaterial = new EffectMaterial(null, null, null, camera);
    this.listener = (event) => this.handleEvent(event);
    this.effects = [];
    this.setEffects(effects);
    this.skipRendering = false;
    this.minTime = 1;
    this.maxTime = Number.POSITIVE_INFINITY;
    this.timeScale = 1;
  }
  set mainScene(value) {
    for (const effect of this.effects) {
      effect.mainScene = value;
    }
  }
  set mainCamera(value) {
    this.fullscreenMaterial.copyCameraSettings(value);
    for (const effect of this.effects) {
      effect.mainCamera = value;
    }
  }
  /**
   * Indicates whether this pass encodes its output when rendering to screen.
   *
   * @type {Boolean}
   * @deprecated Use fullscreenMaterial.encodeOutput instead.
   */
  get encodeOutput() {
    return this.fullscreenMaterial.encodeOutput;
  }
  set encodeOutput(value) {
    this.fullscreenMaterial.encodeOutput = value;
  }
  /**
   * Indicates whether dithering is enabled.
   *
   * @type {Boolean}
   */
  get dithering() {
    return this.fullscreenMaterial.dithering;
  }
  set dithering(value) {
    const material = this.fullscreenMaterial;
    material.dithering = value;
    material.needsUpdate = true;
  }
  /**
   * Sets the effects.
   *
   * @param {Effect[]} effects - The effects.
   * @protected
   */
  setEffects(effects) {
    for (const effect of this.effects) {
      effect.removeEventListener("change", this.listener);
    }
    this.effects = effects.sort((a, b) => b.attributes - a.attributes);
    for (const effect of this.effects) {
      effect.addEventListener("change", this.listener);
    }
  }
  /**
   * Updates the compound shader material.
   *
   * @protected
   */
  updateMaterial() {
    const data = new EffectShaderData();
    let id = 0;
    for (const effect of this.effects) {
      if (effect.blendMode.blendFunction === BlendFunction.DST) {
        data.attributes |= effect.getAttributes() & EffectAttribute.DEPTH;
      } else if ((data.attributes & effect.getAttributes() & EffectAttribute.CONVOLUTION) !== 0) {
        throw new Error(`Convolution effects cannot be merged (${effect.name})`);
      } else {
        integrateEffect("e" + id++, effect, data);
      }
    }
    let fragmentHead = data.shaderParts.get(EffectShaderSection.FRAGMENT_HEAD);
    let fragmentMainImage = data.shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE);
    let fragmentMainUv = data.shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV);
    const blendRegExp = /\bblend\b/g;
    for (const blendMode of data.blendModes.values()) {
      fragmentHead += blendMode.getShaderCode().replace(blendRegExp, `blend${blendMode.blendFunction}`) + "\n";
    }
    if ((data.attributes & EffectAttribute.DEPTH) !== 0) {
      if (data.readDepth) {
        fragmentMainImage = "float depth = readDepth(UV);\n\n	" + fragmentMainImage;
      }
      this.needsDepthTexture = this.getDepthTexture() === null;
    } else {
      this.needsDepthTexture = false;
    }
    if (data.colorSpace === SRGBColorSpace) {
      fragmentMainImage += "color0 = sRGBToLinear(color0);\n	";
    }
    if (data.uvTransformation) {
      fragmentMainUv = "vec2 transformedUv = vUv;\n" + fragmentMainUv;
      data.defines.set("UV", "transformedUv");
    } else {
      data.defines.set("UV", "vUv");
    }
    data.shaderParts.set(EffectShaderSection.FRAGMENT_HEAD, fragmentHead);
    data.shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_IMAGE, fragmentMainImage);
    data.shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_UV, fragmentMainUv);
    for (const [key, value] of data.shaderParts) {
      if (value !== null) {
        data.shaderParts.set(key, value.trim().replace(/^#/, "\n#"));
      }
    }
    this.skipRendering = id === 0;
    this.needsSwap = !this.skipRendering;
    this.fullscreenMaterial.setShaderData(data);
  }
  /**
   * Rebuilds the shader material.
   */
  recompile() {
    this.updateMaterial();
  }
  /**
   * Returns the current depth texture.
   *
   * @return {Texture} The current depth texture, or null if there is none.
   */
  getDepthTexture() {
    return this.fullscreenMaterial.depthBuffer;
  }
  /**
   * Sets the depth texture.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
    this.fullscreenMaterial.depthBuffer = depthTexture;
    this.fullscreenMaterial.depthPacking = depthPacking;
    for (const effect of this.effects) {
      effect.setDepthTexture(depthTexture, depthPacking);
    }
  }
  /**
   * Renders the effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    for (const effect of this.effects) {
      effect.update(renderer, inputBuffer, deltaTime);
    }
    if (!this.skipRendering || this.renderToScreen) {
      const material = this.fullscreenMaterial;
      material.inputBuffer = inputBuffer.texture;
      material.time += deltaTime * this.timeScale;
      renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
      renderer.render(this.scene, this.camera);
    }
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.fullscreenMaterial.setSize(width, height);
    for (const effect of this.effects) {
      effect.setSize(width, height);
    }
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    this.renderer = renderer;
    for (const effect of this.effects) {
      effect.initialize(renderer, alpha, frameBufferType);
    }
    this.updateMaterial();
    if (frameBufferType !== void 0 && frameBufferType !== UnsignedByteType) {
      this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
    }
  }
  /**
   * Deletes disposable objects.
   */
  dispose() {
    super.dispose();
    for (const effect of this.effects) {
      effect.removeEventListener("change", this.listener);
      effect.dispose();
    }
  }
  /**
   * Handles events.
   *
   * @param {Event} event - An event.
   */
  handleEvent(event) {
    switch (event.type) {
      case "change":
        this.recompile();
        break;
    }
  }
};
var NormalPass = class extends Pass {
  /**
   * Constructs a new normal pass.
   *
   * @param {Scene} scene - The scene to render.
   * @param {Camera} camera - The camera to use to render the scene.
   * @param {Object} [options] - The options.
   * @param {WebGLRenderTarget} [options.renderTarget] - A custom render target.
   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
   */
  constructor(scene, camera, {
    renderTarget: renderTarget2,
    resolutionScale = 1,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("NormalPass");
    this.needsSwap = false;
    this.renderPass = new RenderPass(scene, camera, new MeshNormalMaterial());
    const renderPass = this.renderPass;
    renderPass.ignoreBackground = true;
    renderPass.skipShadowMapUpdate = true;
    const clearPass = renderPass.getClearPass();
    clearPass.overrideClearColor = new Color(7829503);
    clearPass.overrideClearAlpha = 1;
    this.renderTarget = renderTarget2;
    if (this.renderTarget === void 0) {
      this.renderTarget = new WebGLRenderTarget(1, 1, {
        minFilter: NearestFilter,
        magFilter: NearestFilter
      });
      this.renderTarget.texture.name = "NormalPass.Target";
    }
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
  }
  set mainScene(value) {
    this.renderPass.mainScene = value;
  }
  set mainCamera(value) {
    this.renderPass.mainCamera = value;
  }
  /**
   * The normal texture.
   *
   * @type {Texture}
   */
  get texture() {
    return this.renderTarget.texture;
  }
  /**
   * The normal texture.
   *
   * @deprecated Use texture instead.
   * @return {Texture} The texture.
   */
  getTexture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the resolution settings.
   *
   * @deprecated Use resolution instead.
   * @return {Resolution} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * Returns the current resolution scale.
   *
   * @return {Number} The resolution scale.
   * @deprecated Use resolution.preferredWidth or resolution.preferredHeight instead.
   */
  getResolutionScale() {
    return this.resolution.scale;
  }
  /**
   * Sets the resolution scale.
   *
   * @param {Number} scale - The new resolution scale.
   * @deprecated Use resolution.preferredWidth or resolution.preferredHeight instead.
   */
  setResolutionScale(scale) {
    this.resolution.scale = scale;
  }
  /**
   * Renders the scene normals.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const renderTarget2 = this.renderToScreen ? null : this.renderTarget;
    this.renderPass.render(renderer, renderTarget2, renderTarget2);
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    this.renderTarget.setSize(resolution.width, resolution.height);
  }
};
var P = [
  new Float32Array(3),
  new Float32Array(3)
];
var C = [
  new Float32Array(3),
  new Float32Array(3),
  new Float32Array(3),
  new Float32Array(3)
];
var T = [
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([1, 0, 0]),
    new Float32Array([1, 1, 0]),
    new Float32Array([1, 1, 1])
  ],
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([1, 0, 0]),
    new Float32Array([1, 0, 1]),
    new Float32Array([1, 1, 1])
  ],
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([0, 0, 1]),
    new Float32Array([1, 0, 1]),
    new Float32Array([1, 1, 1])
  ],
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([0, 1, 0]),
    new Float32Array([1, 1, 0]),
    new Float32Array([1, 1, 1])
  ],
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([0, 1, 0]),
    new Float32Array([0, 1, 1]),
    new Float32Array([1, 1, 1])
  ],
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([0, 0, 1]),
    new Float32Array([0, 1, 1]),
    new Float32Array([1, 1, 1])
  ]
];
var area = [
  new Float32Array(2),
  new Float32Array(2)
];
var orthogonalSubsamplingOffsets = new Float32Array([
  0,
  -0.25,
  0.25,
  -0.125,
  0.125,
  -0.375,
  0.375
]);
var diagonalSubsamplingOffsets = [
  new Float32Array([0, 0]),
  new Float32Array([0.25, -0.25]),
  new Float32Array([-0.25, 0.25]),
  new Float32Array([0.125, -0.125]),
  new Float32Array([-0.125, 0.125])
];
var orthogonalEdges = [
  new Uint8Array([0, 0]),
  new Uint8Array([3, 0]),
  new Uint8Array([0, 3]),
  new Uint8Array([3, 3]),
  new Uint8Array([1, 0]),
  new Uint8Array([4, 0]),
  new Uint8Array([1, 3]),
  new Uint8Array([4, 3]),
  new Uint8Array([0, 1]),
  new Uint8Array([3, 1]),
  new Uint8Array([0, 4]),
  new Uint8Array([3, 4]),
  new Uint8Array([1, 1]),
  new Uint8Array([4, 1]),
  new Uint8Array([1, 4]),
  new Uint8Array([4, 4])
];
var diagonalEdges = [
  new Uint8Array([0, 0]),
  new Uint8Array([1, 0]),
  new Uint8Array([0, 2]),
  new Uint8Array([1, 2]),
  new Uint8Array([2, 0]),
  new Uint8Array([3, 0]),
  new Uint8Array([2, 2]),
  new Uint8Array([3, 2]),
  new Uint8Array([0, 1]),
  new Uint8Array([1, 1]),
  new Uint8Array([0, 3]),
  new Uint8Array([1, 3]),
  new Uint8Array([2, 1]),
  new Uint8Array([3, 1]),
  new Uint8Array([2, 3]),
  new Uint8Array([3, 3])
];
var edges = /* @__PURE__ */ new Map([
  [bilinear(0, 0, 0, 0), new Float32Array([0, 0, 0, 0])],
  [bilinear(0, 0, 0, 1), new Float32Array([0, 0, 0, 1])],
  [bilinear(0, 0, 1, 0), new Float32Array([0, 0, 1, 0])],
  [bilinear(0, 0, 1, 1), new Float32Array([0, 0, 1, 1])],
  [bilinear(0, 1, 0, 0), new Float32Array([0, 1, 0, 0])],
  [bilinear(0, 1, 0, 1), new Float32Array([0, 1, 0, 1])],
  [bilinear(0, 1, 1, 0), new Float32Array([0, 1, 1, 0])],
  [bilinear(0, 1, 1, 1), new Float32Array([0, 1, 1, 1])],
  [bilinear(1, 0, 0, 0), new Float32Array([1, 0, 0, 0])],
  [bilinear(1, 0, 0, 1), new Float32Array([1, 0, 0, 1])],
  [bilinear(1, 0, 1, 0), new Float32Array([1, 0, 1, 0])],
  [bilinear(1, 0, 1, 1), new Float32Array([1, 0, 1, 1])],
  [bilinear(1, 1, 0, 0), new Float32Array([1, 1, 0, 0])],
  [bilinear(1, 1, 0, 1), new Float32Array([1, 1, 0, 1])],
  [bilinear(1, 1, 1, 0), new Float32Array([1, 1, 1, 0])],
  [bilinear(1, 1, 1, 1), new Float32Array([1, 1, 1, 1])]
]);
function lerp2(a, b, p) {
  return a + (b - a) * p;
}
function bilinear(e0, e1, e2, e3) {
  const a = lerp2(e0, e1, 1 - 0.25);
  const b = lerp2(e2, e3, 1 - 0.25);
  return lerp2(a, b, 1 - 0.125);
}

// node_modules/three/examples/jsm/libs/stats.module.js
var Stats = function() {
  var mode = 0;
  var container = document.createElement("div");
  container.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000";
  container.addEventListener("click", function(event) {
    event.preventDefault();
    showPanel(++mode % container.children.length);
  }, false);
  function addPanel(panel) {
    container.appendChild(panel.dom);
    return panel;
  }
  function showPanel(id) {
    for (var i = 0; i < container.children.length; i++) {
      container.children[i].style.display = i === id ? "block" : "none";
    }
    mode = id;
  }
  var beginTime = (performance || Date).now(), prevTime = beginTime, frames = 0;
  var fpsPanel = addPanel(new Stats.Panel("FPS", "#0ff", "#002"));
  var msPanel = addPanel(new Stats.Panel("MS", "#0f0", "#020"));
  if (self.performance && self.performance.memory) {
    var memPanel = addPanel(new Stats.Panel("MB", "#f08", "#201"));
  }
  showPanel(0);
  return {
    REVISION: 16,
    dom: container,
    addPanel,
    showPanel,
    begin: function() {
      beginTime = (performance || Date).now();
    },
    end: function() {
      frames++;
      var time = (performance || Date).now();
      msPanel.update(time - beginTime, 200);
      if (time >= prevTime + 1e3) {
        fpsPanel.update(frames * 1e3 / (time - prevTime), 100);
        prevTime = time;
        frames = 0;
        if (memPanel) {
          var memory = performance.memory;
          memPanel.update(memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576);
        }
      }
      return time;
    },
    update: function() {
      beginTime = this.end();
    },
    // Backwards Compatibility
    domElement: container,
    setMode: showPanel
  };
};
Stats.Panel = function(name, fg, bg) {
  var min = Infinity, max = 0, round = Math.round;
  var PR = round(window.devicePixelRatio || 1);
  var WIDTH = 80 * PR, HEIGHT = 48 * PR, TEXT_X = 3 * PR, TEXT_Y = 2 * PR, GRAPH_X = 3 * PR, GRAPH_Y = 15 * PR, GRAPH_WIDTH = 74 * PR, GRAPH_HEIGHT = 30 * PR;
  var canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.cssText = "width:80px;height:48px";
  var context = canvas.getContext("2d");
  context.font = "bold " + 9 * PR + "px Helvetica,Arial,sans-serif";
  context.textBaseline = "top";
  context.fillStyle = bg;
  context.fillRect(0, 0, WIDTH, HEIGHT);
  context.fillStyle = fg;
  context.fillText(name, TEXT_X, TEXT_Y);
  context.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);
  context.fillStyle = bg;
  context.globalAlpha = 0.9;
  context.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);
  return {
    dom: canvas,
    update: function(value, maxValue) {
      min = Math.min(min, value);
      max = Math.max(max, value);
      context.fillStyle = bg;
      context.globalAlpha = 1;
      context.fillRect(0, 0, WIDTH, GRAPH_Y);
      context.fillStyle = fg;
      context.fillText(round(value) + " " + name + " (" + round(min) + "-" + round(max) + ")", TEXT_X, TEXT_Y);
      context.drawImage(canvas, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT);
      context.fillRect(GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT);
      context.fillStyle = bg;
      context.globalAlpha = 0.9;
      context.fillRect(GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, round((1 - value / maxValue) * GRAPH_HEIGHT));
    }
  };
};
var stats_module_default = Stats;

// node_modules/three/examples/jsm/renderers/webgl-legacy/nodes/WebGLNodeBuilder.js
var nodeFrame = new NodeFrame();
nodeFrame.camera = new PerspectiveCamera();
var nodeShaderLib = {
  LineBasicNodeMaterial: ShaderLib.basic,
  MeshBasicNodeMaterial: ShaderLib.basic,
  PointsNodeMaterial: ShaderLib.points,
  MeshStandardNodeMaterial: ShaderLib.standard,
  MeshPhysicalNodeMaterial: ShaderLib.physical,
  MeshPhongNodeMaterial: ShaderLib.phong
};

// node_modules/@needle-tools/engine/lib/engine/engine_patcher.js
var debugPatch = getParam("debugpatch");
function addPatch(prototype, fieldName, beforeCallback, afterCallback) {
  const debug115 = debugPatch === fieldName;
  if (!beforeCallback && !afterCallback) {
    return;
  }
  const backingField = fieldName + "___needle";
  internalAddPatch(prototype, fieldName, beforeCallback, afterCallback);
  const desc = Object.getOwnPropertyDescriptor(prototype, fieldName);
  const existing = prototype[fieldName];
  if (debug115)
    console.log("Patch", prototype.constructor.name, fieldName, desc, existing);
  if (desc) {
    if (debug115)
      console.log("Apply patch with existing descriptor", prototype.constructor.name, fieldName, desc);
    if (typeof desc.value === "function") {
      prototype[fieldName] = ensureFunctionWrapped(desc.value, prototype, fieldName);
    }
  } else {
    if (debug115)
      console.log("Create patch with new property", prototype.constructor.name, fieldName, desc);
    Object.defineProperty(prototype, fieldName, {
      set: function(value) {
        if (typeof value === "function") {
          this[backingField] = ensureFunctionWrapped(value, prototype, fieldName);
        } else {
          const prev = this[backingField];
          executePrefixes(prototype, fieldName, this, prev, value);
          this[backingField] = value;
          executePostFixes(prototype, fieldName, this, prev, value);
        }
      },
      get: function() {
        const value = this[backingField];
        if (typeof value === "function") {
          if (value[backingField]) {
            return value[backingField];
          }
        }
        return value;
      }
    });
  }
}
function removePatch(prototype, fieldName, prefixOrPostfix) {
  const patches2 = getPatches(prototype, fieldName);
  if (patches2) {
    for (let i = patches2.length - 1; i >= 0; i--) {
      const patch = patches2[i];
      if (patch.prefix === prefixOrPostfix) {
        patch.prefix = null;
      }
      if (patch.postfix === prefixOrPostfix) {
        patch.postfix = null;
      }
      if (!patch.prefix && !patch.postfix) {
        patches2.splice(i, 1);
      }
    }
  }
}
var $wrappedFunctionSymbol = Symbol("Needle:Patches:WrappedFunction");
function ensureFunctionWrapped(originalFunction, prototype, fieldname) {
  if (originalFunction[$wrappedFunctionSymbol]) {
    return originalFunction;
  }
  const wrappedFunction = function(...args) {
    executePrefixes(prototype, fieldname, this, ...args);
    const result = originalFunction.apply(this, args);
    executePostFixes(prototype, fieldname, this, result, ...args);
    return result;
  };
  wrappedFunction[$wrappedFunctionSymbol] = true;
  return wrappedFunction;
}
var NeedlePatchesKey = "Needle:Patches";
function patches() {
  if (!globalThis[NeedlePatchesKey]) {
    globalThis[NeedlePatchesKey] = /* @__PURE__ */ new WeakMap();
  }
  return globalThis[NeedlePatchesKey];
}
function getPatches(prototype, fieldName) {
  const patchesMap = patches().get(prototype);
  if (!patchesMap) {
    return null;
  }
  return patchesMap.get(fieldName);
  ;
}
function internalAddPatch(prototype, fieldName, prefix2, postfix) {
  let patchesMap = patches().get(prototype);
  if (!patchesMap) {
    patchesMap = /* @__PURE__ */ new Map();
    patches().set(prototype, patchesMap);
  }
  let patchList = patchesMap.get(fieldName);
  if (!patchList) {
    patchList = [];
    patchesMap.set(fieldName, patchList);
  }
  patchList.push({
    prefix: prefix2,
    postfix
  });
}
function executePrefixes(prototype, fieldName, instance, ...args) {
  var _a2;
  if (!instance)
    return;
  const patches2 = getPatches(prototype, fieldName);
  if (patches2) {
    for (const patchInfo of patches2) {
      (_a2 = patchInfo.prefix) == null ? void 0 : _a2.call(instance, ...args);
    }
  }
}
function executePostFixes(prototype, fieldName, instance, result, ...args) {
  var _a2;
  if (!instance)
    return;
  const patches2 = getPatches(prototype, fieldName);
  if (patches2) {
    for (const patchInfo of patches2) {
      (_a2 = patchInfo.postfix) == null ? void 0 : _a2.call(instance, result, ...args);
    }
  }
}

// node_modules/@needle-tools/gltf-progressive/lib/version.js
var version = "2.1.0-alpha.1";
globalThis["GLTF_PROGRESSIVE_VERSION"] = version;
console.debug(`[gltf-progressive] version ${version}`);

// node_modules/three/examples/jsm/utils/BufferGeometryUtils.js
function mergeVertices(geometry, tolerance = 1e-4) {
  tolerance = Math.max(tolerance, Number.EPSILON);
  const hashToIndex = {};
  const indices = geometry.getIndex();
  const positions = geometry.getAttribute("position");
  const vertexCount = indices ? indices.count : positions.count;
  let nextIndex = 0;
  const attributeNames = Object.keys(geometry.attributes);
  const tmpAttributes = {};
  const tmpMorphAttributes = {};
  const newIndices = [];
  const getters = ["getX", "getY", "getZ", "getW"];
  const setters = ["setX", "setY", "setZ", "setW"];
  for (let i = 0, l = attributeNames.length; i < l; i++) {
    const name = attributeNames[i];
    const attr = geometry.attributes[name];
    tmpAttributes[name] = new attr.constructor(
      new attr.array.constructor(attr.count * attr.itemSize),
      attr.itemSize,
      attr.normalized
    );
    const morphAttributes = geometry.morphAttributes[name];
    if (morphAttributes) {
      if (!tmpMorphAttributes[name])
        tmpMorphAttributes[name] = [];
      morphAttributes.forEach((morphAttr, i2) => {
        const array = new morphAttr.array.constructor(morphAttr.count * morphAttr.itemSize);
        tmpMorphAttributes[name][i2] = new morphAttr.constructor(array, morphAttr.itemSize, morphAttr.normalized);
      });
    }
  }
  const halfTolerance = tolerance * 0.5;
  const exponent = Math.log10(1 / tolerance);
  const hashMultiplier = Math.pow(10, exponent);
  const hashAdditive = halfTolerance * hashMultiplier;
  for (let i = 0; i < vertexCount; i++) {
    const index = indices ? indices.getX(i) : i;
    let hash = "";
    for (let j = 0, l = attributeNames.length; j < l; j++) {
      const name = attributeNames[j];
      const attribute = geometry.getAttribute(name);
      const itemSize = attribute.itemSize;
      for (let k = 0; k < itemSize; k++) {
        hash += `${~~(attribute[getters[k]](index) * hashMultiplier + hashAdditive)},`;
      }
    }
    if (hash in hashToIndex) {
      newIndices.push(hashToIndex[hash]);
    } else {
      for (let j = 0, l = attributeNames.length; j < l; j++) {
        const name = attributeNames[j];
        const attribute = geometry.getAttribute(name);
        const morphAttributes = geometry.morphAttributes[name];
        const itemSize = attribute.itemSize;
        const newArray = tmpAttributes[name];
        const newMorphArrays = tmpMorphAttributes[name];
        for (let k = 0; k < itemSize; k++) {
          const getterFunc = getters[k];
          const setterFunc = setters[k];
          newArray[setterFunc](nextIndex, attribute[getterFunc](index));
          if (morphAttributes) {
            for (let m2 = 0, ml = morphAttributes.length; m2 < ml; m2++) {
              newMorphArrays[m2][setterFunc](nextIndex, morphAttributes[m2][getterFunc](index));
            }
          }
        }
      }
      hashToIndex[hash] = nextIndex;
      newIndices.push(nextIndex);
      nextIndex++;
    }
  }
  const result = geometry.clone();
  for (const name in geometry.attributes) {
    const tmpAttribute = tmpAttributes[name];
    result.setAttribute(name, new tmpAttribute.constructor(
      tmpAttribute.array.slice(0, nextIndex * tmpAttribute.itemSize),
      tmpAttribute.itemSize,
      tmpAttribute.normalized
    ));
    if (!(name in tmpMorphAttributes))
      continue;
    for (let j = 0; j < tmpMorphAttributes[name].length; j++) {
      const tmpMorphAttribute = tmpMorphAttributes[name][j];
      result.morphAttributes[name][j] = new tmpMorphAttribute.constructor(
        tmpMorphAttribute.array.slice(0, nextIndex * tmpMorphAttribute.itemSize),
        tmpMorphAttribute.itemSize,
        tmpMorphAttribute.normalized
      );
    }
  }
  result.setIndex(newIndices);
  return result;
}
function toTrianglesDrawMode(geometry, drawMode) {
  if (drawMode === TrianglesDrawMode2) {
    console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.");
    return geometry;
  }
  if (drawMode === TriangleFanDrawMode2 || drawMode === TriangleStripDrawMode2) {
    let index = geometry.getIndex();
    if (index === null) {
      const indices = [];
      const position = geometry.getAttribute("position");
      if (position !== void 0) {
        for (let i = 0; i < position.count; i++) {
          indices.push(i);
        }
        geometry.setIndex(indices);
        index = geometry.getIndex();
      } else {
        console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");
        return geometry;
      }
    }
    const numberOfTriangles = index.count - 2;
    const newIndices = [];
    if (drawMode === TriangleFanDrawMode2) {
      for (let i = 1; i <= numberOfTriangles; i++) {
        newIndices.push(index.getX(0));
        newIndices.push(index.getX(i));
        newIndices.push(index.getX(i + 1));
      }
    } else {
      for (let i = 0; i < numberOfTriangles; i++) {
        if (i % 2 === 0) {
          newIndices.push(index.getX(i));
          newIndices.push(index.getX(i + 1));
          newIndices.push(index.getX(i + 2));
        } else {
          newIndices.push(index.getX(i + 2));
          newIndices.push(index.getX(i + 1));
          newIndices.push(index.getX(i));
        }
      }
    }
    if (newIndices.length / 3 !== numberOfTriangles) {
      console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    }
    const newGeometry = geometry.clone();
    newGeometry.setIndex(newIndices);
    newGeometry.clearGroups();
    return newGeometry;
  } else {
    console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", drawMode);
    return geometry;
  }
}

// node_modules/three/examples/jsm/loaders/GLTFLoader.js
var GLTFLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.dracoLoader = null;
    this.ktx2Loader = null;
    this.meshoptDecoder = null;
    this.pluginCallbacks = [];
    this.register(function(parser) {
      return new GLTFMaterialsClearcoatExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsDispersionExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureBasisUExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureWebPExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureAVIFExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSheenExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsTransmissionExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsVolumeExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsIorExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsEmissiveStrengthExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSpecularExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsIridescenceExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsAnisotropyExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsBumpExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFLightsExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMeshoptCompression(parser);
    });
    this.register(function(parser) {
      return new GLTFMeshGpuInstancing(parser);
    });
  }
  load(url, onLoad2, onProgress, onError2) {
    const scope = this;
    let resourcePath;
    if (this.resourcePath !== "") {
      resourcePath = this.resourcePath;
    } else if (this.path !== "") {
      const relativeUrl = LoaderUtils.extractUrlBase(url);
      resourcePath = LoaderUtils.resolveURL(relativeUrl, this.path);
    } else {
      resourcePath = LoaderUtils.extractUrlBase(url);
    }
    this.manager.itemStart(url);
    const _onError = function(e) {
      if (onError2) {
        onError2(e);
      } else {
        console.error(e);
      }
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    };
    const loader2 = new FileLoader(this.manager);
    loader2.setPath(this.path);
    loader2.setResponseType("arraybuffer");
    loader2.setRequestHeader(this.requestHeader);
    loader2.setWithCredentials(this.withCredentials);
    loader2.load(url, function(data) {
      try {
        scope.parse(data, resourcePath, function(gltf) {
          onLoad2(gltf);
          scope.manager.itemEnd(url);
        }, _onError);
      } catch (e) {
        _onError(e);
      }
    }, onProgress, _onError);
  }
  setDRACOLoader(dracoLoader2) {
    this.dracoLoader = dracoLoader2;
    return this;
  }
  setKTX2Loader(ktx2Loader2) {
    this.ktx2Loader = ktx2Loader2;
    return this;
  }
  setMeshoptDecoder(meshoptDecoder2) {
    this.meshoptDecoder = meshoptDecoder2;
    return this;
  }
  register(callback) {
    if (this.pluginCallbacks.indexOf(callback) === -1) {
      this.pluginCallbacks.push(callback);
    }
    return this;
  }
  unregister(callback) {
    if (this.pluginCallbacks.indexOf(callback) !== -1) {
      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
    }
    return this;
  }
  parse(data, path, onLoad2, onError2) {
    let json;
    const extensions = {};
    const plugins2 = {};
    const textDecoder = new TextDecoder();
    if (typeof data === "string") {
      json = JSON.parse(data);
    } else if (data instanceof ArrayBuffer) {
      const magic = textDecoder.decode(new Uint8Array(data, 0, 4));
      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
        try {
          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
        } catch (error) {
          if (onError2)
            onError2(error);
          return;
        }
        json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);
      } else {
        json = JSON.parse(textDecoder.decode(data));
      }
    } else {
      json = data;
    }
    if (json.asset === void 0 || json.asset.version[0] < 2) {
      if (onError2)
        onError2(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const parser = new GLTFParser(json, {
      path: path || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    parser.fileLoader.setRequestHeader(this.requestHeader);
    for (let i = 0; i < this.pluginCallbacks.length; i++) {
      const plugin = this.pluginCallbacks[i](parser);
      if (!plugin.name)
        console.error("THREE.GLTFLoader: Invalid plugin found: missing name");
      plugins2[plugin.name] = plugin;
      extensions[plugin.name] = true;
    }
    if (json.extensionsUsed) {
      for (let i = 0; i < json.extensionsUsed.length; ++i) {
        const extensionName = json.extensionsUsed[i];
        const extensionsRequired = json.extensionsRequired || [];
        switch (extensionName) {
          case EXTENSIONS.KHR_MATERIALS_UNLIT:
            extensions[extensionName] = new GLTFMaterialsUnlitExtension();
            break;
          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
            break;
          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
            extensions[extensionName] = new GLTFTextureTransformExtension();
            break;
          case EXTENSIONS.KHR_MESH_QUANTIZATION:
            extensions[extensionName] = new GLTFMeshQuantizationExtension();
            break;
          default:
            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins2[extensionName] === void 0) {
              console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
            }
        }
      }
    }
    parser.setExtensions(extensions);
    parser.setPlugins(plugins2);
    parser.parse(onLoad2, onError2);
  }
  parseAsync(data, path) {
    const scope = this;
    return new Promise(function(resolve2, reject) {
      scope.parse(data, path, resolve2, reject);
    });
  }
};
function GLTFRegistry() {
  let objects = {};
  return {
    get: function(key) {
      return objects[key];
    },
    add: function(key, object) {
      objects[key] = object;
    },
    remove: function(key) {
      delete objects[key];
    },
    removeAll: function() {
      objects = {};
    }
  };
}
var EXTENSIONS = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_MATERIALS_BUMP: "EXT_materials_bump",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
var GLTFLightsExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
    this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const parser = this.parser;
    const nodeDefs = this.parser.json.nodes || [];
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {
        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
      }
    }
  }
  _loadLight(lightIndex) {
    const parser = this.parser;
    const cacheKey = "light:" + lightIndex;
    let dependency = parser.cache.get(cacheKey);
    if (dependency)
      return dependency;
    const json = parser.json;
    const extensions = json.extensions && json.extensions[this.name] || {};
    const lightDefs = extensions.lights || [];
    const lightDef = lightDefs[lightIndex];
    let lightNode;
    const color2 = new Color(16777215);
    if (lightDef.color !== void 0)
      color2.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], LinearSRGBColorSpace);
    const range = lightDef.range !== void 0 ? lightDef.range : 0;
    switch (lightDef.type) {
      case "directional":
        lightNode = new DirectionalLight(color2);
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      case "point":
        lightNode = new PointLight(color2);
        lightNode.distance = range;
        break;
      case "spot":
        lightNode = new SpotLight(color2);
        lightNode.distance = range;
        lightDef.spot = lightDef.spot || {};
        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;
        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;
        lightNode.angle = lightDef.spot.outerConeAngle;
        lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + lightDef.type);
    }
    lightNode.position.set(0, 0, 0);
    lightNode.decay = 2;
    assignExtrasToUserData(lightNode, lightDef);
    if (lightDef.intensity !== void 0)
      lightNode.intensity = lightDef.intensity;
    lightNode.name = parser.createUniqueName(lightDef.name || "light_" + lightIndex);
    dependency = Promise.resolve(lightNode);
    parser.cache.add(cacheKey, dependency);
    return dependency;
  }
  getDependency(type, index) {
    if (type !== "light")
      return;
    return this._loadLight(index);
  }
  createNodeAttachment(nodeIndex) {
    const self2 = this;
    const parser = this.parser;
    const json = parser.json;
    const nodeDef = json.nodes[nodeIndex];
    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};
    const lightIndex = lightDef.light;
    if (lightIndex === void 0)
      return null;
    return this._loadLight(lightIndex).then(function(light) {
      return parser._getNodeRef(self2.cache, lightIndex, light);
    });
  }
};
var GLTFMaterialsUnlitExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return MeshBasicMaterial;
  }
  extendParams(materialParams, materialDef, parser) {
    const pending = [];
    materialParams.color = new Color(1, 1, 1);
    materialParams.opacity = 1;
    const metallicRoughness = materialDef.pbrMetallicRoughness;
    if (metallicRoughness) {
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, SRGBColorSpace));
      }
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsEmissiveStrengthExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;
    if (emissiveStrength !== void 0) {
      materialParams.emissiveIntensity = emissiveStrength;
    }
    return Promise.resolve();
  }
};
var GLTFMaterialsClearcoatExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.clearcoatFactor !== void 0) {
      materialParams.clearcoat = extension.clearcoatFactor;
    }
    if (extension.clearcoatTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatMap", extension.clearcoatTexture));
    }
    if (extension.clearcoatRoughnessFactor !== void 0) {
      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
    }
    if (extension.clearcoatRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatRoughnessMap", extension.clearcoatRoughnessTexture));
    }
    if (extension.clearcoatNormalTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatNormalMap", extension.clearcoatNormalTexture));
      if (extension.clearcoatNormalTexture.scale !== void 0) {
        const scale = extension.clearcoatNormalTexture.scale;
        materialParams.clearcoatNormalScale = new Vector2(scale, scale);
      }
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsDispersionExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const extension = materialDef.extensions[this.name];
    materialParams.dispersion = extension.dispersion !== void 0 ? extension.dispersion : 0;
    return Promise.resolve();
  }
};
var GLTFMaterialsIridescenceExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.iridescenceFactor !== void 0) {
      materialParams.iridescence = extension.iridescenceFactor;
    }
    if (extension.iridescenceTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "iridescenceMap", extension.iridescenceTexture));
    }
    if (extension.iridescenceIor !== void 0) {
      materialParams.iridescenceIOR = extension.iridescenceIor;
    }
    if (materialParams.iridescenceThicknessRange === void 0) {
      materialParams.iridescenceThicknessRange = [100, 400];
    }
    if (extension.iridescenceThicknessMinimum !== void 0) {
      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;
    }
    if (extension.iridescenceThicknessMaximum !== void 0) {
      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;
    }
    if (extension.iridescenceThicknessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "iridescenceThicknessMap", extension.iridescenceThicknessTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsSheenExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    materialParams.sheenColor = new Color(0, 0, 0);
    materialParams.sheenRoughness = 0;
    materialParams.sheen = 1;
    const extension = materialDef.extensions[this.name];
    if (extension.sheenColorFactor !== void 0) {
      const colorFactor = extension.sheenColorFactor;
      materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], LinearSRGBColorSpace);
    }
    if (extension.sheenRoughnessFactor !== void 0) {
      materialParams.sheenRoughness = extension.sheenRoughnessFactor;
    }
    if (extension.sheenColorTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "sheenColorMap", extension.sheenColorTexture, SRGBColorSpace));
    }
    if (extension.sheenRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "sheenRoughnessMap", extension.sheenRoughnessTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsTransmissionExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.transmissionFactor !== void 0) {
      materialParams.transmission = extension.transmissionFactor;
    }
    if (extension.transmissionTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "transmissionMap", extension.transmissionTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsVolumeExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;
    if (extension.thicknessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "thicknessMap", extension.thicknessTexture));
    }
    materialParams.attenuationDistance = extension.attenuationDistance || Infinity;
    const colorArray = extension.attenuationColor || [1, 1, 1];
    materialParams.attenuationColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);
    return Promise.all(pending);
  }
};
var GLTFMaterialsIorExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_IOR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const extension = materialDef.extensions[this.name];
    materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;
    return Promise.resolve();
  }
};
var GLTFMaterialsSpecularExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;
    if (extension.specularTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularIntensityMap", extension.specularTexture));
    }
    const colorArray = extension.specularColorFactor || [1, 1, 1];
    materialParams.specularColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);
    if (extension.specularColorTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularColorMap", extension.specularColorTexture, SRGBColorSpace));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsBumpExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_MATERIALS_BUMP;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.bumpScale = extension.bumpFactor !== void 0 ? extension.bumpFactor : 1;
    if (extension.bumpTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "bumpMap", extension.bumpTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsAnisotropyExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.anisotropyStrength !== void 0) {
      materialParams.anisotropy = extension.anisotropyStrength;
    }
    if (extension.anisotropyRotation !== void 0) {
      materialParams.anisotropyRotation = extension.anisotropyRotation;
    }
    if (extension.anisotropyTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "anisotropyMap", extension.anisotropyTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFTextureBasisUExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
  }
  loadTexture(textureIndex) {
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[this.name]) {
      return null;
    }
    const extension = textureDef.extensions[this.name];
    const loader2 = parser.options.ktx2Loader;
    if (!loader2) {
      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      } else {
        return null;
      }
    }
    return parser.loadTextureImage(textureIndex, extension.source, loader2);
  }
};
var GLTFTextureWebPExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
    this.isSupported = null;
  }
  loadTexture(textureIndex) {
    const name = this.name;
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[name]) {
      return null;
    }
    const extension = textureDef.extensions[name];
    const source = json.images[extension.source];
    let loader2 = parser.textureLoader;
    if (source.uri) {
      const handler = parser.options.manager.getHandler(source.uri);
      if (handler !== null)
        loader2 = handler;
    }
    return this.detectSupport().then(function(isSupported) {
      if (isSupported)
        return parser.loadTextureImage(textureIndex, extension.source, loader2);
      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      }
      return parser.loadTexture(textureIndex);
    });
  }
  detectSupport() {
    if (!this.isSupported) {
      this.isSupported = new Promise(function(resolve2) {
        const image = new Image();
        image.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA";
        image.onload = image.onerror = function() {
          resolve2(image.height === 1);
        };
      });
    }
    return this.isSupported;
  }
};
var GLTFTextureAVIFExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_AVIF;
    this.isSupported = null;
  }
  loadTexture(textureIndex) {
    const name = this.name;
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[name]) {
      return null;
    }
    const extension = textureDef.extensions[name];
    const source = json.images[extension.source];
    let loader2 = parser.textureLoader;
    if (source.uri) {
      const handler = parser.options.manager.getHandler(source.uri);
      if (handler !== null)
        loader2 = handler;
    }
    return this.detectSupport().then(function(isSupported) {
      if (isSupported)
        return parser.loadTextureImage(textureIndex, extension.source, loader2);
      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      }
      return parser.loadTexture(textureIndex);
    });
  }
  detectSupport() {
    if (!this.isSupported) {
      this.isSupported = new Promise(function(resolve2) {
        const image = new Image();
        image.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=";
        image.onload = image.onerror = function() {
          resolve2(image.height === 1);
        };
      });
    }
    return this.isSupported;
  }
};
var GLTFMeshoptCompression = class {
  constructor(parser) {
    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
    this.parser = parser;
  }
  loadBufferView(index) {
    const json = this.parser.json;
    const bufferView = json.bufferViews[index];
    if (bufferView.extensions && bufferView.extensions[this.name]) {
      const extensionDef = bufferView.extensions[this.name];
      const buffer2 = this.parser.getDependency("buffer", extensionDef.buffer);
      const decoder = this.parser.options.meshoptDecoder;
      if (!decoder || !decoder.supported) {
        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        } else {
          return null;
        }
      }
      return buffer2.then(function(res) {
        const byteOffset = extensionDef.byteOffset || 0;
        const byteLength = extensionDef.byteLength || 0;
        const count = extensionDef.count;
        const stride = extensionDef.byteStride;
        const source = new Uint8Array(res, byteOffset, byteLength);
        if (decoder.decodeGltfBufferAsync) {
          return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {
            return res2.buffer;
          });
        } else {
          return decoder.ready.then(function() {
            const result = new ArrayBuffer(count * stride);
            decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);
            return result;
          });
        }
      });
    } else {
      return null;
    }
  }
};
var GLTFMeshGpuInstancing = class {
  constructor(parser) {
    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;
    this.parser = parser;
  }
  createNodeMesh(nodeIndex) {
    const json = this.parser.json;
    const nodeDef = json.nodes[nodeIndex];
    if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {
      return null;
    }
    const meshDef = json.meshes[nodeDef.mesh];
    for (const primitive of meshDef.primitives) {
      if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== void 0) {
        return null;
      }
    }
    const extensionDef = nodeDef.extensions[this.name];
    const attributesDef = extensionDef.attributes;
    const pending = [];
    const attributes = {};
    for (const key in attributesDef) {
      pending.push(this.parser.getDependency("accessor", attributesDef[key]).then((accessor) => {
        attributes[key] = accessor;
        return attributes[key];
      }));
    }
    if (pending.length < 1) {
      return null;
    }
    pending.push(this.parser.createNodeMesh(nodeIndex));
    return Promise.all(pending).then((results) => {
      const nodeObject = results.pop();
      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject];
      const count = results[0].count;
      const instancedMeshes = [];
      for (const mesh of meshes) {
        const m2 = new Matrix4();
        const p = new Vector32();
        const q = new Quaternion();
        const s = new Vector32(1, 1, 1);
        const instancedMesh = new InstancedMesh(mesh.geometry, mesh.material, count);
        for (let i = 0; i < count; i++) {
          if (attributes.TRANSLATION) {
            p.fromBufferAttribute(attributes.TRANSLATION, i);
          }
          if (attributes.ROTATION) {
            q.fromBufferAttribute(attributes.ROTATION, i);
          }
          if (attributes.SCALE) {
            s.fromBufferAttribute(attributes.SCALE, i);
          }
          instancedMesh.setMatrixAt(i, m2.compose(p, q, s));
        }
        for (const attributeName in attributes) {
          if (attributeName === "_COLOR_0") {
            const attr = attributes[attributeName];
            instancedMesh.instanceColor = new InstancedBufferAttribute2(attr.array, attr.itemSize, attr.normalized);
          } else if (attributeName !== "TRANSLATION" && attributeName !== "ROTATION" && attributeName !== "SCALE") {
            mesh.geometry.setAttribute(attributeName, attributes[attributeName]);
          }
        }
        Object3D.prototype.copy.call(instancedMesh, mesh);
        this.parser.assignFinalMaterial(instancedMesh);
        instancedMeshes.push(instancedMesh);
      }
      if (nodeObject.isGroup) {
        nodeObject.clear();
        nodeObject.add(...instancedMeshes);
        return nodeObject;
      }
      return instancedMeshes[0];
    });
  }
};
var BINARY_EXTENSION_HEADER_MAGIC = "glTF";
var BINARY_EXTENSION_HEADER_LENGTH = 12;
var BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };
var GLTFBinaryExtension = class {
  constructor(data) {
    this.name = EXTENSIONS.KHR_BINARY_GLTF;
    this.content = null;
    this.body = null;
    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
    const textDecoder = new TextDecoder();
    this.header = {
      magic: textDecoder.decode(new Uint8Array(data.slice(0, 4))),
      version: headerView.getUint32(4, true),
      length: headerView.getUint32(8, true)
    };
    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    } else if (this.header.version < 2) {
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    }
    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
    let chunkIndex = 0;
    while (chunkIndex < chunkContentsLength) {
      const chunkLength = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      const chunkType = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
        this.content = textDecoder.decode(contentArray);
      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
        this.body = data.slice(byteOffset, byteOffset + chunkLength);
      }
      chunkIndex += chunkLength;
    }
    if (this.content === null) {
      throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
  }
};
var GLTFDracoMeshCompressionExtension = class {
  constructor(json, dracoLoader2) {
    if (!dracoLoader2) {
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    }
    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
    this.json = json;
    this.dracoLoader = dracoLoader2;
    this.dracoLoader.preload();
  }
  decodePrimitive(primitive, parser) {
    const json = this.json;
    const dracoLoader2 = this.dracoLoader;
    const bufferViewIndex = primitive.extensions[this.name].bufferView;
    const gltfAttributeMap = primitive.extensions[this.name].attributes;
    const threeAttributeMap = {};
    const attributeNormalizedMap = {};
    const attributeTypeMap = {};
    for (const attributeName in gltfAttributeMap) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
    }
    for (const attributeName in primitive.attributes) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      if (gltfAttributeMap[attributeName] !== void 0) {
        const accessorDef = json.accessors[primitive.attributes[attributeName]];
        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
        attributeTypeMap[threeAttributeName] = componentType.name;
        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
      }
    }
    return parser.getDependency("bufferView", bufferViewIndex).then(function(bufferView) {
      return new Promise(function(resolve2, reject) {
        dracoLoader2.decodeDracoFile(bufferView, function(geometry) {
          for (const attributeName in geometry.attributes) {
            const attribute = geometry.attributes[attributeName];
            const normalized = attributeNormalizedMap[attributeName];
            if (normalized !== void 0)
              attribute.normalized = normalized;
          }
          resolve2(geometry);
        }, threeAttributeMap, attributeTypeMap, LinearSRGBColorSpace, reject);
      });
    });
  }
};
var GLTFTextureTransformExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(texture, transform) {
    if ((transform.texCoord === void 0 || transform.texCoord === texture.channel) && transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {
      return texture;
    }
    texture = texture.clone();
    if (transform.texCoord !== void 0) {
      texture.channel = transform.texCoord;
    }
    if (transform.offset !== void 0) {
      texture.offset.fromArray(transform.offset);
    }
    if (transform.rotation !== void 0) {
      texture.rotation = transform.rotation;
    }
    if (transform.scale !== void 0) {
      texture.repeat.fromArray(transform.scale);
    }
    texture.needsUpdate = true;
    return texture;
  }
};
var GLTFMeshQuantizationExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
  }
};
var GLTFCubicSplineInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  copySampleValue_(index) {
    const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;
    for (let i = 0; i !== valueSize; i++) {
      result[i] = values[offset + i];
    }
    return result;
  }
  interpolate_(i1, t0, t2, t1) {
    const result = this.resultBuffer;
    const values = this.sampleValues;
    const stride = this.valueSize;
    const stride2 = stride * 2;
    const stride3 = stride * 3;
    const td = t1 - t0;
    const p = (t2 - t0) / td;
    const pp = p * p;
    const ppp = pp * p;
    const offset1 = i1 * stride3;
    const offset0 = offset1 - stride3;
    const s2 = -2 * ppp + 3 * pp;
    const s3 = ppp - pp;
    const s0 = 1 - s2;
    const s1 = s3 - pp + p;
    for (let i = 0; i !== stride; i++) {
      const p0 = values[offset0 + i + stride];
      const m0 = values[offset0 + i + stride2] * td;
      const p1 = values[offset1 + i + stride];
      const m1 = values[offset1 + i] * td;
      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
    }
    return result;
  }
};
var _q = new Quaternion();
var GLTFCubicSplineQuaternionInterpolant = class extends GLTFCubicSplineInterpolant {
  interpolate_(i1, t0, t2, t1) {
    const result = super.interpolate_(i1, t0, t2, t1);
    _q.fromArray(result).normalize().toArray(result);
    return result;
  }
};
var WEBGL_CONSTANTS = {
  FLOAT: 5126,
  //FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
};
var WEBGL_COMPONENT_TYPES = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
var WEBGL_FILTERS = {
  9728: NearestFilter,
  9729: LinearFilter,
  9984: NearestMipmapNearestFilter,
  9985: LinearMipmapNearestFilter,
  9986: NearestMipmapLinearFilter,
  9987: LinearMipmapLinearFilter
};
var WEBGL_WRAPPINGS = {
  33071: ClampToEdgeWrapping,
  33648: MirroredRepeatWrapping,
  10497: RepeatWrapping
};
var WEBGL_TYPE_SIZES = {
  "SCALAR": 1,
  "VEC2": 2,
  "VEC3": 3,
  "VEC4": 4,
  "MAT2": 4,
  "MAT3": 9,
  "MAT4": 16
};
var ATTRIBUTES = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv1",
  TEXCOORD_2: "uv2",
  TEXCOORD_3: "uv3",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
};
var PATH_PROPERTIES = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
};
var INTERPOLATION = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: InterpolateLinear,
  STEP: InterpolateDiscrete
};
var ALPHA_MODES = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function createDefaultMaterial(cache) {
  if (cache["DefaultMaterial"] === void 0) {
    cache["DefaultMaterial"] = new MeshStandardMaterial({
      color: 16777215,
      emissive: 0,
      metalness: 1,
      roughness: 1,
      transparent: false,
      depthTest: true,
      side: FrontSide
    });
  }
  return cache["DefaultMaterial"];
}
function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
  for (const name in objectDef.extensions) {
    if (knownExtensions[name] === void 0) {
      object.userData.gltfExtensions = object.userData.gltfExtensions || {};
      object.userData.gltfExtensions[name] = objectDef.extensions[name];
    }
  }
}
function assignExtrasToUserData(object, gltfDef) {
  if (gltfDef.extras !== void 0) {
    if (typeof gltfDef.extras === "object") {
      Object.assign(object.userData, gltfDef.extras);
    } else {
      console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + gltfDef.extras);
    }
  }
}
function addMorphTargets(geometry, targets, parser) {
  let hasMorphPosition = false;
  let hasMorphNormal = false;
  let hasMorphColor = false;
  for (let i = 0, il = targets.length; i < il; i++) {
    const target = targets[i];
    if (target.POSITION !== void 0)
      hasMorphPosition = true;
    if (target.NORMAL !== void 0)
      hasMorphNormal = true;
    if (target.COLOR_0 !== void 0)
      hasMorphColor = true;
    if (hasMorphPosition && hasMorphNormal && hasMorphColor)
      break;
  }
  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor)
    return Promise.resolve(geometry);
  const pendingPositionAccessors = [];
  const pendingNormalAccessors = [];
  const pendingColorAccessors = [];
  for (let i = 0, il = targets.length; i < il; i++) {
    const target = targets[i];
    if (hasMorphPosition) {
      const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency("accessor", target.POSITION) : geometry.attributes.position;
      pendingPositionAccessors.push(pendingAccessor);
    }
    if (hasMorphNormal) {
      const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency("accessor", target.NORMAL) : geometry.attributes.normal;
      pendingNormalAccessors.push(pendingAccessor);
    }
    if (hasMorphColor) {
      const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency("accessor", target.COLOR_0) : geometry.attributes.color;
      pendingColorAccessors.push(pendingAccessor);
    }
  }
  return Promise.all([
    Promise.all(pendingPositionAccessors),
    Promise.all(pendingNormalAccessors),
    Promise.all(pendingColorAccessors)
  ]).then(function(accessors) {
    const morphPositions = accessors[0];
    const morphNormals = accessors[1];
    const morphColors = accessors[2];
    if (hasMorphPosition)
      geometry.morphAttributes.position = morphPositions;
    if (hasMorphNormal)
      geometry.morphAttributes.normal = morphNormals;
    if (hasMorphColor)
      geometry.morphAttributes.color = morphColors;
    geometry.morphTargetsRelative = true;
    return geometry;
  });
}
function updateMorphTargets(mesh, meshDef) {
  mesh.updateMorphTargets();
  if (meshDef.weights !== void 0) {
    for (let i = 0, il = meshDef.weights.length; i < il; i++) {
      mesh.morphTargetInfluences[i] = meshDef.weights[i];
    }
  }
  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
    const targetNames = meshDef.extras.targetNames;
    if (mesh.morphTargetInfluences.length === targetNames.length) {
      mesh.morphTargetDictionary = {};
      for (let i = 0, il = targetNames.length; i < il; i++) {
        mesh.morphTargetDictionary[targetNames[i]] = i;
      }
    } else {
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
    }
  }
}
function createPrimitiveKey(primitiveDef) {
  let geometryKey;
  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
  if (dracoExtension) {
    geometryKey = "draco:" + dracoExtension.bufferView + ":" + dracoExtension.indices + ":" + createAttributesKey(dracoExtension.attributes);
  } else {
    geometryKey = primitiveDef.indices + ":" + createAttributesKey(primitiveDef.attributes) + ":" + primitiveDef.mode;
  }
  if (primitiveDef.targets !== void 0) {
    for (let i = 0, il = primitiveDef.targets.length; i < il; i++) {
      geometryKey += ":" + createAttributesKey(primitiveDef.targets[i]);
    }
  }
  return geometryKey;
}
function createAttributesKey(attributes) {
  let attributesKey = "";
  const keys = Object.keys(attributes).sort();
  for (let i = 0, il = keys.length; i < il; i++) {
    attributesKey += keys[i] + ":" + attributes[keys[i]] + ";";
  }
  return attributesKey;
}
function getNormalizedComponentScale(constructor) {
  switch (constructor) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function getImageURIMimeType(uri) {
  if (uri.search(/\.jpe?g($|\?)/i) > 0 || uri.search(/^data\:image\/jpeg/) === 0)
    return "image/jpeg";
  if (uri.search(/\.webp($|\?)/i) > 0 || uri.search(/^data\:image\/webp/) === 0)
    return "image/webp";
  return "image/png";
}
var _identityMatrix = new Matrix4();
var GLTFParser = class {
  constructor(json = {}, options = {}) {
    this.json = json;
    this.extensions = {};
    this.plugins = {};
    this.options = options;
    this.cache = new GLTFRegistry();
    this.associations = /* @__PURE__ */ new Map();
    this.primitiveCache = {};
    this.nodeCache = {};
    this.meshCache = { refs: {}, uses: {} };
    this.cameraCache = { refs: {}, uses: {} };
    this.lightCache = { refs: {}, uses: {} };
    this.sourceCache = {};
    this.textureCache = {};
    this.nodeNamesUsed = {};
    let isSafari2 = false;
    let safariVersion = -1;
    let isFirefox = false;
    let firefoxVersion = -1;
    if (typeof navigator !== "undefined") {
      const userAgent = navigator.userAgent;
      isSafari2 = /^((?!chrome|android).)*safari/i.test(userAgent) === true;
      const safariMatch = userAgent.match(/Version\/(\d+)/);
      safariVersion = isSafari2 && safariMatch ? parseInt(safariMatch[1], 10) : -1;
      isFirefox = userAgent.indexOf("Firefox") > -1;
      firefoxVersion = isFirefox ? userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
    }
    if (typeof createImageBitmap === "undefined" || isSafari2 && safariVersion < 17 || isFirefox && firefoxVersion < 98) {
      this.textureLoader = new TextureLoader(this.options.manager);
    } else {
      this.textureLoader = new ImageBitmapLoader(this.options.manager);
    }
    this.textureLoader.setCrossOrigin(this.options.crossOrigin);
    this.textureLoader.setRequestHeader(this.options.requestHeader);
    this.fileLoader = new FileLoader(this.options.manager);
    this.fileLoader.setResponseType("arraybuffer");
    if (this.options.crossOrigin === "use-credentials") {
      this.fileLoader.setWithCredentials(true);
    }
  }
  setExtensions(extensions) {
    this.extensions = extensions;
  }
  setPlugins(plugins2) {
    this.plugins = plugins2;
  }
  parse(onLoad2, onError2) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    this.cache.removeAll();
    this.nodeCache = {};
    this._invokeAll(function(ext) {
      return ext._markDefs && ext._markDefs();
    });
    Promise.all(this._invokeAll(function(ext) {
      return ext.beforeRoot && ext.beforeRoot();
    })).then(function() {
      return Promise.all([
        parser.getDependencies("scene"),
        parser.getDependencies("animation"),
        parser.getDependencies("camera")
      ]);
    }).then(function(dependencies) {
      const result = {
        scene: dependencies[0][json.scene || 0],
        scenes: dependencies[0],
        animations: dependencies[1],
        cameras: dependencies[2],
        asset: json.asset,
        parser,
        userData: {}
      };
      addUnknownExtensionsToUserData(extensions, result, json);
      assignExtrasToUserData(result, json);
      return Promise.all(parser._invokeAll(function(ext) {
        return ext.afterRoot && ext.afterRoot(result);
      })).then(function() {
        for (const scene of result.scenes) {
          scene.updateMatrixWorld();
        }
        onLoad2(result);
      });
    }).catch(onError2);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const nodeDefs = this.json.nodes || [];
    const skinDefs = this.json.skins || [];
    const meshDefs = this.json.meshes || [];
    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
      const joints = skinDefs[skinIndex].joints;
      for (let i = 0, il = joints.length; i < il; i++) {
        nodeDefs[joints[i]].isBone = true;
      }
    }
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.mesh !== void 0) {
        this._addNodeRef(this.meshCache, nodeDef.mesh);
        if (nodeDef.skin !== void 0) {
          meshDefs[nodeDef.mesh].isSkinnedMesh = true;
        }
      }
      if (nodeDef.camera !== void 0) {
        this._addNodeRef(this.cameraCache, nodeDef.camera);
      }
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(cache, index) {
    if (index === void 0)
      return;
    if (cache.refs[index] === void 0) {
      cache.refs[index] = cache.uses[index] = 0;
    }
    cache.refs[index]++;
  }
  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(cache, index, object) {
    if (cache.refs[index] <= 1)
      return object;
    const ref = object.clone();
    const updateMappings = (original, clone) => {
      const mappings = this.associations.get(original);
      if (mappings != null) {
        this.associations.set(clone, mappings);
      }
      for (const [i, child] of original.children.entries()) {
        updateMappings(child, clone.children[i]);
      }
    };
    updateMappings(object, ref);
    ref.name += "_instance_" + cache.uses[index]++;
    return ref;
  }
  _invokeOne(func) {
    const extensions = Object.values(this.plugins);
    extensions.push(this);
    for (let i = 0; i < extensions.length; i++) {
      const result = func(extensions[i]);
      if (result)
        return result;
    }
    return null;
  }
  _invokeAll(func) {
    const extensions = Object.values(this.plugins);
    extensions.unshift(this);
    const pending = [];
    for (let i = 0; i < extensions.length; i++) {
      const result = func(extensions[i]);
      if (result)
        pending.push(result);
    }
    return pending;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(type, index) {
    const cacheKey = type + ":" + index;
    let dependency = this.cache.get(cacheKey);
    if (!dependency) {
      switch (type) {
        case "scene":
          dependency = this.loadScene(index);
          break;
        case "node":
          dependency = this._invokeOne(function(ext) {
            return ext.loadNode && ext.loadNode(index);
          });
          break;
        case "mesh":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMesh && ext.loadMesh(index);
          });
          break;
        case "accessor":
          dependency = this.loadAccessor(index);
          break;
        case "bufferView":
          dependency = this._invokeOne(function(ext) {
            return ext.loadBufferView && ext.loadBufferView(index);
          });
          break;
        case "buffer":
          dependency = this.loadBuffer(index);
          break;
        case "material":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMaterial && ext.loadMaterial(index);
          });
          break;
        case "texture":
          dependency = this._invokeOne(function(ext) {
            return ext.loadTexture && ext.loadTexture(index);
          });
          break;
        case "skin":
          dependency = this.loadSkin(index);
          break;
        case "animation":
          dependency = this._invokeOne(function(ext) {
            return ext.loadAnimation && ext.loadAnimation(index);
          });
          break;
        case "camera":
          dependency = this.loadCamera(index);
          break;
        default:
          dependency = this._invokeOne(function(ext) {
            return ext != this && ext.getDependency && ext.getDependency(type, index);
          });
          if (!dependency) {
            throw new Error("Unknown type: " + type);
          }
          break;
      }
      this.cache.add(cacheKey, dependency);
    }
    return dependency;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(type) {
    let dependencies = this.cache.get(type);
    if (!dependencies) {
      const parser = this;
      const defs = this.json[type + (type === "mesh" ? "es" : "s")] || [];
      dependencies = Promise.all(defs.map(function(def, index) {
        return parser.getDependency(type, index);
      }));
      this.cache.add(type, dependencies);
    }
    return dependencies;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(bufferIndex) {
    const bufferDef = this.json.buffers[bufferIndex];
    const loader2 = this.fileLoader;
    if (bufferDef.type && bufferDef.type !== "arraybuffer") {
      throw new Error("THREE.GLTFLoader: " + bufferDef.type + " buffer type is not supported.");
    }
    if (bufferDef.uri === void 0 && bufferIndex === 0) {
      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
    }
    const options = this.options;
    return new Promise(function(resolve2, reject) {
      loader2.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve2, void 0, function() {
        reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(bufferViewIndex) {
    const bufferViewDef = this.json.bufferViews[bufferViewIndex];
    return this.getDependency("buffer", bufferViewDef.buffer).then(function(buffer2) {
      const byteLength = bufferViewDef.byteLength || 0;
      const byteOffset = bufferViewDef.byteOffset || 0;
      return buffer2.slice(byteOffset, byteOffset + byteLength);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(accessorIndex) {
    const parser = this;
    const json = this.json;
    const accessorDef = this.json.accessors[accessorIndex];
    if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {
      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
      const normalized = accessorDef.normalized === true;
      const array = new TypedArray(accessorDef.count * itemSize);
      return Promise.resolve(new BufferAttribute2(array, itemSize, normalized));
    }
    const pendingBufferViews = [];
    if (accessorDef.bufferView !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.bufferView));
    } else {
      pendingBufferViews.push(null);
    }
    if (accessorDef.sparse !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.indices.bufferView));
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.values.bufferView));
    }
    return Promise.all(pendingBufferViews).then(function(bufferViews) {
      const bufferView = bufferViews[0];
      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
      const elementBytes = TypedArray.BYTES_PER_ELEMENT;
      const itemBytes = elementBytes * itemSize;
      const byteOffset = accessorDef.byteOffset || 0;
      const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;
      const normalized = accessorDef.normalized === true;
      let array, bufferAttribute;
      if (byteStride && byteStride !== itemBytes) {
        const ibSlice = Math.floor(byteOffset / byteStride);
        const ibCacheKey = "InterleavedBuffer:" + accessorDef.bufferView + ":" + accessorDef.componentType + ":" + ibSlice + ":" + accessorDef.count;
        let ib = parser.cache.get(ibCacheKey);
        if (!ib) {
          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);
          ib = new InterleavedBuffer2(array, byteStride / elementBytes);
          parser.cache.add(ibCacheKey, ib);
        }
        bufferAttribute = new InterleavedBufferAttribute2(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
      } else {
        if (bufferView === null) {
          array = new TypedArray(accessorDef.count * itemSize);
        } else {
          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
        }
        bufferAttribute = new BufferAttribute2(array, itemSize, normalized);
      }
      if (accessorDef.sparse !== void 0) {
        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
        const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
        if (bufferView !== null) {
          bufferAttribute = new BufferAttribute2(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
        }
        bufferAttribute.normalized = false;
        for (let i = 0, il = sparseIndices.length; i < il; i++) {
          const index = sparseIndices[i];
          bufferAttribute.setX(index, sparseValues[i * itemSize]);
          if (itemSize >= 2)
            bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);
          if (itemSize >= 3)
            bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);
          if (itemSize >= 4)
            bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);
          if (itemSize >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
        bufferAttribute.normalized = normalized;
      }
      return bufferAttribute;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(textureIndex) {
    const json = this.json;
    const options = this.options;
    const textureDef = json.textures[textureIndex];
    const sourceIndex = textureDef.source;
    const sourceDef = json.images[sourceIndex];
    let loader2 = this.textureLoader;
    if (sourceDef.uri) {
      const handler = options.manager.getHandler(sourceDef.uri);
      if (handler !== null)
        loader2 = handler;
    }
    return this.loadTextureImage(textureIndex, sourceIndex, loader2);
  }
  loadTextureImage(textureIndex, sourceIndex, loader2) {
    const parser = this;
    const json = this.json;
    const textureDef = json.textures[textureIndex];
    const sourceDef = json.images[sourceIndex];
    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + ":" + textureDef.sampler;
    if (this.textureCache[cacheKey]) {
      return this.textureCache[cacheKey];
    }
    const promise = this.loadImageSource(sourceIndex, loader2).then(function(texture) {
      texture.flipY = false;
      texture.name = textureDef.name || sourceDef.name || "";
      if (texture.name === "" && typeof sourceDef.uri === "string" && sourceDef.uri.startsWith("data:image/") === false) {
        texture.name = sourceDef.uri;
      }
      const samplers = json.samplers || {};
      const sampler = samplers[textureDef.sampler] || {};
      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;
      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;
      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;
      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;
      texture.anisotropy = 4;
      parser.associations.set(texture, { textures: textureIndex });
      return texture;
    }).catch(function() {
      return null;
    });
    this.textureCache[cacheKey] = promise;
    return promise;
  }
  loadImageSource(sourceIndex, loader2) {
    const parser = this;
    const json = this.json;
    const options = this.options;
    if (this.sourceCache[sourceIndex] !== void 0) {
      return this.sourceCache[sourceIndex].then((texture) => texture.clone());
    }
    const sourceDef = json.images[sourceIndex];
    const URL3 = self.URL || self.webkitURL;
    let sourceURI = sourceDef.uri || "";
    let isObjectURL = false;
    if (sourceDef.bufferView !== void 0) {
      sourceURI = parser.getDependency("bufferView", sourceDef.bufferView).then(function(bufferView) {
        isObjectURL = true;
        const blob = new Blob([bufferView], { type: sourceDef.mimeType });
        sourceURI = URL3.createObjectURL(blob);
        return sourceURI;
      });
    } else if (sourceDef.uri === void 0) {
      throw new Error("THREE.GLTFLoader: Image " + sourceIndex + " is missing URI and bufferView");
    }
    const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {
      return new Promise(function(resolve2, reject) {
        let onLoad2 = resolve2;
        if (loader2.isImageBitmapLoader === true) {
          onLoad2 = function(imageBitmap) {
            const texture = new Texture(imageBitmap);
            texture.needsUpdate = true;
            resolve2(texture);
          };
        }
        loader2.load(LoaderUtils.resolveURL(sourceURI2, options.path), onLoad2, void 0, reject);
      });
    }).then(function(texture) {
      if (isObjectURL === true) {
        URL3.revokeObjectURL(sourceURI);
      }
      assignExtrasToUserData(texture, sourceDef);
      texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);
      return texture;
    }).catch(function(error) {
      console.error("THREE.GLTFLoader: Couldn't load texture", sourceURI);
      throw error;
    });
    this.sourceCache[sourceIndex] = promise;
    return promise;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */
  assignTexture(materialParams, mapName, mapDef, colorSpace) {
    const parser = this;
    return this.getDependency("texture", mapDef.index).then(function(texture) {
      if (!texture)
        return null;
      if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {
        texture = texture.clone();
        texture.channel = mapDef.texCoord;
      }
      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
        const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
        if (transform) {
          const gltfReference = parser.associations.get(texture);
          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
          parser.associations.set(texture, gltfReference);
        }
      }
      if (colorSpace !== void 0) {
        texture.colorSpace = colorSpace;
      }
      materialParams[mapName] = texture;
      return texture;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(mesh) {
    const geometry = mesh.geometry;
    let material = mesh.material;
    const useDerivativeTangents = geometry.attributes.tangent === void 0;
    const useVertexColors = geometry.attributes.color !== void 0;
    const useFlatShading = geometry.attributes.normal === void 0;
    if (mesh.isPoints) {
      const cacheKey = "PointsMaterial:" + material.uuid;
      let pointsMaterial = this.cache.get(cacheKey);
      if (!pointsMaterial) {
        pointsMaterial = new PointsMaterial();
        Material.prototype.copy.call(pointsMaterial, material);
        pointsMaterial.color.copy(material.color);
        pointsMaterial.map = material.map;
        pointsMaterial.sizeAttenuation = false;
        this.cache.add(cacheKey, pointsMaterial);
      }
      material = pointsMaterial;
    } else if (mesh.isLine) {
      const cacheKey = "LineBasicMaterial:" + material.uuid;
      let lineMaterial = this.cache.get(cacheKey);
      if (!lineMaterial) {
        lineMaterial = new LineBasicMaterial();
        Material.prototype.copy.call(lineMaterial, material);
        lineMaterial.color.copy(material.color);
        lineMaterial.map = material.map;
        this.cache.add(cacheKey, lineMaterial);
      }
      material = lineMaterial;
    }
    if (useDerivativeTangents || useVertexColors || useFlatShading) {
      let cacheKey = "ClonedMaterial:" + material.uuid + ":";
      if (useDerivativeTangents)
        cacheKey += "derivative-tangents:";
      if (useVertexColors)
        cacheKey += "vertex-colors:";
      if (useFlatShading)
        cacheKey += "flat-shading:";
      let cachedMaterial = this.cache.get(cacheKey);
      if (!cachedMaterial) {
        cachedMaterial = material.clone();
        if (useVertexColors)
          cachedMaterial.vertexColors = true;
        if (useFlatShading)
          cachedMaterial.flatShading = true;
        if (useDerivativeTangents) {
          if (cachedMaterial.normalScale)
            cachedMaterial.normalScale.y *= -1;
          if (cachedMaterial.clearcoatNormalScale)
            cachedMaterial.clearcoatNormalScale.y *= -1;
        }
        this.cache.add(cacheKey, cachedMaterial);
        this.associations.set(cachedMaterial, this.associations.get(material));
      }
      material = cachedMaterial;
    }
    mesh.material = material;
  }
  getMaterialType() {
    return MeshStandardMaterial;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(materialIndex) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    const materialDef = json.materials[materialIndex];
    let materialType;
    const materialParams = {};
    const materialExtensions = materialDef.extensions || {};
    const pending = [];
    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
      materialType = kmuExtension.getMaterialType();
      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
    } else {
      const metallicRoughness = materialDef.pbrMetallicRoughness || {};
      materialParams.color = new Color(1, 1, 1);
      materialParams.opacity = 1;
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, SRGBColorSpace));
      }
      materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;
      materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;
      if (metallicRoughness.metallicRoughnessTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "metalnessMap", metallicRoughness.metallicRoughnessTexture));
        pending.push(parser.assignTexture(materialParams, "roughnessMap", metallicRoughness.metallicRoughnessTexture));
      }
      materialType = this._invokeOne(function(ext) {
        return ext.getMaterialType && ext.getMaterialType(materialIndex);
      });
      pending.push(Promise.all(this._invokeAll(function(ext) {
        return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
      })));
    }
    if (materialDef.doubleSided === true) {
      materialParams.side = DoubleSide;
    }
    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
    if (alphaMode === ALPHA_MODES.BLEND) {
      materialParams.transparent = true;
      materialParams.depthWrite = false;
    } else {
      materialParams.transparent = false;
      if (alphaMode === ALPHA_MODES.MASK) {
        materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;
      }
    }
    if (materialDef.normalTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "normalMap", materialDef.normalTexture));
      materialParams.normalScale = new Vector2(1, 1);
      if (materialDef.normalTexture.scale !== void 0) {
        const scale = materialDef.normalTexture.scale;
        materialParams.normalScale.set(scale, scale);
      }
    }
    if (materialDef.occlusionTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "aoMap", materialDef.occlusionTexture));
      if (materialDef.occlusionTexture.strength !== void 0) {
        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
      }
    }
    if (materialDef.emissiveFactor !== void 0 && materialType !== MeshBasicMaterial) {
      const emissiveFactor = materialDef.emissiveFactor;
      materialParams.emissive = new Color().setRGB(emissiveFactor[0], emissiveFactor[1], emissiveFactor[2], LinearSRGBColorSpace);
    }
    if (materialDef.emissiveTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "emissiveMap", materialDef.emissiveTexture, SRGBColorSpace));
    }
    return Promise.all(pending).then(function() {
      const material = new materialType(materialParams);
      if (materialDef.name)
        material.name = materialDef.name;
      assignExtrasToUserData(material, materialDef);
      parser.associations.set(material, { materials: materialIndex });
      if (materialDef.extensions)
        addUnknownExtensionsToUserData(extensions, material, materialDef);
      return material;
    });
  }
  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(originalName) {
    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || "");
    if (sanitizedName in this.nodeNamesUsed) {
      return sanitizedName + "_" + ++this.nodeNamesUsed[sanitizedName];
    } else {
      this.nodeNamesUsed[sanitizedName] = 0;
      return sanitizedName;
    }
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(primitives) {
    const parser = this;
    const extensions = this.extensions;
    const cache = this.primitiveCache;
    function createDracoPrimitive(primitive) {
      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {
        return addPrimitiveAttributes(geometry, primitive, parser);
      });
    }
    const pending = [];
    for (let i = 0, il = primitives.length; i < il; i++) {
      const primitive = primitives[i];
      const cacheKey = createPrimitiveKey(primitive);
      const cached = cache[cacheKey];
      if (cached) {
        pending.push(cached.promise);
      } else {
        let geometryPromise;
        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
          geometryPromise = createDracoPrimitive(primitive);
        } else {
          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);
        }
        cache[cacheKey] = { primitive, promise: geometryPromise };
        pending.push(geometryPromise);
      }
    }
    return Promise.all(pending);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(meshIndex) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    const meshDef = json.meshes[meshIndex];
    const primitives = meshDef.primitives;
    const pending = [];
    for (let i = 0, il = primitives.length; i < il; i++) {
      const material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", primitives[i].material);
      pending.push(material);
    }
    pending.push(parser.loadGeometries(primitives));
    return Promise.all(pending).then(function(results) {
      const materials = results.slice(0, results.length - 1);
      const geometries = results[results.length - 1];
      const meshes = [];
      for (let i = 0, il = geometries.length; i < il; i++) {
        const geometry = geometries[i];
        const primitive = primitives[i];
        let mesh;
        const material = materials[i];
        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {
          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);
          if (mesh.isSkinnedMesh === true) {
            mesh.normalizeSkinWeights();
          }
          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode2);
          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode2);
          }
        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
          mesh = new LineSegments(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
          mesh = new Line(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
          mesh = new LineLoop(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
          mesh = new Points(geometry, material);
        } else {
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + primitive.mode);
        }
        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
          updateMorphTargets(mesh, meshDef);
        }
        mesh.name = parser.createUniqueName(meshDef.name || "mesh_" + meshIndex);
        assignExtrasToUserData(mesh, meshDef);
        if (primitive.extensions)
          addUnknownExtensionsToUserData(extensions, mesh, primitive);
        parser.assignFinalMaterial(mesh);
        meshes.push(mesh);
      }
      for (let i = 0, il = meshes.length; i < il; i++) {
        parser.associations.set(meshes[i], {
          meshes: meshIndex,
          primitives: i
        });
      }
      if (meshes.length === 1) {
        if (meshDef.extensions)
          addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);
        return meshes[0];
      }
      const group = new Group();
      if (meshDef.extensions)
        addUnknownExtensionsToUserData(extensions, group, meshDef);
      parser.associations.set(group, { meshes: meshIndex });
      for (let i = 0, il = meshes.length; i < il; i++) {
        group.add(meshes[i]);
      }
      return group;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(cameraIndex) {
    let camera;
    const cameraDef = this.json.cameras[cameraIndex];
    const params = cameraDef[cameraDef.type];
    if (!params) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    if (cameraDef.type === "perspective") {
      camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
    } else if (cameraDef.type === "orthographic") {
      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
    }
    if (cameraDef.name)
      camera.name = this.createUniqueName(cameraDef.name);
    assignExtrasToUserData(camera, cameraDef);
    return Promise.resolve(camera);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(skinIndex) {
    const skinDef = this.json.skins[skinIndex];
    const pending = [];
    for (let i = 0, il = skinDef.joints.length; i < il; i++) {
      pending.push(this._loadNodeShallow(skinDef.joints[i]));
    }
    if (skinDef.inverseBindMatrices !== void 0) {
      pending.push(this.getDependency("accessor", skinDef.inverseBindMatrices));
    } else {
      pending.push(null);
    }
    return Promise.all(pending).then(function(results) {
      const inverseBindMatrices = results.pop();
      const jointNodes = results;
      const bones = [];
      const boneInverses = [];
      for (let i = 0, il = jointNodes.length; i < il; i++) {
        const jointNode = jointNodes[i];
        if (jointNode) {
          bones.push(jointNode);
          const mat = new Matrix4();
          if (inverseBindMatrices !== null) {
            mat.fromArray(inverseBindMatrices.array, i * 16);
          }
          boneInverses.push(mat);
        } else {
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinDef.joints[i]);
        }
      }
      return new Skeleton(bones, boneInverses);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(animationIndex) {
    const json = this.json;
    const parser = this;
    const animationDef = json.animations[animationIndex];
    const animationName = animationDef.name ? animationDef.name : "animation_" + animationIndex;
    const pendingNodes = [];
    const pendingInputAccessors = [];
    const pendingOutputAccessors = [];
    const pendingSamplers = [];
    const pendingTargets = [];
    let i = 0;
    let il = animationDef.channels.length;
    for (i = 0, il = animationDef.channels.length; i < il; i++) {
      const channel = animationDef.channels[i];
      const sampler = animationDef.samplers[channel.sampler];
      const target = channel.target;
      const name = target.node;
      const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;
      const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;
      if (target.node === void 0)
        continue;
      pendingNodes.push(this.getDependency("node", name));
      pendingInputAccessors.push(this.getDependency("accessor", input));
      pendingOutputAccessors.push(this.getDependency("accessor", output));
      pendingSamplers.push(sampler);
      pendingTargets.push(target);
    }
    return Promise.all([
      Promise.all(pendingNodes),
      Promise.all(pendingInputAccessors),
      Promise.all(pendingOutputAccessors),
      Promise.all(pendingSamplers),
      Promise.all(pendingTargets)
    ]).then(function(dependencies) {
      const nodes = dependencies[0];
      const inputAccessors = dependencies[1];
      const outputAccessors = dependencies[2];
      const samplers = dependencies[3];
      const targets = dependencies[4];
      const tracks = [];
      for (i = 0, il = nodes.length; i < il; i++) {
        const node = nodes[i];
        const inputAccessor = inputAccessors[i];
        const outputAccessor = outputAccessors[i];
        const sampler = samplers[i];
        const target = targets[i];
        if (node === void 0)
          continue;
        if (node.updateMatrix) {
          node.updateMatrix();
        }
        const createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target);
        if (createdTracks) {
          for (let k = 0; k < createdTracks.length; k++) {
            tracks.push(createdTracks[k]);
          }
        }
      }
      return new AnimationClip(animationName, void 0, tracks);
    });
  }
  createNodeMesh(nodeIndex) {
    const json = this.json;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    if (nodeDef.mesh === void 0)
      return null;
    return parser.getDependency("mesh", nodeDef.mesh).then(function(mesh) {
      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);
      if (nodeDef.weights !== void 0) {
        node.traverse(function(o) {
          if (!o.isMesh)
            return;
          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {
            o.morphTargetInfluences[i] = nodeDef.weights[i];
          }
        });
      }
      return node;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(nodeIndex) {
    const json = this.json;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    const nodePending = parser._loadNodeShallow(nodeIndex);
    const childPending = [];
    const childrenDef = nodeDef.children || [];
    for (let i = 0, il = childrenDef.length; i < il; i++) {
      childPending.push(parser.getDependency("node", childrenDef[i]));
    }
    const skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency("skin", nodeDef.skin);
    return Promise.all([
      nodePending,
      Promise.all(childPending),
      skeletonPending
    ]).then(function(results) {
      const node = results[0];
      const children = results[1];
      const skeleton = results[2];
      if (skeleton !== null) {
        node.traverse(function(mesh) {
          if (!mesh.isSkinnedMesh)
            return;
          mesh.bind(skeleton, _identityMatrix);
        });
      }
      for (let i = 0, il = children.length; i < il; i++) {
        node.add(children[i]);
      }
      return node;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(nodeIndex) {
    const json = this.json;
    const extensions = this.extensions;
    const parser = this;
    if (this.nodeCache[nodeIndex] !== void 0) {
      return this.nodeCache[nodeIndex];
    }
    const nodeDef = json.nodes[nodeIndex];
    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : "";
    const pending = [];
    const meshPromise = parser._invokeOne(function(ext) {
      return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);
    });
    if (meshPromise) {
      pending.push(meshPromise);
    }
    if (nodeDef.camera !== void 0) {
      pending.push(parser.getDependency("camera", nodeDef.camera).then(function(camera) {
        return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);
      }));
    }
    parser._invokeAll(function(ext) {
      return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
    }).forEach(function(promise) {
      pending.push(promise);
    });
    this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {
      let node;
      if (nodeDef.isBone === true) {
        node = new Bone();
      } else if (objects.length > 1) {
        node = new Group();
      } else if (objects.length === 1) {
        node = objects[0];
      } else {
        node = new Object3D();
      }
      if (node !== objects[0]) {
        for (let i = 0, il = objects.length; i < il; i++) {
          node.add(objects[i]);
        }
      }
      if (nodeDef.name) {
        node.userData.name = nodeDef.name;
        node.name = nodeName;
      }
      assignExtrasToUserData(node, nodeDef);
      if (nodeDef.extensions)
        addUnknownExtensionsToUserData(extensions, node, nodeDef);
      if (nodeDef.matrix !== void 0) {
        const matrix = new Matrix4();
        matrix.fromArray(nodeDef.matrix);
        node.applyMatrix4(matrix);
      } else {
        if (nodeDef.translation !== void 0) {
          node.position.fromArray(nodeDef.translation);
        }
        if (nodeDef.rotation !== void 0) {
          node.quaternion.fromArray(nodeDef.rotation);
        }
        if (nodeDef.scale !== void 0) {
          node.scale.fromArray(nodeDef.scale);
        }
      }
      if (!parser.associations.has(node)) {
        parser.associations.set(node, {});
      }
      parser.associations.get(node).nodes = nodeIndex;
      return node;
    });
    return this.nodeCache[nodeIndex];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(sceneIndex) {
    const extensions = this.extensions;
    const sceneDef = this.json.scenes[sceneIndex];
    const parser = this;
    const scene = new Group();
    if (sceneDef.name)
      scene.name = parser.createUniqueName(sceneDef.name);
    assignExtrasToUserData(scene, sceneDef);
    if (sceneDef.extensions)
      addUnknownExtensionsToUserData(extensions, scene, sceneDef);
    const nodeIds = sceneDef.nodes || [];
    const pending = [];
    for (let i = 0, il = nodeIds.length; i < il; i++) {
      pending.push(parser.getDependency("node", nodeIds[i]));
    }
    return Promise.all(pending).then(function(nodes) {
      for (let i = 0, il = nodes.length; i < il; i++) {
        scene.add(nodes[i]);
      }
      const reduceAssociations = (node) => {
        const reducedAssociations = /* @__PURE__ */ new Map();
        for (const [key, value] of parser.associations) {
          if (key instanceof Material || key instanceof Texture) {
            reducedAssociations.set(key, value);
          }
        }
        node.traverse((node2) => {
          const mappings = parser.associations.get(node2);
          if (mappings != null) {
            reducedAssociations.set(node2, mappings);
          }
        });
        return reducedAssociations;
      };
      parser.associations = reduceAssociations(scene);
      return scene;
    });
  }
  _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {
    const tracks = [];
    const targetName = node.name ? node.name : node.uuid;
    const targetNames = [];
    if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
      node.traverse(function(object) {
        if (object.morphTargetInfluences) {
          targetNames.push(object.name ? object.name : object.uuid);
        }
      });
    } else {
      targetNames.push(targetName);
    }
    let TypedKeyframeTrack;
    switch (PATH_PROPERTIES[target.path]) {
      case PATH_PROPERTIES.weights:
        TypedKeyframeTrack = NumberKeyframeTrack;
        break;
      case PATH_PROPERTIES.rotation:
        TypedKeyframeTrack = QuaternionKeyframeTrack;
        break;
      case PATH_PROPERTIES.position:
      case PATH_PROPERTIES.scale:
        TypedKeyframeTrack = VectorKeyframeTrack;
        break;
      default:
        switch (outputAccessor.itemSize) {
          case 1:
            TypedKeyframeTrack = NumberKeyframeTrack;
            break;
          case 2:
          case 3:
          default:
            TypedKeyframeTrack = VectorKeyframeTrack;
            break;
        }
        break;
    }
    const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;
    const outputArray = this._getArrayFromAccessor(outputAccessor);
    for (let j = 0, jl = targetNames.length; j < jl; j++) {
      const track = new TypedKeyframeTrack(
        targetNames[j] + "." + PATH_PROPERTIES[target.path],
        inputAccessor.array,
        outputArray,
        interpolation
      );
      if (sampler.interpolation === "CUBICSPLINE") {
        this._createCubicSplineTrackInterpolant(track);
      }
      tracks.push(track);
    }
    return tracks;
  }
  _getArrayFromAccessor(accessor) {
    let outputArray = accessor.array;
    if (accessor.normalized) {
      const scale = getNormalizedComponentScale(outputArray.constructor);
      const scaled = new Float32Array(outputArray.length);
      for (let j = 0, jl = outputArray.length; j < jl; j++) {
        scaled[j] = outputArray[j] * scale;
      }
      outputArray = scaled;
    }
    return outputArray;
  }
  _createCubicSplineTrackInterpolant(track) {
    track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
      const interpolantType = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;
      return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);
    };
    track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
  }
};
function computeBounds(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const box2 = new Box3();
  if (attributes.POSITION !== void 0) {
    const accessor = parser.json.accessors[attributes.POSITION];
    const min = accessor.min;
    const max = accessor.max;
    if (min !== void 0 && max !== void 0) {
      box2.set(
        new Vector32(min[0], min[1], min[2]),
        new Vector32(max[0], max[1], max[2])
      );
      if (accessor.normalized) {
        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
        box2.min.multiplyScalar(boxScale);
        box2.max.multiplyScalar(boxScale);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else {
    return;
  }
  const targets = primitiveDef.targets;
  if (targets !== void 0) {
    const maxDisplacement = new Vector32();
    const vector = new Vector32();
    for (let i = 0, il = targets.length; i < il; i++) {
      const target = targets[i];
      if (target.POSITION !== void 0) {
        const accessor = parser.json.accessors[target.POSITION];
        const min = accessor.min;
        const max = accessor.max;
        if (min !== void 0 && max !== void 0) {
          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));
          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));
          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));
          if (accessor.normalized) {
            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
            vector.multiplyScalar(boxScale);
          }
          maxDisplacement.max(vector);
        } else {
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        }
      }
    }
    box2.expandByVector(maxDisplacement);
  }
  geometry.boundingBox = box2;
  const sphere = new Sphere();
  box2.getCenter(sphere.center);
  sphere.radius = box2.min.distanceTo(box2.max) / 2;
  geometry.boundingSphere = sphere;
}
function addPrimitiveAttributes(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const pending = [];
  function assignAttributeAccessor(accessorIndex, attributeName) {
    return parser.getDependency("accessor", accessorIndex).then(function(accessor) {
      geometry.setAttribute(attributeName, accessor);
    });
  }
  for (const gltfAttributeName in attributes) {
    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
    if (threeAttributeName in geometry.attributes)
      continue;
    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
  }
  if (primitiveDef.indices !== void 0 && !geometry.index) {
    const accessor = parser.getDependency("accessor", primitiveDef.indices).then(function(accessor2) {
      geometry.setIndex(accessor2);
    });
    pending.push(accessor);
  }
  if (ColorManagement.workingColorSpace !== LinearSRGBColorSpace && "COLOR_0" in attributes) {
    console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${ColorManagement.workingColorSpace}" not supported.`);
  }
  assignExtrasToUserData(geometry, primitiveDef);
  computeBounds(geometry, primitiveDef, parser);
  return Promise.all(pending).then(function() {
    return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
  });
}

// node_modules/three/examples/jsm/libs/meshopt_decoder.module.js
var MeshoptDecoder = function() {
  "use strict";
  var wasm_base = "b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q;iekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq:P8Yqdbk;3sezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhDcbhqinaqae9pmeaDaeaq9RaqaDfae6Egkcsfgocl4cifcd4hxdndndndnaoc9WGgmTmbcbhPcehsawcjdfhzalhHinaraH9Rax6midnaraHaxfgl9RcK6mbczhoinawcj;cbfaogifgoc9WfhOdndndndndnaHaic9WfgAco4fRbbaAci4coG4ciGPlbedibkaO9cb83ibaOcwf9cb83ibxikaOalRblalRbbgAco4gCaCciSgCE86bbaocGfalclfaCfgORbbaAcl4ciGgCaCciSgCE86bbaocVfaOaCfgORbbaAcd4ciGgCaCciSgCE86bbaoc7faOaCfgORbbaAciGgAaAciSgAE86bbaoctfaOaAfgARbbalRbegOco4gCaCciSgCE86bbaoc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc93faAaCfgARbbaOciGgOaOciSgOE86bbaoc94faAaOfgARbbalRbdgOco4gCaCciSgCE86bbaoc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc97faAaCfgARbbaOciGgOaOciSgOE86bbaoc98faAaOfgORbbalRbiglco4gAaAciSgAE86bbaoc99faOaAfgORbbalcl4ciGgAaAciSgAE86bbaoc9:faOaAfgORbbalcd4ciGgAaAciSgAE86bbaocufaOaAfgoRbbalciGglalciSglE86bbaoalfhlxdkaOalRbwalRbbgAcl4gCaCcsSgCE86bbaocGfalcwfaCfgORbbaAcsGgAaAcsSgAE86bbaocVfaOaAfgORbbalRbegAcl4gCaCcsSgCE86bbaoc7faOaCfgORbbaAcsGgAaAcsSgAE86bbaoctfaOaAfgORbbalRbdgAcl4gCaCcsSgCE86bbaoc91faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc4faOaAfgORbbalRbigAcl4gCaCcsSgCE86bbaoc93faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc94faOaAfgORbbalRblgAcl4gCaCcsSgCE86bbaoc95faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc96faOaAfgORbbalRbvgAcl4gCaCcsSgCE86bbaoc97faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc98faOaAfgORbbalRbogAcl4gCaCcsSgCE86bbaoc99faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc9:faOaAfgORbbalRbrglcl4gAaAcsSgAE86bbaocufaOaAfgoRbbalcsGglalcsSglE86bbaoalfhlxekaOal8Pbb83bbaOcwfalcwf8Pbb83bbalczfhlkdnaiam9pmbaiczfhoaral9RcL0mekkaiam6mialTmidnakTmbawaPfRbbhOcbhoazhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkkazcefhzaPcefgPad6hsalhHaPad9hmexvkkcbhlasceGmdxikalaxad2fhCdnakTmbcbhHcehsawcjdfhminaral9Rax6mialTmdalaxfhlawaHfRbbhOcbhoamhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkamcefhmaHcefgHad6hsaHad9hmbkaChlxikcbhocehsinaral9Rax6mdalTmealaxfhlaocefgoad6hsadao9hmbkaChlxdkcbhlasceGTmekc9:hoxikabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqalmbkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;ebf8Kjjjjbaok;yzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;siliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabavcefciGaiVcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:Ohkxekcjjjj94hkkabavcdfciGaiVcetfak87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:Ohqxekcjjjj94hqkabavcufciGaiVcetfaq87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohqxekcjjjj94hqkabavciGaiVcetfaq87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2geTmbinababydbgdcwtcw91:Yadce91cjjj;8ifcjjj98G::NUdbabclfhbaecufgembkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaiczfhiaeczfheadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklz9Kbb";
  var wasm_simd = "b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q;Aekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq;t9tqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk;h8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhwcbhDinaDae9pmeawaeaD9RaDawfae6Egqcsfgoc9WGgkci2hxakcethmaocl4cifcd4hPabaDad2fhscbhzdnincehHalhOcbhAdninaraO9RaP6miavcj;cbfaAak2fhCaOaPfhlcbhidnakc;ab6mbaral9Rc;Gb6mbcbhoinaCaofhidndndndndnaOaoco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklbalczfhlkdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklzalczfhlkdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklaalczfhlkdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalclfaYpQbfaXc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalcwfaYpQbfaXc:q:yjjbfRbbfhlxekaialpbbbpkl8Walczfhlkaoc;abfhiaocjefak0meaihoaral9Rc;Fb0mbkkdndnaiak9pmbaici4hoinaral9RcK6mdaCaifhXdndndndndnaOaico4fRbbaocoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpklbxikaXalpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaXalpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaXalpbbbpklbalczfhlkaocdfhoaiczfgiak6mbkkalTmbaAci6hHalhOaAcefgohAaoclSmdxekkcbhlaHceGmdkdnakTmbavcjdfazfhiavazfpbdbhYcbhXinaiavcj;cbfaXfgopblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLaoakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEaoamfpblbg3cep9Ta3aQp9op9Hp9rg3aoaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfhiaXczfgXak6mbkkazclfgzad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfhDc9:hoalmexikkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk;uzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:EPliuo97eue978Jjjjjbca9Rhidndnadcl9hmbdnaec98GglTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalae9pmeaiaeciGgvcdtgdVcbczad9R;8kbaiabalcdtfglad;8qbbdnavTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkalaiad;8qbbskdnaec98GgxTmbcbhvabhdinadczfglalpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oawaopmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgvax6mbkkaxae9pmbaiaeciGgvcitgdfcbcaad9R;8kbaiabaxcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oawaopmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalae9pmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbhdabheinaeaepbbbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepkbbaeczfheadclfgdav6mbkkdnaval9pmbaialciGgdcdtgeVcbc;abae9R;8kbaiabavcdtfgvae;8qbbdnadTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepklbkavaiae;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz9Tbb";
  var detector = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]);
  var wasmpack = new Uint8Array([32, 0, 65, 2, 1, 106, 34, 33, 3, 128, 11, 4, 13, 64, 6, 253, 10, 7, 15, 116, 127, 5, 8, 12, 40, 16, 19, 54, 20, 9, 27, 255, 113, 17, 42, 67, 24, 23, 146, 148, 18, 14, 22, 45, 70, 69, 56, 114, 101, 21, 25, 63, 75, 136, 108, 28, 118, 29, 73, 115]);
  if (typeof WebAssembly !== "object") {
    return {
      supported: false
    };
  }
  var wasm = WebAssembly.validate(detector) ? wasm_simd : wasm_base;
  var instance;
  var ready = WebAssembly.instantiate(unpack(wasm), {}).then(function(result) {
    instance = result.instance;
    instance.exports.__wasm_call_ctors();
  });
  function unpack(data) {
    var result = new Uint8Array(data.length);
    for (var i = 0; i < data.length; ++i) {
      var ch = data.charCodeAt(i);
      result[i] = ch > 96 ? ch - 97 : ch > 64 ? ch - 39 : ch + 4;
    }
    var write = 0;
    for (var i = 0; i < data.length; ++i) {
      result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];
    }
    return result.buffer.slice(0, write);
  }
  function decode(fun, target, count, size, source, filter) {
    var sbrk = instance.exports.sbrk;
    var count4 = count + 3 & ~3;
    var tp = sbrk(count4 * size);
    var sp = sbrk(source.length);
    var heap = new Uint8Array(instance.exports.memory.buffer);
    heap.set(source, sp);
    var res = fun(tp, count, size, sp, source.length);
    if (res == 0 && filter) {
      filter(tp, count4, size);
    }
    target.set(heap.subarray(tp, tp + count * size));
    sbrk(tp - sbrk(0));
    if (res != 0) {
      throw new Error("Malformed buffer data: " + res);
    }
  }
  var filters = {
    NONE: "",
    OCTAHEDRAL: "meshopt_decodeFilterOct",
    QUATERNION: "meshopt_decodeFilterQuat",
    EXPONENTIAL: "meshopt_decodeFilterExp"
  };
  var decoders = {
    ATTRIBUTES: "meshopt_decodeVertexBuffer",
    TRIANGLES: "meshopt_decodeIndexBuffer",
    INDICES: "meshopt_decodeIndexSequence"
  };
  var workers = [];
  var requestId = 0;
  function createWorker(url) {
    var worker = {
      object: new Worker(url),
      pending: 0,
      requests: {}
    };
    worker.object.onmessage = function(event) {
      var data = event.data;
      worker.pending -= data.count;
      worker.requests[data.id][data.action](data.value);
      delete worker.requests[data.id];
    };
    return worker;
  }
  function initWorkers(count) {
    var source = "var instance; var ready = WebAssembly.instantiate(new Uint8Array([" + new Uint8Array(unpack(wasm)) + "]), {}).then(function(result) { instance = result.instance; instance.exports.__wasm_call_ctors(); });self.onmessage = workerProcess;" + decode.toString() + workerProcess.toString();
    var blob = new Blob([source], { type: "text/javascript" });
    var url = URL.createObjectURL(blob);
    for (var i = 0; i < count; ++i) {
      workers[i] = createWorker(url);
    }
    URL.revokeObjectURL(url);
  }
  function decodeWorker(count, size, source, mode, filter) {
    var worker = workers[0];
    for (var i = 1; i < workers.length; ++i) {
      if (workers[i].pending < worker.pending) {
        worker = workers[i];
      }
    }
    return new Promise(function(resolve2, reject) {
      var data = new Uint8Array(source);
      var id = requestId++;
      worker.pending += count;
      worker.requests[id] = { resolve: resolve2, reject };
      worker.object.postMessage({ id, count, size, source: data, mode, filter }, [data.buffer]);
    });
  }
  function workerProcess(event) {
    ready.then(function() {
      var data = event.data;
      try {
        var target = new Uint8Array(data.count * data.size);
        decode(instance.exports[data.mode], target, data.count, data.size, data.source, instance.exports[data.filter]);
        self.postMessage({ id: data.id, count: data.count, action: "resolve", value: target }, [target.buffer]);
      } catch (error) {
        self.postMessage({ id: data.id, count: data.count, action: "reject", value: error });
      }
    });
  }
  return {
    ready,
    supported: true,
    useWorkers: function(count) {
      initWorkers(count);
    },
    decodeVertexBuffer: function(target, count, size, source, filter) {
      decode(instance.exports.meshopt_decodeVertexBuffer, target, count, size, source, instance.exports[filters[filter]]);
    },
    decodeIndexBuffer: function(target, count, size, source) {
      decode(instance.exports.meshopt_decodeIndexBuffer, target, count, size, source);
    },
    decodeIndexSequence: function(target, count, size, source) {
      decode(instance.exports.meshopt_decodeIndexSequence, target, count, size, source);
    },
    decodeGltfBuffer: function(target, count, size, source, mode, filter) {
      decode(instance.exports[decoders[mode]], target, count, size, source, instance.exports[filters[filter]]);
    },
    decodeGltfBufferAsync: function(count, size, source, mode, filter) {
      if (workers.length > 0) {
        return decodeWorker(count, size, source, decoders[mode], filters[filter]);
      }
      return ready.then(function() {
        var target = new Uint8Array(count * size);
        decode(instance.exports[decoders[mode]], target, count, size, source, instance.exports[filters[filter]]);
        return target;
      });
    }
  };
}();

// node_modules/three/examples/jsm/loaders/DRACOLoader.js
var _taskCache = /* @__PURE__ */ new WeakMap();
var DRACOLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.decoderPath = "";
    this.decoderConfig = {};
    this.decoderBinary = null;
    this.decoderPending = null;
    this.workerLimit = 4;
    this.workerPool = [];
    this.workerNextTaskID = 1;
    this.workerSourceURL = "";
    this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    };
    this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(path) {
    this.decoderPath = path;
    return this;
  }
  setDecoderConfig(config) {
    this.decoderConfig = config;
    return this;
  }
  setWorkerLimit(workerLimit) {
    this.workerLimit = workerLimit;
    return this;
  }
  load(url, onLoad2, onProgress, onError2) {
    const loader2 = new FileLoader(this.manager);
    loader2.setPath(this.path);
    loader2.setResponseType("arraybuffer");
    loader2.setRequestHeader(this.requestHeader);
    loader2.setWithCredentials(this.withCredentials);
    loader2.load(url, (buffer2) => {
      this.parse(buffer2, onLoad2, onError2);
    }, onProgress, onError2);
  }
  parse(buffer2, onLoad2, onError2 = () => {
  }) {
    this.decodeDracoFile(buffer2, onLoad2, null, null, SRGBColorSpace, onError2).catch(onError2);
  }
  decodeDracoFile(buffer2, callback, attributeIDs, attributeTypes, vertexColorSpace = LinearSRGBColorSpace, onError2 = () => {
  }) {
    const taskConfig = {
      attributeIDs: attributeIDs || this.defaultAttributeIDs,
      attributeTypes: attributeTypes || this.defaultAttributeTypes,
      useUniqueIDs: !!attributeIDs,
      vertexColorSpace
    };
    return this.decodeGeometry(buffer2, taskConfig).then(callback).catch(onError2);
  }
  decodeGeometry(buffer2, taskConfig) {
    const taskKey = JSON.stringify(taskConfig);
    if (_taskCache.has(buffer2)) {
      const cachedTask = _taskCache.get(buffer2);
      if (cachedTask.key === taskKey) {
        return cachedTask.promise;
      } else if (buffer2.byteLength === 0) {
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
      }
    }
    let worker;
    const taskID = this.workerNextTaskID++;
    const taskCost = buffer2.byteLength;
    const geometryPending = this._getWorker(taskID, taskCost).then((_worker) => {
      worker = _worker;
      return new Promise((resolve2, reject) => {
        worker._callbacks[taskID] = { resolve: resolve2, reject };
        worker.postMessage({ type: "decode", id: taskID, taskConfig, buffer: buffer2 }, [buffer2]);
      });
    }).then((message) => this._createGeometry(message.geometry));
    geometryPending.catch(() => true).then(() => {
      if (worker && taskID) {
        this._releaseTask(worker, taskID);
      }
    });
    _taskCache.set(buffer2, {
      key: taskKey,
      promise: geometryPending
    });
    return geometryPending;
  }
  _createGeometry(geometryData) {
    const geometry = new BufferGeometry();
    if (geometryData.index) {
      geometry.setIndex(new BufferAttribute2(geometryData.index.array, 1));
    }
    for (let i = 0; i < geometryData.attributes.length; i++) {
      const result = geometryData.attributes[i];
      const name = result.name;
      const array = result.array;
      const itemSize = result.itemSize;
      const attribute = new BufferAttribute2(array, itemSize);
      if (name === "color") {
        this._assignVertexColorSpace(attribute, result.vertexColorSpace);
        attribute.normalized = array instanceof Float32Array === false;
      }
      geometry.setAttribute(name, attribute);
    }
    return geometry;
  }
  _assignVertexColorSpace(attribute, inputColorSpace) {
    if (inputColorSpace !== SRGBColorSpace)
      return;
    const _color2 = new Color();
    for (let i = 0, il = attribute.count; i < il; i++) {
      _color2.fromBufferAttribute(attribute, i);
      ColorManagement.toWorkingColorSpace(_color2, SRGBColorSpace);
      attribute.setXYZ(i, _color2.r, _color2.g, _color2.b);
    }
  }
  _loadLibrary(url, responseType) {
    const loader2 = new FileLoader(this.manager);
    loader2.setPath(this.decoderPath);
    loader2.setResponseType(responseType);
    loader2.setWithCredentials(this.withCredentials);
    return new Promise((resolve2, reject) => {
      loader2.load(url, resolve2, void 0, reject);
    });
  }
  preload() {
    this._initDecoder();
    return this;
  }
  _initDecoder() {
    if (this.decoderPending)
      return this.decoderPending;
    const useJS = typeof WebAssembly !== "object" || this.decoderConfig.type === "js";
    const librariesPending = [];
    if (useJS) {
      librariesPending.push(this._loadLibrary("draco_decoder.js", "text"));
    } else {
      librariesPending.push(this._loadLibrary("draco_wasm_wrapper.js", "text"));
      librariesPending.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"));
    }
    this.decoderPending = Promise.all(librariesPending).then((libraries) => {
      const jsContent = libraries[0];
      if (!useJS) {
        this.decoderConfig.wasmBinary = libraries[1];
      }
      const fn2 = DRACOWorker.toString();
      const body = [
        "/* draco decoder */",
        jsContent,
        "",
        "/* worker */",
        fn2.substring(fn2.indexOf("{") + 1, fn2.lastIndexOf("}"))
      ].join("\n");
      this.workerSourceURL = URL.createObjectURL(new Blob([body]));
    });
    return this.decoderPending;
  }
  _getWorker(taskID, taskCost) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const worker2 = new Worker(this.workerSourceURL);
        worker2._callbacks = {};
        worker2._taskCosts = {};
        worker2._taskLoad = 0;
        worker2.postMessage({ type: "init", decoderConfig: this.decoderConfig });
        worker2.onmessage = function(e) {
          const message = e.data;
          switch (message.type) {
            case "decode":
              worker2._callbacks[message.id].resolve(message);
              break;
            case "error":
              worker2._callbacks[message.id].reject(message);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + message.type + '"');
          }
        };
        this.workerPool.push(worker2);
      } else {
        this.workerPool.sort(function(a, b) {
          return a._taskLoad > b._taskLoad ? -1 : 1;
        });
      }
      const worker = this.workerPool[this.workerPool.length - 1];
      worker._taskCosts[taskID] = taskCost;
      worker._taskLoad += taskCost;
      return worker;
    });
  }
  _releaseTask(worker, taskID) {
    worker._taskLoad -= worker._taskCosts[taskID];
    delete worker._callbacks[taskID];
    delete worker._taskCosts[taskID];
  }
  debug() {
    console.log("Task load: ", this.workerPool.map((worker) => worker._taskLoad));
  }
  dispose() {
    for (let i = 0; i < this.workerPool.length; ++i) {
      this.workerPool[i].terminate();
    }
    this.workerPool.length = 0;
    if (this.workerSourceURL !== "") {
      URL.revokeObjectURL(this.workerSourceURL);
    }
    return this;
  }
};
function DRACOWorker() {
  let decoderConfig;
  let decoderPending;
  onmessage = function(e) {
    const message = e.data;
    switch (message.type) {
      case "init":
        decoderConfig = message.decoderConfig;
        decoderPending = new Promise(function(resolve2) {
          decoderConfig.onModuleLoaded = function(draco) {
            resolve2({ draco });
          };
          DracoDecoderModule(decoderConfig);
        });
        break;
      case "decode":
        const buffer2 = message.buffer;
        const taskConfig = message.taskConfig;
        decoderPending.then((module) => {
          const draco = module.draco;
          const decoder = new draco.Decoder();
          try {
            const geometry = decodeGeometry(draco, decoder, new Int8Array(buffer2), taskConfig);
            const buffers = geometry.attributes.map((attr) => attr.array.buffer);
            if (geometry.index)
              buffers.push(geometry.index.array.buffer);
            self.postMessage({ type: "decode", id: message.id, geometry }, buffers);
          } catch (error) {
            console.error(error);
            self.postMessage({ type: "error", id: message.id, error: error.message });
          } finally {
            draco.destroy(decoder);
          }
        });
        break;
    }
  };
  function decodeGeometry(draco, decoder, array, taskConfig) {
    const attributeIDs = taskConfig.attributeIDs;
    const attributeTypes = taskConfig.attributeTypes;
    let dracoGeometry;
    let decodingStatus;
    const geometryType = decoder.GetEncodedGeometryType(array);
    if (geometryType === draco.TRIANGULAR_MESH) {
      dracoGeometry = new draco.Mesh();
      decodingStatus = decoder.DecodeArrayToMesh(array, array.byteLength, dracoGeometry);
    } else if (geometryType === draco.POINT_CLOUD) {
      dracoGeometry = new draco.PointCloud();
      decodingStatus = decoder.DecodeArrayToPointCloud(array, array.byteLength, dracoGeometry);
    } else {
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    }
    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {
      throw new Error("THREE.DRACOLoader: Decoding failed: " + decodingStatus.error_msg());
    }
    const geometry = { index: null, attributes: [] };
    for (const attributeName in attributeIDs) {
      const attributeType = self[attributeTypes[attributeName]];
      let attribute;
      let attributeID;
      if (taskConfig.useUniqueIDs) {
        attributeID = attributeIDs[attributeName];
        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);
      } else {
        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);
        if (attributeID === -1)
          continue;
        attribute = decoder.GetAttribute(dracoGeometry, attributeID);
      }
      const attributeResult = decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute);
      if (attributeName === "color") {
        attributeResult.vertexColorSpace = taskConfig.vertexColorSpace;
      }
      geometry.attributes.push(attributeResult);
    }
    if (geometryType === draco.TRIANGULAR_MESH) {
      geometry.index = decodeIndex(draco, decoder, dracoGeometry);
    }
    draco.destroy(dracoGeometry);
    return geometry;
  }
  function decodeIndex(draco, decoder, dracoGeometry) {
    const numFaces = dracoGeometry.num_faces();
    const numIndices = numFaces * 3;
    const byteLength = numIndices * 4;
    const ptr = draco._malloc(byteLength);
    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();
    draco._free(ptr);
    return { array: index, itemSize: 1 };
  }
  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {
    const numComponents = attribute.num_components();
    const numPoints = dracoGeometry.num_points();
    const numValues = numPoints * numComponents;
    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
    const dataType = getDracoDataType(draco, attributeType);
    const ptr = draco._malloc(byteLength);
    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);
    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();
    draco._free(ptr);
    return {
      name: attributeName,
      array,
      itemSize: numComponents
    };
  }
  function getDracoDataType(draco, attributeType) {
    switch (attributeType) {
      case Float32Array:
        return draco.DT_FLOAT32;
      case Int8Array:
        return draco.DT_INT8;
      case Int16Array:
        return draco.DT_INT16;
      case Int32Array:
        return draco.DT_INT32;
      case Uint8Array:
        return draco.DT_UINT8;
      case Uint16Array:
        return draco.DT_UINT16;
      case Uint32Array:
        return draco.DT_UINT32;
    }
  }
}

// node_modules/three/examples/jsm/utils/WorkerPool.js
var WorkerPool = class {
  constructor(pool = 4) {
    this.pool = pool;
    this.queue = [];
    this.workers = [];
    this.workersResolve = [];
    this.workerStatus = 0;
  }
  _initWorker(workerId) {
    if (!this.workers[workerId]) {
      const worker = this.workerCreator();
      worker.addEventListener("message", this._onMessage.bind(this, workerId));
      this.workers[workerId] = worker;
    }
  }
  _getIdleWorker() {
    for (let i = 0; i < this.pool; i++)
      if (!(this.workerStatus & 1 << i))
        return i;
    return -1;
  }
  _onMessage(workerId, msg) {
    const resolve2 = this.workersResolve[workerId];
    resolve2 && resolve2(msg);
    if (this.queue.length) {
      const { resolve: resolve3, msg: msg2, transfer } = this.queue.shift();
      this.workersResolve[workerId] = resolve3;
      this.workers[workerId].postMessage(msg2, transfer);
    } else {
      this.workerStatus ^= 1 << workerId;
    }
  }
  setWorkerCreator(workerCreator) {
    this.workerCreator = workerCreator;
  }
  setWorkerLimit(pool) {
    this.pool = pool;
  }
  postMessage(msg, transfer) {
    return new Promise((resolve2) => {
      const workerId = this._getIdleWorker();
      if (workerId !== -1) {
        this._initWorker(workerId);
        this.workerStatus |= 1 << workerId;
        this.workersResolve[workerId] = resolve2;
        this.workers[workerId].postMessage(msg, transfer);
      } else {
        this.queue.push({ resolve: resolve2, msg, transfer });
      }
    });
  }
  dispose() {
    this.workers.forEach((worker) => worker.terminate());
    this.workersResolve.length = 0;
    this.workers.length = 0;
    this.queue.length = 0;
    this.workerStatus = 0;
  }
};

// node_modules/three/examples/jsm/libs/ktx-parse.module.js
var t = 0;
var n = 2;
var g = 1;
var u = 2;
var T2 = 0;
var C2 = 1;
var R = 10;
var it = 0;
var ct = 9;
var yt = 15;
var xt = 16;
var wt = 22;
var Ft = 37;
var Ct = 43;
var te = 76;
var ae = 83;
var ge = 97;
var ue = 100;
var we = 103;
var Ae = 109;
var In = 165;
var Sn = 166;
var pi = 1000066e3;
var Ii = class {
  constructor() {
    this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{ vendorId: 0, descriptorType: 0, descriptorBlockSize: 0, versionNumber: 2, colorModel: 0, colorPrimaries: 1, transferFunction: 2, flags: 0, texelBlockDimension: [0, 0, 0, 0], bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0], samples: [] }], this.keyValue = {}, this.globalData = null;
  }
};
var Si = class {
  constructor(t2, e, n2, i) {
    this._dataView = void 0, this._littleEndian = void 0, this._offset = void 0, this._dataView = new DataView(t2.buffer, t2.byteOffset + e, n2), this._littleEndian = i, this._offset = 0;
  }
  _nextUint8() {
    const t2 = this._dataView.getUint8(this._offset);
    return this._offset += 1, t2;
  }
  _nextUint16() {
    const t2 = this._dataView.getUint16(this._offset, this._littleEndian);
    return this._offset += 2, t2;
  }
  _nextUint32() {
    const t2 = this._dataView.getUint32(this._offset, this._littleEndian);
    return this._offset += 4, t2;
  }
  _nextUint64() {
    const t2 = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
    return this._offset += 8, t2;
  }
  _nextInt32() {
    const t2 = this._dataView.getInt32(this._offset, this._littleEndian);
    return this._offset += 4, t2;
  }
  _nextUint8Array(t2) {
    const e = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._offset, t2);
    return this._offset += t2, e;
  }
  _skip(t2) {
    return this._offset += t2, this;
  }
  _scan(t2, e) {
    void 0 === e && (e = 0);
    const n2 = this._offset;
    let i = 0;
    for (; this._dataView.getUint8(this._offset) !== e && i < t2; )
      i++, this._offset++;
    return i < t2 && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n2, i);
  }
};
var Fi = new Uint8Array([0]);
var Oi = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
function Ti(t2) {
  return new TextDecoder().decode(t2);
}
function Pi(t2) {
  const e = new Uint8Array(t2.buffer, t2.byteOffset, Oi.length);
  if (e[0] !== Oi[0] || e[1] !== Oi[1] || e[2] !== Oi[2] || e[3] !== Oi[3] || e[4] !== Oi[4] || e[5] !== Oi[5] || e[6] !== Oi[6] || e[7] !== Oi[7] || e[8] !== Oi[8] || e[9] !== Oi[9] || e[10] !== Oi[10] || e[11] !== Oi[11])
    throw new Error("Missing KTX 2.0 identifier.");
  const n2 = new Ii(), i = 17 * Uint32Array.BYTES_PER_ELEMENT, s = new Si(t2, Oi.length, i, true);
  n2.vkFormat = s._nextUint32(), n2.typeSize = s._nextUint32(), n2.pixelWidth = s._nextUint32(), n2.pixelHeight = s._nextUint32(), n2.pixelDepth = s._nextUint32(), n2.layerCount = s._nextUint32(), n2.faceCount = s._nextUint32();
  const a = s._nextUint32();
  n2.supercompressionScheme = s._nextUint32();
  const r = s._nextUint32(), o = s._nextUint32(), l = s._nextUint32(), f2 = s._nextUint32(), h = s._nextUint64(), U = s._nextUint64(), c2 = new Si(t2, Oi.length + i, 3 * a * 8, true);
  for (let e2 = 0; e2 < a; e2++)
    n2.levels.push({ levelData: new Uint8Array(t2.buffer, t2.byteOffset + c2._nextUint64(), c2._nextUint64()), uncompressedByteLength: c2._nextUint64() });
  const _ = new Si(t2, r, o, true), p = { vendorId: _._skip(4)._nextUint16(), descriptorType: _._nextUint16(), versionNumber: _._nextUint16(), descriptorBlockSize: _._nextUint16(), colorModel: _._nextUint8(), colorPrimaries: _._nextUint8(), transferFunction: _._nextUint8(), flags: _._nextUint8(), texelBlockDimension: [_._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8()], bytesPlane: [_._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8()], samples: [] }, g3 = (p.descriptorBlockSize / 4 - 6) / 4;
  for (let t3 = 0; t3 < g3; t3++) {
    const e2 = { bitOffset: _._nextUint16(), bitLength: _._nextUint8(), channelType: _._nextUint8(), samplePosition: [_._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8()], sampleLower: -Infinity, sampleUpper: Infinity };
    64 & e2.channelType ? (e2.sampleLower = _._nextInt32(), e2.sampleUpper = _._nextInt32()) : (e2.sampleLower = _._nextUint32(), e2.sampleUpper = _._nextUint32()), p.samples[t3] = e2;
  }
  n2.dataFormatDescriptor.length = 0, n2.dataFormatDescriptor.push(p);
  const y = new Si(t2, l, f2, true);
  for (; y._offset < f2; ) {
    const t3 = y._nextUint32(), e2 = y._scan(t3), i2 = Ti(e2);
    if (n2.keyValue[i2] = y._nextUint8Array(t3 - e2.byteLength - 1), i2.match(/^ktx/i)) {
      const t4 = Ti(n2.keyValue[i2]);
      n2.keyValue[i2] = t4.substring(0, t4.lastIndexOf("\0"));
    }
    y._skip(t3 % 4 ? 4 - t3 % 4 : 0);
  }
  if (U <= 0)
    return n2;
  const x2 = new Si(t2, h, U, true), u2 = x2._nextUint16(), b = x2._nextUint16(), d = x2._nextUint32(), w = x2._nextUint32(), m2 = x2._nextUint32(), D = x2._nextUint32(), B2 = [];
  for (let t3 = 0; t3 < a; t3++)
    B2.push({ imageFlags: x2._nextUint32(), rgbSliceByteOffset: x2._nextUint32(), rgbSliceByteLength: x2._nextUint32(), alphaSliceByteOffset: x2._nextUint32(), alphaSliceByteLength: x2._nextUint32() });
  const L = h + x2._offset, v4 = L + d, A2 = v4 + w, k = A2 + m2, V = new Uint8Array(t2.buffer, t2.byteOffset + L, d), I2 = new Uint8Array(t2.buffer, t2.byteOffset + v4, w), S = new Uint8Array(t2.buffer, t2.byteOffset + A2, m2), F = new Uint8Array(t2.buffer, t2.byteOffset + k, D);
  return n2.globalData = { endpointCount: u2, selectorCount: b, imageDescs: B2, endpointsData: V, selectorsData: I2, tablesData: S, extendedData: F }, n2;
}

// node_modules/three/examples/jsm/libs/zstddec.module.js
var A;
var I;
var B;
var g2 = { env: { emscripten_notify_memory_growth: function(A2) {
  B = new Uint8Array(I.exports.memory.buffer);
} } };
var Q = class {
  init() {
    return A || (A = "undefined" != typeof fetch ? fetch("data:application/wasm;base64," + C3).then((A2) => A2.arrayBuffer()).then((A2) => WebAssembly.instantiate(A2, g2)).then(this._init) : WebAssembly.instantiate(Buffer.from(C3, "base64"), g2).then(this._init), A);
  }
  _init(A2) {
    I = A2.instance, g2.env.emscripten_notify_memory_growth(0);
  }
  decode(A2, g3 = 0) {
    if (!I)
      throw new Error("ZSTDDecoder: Await .init() before decoding.");
    const Q2 = A2.byteLength, C4 = I.exports.malloc(Q2);
    B.set(A2, C4), g3 = g3 || Number(I.exports.ZSTD_findDecompressedSize(C4, Q2));
    const E = I.exports.malloc(g3), i = I.exports.ZSTD_decompress(E, g3, C4, Q2), D = B.slice(E, E + i);
    return I.exports.free(C4), I.exports.free(E), D;
  }
};
var C3 = "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IAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQh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ASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdB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IAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY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wOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEE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";

// node_modules/three/examples/jsm/loaders/KTX2Loader.js
var _taskCache2 = /* @__PURE__ */ new WeakMap();
var _activeLoaders = 0;
var _zstd;
var KTX2Loader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.transcoderPath = "";
    this.transcoderBinary = null;
    this.transcoderPending = null;
    this.workerPool = new WorkerPool();
    this.workerSourceURL = "";
    this.workerConfig = null;
    if (typeof MSC_TRANSCODER !== "undefined") {
      console.warn(
        'THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.'
      );
    }
  }
  setTranscoderPath(path) {
    this.transcoderPath = path;
    return this;
  }
  setWorkerLimit(num) {
    this.workerPool.setWorkerLimit(num);
    return this;
  }
  async detectSupportAsync(renderer) {
    this.workerConfig = {
      astcSupported: await renderer.hasFeatureAsync("texture-compression-astc"),
      etc1Supported: await renderer.hasFeatureAsync("texture-compression-etc1"),
      etc2Supported: await renderer.hasFeatureAsync("texture-compression-etc2"),
      dxtSupported: await renderer.hasFeatureAsync("texture-compression-bc"),
      bptcSupported: await renderer.hasFeatureAsync("texture-compression-bptc"),
      pvrtcSupported: await renderer.hasFeatureAsync("texture-compression-pvrtc")
    };
    return this;
  }
  detectSupport(renderer) {
    if (renderer.isWebGPURenderer === true) {
      this.workerConfig = {
        astcSupported: renderer.hasFeature("texture-compression-astc"),
        etc1Supported: renderer.hasFeature("texture-compression-etc1"),
        etc2Supported: renderer.hasFeature("texture-compression-etc2"),
        dxtSupported: renderer.hasFeature("texture-compression-bc"),
        bptcSupported: renderer.hasFeature("texture-compression-bptc"),
        pvrtcSupported: renderer.hasFeature("texture-compression-pvrtc")
      };
    } else {
      this.workerConfig = {
        astcSupported: renderer.extensions.has("WEBGL_compressed_texture_astc"),
        etc1Supported: renderer.extensions.has("WEBGL_compressed_texture_etc1"),
        etc2Supported: renderer.extensions.has("WEBGL_compressed_texture_etc"),
        dxtSupported: renderer.extensions.has("WEBGL_compressed_texture_s3tc"),
        bptcSupported: renderer.extensions.has("EXT_texture_compression_bptc"),
        pvrtcSupported: renderer.extensions.has("WEBGL_compressed_texture_pvrtc") || renderer.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
      };
    }
    return this;
  }
  init() {
    if (!this.transcoderPending) {
      const jsLoader = new FileLoader(this.manager);
      jsLoader.setPath(this.transcoderPath);
      jsLoader.setWithCredentials(this.withCredentials);
      const jsContent = jsLoader.loadAsync("basis_transcoder.js");
      const binaryLoader = new FileLoader(this.manager);
      binaryLoader.setPath(this.transcoderPath);
      binaryLoader.setResponseType("arraybuffer");
      binaryLoader.setWithCredentials(this.withCredentials);
      const binaryContent = binaryLoader.loadAsync("basis_transcoder.wasm");
      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent2, binaryContent2]) => {
        const fn2 = KTX2Loader.BasisWorker.toString();
        const body = [
          "/* constants */",
          "let _EngineFormat = " + JSON.stringify(KTX2Loader.EngineFormat),
          "let _TranscoderFormat = " + JSON.stringify(KTX2Loader.TranscoderFormat),
          "let _BasisFormat = " + JSON.stringify(KTX2Loader.BasisFormat),
          "/* basis_transcoder.js */",
          jsContent2,
          "/* worker */",
          fn2.substring(fn2.indexOf("{") + 1, fn2.lastIndexOf("}"))
        ].join("\n");
        this.workerSourceURL = URL.createObjectURL(new Blob([body]));
        this.transcoderBinary = binaryContent2;
        this.workerPool.setWorkerCreator(() => {
          const worker = new Worker(this.workerSourceURL);
          const transcoderBinary = this.transcoderBinary.slice(0);
          worker.postMessage({ type: "init", config: this.workerConfig, transcoderBinary }, [transcoderBinary]);
          return worker;
        });
      });
      if (_activeLoaders > 0) {
        console.warn(
          "THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."
        );
      }
      _activeLoaders++;
    }
    return this.transcoderPending;
  }
  load(url, onLoad2, onProgress, onError2) {
    if (this.workerConfig === null) {
      throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
    }
    const loader2 = new FileLoader(this.manager);
    loader2.setResponseType("arraybuffer");
    loader2.setWithCredentials(this.withCredentials);
    loader2.load(url, (buffer2) => {
      this.parse(buffer2, onLoad2, onError2);
    }, onProgress, onError2);
  }
  parse(buffer2, onLoad2, onError2) {
    if (this.workerConfig === null) {
      throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
    }
    if (_taskCache2.has(buffer2)) {
      const cachedTask = _taskCache2.get(buffer2);
      return cachedTask.promise.then(onLoad2).catch(onError2);
    }
    this._createTexture(buffer2).then((texture) => onLoad2 ? onLoad2(texture) : null).catch(onError2);
  }
  _createTextureFrom(transcodeResult, container) {
    const { faces, width, height, format, type, error, dfdFlags } = transcodeResult;
    if (type === "error")
      return Promise.reject(error);
    let texture;
    if (container.faceCount === 6) {
      texture = new CompressedCubeTexture(faces, format, UnsignedByteType);
    } else {
      const mipmaps = faces[0].mipmaps;
      texture = container.layerCount > 1 ? new CompressedArrayTexture(mipmaps, width, height, container.layerCount, format, UnsignedByteType) : new CompressedTexture(mipmaps, width, height, format, UnsignedByteType);
    }
    texture.minFilter = faces[0].mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;
    texture.magFilter = LinearFilter;
    texture.generateMipmaps = false;
    texture.needsUpdate = true;
    texture.colorSpace = parseColorSpace(container);
    texture.premultiplyAlpha = !!(dfdFlags & g);
    return texture;
  }
  /**
   * @param {ArrayBuffer} buffer
   * @param {object?} config
   * @return {Promise<CompressedTexture|CompressedArrayTexture|DataTexture|Data3DTexture>}
   */
  async _createTexture(buffer2, config = {}) {
    const container = Pi(new Uint8Array(buffer2));
    if (container.vkFormat !== it) {
      return createRawTexture(container);
    }
    const taskConfig = config;
    const texturePending = this.init().then(() => {
      return this.workerPool.postMessage({ type: "transcode", buffer: buffer2, taskConfig }, [buffer2]);
    }).then((e) => this._createTextureFrom(e.data, container));
    _taskCache2.set(buffer2, { promise: texturePending });
    return texturePending;
  }
  dispose() {
    this.workerPool.dispose();
    if (this.workerSourceURL)
      URL.revokeObjectURL(this.workerSourceURL);
    _activeLoaders--;
    return this;
  }
};
KTX2Loader.BasisFormat = {
  ETC1S: 0,
  UASTC_4x4: 1
};
KTX2Loader.TranscoderFormat = {
  ETC1: 0,
  ETC2: 1,
  BC1: 2,
  BC3: 3,
  BC4: 4,
  BC5: 5,
  BC7_M6_OPAQUE_ONLY: 6,
  BC7_M5: 7,
  PVRTC1_4_RGB: 8,
  PVRTC1_4_RGBA: 9,
  ASTC_4x4: 10,
  ATC_RGB: 11,
  ATC_RGBA_INTERPOLATED_ALPHA: 12,
  RGBA32: 13,
  RGB565: 14,
  BGR565: 15,
  RGBA4444: 16
};
KTX2Loader.EngineFormat = {
  RGBAFormat,
  RGBA_ASTC_4x4_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT5_Format,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT1_Format
};
KTX2Loader.BasisWorker = function() {
  let config;
  let transcoderPending;
  let BasisModule;
  const EngineFormat = _EngineFormat;
  const TranscoderFormat = _TranscoderFormat;
  const BasisFormat = _BasisFormat;
  self.addEventListener("message", function(e) {
    const message = e.data;
    switch (message.type) {
      case "init":
        config = message.config;
        init(message.transcoderBinary);
        break;
      case "transcode":
        transcoderPending.then(() => {
          try {
            const { faces, buffers, width, height, hasAlpha, format, dfdFlags } = transcode(message.buffer);
            self.postMessage({ type: "transcode", id: message.id, faces, width, height, hasAlpha, format, dfdFlags }, buffers);
          } catch (error) {
            console.error(error);
            self.postMessage({ type: "error", id: message.id, error: error.message });
          }
        });
        break;
    }
  });
  function init(wasmBinary) {
    transcoderPending = new Promise((resolve2) => {
      BasisModule = { wasmBinary, onRuntimeInitialized: resolve2 };
      BASIS(BasisModule);
    }).then(() => {
      BasisModule.initializeBasis();
      if (BasisModule.KTX2File === void 0) {
        console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.");
      }
    });
  }
  function transcode(buffer2) {
    const ktx2File = new BasisModule.KTX2File(new Uint8Array(buffer2));
    function cleanup() {
      ktx2File.close();
      ktx2File.delete();
    }
    if (!ktx2File.isValid()) {
      cleanup();
      throw new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
    }
    const basisFormat = ktx2File.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;
    const width = ktx2File.getWidth();
    const height = ktx2File.getHeight();
    const layerCount = ktx2File.getLayers() || 1;
    const levelCount = ktx2File.getLevels();
    const faceCount = ktx2File.getFaces();
    const hasAlpha = ktx2File.getHasAlpha();
    const dfdFlags = ktx2File.getDFDFlags();
    const { transcoderFormat, engineFormat } = getTranscoderFormat(basisFormat, width, height, hasAlpha);
    if (!width || !height || !levelCount) {
      cleanup();
      throw new Error("THREE.KTX2Loader:	Invalid texture");
    }
    if (!ktx2File.startTranscoding()) {
      cleanup();
      throw new Error("THREE.KTX2Loader: .startTranscoding failed");
    }
    const faces = [];
    const buffers = [];
    for (let face = 0; face < faceCount; face++) {
      const mipmaps = [];
      for (let mip = 0; mip < levelCount; mip++) {
        const layerMips = [];
        let mipWidth, mipHeight;
        for (let layer = 0; layer < layerCount; layer++) {
          const levelInfo = ktx2File.getImageLevelInfo(mip, layer, face);
          if (face === 0 && mip === 0 && layer === 0 && (levelInfo.origWidth % 4 !== 0 || levelInfo.origHeight % 4 !== 0)) {
            console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions.");
          }
          if (levelCount > 1) {
            mipWidth = levelInfo.origWidth;
            mipHeight = levelInfo.origHeight;
          } else {
            mipWidth = levelInfo.width;
            mipHeight = levelInfo.height;
          }
          const dst = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip, layer, 0, transcoderFormat));
          const status = ktx2File.transcodeImage(dst, mip, layer, face, transcoderFormat, 0, -1, -1);
          if (!status) {
            cleanup();
            throw new Error("THREE.KTX2Loader: .transcodeImage failed.");
          }
          layerMips.push(dst);
        }
        const mipData = concat(layerMips);
        mipmaps.push({ data: mipData, width: mipWidth, height: mipHeight });
        buffers.push(mipData.buffer);
      }
      faces.push({ mipmaps, width, height, format: engineFormat });
    }
    cleanup();
    return { faces, buffers, width, height, hasAlpha, format: engineFormat, dfdFlags };
  }
  const FORMAT_OPTIONS = [
    {
      if: "astcSupported",
      basisFormat: [BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],
      engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],
      priorityETC1S: Infinity,
      priorityUASTC: 1,
      needsPowerOfTwo: false
    },
    {
      if: "bptcSupported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],
      engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],
      priorityETC1S: 3,
      priorityUASTC: 2,
      needsPowerOfTwo: false
    },
    {
      if: "dxtSupported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],
      engineFormat: [EngineFormat.RGBA_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],
      priorityETC1S: 4,
      priorityUASTC: 5,
      needsPowerOfTwo: false
    },
    {
      if: "etc2Supported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],
      engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],
      priorityETC1S: 1,
      priorityUASTC: 3,
      needsPowerOfTwo: false
    },
    {
      if: "etc1Supported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.ETC1],
      engineFormat: [EngineFormat.RGB_ETC1_Format],
      priorityETC1S: 2,
      priorityUASTC: 4,
      needsPowerOfTwo: false
    },
    {
      if: "pvrtcSupported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],
      engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],
      priorityETC1S: 5,
      priorityUASTC: 6,
      needsPowerOfTwo: true
    }
  ];
  const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function(a, b) {
    return a.priorityETC1S - b.priorityETC1S;
  });
  const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function(a, b) {
    return a.priorityUASTC - b.priorityUASTC;
  });
  function getTranscoderFormat(basisFormat, width, height, hasAlpha) {
    let transcoderFormat;
    let engineFormat;
    const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;
    for (let i = 0; i < options.length; i++) {
      const opt = options[i];
      if (!config[opt.if])
        continue;
      if (!opt.basisFormat.includes(basisFormat))
        continue;
      if (hasAlpha && opt.transcoderFormat.length < 2)
        continue;
      if (opt.needsPowerOfTwo && !(isPowerOfTwo2(width) && isPowerOfTwo2(height)))
        continue;
      transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];
      engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];
      return { transcoderFormat, engineFormat };
    }
    console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32.");
    transcoderFormat = TranscoderFormat.RGBA32;
    engineFormat = EngineFormat.RGBAFormat;
    return { transcoderFormat, engineFormat };
  }
  function isPowerOfTwo2(value) {
    if (value <= 2)
      return true;
    return (value & value - 1) === 0 && value !== 0;
  }
  function concat(arrays) {
    if (arrays.length === 1)
      return arrays[0];
    let totalByteLength = 0;
    for (let i = 0; i < arrays.length; i++) {
      const array = arrays[i];
      totalByteLength += array.byteLength;
    }
    const result = new Uint8Array(totalByteLength);
    let byteOffset = 0;
    for (let i = 0; i < arrays.length; i++) {
      const array = arrays[i];
      result.set(array, byteOffset);
      byteOffset += array.byteLength;
    }
    return result;
  }
};
var UNCOMPRESSED_FORMATS = /* @__PURE__ */ new Set([RGBAFormat, RGFormat, RedFormat]);
var FORMAT_MAP = {
  [Ae]: RGBAFormat,
  [ge]: RGBAFormat,
  [Ft]: RGBAFormat,
  [Ct]: RGBAFormat,
  [we]: RGFormat,
  [ae]: RGFormat,
  [xt]: RGFormat,
  [wt]: RGFormat,
  [ue]: RedFormat,
  [te]: RedFormat,
  [yt]: RedFormat,
  [ct]: RedFormat,
  [pi]: RGBA_ASTC_4x4_Format,
  [Sn]: RGBA_ASTC_6x6_Format,
  [In]: RGBA_ASTC_6x6_Format
};
var TYPE_MAP = {
  [Ae]: FloatType,
  [ge]: HalfFloatType,
  [Ft]: UnsignedByteType,
  [Ct]: UnsignedByteType,
  [we]: FloatType,
  [ae]: HalfFloatType,
  [xt]: UnsignedByteType,
  [wt]: UnsignedByteType,
  [ue]: FloatType,
  [te]: HalfFloatType,
  [yt]: UnsignedByteType,
  [ct]: UnsignedByteType,
  [pi]: HalfFloatType,
  [Sn]: UnsignedByteType,
  [In]: UnsignedByteType
};
async function createRawTexture(container) {
  const { vkFormat } = container;
  if (FORMAT_MAP[vkFormat] === void 0) {
    throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
  }
  let zstd;
  if (container.supercompressionScheme === n) {
    if (!_zstd) {
      _zstd = new Promise(async (resolve2) => {
        const zstd2 = new Q();
        await zstd2.init();
        resolve2(zstd2);
      });
    }
    zstd = await _zstd;
  }
  const mipmaps = [];
  for (let levelIndex = 0; levelIndex < container.levels.length; levelIndex++) {
    const levelWidth = Math.max(1, container.pixelWidth >> levelIndex);
    const levelHeight = Math.max(1, container.pixelHeight >> levelIndex);
    const levelDepth = container.pixelDepth ? Math.max(1, container.pixelDepth >> levelIndex) : 0;
    const level = container.levels[levelIndex];
    let levelData;
    if (container.supercompressionScheme === t) {
      levelData = level.levelData;
    } else if (container.supercompressionScheme === n) {
      levelData = zstd.decode(level.levelData, level.uncompressedByteLength);
    } else {
      throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
    }
    let data;
    if (TYPE_MAP[vkFormat] === FloatType) {
      data = new Float32Array(
        levelData.buffer,
        levelData.byteOffset,
        levelData.byteLength / Float32Array.BYTES_PER_ELEMENT
      );
    } else if (TYPE_MAP[vkFormat] === HalfFloatType) {
      data = new Uint16Array(
        levelData.buffer,
        levelData.byteOffset,
        levelData.byteLength / Uint16Array.BYTES_PER_ELEMENT
      );
    } else {
      data = levelData;
    }
    mipmaps.push({
      data,
      width: levelWidth,
      height: levelHeight,
      depth: levelDepth
    });
  }
  let texture;
  if (UNCOMPRESSED_FORMATS.has(FORMAT_MAP[vkFormat])) {
    texture = container.pixelDepth === 0 ? new DataTexture(mipmaps[0].data, container.pixelWidth, container.pixelHeight) : new Data3DTexture(mipmaps[0].data, container.pixelWidth, container.pixelHeight, container.pixelDepth);
  } else {
    if (container.pixelDepth > 0)
      throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");
    texture = new CompressedTexture(mipmaps, container.pixelWidth, container.pixelHeight);
  }
  texture.mipmaps = mipmaps;
  texture.type = TYPE_MAP[vkFormat];
  texture.format = FORMAT_MAP[vkFormat];
  texture.colorSpace = parseColorSpace(container);
  texture.needsUpdate = true;
  return Promise.resolve(texture);
}
function parseColorSpace(container) {
  const dfd = container.dataFormatDescriptor[0];
  if (dfd.colorPrimaries === C2) {
    return dfd.transferFunction === u ? SRGBColorSpace : LinearSRGBColorSpace;
  } else if (dfd.colorPrimaries === R) {
    return dfd.transferFunction === u ? DisplayP3ColorSpace : LinearDisplayP3ColorSpace;
  } else if (dfd.colorPrimaries === T2) {
    return NoColorSpace;
  } else {
    console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${dfd.colorPrimaries}"`);
    return NoColorSpace;
  }
}

// node_modules/@needle-tools/gltf-progressive/lib/loaders.js
var DEFAULT_DRACO_DECODER_LOCATION = "https://www.gstatic.com/draco/versioned/decoders/1.5.7/";
var DEFAULT_KTX2_TRANSCODER_LOCATION = "https://www.gstatic.com/basis-universal/versioned/2021-04-15-ba1c3e4/";
var defaultDraco = DEFAULT_DRACO_DECODER_LOCATION;
var defaultKTX2 = DEFAULT_KTX2_TRANSCODER_LOCATION;
fetch(DEFAULT_DRACO_DECODER_LOCATION + "draco_decoder.js", { method: "head" }).catch((_) => {
  if (DEFAULT_DRACO_DECODER_LOCATION === defaultDraco)
    DEFAULT_DRACO_DECODER_LOCATION = "./include/draco/";
  if (DEFAULT_KTX2_TRANSCODER_LOCATION === defaultKTX2)
    DEFAULT_KTX2_TRANSCODER_LOCATION = "./include/ktx2/";
});
function setDracoDecoderLocation(location2) {
  DEFAULT_DRACO_DECODER_LOCATION = location2;
}
function setKTX2TranscoderLocation(location2) {
  DEFAULT_KTX2_TRANSCODER_LOCATION = location2;
}
var dracoLoader;
var meshoptDecoder;
var ktx2Loader;
function createLoaders(renderer) {
  if (!dracoLoader) {
    dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath(DEFAULT_DRACO_DECODER_LOCATION);
    dracoLoader.setDecoderConfig({ type: "js" });
  }
  if (!ktx2Loader) {
    ktx2Loader = new KTX2Loader();
    ktx2Loader.setTranscoderPath(DEFAULT_KTX2_TRANSCODER_LOCATION);
  }
  if (!meshoptDecoder) {
    meshoptDecoder = MeshoptDecoder;
  }
  if (renderer) {
    ktx2Loader.detectSupport(renderer);
  } else if (renderer !== null)
    console.warn("No renderer provided to detect ktx2 support - loading KTX2 textures might fail");
  return { dracoLoader, ktx2Loader, meshoptDecoder };
}
function addDracoAndKTX2Loaders(loader2) {
  if (!loader2.dracoLoader)
    loader2.setDRACOLoader(dracoLoader);
  if (!loader2.ktx2Loader)
    loader2.setKTX2Loader(ktx2Loader);
  if (!loader2.meshoptDecoder)
    loader2.setMeshoptDecoder(meshoptDecoder);
}
var gltfLoaderConfigurations = /* @__PURE__ */ new WeakMap();
function configureLoader(loader2, opts) {
  let config = gltfLoaderConfigurations.get(loader2);
  if (config) {
    config = Object.assign(config, opts);
  } else {
    config = opts;
  }
  gltfLoaderConfigurations.set(loader2, config);
}
var originalLoadFunction = GLTFLoader.prototype.load;
function onLoad(...args) {
  const config = gltfLoaderConfigurations.get(this);
  let url_str = args[0];
  const url = new URL(url_str, window.location.href);
  if (url.hostname.endsWith("needle.tools")) {
    const progressive = (config == null ? void 0 : config.progressive) !== void 0 ? config.progressive : true;
    const usecase = (config == null ? void 0 : config.usecase) ? config.usecase : "default";
    if (progressive) {
      this.requestHeader["Accept"] = `*/*;progressive=allowed;usecase=${usecase}`;
    } else {
      this.requestHeader["Accept"] = `*/*;usecase=${usecase}`;
    }
    url_str = url.toString();
  }
  args[0] = url_str;
  const res = originalLoadFunction == null ? void 0 : originalLoadFunction.call(this, ...args);
  return res;
}
GLTFLoader.prototype.load = onLoad;

// node_modules/@needle-tools/gltf-progressive/lib/utils.internal.js
var debug3 = getParam2("debugprogressive");
function getParam2(name) {
  if (typeof window === "undefined")
    return false;
  const url = new URL(window.location.href);
  const param = url.searchParams.get(name);
  if (param == null || param === "0" || param === "false")
    return false;
  if (param === "")
    return true;
  return param;
}
function resolveUrl2(source, uri) {
  if (uri === void 0) {
    return uri;
  }
  if (uri.startsWith("./")) {
    return uri;
  }
  if (uri.startsWith("http")) {
    return uri;
  }
  if (source === void 0) {
    return uri;
  }
  const pathIndex = source.lastIndexOf("/");
  if (pathIndex >= 0) {
    const basePath = source.substring(0, pathIndex + 1);
    while (basePath.endsWith("/") && uri.startsWith("/"))
      uri = uri.substring(1);
    const newUri = basePath + uri;
    return newUri;
  }
  return uri;
}
var _ismobile;
function isMobileDevice2() {
  if (_ismobile !== void 0)
    return _ismobile;
  _ismobile = /iPhone|iPad|iPod|Android|IEMobile/i.test(navigator.userAgent);
  if (getParam2("debugprogressive"))
    console.log("[glTF Progressive]: isMobileDevice", _ismobile);
  return _ismobile;
}

// node_modules/@needle-tools/gltf-progressive/lib/utils.js
var $raycastmesh = Symbol("needle:raycast-mesh");
function getRaycastMesh(obj) {
  if ((obj == null ? void 0 : obj[$raycastmesh]) instanceof BufferGeometry) {
    return obj[$raycastmesh];
  }
  return null;
}
function registerRaycastMesh(obj, geom) {
  if (obj.type === "Mesh" || obj.type === "SkinnedMesh") {
    const existing = getRaycastMesh(obj);
    if (!existing) {
      const clone = shallowCloneGeometry(geom);
      clone.userData = { isRaycastMesh: true };
      obj[$raycastmesh] = clone;
    }
  }
}
function shallowCloneGeometry(geom) {
  const clone = new BufferGeometry();
  for (const key in geom.attributes) {
    clone.setAttribute(key, geom.getAttribute(key));
  }
  clone.setIndex(geom.getIndex());
  return clone;
}

// node_modules/@needle-tools/gltf-progressive/lib/plugins/plugin.js
var plugins = new Array();

// node_modules/@needle-tools/gltf-progressive/lib/extension.js
var EXTENSION_NAME = "NEEDLE_progressive";
var debug4 = getParam2("debugprogressive");
var $progressiveTextureExtension = Symbol("needle-progressive-texture");
var debug_toggle_maps = /* @__PURE__ */ new Map();
var debug_materials = /* @__PURE__ */ new Set();
if (debug4) {
  let debugToggleProgressive = function() {
    currentDebugLodLevel += 1;
    console.log("Toggle LOD level", currentDebugLodLevel, debug_toggle_maps);
    debug_toggle_maps.forEach((arr, obj) => {
      for (const key of arr.keys) {
        const cur = obj[key];
        if (cur == null) {
          continue;
        }
        if (cur.isBufferGeometry === true) {
          const info = NEEDLE_progressive.getMeshLODInformation(cur);
          const level = !info ? 0 : Math.min(currentDebugLodLevel, info.lods.length);
          obj["DEBUG:LOD"] = currentDebugLodLevel;
          NEEDLE_progressive.assignMeshLOD(obj, level);
          if (info)
            maxLevel = Math.max(maxLevel, info.lods.length - 1);
        } else if (obj.isMaterial === true) {
          obj["DEBUG:LOD"] = currentDebugLodLevel;
          NEEDLE_progressive.assignTextureLOD(obj, currentDebugLodLevel);
          break;
        }
      }
    });
    if (currentDebugLodLevel >= maxLevel) {
      currentDebugLodLevel = -1;
    }
  };
  let currentDebugLodLevel = -1;
  let maxLevel = 2;
  let wireframe = false;
  window.addEventListener("keyup", (evt) => {
    if (evt.key === "p")
      debugToggleProgressive();
    if (evt.key === "w") {
      wireframe = !wireframe;
      if (debug_materials) {
        debug_materials.forEach((mat) => {
          if (mat.name == "BackgroundCubeMaterial")
            return;
          if (mat["glyphMap"] != void 0)
            return;
          if ("wireframe" in mat) {
            mat.wireframe = wireframe;
          }
        });
      }
    }
  });
}
function registerDebug(obj, key, sourceId) {
  var _a2;
  if (!debug4)
    return;
  if (!debug_toggle_maps.has(obj)) {
    debug_toggle_maps.set(obj, { keys: [], sourceId });
  }
  const existing = debug_toggle_maps.get(obj);
  if (((_a2 = existing == null ? void 0 : existing.keys) == null ? void 0 : _a2.includes(key)) == false) {
    existing.keys.push(key);
  }
}
var _NEEDLE_progressive = class {
  constructor(parser, url) {
    __publicField(this, "parser");
    __publicField(this, "url");
    __publicField(this, "_isLoadingMesh");
    __publicField(this, "loadMesh", (meshIndex) => {
      var _a2, _b;
      if (this._isLoadingMesh)
        return null;
      const ext = (_b = (_a2 = this.parser.json.meshes[meshIndex]) == null ? void 0 : _a2.extensions) == null ? void 0 : _b[EXTENSION_NAME];
      if (!ext)
        return null;
      this._isLoadingMesh = true;
      return this.parser.getDependency("mesh", meshIndex).then((mesh) => {
        var _a3;
        this._isLoadingMesh = false;
        if (mesh) {
          _NEEDLE_progressive.registerMesh(this.url, ext.guid, mesh, (_a3 = ext.lods) == null ? void 0 : _a3.length, void 0, ext);
        }
        return mesh;
      });
    });
    if (debug4)
      console.log("Progressive extension registered for", url);
    this.parser = parser;
    this.url = url;
  }
  /** The name of the extension */
  get name() {
    return EXTENSION_NAME;
  }
  static getMeshLODInformation(geo) {
    const info = this.getAssignedLODInformation(geo);
    if (info == null ? void 0 : info.key) {
      return this.lodInfos.get(info.key);
    }
    return null;
  }
  static getMaterialMinMaxLODsCount(material, minmax) {
    const self2 = this;
    const cacheKey = "LODS:minmax";
    const cached = material[cacheKey];
    if (cached != void 0)
      return cached;
    if (!minmax) {
      minmax = {
        min_count: Infinity,
        max_count: 0,
        lods: []
      };
    }
    if (Array.isArray(material)) {
      for (const mat of material) {
        this.getMaterialMinMaxLODsCount(mat, minmax);
      }
      material[cacheKey] = minmax;
      return minmax;
    }
    if (debug4 === "verbose")
      console.log("getMaterialMinMaxLODsCount", material);
    if (material.type === "ShaderMaterial" || material.type === "RawShaderMaterial") {
      const mat = material;
      for (const slot of Object.keys(mat.uniforms)) {
        const val = mat.uniforms[slot].value;
        if ((val == null ? void 0 : val.isTexture) === true) {
          processTexture(val, minmax);
        }
      }
    } else if (material.isMaterial) {
      for (const slot of Object.keys(material)) {
        const val = material[slot];
        if ((val == null ? void 0 : val.isTexture) === true) {
          processTexture(val, minmax);
        }
      }
    }
    material[cacheKey] = minmax;
    return minmax;
    function processTexture(tex, minmax2) {
      const info = self2.getAssignedLODInformation(tex);
      if (info) {
        const model = self2.lodInfos.get(info.key);
        if (model && model.lods) {
          minmax2.min_count = Math.min(minmax2.min_count, model.lods.length);
          minmax2.max_count = Math.max(minmax2.max_count, model.lods.length);
          for (let i = 0; i < model.lods.length; i++) {
            const lod = model.lods[i];
            if (lod.width) {
              minmax2.lods[i] = minmax2.lods[i] || { min_height: Infinity, max_height: 0 };
              minmax2.lods[i].min_height = Math.min(minmax2.lods[i].min_height, lod.height);
              minmax2.lods[i].max_height = Math.max(minmax2.lods[i].max_height, lod.height);
            }
          }
        }
      }
    }
  }
  /** Check if a LOD level is available for a mesh or a texture
   * @param obj the mesh or texture to check
   * @param level the level of detail to check for (0 is the highest resolution). If undefined, the function checks if any LOD level is available
   * @returns true if the LOD level is available (or if any LOD level is available if level is undefined)
   */
  static hasLODLevelAvailable(obj, level) {
    var _a2;
    if (Array.isArray(obj)) {
      for (const mat of obj) {
        if (this.hasLODLevelAvailable(mat, level))
          return true;
      }
      return false;
    }
    if (obj.isMaterial === true) {
      for (const slot of Object.keys(obj)) {
        const val = obj[slot];
        if (val && val.isTexture) {
          if (this.hasLODLevelAvailable(val, level))
            return true;
        }
      }
      return false;
    } else if (obj.isGroup === true) {
      for (const child of obj.children) {
        if (child.isMesh === true) {
          if (this.hasLODLevelAvailable(child, level))
            return true;
        }
      }
    }
    let lodObject;
    let lodInformation;
    if (obj.isMesh) {
      lodObject = obj.geometry;
    } else if (obj.isBufferGeometry) {
      lodObject = obj;
    } else if (obj.isTexture) {
      lodObject = obj;
    }
    if (lodObject) {
      if ((_a2 = lodObject == null ? void 0 : lodObject.userData) == null ? void 0 : _a2.LODS) {
        const lods = lodObject.userData.LODS;
        lodInformation = this.lodInfos.get(lods.key);
        if (level === void 0)
          return lodInformation != void 0;
        if (lodInformation) {
          if (Array.isArray(lodInformation.lods)) {
            return level < lodInformation.lods.length;
          }
          return level === 0;
        }
      }
    }
    return false;
  }
  /** Load a different resolution of a mesh (if available)
   * @param context the context
   * @param source the sourceid of the file from which the mesh is loaded (this is usually the component's sourceId)
   * @param mesh the mesh to load the LOD for
   * @param level the level of detail to load (0 is the highest resolution)
   * @returns a promise that resolves to the mesh with the requested LOD level
   * @example
   * ```javascript
   * const mesh = this.gameObject as Mesh;
   * NEEDLE_progressive.assignMeshLOD(context, sourceId, mesh, 1).then(mesh => {
   *    console.log("Mesh with LOD level 1 loaded", mesh);
   * });
   * ```
   */
  static assignMeshLOD(mesh, level) {
    var _a2;
    if (!mesh)
      return Promise.resolve(null);
    if (mesh instanceof Mesh || mesh.isMesh === true) {
      const currentGeometry = mesh.geometry;
      const lodinfo = this.getAssignedLODInformation(currentGeometry);
      if (!lodinfo) {
        return Promise.resolve(null);
      }
      for (const plugin of plugins) {
        (_a2 = plugin.onBeforeGetLODMesh) == null ? void 0 : _a2.call(plugin, mesh, level);
      }
      mesh["LOD:requested level"] = level;
      return _NEEDLE_progressive.getOrLoadLOD(currentGeometry, level).then((geo) => {
        if (Array.isArray(geo)) {
          const index = lodinfo.index || 0;
          geo = geo[index];
        }
        if (mesh["LOD:requested level"] === level) {
          delete mesh["LOD:requested level"];
          if (geo && currentGeometry != geo) {
            const isGeometry = geo == null ? void 0 : geo.isBufferGeometry;
            if (isGeometry) {
              mesh.geometry = geo;
              if (debug4)
                registerDebug(mesh, "geometry", lodinfo.url);
            } else if (debug4) {
              console.error("Invalid LOD geometry", geo);
            }
          }
        }
        return geo;
      }).catch((err) => {
        console.error("Error loading mesh LOD", mesh, err);
        return null;
      });
    } else if (debug4) {
      console.error("Invalid call to assignMeshLOD: Request mesh LOD but the object is not a mesh", mesh);
    }
    return Promise.resolve(null);
  }
  static assignTextureLOD(materialOrTexture, level = 0) {
    if (!materialOrTexture)
      return Promise.resolve(null);
    if (materialOrTexture.isMesh === true) {
      const mesh = materialOrTexture;
      if (Array.isArray(mesh.material)) {
        const arr = new Array();
        for (const mat of mesh.material) {
          const promise = this.assignTextureLOD(mat, level);
          arr.push(promise);
        }
        return Promise.all(arr).then((res) => {
          const textures2 = new Array();
          for (const tex of res) {
            if (Array.isArray(tex)) {
              textures2.push(...tex);
            }
          }
          return textures2;
        });
      } else {
        return this.assignTextureLOD(mesh.material, level);
      }
    }
    if (materialOrTexture instanceof Material || materialOrTexture.isMaterial === true) {
      const material = materialOrTexture;
      const promises = [];
      const slots = new Array();
      if (debug4)
        debug_materials.add(material);
      if (material.uniforms && (material.isRawShaderMaterial || material.isShaderMaterial === true)) {
        const shaderMaterial = material;
        for (const slot of Object.keys(shaderMaterial.uniforms)) {
          const val = shaderMaterial.uniforms[slot].value;
          if ((val == null ? void 0 : val.isTexture) === true) {
            const task = this.assignTextureLODForSlot(val, level, material, slot).then((res) => {
              if (res && shaderMaterial.uniforms[slot].value != res) {
                shaderMaterial.uniforms[slot].value = res;
                shaderMaterial.uniformsNeedUpdate = true;
              }
              return res;
            });
            promises.push(task);
            slots.push(slot);
          }
        }
      } else {
        for (const slot of Object.keys(material)) {
          const val = material[slot];
          if ((val == null ? void 0 : val.isTexture) === true) {
            const task = this.assignTextureLODForSlot(val, level, material, slot);
            promises.push(task);
            slots.push(slot);
          }
        }
      }
      return Promise.all(promises).then((res) => {
        const textures2 = new Array();
        for (let i = 0; i < res.length; i++) {
          const tex = res[i];
          const slot = slots[i];
          if (tex && tex.isTexture === true) {
            textures2.push({ material, slot, texture: tex, level });
          } else {
            textures2.push({ material, slot, texture: null, level });
          }
        }
        return textures2;
      });
    }
    if (materialOrTexture instanceof Texture || materialOrTexture.isTexture === true) {
      const texture = materialOrTexture;
      return this.assignTextureLODForSlot(texture, level, null, null);
    }
    return Promise.resolve(null);
  }
  static assignTextureLODForSlot(current, level, material, slot) {
    if ((current == null ? void 0 : current.isTexture) !== true)
      return Promise.resolve(null);
    if (slot === "glyphMap") {
      return Promise.resolve(current);
    }
    return _NEEDLE_progressive.getOrLoadLOD(current, level).then((tex) => {
      if (Array.isArray(tex))
        return null;
      if ((tex == null ? void 0 : tex.isTexture) === true) {
        if (tex != current) {
          if (material && slot) {
            const assigned = material[slot];
            if (assigned) {
              const assignedLOD = this.getAssignedLODInformation(assigned);
              if (assignedLOD && (assignedLOD == null ? void 0 : assignedLOD.level) < level) {
                if (debug4 === "verbose")
                  console.warn("Assigned texture level is already higher: ", assignedLOD.level, level, material, assigned, tex);
                return null;
              }
            }
            material[slot] = tex;
          }
          if (debug4 && slot && material) {
            const lodinfo = this.getAssignedLODInformation(current);
            if (lodinfo)
              registerDebug(material, slot, lodinfo.url);
          }
        }
        return tex;
      } else if (debug4 == "verbose") {
        console.warn("No LOD found for", current, level);
      }
      return null;
    }).catch((err) => {
      console.error("Error loading LOD", current, err);
      return null;
    });
  }
  afterRoot(gltf) {
    var _a2, _b;
    if (debug4)
      console.log("AFTER", this.url, gltf);
    (_a2 = this.parser.json.textures) == null ? void 0 : _a2.forEach((textureInfo, index) => {
      var _a3;
      if (textureInfo == null ? void 0 : textureInfo.extensions) {
        const ext = textureInfo == null ? void 0 : textureInfo.extensions[EXTENSION_NAME];
        if (ext) {
          if (!ext.lods) {
            if (debug4)
              console.warn("Texture has no LODs", ext);
            return;
          }
          let found = false;
          for (const key of this.parser.associations.keys()) {
            if (key.isTexture === true) {
              const val = this.parser.associations.get(key);
              if ((val == null ? void 0 : val.textures) === index) {
                found = true;
                _NEEDLE_progressive.registerTexture(this.url, key, (_a3 = ext.lods) == null ? void 0 : _a3.length, index, ext);
              }
            }
          }
          if (!found) {
            this.parser.getDependency("texture", index).then((tex) => {
              var _a4;
              if (tex) {
                _NEEDLE_progressive.registerTexture(this.url, tex, (_a4 = ext.lods) == null ? void 0 : _a4.length, index, ext);
              }
            });
          }
        }
      }
    });
    (_b = this.parser.json.meshes) == null ? void 0 : _b.forEach((meshInfo, index) => {
      if (meshInfo == null ? void 0 : meshInfo.extensions) {
        const ext = meshInfo == null ? void 0 : meshInfo.extensions[EXTENSION_NAME];
        if (ext && ext.lods) {
          let found = false;
          for (const entry of this.parser.associations.keys()) {
            if (entry.isMesh) {
              const val = this.parser.associations.get(entry);
              if ((val == null ? void 0 : val.meshes) === index) {
                found = true;
                _NEEDLE_progressive.registerMesh(this.url, ext.guid, entry, ext.lods.length, val.primitives, ext);
              }
            }
          }
        }
      }
    });
    return null;
  }
  static async getOrLoadLOD(current, level) {
    var _a2, _b, _c, _d;
    const debugverbose = debug4 == "verbose";
    const LOD3 = current.userData.LODS;
    if (!LOD3) {
      return null;
    }
    const LODKEY = LOD3 == null ? void 0 : LOD3.key;
    let progressiveInfo;
    if (current.isTexture === true) {
      const tex = current;
      if (tex.source && tex.source[$progressiveTextureExtension])
        progressiveInfo = tex.source[$progressiveTextureExtension];
    }
    if (!progressiveInfo)
      progressiveInfo = _NEEDLE_progressive.lodInfos.get(LODKEY);
    if (progressiveInfo) {
      if (level > 0) {
        let useLowRes = false;
        const hasMultipleLevels = Array.isArray(progressiveInfo.lods);
        if (hasMultipleLevels && level >= progressiveInfo.lods.length) {
          useLowRes = true;
        } else if (!hasMultipleLevels) {
          useLowRes = true;
        }
        if (useLowRes) {
          const lowres = this.lowresCache.get(LODKEY);
          return lowres;
        }
      }
      const unresolved_lod_url = Array.isArray(progressiveInfo.lods) ? (_a2 = progressiveInfo.lods[level]) == null ? void 0 : _a2.path : progressiveInfo.lods;
      if (!unresolved_lod_url) {
        if (debug4 && !progressiveInfo["missing:uri"]) {
          progressiveInfo["missing:uri"] = true;
          console.warn("Missing uri for progressive asset for LOD " + level, progressiveInfo);
        }
        return null;
      }
      const lod_url = resolveUrl2(LOD3.url, unresolved_lod_url);
      if (lod_url.endsWith(".glb") || lod_url.endsWith(".gltf")) {
        if (!progressiveInfo.guid) {
          console.warn("missing pointer for glb/gltf texture", progressiveInfo);
          return null;
        }
        const KEY = lod_url + "_" + progressiveInfo.guid;
        const existing = this.previouslyLoaded.get(KEY);
        if (existing !== void 0) {
          if (debugverbose)
            console.log(`LOD ${level} was already loading/loaded: ${KEY}`);
          let res2 = await existing.catch((err) => {
            console.error(`Error loading LOD ${level} from ${lod_url}
`, err);
            return null;
          });
          let resouceIsDisposed = false;
          if (res2 == null) {
          } else if (res2 instanceof Texture && current instanceof Texture) {
            if (((_b = res2.image) == null ? void 0 : _b.data) || ((_c = res2.source) == null ? void 0 : _c.data)) {
              res2 = this.copySettings(current, res2);
            } else {
              resouceIsDisposed = true;
              this.previouslyLoaded.delete(KEY);
            }
          } else if (res2 instanceof BufferGeometry && current instanceof BufferGeometry) {
            if ((_d = res2.attributes.position) == null ? void 0 : _d.array) {
            } else {
              resouceIsDisposed = true;
              this.previouslyLoaded.delete(KEY);
            }
          }
          if (!resouceIsDisposed) {
            return res2;
          }
        }
        const ext = progressiveInfo;
        const request = new Promise(async (resolve2, _) => {
          const loader2 = new GLTFLoader();
          addDracoAndKTX2Loaders(loader2);
          if (debug4) {
            await new Promise((resolve3) => setTimeout(resolve3, 1e3));
            if (debugverbose)
              console.warn("Start loading (delayed) " + lod_url, ext.guid);
          }
          let url = lod_url;
          if (ext && Array.isArray(ext.lods)) {
            const lodinfo = ext.lods[level];
            if (lodinfo.hash) {
              url += "?v=" + lodinfo.hash;
            }
          }
          const gltf = await loader2.loadAsync(url).catch((err) => {
            console.error(`Error loading LOD ${level} from ${lod_url}
`, err);
            return null;
          });
          if (!gltf)
            return null;
          const parser = gltf.parser;
          if (debugverbose)
            console.log("Loading finished " + lod_url, ext.guid);
          let index = 0;
          if (gltf.parser.json.textures) {
            let found = false;
            for (const tex of gltf.parser.json.textures) {
              if (tex == null ? void 0 : tex.extensions) {
                const other = tex == null ? void 0 : tex.extensions[EXTENSION_NAME];
                if (other == null ? void 0 : other.guid) {
                  if (other.guid === ext.guid) {
                    found = true;
                    break;
                  }
                }
              }
              index++;
            }
            if (found) {
              let tex = await parser.getDependency("texture", index);
              if (tex) {
                _NEEDLE_progressive.assignLODInformation(LOD3.url, tex, LODKEY, level, void 0, void 0);
              }
              if (debugverbose)
                console.log('change "' + current.name + '" → "' + tex.name + '"', lod_url, index, tex, KEY);
              if (current instanceof Texture)
                tex = this.copySettings(current, tex);
              if (tex) {
                tex.guid = ext.guid;
              }
              return resolve2(tex);
            } else if (debug4) {
              console.warn("Could not find texture with guid", ext.guid, gltf.parser.json);
            }
          }
          index = 0;
          if (gltf.parser.json.meshes) {
            let found = false;
            for (const mesh of gltf.parser.json.meshes) {
              if (mesh == null ? void 0 : mesh.extensions) {
                const other = mesh == null ? void 0 : mesh.extensions[EXTENSION_NAME];
                if (other == null ? void 0 : other.guid) {
                  if (other.guid === ext.guid) {
                    found = true;
                    break;
                  }
                }
              }
              index++;
            }
            if (found) {
              const mesh = await parser.getDependency("mesh", index);
              const meshExt = ext;
              if (debugverbose)
                console.log(`Loaded Mesh "${mesh.name}"`, lod_url, index, mesh, KEY);
              if (mesh.isMesh === true) {
                const geo = mesh.geometry;
                _NEEDLE_progressive.assignLODInformation(LOD3.url, geo, LODKEY, level, void 0, meshExt.density);
                return resolve2(geo);
              } else {
                const geometries = new Array();
                for (let i = 0; i < mesh.children.length; i++) {
                  const child = mesh.children[i];
                  if (child.isMesh === true) {
                    const geo = child.geometry;
                    _NEEDLE_progressive.assignLODInformation(LOD3.url, geo, LODKEY, level, i, meshExt.density);
                    geometries.push(geo);
                  }
                }
                return resolve2(geometries);
              }
            } else if (debug4) {
              console.warn("Could not find mesh with guid", ext.guid, gltf.parser.json);
            }
          }
          return resolve2(null);
        });
        this.previouslyLoaded.set(KEY, request);
        const res = await request;
        return res;
      } else {
        if (current instanceof Texture) {
          if (debugverbose)
            console.log("Load texture from uri: " + lod_url);
          const loader2 = new TextureLoader();
          const tex = await loader2.loadAsync(lod_url);
          if (tex) {
            tex.guid = progressiveInfo.guid;
            tex.flipY = false;
            tex.needsUpdate = true;
            tex.colorSpace = current.colorSpace;
            if (debugverbose)
              console.log(progressiveInfo, tex);
          } else if (debug4)
            console.warn("failed loading", lod_url);
          return tex;
        }
      }
    } else {
      if (debug4)
        console.warn(`Can not load LOD ${level}: no LOD info found for "${LODKEY}" ${current.name}`, current.type);
    }
    return null;
  }
  static assignLODInformation(url, res, key, level, index, density) {
    if (!res)
      return;
    if (!res.userData)
      res.userData = {};
    const info = new LODInformation(url, key, level, index, density);
    res.userData.LODS = info;
  }
  static getAssignedLODInformation(res) {
    var _a2;
    return ((_a2 = res == null ? void 0 : res.userData) == null ? void 0 : _a2.LODS) || null;
  }
  // private static readonly _copiedTextures: WeakMap<Texture, Texture> = new Map();
  static copySettings(source, target) {
    {
      target = target.clone();
      if (debug4)
        console.warn("Copying texture settings\n", source.uuid, "\n", target.uuid);
    }
    target.offset = source.offset;
    target.repeat = source.repeat;
    target.colorSpace = source.colorSpace;
    target.magFilter = source.magFilter;
    target.minFilter = source.minFilter;
    target.wrapS = source.wrapS;
    target.wrapT = source.wrapT;
    target.flipY = source.flipY;
    target.anisotropy = source.anisotropy;
    if (!target.mipmaps)
      target.generateMipmaps = source.generateMipmaps;
    return target;
  }
};
var NEEDLE_progressive = _NEEDLE_progressive;
/**
 * Register a texture with LOD information
 */
__publicField(NEEDLE_progressive, "registerTexture", (url, tex, level, index, ext) => {
  if (debug4)
    console.log("> Progressive: register texture", index, tex.name, tex.uuid, tex, ext);
  if (!tex) {
    if (debug4)
      console.error("gltf-progressive: Register texture without texture");
    return;
  }
  if (tex.source)
    tex.source[$progressiveTextureExtension] = ext;
  const LODKEY = ext.guid;
  _NEEDLE_progressive.assignLODInformation(url, tex, LODKEY, level, index, void 0);
  _NEEDLE_progressive.lodInfos.set(LODKEY, ext);
  _NEEDLE_progressive.lowresCache.set(LODKEY, tex);
});
/**
 * Register a mesh with LOD information
 */
__publicField(NEEDLE_progressive, "registerMesh", (url, key, mesh, level, index, ext) => {
  var _a2;
  if (debug4)
    console.log("> Progressive: register mesh", index, mesh.name, ext, mesh.uuid, mesh);
  const geometry = mesh.geometry;
  if (!geometry) {
    if (debug4)
      console.warn("gltf-progressive: Register mesh without geometry");
    return;
  }
  if (!geometry.userData)
    geometry.userData = {};
  _NEEDLE_progressive.assignLODInformation(url, geometry, key, level, index, ext.density);
  _NEEDLE_progressive.lodInfos.set(key, ext);
  let existing = _NEEDLE_progressive.lowresCache.get(key);
  if (existing)
    existing.push(mesh.geometry);
  else
    existing = [mesh.geometry];
  _NEEDLE_progressive.lowresCache.set(key, existing);
  if (level > 0 && !getRaycastMesh(mesh)) {
    registerRaycastMesh(mesh, geometry);
  }
  for (const plugin of plugins) {
    (_a2 = plugin.onRegisteredNewMesh) == null ? void 0 : _a2.call(plugin, mesh, ext);
  }
});
/** A map of key = asset uuid and value = LOD information */
__publicField(NEEDLE_progressive, "lodInfos", /* @__PURE__ */ new Map());
/** cache of already loaded mesh lods */
__publicField(NEEDLE_progressive, "previouslyLoaded", /* @__PURE__ */ new Map());
/** this contains the geometry/textures that were originally loaded */
__publicField(NEEDLE_progressive, "lowresCache", /* @__PURE__ */ new Map());
var LODInformation = class {
  constructor(url, key, level, index, density) {
    __publicField(this, "url");
    /** the key to lookup the LOD information */
    __publicField(this, "key");
    __publicField(this, "level");
    /** For multi objects (e.g. a group of meshes) this is the index of the object */
    __publicField(this, "index");
    /** the mesh density */
    __publicField(this, "density");
    this.url = url;
    this.key = key;
    this.level = level;
    if (index != void 0)
      this.index = index;
    if (density != void 0)
      this.density = density;
  }
};

// node_modules/@needle-tools/gltf-progressive/lib/lods_manager.js
var debugProgressiveLoading = getParam2("debugprogressive");
var suppressProgressiveLoading = getParam2("noprogressive");
var $lodsManager = Symbol("Needle:LODSManager");
var $lodstate = Symbol("Needle:LODState");
var $currentLOD = Symbol("Needle:CurrentLOD");
var levels = { mesh_lod: -1, texture_lod: -1 };
var _updateInterval, _originalRender, _clock, _frame, _delta, _time, _fps;
var _LODsManager = class {
  // readonly plugins: NEEDLE_progressive_plugin[] = [];
  constructor(renderer, context) {
    __publicField(this, "context");
    __publicField(this, "renderer");
    __publicField(this, "projectionScreenMatrix", new Matrix4());
    /**
     * The target triangle density is the desired max amount of triangles on screen when the mesh is filling the screen.
     * @default 200_000
     */
    __publicField(this, "targetTriangleDensity", 2e5);
    /**
     * The update interval in frames. If set to 0, the LODs will be updated every frame. If set to 2, the LODs will be updated every second frame, etc.
     * @default "auto"
     */
    __publicField(this, "updateInterval", "auto");
    __privateAdd(this, _updateInterval, 1);
    /**
     * If set to true, the LODsManager will not update the LODs.
     * @default false
     */
    __publicField(this, "pause", false);
    /**
     * When set to true the LODsManager will not update the LODs. This can be used to manually update the LODs using the `update` method.
     * Otherwise the LODs will be updated automatically when the renderer renders the scene.
     * @default false
     */
    __publicField(this, "manual", false);
    __publicField(this, "_lodchangedlisteners", []);
    __privateAdd(this, _originalRender, void 0);
    __privateAdd(this, _clock, new Clock());
    __privateAdd(this, _frame, 0);
    __privateAdd(this, _delta, 0);
    __privateAdd(this, _time, 0);
    __privateAdd(this, _fps, 0);
    __publicField(this, "_fpsBuffer", [60, 60, 60, 60, 60]);
    // private testIfLODLevelsAreAvailable() {
    __publicField(this, "_sphere", new Sphere());
    __publicField(this, "_tempBox", new Box3());
    __publicField(this, "_tempBox2", new Box3());
    __publicField(this, "tempMatrix", new Matrix4());
    __publicField(this, "_tempWorldPosition", new Vector32());
    __publicField(this, "_tempBoxSize", new Vector32());
    __publicField(this, "_tempBox2Size", new Vector32());
    this.renderer = renderer;
    this.context = { ...context };
  }
  /** @internal */
  static getObjectLODState(object) {
    return object[$lodstate];
  }
  static addPlugin(plugin) {
    plugins.push(plugin);
  }
  static removePlugin(plugin) {
    const index = plugins.indexOf(plugin);
    if (index >= 0)
      plugins.splice(index, 1);
  }
  /**
   * Gets the LODsManager for the given renderer. If the LODsManager does not exist yet, it will be created.
   * @param renderer The renderer to get the LODsManager for.
   * @returns The LODsManager instance.
   */
  static get(renderer, context) {
    if (renderer[$lodsManager]) {
      console.debug("[gltf-progressive] LODsManager already exists for this renderer");
      return renderer[$lodsManager];
    }
    const lodsManager = new _LODsManager(renderer, {
      engine: "unknown",
      ...context
    });
    renderer[$lodsManager] = lodsManager;
    return lodsManager;
  }
  /** @deprecated use static `LODsManager.addPlugin()` method. This getter will be removed in later versions */
  get plugins() {
    return plugins;
  }
  addEventListener(evt, listener) {
    if (evt === "changed") {
      this._lodchangedlisteners.push(listener);
    }
  }
  removeEventListener(evt, listener) {
    if (evt === "changed") {
      const index = this._lodchangedlisteners.indexOf(listener);
      if (index >= 0)
        this._lodchangedlisteners.splice(index, 1);
    }
  }
  /**
   * Enable the LODsManager. This will replace the render method of the renderer with a method that updates the LODs.
   */
  enable() {
    if (__privateGet(this, _originalRender))
      return;
    console.debug("[gltf-progressive] Enabling LODsManager for renderer");
    let stack = 0;
    __privateSet(this, _originalRender, this.renderer.render);
    const self2 = this;
    createLoaders(this.renderer);
    this.renderer.render = function(scene, camera) {
      const renderTarget2 = self2.renderer.getRenderTarget();
      if (renderTarget2 == null || "isXRRenderTarget" in renderTarget2 && renderTarget2.isXRRenderTarget) {
        stack = 0;
        __privateSet(self2, _frame, __privateGet(self2, _frame) + 1);
        __privateSet(self2, _delta, __privateGet(self2, _clock).getDelta());
        __privateSet(self2, _time, __privateGet(self2, _time) + __privateGet(self2, _delta));
        self2._fpsBuffer.shift();
        self2._fpsBuffer.push(1 / __privateGet(self2, _delta));
        __privateSet(self2, _fps, self2._fpsBuffer.reduce((a, b) => a + b) / self2._fpsBuffer.length);
        if (debugProgressiveLoading && __privateGet(self2, _frame) % 200 === 0)
          console.log("FPS", Math.round(__privateGet(self2, _fps)), "Interval:", __privateGet(self2, _updateInterval));
      }
      const stack_level = stack++;
      __privateGet(self2, _originalRender).call(this, scene, camera);
      self2.onAfterRender(scene, camera, stack_level);
    };
  }
  disable() {
    if (!__privateGet(this, _originalRender))
      return;
    console.debug("[gltf-progressive] Disabling LODsManager for renderer");
    this.renderer.render = __privateGet(this, _originalRender);
    __privateSet(this, _originalRender, void 0);
  }
  update(scene, camera) {
    this.internalUpdate(scene, camera);
  }
  onAfterRender(scene, camera, _stack) {
    if (this.pause)
      return;
    const renderList = this.renderer.renderLists.get(scene, 0);
    const opaque = renderList.opaque;
    let updateLODs = true;
    if (opaque.length === 1) {
      const material = opaque[0].material;
      if (material.name === "EffectMaterial") {
        updateLODs = false;
      } else if (material.name === "CopyShader") {
        updateLODs = false;
      }
    }
    if (camera.parent && camera.parent.type === "CubeCamera") {
      updateLODs = false;
    } else if (_stack >= 1) {
      if (camera.type === "OrthographicCamera") {
        updateLODs = false;
      }
    }
    if (updateLODs) {
      if (suppressProgressiveLoading)
        return;
      if (this.updateInterval === "auto") {
        if (__privateGet(this, _fps) < 40 && __privateGet(this, _updateInterval) < 10) {
          __privateSet(this, _updateInterval, __privateGet(this, _updateInterval) + 1);
          if (debugProgressiveLoading)
            console.warn("↓ Reducing LOD updates", __privateGet(this, _updateInterval), __privateGet(this, _fps).toFixed(0));
        } else if (__privateGet(this, _fps) >= 60 && __privateGet(this, _updateInterval) > 1) {
          __privateSet(this, _updateInterval, __privateGet(this, _updateInterval) - 1);
          if (debugProgressiveLoading)
            console.warn("↑ Increasing LOD updates", __privateGet(this, _updateInterval), __privateGet(this, _fps).toFixed(0));
        }
      } else {
        __privateSet(this, _updateInterval, this.updateInterval);
      }
      if (__privateGet(this, _updateInterval) > 0 && __privateGet(this, _frame) % __privateGet(this, _updateInterval) != 0) {
        return;
      }
      this.internalUpdate(scene, camera);
    }
  }
  /**
   * Update LODs in a scene
   */
  internalUpdate(scene, camera) {
    var _a2, _b;
    const renderList = this.renderer.renderLists.get(scene, 0);
    const opaque = renderList.opaque;
    this.projectionScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    const desiredDensity = this.targetTriangleDensity;
    for (const entry of opaque) {
      if (entry.material && (((_a2 = entry.geometry) == null ? void 0 : _a2.type) === "BoxGeometry" || ((_b = entry.geometry) == null ? void 0 : _b.type) === "BufferGeometry")) {
        if (entry.material.name === "SphericalGaussianBlur" || entry.material.name == "BackgroundCubeMaterial" || entry.material.name === "CubemapFromEquirect" || entry.material.name === "EquirectangularToCubeUV") {
          if (debugProgressiveLoading) {
            if (!entry.material["NEEDLE_PROGRESSIVE:IGNORE-WARNING"]) {
              entry.material["NEEDLE_PROGRESSIVE:IGNORE-WARNING"] = true;
              console.warn("Ignoring skybox or BLIT object", entry, entry.material.name, entry.material.type);
            }
          }
          continue;
        }
      }
      switch (entry.material.type) {
        case "LineBasicMaterial":
        case "LineDashedMaterial":
        case "PointsMaterial":
        case "ShadowMaterial":
        case "MeshDistanceMaterial":
        case "MeshDepthMaterial":
          continue;
      }
      if (debugProgressiveLoading === "color") {
        if (entry.material) {
          if (!entry.object["progressive_debug_color"]) {
            entry.object["progressive_debug_color"] = true;
            const randomColor = Math.random() * 16777215;
            const newMaterial = new MeshStandardMaterial({ color: randomColor });
            entry.object.material = newMaterial;
          }
        }
      }
      const object = entry.object;
      if (object instanceof Mesh || object.isMesh) {
        this.updateLODs(scene, camera, object, desiredDensity);
      }
    }
    const transparent = renderList.transparent;
    for (const entry of transparent) {
      const object = entry.object;
      if (object instanceof Mesh || object.isMesh) {
        this.updateLODs(scene, camera, object, desiredDensity);
      }
    }
    const transmissive = renderList.transmissive;
    for (const entry of transmissive) {
      const object = entry.object;
      if (object instanceof Mesh || object.isMesh) {
        this.updateLODs(scene, camera, object, desiredDensity);
      }
    }
  }
  /** Update the LOD levels for the renderer. */
  updateLODs(scene, camera, object, desiredDensity) {
    var _a2, _b;
    if (!object.userData) {
      object.userData = {};
    }
    let state = object[$lodstate];
    if (!state) {
      state = new LOD_state();
      object[$lodstate] = state;
    }
    if (state.frames++ < 2) {
      return;
    }
    for (const plugin of plugins) {
      (_a2 = plugin.onBeforeUpdateLOD) == null ? void 0 : _a2.call(plugin, this.renderer, scene, camera, object);
    }
    this.calculateLodLevel(camera, object, state, desiredDensity, levels);
    levels.mesh_lod = Math.round(levels.mesh_lod);
    levels.texture_lod = Math.round(levels.texture_lod);
    if (levels.mesh_lod >= 0) {
      this.loadProgressiveMeshes(object, levels.mesh_lod);
    }
    let textureLOD = levels.texture_lod;
    if (object.material && textureLOD >= 0) {
      const debugLevel = object["DEBUG:LOD"];
      if (debugLevel != void 0)
        textureLOD = debugLevel;
      this.loadProgressiveTextures(object.material, textureLOD);
    }
    for (const plugin of plugins) {
      (_b = plugin.onAfterUpdatedLOD) == null ? void 0 : _b.call(plugin, this.renderer, scene, camera, object, levels);
    }
    state.lastLodLevel_Mesh = levels.mesh_lod;
    state.lastLodLevel_Texture = levels.texture_lod;
  }
  /** Load progressive textures for the given material
   * @param material the material to load the textures for
   * @param level the LOD level to load. Level 0 is the best quality, higher levels are lower quality
   * @returns Promise with true if the LOD was loaded, false if not
   */
  loadProgressiveTextures(material, level) {
    if (!material)
      return;
    if (Array.isArray(material)) {
      for (const mat of material) {
        this.loadProgressiveTextures(mat, level);
      }
      return;
    }
    let update2 = false;
    if (material[$currentLOD] === void 0) {
      update2 = true;
    } else if (level < material[$currentLOD]) {
      update2 = true;
    }
    if (update2) {
      material[$currentLOD] = level;
      NEEDLE_progressive.assignTextureLOD(material, level).then((_) => {
        this._lodchangedlisteners.forEach((l) => l({ type: "texture", level, object: material }));
      });
    }
  }
  /** Load progressive meshes for the given mesh
   * @param mesh the mesh to load the LOD for
   * @param index the index of the mesh if it's part of a group
   * @param level the LOD level to load. Level 0 is the best quality, higher levels are lower quality
   * @returns Promise with true if the LOD was loaded, false if not
   */
  loadProgressiveMeshes(mesh, level) {
    if (!mesh)
      return Promise.resolve(null);
    if (mesh[$currentLOD] !== level) {
      mesh[$currentLOD] = level;
      const originalGeometry = mesh.geometry;
      return NEEDLE_progressive.assignMeshLOD(mesh, level).then((res) => {
        if (res && mesh[$currentLOD] == level && originalGeometry != mesh.geometry) {
          this._lodchangedlisteners.forEach((l) => l({ type: "mesh", level, object: mesh }));
        }
        return res;
      });
    }
    return Promise.resolve(null);
  }
  static isInside(box2, matrix) {
    const min = box2.min;
    const max = box2.max;
    const centerx = (min.x + max.x) * 0.5;
    const centery = (min.y + max.y) * 0.5;
    const pt1 = this._tempPtInside.set(centerx, centery, min.z).applyMatrix4(matrix);
    return pt1.z < 0;
  }
  calculateLodLevel(camera, mesh, state, desiredDensity, result) {
    var _a2;
    if (!mesh) {
      result.mesh_lod = -1;
      result.texture_lod = -1;
      return;
    }
    if (!camera) {
      result.mesh_lod = -1;
      result.texture_lod = -1;
      return;
    }
    const maxLevel = 10;
    let mesh_level = maxLevel + 1;
    let mesh_level_calculated = false;
    if (debugProgressiveLoading && mesh["DEBUG:LOD"] != void 0) {
      return mesh["DEBUG:LOD"];
    }
    const mesh_lods_info = NEEDLE_progressive.getMeshLODInformation(mesh.geometry);
    const mesh_lods = mesh_lods_info == null ? void 0 : mesh_lods_info.lods;
    const has_mesh_lods = mesh_lods && mesh_lods.length > 0;
    const texture_lods_minmax = NEEDLE_progressive.getMaterialMinMaxLODsCount(mesh.material);
    const has_texture_lods = (texture_lods_minmax == null ? void 0 : texture_lods_minmax.min_count) != Infinity && texture_lods_minmax.min_count > 0 && texture_lods_minmax.max_count > 0;
    if (!has_mesh_lods && !has_texture_lods) {
      result.mesh_lod = 0;
      result.texture_lod = 0;
      return;
    }
    if (!has_mesh_lods) {
      mesh_level_calculated = true;
      mesh_level = 0;
    }
    const canvasHeight = this.renderer.domElement.clientHeight || this.renderer.domElement.height;
    let boundingBox = mesh.geometry.boundingBox;
    if (mesh.type === "SkinnedMesh") {
      const skinnedMesh = mesh;
      if (!skinnedMesh.boundingBox) {
        skinnedMesh.computeBoundingBox();
      } else if (state.frames % 30 === 0) {
        const raycastmesh = getRaycastMesh(skinnedMesh);
        const originalGeometry = skinnedMesh.geometry;
        if (raycastmesh) {
          skinnedMesh.geometry = raycastmesh;
        }
        skinnedMesh.computeBoundingBox();
        skinnedMesh.geometry = originalGeometry;
      }
      boundingBox = skinnedMesh.boundingBox;
    }
    if (boundingBox && camera.isPerspectiveCamera) {
      const cam = camera;
      if (mesh.geometry.attributes.color && mesh.geometry.attributes.color.count < 100) {
        if (mesh.geometry.boundingSphere) {
          this._sphere.copy(mesh.geometry.boundingSphere);
          this._sphere.applyMatrix4(mesh.matrixWorld);
          const worldPosition = camera.getWorldPosition(this._tempWorldPosition);
          if (this._sphere.containsPoint(worldPosition)) {
            result.mesh_lod = 0;
            result.texture_lod = 0;
            return;
          }
        }
      }
      this._tempBox.copy(boundingBox);
      this._tempBox.applyMatrix4(mesh.matrixWorld);
      if (_LODsManager.isInside(this._tempBox, this.projectionScreenMatrix)) {
        result.mesh_lod = 0;
        result.texture_lod = 0;
        return;
      }
      this._tempBox.applyMatrix4(this.projectionScreenMatrix);
      if (this.renderer.xr.enabled && cam.fov > 70) {
        const min = this._tempBox.min;
        const max = this._tempBox.max;
        let minX = min.x;
        let minY = min.y;
        let maxX = max.x;
        let maxY = max.y;
        const enlargementFactor = 2;
        const centerBoost = 1.5;
        const centerX = (min.x + max.x) * 0.5;
        const centerY = (min.y + max.y) * 0.5;
        minX = (minX - centerX) * enlargementFactor + centerX;
        minY = (minY - centerY) * enlargementFactor + centerY;
        maxX = (maxX - centerX) * enlargementFactor + centerX;
        maxY = (maxY - centerY) * enlargementFactor + centerY;
        const xCentrality = minX < 0 && maxX > 0 ? 0 : Math.min(Math.abs(min.x), Math.abs(max.x));
        const yCentrality = minY < 0 && maxY > 0 ? 0 : Math.min(Math.abs(min.y), Math.abs(max.y));
        const centrality = Math.max(xCentrality, yCentrality);
        state.lastCentrality = (centerBoost - centrality) * (centerBoost - centrality) * (centerBoost - centrality);
      } else {
        state.lastCentrality = 1;
      }
      const boxSize = this._tempBox.getSize(this._tempBoxSize);
      boxSize.multiplyScalar(0.5);
      if (screen.availHeight > 0) {
        if (canvasHeight > 0)
          boxSize.multiplyScalar(canvasHeight / screen.availHeight);
      }
      boxSize.x *= cam.aspect;
      const matView = camera.matrixWorldInverse;
      const box2 = this._tempBox2;
      box2.copy(boundingBox);
      box2.applyMatrix4(mesh.matrixWorld);
      box2.applyMatrix4(matView);
      const boxSize2 = box2.getSize(this._tempBox2Size);
      const max2 = Math.max(boxSize2.x, boxSize2.y);
      const max1 = Math.max(boxSize.x, boxSize.y);
      if (max1 != 0 && max2 != 0)
        boxSize.z = boxSize2.z / Math.max(boxSize2.x, boxSize2.y) * Math.max(boxSize.x, boxSize.y);
      state.lastScreenCoverage = Math.max(boxSize.x, boxSize.y, boxSize.z);
      state.lastScreenspaceVolume.copy(boxSize);
      state.lastScreenCoverage *= state.lastCentrality;
      if (debugProgressiveLoading && _LODsManager.debugDrawLine) {
        const mat = this.tempMatrix.copy(this.projectionScreenMatrix);
        mat.invert();
        const corner0 = _LODsManager.corner0;
        const corner1 = _LODsManager.corner1;
        const corner2 = _LODsManager.corner2;
        const corner3 = _LODsManager.corner3;
        corner0.copy(this._tempBox.min);
        corner1.copy(this._tempBox.max);
        corner1.x = corner0.x;
        corner2.copy(this._tempBox.max);
        corner2.y = corner0.y;
        corner3.copy(this._tempBox.max);
        const z = (corner0.z + corner3.z) * 0.5;
        corner0.z = corner1.z = corner2.z = corner3.z = z;
        corner0.applyMatrix4(mat);
        corner1.applyMatrix4(mat);
        corner2.applyMatrix4(mat);
        corner3.applyMatrix4(mat);
        _LODsManager.debugDrawLine(corner0, corner1, 255);
        _LODsManager.debugDrawLine(corner0, corner2, 255);
        _LODsManager.debugDrawLine(corner1, corner3, 255);
        _LODsManager.debugDrawLine(corner2, corner3, 255);
      }
      let expectedLevel = 999;
      if (mesh_lods && state.lastScreenCoverage > 0) {
        for (let l = 0; l < mesh_lods.length; l++) {
          const densityForThisLevel = mesh_lods[l].density;
          const resultingDensity = densityForThisLevel / state.lastScreenCoverage;
          if (resultingDensity < desiredDensity) {
            expectedLevel = l;
            break;
          }
        }
      }
      const isLowerLod = expectedLevel < mesh_level;
      if (isLowerLod) {
        mesh_level = expectedLevel;
        mesh_level_calculated = true;
      }
    }
    if (mesh_level_calculated) {
      result.mesh_lod = mesh_level;
    } else {
      result.mesh_lod = state.lastLodLevel_Mesh;
    }
    if (debugProgressiveLoading) {
      const changed = result.mesh_lod != state.lastLodLevel_Mesh;
      if (changed) {
        const level = mesh_lods == null ? void 0 : mesh_lods[result.mesh_lod];
        if (level) {
          console.log(`Mesh LOD changed: ${state.lastLodLevel_Mesh} → ${result.mesh_lod} (${level.density.toFixed(0)}) - ${mesh.name}`);
        }
      }
    }
    if (has_texture_lods) {
      const saveDataEnabled = "saveData" in globalThis.navigator && globalThis.navigator.saveData === true;
      if (state.lastLodLevel_Texture < 0) {
        result.texture_lod = texture_lods_minmax.max_count - 1;
        if (debugProgressiveLoading) {
          const level = texture_lods_minmax.lods[texture_lods_minmax.max_count - 1];
          if (debugProgressiveLoading)
            console.log(`First Texture LOD ${result.texture_lod} (${level.max_height}px) - ${mesh.name}`);
        }
      } else {
        const volume = state.lastScreenspaceVolume.x + state.lastScreenspaceVolume.y + state.lastScreenspaceVolume.z;
        let factor = state.lastScreenCoverage * 4;
        if (((_a2 = this.context) == null ? void 0 : _a2.engine) === "model-viewer") {
          factor *= 1.5;
        }
        const screenSize = canvasHeight / window.devicePixelRatio;
        const pixelSizeOnScreen = screenSize * factor;
        for (let i = texture_lods_minmax.lods.length - 1; i >= 0; i--) {
          let lod = texture_lods_minmax.lods[i];
          if (saveDataEnabled && lod.max_height >= 2048) {
            continue;
          }
          if (isMobileDevice2() && lod.max_height > 4096)
            continue;
          if (lod.max_height > pixelSizeOnScreen) {
            result.texture_lod = i;
            if (result.texture_lod < state.lastLodLevel_Texture) {
              const lod_pixel_height = lod.max_height;
              if (debugProgressiveLoading)
                console.log(`Texture LOD changed: ${state.lastLodLevel_Texture} → ${result.texture_lod} = ${lod_pixel_height}px 
Screensize: ${pixelSizeOnScreen.toFixed(0)}px, Coverage: ${(100 * state.lastScreenCoverage).toFixed(2)}%, Volume ${volume.toFixed(1)} 
${mesh.name}`);
            }
            break;
          }
        }
      }
    } else {
      result.texture_lod = 0;
    }
  }
};
var LODsManager = _LODsManager;
_updateInterval = new WeakMap();
_originalRender = new WeakMap();
_clock = new WeakMap();
_frame = new WeakMap();
_delta = new WeakMap();
_time = new WeakMap();
_fps = new WeakMap();
/** Assign a function to draw debug lines for the LODs. This function will be called with the start and end position of the line and the color of the line when the `debugprogressive` query parameter is set.
 */
__publicField(LODsManager, "debugDrawLine");
__publicField(LODsManager, "corner0", new Vector32());
__publicField(LODsManager, "corner1", new Vector32());
__publicField(LODsManager, "corner2", new Vector32());
__publicField(LODsManager, "corner3", new Vector32());
__publicField(LODsManager, "_tempPtInside", new Vector32());
var LOD_state = class {
  constructor() {
    __publicField(this, "frames", 0);
    __publicField(this, "lastLodLevel_Mesh", -1);
    __publicField(this, "lastLodLevel_Texture", -1);
    __publicField(this, "lastScreenCoverage", 0);
    __publicField(this, "lastScreenspaceVolume", new Vector32());
    __publicField(this, "lastCentrality", 0);
  }
};

// node_modules/@needle-tools/gltf-progressive/lib/plugins/modelviewer.js
var $meshLODSymbol = Symbol("NEEDLE_mesh_lod");
var $textureLODSymbol = Symbol("NEEDLE_texture_lod");
var documentObserver = null;
function patchModelViewer() {
  const ModelViewerElement = tryGetModelViewerConstructor();
  if (!ModelViewerElement) {
    return;
  }
  ModelViewerElement.mapURLs(function(url) {
    searchModelViewers();
    return url;
  });
  searchModelViewers();
  documentObserver == null ? void 0 : documentObserver.disconnect();
  documentObserver = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      mutation.addedNodes.forEach((node) => {
        if (node instanceof HTMLElement && node.tagName.toLowerCase() === "model-viewer") {
          _patchModelViewer(node);
        }
      });
    });
  });
  documentObserver.observe(document, { childList: true, subtree: true });
}
function tryGetModelViewerConstructor() {
  if (typeof customElements === "undefined")
    return null;
  const ModelViewerElement = customElements.get("model-viewer");
  if (ModelViewerElement)
    return ModelViewerElement;
  customElements.whenDefined("model-viewer").then(() => {
    console.debug("[gltf-progressive] model-viewer defined");
    patchModelViewer();
  });
  return null;
}
function searchModelViewers() {
  if (typeof document === "undefined")
    return;
  const modelviewers = document.querySelectorAll("model-viewer");
  modelviewers.forEach((modelviewer) => {
    _patchModelViewer(modelviewer);
  });
}
var foundModelViewers = /* @__PURE__ */ new WeakSet();
var modelViewerCount = 0;
function _patchModelViewer(modelviewer) {
  if (!modelviewer)
    return null;
  if (foundModelViewers.has(modelviewer))
    return null;
  foundModelViewers.add(modelviewer);
  console.debug("[gltf-progressive] found new model-viewer..." + ++modelViewerCount + "\n", modelviewer.getAttribute("src"));
  let renderer = null;
  let scene = null;
  let needsRender = null;
  for (let p = modelviewer; p != null; p = Object.getPrototypeOf(p)) {
    const privateAPI = Object.getOwnPropertySymbols(p);
    const rendererSymbol = privateAPI.find((value) => value.toString() == "Symbol(renderer)");
    const sceneSymbol = privateAPI.find((value) => value.toString() == "Symbol(scene)");
    const needsRenderSymbol = privateAPI.find((value) => value.toString() == "Symbol(needsRender)");
    if (!renderer && rendererSymbol != null) {
      renderer = modelviewer[rendererSymbol].threeRenderer;
    }
    if (!scene && sceneSymbol != null) {
      scene = modelviewer[sceneSymbol];
    }
    if (!needsRender && needsRenderSymbol != null) {
      needsRender = modelviewer[needsRenderSymbol];
    }
  }
  if (renderer && scene) {
    let renderFrames = function() {
      if (needsRender) {
        let forcedFrames = 0;
        let interval = setInterval(() => {
          if (forcedFrames++ > 5) {
            clearInterval(interval);
            return;
          }
          needsRender == null ? void 0 : needsRender.call(modelviewer);
        }, 300);
      }
    };
    console.debug("[gltf-progressive] setup model-viewer");
    const lod = LODsManager.get(renderer, { engine: "model-viewer" });
    LODsManager.addPlugin(new RegisterModelviewerDataPlugin());
    lod.enable();
    lod.addEventListener("changed", () => {
      needsRender == null ? void 0 : needsRender.call(modelviewer);
    });
    modelviewer.addEventListener("model-visibility", (evt) => {
      const visible = evt.detail.visible;
      if (visible)
        needsRender == null ? void 0 : needsRender.call(modelviewer);
    });
    modelviewer.addEventListener("load", () => {
      renderFrames();
    });
    return () => {
      lod.disable();
    };
  }
  return null;
}
var RegisterModelviewerDataPlugin = class {
  constructor() {
    __publicField(this, "_didWarnAboutMissingUrl", false);
  }
  onBeforeUpdateLOD(_renderer3, scene, _camera2, object) {
    this.tryParseMeshLOD(scene, object);
    this.tryParseTextureLOD(scene, object);
  }
  getUrl(element) {
    if (!element) {
      return null;
    }
    let url = element.getAttribute("src");
    if (!url) {
      url = element["src"];
    }
    if (!url) {
      if (!this._didWarnAboutMissingUrl)
        console.warn("No url found in modelviewer", element);
      this._didWarnAboutMissingUrl = true;
    }
    return url;
  }
  tryGetCurrentGLTF(scene) {
    return scene._currentGLTF;
  }
  tryGetCurrentModelViewer(scene) {
    return scene.element;
  }
  tryParseTextureLOD(scene, object) {
    if (object[$textureLODSymbol] == true)
      return;
    object[$textureLODSymbol] = true;
    const currentGLTF = this.tryGetCurrentGLTF(scene);
    const element = this.tryGetCurrentModelViewer(scene);
    const url = this.getUrl(element);
    if (!url) {
      return;
    }
    if (currentGLTF) {
      if (object.material) {
        let handleMaterial = function(mat2) {
          var _a2, _b, _c;
          if (mat2[$textureLODSymbol] == true)
            return;
          mat2[$textureLODSymbol] = true;
          if (mat2.userData)
            mat2.userData.LOD = -1;
          const keys = Object.keys(mat2);
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            const value = mat2[key];
            if ((value == null ? void 0 : value.isTexture) === true) {
              const textureIndex = (_b = (_a2 = value.userData) == null ? void 0 : _a2.associations) == null ? void 0 : _b.textures;
              if (textureIndex == null)
                continue;
              const textureData = currentGLTF.parser.json.textures[textureIndex];
              if (!textureData) {
                console.warn("Texture data not found for texture index " + textureIndex);
                continue;
              }
              if ((_c = textureData == null ? void 0 : textureData.extensions) == null ? void 0 : _c[EXTENSION_NAME]) {
                const ext = textureData.extensions[EXTENSION_NAME];
                if (ext && url) {
                  NEEDLE_progressive.registerTexture(url, value, ext.lods.length, textureIndex, ext);
                }
              }
            }
          }
        };
        const mat = object.material;
        if (Array.isArray(mat))
          for (const m2 of mat)
            handleMaterial(m2);
        else
          handleMaterial(mat);
      }
    }
  }
  tryParseMeshLOD(scene, object) {
    var _a2, _b;
    if (object[$meshLODSymbol] == true)
      return;
    object[$meshLODSymbol] = true;
    const element = this.tryGetCurrentModelViewer(scene);
    const url = this.getUrl(element);
    if (!url) {
      return;
    }
    const ext = (_b = (_a2 = object.userData) == null ? void 0 : _a2["gltfExtensions"]) == null ? void 0 : _b[EXTENSION_NAME];
    if (ext && url) {
      const lodKey = object.uuid;
      NEEDLE_progressive.registerMesh(url, lodKey, object, 0, ext.lods.length, ext);
    }
  }
};

// node_modules/@needle-tools/gltf-progressive/lib/index.js
patchModelViewer();

// node_modules/@needle-tools/engine/lib/engine/xr/events.js
var onXRSessionStartListeners = [];
function onXRSessionStart(fn2) {
  if (onXRSessionStartListeners.indexOf(fn2) === -1) {
    onXRSessionStartListeners.push(fn2);
  }
}
function offXRSessionStart(fn2) {
  const index = onXRSessionStartListeners.indexOf(fn2);
  if (index !== -1) {
    onXRSessionStartListeners.splice(index, 1);
  }
}
var onXRSessionEndListeners = [];
function onXRSessionEnd(fn2) {
  if (onXRSessionEndListeners.indexOf(fn2) === -1) {
    onXRSessionEndListeners.push(fn2);
  }
}
function offXRSessionEnd(fn2) {
  const index = onXRSessionEndListeners.indexOf(fn2);
  if (index !== -1) {
    onXRSessionEndListeners.splice(index, 1);
  }
}
function invokeXRSessionStart(evt) {
  globalThis.dispatchEvent(new CustomEvent("needle-xrsession-start", { detail: evt }));
  for (let i = 0; i < onXRSessionStartListeners.length; i++) {
    onXRSessionStartListeners[i](evt);
  }
}
function invokeXRSessionEnd(evt) {
  globalThis.dispatchEvent(new CustomEvent("needle-xrsession-end", { detail: evt }));
  for (let i = 0; i < onXRSessionEndListeners.length; i++) {
    onXRSessionEndListeners[i](evt);
  }
}

// node_modules/@webxr-input-profiles/motion-controllers/dist/motion-controllers.module.js
var Constants = {
  Handedness: Object.freeze({
    NONE: "none",
    LEFT: "left",
    RIGHT: "right"
  }),
  ComponentState: Object.freeze({
    DEFAULT: "default",
    TOUCHED: "touched",
    PRESSED: "pressed"
  }),
  ComponentProperty: Object.freeze({
    BUTTON: "button",
    X_AXIS: "xAxis",
    Y_AXIS: "yAxis",
    STATE: "state"
  }),
  ComponentType: Object.freeze({
    TRIGGER: "trigger",
    SQUEEZE: "squeeze",
    TOUCHPAD: "touchpad",
    THUMBSTICK: "thumbstick",
    BUTTON: "button"
  }),
  ButtonTouchThreshold: 0.05,
  AxisTouchThreshold: 0.1,
  VisualResponseProperty: Object.freeze({
    TRANSFORM: "transform",
    VISIBILITY: "visibility"
  })
};
async function fetchJsonFile(path) {
  const response = await fetch(path);
  if (!response.ok) {
    throw new Error(response.statusText);
  } else {
    return response.json();
  }
}
async function fetchProfilesList(basePath) {
  if (!basePath) {
    throw new Error("No basePath supplied");
  }
  const profileListFileName = "profilesList.json";
  const profilesList = await fetchJsonFile(`${basePath}/${profileListFileName}`);
  return profilesList;
}
async function fetchProfile(xrInputSource, basePath, defaultProfile = null, getAssetPath = true) {
  if (!xrInputSource) {
    throw new Error("No xrInputSource supplied");
  }
  if (!basePath) {
    throw new Error("No basePath supplied");
  }
  const supportedProfilesList = await fetchProfilesList(basePath);
  let match;
  xrInputSource.profiles.some((profileId) => {
    const supportedProfile = supportedProfilesList[profileId];
    if (supportedProfile) {
      match = {
        profileId,
        profilePath: `${basePath}/${supportedProfile.path}`,
        deprecated: !!supportedProfile.deprecated
      };
    }
    return !!match;
  });
  if (!match) {
    if (!defaultProfile) {
      throw new Error("No matching profile name found");
    }
    const supportedProfile = supportedProfilesList[defaultProfile];
    if (!supportedProfile) {
      throw new Error(`No matching profile name found and default profile "${defaultProfile}" missing.`);
    }
    match = {
      profileId: defaultProfile,
      profilePath: `${basePath}/${supportedProfile.path}`,
      deprecated: !!supportedProfile.deprecated
    };
  }
  const profile = await fetchJsonFile(match.profilePath);
  let assetPath;
  if (getAssetPath) {
    let layout;
    if (xrInputSource.handedness === "any") {
      layout = profile.layouts[Object.keys(profile.layouts)[0]];
    } else {
      layout = profile.layouts[xrInputSource.handedness];
    }
    if (!layout) {
      throw new Error(
        `No matching handedness, ${xrInputSource.handedness}, in profile ${match.profileId}`
      );
    }
    if (layout.assetPath) {
      assetPath = match.profilePath.replace("profile.json", layout.assetPath);
    }
  }
  return { profile, assetPath };
}
var defaultComponentValues = {
  xAxis: 0,
  yAxis: 0,
  button: 0,
  state: Constants.ComponentState.DEFAULT
};
function normalizeAxes(x2 = 0, y = 0) {
  let xAxis = x2;
  let yAxis = y;
  const hypotenuse = Math.sqrt(x2 * x2 + y * y);
  if (hypotenuse > 1) {
    const theta = Math.atan2(y, x2);
    xAxis = Math.cos(theta);
    yAxis = Math.sin(theta);
  }
  const result = {
    normalizedXAxis: xAxis * 0.5 + 0.5,
    normalizedYAxis: yAxis * 0.5 + 0.5
  };
  return result;
}
var VisualResponse = class {
  constructor(visualResponseDescription) {
    this.componentProperty = visualResponseDescription.componentProperty;
    this.states = visualResponseDescription.states;
    this.valueNodeName = visualResponseDescription.valueNodeName;
    this.valueNodeProperty = visualResponseDescription.valueNodeProperty;
    if (this.valueNodeProperty === Constants.VisualResponseProperty.TRANSFORM) {
      this.minNodeName = visualResponseDescription.minNodeName;
      this.maxNodeName = visualResponseDescription.maxNodeName;
    }
    this.value = 0;
    this.updateFromComponent(defaultComponentValues);
  }
  /**
   * Computes the visual response's interpolation weight based on component state
   * @param {Object} componentValues - The component from which to update
   * @param {number} xAxis - The reported X axis value of the component
   * @param {number} yAxis - The reported Y axis value of the component
   * @param {number} button - The reported value of the component's button
   * @param {string} state - The component's active state
   */
  updateFromComponent({
    xAxis,
    yAxis,
    button,
    state
  }) {
    const { normalizedXAxis, normalizedYAxis } = normalizeAxes(xAxis, yAxis);
    switch (this.componentProperty) {
      case Constants.ComponentProperty.X_AXIS:
        this.value = this.states.includes(state) ? normalizedXAxis : 0.5;
        break;
      case Constants.ComponentProperty.Y_AXIS:
        this.value = this.states.includes(state) ? normalizedYAxis : 0.5;
        break;
      case Constants.ComponentProperty.BUTTON:
        this.value = this.states.includes(state) ? button : 0;
        break;
      case Constants.ComponentProperty.STATE:
        if (this.valueNodeProperty === Constants.VisualResponseProperty.VISIBILITY) {
          this.value = this.states.includes(state);
        } else {
          this.value = this.states.includes(state) ? 1 : 0;
        }
        break;
      default:
        throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`);
    }
  }
};
var Component = class {
  /**
   * @param {Object} componentId - Id of the component
   * @param {Object} componentDescription - Description of the component to be created
   */
  constructor(componentId, componentDescription) {
    if (!componentId || !componentDescription || !componentDescription.visualResponses || !componentDescription.gamepadIndices || Object.keys(componentDescription.gamepadIndices).length === 0) {
      throw new Error("Invalid arguments supplied");
    }
    this.id = componentId;
    this.type = componentDescription.type;
    this.rootNodeName = componentDescription.rootNodeName;
    this.touchPointNodeName = componentDescription.touchPointNodeName;
    this.visualResponses = {};
    Object.keys(componentDescription.visualResponses).forEach((responseName) => {
      const visualResponse = new VisualResponse(componentDescription.visualResponses[responseName]);
      this.visualResponses[responseName] = visualResponse;
    });
    this.gamepadIndices = Object.assign({}, componentDescription.gamepadIndices);
    this.values = {
      state: Constants.ComponentState.DEFAULT,
      button: this.gamepadIndices.button !== void 0 ? 0 : void 0,
      xAxis: this.gamepadIndices.xAxis !== void 0 ? 0 : void 0,
      yAxis: this.gamepadIndices.yAxis !== void 0 ? 0 : void 0
    };
  }
  get data() {
    const data = { id: this.id, ...this.values };
    return data;
  }
  /**
   * @description Poll for updated data based on current gamepad state
   * @param {Object} gamepad - The gamepad object from which the component data should be polled
   */
  updateFromGamepad(gamepad) {
    this.values.state = Constants.ComponentState.DEFAULT;
    if (this.gamepadIndices.button !== void 0 && gamepad.buttons.length > this.gamepadIndices.button) {
      const gamepadButton = gamepad.buttons[this.gamepadIndices.button];
      this.values.button = gamepadButton.value;
      this.values.button = this.values.button < 0 ? 0 : this.values.button;
      this.values.button = this.values.button > 1 ? 1 : this.values.button;
      if (gamepadButton.pressed || this.values.button === 1) {
        this.values.state = Constants.ComponentState.PRESSED;
      } else if (gamepadButton.touched || this.values.button > Constants.ButtonTouchThreshold) {
        this.values.state = Constants.ComponentState.TOUCHED;
      }
    }
    if (this.gamepadIndices.xAxis !== void 0 && gamepad.axes.length > this.gamepadIndices.xAxis) {
      this.values.xAxis = gamepad.axes[this.gamepadIndices.xAxis];
      this.values.xAxis = this.values.xAxis < -1 ? -1 : this.values.xAxis;
      this.values.xAxis = this.values.xAxis > 1 ? 1 : this.values.xAxis;
      if (this.values.state === Constants.ComponentState.DEFAULT && Math.abs(this.values.xAxis) > Constants.AxisTouchThreshold) {
        this.values.state = Constants.ComponentState.TOUCHED;
      }
    }
    if (this.gamepadIndices.yAxis !== void 0 && gamepad.axes.length > this.gamepadIndices.yAxis) {
      this.values.yAxis = gamepad.axes[this.gamepadIndices.yAxis];
      this.values.yAxis = this.values.yAxis < -1 ? -1 : this.values.yAxis;
      this.values.yAxis = this.values.yAxis > 1 ? 1 : this.values.yAxis;
      if (this.values.state === Constants.ComponentState.DEFAULT && Math.abs(this.values.yAxis) > Constants.AxisTouchThreshold) {
        this.values.state = Constants.ComponentState.TOUCHED;
      }
    }
    Object.values(this.visualResponses).forEach((visualResponse) => {
      visualResponse.updateFromComponent(this.values);
    });
  }
};
var MotionController = class {
  /**
   * @param {Object} xrInputSource - The XRInputSource to build the MotionController around
   * @param {Object} profile - The best matched profile description for the supplied xrInputSource
   * @param {Object} assetUrl
   */
  constructor(xrInputSource, profile, assetUrl) {
    if (!xrInputSource) {
      throw new Error("No xrInputSource supplied");
    }
    if (!profile) {
      throw new Error("No profile supplied");
    }
    this.xrInputSource = xrInputSource;
    this.assetUrl = assetUrl;
    this.id = profile.profileId;
    this.layoutDescription = profile.layouts[xrInputSource.handedness];
    this.components = {};
    Object.keys(this.layoutDescription.components).forEach((componentId) => {
      const componentDescription = this.layoutDescription.components[componentId];
      this.components[componentId] = new Component(componentId, componentDescription);
    });
    this.updateFromGamepad();
  }
  get gripSpace() {
    return this.xrInputSource.gripSpace;
  }
  get targetRaySpace() {
    return this.xrInputSource.targetRaySpace;
  }
  /**
   * @description Returns a subset of component data for simplified debugging
   */
  get data() {
    const data = [];
    Object.values(this.components).forEach((component) => {
      data.push(component.data);
    });
    return data;
  }
  /**
   * @description Poll for updated data based on current gamepad state
   */
  updateFromGamepad() {
    Object.values(this.components).forEach((component) => {
      component.updateFromGamepad(this.xrInputSource.gamepad);
    });
  }
};

// node_modules/@needle-tools/engine/lib/engine/engine_input.js
var debug5 = getParam("debuginput");
var PointerType;
(function(PointerType2) {
  PointerType2["Mouse"] = "mouse";
  PointerType2["Touch"] = "touch";
  PointerType2["Controller"] = "controller";
  PointerType2["Hand"] = "hand";
})(PointerType || (PointerType = {}));
var PointerEnumType;
(function(PointerEnumType2) {
  PointerEnumType2["PointerDown"] = "pointerdown";
  PointerEnumType2["PointerUp"] = "pointerup";
  PointerEnumType2["PointerMove"] = "pointermove";
})(PointerEnumType || (PointerEnumType = {}));
var KeyboardEnumType;
(function(KeyboardEnumType2) {
  KeyboardEnumType2["KeyDown"] = "keydown";
  KeyboardEnumType2["KeyUp"] = "keyup";
  KeyboardEnumType2["KeyPressed"] = "keypress";
})(KeyboardEnumType || (KeyboardEnumType = {}));
var InputEvents;
(function(InputEvents2) {
  InputEvents2["PointerDown"] = "pointerdown";
  InputEvents2["PointerUp"] = "pointerup";
  InputEvents2["PointerMove"] = "pointermove";
  InputEvents2["KeyDown"] = "keydown";
  InputEvents2["KeyUp"] = "keyup";
  InputEvents2["KeyPressed"] = "keypress";
})(InputEvents || (InputEvents = {}));
var NEPointerEvent = class extends PointerEvent {
  constructor(type, source, init) {
    super(type, init);
    /**
     * Spatial input data
     */
    __publicField(this, "clientZ");
    /** the device index: mouse and touch are always 0, otherwise e.g. index of the connected Gamepad or XRController */
    __publicField(this, "deviceIndex");
    /** The origin of the event contains a reference to the creator of this event.
     * This can be the Needle Engine input system or e.g. a XR controller.
     * Implement `onPointerHits` to receive the intersections of this event.
     */
    __publicField(this, "origin");
    /** the browser event that triggered this event (if any) */
    __publicField(this, "source");
    /** Is the pointer event created via a touch on screen or a spatial device like a XR controller or hand tracking? */
    __publicField(this, "mode");
    __publicField(this, "_ray");
    /** The device space (this object is not necessarily rendered in the scene but you can access or copy the matrix)
     * E.g. you can access the input world space source position with `space.worldPosition` or world direction with `space.worldForward`
    */
    __publicField(this, "space");
    /** true if this event is a click */
    __publicField(this, "isClick", false);
    /** true if this event is a double click */
    __publicField(this, "isDoubleClick", false);
    __publicField(this, "_used", false);
    __publicField(this, "_pointerid");
    __publicField(this, "_pointerType");
    __publicField(this, "_type");
    /** metadata can be used to associate additional information with the event */
    __publicField(this, "metadata", {});
    /** intersections that were generated from this event (or are associated with this event in any way) */
    __publicField(this, "intersections", new Array());
    __publicField(this, "_immediatePropagationStopped", false);
    __publicField(this, "_propagationStopped", false);
    this.clientZ = init.clientZ;
    this._pointerid = init.pointerId;
    this._pointerType = init.pointerType;
    this._type = type;
    this.deviceIndex = init.deviceIndex;
    this.origin = init.origin;
    this.source = source;
    this.mode = init.mode;
    this._ray = init.ray;
    this.space = init.device;
  }
  /** Returns true if the input was emitted in 3D space (and not by e.g. clicking on a 2D screen). You can use {@link mode} if you need more information about the input source */
  get isSpatial() {
    return this.mode != "screen";
  }
  /** A ray in worldspace for the event.
   * If the ray is undefined you can also use `space.worldForward` and `space.worldPosition` */
  get ray() {
    if (!this._ray) {
      this._ray = new Ray(this.space.worldPosition.clone(), this.space.worldForward.clone());
    }
    return this._ray;
  }
  set ray(value) {
    this._ray = value;
  }
  /**@returns true if this event has a ray. If you access the ray property a ray will automatically created */
  get hasRay() {
    return this._ray !== void 0;
  }
  /** @returns `true` if the event is marked to be used (when `use()` has been called). Default: `false` */
  get used() {
    return this._used;
  }
  /** Call to mark an event to be used */
  use() {
    this._used = true;
  }
  /** Unique identifier for this input: a combination of the deviceIndex + button to uniquely identify the exact input (e.g. LeftController:Button0 = 0, RightController:Button1 = 11) */
  get pointerId() {
    return this._pointerid;
  }
  // this is set via the init arguments (we override it here for intellisense to show the string options)
  /** What type of input created this event: touch, mouse, xr controller, xr hand tracking... */
  get pointerType() {
    return this._pointerType;
  }
  // this is set via the init arguments (we override it here for intellisense to show the string options)
  /** The input that raised this event like `pointerdown` */
  get type() {
    return this._type;
  }
  get immediatePropagationStopped() {
    return this._immediatePropagationStopped;
  }
  get propagationStopped() {
    return this._immediatePropagationStopped || this._propagationStopped;
  }
  stopImmediatePropagation() {
    var _a2;
    this._immediatePropagationStopped = true;
    super.stopImmediatePropagation();
    (_a2 = this.source) == null ? void 0 : _a2.stopImmediatePropagation();
  }
  stopPropagation() {
    var _a2;
    this._propagationStopped = true;
    super.stopPropagation();
    (_a2 = this.source) == null ? void 0 : _a2.stopPropagation();
    if (debug5)
      console.warn("Stop propagation...", this.pointerId, this.pointerType);
  }
};
var NEKeyboardEvent = class extends KeyboardEvent {
  constructor(type, source, init) {
    super(type, init);
    __publicField(this, "source");
    this.source = source;
  }
  stopImmediatePropagation() {
    var _a2;
    super.stopImmediatePropagation();
    (_a2 = this.source) == null ? void 0 : _a2.stopImmediatePropagation();
  }
};
var KeyEventArgs = class {
  constructor(evt) {
    __publicField(this, "key");
    __publicField(this, "keyType");
    __publicField(this, "source");
    this.key = evt.key;
    this.keyType = evt.type;
    this.source = evt;
  }
};
var InputEventQueue;
(function(InputEventQueue2) {
  InputEventQueue2[InputEventQueue2["Early"] = -100] = "Early";
  InputEventQueue2[InputEventQueue2["Default"] = 0] = "Default";
  InputEventQueue2[InputEventQueue2["Late"] = 100] = "Late";
})(InputEventQueue || (InputEventQueue = {}));
var Input = class {
  /** @internal */
  constructor(context) {
    /** This is a list of event listeners per event type (e.g. pointerdown, pointerup, keydown...). Each entry contains a priority and list of listeners.
     * That way users can control if they want to receive events before or after other listeners (e.g subscribe to pointer events before the EventSystem receives them) - this allows certain listeners to be always invoked first (or last) and stop propagation
     * Listeners per event are sorted
     */
    __publicField(this, "_eventListeners", {});
    __publicField(this, "_doubleClickTimeThreshold", 0.2);
    __publicField(this, "_longPressTimeThreshold", 1);
    __publicField(this, "_specialCursorTrigger", 0);
    __publicField(this, "context");
    __publicField(this, "_pointerDown", [false]);
    __publicField(this, "_pointerUp", [false]);
    __publicField(this, "_pointerClick", [false]);
    __publicField(this, "_pointerDoubleClick", [false]);
    __publicField(this, "_pointerPressed", [false]);
    __publicField(this, "_pointerPositions", [new Vector2()]);
    __publicField(this, "_pointerPositionsLastFrame", [new Vector2()]);
    __publicField(this, "_pointerPositionsDelta", [new Vector2()]);
    __publicField(this, "_pointerPositionsRC", [new Vector2()]);
    __publicField(this, "_pointerPositionDown", [new Vector32()]);
    __publicField(this, "_pointerDownTime", []);
    __publicField(this, "_pointerUpTime", []);
    __publicField(this, "_pointerUpTimestamp", []);
    __publicField(this, "_pointerIds", []);
    __publicField(this, "_pointerTypes", [""]);
    __publicField(this, "_mouseWheelChanged", [false]);
    __publicField(this, "_mouseWheelDeltaY", [0]);
    __publicField(this, "_pointerEvent", []);
    /** current pressed pointer events. Used to check if any of those events was used  */
    __publicField(this, "_pointerEventsPressed", []);
    /** This is added/updated for pointers. screenspace pointers set this to the camera near plane  */
    __publicField(this, "_pointerSpace", []);
    __publicField(this, "_pressedStack", /* @__PURE__ */ new Map());
    /** this is the html element we subscribed to for events */
    __publicField(this, "_htmlEventSource");
    __publicField(this, "onLostFocus", () => {
      for (const kp in this.keysPressed) {
        this.keysPressed[kp].pressed = false;
      }
    });
    __publicField(this, "onEndOfFrame", () => {
      for (let i = 0; i < this._pointerUp.length; i++)
        this._pointerUp[i] = false;
      for (let i = 0; i < this._pointerDown.length; i++)
        this._pointerDown[i] = false;
      for (let i = 0; i < this._pointerClick.length; i++)
        this._pointerClick[i] = false;
      for (let i = 0; i < this._pointerDoubleClick.length; i++)
        this._pointerDoubleClick[i] = false;
      for (const pt of this._pointerPositionsDelta)
        pt.set(0, 0);
      for (let i = 0; i < this._mouseWheelChanged.length; i++)
        this._mouseWheelChanged[i] = false;
      for (let i = 0; i < this._mouseWheelDeltaY.length; i++)
        this._mouseWheelDeltaY[i] = 0;
    });
    __publicField(this, "onContextMenu", (evt) => {
      if (this.canReceiveInput(evt) === false)
        return;
      if (evt instanceof PointerEvent) {
        if (evt.pointerType === "touch") {
        }
      }
    });
    __publicField(this, "keysPressed", {});
    __publicField(this, "onKeyDown", (evt) => {
      if (debug5)
        console.log(`key down ${evt.code}, ${this.context.application.hasFocus}`, evt);
      if (!this.context.application.hasFocus)
        return;
      const ex = this.keysPressed[evt.code];
      if (ex && ex.pressed)
        return;
      this.keysPressed[evt.code] = { pressed: true, frame: this.context.time.frameCount + 1, startFrame: this.context.time.frameCount + 1, key: evt.key, code: evt.code };
      const ne = new NEKeyboardEvent(InputEvents.KeyDown, evt, evt);
      this.onDispatchEvent(ne);
    });
    __publicField(this, "onKeyPressed", (evt) => {
      if (!this.context.application.hasFocus)
        return;
      const p = this.keysPressed[evt.code];
      if (!p)
        return;
      p.pressed = true;
      p.frame = this.context.time.frameCount + 1;
      const ne = new NEKeyboardEvent(InputEvents.KeyPressed, evt, evt);
      this.onDispatchEvent(ne);
    });
    __publicField(this, "onKeyUp", (evt) => {
      if (!this.context.application.hasFocus)
        return;
      const p = this.keysPressed[evt.code];
      if (!p)
        return;
      p.pressed = false;
      p.frame = this.context.time.frameCount + 1;
      const ne = new NEKeyboardEvent(InputEvents.KeyUp, evt, evt);
      this.onDispatchEvent(ne);
    });
    __publicField(this, "onWheelWindow", (evt) => {
      if (document.pointerLockElement) {
        this.onMouseWheel(evt);
      }
    });
    __publicField(this, "onMouseWheel", (evt) => {
      if (this.canReceiveInput(evt) === false)
        return;
      if (this._mouseWheelDeltaY.length <= 0)
        this._mouseWheelDeltaY.push(0);
      if (this._mouseWheelChanged.length <= 0)
        this._mouseWheelChanged.push(false);
      this._mouseWheelChanged[0] = true;
      const current = this._mouseWheelDeltaY[0];
      this._mouseWheelDeltaY[0] = current + evt.deltaY;
    });
    __publicField(this, "onPointerDown", (evt) => {
      if (this.context.isInAR)
        return;
      if (this.canReceiveInput(evt) === false)
        return;
      if (evt.target instanceof HTMLElement) {
        evt.target.setPointerCapture(evt.pointerId);
      }
      const id = this.getPointerId(evt);
      if (debug5)
        showBalloonMessage(`pointer down #${id}, identifier:${evt.pointerId}`);
      const space = this.getAndUpdateSpatialObjectForScreenPosition(id, evt.clientX, evt.clientY);
      const ne = new NEPointerEvent(InputEvents.PointerDown, evt, { origin: this, mode: "screen", deviceIndex: 0, pointerId: id, button: evt.button, clientX: evt.clientX, clientY: evt.clientY, pointerType: evt.pointerType, buttonName: this.getButtonName(evt), device: space, pressure: evt.pressure });
      this.onDown(ne);
    });
    __publicField(this, "onPointerMove", (evt) => {
      if (this.context.isInAR)
        return;
      let button = evt.button;
      if (evt.pointerType === "mouse") {
        const pressedButton = this.getFirstPressedButtonForPointer(0);
        button = pressedButton ?? 0;
      }
      const id = this.getPointerId(evt, button);
      if (button === -1) {
        button = id;
      }
      const space = this.getAndUpdateSpatialObjectForScreenPosition(id, evt.clientX, evt.clientY);
      const ne = new NEPointerEvent(InputEvents.PointerMove, evt, { origin: this, mode: "screen", deviceIndex: 0, pointerId: id, button, clientX: evt.clientX, clientY: evt.clientY, pointerType: evt.pointerType, buttonName: this.getButtonName(evt), device: space, pressure: evt.pressure });
      this.onMove(ne);
    });
    __publicField(this, "onPointerCancel", (evt) => {
      if (this.context.isInAR)
        return;
      if (debug5)
        console.log("Pointer cancel", evt);
      this.onPointerUp(evt);
    });
    __publicField(this, "onPointerUp", (evt) => {
      if (this.context.isInAR)
        return;
      if (evt.target instanceof HTMLElement) {
        evt.target.releasePointerCapture(evt.pointerId);
      }
      const id = this.getPointerId(evt);
      const ne = new NEPointerEvent(InputEvents.PointerUp, evt, { origin: this, mode: "screen", deviceIndex: 0, pointerId: id, button: evt.button, clientX: evt.clientX, clientY: evt.clientY, pointerType: evt.pointerType, buttonName: this.getButtonName(evt), device: this.getAndUpdateSpatialObjectForScreenPosition(id, evt.clientX, evt.clientY), pressure: evt.pressure });
      this.onUp(ne);
      this._pointerIds[id] = -1;
      if (debug5)
        console.log("ID=" + id, "PointerId=" + evt.pointerId, "ALL:", [...this._pointerIds]);
    });
    // the touch events are currently only used for AR support on android
    __publicField(this, "onTouchStart", (evt) => {
      if (!this.context.isInAR)
        return;
      for (let i = 0; i < evt.changedTouches.length; i++) {
        const touch = evt.changedTouches[i];
        const id = this.getPointerIndex(touch.identifier);
        const space = this.getAndUpdateSpatialObjectForScreenPosition(id, touch.clientX, touch.clientY);
        const ne = new NEPointerEvent(InputEvents.PointerDown, evt, { origin: this, mode: "screen", deviceIndex: 0, pointerId: id, button: 0, clientX: touch.clientX, clientY: touch.clientY, pointerType: "touch", buttonName: "unknown", device: space, pressure: touch.force });
        this.onDown(ne);
      }
      ;
    });
    __publicField(this, "onTouchMove", (evt) => {
      if (!this.context.isInAR)
        return;
      for (let i = 0; i < evt.changedTouches.length; i++) {
        const touch = evt.changedTouches[i];
        const id = this.getPointerIndex(touch.identifier);
        const space = this.getAndUpdateSpatialObjectForScreenPosition(id, touch.clientX, touch.clientY);
        const ne = new NEPointerEvent(InputEvents.PointerMove, evt, { origin: this, mode: "screen", deviceIndex: 0, pointerId: id, button: 0, clientX: touch.clientX, clientY: touch.clientY, pointerType: "touch", buttonName: "unknown", device: space, pressure: touch.force });
        this.onMove(ne);
      }
      ;
    });
    __publicField(this, "onTouchEnd", (evt) => {
      if (!this.context.isInAR)
        return;
      for (let i = 0; i < evt.changedTouches.length; i++) {
        const touch = evt.changedTouches[i];
        const id = this.getPointerIndex(touch.identifier);
        const ne = new NEPointerEvent(InputEvents.PointerUp, evt, { origin: this, mode: "screen", deviceIndex: 0, pointerId: id, button: 0, clientX: touch.clientX, clientY: touch.clientY, pointerType: "touch", buttonName: "unknown", device: this.getAndUpdateSpatialObjectForScreenPosition(id, touch.clientX, touch.clientY), pressure: touch.force });
        this.onUp(ne);
        this._pointerIds[id] = -1;
      }
      ;
    });
    __publicField(this, "tempNearPlaneVector", new Vector32());
    __publicField(this, "tempFarPlaneVector", new Vector32());
    __publicField(this, "tempLookMatrix", new Matrix4());
    this.context = context;
    this.context.post_render_callbacks.push(this.onEndOfFrame);
  }
  /** Adds an event listener for the specified event type. The callback will be called when the event is triggered.
   * @param type The event type to listen for
   * @param callback The callback to call when the event is triggered
   * @param options The options for adding the event listener
   */
  addEventListener(type, callback, options) {
    if (!this._eventListeners[type])
      this._eventListeners[type] = [];
    if (!callback || typeof callback !== "function") {
      console.error("Invalid call to addEventListener: callback is required and must be a function!");
      return;
    }
    if (!options)
      options = {};
    else
      options = { ...options };
    let queue = 0;
    if ((options == null ? void 0 : options.queue) != void 0)
      queue = options.queue;
    const listeners = this._eventListeners[type];
    const queueListeners = listeners.find((l) => l.priority === queue);
    if (!queueListeners) {
      listeners.push({ priority: queue, listeners: [{ callback, options }] });
      listeners.sort((a, b) => a.priority - b.priority);
    } else {
      queueListeners.listeners.push({ callback, options });
    }
  }
  /** Removes the event listener from the specified event type. If no queue is specified the listener will be removed from all queues.
   * @param type The event type to remove the listener from
   * @param callback The callback to remove
   * @param options The options for removing the event listener
   */
  removeEventListener(type, callback, options) {
    if (!this._eventListeners[type])
      return;
    if (!callback)
      return;
    const listeners = this._eventListeners[type];
    if ((options == null ? void 0 : options.queue) != void 0) {
      const queueListeners = listeners.find((l) => l.priority === options.queue);
      if (!queueListeners)
        return;
      const index = queueListeners.listeners.findIndex((l) => l.callback === callback);
      if (index >= 0)
        queueListeners.listeners.splice(index, 1);
    } else {
      for (const l of listeners) {
        const index = l.listeners.findIndex((l2) => l2.callback === callback);
        if (index >= 0)
          l.listeners.splice(index, 1);
      }
    }
  }
  dispatchEvent(evt) {
    var _a2, _b, _c, _d;
    let preventNextEventQueue = false;
    if (evt instanceof NEKeyboardEvent) {
      const listeners = this._eventListeners[evt.type];
      if (listeners) {
        for (const queue of listeners) {
          for (let i = 0; i < queue.listeners.length; i++) {
            const entry = queue.listeners[i];
            if ((_b = (_a2 = entry.options) == null ? void 0 : _a2.signal) == null ? void 0 : _b.aborted) {
              queue.listeners.splice(i, 1);
              i--;
              continue;
            }
            if (entry.options.once) {
              queue.listeners.splice(i, 1);
              i--;
            }
            entry.callback(evt);
          }
        }
      }
    }
    if (evt instanceof NEPointerEvent) {
      const listeners = this._eventListeners[evt.type];
      if (listeners) {
        for (const queue of listeners) {
          if (preventNextEventQueue)
            break;
          for (let i = 0; i < queue.listeners.length; i++) {
            const entry = queue.listeners[i];
            if ((_d = (_c = entry.options) == null ? void 0 : _c.signal) == null ? void 0 : _d.aborted) {
              queue.listeners.splice(i, 1);
              i--;
              continue;
            }
            if (evt.immediatePropagationStopped) {
              preventNextEventQueue = true;
              if (debug5)
                console.log("immediatePropagationStopped", evt.type);
              break;
            } else if (evt.propagationStopped) {
              preventNextEventQueue = true;
              if (debug5)
                console.log("propagationStopped", evt.type);
            }
            if (entry.options.once) {
              queue.listeners.splice(i, 1);
              i--;
            }
            entry.callback(evt);
          }
        }
      }
    }
  }
  get mousePosition() {
    return this._pointerPositions[0];
  }
  get mousePositionRC() {
    return this._pointerPositionsRC[0];
  }
  get mouseDown() {
    return this._pointerDown[0];
  }
  get mouseUp() {
    return this._pointerUp[0];
  }
  /** Is the primary pointer clicked (usually the left button). This is equivalent to `input.click` */
  get mouseClick() {
    return this._pointerClick[0];
  }
  /** Was a double click detected for the primary pointer? This is equivalent to `input.doubleClick` */
  get mouseDoubleClick() {
    return this._pointerDoubleClick[0];
  }
  get mousePressed() {
    return this._pointerPressed[0];
  }
  get mouseWheelChanged() {
    return this.getMouseWheelChanged(0);
  }
  /** Is the primary pointer double clicked (usually the left button). This is equivalent to `input.mouseDoubleClick` */
  get click() {
    return this._pointerClick[0];
  }
  /** Was a double click detected for the primary pointer? */
  get doubleClick() {
    return this._pointerDoubleClick[0];
  }
  setCursorPointer() {
    this._specialCursorTrigger += 1;
    this.context.domElement.style.cursor = "pointer";
  }
  setCursorNormal() {
    this._specialCursorTrigger -= 1;
    this._specialCursorTrigger = Math.max(0, this._specialCursorTrigger);
    if (this._specialCursorTrigger === 0)
      this.context.domElement.style.cursor = "default";
  }
  /**
   * Check if a pointer id is currently used.
   */
  getIsPointerIdInUse(pointerId) {
    for (const evt of this._pointerEventsPressed) {
      if (evt.pointerId === pointerId) {
        if (evt.used)
          return true;
      }
    }
    return false;
  }
  /** how many pointers are currently pressed */
  getPointerPressedCount() {
    let count = 0;
    for (let i = 0; i < this._pointerPressed.length; i++) {
      if (this._pointerPressed[i]) {
        count++;
      }
    }
    return count;
  }
  /**
   * Gets the position of the given pointer index in pixel
   * @param i The pointer index
   * @returns The position of the pointer in pixel
   */
  getPointerPosition(i) {
    if (i >= this._pointerPositions.length)
      return null;
    return this._pointerPositions[i];
  }
  getPointerPositionLastFrame(i) {
    if (i >= this._pointerPositionsLastFrame.length)
      return null;
    return this._pointerPositionsLastFrame[i];
  }
  getPointerPositionDelta(i) {
    if (i >= this._pointerPositionsDelta.length)
      return null;
    return this._pointerPositionsDelta[i];
  }
  getPointerPositionRC(i) {
    if (i >= this._pointerPositionsRC.length)
      return null;
    return this._pointerPositionsRC[i];
  }
  getPointerDown(i) {
    if (i >= this._pointerDown.length)
      return false;
    return this._pointerDown[i];
  }
  getPointerUp(i) {
    if (i >= this._pointerUp.length)
      return false;
    return this._pointerUp[i];
  }
  getPointerPressed(i) {
    if (i >= this._pointerPressed.length)
      return false;
    const res = this._pointerPressed[i];
    return res;
  }
  getPointerClicked(i) {
    if (i >= this._pointerClick.length)
      return false;
    return this._pointerClick[i];
  }
  getPointerDoubleClicked(i) {
    if (i >= this._pointerDoubleClick.length)
      return false;
    return this._pointerDoubleClick[i];
  }
  getPointerDownTime(i) {
    if (i >= this._pointerDownTime.length)
      return -1;
    return this._pointerDownTime[i];
  }
  getPointerUpTime(i) {
    if (i >= this._pointerUpTime.length)
      return -1;
    return this._pointerUpTime[i];
  }
  getPointerLongPress(i) {
    if (i >= this._pointerDownTime.length)
      return false;
    return this.getPointerPressed(i) && this.context.time.time - this._pointerDownTime[i] > this._longPressTimeThreshold;
  }
  getIsMouse(i) {
    if (i < 0 || i >= this._pointerTypes.length)
      return false;
    return this._pointerTypes[i] === PointerType.Mouse;
  }
  getIsTouch(i) {
    if (i < 0 || i >= this._pointerTypes.length)
      return false;
    return this._pointerTypes[i] === PointerType.Touch;
  }
  getTouchesPressedCount() {
    let count = 0;
    for (let i = 0; i < this._pointerPressed.length; i++) {
      if (this._pointerPressed[i] && this.getIsTouch(i)) {
        count++;
      }
    }
    return count;
  }
  getMouseWheelChanged(i = 0) {
    if (i >= this._mouseWheelChanged.length)
      return false;
    return this._mouseWheelChanged[i];
  }
  getMouseWheelDeltaY(i = 0) {
    if (i >= this._mouseWheelDeltaY.length)
      return 0;
    return this._mouseWheelDeltaY[i];
  }
  getPointerEvent(i) {
    if (i >= this._pointerEvent.length)
      return void 0;
    return this._pointerEvent[i] ?? void 0;
  }
  *foreachPointerId(pointerType) {
    for (let i = 0; i < this._pointerTypes.length; i++) {
      if (this._pointerIsActive(i)) {
        if (pointerType !== void 0) {
          const type = this._pointerTypes[i];
          if (Array.isArray(pointerType)) {
            let isInArray = false;
            for (const t2 of pointerType) {
              if (type === t2) {
                isInArray = true;
                break;
              }
            }
            if (!isInArray)
              continue;
          } else {
            if (pointerType !== type)
              continue;
          }
        }
        yield i;
      }
    }
  }
  *foreachTouchId() {
    for (let i = 0; i < this._pointerTypes.length; i++) {
      const type = this._pointerTypes[i];
      if (type !== PointerType.Touch)
        continue;
      if (this._pointerIsActive[i])
        yield i;
    }
  }
  _pointerIsActive(index) {
    if (index < 0)
      return false;
    return this._pointerPressed[index] || this._pointerDown[index] || this._pointerUp[index];
  }
  onDownButton(pointerId, button) {
    let stack = this._pressedStack.get(pointerId);
    if (!stack) {
      stack = [];
      this._pressedStack.set(pointerId, stack);
    }
    stack.push(button);
  }
  onReleaseButton(pointerId, button) {
    const stack = this._pressedStack.get(pointerId);
    if (!stack)
      return;
    const index = stack.indexOf(button);
    if (index >= 0)
      stack.splice(index, 1);
  }
  /** the first button that was down and is currently pressed */
  getFirstPressedButtonForPointer(pointerId) {
    const stack = this._pressedStack.get(pointerId);
    if (!stack)
      return void 0;
    return stack[0];
  }
  /** the last (most recent) button that was down and is currently pressed */
  getLatestPressedButtonForPointer(pointerId) {
    const stack = this._pressedStack.get(pointerId);
    if (!stack)
      return void 0;
    return stack[stack.length - 1];
  }
  getKeyDown() {
    for (const key in this.keysPressed) {
      const k = this.keysPressed[key];
      if (k.startFrame === this.context.time.frameCount)
        return k.key;
    }
    return null;
  }
  getKeyPressed() {
    for (const key in this.keysPressed) {
      const k = this.keysPressed[key];
      if (k.pressed)
        return k.key;
    }
    return null;
  }
  isKeyDown(keyCode) {
    var _a2;
    if (!this.context.application.isVisible || !this.context.application.hasFocus)
      return false;
    const codes = this.getCodeForCommonKeyName(keyCode);
    if (codes !== null) {
      for (const code of codes)
        if (this.isKeyDown(code))
          return true;
      return false;
    }
    return ((_a2 = this.keysPressed[keyCode]) == null ? void 0 : _a2.startFrame) === this.context.time.frameCount && this.keysPressed[keyCode].pressed;
  }
  isKeyUp(keyCode) {
    var _a2;
    if (!this.context.application.isVisible || !this.context.application.hasFocus)
      return false;
    const codes = this.getCodeForCommonKeyName(keyCode);
    if (codes !== null) {
      for (const code of codes)
        if (this.isKeyUp(code))
          return true;
      return false;
    }
    return ((_a2 = this.keysPressed[keyCode]) == null ? void 0 : _a2.frame) === this.context.time.frameCount && !this.keysPressed[keyCode].pressed;
  }
  isKeyPressed(keyCode) {
    var _a2;
    if (!this.context.application.isVisible || !this.context.application.hasFocus)
      return false;
    const codes = this.getCodeForCommonKeyName(keyCode);
    if (codes !== null) {
      for (const code of codes)
        if (this.isKeyPressed(code))
          return true;
      return false;
    }
    return (_a2 = this.keysPressed[keyCode]) == null ? void 0 : _a2.pressed;
  }
  // utility helper for mapping common names to actual codes; e.g. "Shift" -> "ShiftLeft" and "ShiftRight" or "a" -> "KeyA"
  getCodeForCommonKeyName(keyName) {
    if (keyName.length === 1) {
      if (keyName >= "0" && keyName <= "9")
        return ["Digit" + keyName];
      if (keyName >= "a" && keyName <= "z")
        return ["Key" + keyName.toUpperCase()];
      if (keyName == " ")
        return ["Space"];
    }
    switch (keyName) {
      case "shift":
      case "Shift":
        return ["ShiftLeft", "ShiftRight"];
      case "control":
      case "Control":
        return ["ControlLeft", "ControlRight"];
      case "alt":
      case "Alt":
        return ["AltLeft", "AltRight"];
    }
    return null;
  }
  createInputEvent(args) {
    switch (args.type) {
      case InputEvents.PointerDown:
        if (debug5)
          showBalloonMessage("Create Pointer down");
        this.onDownButton(args.deviceIndex, args.button);
        this.onDown(args);
        break;
      case InputEvents.PointerMove:
        if (debug5)
          showBalloonMessage("Create Pointer move");
        this.onMove(args);
        break;
      case InputEvents.PointerUp:
        if (debug5)
          showBalloonMessage("Create Pointer up");
        this.onUp(args);
        this.onReleaseButton(args.deviceIndex, args.button);
        break;
    }
  }
  convertScreenspaceToRaycastSpace(vec2) {
    vec2.x = (vec2.x - this.context.domX) / this.context.domWidth * 2 - 1;
    vec2.y = -((vec2.y - this.context.domY) / this.context.domHeight) * 2 + 1;
    return vec2;
  }
  bindEvents() {
    this.unbindEvents();
    this._htmlEventSource = this.context.renderer.domElement;
    window.addEventListener("contextmenu", this.onContextMenu);
    this._htmlEventSource.addEventListener("pointerdown", this.onPointerDown, { passive: true });
    window.addEventListener("pointermove", this.onPointerMove, { passive: true, capture: true });
    window.addEventListener("pointerup", this.onPointerUp, { passive: true });
    window.addEventListener("pointercancel", this.onPointerCancel, { passive: true });
    window.addEventListener("touchstart", this.onTouchStart, { passive: true });
    window.addEventListener("touchmove", this.onTouchMove, { passive: true });
    window.addEventListener("touchend", this.onTouchEnd, { passive: true });
    this._htmlEventSource.addEventListener("wheel", this.onMouseWheel, { passive: true });
    window.addEventListener("wheel", this.onWheelWindow, { passive: true });
    window.addEventListener("keydown", this.onKeyDown, false);
    window.addEventListener("keypress", this.onKeyPressed, false);
    window.addEventListener("keyup", this.onKeyUp, false);
    window.addEventListener("blur", this.onLostFocus);
  }
  unbindEvents() {
    var _a2, _b;
    window.removeEventListener("contextmenu", this.onContextMenu);
    (_a2 = this._htmlEventSource) == null ? void 0 : _a2.removeEventListener("pointerdown", this.onPointerDown);
    window.removeEventListener("pointermove", this.onPointerMove);
    window.removeEventListener("pointerup", this.onPointerUp);
    window.removeEventListener("pointercancel", this.onPointerCancel);
    (_b = this._htmlEventSource) == null ? void 0 : _b.removeEventListener("wheel", this.onMouseWheel, false);
    window.removeEventListener("wheel", this.onWheelWindow, false);
    window.removeEventListener("keydown", this.onKeyDown, false);
    window.removeEventListener("keypress", this.onKeyPressed, false);
    window.removeEventListener("keyup", this.onKeyUp, false);
    window.removeEventListener("blur", this.onLostFocus);
  }
  dispose() {
    const index = this.context.post_render_callbacks.indexOf(this.onEndOfFrame);
    if (index >= 0)
      this.context.post_render_callbacks.splice(index, 1);
    this.unbindEvents();
  }
  canReceiveInput(evt) {
    var _a2;
    if (evt.target === ((_a2 = this.context.renderer) == null ? void 0 : _a2.domElement))
      return true;
    if (evt.target === this.context.domElement)
      return true;
    if (this.context.isInAR) {
      return true;
    }
    if (this.context.isInAR && evt.target === document.body && DeviceUtilities.isMozillaXR())
      return true;
    if (debug5)
      console.warn("CanReceiveInput:False for", evt.target);
    return false;
  }
  getPointerId(evt, button) {
    if (evt.pointerType === "mouse")
      return 0 + (button ?? evt.button);
    return this.getPointerIndex(evt.pointerId);
  }
  getButtonName(evt) {
    const button = evt.button;
    if (evt.pointerType === "mouse") {
      switch (button) {
        case 0:
          return "left";
        case 1:
          return "middle";
        case 2:
          return "right";
      }
    }
    return "unknown";
  }
  getAndUpdateSpatialObjectForScreenPosition(id, screenX, screenY) {
    let space = this._pointerSpace[id];
    if (!space) {
      space = new Object3D();
      this._pointerSpace[id] = space;
    }
    this._pointerSpace[id] = space;
    const camera = this.context.mainCamera;
    if (camera) {
      const pointOnNearPlane = this.tempNearPlaneVector.set(screenX, screenY, -1);
      this.convertScreenspaceToRaycastSpace(pointOnNearPlane);
      const pointOnFarPlane = this.tempFarPlaneVector.set(pointOnNearPlane.x, pointOnNearPlane.y, 1);
      pointOnNearPlane.unproject(camera);
      pointOnFarPlane.unproject(camera);
      const worldUp = camera.worldUp || getTempVector(0, 1, 0).applyQuaternion(getWorldQuaternion(camera));
      this.tempLookMatrix.lookAt(pointOnFarPlane, pointOnNearPlane, worldUp);
      space.position.set(pointOnNearPlane.x, pointOnNearPlane.y, pointOnNearPlane.z);
      space.quaternion.setFromRotationMatrix(this.tempLookMatrix);
    }
    return space;
  }
  // Prevent the same event being handled twice (e.g. on touch we get a mouseUp and touchUp evt with the same timestamp)
  // private isNewEvent(timestamp: number, index: number, arr: number[]): boolean {
  //     while (arr.length <= index) arr.push(-1);
  //     if (timestamp === arr[index]) return false;
  //     arr[index] = timestamp;
  //     return true;
  // }
  isInRect(e) {
    if (this.context.isInXR)
      return true;
    const rect = this.context.domElement.getBoundingClientRect();
    const px = e.clientX;
    const py = e.clientY;
    const isInRect = px >= rect.x && px <= rect.right && py >= rect.y && py <= rect.bottom;
    if (debug5 && !isInRect)
      console.log("Not in rect", rect, px, py);
    return isInRect;
  }
  onDown(evt) {
    const index = evt.pointerId;
    if (this.getPointerPressed(index)) {
      console.warn(`Received pointerDown for pointerId that is already pressed: ${index}`, debug5 ? evt : "");
    }
    if (debug5)
      console.log(evt.pointerType, "DOWN", index);
    if (!this.isInRect(evt))
      return;
    this.setPointerState(index, this._pointerPressed, true);
    this.setPointerState(index, this._pointerDown, true);
    this.setPointerStateT(index, this._pointerEvent, evt.source);
    while (index >= this._pointerTypes.length)
      this._pointerTypes.push(evt.pointerType);
    this._pointerTypes[index] = evt.pointerType;
    while (index >= this._pointerPositionDown.length)
      this._pointerPositionDown.push(new Vector32());
    this._pointerPositionDown[index].set(evt.clientX, evt.clientY, evt.clientZ ?? 0);
    while (index >= this._pointerPositions.length)
      this._pointerPositions.push(new Vector2());
    this._pointerPositions[index].set(evt.clientX, evt.clientY);
    if (index >= this._pointerDownTime.length)
      this._pointerDownTime.push(0);
    this._pointerDownTime[index] = this.context.time.realtimeSinceStartup;
    this.updatePointerPosition(evt);
    this._pointerEventsPressed.push(evt);
    this.onDispatchEvent(evt);
  }
  // moveEvent?: Event;
  onMove(evt) {
    const index = evt.pointerId;
    const isDown = this.getPointerPressed(index);
    if (isDown === false && !this.isInRect(evt))
      return;
    if (evt.pointerType === PointerType.Touch && !isDown)
      return;
    this.updatePointerPosition(evt);
    this.setPointerStateT(index, this._pointerEvent, evt.source);
    this.onDispatchEvent(evt);
  }
  onUp(evt) {
    const index = evt.pointerId;
    const wasDown = this.getPointerPressed(index);
    if (!wasDown) {
      if (debug5)
        console.log(evt.pointerType, "UP", index, "was not down");
      return;
    }
    if (debug5)
      console.log(evt.pointerType, "UP", index);
    this.setPointerState(index, this._pointerPressed, false);
    this.setPointerStateT(index, this._pointerEvent, evt.source);
    this.setPointerState(index, this._pointerUp, true);
    this.updatePointerPosition(evt);
    for (let i = this._pointerEventsPressed.length - 1; i >= 0; i--) {
      const ptr = this._pointerEventsPressed[i];
      if (ptr.pointerId === index) {
        this._pointerEventsPressed.splice(i, 1);
        break;
      }
    }
    if (!this._pointerPositionDown[index]) {
      if (debug5)
        showBalloonWarning("Received pointer up event without matching down event for button: " + index);
      console.warn("Received pointer up event without matching down event for button: " + index);
      return;
    }
    const lastUpTime = this._pointerUpTime[index];
    const downTime = this._pointerDownTime[index];
    const upTime = this.context.time.realtimeSinceStartup;
    const dt = upTime - downTime;
    if (index >= this._pointerUpTime.length)
      this._pointerUpTime.push(-99);
    this._pointerUpTime[index] = upTime;
    if (dt < 1) {
      let dx = evt.clientX - this._pointerPositionDown[index].x;
      let dy = evt.clientY - this._pointerPositionDown[index].y;
      let dz = 0;
      if (evt.isSpatial && evt.clientZ != void 0) {
        dz = evt.clientZ - this._pointerPositionDown[index].z;
        dx *= 200;
        dy *= 200;
        dz *= 200;
      }
      if (Math.abs(dx) < 5 && Math.abs(dy) < 5 && Math.abs(dz) < 5) {
        this.setPointerState(index, this._pointerClick, true);
        evt.isClick = true;
        const dt2 = upTime - lastUpTime;
        if (debug5)
          console.log("CLICK", index, dx, dy, dz, dt2);
        if (dt2 < this._doubleClickTimeThreshold && dt2 > 0) {
          this.setPointerState(index, this._pointerDoubleClick, true);
          evt.isDoubleClick = true;
        }
      }
    }
    this.onDispatchEvent(evt);
  }
  updatePointerPosition(evt) {
    const index = evt.pointerId;
    while (index >= this._pointerPositions.length)
      this._pointerPositions.push(new Vector2());
    while (index >= this._pointerPositionsLastFrame.length)
      this._pointerPositionsLastFrame.push(new Vector2());
    while (index >= this._pointerPositionsDelta.length)
      this._pointerPositionsDelta.push(new Vector2());
    const lf = this._pointerPositionsLastFrame[index];
    lf.copy(this._pointerPositions[index]);
    const delta = this._pointerPositionsDelta[index];
    let dx = evt.clientX - lf.x;
    let dy = evt.clientY - lf.y;
    if (evt.source instanceof MouseEvent || evt.source instanceof TouchEvent) {
      const source = evt.source;
      if (dx === 0 && source.movementX !== 0)
        dx = source.movementX || 0;
      if (dy === 0 && source.movementY !== 0)
        dy = source.movementY || 0;
    }
    delta.x += dx;
    delta.y += dy;
    this._pointerPositions[index].x = evt.clientX;
    this._pointerPositions[index].y = evt.clientY;
    const px = evt.clientX;
    const py = evt.clientY;
    while (index >= this._pointerPositionsRC.length)
      this._pointerPositionsRC.push(new Vector2());
    const rc = this._pointerPositionsRC[index];
    rc.set(px, py);
    this.convertScreenspaceToRaycastSpace(rc);
  }
  /** get the next free id */
  getPointerIndex(pointerId) {
    let firstFreeIndex = -1;
    for (let i = 0; i < this._pointerIds.length; i++) {
      if (this._pointerIds[i] === pointerId)
        return i;
      else if (firstFreeIndex === -1 && this._pointerIds[i] === -1) {
        firstFreeIndex = i;
      }
    }
    if (firstFreeIndex !== -1) {
      this._pointerIds[firstFreeIndex] = pointerId;
      return firstFreeIndex;
    }
    if (debug5)
      console.log("PUSH pointerId:", pointerId);
    this._pointerIds.push(pointerId);
    return this._pointerIds.length - 1;
  }
  setPointerState(index, arr, value) {
    arr[index] = value;
  }
  setPointerStateT(index, arr, value) {
    arr[index] = value;
    return value;
  }
  onDispatchEvent(evt) {
    const prevContext = Context.Current;
    try {
      Context.Current = this.context;
      this.dispatchEvent(evt);
    } finally {
      Context.Current = prevContext;
    }
  }
};

// node_modules/@needle-tools/engine/lib/engine/xr/internal.js
var flipForwardMatrix = new Matrix4().makeRotationY(Math.PI);
var flipForwardQuaternion = new Quaternion().setFromAxisAngle(new Vector32(0, 1, 0), Math.PI);
var debug6 = getParam("debugwebxr");
var ImplictXRRig = class {
  constructor() {
    __publicField(this, "priority", -1e5);
    __publicField(this, "gameObject");
    this.gameObject = new Object3D();
    this.gameObject.name = "Implicit XR Rig";
    if (debug6) {
      const cube = CreateWireCube(16733661);
      cube.position.y += 0.5;
      this.gameObject.add(cube);
    }
  }
  isXRRig() {
    return true;
  }
  get isActive() {
    return this.gameObject.visible;
  }
};

// node_modules/@needle-tools/engine/lib/engine/xr/NeedleXRController.js
var debug7 = getParam("debugwebxr");
var debugCustomGesture = getParam("debugcustomgesture");
var DEFAULT_PROFILES_PATH = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles";
var DEFAULT_PROFILE = "generic-trigger";
var metacarpalToGripQuaternion = new Quaternion().setFromEuler(new Euler(MathUtils.degToRad(0), MathUtils.degToRad(-90), MathUtils.degToRad(-90)));
var metacarpalToGripPosition = new Vector32(0.04, -0.04, 0);
var NeedleXRController = class {
  constructor(session, device, index) {
    /** the Needle XR Session */
    __publicField(this, "xr");
    /**
     * https://developer.mozilla.org/en-US/docs/Web/API/XRInputSource
     */
    __publicField(this, "inputSource");
    /** the input source index */
    __publicField(this, "index", 0);
    /** When enabled the controller will create input events in the Needle Engine input system (e.g. when a button is pressed or the controller is moved)
     * You can disable this if you don't want inputs to go through the input system but be aware that this will result in `onPointerDown` component callbacks to not be invoked anymore for this XRController
    */
    __publicField(this, "emitEvents", true);
    __publicField(this, "_connected", true);
    __publicField(this, "_isTracking", false);
    __publicField(this, "__gamepad");
    __publicField(this, "__hand");
    __publicField(this, "__side");
    __publicField(this, "_hitTestSource");
    __publicField(this, "_hasSelectEvent", false);
    __publicField(this, "_isMxInk", false);
    __publicField(this, "_isMxInkFallback", false);
    __publicField(this, "_isMetaQuestTouchController", false);
    /** This is cleared at the beginning of each frame */
    __publicField(this, "_handJointPoses", /* @__PURE__ */ new Map());
    /** Grip matrix in grip space */
    __publicField(this, "_gripMatrix", new Matrix4());
    /** Grip position in grip space */
    __publicField(this, "_gripPosition", new Vector32());
    /** Grip rotation in grip space */
    __publicField(this, "_gripQuaternion", new Quaternion());
    __publicField(this, "_linearVelocity", new Vector32());
    __publicField(this, "_rayPositionRaw", new Vector32());
    __publicField(this, "_rayRotationRaw", new Quaternion());
    /** ray matrix in grip space */
    __publicField(this, "_rayMatrix", new Matrix4());
    /** Ray position in rig space */
    __publicField(this, "_rayPosition", new Vector32());
    /** Ray rotation in rig space */
    __publicField(this, "_rayQuaternion", new Quaternion());
    __publicField(this, "_gripWorldPosition", new Vector32());
    __publicField(this, "_gripWorldQuaternion", new Quaternion());
    __publicField(this, "_rayWorldPosition", new Vector32());
    __publicField(this, "_rayWorldQuaternion", new Quaternion());
    __publicField(this, "_pinchPosition", new Vector32());
    __publicField(this, "_ray");
    /** Recalculated once per update */
    __publicField(this, "_hand_wristDotUp");
    __publicField(this, "_object");
    __publicField(this, "_gripSpaceObject");
    __publicField(this, "_raySpaceObject");
    /** Assigned the model that you use for rendering. This can be used as a hint for other components */
    __publicField(this, "model", null);
    __publicField(this, "_debugAxesHelper", new AxesHelper(0.15));
    __publicField(this, "_debugGripAxesHelper", new AxesHelper(0.07));
    __publicField(this, "_debugRayAxesHelper", new AxesHelper(0.07));
    __publicField(this, "_hitTestSourcePromise", null);
    __publicField(this, "onPointerHits", (_evt) => {
    });
    __publicField(this, "_needleGamepadButtons", {});
    __publicField(this, "_buttonMap", /* @__PURE__ */ new Map());
    // the motion controller contains the controller scheme, we use this to simplify button access
    __publicField(this, "_motioncontroller");
    __publicField(this, "_layout");
    __publicField(this, "getMotionController");
    /**
     * When enabled the controller will automatically emit pointer down events to the Needle Engine Input System.
     * @default true
     */
    __publicField(this, "emitPointerDownEvent", true);
    /**
     * When enabled the controller will automatically emit pointer up events to the Needle Engine Input System.
     * @default true
     */
    __publicField(this, "emitPointerUpEvent", true);
    /**
     * When enabled the controller will automatically emit pointer move events to the Needle Engine Input System.
     * @default true
     */
    __publicField(this, "emitPointerMoveEvent", true);
    /**
     * The distance threshold for pointer move events. This value is in units in rig space
     * @default 0.03
     */
    __publicField(this, "pointerMoveDistanceThreshold", 0.03);
    /**
     * The angle threshold for pointer move events. This value is in radians.
     * @default 0.05
     */
    __publicField(this, "pointerMoveAngleThreshold", 0.05);
    __publicField(this, "_selectButtonIndex");
    __publicField(this, "_squeezeButtonIndex");
    __publicField(this, "onSelectStart", (evt) => {
      var _a2, _b, _c, _d;
      if (!this.emitPointerDownEvent)
        return;
      if (this.inputSource !== evt.inputSource)
        return;
      this.onUpdateFrame(evt.frame);
      this._hasSelectEvent = true;
      const selectComponentId = (_a2 = this._layout) == null ? void 0 : _a2.selectComponentId;
      const i = (_d = (_c = (_b = this._layout) == null ? void 0 : _b.components[selectComponentId]) == null ? void 0 : _c.gamepadIndices) == null ? void 0 : _d.button;
      if (i !== void 0)
        this._selectButtonIndex = i;
      if (debugCustomGesture)
        return;
      if (debug7)
        Gizmos.DrawDirection(this.rayWorldPosition, getTempVector(0, 0.01, 1).applyQuaternion(this.rayWorldQuaternion), 16711680, 10);
      this.emitPointerEvent(InputEvents.PointerDown, this._selectButtonIndex || 0, "xr-standard-trigger", true, evt);
    });
    __publicField(this, "onSelectEnd", (evt) => {
      if (!this.emitPointerUpEvent)
        return;
      if (debugCustomGesture)
        return;
      if (this.inputSource !== evt.inputSource)
        return;
      this.emitPointerEvent(InputEvents.PointerUp, this._selectButtonIndex || 0, "xr-standard-trigger", true, evt);
    });
    __publicField(this, "onSequeezeStart", (evt) => {
      var _a2, _b, _c;
      if (!this.emitPointerDownEvent)
        return;
      if (this.inputSource !== evt.inputSource)
        return;
      this._squeezeButtonIndex = (_c = (_b = (_a2 = this._layout) == null ? void 0 : _a2.components["xr-standard-squeeze"]) == null ? void 0 : _b.gamepadIndices) == null ? void 0 : _c.button;
      if (this._squeezeButtonIndex !== void 0) {
        if (debug7)
          Gizmos.DrawDirection(this.rayWorldPosition, getTempVector(0, 0.01, 1).applyQuaternion(this.rayWorldQuaternion), 255, 10);
        this.emitPointerEvent(InputEvents.PointerDown, this._squeezeButtonIndex || 0, "xr-standard-squeeze", true, evt);
      }
    });
    __publicField(this, "onSequeezeEnd", (evt) => {
      if (!this.emitPointerUpEvent)
        return;
      if (this.inputSource !== evt.inputSource)
        return;
      if (this._squeezeButtonIndex !== void 0)
        this.emitPointerEvent(InputEvents.PointerUp, this._squeezeButtonIndex || 0, "xr-standard-squeeze", true, evt);
    });
    /** Index = button index */
    __publicField(this, "states", {});
    __publicField(this, "_didMoveLastFrame", false);
    __publicField(this, "_lastPointerMovePosition", new Vector32());
    __publicField(this, "_lastPointerMoveQuaternion", new Quaternion());
    /** cached spatial pointer init object. We re-use it to not have */
    __publicField(this, "pointerInit");
    this.xr = session;
    this.inputSource = device;
    this.index = index;
    this._object = new Object3D();
    this._object.name = `NeedleXRController_${index}`;
    if (debug7) {
      this._object.add(this._debugAxesHelper);
      this._gripSpaceObject = new Object3D();
      this._raySpaceObject = new Object3D();
      this._gripSpaceObject.name = `NeedleXRController_${index}_gripSpace`;
      this._raySpaceObject.name = `NeedleXRController_${index}_raySpace`;
      this._gripSpaceObject.add(this._debugGripAxesHelper);
      this._raySpaceObject.add(this._debugRayAxesHelper);
      this.xr.context.scene.add(this._gripSpaceObject);
      this.xr.context.scene.add(this._raySpaceObject);
    }
    this.xr.context.scene.add(this._object);
    this._ray = new Ray();
    this.pointerInit = {
      origin: this,
      pointerType: this.hand ? "hand" : "controller",
      deviceIndex: this.index,
      pointerId: -1,
      mode: this.inputSource.targetRayMode,
      ray: this._ray,
      device: this._object,
      buttonName: "none"
    };
    this.initialize();
    this.subscribeEvents();
  }
  get context() {
    return this.xr.context;
  }
  /** Is the controller still connected?  */
  get connected() {
    return this._connected;
  }
  get isTracking() {
    return this._isTracking;
  }
  /** the input source gamepad giving raw access to the gamepad values
   * You should usually use the `getButton` and `getStick` methods instead to get access to named buttons and sticks
   */
  get gamepad() {
    return this.__gamepad ?? (this.__gamepad = this.inputSource.gamepad);
  }
  /** @returns true if this is a hand (otherwise this is a controller) */
  get isHand() {
    return this.hand != void 0;
  }
  /**
   * If this is a hand then this is the hand info (XRHand)
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRHand
   */
  get hand() {
    return this.__hand ?? (this.__hand = this.inputSource.hand);
  }
  /** threejs XRHandSpace, shorthand for `context.renderer.xr.getHand(controllerIndex)`
   * @link https://threejs.org/docs/#api/en/renderers/webxr/WebXRManager.getHand
  */
  get handObject() {
    return this.context.renderer.xr.getHand(this.index);
  }
  /** The input source profiles */
  get profiles() {
    return this.inputSource.profiles;
  }
  /** The device input layout */
  get layout() {
    return this._layout;
  }
  /** shorthand for `inputSource.targetRayMode` */
  get targetRayMode() {
    return this.inputSource.targetRayMode;
  }
  /** shorthand for `inputSource.targetRaySpace` */
  get targetRaySpace() {
    return this.inputSource.targetRaySpace;
  }
  /** shorthand for `inputSource.gripSpace` */
  get gripSpace() {
    return this.inputSource.gripSpace;
  }
  /**
   * If the controller if held in the left or right hand (or if it's a left or right hand)
   **/
  get side() {
    return this.__side ?? (this.__side = this.inputSource.handedness);
  }
  /** is right side. shorthand for `side === 'right'` */
  get isRight() {
    return this.side === "right";
  }
  /** is left side. shorthand for `side === 'left'` */
  get isLeft() {
    return this.side === "left";
  }
  /** is XR stylus, e.g. Logitech MX Ink */
  get isStylus() {
    return this._isMxInk;
  }
  /** The XRTransientInputHitTestSource can be used to perform hit tests with the controller ray against the real world.
   * see https://developer.mozilla.org/en-US/docs/Web/API/XRSession/requestHitTestSourceForTransientInput for more information
   * Requires the hit-test feature to be enabled in the XRSession
   *
   * NOTE: The hit test source should be cancelled once it's not needed anymore. Call `cancelHitTestSource` to do this
   */
  getHitTestSource() {
    if (!this._hitTestSource)
      this._requestHitTestSource();
    return this._hitTestSource;
  }
  get hasHitTestSource() {
    return this._hitTestSource;
  }
  /** Make sure to cancel the hittest source once it's not needed anymore */
  cancelHitTestSource() {
    if (this._hitTestSource) {
      this._hitTestSource.cancel();
      this._hitTestSource = void 0;
    }
  }
  get hasSelectEvent() {
    return this._hasSelectEvent;
  }
  /** Perform a hit test against the XR planes or meshes. shorthand for `xr.getHitTest(controller)`
   * @returns the hit test result (with position and rotation in worldspace) or null if no hit was found
   */
  getHitTest() {
    return this.xr.getHitTest(this);
  }
  /** Get the hand joint pose from the current XRFrame. Results are cached for a frame to avoid calling getJointPose multiple times */
  getHandJointPose(joint, frame) {
    var _a2;
    frame = frame || this.xr.frame;
    if (!this.hand || !(frame == null ? void 0 : frame.getJointPose) || !this.xr.referenceSpace)
      return null;
    let pose = (_a2 = this._handJointPoses) == null ? void 0 : _a2.get(joint);
    if (pose)
      return pose;
    pose = frame.getJointPose(joint, this.xr.referenceSpace);
    if (pose)
      this._handJointPoses.set(joint, pose);
    return pose;
  }
  /** Grip position in rig space */
  get gripPosition() {
    return getTempVector(this._gripPosition);
  }
  /** Grip rotation in rig space */
  get gripQuaternion() {
    return getTempQuaternion(this._gripQuaternion);
  }
  get gripMatrix() {
    return this._gripMatrix;
  }
  /** Grip linear velocity in rig space
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRPose/linearVelocity
   */
  get gripLinearVelocity() {
    return getTempVector(this._linearVelocity).applyQuaternion(flipForwardQuaternion);
  }
  /** Ray position in rig space */
  get rayPosition() {
    return getTempVector(this._rayPosition);
  }
  /** Ray rotation in rig space */
  get rayQuaternion() {
    return getTempQuaternion(this._rayQuaternion);
  }
  /** Controller grip position in worldspace */
  get gripWorldPosition() {
    return getTempVector(this._gripWorldPosition);
  }
  /** Controller grip rotation in wordspace */
  get gripWorldQuaternion() {
    return getTempQuaternion(this._gripWorldQuaternion);
  }
  /** Controller ray position in worldspace (this value is calculated once per frame by default - call `updateRayWorldPosition` to force an update) */
  get rayWorldPosition() {
    return getTempVector(this._rayWorldPosition);
  }
  /** Recalculates the ray world position */
  updateRayWorldPosition() {
    var _a2;
    const parent = (_a2 = this.xr.context.mainCamera) == null ? void 0 : _a2.parent;
    this._rayWorldPosition.copy(this._rayPositionRaw);
    if (parent)
      this._rayWorldPosition.applyMatrix4(parent.matrixWorld);
  }
  /** Controller ray rotation in wordspace (this value is calculated once per frame by default - call `updateRayWorldQuaternion` to force an update) */
  get rayWorldQuaternion() {
    return getTempQuaternion(this._rayWorldQuaternion);
  }
  get pinchPosition() {
    return getTempVector(this._pinchPosition);
  }
  /** Recalculates the ray world quaternion */
  updateRayWorldQuaternion() {
    var _a2;
    const parent = (_a2 = this.xr.context.mainCamera) == null ? void 0 : _a2.parent;
    const parentWorldQuaternion = parent ? getWorldQuaternion(parent) : void 0;
    this._rayWorldQuaternion.copy(this._rayRotationRaw).multiply(flipForwardQuaternion);
    if (parentWorldQuaternion)
      this._rayWorldQuaternion.premultiply(parentWorldQuaternion);
  }
  /** The controller ray in worldspace */
  get ray() {
    this._ray.origin.copy(this.rayWorldPosition);
    this._ray.direction.copy(getTempVector(0, 0, 1).applyQuaternion(this.rayWorldQuaternion));
    return this._ray;
  }
  /**
   * The dot product of the hand palm with the up vector.
   * This is a number between -1 and 1, where 1 means the palm is directly up and -1 means the palm is directly down (upside down).
   * This value is undefined if there's no hand
   */
  get handWristDotUp() {
    var _a2;
    if (this._hand_wristDotUp !== void 0)
      return this._hand_wristDotUp;
    const handPalm = (_a2 = this.handObject) == null ? void 0 : _a2.joints["wrist"];
    if (handPalm) {
      const up2 = getTempVector(0, 1, 0).applyQuaternion(handPalm.quaternion);
      const dot = getTempVector(0, 1, 0).dot(up2);
      return this._hand_wristDotUp = dot;
    }
    return void 0;
  }
  /**
   * @returns true if the hand is upside down
   */
  get isHandUpsideDown() {
    return this.handWristDotUp !== void 0 ? this.handWristDotUp < -0.7 : false;
  }
  /**
   * @returns true if the hand is upside down and we got a pinch down event this frame.
   */
  get isTeleportGesture() {
    var _a2;
    return this.isHandUpsideDown && ((_a2 = this.getGesture("pinch")) == null ? void 0 : _a2.isDown);
  }
  /** The controller object space.
   * You can use it to attach objects to the controller.
   * Children will be automatically detached and put into the scene when the controller disconnects
   */
  get object() {
    return this._object;
  }
  /** returns the URL of the default controller model */
  async getModelUrl() {
    var _a2;
    return (_a2 = this.getMotionController) == null ? void 0 : _a2.then((res) => (res == null ? void 0 : res.assetUrl) || null);
  }
  _requestHitTestSource() {
    var _a2;
    if (this._hitTestSourcePromise)
      return this._hitTestSourcePromise;
    if (this.xr.mode === "immersive-ar" && this.inputSource.targetRayMode === "tracked-pointer" && this.xr.session.requestHitTestSourceForTransientInput) {
      return this._hitTestSourcePromise = ((_a2 = this.xr.session.requestHitTestSourceForTransientInput({
        profile: this.inputSource.profiles[0],
        offsetRay: new XRRay()
      })) == null ? void 0 : _a2.then((hitTestSource) => {
        this._hitTestSourcePromise = null;
        if (!this.connected) {
          hitTestSource.cancel();
          return null;
        }
        return this._hitTestSource = hitTestSource;
      })) ?? null;
    }
    return null;
  }
  onUpdate(frame) {
    performance.mark("NeedleXRController onUpdate start");
    this.onUpdateFrame(frame);
    this.updateInputEvents();
    this.onUpdateMove();
    performance.mark("NeedleXRController onUpdate end");
    performance.measure("NeedleXRController onUpdate", "NeedleXRController onUpdate start", "NeedleXRController onUpdate end");
  }
  onRenderDebug() {
    var _a2;
    Gizmos.DrawSphere(this.rayWorldPosition, 3e-3);
    Gizmos.DrawDirection(this.rayWorldPosition, getTempVector(0, 0, 10).applyQuaternion(this.rayWorldQuaternion));
    const labelPosition = this.inputSource.gripSpace ? this.gripWorldPosition : this.object.worldPosition;
    const debugLabelPosition = labelPosition.sub(this.object.worldForward.multiplyScalar(0.1));
    const profileStr = this.inputSource.profiles.join("\n");
    let debugStr = `Controller[${this.index}] (${this.inputSource.targetRayMode}, ${this.side})
C:${this.connected ? "x" : "-"} T:${this.isTracking ? "x" : "-"} Hand:${this.inputSource.hand ? "x" : "-"} Pen: ${this._isMxInk ? "x" : "-"}`;
    if (this.inputSource.hand)
      debugStr += `
Pinch: ${(_a2 = this.getGesture("pinch")) == null ? void 0 : _a2.value.toFixed(3)}`;
    debugStr += "\n" + profileStr;
    debugStr += "\n" + (this.inputSource.targetRaySpace ? `Ray: x` : "Ray: -") + (this.inputSource.gripSpace ? " Grip: x" : " Grip: -") + (this.inputSource.gamepad ? ` Gamepad: ${this.inputSource.gamepad.mapping}` : " Gamepad: -");
    if (this.inputSource.gamepad) {
      const gp = this.inputSource.gamepad;
      let gamepadStr = "[btns " + gp.buttons.length + "]: " + gp.buttons.map((b) => b.value.toPrecision(1)).join(",");
      gamepadStr += "\n[axes " + gp.axes.length + "]: " + gp.axes.map((a) => a.toPrecision(1)).join(",");
      debugStr += "\n" + gamepadStr;
    }
    Gizmos.DrawLabel(debugLabelPosition, debugStr, 6e-3);
  }
  onUpdateFrame(frame) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
    this._handJointPoses.clear();
    this._hand_wristDotUp = void 0;
    if (!this.xr.referenceSpace) {
      this._isTracking = false;
      return;
    }
    const rayPose = frame.getPose(this.inputSource.targetRaySpace, this.xr.referenceSpace);
    this._isTracking = rayPose != null;
    let gripPositionRaw = null;
    let gripQuaternionRaw = null;
    let rayPositionRaw = null;
    let rayQuaternionRaw = null;
    if (rayPose) {
      const t2 = rayPose.transform;
      this._rayMatrix.fromArray(t2.matrix).premultiply(flipForwardMatrix);
      this._rayMatrix.decompose(this._rayPosition, this._rayQuaternion, getTempVector(1, 1, 1));
      rayPositionRaw = getTempVector(t2.position);
      rayQuaternionRaw = getTempQuaternion(t2.orientation);
      if (this._isMxInk && !this._isMxInkFallback) {
        const offset = getTempVector(0.013, 0, -0.028).applyQuaternion(rayQuaternionRaw);
        rayPositionRaw.add(offset);
        this._rayPosition.add(offset);
      }
      this._rayPositionRaw.copy(rayPositionRaw);
      this._rayRotationRaw.copy(rayQuaternionRaw);
    }
    if (this.inputSource.gripSpace) {
      const gripPose = frame.getPose(this.inputSource.gripSpace, this.xr.referenceSpace);
      if (gripPose) {
        const t2 = gripPose.transform;
        gripPositionRaw = getTempVector(t2.position);
        gripQuaternionRaw = getTempQuaternion(t2.orientation);
        this._gripMatrix.fromArray(t2.matrix).premultiply(flipForwardMatrix);
        this._gripMatrix.decompose(this._gripPosition, this._gripQuaternion, getTempVector(1, 1, 1));
        if ("linearVelocity" in gripPose && gripPose.linearVelocity) {
          const p = gripPose.linearVelocity;
          this._linearVelocity.set(p.x, p.y, p.z);
        }
      }
    }
    if ((_a2 = this.xr.context.mainCamera) == null ? void 0 : _a2.parent) {
      if (this._object.parent !== ((_b = this.xr.context.mainCamera) == null ? void 0 : _b.parent))
        this.xr.context.mainCamera.parent.add(this._object);
      if (this._gripSpaceObject !== void 0 && ((_c = this._gripSpaceObject) == null ? void 0 : _c.parent) !== ((_d = this.xr.context.mainCamera) == null ? void 0 : _d.parent))
        this.xr.context.mainCamera.parent.add(this._gripSpaceObject);
      if (this._raySpaceObject !== void 0 && ((_e = this._raySpaceObject) == null ? void 0 : _e.parent) !== ((_f = this.xr.context.mainCamera) == null ? void 0 : _f.parent))
        this.xr.context.mainCamera.parent.add(this._raySpaceObject);
    }
    const hand = this.hand;
    if (hand) {
      let gotWrist = false;
      const wrist = hand.get("wrist");
      const wristPose = wrist && this.getHandJointPose(wrist, frame);
      if (wristPose) {
        gotWrist = true;
        const p = wristPose.transform.position;
        const q = wristPose.transform.orientation;
        this._object.position.set(p.x, p.y, p.z);
        this._object.quaternion.set(q.x, q.y, q.z, q.w).multiply(flipForwardQuaternion);
      }
      if (!gotWrist) {
        this._object.position.copy(this._rayPosition);
        this._object.quaternion.copy(this._rayQuaternion).multiply(flipForwardQuaternion);
      }
      const middle = hand.get("middle-finger-metacarpal");
      const middlePose = middle && this.getHandJointPose(middle, frame);
      if (middlePose) {
        this._gripMatrix.fromArray(middlePose.transform.matrix).premultiply(flipForwardMatrix);
        this._gripMatrix.decompose(this._gripPosition, this._gripQuaternion, getTempVector(1, 1, 1));
        if (true) {
          gripPositionRaw = getTempVector().copy(middlePose.transform.position);
          gripQuaternionRaw = getTempQuaternion().copy(middlePose.transform.orientation);
          gripQuaternionRaw.multiply(metacarpalToGripQuaternion);
          gripPositionRaw.add(getTempVector(metacarpalToGripPosition).applyQuaternion(gripQuaternionRaw));
        }
      }
    } else if (this.inputSource.gripSpace && this.targetRayMode === "transient-pointer" && gripPositionRaw && gripQuaternionRaw) {
      this._object.position.copy(gripPositionRaw);
      this._object.quaternion.copy(gripQuaternionRaw).multiply(flipForwardQuaternion);
    } else if (rayPositionRaw && rayQuaternionRaw) {
      this._object.position.copy(rayPositionRaw);
      this._object.quaternion.copy(rayQuaternionRaw).multiply(flipForwardQuaternion);
    }
    if (debug7) {
      if (rayPositionRaw && rayQuaternionRaw) {
        (_g = this._raySpaceObject) == null ? void 0 : _g.position.copy(rayPositionRaw);
        (_h = this._raySpaceObject) == null ? void 0 : _h.quaternion.copy(rayQuaternionRaw).multiply(flipForwardQuaternion);
      }
      if (gripPositionRaw && gripQuaternionRaw) {
        (_i = this._gripSpaceObject) == null ? void 0 : _i.position.copy(gripPositionRaw);
        (_j = this._gripSpaceObject) == null ? void 0 : _j.quaternion.copy(gripQuaternionRaw).multiply(flipForwardQuaternion);
      }
    }
    const parent = (_k = this.xr.context.mainCamera) == null ? void 0 : _k.parent;
    const parentWorldQuaternion = parent ? getWorldQuaternion(parent) : void 0;
    if (gripPositionRaw && gripQuaternionRaw) {
      this._gripWorldPosition.copy(gripPositionRaw);
      if (parent)
        this._gripWorldPosition.applyMatrix4(parent.matrixWorld);
      this._gripWorldQuaternion.copy(gripQuaternionRaw);
      this._gripWorldQuaternion.multiply(flipForwardQuaternion);
      if (parentWorldQuaternion)
        this._gripWorldQuaternion.premultiply(parentWorldQuaternion);
    }
    this.updateRayWorldPosition();
    this.updateRayWorldQuaternion();
  }
  /** Called when the input source disconnects */
  onDisconnected() {
    var _a2, _b, _c, _d, _e, _f;
    this._connected = false;
    if (debug7)
      console.warn("Controller disconnected", this.index);
    for (const child of this._object.children) {
      this.xr.context.scene.attach(child);
    }
    (_a2 = this._object) == null ? void 0 : _a2.removeFromParent();
    (_b = this._debugAxesHelper) == null ? void 0 : _b.removeFromParent();
    (_c = this._debugGripAxesHelper) == null ? void 0 : _c.removeFromParent();
    (_d = this._debugRayAxesHelper) == null ? void 0 : _d.removeFromParent();
    (_e = this._gripSpaceObject) == null ? void 0 : _e.removeFromParent();
    (_f = this._raySpaceObject) == null ? void 0 : _f.removeFromParent();
    this.unsubscribeEvents();
    if (this._hitTestSource) {
      this._hitTestSource.cancel();
      this._hitTestSource = void 0;
    }
  }
  /**
   * Get a gamepad button
   * @link https://github.com/immersive-web/webxr-gamepads-module/blob/main/gamepads-module-explainer.md
   * @param key the controller button name e.g. x-button
   * @returns the gamepad button if it exists on the controller - otherwise undefined
   */
  getButton(key) {
    var _a2;
    if (!this._layout)
      return void 0;
    switch (key) {
      case "primary-button":
        if (this.isLeft)
          key = "x-button";
        else if (this.isRight)
          key = "a-button";
        else
          return void 0;
        break;
      case "primary":
        if (this.hand) {
          return this.getGesture("pinch");
        }
        return this.toNeedleGamepadButton(0, key);
    }
    if (this._buttonMap.has(key)) {
      return this.toNeedleGamepadButton(this._buttonMap.get(key), key);
    }
    const componentModel = (_a2 = this._layout) == null ? void 0 : _a2.components[key];
    if (componentModel == null ? void 0 : componentModel.gamepadIndices) {
      switch (componentModel.type) {
        case "button":
        case "squeeze":
          if (this.inputSource.gamepad) {
            const index = componentModel.gamepadIndices.button;
            this._buttonMap.set(key, index);
            return this.toNeedleGamepadButton(index, key);
          }
          break;
        default:
          console.warn("Unsupported component type", componentModel.type);
          break;
      }
    }
    this._buttonMap.set(key, void 0);
    return void 0;
  }
  /** Get a gesture state */
  getGesture(key) {
    const state = this.states[key];
    if (!state)
      return null;
    this.states[key] = state;
    const needleButton = this._needleGamepadButtons[key] || new NeedleGamepadButton(void 0, key);
    needleButton.pressed = state.pressed;
    needleButton.value = state.value;
    needleButton.isDown = state.isDown;
    needleButton.isUp = state.isUp;
    this._needleGamepadButtons[key] = needleButton;
    return needleButton;
  }
  getPointerId(button) {
    if (button === "primary") {
      button = 0;
    } else if (button === "pinch") {
      button = 0;
    }
    if (typeof button !== "number") {
      const needleButton = this._buttonMap.get(button);
      if (needleButton === void 0) {
        return void 0;
      }
      button = needleButton;
    }
    return this.index * 10 + button;
  }
  /** combine the InputState information + the GamepadButton information (since GamepadButtons can not be extended) */
  toNeedleGamepadButton(index, name) {
    var _a2, _b;
    if (!((_a2 = this.inputSource.gamepad) == null ? void 0 : _a2.buttons))
      return void 0;
    const button = (_b = this.inputSource.gamepad) == null ? void 0 : _b.buttons[index];
    const state = this.states[index];
    const needleButton = this._needleGamepadButtons[index] || new NeedleGamepadButton(index, name);
    if (button) {
      needleButton.pressed = button.pressed;
      needleButton.value = button.value;
      needleButton.touched = button.touched;
    }
    if (state) {
      needleButton.isDown = state.isDown;
      needleButton.isUp = state.isUp;
    }
    this._needleGamepadButtons[index] = needleButton;
    return needleButton;
  }
  /**
   * Get the values of a controller joystick
   * @link https://github.com/immersive-web/webxr-gamepads-module/blob/main/gamepads-module-explainer.md
   * @returns the stick values where x is left/right, y is up/down and z is the button value
   */
  getStick(key) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _i;
    if (!this._layout)
      return { x: 0, y: 0, z: 0 };
    if (key === "primary") {
      const x2 = ((_a2 = this.inputSource.gamepad) == null ? void 0 : _a2.axes[0]) || 0;
      const y = ((_b = this.inputSource.gamepad) == null ? void 0 : _b.axes[1]) || 0;
      const z = ((_d = (_c = this.inputSource.gamepad) == null ? void 0 : _c.buttons[3]) == null ? void 0 : _d.value) || 0;
      return { x: x2, y, z };
    }
    const componentModel = (_e = this._layout) == null ? void 0 : _e.components[key];
    if (componentModel == null ? void 0 : componentModel.gamepadIndices) {
      switch (componentModel.type) {
        case "thumbstick":
          if (this.inputSource.gamepad) {
            const xIndex = componentModel.gamepadIndices.xAxis;
            const yIndex = componentModel.gamepadIndices.yAxis;
            let x2 = (_f = this.inputSource.gamepad) == null ? void 0 : _f.axes[xIndex];
            let y = (_g = this.inputSource.gamepad) == null ? void 0 : _g.axes[yIndex];
            x2 *= -1;
            y *= -1;
            const buttonIndex = componentModel.gamepadIndices.button;
            const z = (_i = (_h = this.inputSource.gamepad) == null ? void 0 : _h.buttons[buttonIndex]) == null ? void 0 : _i.value;
            return { x: x2, y, z };
          }
      }
    }
    return { x: 0, y: 0, z: 0 };
  }
  initialize() {
    this._hasSelectEvent = this.profiles.includes("generic-hand-select") || this.profiles.some((p) => p.startsWith("generic-trigger"));
    this._isMetaQuestTouchController = this.profiles.includes("meta-quest-touch-plus") || this.profiles.includes("oculus-touch-v3");
    this._isMxInk = this.profiles.includes("logitech-mx-ink");
    if (!this._layout) {
      if (this.inputSource.targetRayMode === "transient-pointer")
        return;
      const fetchProfileCall = fetchProfile(this.inputSource, DEFAULT_PROFILES_PATH, DEFAULT_PROFILE);
      this.getMotionController = fetchProfileCall.then((res) => {
        var _a2;
        if (!this.connected)
          return null;
        if (this._isMxInk && !res.assetPath) {
          if (debug7)
            console.log("Falling back to custom MX Ink model", res.profile, res.assetPath);
          res.assetPath = "https://cdn.needle.tools/static/models/controllers/logitech_vr_stylus_v1.3.1_grip_questos68.glb";
          this._isMxInkFallback = true;
        }
        this._motioncontroller = new MotionController(this.inputSource, res.profile, res.assetPath || "");
        const profile = res.profile;
        const layout = profile.layouts[this.inputSource.handedness];
        this._layout = layout;
        if (this._layout) {
          if (!((_a2 = this._layout.gamepad) == null ? void 0 : _a2.length)) {
            this._layout.gamepad = [];
            for (const key in this._layout.components) {
              const component = this._layout.components[key];
              this._layout.gamepad[component.gamepadIndices.button] = key;
            }
          }
        }
        return this._motioncontroller;
      }).catch((err) => {
        if (this.inputSource)
          console.warn("Couldn't initialize motion controller profile for ", this.inputSource, err);
        return null;
      });
    }
  }
  subscribeEvents() {
    this.xr.session.addEventListener("selectstart", this.onSelectStart);
    this.xr.session.addEventListener("selectend", this.onSelectEnd);
    this.xr.session.addEventListener("squeezestart", this.onSequeezeStart);
    this.xr.session.addEventListener("squeezeend", this.onSequeezeEnd);
  }
  unsubscribeEvents() {
    this.xr.session.removeEventListener("selectstart", this.onSelectStart);
    this.xr.session.removeEventListener("selectend", this.onSelectEnd);
    this.xr.session.removeEventListener("squeezestart", this.onSequeezeStart);
    this.xr.session.removeEventListener("squeezeend", this.onSequeezeEnd);
  }
  // If we want to invoke button events for ALL buttons we need to keep track of the previous state
  // instead of using XR input select start events which is only raised for the primary button
  // we should probably do both but then we need to ignore the primary index in the following function (to not raise an event for the same button twice)
  // and start with index = 1
  updateInputEvents() {
    var _a2, _b, _c;
    if ((_a2 = this.gamepad) == null ? void 0 : _a2.buttons) {
      for (let index = 0; index < this.gamepad.buttons.length; index++) {
        const button = this.gamepad.buttons[index];
        const state = this.states[index] || new InputState();
        let eventName = null;
        if (this._isMxInk && (index === 4 || index === 5)) {
          if (button.value > 0 && !state.pressed) {
            eventName = "pointerdown";
            state.isDown = true;
            state.isUp = false;
          } else if (button.value === 0 && state.pressed) {
            eventName = "pointerup";
            state.isDown = false;
            state.isUp = true;
          } else if (state.pressed) {
            eventName = "pointermove";
            state.isDown = false;
            state.isUp = false;
          }
          state.pressed = button.value > 0;
          state.value = button.value;
        } else {
          if (button.pressed && !state.pressed) {
            eventName = "pointerdown";
            state.isDown = true;
            state.isUp = false;
          } else if (!button.pressed && state.pressed) {
            eventName = "pointerup";
            state.isDown = false;
            state.isUp = true;
          } else {
            state.isDown = false;
            state.isUp = false;
          }
          state.pressed = button.pressed;
          state.value = button.value;
        }
        this.states[index] = state;
        const emitEvent = index !== this._selectButtonIndex && index !== this._squeezeButtonIndex;
        if (eventName != null && emitEvent) {
          let name = (_b = this._layout) == null ? void 0 : _b.gamepad[index];
          if (this._isMxInk && index === 4)
            name = "stylus-touch";
          if (this._isMxInk && index === 5)
            name = "stylus-tip";
          if (debug7 || debugCustomGesture)
            console.log("Emitting pointer event", eventName, index, name, button.value, this.gamepad, this._layout);
          this.emitPointerEvent(eventName, index, name ?? "none", false, null, button.value);
        }
      }
      if (this._isMetaQuestTouchController) {
        const menuButtonIndex = this.gamepad.buttons.length - 1;
        const menuButtonState = this.states[menuButtonIndex];
        if (menuButtonState) {
          if (menuButtonState.isDown) {
            const menu = this.context.menu;
            if (menu.spatialMenuIsVisible)
              menu.setSpatialMenuVisible(false);
            else
              this.context.menu.setSpatialMenuVisible(true);
          }
        }
      }
    }
    if (this.hand) {
      const handObject = this.handObject;
      if (handObject) {
        const indexTip = handObject.joints["index-finger-tip"];
        const thumbTip = handObject.joints["thumb-tip"];
        if (indexTip && thumbTip) {
          const distance = indexTip.position.distanceTo(thumbTip.position);
          this._pinchPosition.lerpVectors(indexTip.position, thumbTip.position, 0.5);
          const parent = (_c = this.xr.context.mainCamera) == null ? void 0 : _c.parent;
          if (parent)
            this._pinchPosition.applyMatrix4(parent.matrixWorld);
          if (distance !== 0) {
            const pinchThreshold = 0.02;
            const pinchHysteresis = 0.01;
            const state = this.states["pinch"] || new InputState();
            const maxDistance = (pinchThreshold + pinchHysteresis) * 1.5;
            state.value = 1 - (distance - pinchThreshold) / maxDistance;
            const isPressed = distance < pinchThreshold - pinchHysteresis;
            const isReleased = distance > pinchThreshold + pinchHysteresis;
            if (isPressed && !state.pressed) {
              if (debugCustomGesture)
                console.log("pinch start", distance);
              state.isDown = true;
              state.isUp = false;
              state.pressed = true;
            } else if (isReleased && state.pressed) {
              state.isDown = false;
              state.isUp = true;
              state.pressed = false;
            } else {
              state.isDown = false;
              state.isUp = false;
            }
            this.states["pinch"] = state;
          }
        }
      }
    }
  }
  onUpdateMove() {
    var _a2, _b;
    if (!this.emitPointerMoveEvent)
      return;
    let didMove = false;
    const dist = this._lastPointerMovePosition.distanceTo(this.gripWorldPosition);
    if (dist > this.pointerMoveDistanceThreshold * this.xr.rigScale)
      didMove = true;
    if (!didMove) {
      const angle = this._lastPointerMoveQuaternion.angleTo(this.gripWorldQuaternion);
      if (angle > this.pointerMoveAngleThreshold)
        didMove = true;
    }
    if (didMove) {
      this._didMoveLastFrame = true;
      this._lastPointerMovePosition.copy(this.gripWorldPosition);
      this._lastPointerMoveQuaternion.copy(this.gripWorldQuaternion);
      if (debug7)
        Gizmos.DrawLabel(this.rayWorldPosition.add(this.object.worldForward.multiplyScalar(0.1)), "move", 0.01);
      let button = this.xr.context.input.getFirstPressedButtonForPointer(this.index);
      if (button === void 0)
        button = 0;
      const pressure = (_b = (_a2 = this.gamepad) == null ? void 0 : _a2.buttons[button]) == null ? void 0 : _b.value;
      this.emitPointerEvent("pointermove", button, "none", false, null, pressure);
    } else {
      this._didMoveLastFrame = false;
    }
  }
  emitPointerEvent(type, button, buttonName, primary, source = null, pressure) {
    if (!this.emitEvents) {
      if (debug7 && type !== InputEvents.PointerMove)
        console.warn("Pointer events are disabled for this controller", this.index, type, button);
      return;
    }
    if (this.xr.mode === "immersive-vr" || this.xr.isPassThrough) {
      this.pointerInit.origin = this;
      this.pointerInit.pointerId = this.getPointerId(button);
      this.pointerInit.pointerType = this.hand ? "hand" : "controller";
      this.pointerInit.button = button;
      this.pointerInit.buttonName = buttonName;
      this.pointerInit.isPrimary = primary;
      this.pointerInit.mode = this.inputSource.targetRayMode;
      this.pointerInit.ray = this.ray;
      this.pointerInit.device = this.object;
      this.pointerInit.pressure = pressure;
      this.pointerInit.clientX = this._rayPosition.x / this.xr.rigScale;
      this.pointerInit.clientY = this._rayPosition.y / this.xr.rigScale;
      this.pointerInit.clientZ = this._rayPosition.z / this.xr.rigScale;
      const prevContext = Context.Current;
      Context.Current = this.xr.context;
      if (debug7 && type !== "pointermove")
        console.warn("Pointer event", type, button, buttonName, { ...this.pointerInit });
      this.xr.context.input.createInputEvent(new NEPointerEvent(type, source, this.pointerInit));
      Context.Current = prevContext;
    }
  }
};
var InputState = class {
  constructor() {
    /** if the button was pressed the last update */
    __publicField(this, "isDown", false);
    /** if the button was released the last update */
    __publicField(this, "isUp", false);
    __publicField(this, "pressed", false);
    __publicField(this, "value", 0);
  }
};
var NeedleGamepadButton = class {
  constructor(index, name) {
    /** The index of the button in the input gamepad */
    __publicField(this, "index");
    __publicField(this, "name");
    __publicField(this, "touched", false);
    __publicField(this, "pressed", false);
    __publicField(this, "value", 0);
    /** was the button just pressed down the last update */
    __publicField(this, "isDown", false);
    /** was the button just released the last update */
    __publicField(this, "isUp", false);
    this.index = index;
    this.name = name;
  }
};

// node_modules/@needle-tools/engine/lib/engine/engine_lifecycle_functions_internal.js
var newMethods = /* @__PURE__ */ new Map();
var allMethods = /* @__PURE__ */ new Map();
var methodsWarningCounter = 0;
function registerFrameEventCallback(cb, evt, opts) {
  if (!newMethods.has(evt)) {
    newMethods.set(evt, new Array());
  }
  newMethods.get(evt).push({
    method: cb,
    options: { once: false, ...opts }
  });
  if (methodsWarningCounter < 30) {
    const existing = allMethods.get(evt);
    if (existing && (existing == null ? void 0 : existing.length) > 100) {
      methodsWarningCounter += 1;
      console.warn(`You have ${existing.length} methods registered for Event ${evt}.

This might be a performance issue!
Consider unregistering the methods when they are not needed anymore!

To unregister you can call the function returned by your event hook (e.g.const unregister = onStart(...)) 

or by using the once option like onStart(()=>{}, { once:true }).

See https://engine.needle.tools/docs/scripting.html#special-lifecycle-hooks for more information.`);
    }
  }
}
function unregisterFrameEventCallback(cb, evt) {
  const methods = allMethods.get(evt);
  if (methods) {
    for (let i = 0; i < methods.length; i++) {
      if (methods[i].method === cb) {
        methods.splice(i, 1);
        return;
      }
    }
  }
  const newMethodsArray = newMethods.get(evt);
  if (newMethodsArray) {
    for (let i = 0; i < newMethodsArray.length; i++) {
      if (newMethodsArray[i].method === cb) {
        newMethodsArray.splice(i, 1);
        return;
      }
    }
  }
}
function invokeLifecycleFunctions(ctx, evt) {
  if (evt === ContextEvent.ContextCreated) {
    _ignore.delete(ctx);
  }
  internalInvokeLifecycleFunctions(ctx, evt);
}
function internalInvokeLifecycleFunctions(ctx, evt) {
  if (evt === FrameEvent.Start) {
    const initializeMethods = newMethods.get(ContextEvent.ContextCreated);
    if (initializeMethods) {
      internalInvokeLifecycleFunctions(ctx, ContextEvent.ContextCreated);
    }
  }
  const shouldBeInvokedOnce = evt === FrameEvent.Start || evt === ContextEvent.ContextCreated;
  const methods = allMethods.get(evt);
  if (methods) {
    if (methods.length > 0) {
      const array = methods;
      invoke(ctx, array, shouldBeInvokedOnce);
    }
  }
  const newMethodsArray = newMethods.get(evt);
  if (newMethodsArray) {
    if (newMethodsArray.length > 0) {
      const array = [...newMethodsArray];
      newMethodsArray.length = 0;
      invoke(ctx, array, shouldBeInvokedOnce);
      if (array.length > 0) {
        if (!allMethods.has(evt)) {
          allMethods.set(evt, new Array());
        }
        const methodsArray = allMethods.get(evt);
        methodsArray.push(...array);
      }
    }
  }
}
var bufferArray = new Array();
var hookContext = {
  context: null
};
function invoke(ctx, methods, invokeOnce) {
  var _a2, _b;
  bufferArray.length = 0;
  for (let i = 0; i < methods.length; i++) {
    bufferArray.push(methods[i]);
  }
  let ignoreSet = _ignore.get(ctx);
  for (let i = 0; i < bufferArray.length; i++) {
    const entry = bufferArray[i];
    let invoke2 = true;
    if (ignoreSet && ignoreSet.has(entry)) {
      invoke2 = false;
    }
    if (invoke2) {
      try {
        hookContext.context = ctx;
        (_a2 = entry.method) == null ? void 0 : _a2.call(hookContext, ctx);
      } catch (e) {
        console.error("Error in lifecycle method", e);
      }
    }
    if ((_b = entry.options) == null ? void 0 : _b.once) {
      for (let j = 0; j < methods.length; j++) {
        if (methods[j] === entry) {
          methods.splice(j, 1);
          break;
        }
      }
    } else if (invokeOnce) {
      if (!ignoreSet) {
        ignoreSet = /* @__PURE__ */ new Set();
        _ignore.set(ctx, ignoreSet);
      }
      ignoreSet.add(entry);
    }
  }
}
var _ignore = /* @__PURE__ */ new WeakMap();

// node_modules/flatbuffers/mjs/constants.js
var SIZEOF_SHORT = 2;
var SIZEOF_INT = 4;
var FILE_IDENTIFIER_LENGTH = 4;
var SIZE_PREFIX_LENGTH = 4;

// node_modules/flatbuffers/mjs/utils.js
var int32 = new Int32Array(2);
var float32 = new Float32Array(int32.buffer);
var float64 = new Float64Array(int32.buffer);
var isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;

// node_modules/flatbuffers/mjs/long.js
var Long = class {
  constructor(low, high) {
    this.low = low | 0;
    this.high = high | 0;
  }
  static create(low, high) {
    return low == 0 && high == 0 ? Long.ZERO : new Long(low, high);
  }
  toFloat64() {
    return (this.low >>> 0) + this.high * 4294967296;
  }
  equals(other) {
    return this.low == other.low && this.high == other.high;
  }
};
Long.ZERO = new Long(0, 0);

// node_modules/flatbuffers/mjs/encoding.js
var Encoding;
(function(Encoding2) {
  Encoding2[Encoding2["UTF8_BYTES"] = 1] = "UTF8_BYTES";
  Encoding2[Encoding2["UTF16_STRING"] = 2] = "UTF16_STRING";
})(Encoding || (Encoding = {}));

// node_modules/flatbuffers/mjs/byte-buffer.js
var ByteBuffer = class {
  /**
   * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)
   */
  constructor(bytes_) {
    this.bytes_ = bytes_;
    this.position_ = 0;
  }
  /**
   * Create and allocate a new ByteBuffer with a given size.
   */
  static allocate(byte_size) {
    return new ByteBuffer(new Uint8Array(byte_size));
  }
  clear() {
    this.position_ = 0;
  }
  /**
   * Get the underlying `Uint8Array`.
   */
  bytes() {
    return this.bytes_;
  }
  /**
   * Get the buffer's position.
   */
  position() {
    return this.position_;
  }
  /**
   * Set the buffer's position.
   */
  setPosition(position) {
    this.position_ = position;
  }
  /**
   * Get the buffer's capacity.
   */
  capacity() {
    return this.bytes_.length;
  }
  readInt8(offset) {
    return this.readUint8(offset) << 24 >> 24;
  }
  readUint8(offset) {
    return this.bytes_[offset];
  }
  readInt16(offset) {
    return this.readUint16(offset) << 16 >> 16;
  }
  readUint16(offset) {
    return this.bytes_[offset] | this.bytes_[offset + 1] << 8;
  }
  readInt32(offset) {
    return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;
  }
  readUint32(offset) {
    return this.readInt32(offset) >>> 0;
  }
  readInt64(offset) {
    return new Long(this.readInt32(offset), this.readInt32(offset + 4));
  }
  readUint64(offset) {
    return new Long(this.readUint32(offset), this.readUint32(offset + 4));
  }
  readFloat32(offset) {
    int32[0] = this.readInt32(offset);
    return float32[0];
  }
  readFloat64(offset) {
    int32[isLittleEndian ? 0 : 1] = this.readInt32(offset);
    int32[isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);
    return float64[0];
  }
  writeInt8(offset, value) {
    this.bytes_[offset] = value;
  }
  writeUint8(offset, value) {
    this.bytes_[offset] = value;
  }
  writeInt16(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
  }
  writeUint16(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
  }
  writeInt32(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
    this.bytes_[offset + 2] = value >> 16;
    this.bytes_[offset + 3] = value >> 24;
  }
  writeUint32(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
    this.bytes_[offset + 2] = value >> 16;
    this.bytes_[offset + 3] = value >> 24;
  }
  writeInt64(offset, value) {
    this.writeInt32(offset, value.low);
    this.writeInt32(offset + 4, value.high);
  }
  writeUint64(offset, value) {
    this.writeUint32(offset, value.low);
    this.writeUint32(offset + 4, value.high);
  }
  writeFloat32(offset, value) {
    float32[0] = value;
    this.writeInt32(offset, int32[0]);
  }
  writeFloat64(offset, value) {
    float64[0] = value;
    this.writeInt32(offset, int32[isLittleEndian ? 0 : 1]);
    this.writeInt32(offset + 4, int32[isLittleEndian ? 1 : 0]);
  }
  /**
   * Return the file identifier.   Behavior is undefined for FlatBuffers whose
   * schema does not include a file_identifier (likely points at padding or the
   * start of a the root vtable).
   */
  getBufferIdentifier() {
    if (this.bytes_.length < this.position_ + SIZEOF_INT + FILE_IDENTIFIER_LENGTH) {
      throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
    }
    let result = "";
    for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {
      result += String.fromCharCode(this.readInt8(this.position_ + SIZEOF_INT + i));
    }
    return result;
  }
  /**
   * Look up a field in the vtable, return an offset into the object, or 0 if the
   * field is not present.
   */
  __offset(bb_pos, vtable_offset) {
    const vtable = bb_pos - this.readInt32(bb_pos);
    return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
  }
  /**
   * Initialize any Table-derived type to point to the union at the given offset.
   */
  __union(t2, offset) {
    t2.bb_pos = offset + this.readInt32(offset);
    t2.bb = this;
    return t2;
  }
  /**
   * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
   * This allocates a new string and converts to wide chars upon each access.
   *
   * To avoid the conversion to UTF-16, pass Encoding.UTF8_BYTES as
   * the "optionalEncoding" argument. This is useful for avoiding conversion to
   * and from UTF-16 when the data will just be packaged back up in another
   * FlatBuffer later on.
   *
   * @param offset
   * @param opt_encoding Defaults to UTF16_STRING
   */
  __string(offset, opt_encoding) {
    offset += this.readInt32(offset);
    const length = this.readInt32(offset);
    let result = "";
    let i = 0;
    offset += SIZEOF_INT;
    if (opt_encoding === Encoding.UTF8_BYTES) {
      return this.bytes_.subarray(offset, offset + length);
    }
    while (i < length) {
      let codePoint;
      const a = this.readUint8(offset + i++);
      if (a < 192) {
        codePoint = a;
      } else {
        const b = this.readUint8(offset + i++);
        if (a < 224) {
          codePoint = (a & 31) << 6 | b & 63;
        } else {
          const c2 = this.readUint8(offset + i++);
          if (a < 240) {
            codePoint = (a & 15) << 12 | (b & 63) << 6 | c2 & 63;
          } else {
            const d = this.readUint8(offset + i++);
            codePoint = (a & 7) << 18 | (b & 63) << 12 | (c2 & 63) << 6 | d & 63;
          }
        }
      }
      if (codePoint < 65536) {
        result += String.fromCharCode(codePoint);
      } else {
        codePoint -= 65536;
        result += String.fromCharCode((codePoint >> 10) + 55296, (codePoint & (1 << 10) - 1) + 56320);
      }
    }
    return result;
  }
  /**
   * Handle unions that can contain string as its member, if a Table-derived type then initialize it,
   * if a string then return a new one
   *
   * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this
   * makes the behaviour of __union_with_string different compared to __union
   */
  __union_with_string(o, offset) {
    if (typeof o === "string") {
      return this.__string(offset);
    }
    return this.__union(o, offset);
  }
  /**
   * Retrieve the relative offset stored at "offset"
   */
  __indirect(offset) {
    return offset + this.readInt32(offset);
  }
  /**
   * Get the start of data of a vector whose offset is stored at "offset" in this object.
   */
  __vector(offset) {
    return offset + this.readInt32(offset) + SIZEOF_INT;
  }
  /**
   * Get the length of a vector whose offset is stored at "offset" in this object.
   */
  __vector_len(offset) {
    return this.readInt32(offset + this.readInt32(offset));
  }
  __has_identifier(ident) {
    if (ident.length != FILE_IDENTIFIER_LENGTH) {
      throw new Error("FlatBuffers: file identifier must be length " + FILE_IDENTIFIER_LENGTH);
    }
    for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {
      if (ident.charCodeAt(i) != this.readInt8(this.position() + SIZEOF_INT + i)) {
        return false;
      }
    }
    return true;
  }
  /**
   * A helper function to avoid generated code depending on this file directly.
   */
  createLong(low, high) {
    return Long.create(low, high);
  }
  /**
   * A helper function for generating list for obj api
   */
  createScalarList(listAccessor, listLength) {
    const ret = [];
    for (let i = 0; i < listLength; ++i) {
      if (listAccessor(i) !== null) {
        ret.push(listAccessor(i));
      }
    }
    return ret;
  }
  /**
   * A helper function for generating list for obj api
   * @param listAccessor function that accepts an index and return data at that index
   * @param listLength listLength
   * @param res result list
   */
  createObjList(listAccessor, listLength) {
    const ret = [];
    for (let i = 0; i < listLength; ++i) {
      const val = listAccessor(i);
      if (val !== null) {
        ret.push(val.unpack());
      }
    }
    return ret;
  }
};

// node_modules/flatbuffers/mjs/builder.js
var Builder = class {
  /**
   * Create a FlatBufferBuilder.
   */
  constructor(opt_initial_size) {
    this.minalign = 1;
    this.vtable = null;
    this.vtable_in_use = 0;
    this.isNested = false;
    this.object_start = 0;
    this.vtables = [];
    this.vector_num_elems = 0;
    this.force_defaults = false;
    this.string_maps = null;
    let initial_size;
    if (!opt_initial_size) {
      initial_size = 1024;
    } else {
      initial_size = opt_initial_size;
    }
    this.bb = ByteBuffer.allocate(initial_size);
    this.space = initial_size;
  }
  clear() {
    this.bb.clear();
    this.space = this.bb.capacity();
    this.minalign = 1;
    this.vtable = null;
    this.vtable_in_use = 0;
    this.isNested = false;
    this.object_start = 0;
    this.vtables = [];
    this.vector_num_elems = 0;
    this.force_defaults = false;
    this.string_maps = null;
  }
  /**
   * In order to save space, fields that are set to their default value
   * don't get serialized into the buffer. Forcing defaults provides a
   * way to manually disable this optimization.
   *
   * @param forceDefaults true always serializes default values
   */
  forceDefaults(forceDefaults) {
    this.force_defaults = forceDefaults;
  }
  /**
   * Get the ByteBuffer representing the FlatBuffer. Only call this after you've
   * called finish(). The actual data starts at the ByteBuffer's current position,
   * not necessarily at 0.
   */
  dataBuffer() {
    return this.bb;
  }
  /**
   * Get the bytes representing the FlatBuffer. Only call this after you've
   * called finish().
   */
  asUint8Array() {
    return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
  }
  /**
   * Prepare to write an element of `size` after `additional_bytes` have been
   * written, e.g. if you write a string, you need to align such the int length
   * field is aligned to 4 bytes, and the string data follows it directly. If all
   * you need to do is alignment, `additional_bytes` will be 0.
   *
   * @param size This is the of the new element to write
   * @param additional_bytes The padding size
   */
  prep(size, additional_bytes) {
    if (size > this.minalign) {
      this.minalign = size;
    }
    const align_size = ~(this.bb.capacity() - this.space + additional_bytes) + 1 & size - 1;
    while (this.space < align_size + size + additional_bytes) {
      const old_buf_size = this.bb.capacity();
      this.bb = Builder.growByteBuffer(this.bb);
      this.space += this.bb.capacity() - old_buf_size;
    }
    this.pad(align_size);
  }
  pad(byte_size) {
    for (let i = 0; i < byte_size; i++) {
      this.bb.writeInt8(--this.space, 0);
    }
  }
  writeInt8(value) {
    this.bb.writeInt8(this.space -= 1, value);
  }
  writeInt16(value) {
    this.bb.writeInt16(this.space -= 2, value);
  }
  writeInt32(value) {
    this.bb.writeInt32(this.space -= 4, value);
  }
  writeInt64(value) {
    this.bb.writeInt64(this.space -= 8, value);
  }
  writeFloat32(value) {
    this.bb.writeFloat32(this.space -= 4, value);
  }
  writeFloat64(value) {
    this.bb.writeFloat64(this.space -= 8, value);
  }
  /**
   * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int8` to add the the buffer.
   */
  addInt8(value) {
    this.prep(1, 0);
    this.writeInt8(value);
  }
  /**
   * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int16` to add the the buffer.
   */
  addInt16(value) {
    this.prep(2, 0);
    this.writeInt16(value);
  }
  /**
   * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int32` to add the the buffer.
   */
  addInt32(value) {
    this.prep(4, 0);
    this.writeInt32(value);
  }
  /**
   * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int64` to add the the buffer.
   */
  addInt64(value) {
    this.prep(8, 0);
    this.writeInt64(value);
  }
  /**
   * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `float32` to add the the buffer.
   */
  addFloat32(value) {
    this.prep(4, 0);
    this.writeFloat32(value);
  }
  /**
   * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `float64` to add the the buffer.
   */
  addFloat64(value) {
    this.prep(8, 0);
    this.writeFloat64(value);
  }
  addFieldInt8(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addInt8(value);
      this.slot(voffset);
    }
  }
  addFieldInt16(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addInt16(value);
      this.slot(voffset);
    }
  }
  addFieldInt32(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addInt32(value);
      this.slot(voffset);
    }
  }
  addFieldInt64(voffset, value, defaultValue) {
    if (this.force_defaults || !value.equals(defaultValue)) {
      this.addInt64(value);
      this.slot(voffset);
    }
  }
  addFieldFloat32(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addFloat32(value);
      this.slot(voffset);
    }
  }
  addFieldFloat64(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addFloat64(value);
      this.slot(voffset);
    }
  }
  addFieldOffset(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addOffset(value);
      this.slot(voffset);
    }
  }
  /**
   * Structs are stored inline, so nothing additional is being added. `d` is always 0.
   */
  addFieldStruct(voffset, value, defaultValue) {
    if (value != defaultValue) {
      this.nested(value);
      this.slot(voffset);
    }
  }
  /**
   * Structures are always stored inline, they need to be created right
   * where they're used.  You'll get this assertion failure if you
   * created it elsewhere.
   */
  nested(obj) {
    if (obj != this.offset()) {
      throw new Error("FlatBuffers: struct must be serialized inline.");
    }
  }
  /**
   * Should not be creating any other object, string or vector
   * while an object is being constructed
   */
  notNested() {
    if (this.isNested) {
      throw new Error("FlatBuffers: object serialization must not be nested.");
    }
  }
  /**
   * Set the current vtable at `voffset` to the current location in the buffer.
   */
  slot(voffset) {
    if (this.vtable !== null)
      this.vtable[voffset] = this.offset();
  }
  /**
   * @returns Offset relative to the end of the buffer.
   */
  offset() {
    return this.bb.capacity() - this.space;
  }
  /**
   * Doubles the size of the backing ByteBuffer and copies the old data towards
   * the end of the new buffer (since we build the buffer backwards).
   *
   * @param bb The current buffer with the existing data
   * @returns A new byte buffer with the old data copied
   * to it. The data is located at the end of the buffer.
   *
   * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass
   * it a uint8Array we need to suppress the type check:
   * @suppress {checkTypes}
   */
  static growByteBuffer(bb) {
    const old_buf_size = bb.capacity();
    if (old_buf_size & 3221225472) {
      throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
    }
    const new_buf_size = old_buf_size << 1;
    const nbb = ByteBuffer.allocate(new_buf_size);
    nbb.setPosition(new_buf_size - old_buf_size);
    nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);
    return nbb;
  }
  /**
   * Adds on offset, relative to where it will be written.
   *
   * @param offset The offset to add.
   */
  addOffset(offset) {
    this.prep(SIZEOF_INT, 0);
    this.writeInt32(this.offset() - offset + SIZEOF_INT);
  }
  /**
   * Start encoding a new object in the buffer.  Users will not usually need to
   * call this directly. The FlatBuffers compiler will generate helper methods
   * that call this method internally.
   */
  startObject(numfields) {
    this.notNested();
    if (this.vtable == null) {
      this.vtable = [];
    }
    this.vtable_in_use = numfields;
    for (let i = 0; i < numfields; i++) {
      this.vtable[i] = 0;
    }
    this.isNested = true;
    this.object_start = this.offset();
  }
  /**
   * Finish off writing the object that is under construction.
   *
   * @returns The offset to the object inside `dataBuffer`
   */
  endObject() {
    if (this.vtable == null || !this.isNested) {
      throw new Error("FlatBuffers: endObject called without startObject");
    }
    this.addInt32(0);
    const vtableloc = this.offset();
    let i = this.vtable_in_use - 1;
    for (; i >= 0 && this.vtable[i] == 0; i--) {
    }
    const trimmed_size = i + 1;
    for (; i >= 0; i--) {
      this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);
    }
    const standard_fields = 2;
    this.addInt16(vtableloc - this.object_start);
    const len = (trimmed_size + standard_fields) * SIZEOF_SHORT;
    this.addInt16(len);
    let existing_vtable = 0;
    const vt1 = this.space;
    outer_loop:
      for (i = 0; i < this.vtables.length; i++) {
        const vt2 = this.bb.capacity() - this.vtables[i];
        if (len == this.bb.readInt16(vt2)) {
          for (let j = SIZEOF_SHORT; j < len; j += SIZEOF_SHORT) {
            if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {
              continue outer_loop;
            }
          }
          existing_vtable = this.vtables[i];
          break;
        }
      }
    if (existing_vtable) {
      this.space = this.bb.capacity() - vtableloc;
      this.bb.writeInt32(this.space, existing_vtable - vtableloc);
    } else {
      this.vtables.push(this.offset());
      this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);
    }
    this.isNested = false;
    return vtableloc;
  }
  /**
   * Finalize a buffer, poiting to the given `root_table`.
   */
  finish(root_table, opt_file_identifier, opt_size_prefix) {
    const size_prefix = opt_size_prefix ? SIZE_PREFIX_LENGTH : 0;
    if (opt_file_identifier) {
      const file_identifier = opt_file_identifier;
      this.prep(this.minalign, SIZEOF_INT + FILE_IDENTIFIER_LENGTH + size_prefix);
      if (file_identifier.length != FILE_IDENTIFIER_LENGTH) {
        throw new Error("FlatBuffers: file identifier must be length " + FILE_IDENTIFIER_LENGTH);
      }
      for (let i = FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {
        this.writeInt8(file_identifier.charCodeAt(i));
      }
    }
    this.prep(this.minalign, SIZEOF_INT + size_prefix);
    this.addOffset(root_table);
    if (size_prefix) {
      this.addInt32(this.bb.capacity() - this.space);
    }
    this.bb.setPosition(this.space);
  }
  /**
   * Finalize a size prefixed buffer, pointing to the given `root_table`.
   */
  finishSizePrefixed(root_table, opt_file_identifier) {
    this.finish(root_table, opt_file_identifier, true);
  }
  /**
   * This checks a required field has been set in a given table that has
   * just been constructed.
   */
  requiredField(table, field) {
    const table_start = this.bb.capacity() - table;
    const vtable_start = table_start - this.bb.readInt32(table_start);
    const ok = this.bb.readInt16(vtable_start + field) != 0;
    if (!ok) {
      throw new Error("FlatBuffers: field " + field + " must be set");
    }
  }
  /**
   * Start a new array/vector of objects.  Users usually will not call
   * this directly. The FlatBuffers compiler will create a start/end
   * method for vector types in generated code.
   *
   * @param elem_size The size of each element in the array
   * @param num_elems The number of elements in the array
   * @param alignment The alignment of the array
   */
  startVector(elem_size, num_elems, alignment) {
    this.notNested();
    this.vector_num_elems = num_elems;
    this.prep(SIZEOF_INT, elem_size * num_elems);
    this.prep(alignment, elem_size * num_elems);
  }
  /**
   * Finish off the creation of an array and all its elements. The array must be
   * created with `startVector`.
   *
   * @returns The offset at which the newly created array
   * starts.
   */
  endVector() {
    this.writeInt32(this.vector_num_elems);
    return this.offset();
  }
  /**
   * Encode the string `s` in the buffer using UTF-8. If the string passed has
   * already been seen, we return the offset of the already written string
   *
   * @param s The string to encode
   * @return The offset in the buffer where the encoded string starts
   */
  createSharedString(s) {
    if (!s) {
      return 0;
    }
    if (!this.string_maps) {
      this.string_maps = /* @__PURE__ */ new Map();
    }
    if (this.string_maps.has(s)) {
      return this.string_maps.get(s);
    }
    const offset = this.createString(s);
    this.string_maps.set(s, offset);
    return offset;
  }
  /**
   * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed
   * instead of a string, it is assumed to contain valid UTF-8 encoded data.
   *
   * @param s The string to encode
   * @return The offset in the buffer where the encoded string starts
   */
  createString(s) {
    if (!s) {
      return 0;
    }
    let utf8;
    if (s instanceof Uint8Array) {
      utf8 = s;
    } else {
      utf8 = [];
      let i = 0;
      while (i < s.length) {
        let codePoint;
        const a = s.charCodeAt(i++);
        if (a < 55296 || a >= 56320) {
          codePoint = a;
        } else {
          const b = s.charCodeAt(i++);
          codePoint = (a << 10) + b + (65536 - (55296 << 10) - 56320);
        }
        if (codePoint < 128) {
          utf8.push(codePoint);
        } else {
          if (codePoint < 2048) {
            utf8.push(codePoint >> 6 & 31 | 192);
          } else {
            if (codePoint < 65536) {
              utf8.push(codePoint >> 12 & 15 | 224);
            } else {
              utf8.push(codePoint >> 18 & 7 | 240, codePoint >> 12 & 63 | 128);
            }
            utf8.push(codePoint >> 6 & 63 | 128);
          }
          utf8.push(codePoint & 63 | 128);
        }
      }
    }
    this.addInt8(0);
    this.startVector(1, utf8.length, 1);
    this.bb.setPosition(this.space -= utf8.length);
    for (let i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {
      bytes[offset++] = utf8[i];
    }
    return this.endVector();
  }
  /**
   * A helper function to avoid generated code depending on this file directly.
   */
  createLong(low, high) {
    return Long.create(low, high);
  }
  /**
   * A helper function to pack an object
   *
   * @returns offset of obj
   */
  createObjectOffset(obj) {
    if (obj === null) {
      return 0;
    }
    if (typeof obj === "string") {
      return this.createString(obj);
    } else {
      return obj.pack(this);
    }
  }
  /**
   * A helper function to pack a list of object
   *
   * @returns list of offsets of each non null object
   */
  createObjectOffsetList(list) {
    const ret = [];
    for (let i = 0; i < list.length; ++i) {
      const val = list[i];
      if (val !== null) {
        ret.push(this.createObjectOffset(val));
      } else {
        throw new Error("FlatBuffers: Argument for createObjectOffsetList cannot contain null.");
      }
    }
    return ret;
  }
  createStructOffsetList(list, startFunc) {
    startFunc(this, list.length);
    this.createObjectOffsetList(list);
    return this.endVector();
  }
};

// node_modules/@needle-tools/engine/lib/engine-schemes/schemes.js
var binaryIdentifierCasts = {};
function registerBinaryType(identifier, cast) {
  binaryIdentifierCasts[identifier] = cast;
}
function tryCastBinary(bin) {
  const id = bin.getBufferIdentifier();
  const cast = binaryIdentifierCasts[id];
  const mod = cast(bin);
  return mod;
}
function tryGetGuid(obj) {
  if (typeof obj["guid"] === "function") {
    return obj.guid();
  }
  return null;
}

// node_modules/@needle-tools/engine/lib/engine/engine_networking_peer.js
var peerOptions = void 0;
function getPeerOptions() {
  return peerOptions;
}
function setPeerOptions(opts) {
  peerOptions = opts;
}
function getPeerjsInstance(id, opts) {
  if (!opts)
    opts = {};
  opts = {
    ...peerOptions,
    ...opts
  };
  if (id)
    return new $70d766613f57b014$export$2e2bcd8739ae039(id, opts);
  return new $70d766613f57b014$export$2e2bcd8739ae039(opts);
}
async function importPeer() {
  const pkg = await import("./bundler-32ZNZ4NL.js");
  console.log(pkg);
  if (pkg.default === void 0)
    return pkg;
  return pkg.default;
}
var MessageType;
(function(MessageType2) {
  MessageType2["ConnectionList"] = "connection-list";
})(MessageType || (MessageType = {}));
var PeerNetworking = class {
  constructor() {
    __publicField(this, "_host");
    __publicField(this, "_client");
    __publicField(this, "_clientData");
    this.onEnable();
  }
  get isHost() {
    return this._host !== void 0;
  }
  onEnable() {
    const hostId = "HOST-5980e65c-8438-453e-8b35-f13c736dcd81";
    this.trySetupHost(hostId);
  }
  async trySetupHost(id) {
    const Peer = await importPeer();
    const host = new Peer(id);
    host.on("error", (err) => {
      console.error(err);
      this._host = void 0;
      this.trySetupClient(id);
    });
    host.on("open", (_id) => {
      this._host = new PeerHost(host);
    });
  }
  async trySetupClient(hostId) {
    const Peer = await importPeer();
    this._client = new Peer();
    this._client.on("error", (err) => {
      console.error("Client error", err);
    });
    this._client.on("open", (id) => {
      console.log("client connected", id);
      this._clientData = this._client.connect(hostId, { metadata: { id } });
      this._clientData.on("open", () => {
        console.log("Connected to host");
      });
      this._clientData.on("data", (data) => {
        console.log("<<", data);
      });
    });
  }
};
var AbstractPeerHandler = class {
  constructor(peer) {
    __publicField(this, "_peer");
    this._peer = peer;
  }
};
var PeerHost = class extends AbstractPeerHandler {
  constructor(peer) {
    var _a2;
    super(peer);
    __publicField(this, "_connections", []);
    console.log("I AM THE HOST");
    (_a2 = this._peer) == null ? void 0 : _a2.on("connection", this.onConnection.bind(this));
    this._peer.on("close", () => {
      this.broadcast("BYE");
    });
    setInterval(() => {
      this.broadcast("HELLO");
    }, 2e3);
  }
  get isHost() {
    return true;
  }
  onConnection(con) {
    console.log("host connection", con);
    con.on("open", () => {
      this._connections.push(con);
      this.broadcastConnection(con);
    });
  }
  broadcastConnection(_con) {
    const connectionIds = this._connections.map((c2) => {
      var _a2;
      return (_a2 = c2.metadata) == null ? void 0 : _a2.id;
    }).filter((id) => id !== void 0);
    this.broadcast({ "type": MessageType.ConnectionList, "connections": connectionIds });
  }
  broadcast(msg) {
    if (msg === void 0 || msg === null)
      return;
    console.log(">>", msg);
    for (const cur in this._peer.connections) {
      const curCon = this._peer.connections[cur];
      if (!curCon)
        continue;
      if (Array.isArray(curCon)) {
        for (const entry of curCon) {
          if (!entry)
            continue;
          entry.send(msg);
        }
      } else {
        console.warn(curCon);
      }
    }
  }
};

// node_modules/@needle-tools/engine/lib/engine/engine_networking_types.js
var SendQueue;
(function(SendQueue2) {
  SendQueue2[SendQueue2["OnConnection"] = 0] = "OnConnection";
  SendQueue2[SendQueue2["OnRoomJoin"] = 1] = "OnRoomJoin";
  SendQueue2[SendQueue2["Queued"] = 2] = "Queued";
  SendQueue2[SendQueue2["Immediate"] = 3] = "Immediate";
})(SendQueue || (SendQueue = {}));

// node_modules/@needle-tools/engine/lib/engine/engine_networking.js
var defaultNetworkingBackendUrlProvider = "https://urls.needle.tools/default-networking-backend/index";
var networkingServerUrl = "wss://networking.needle.tools/socket";
var debugNet = getParam("debugnet") ? true : false;
var debugOwner = debugNet || getParam("debugowner") ? true : false;
var debugnetBin = getParam("debugnetbin");
var ConnectionEvents;
(function(ConnectionEvents2) {
  ConnectionEvents2["ConnectionInfo"] = "connection-start-info";
})(ConnectionEvents || (ConnectionEvents = {}));
var RoomEvents;
(function(RoomEvents2) {
  RoomEvents2["Join"] = "join-room";
  RoomEvents2["Leave"] = "leave-room";
  RoomEvents2["JoinedRoom"] = "joined-room";
  RoomEvents2["LeftRoom"] = "left-room";
  RoomEvents2["UserJoinedRoom"] = "user-joined-room";
  RoomEvents2["UserLeftRoom"] = "user-left-room";
  RoomEvents2["RoomStateSent"] = "room-state-sent";
})(RoomEvents || (RoomEvents = {}));
var JoinedRoomResponse = class {
  constructor() {
    __publicField(this, "room");
    // room name
    __publicField(this, "viewId");
    __publicField(this, "allowEditing");
    __publicField(this, "inRoom");
  }
  // connection ids
};
var LeftRoomResponse = class {
  constructor() {
    __publicField(this, "room");
  }
  // room name
};
var UserJoinedOrLeftRoomModel = class {
  constructor() {
    __publicField(this, "userId");
  }
};
var OwnershipEvent;
(function(OwnershipEvent2) {
  OwnershipEvent2["RequestHasOwner"] = "request-has-owner";
  OwnershipEvent2["ResponseHasOwner"] = "response-has-owner";
  OwnershipEvent2["RequestIsOwner"] = "request-is-owner";
  OwnershipEvent2["ResponseIsOwner"] = "response-is-owner";
  OwnershipEvent2["RequestOwnership"] = "request-ownership";
  OwnershipEvent2["GainedOwnership"] = "gained-ownership";
  OwnershipEvent2["RemoveOwnership"] = "remove-ownership";
  OwnershipEvent2["LostOwnership"] = "lost-ownership";
  OwnershipEvent2["GainedOwnershipBroadcast"] = "gained-ownership-broadcast";
  OwnershipEvent2["LostOwnershipBroadcast"] = "lost-ownership-broadcast";
})(OwnershipEvent || (OwnershipEvent = {}));
var OwnershipModel = class {
  constructor(connection, guid) {
    __publicField(this, "guid");
    __publicField(this, "connection");
    __publicField(this, "_hasOwnership", false);
    __publicField(this, "_isOwned");
    __publicField(this, "_gainSubscription");
    __publicField(this, "_lostSubscription");
    __publicField(this, "_hasOwnerResponse");
    __publicField(this, "_isWaitingForOwnershipResponseCallback", null);
    this.connection = connection;
    this.guid = guid;
    this._gainSubscription = this.onGainedOwnership.bind(this);
    this._lostSubscription = this.onLostOwnership.bind(this);
    connection.beginListen(OwnershipEvent.LostOwnership, this._lostSubscription);
    connection.beginListen(OwnershipEvent.GainedOwnershipBroadcast, this._gainSubscription);
    this._hasOwnerResponse = this.onHasOwnerResponse.bind(this);
    connection.beginListen(OwnershipEvent.ResponseHasOwner, this._hasOwnerResponse);
  }
  get hasOwnership() {
    return this._hasOwnership;
  }
  // TODO: server should just send id to everyone
  // if anyone has ownership
  get isOwned() {
    return this._isOwned;
  }
  get isConnected() {
    return this.connection.isConnected;
  }
  updateIsOwned() {
    this.connection.send(OwnershipEvent.RequestHasOwner, { guid: this.guid });
  }
  onHasOwnerResponse(res) {
    if (res.guid === this.guid) {
      this._isOwned = res.value;
    }
  }
  requestOwnershipIfNotOwned() {
    if (this._isWaitingForOwnershipResponseCallback !== null)
      return this;
    this._isWaitingForOwnershipResponseCallback = this.waitForHasOwnershipRequestResponse.bind(this);
    this.connection.beginListen(OwnershipEvent.ResponseHasOwner, this._isWaitingForOwnershipResponseCallback);
    this.connection.send(OwnershipEvent.RequestHasOwner, { guid: this.guid });
    return this;
  }
  waitForHasOwnershipRequestResponse(res) {
    if (res.guid === this.guid) {
      if (this._isWaitingForOwnershipResponseCallback) {
        this.connection.stopListen(OwnershipEvent.ResponseHasOwner, this._isWaitingForOwnershipResponseCallback);
        this._isWaitingForOwnershipResponseCallback = null;
      }
      this._isOwned = res.value;
      if (!res.value) {
        if (debugOwner)
          console.log("request ownership", this.guid);
        this.requestOwnership();
      }
    }
  }
  requestOwnershipAsync() {
    return new Promise((resolve2, reject) => {
      this.requestOwnership();
      let updates = 0;
      const waitForOwnership = () => {
        if (updates++ > 10)
          return reject("Timeout");
        setTimeout(() => {
          if (this.hasOwnership)
            resolve2(this);
          else
            waitForOwnership();
        }, 100);
      };
      waitForOwnership();
    });
  }
  requestOwnership() {
    if (debugOwner)
      console.log("Request ownership", this.guid);
    this.connection.send(OwnershipEvent.RequestOwnership, { guid: this.guid });
    return this;
  }
  freeOwnership() {
    this.connection.send(OwnershipEvent.RemoveOwnership, { guid: this.guid });
    if (this._isWaitingForOwnershipResponseCallback) {
      this.connection.stopListen(OwnershipEvent.ResponseHasOwner, this._isWaitingForOwnershipResponseCallback);
      this._isWaitingForOwnershipResponseCallback = null;
    }
    return this;
  }
  destroy() {
    this.connection.stopListen(OwnershipEvent.GainedOwnership, this._gainSubscription);
    this.connection.stopListen(OwnershipEvent.LostOwnership, this._lostSubscription);
    this.connection.stopListen(OwnershipEvent.ResponseHasOwner, this._hasOwnerResponse);
    if (this._isWaitingForOwnershipResponseCallback) {
      this.connection.stopListen(OwnershipEvent.ResponseHasOwner, this._isWaitingForOwnershipResponseCallback);
      this._isWaitingForOwnershipResponseCallback = null;
    }
  }
  onGainedOwnership(res) {
    if (res.guid === this.guid) {
      this._isOwned = true;
      if (this.connection.connectionId === res.owner) {
        if (debugOwner)
          console.log("GAINED OWNERSHIP", this.guid);
        this._hasOwnership = true;
      } else
        this._hasOwnership = false;
    }
  }
  onLostOwnership(guid) {
    if (guid === this.guid) {
      if (debugOwner)
        console.log("LOST OWNERSHIP", this.guid);
      this._hasOwnership = false;
      this._isOwned = false;
    }
  }
};
var NetworkConnection = class {
  constructor(context) {
    __publicField(this, "context");
    __publicField(this, "_peer", null);
    __publicField(this, "_usersInRoomCopy", []);
    __publicField(this, "_defaultMessagesBuffer", []);
    __publicField(this, "_defaultMessagesBufferArray", []);
    __publicField(this, "netWebSocketUrlProvider");
    __publicField(this, "_listeners", {});
    __publicField(this, "_listenersBinary", {});
    __publicField(this, "connected", false);
    __publicField(this, "channelId");
    __publicField(this, "_connectionId", null);
    // Websocket ------------------------------------------------------------
    __publicField(this, "_ws");
    __publicField(this, "_waitingForSocket", {});
    __publicField(this, "_isInRoom", false);
    __publicField(this, "_currentRoomName", null);
    __publicField(this, "_currentRoomViewId", null);
    __publicField(this, "_currentRoomAllowEditing", true);
    __publicField(this, "_currentInRoom", []);
    __publicField(this, "_state", {});
    __publicField(this, "_currentDelay", -1);
    __publicField(this, "_connectingToWebsocketPromise", null);
    this.context = context;
  }
  /** Experimental: networking via peerjs */
  get peer() {
    if (!this._peer) {
      this._peer = new PeerNetworking();
    }
    return this._peer;
  }
  /**
   * Returns the state of a given guid.
   */
  tryGetState(guid) {
    if (guid === "invalid")
      return null;
    return this._state[guid];
  }
  /** The connection id of the local user - it is given by the networking backend and can not be changed */
  get connectionId() {
    return this._connectionId;
  }
  /** Returns true if the networking backend is in debug mode.
   * To see all networking messages in the console use `?debugnet` in the url
   */
  get isDebugEnabled() {
    return debugNet;
  }
  /** True when connected to the networking backend */
  get isConnected() {
    return this.connected;
  }
  /** The name of the room the user is currently connected to */
  get currentRoomName() {
    return this._currentRoomName;
  }
  /** True when connected to a room via a regular url, otherwise (when using a view only url) false indicating that the user should not be able to modify the scene */
  get allowEditing() {
    return this._currentRoomAllowEditing;
  }
  /**
   * The view id of the room the user is currently connected to.
   */
  get currentRoomViewId() {
    return this._currentRoomViewId;
  }
  /**
   * Returns a url that can be shared with others to view the current room in view only mode.
   * This is useful for sharing a room with others without allowing them to modify the scene.
   * Use `connection.allowEditing` to check if the current room is in view only mode.
   */
  getViewOnlyUrl() {
    if (this.currentRoomViewId === null)
      return null;
    const url = new URL(window.location.href);
    url.searchParams.set("view", this.currentRoomViewId);
    return url.href;
  }
  /** True if connected to a networked room. Use the joinRoom function or a `SyncedRoom` component */
  get isInRoom() {
    return this._isInRoom;
  }
  /** Latency to currently connected backend server */
  get currentLatency() {
    return this._currentDelay;
  }
  /**
   * The current server url that the networking backend is connected to (e.g. the url of the websocket server)
   */
  get currentServerUrl() {
    var _a2;
    return ((_a2 = this._ws) == null ? void 0 : _a2.url) ?? null;
  }
  /** A ping is sent to the server at a regular interval while the browser tab is active. This method can be used to send additional ping messages when needed so that the user doesn't get disconnected from the networking backend */
  sendPing() {
    this.send("ping", { time: this.context.time.time });
  }
  /** Returns true if a user with the given connectionId is in the room */
  userIsInRoom(id) {
    return this._currentInRoom.indexOf(id) !== -1;
  }
  /** Returns a list of all user ids in the current room */
  usersInRoom(target = null) {
    if (!target)
      target = this._usersInRoomCopy;
    target.length = 0;
    for (const user of this._currentInRoom)
      target.push(user);
    return target;
  }
  /** Joins a networked room. If you don't want to manage a connection yourself you can use a `SyncedRoom` component as well */
  joinRoom(room, viewOnly = false) {
    if (!room) {
      console.error('Missing room name, can not join: "' + room + '"');
      return false;
    }
    if (room.length > 1024) {
      console.error('Room name too long, can not join: "' + room + '". Max length is 1024 characters.');
      return false;
    }
    this.connect();
    if (debugNet)
      console.log("join: " + room);
    this.send(RoomEvents.Join, { room, viewOnly }, SendQueue.OnConnection);
    return true;
  }
  /** Use to leave a room that you are currently connected to (use `leaveRoom()` to disconnect from the currently active room but you can also specify a room name) */
  leaveRoom(room = null) {
    if (!room)
      room = this.currentRoomName;
    if (!room) {
      console.error('Missing room name, can not join: "' + room + '"');
      return false;
    }
    this.send(RoomEvents.Leave, { room });
    return true;
  }
  /** Send a message to the networking backend - it will broadcasted to all connected users in the same room by default */
  send(key, data = null, queue = SendQueue.Queued) {
    if (data === null)
      data = {};
    if (queue === SendQueue.Queued) {
      this._defaultMessagesBuffer.push({ key, value: data });
      return;
    }
    return this.sendWithWebsocket(key, data, queue);
  }
  /** Use to delete state for a given guid on the server */
  sendDeleteRemoteState(guid) {
    this.send("delete-state", { guid, dontSave: true });
    delete this._state[guid];
  }
  /** Use to delete all state in the currently connected room on the server */
  sendDeleteRemoteStateAll() {
    this.send("delete-all-state");
    this._state = {};
  }
  /** Send a binary message to the server (broadcasted to all connected users) */
  sendBinary(bin) {
    var _a2;
    if (debugnetBin)
      console.log("<< send binary", this.context.time.frame, bin.length / 1024 + " KB");
    (_a2 = this._ws) == null ? void 0 : _a2.send(bin);
  }
  sendBufferedMessagesNow() {
    var _a2;
    if (!this._ws)
      return;
    this._defaultMessagesBufferArray.length = 0;
    const count = Object.keys(this._defaultMessagesBuffer).length;
    for (const key in this._defaultMessagesBuffer) {
      const data = this._defaultMessagesBuffer[key];
      if (count <= 1) {
        this.sendWithWebsocket(data.key, data.value, SendQueue.Immediate);
        break;
      }
      const msg = this.toMessage(data.key, data.value);
      this._defaultMessagesBufferArray.push(msg);
    }
    this._defaultMessagesBuffer.length = 0;
    if (this._defaultMessagesBufferArray.length > 0 && debugNet)
      console.log("SEND BUFFERED", this._defaultMessagesBufferArray.length);
    if (this._defaultMessagesBufferArray.length <= 0)
      return;
    const message = JSON.stringify(this._defaultMessagesBufferArray);
    (_a2 = this._ws) == null ? void 0 : _a2.send(message);
  }
  /** Use to start listening to networking events.
   * To unsubscribe from events use the `stopListen` method.
   * See the example below for typical usage:
   *
   * ### Component Example
   * ```ts
   * // Make sure to unsubscribe from events when the component is disabled
   * export class MyComponent extends Behaviour {
   *   onEnable() {
   *     this.connection.beginListen("joined-room", this.onJoinedRoom)
   *   }
   *   onDisable() {
   *     this.connection.stopListen("joined-room", this.onJoinedRoom)
   *   }
   *   onJoinedRoom = () => {
   *      console.log("I joined a networked room")
   *   }
   * }
   * ```
   * @link https://engine.needle.tools/docs/networking.html
   *
  */
  beginListen(key, callback) {
    if (!this._listeners[key])
      this._listeners[key] = [];
    this._listeners[key].push(callback);
    return callback;
  }
  /**@deprecated please use stopListen instead (2.65.2-pre) */
  stopListening(key, callback) {
    return this.stopListen(key, callback);
  }
  /** Use to stop listening to networking events
   * To subscribe to events use the `beginListen` method.
   * See the example below for typical usage:
   *
   * ### Component Example
   * ```ts
   * // Make sure to unsubscribe from events when the component is disabled
   * export class MyComponent extends Behaviour {
   *   onEnable() {
   *     this.connection.beginListen("joined-room", this.onJoinedRoom)
   *   }
   *   onDisable() {
   *     this.connection.stopListen("joined-room", this.onJoinedRoom)
   *   }
   *   onJoinedRoom = () => {
   *      console.log("I joined a networked room")
   *   }
   * }
   * ```
   */
  stopListen(key, callback) {
    if (!callback)
      return;
    if (!this._listeners[key])
      return;
    const index = this._listeners[key].indexOf(callback);
    if (index >= 0) {
      this._listeners[key].splice(index, 1);
    }
  }
  /** Use to start listening to networking binary events */
  beginListenBinary(identifier, callback) {
    if (!this._listenersBinary[identifier])
      this._listenersBinary[identifier] = [];
    this._listenersBinary[identifier].push(callback);
    return callback;
  }
  /** Use to stop listening to networking binary events */
  stopListenBinary(identifier, callback) {
    if (!this._listenersBinary[identifier])
      return;
    const index = this._listenersBinary[identifier].indexOf(callback);
    if (index >= 0) {
      this._listenersBinary[identifier].splice(index, 1);
    }
  }
  /** Use to override the networking server backend url. This is what the `Networking` component uses to modify the backend url */
  registerProvider(prov) {
    this.netWebSocketUrlProvider = prov;
  }
  /** Used to connect to the networking server */
  async connect(url) {
    var _a2;
    if (this.connected && url && url !== networkingServerUrl) {
      return Promise.reject("Can not connect to different server url. Please disconnect first.");
    }
    if (this.connected) {
      return Promise.resolve(true);
    }
    if (url)
      console.debug("Connecting to user provided url " + url);
    const overrideUrl = url || ((_a2 = this.netWebSocketUrlProvider) == null ? void 0 : _a2.getWebsocketUrl());
    if (overrideUrl) {
      networkingServerUrl = overrideUrl;
    } else if (isHostedOnGlitch()) {
      networkingServerUrl = "wss://" + window.location.host + "/socket";
    }
    return this.connectWebsocket();
  }
  /** Used to disconnect from the networking server */
  disconnect() {
    var _a2;
    (_a2 = this._ws) == null ? void 0 : _a2.close();
    this._ws = void 0;
    networkingServerUrl = void 0;
  }
  connectWebsocket() {
    if (this._connectingToWebsocketPromise)
      return this._connectingToWebsocketPromise;
    return this._connectingToWebsocketPromise = new Promise(async (res, _) => {
      var _a2, _b;
      let didResolve = false;
      const resolve2 = (val) => {
        if (didResolve)
          return;
        didResolve = true;
        res(val);
      };
      if (networkingServerUrl === void 0) {
        console.log("Fetch default backend url: " + defaultNetworkingBackendUrlProvider);
        const failed = false;
        const defaultUrlResponse = await fetch(defaultNetworkingBackendUrlProvider);
        networkingServerUrl = await defaultUrlResponse.text();
        if (failed)
          return;
      }
      if (networkingServerUrl === void 0) {
        resolve2(false);
        return;
      }
      console.debug("⊡ Connecting to networking backend on\n" + networkingServerUrl);
      const pkg = await import("./src-XB5GKDX2.js");
      const WebsocketBuilder = ((_a2 = pkg.default) == null ? void 0 : _a2.WebsocketBuilder) ?? pkg.WebsocketBuilder;
      const ExponentialBackoff = ((_b = pkg.default) == null ? void 0 : _b.ExponentialBackoff) ?? pkg.ExponentialBackoff;
      const ws = new WebsocketBuilder(networkingServerUrl).withMaxRetries(10).withBackoff(new ExponentialBackoff(2e3, 4)).onOpen(() => {
        this._connectingToWebsocketPromise = null;
        this._ws = ws;
        this.connected = true;
        if (isDevEnvironment() || debugNet)
          console.log("⊞ Connected to networking backend\n" + networkingServerUrl);
        else
          console.debug("⊞ Connected to networking backend", networkingServerUrl);
        resolve2(true);
        this.onSendQueued(SendQueue.OnConnection);
      }).onClose((_evt) => {
        this._connectingToWebsocketPromise = null;
        this.connected = false;
        this._isInRoom = false;
        resolve2(false);
        let msg = "Websocket connection closed...";
        if (!(networkingServerUrl == null ? void 0 : networkingServerUrl.includes("/socket")))
          msg += ` Do you perhaps mean to connect to "/socket"?`;
        console.error(msg);
      }).onError((_e) => {
        console.error("⊠ Websocket connection failed...");
        resolve2(false);
      }).onRetry(() => {
        console.log("→ Retry connecting to networking websocket");
      }).build();
      ws.addEventListener(pkg.WebsocketEvent.message, (socket, msg) => {
        this.onMessage(socket, msg);
      });
    });
  }
  onMessage(_, ev) {
    const msg = ev.data;
    try {
      if (typeof msg !== "string") {
        if (msg.size) {
          this.handleIncomingBinaryMessage(msg);
        }
        return;
      }
      const message = JSON.parse(msg);
      if (Array.isArray(message)) {
        for (const msg2 of message) {
          this.handleIncomingStringMessage(msg2);
        }
      } else
        this.handleIncomingStringMessage(message);
      return;
    } catch (err) {
      if (debugNet && msg === "pong")
        console.log("<<", msg);
      else if (isDevEnvironment())
        console.error("Failed to parse message", err);
    }
  }
  async handleIncomingBinaryMessage(blob) {
    if (debugnetBin)
      console.log("<< bin", this.context.time.frame);
    const buf = await blob.arrayBuffer();
    var data = new Uint8Array(buf);
    const bb = new ByteBuffer(data);
    const id = bb.getBufferIdentifier();
    const callbacks = this._listenersBinary[id];
    const obj = tryCastBinary(bb);
    const guid = tryGetGuid(obj);
    if (guid && typeof guid === "string") {
      this._state[guid] = obj;
    }
    if (!callbacks)
      return;
    const res = obj ?? bb;
    for (const cb of callbacks) {
      cb(res);
    }
  }
  handleIncomingStringMessage(message) {
    var _a2, _b;
    if (debugNet)
      console.log("<<", message.key ?? message);
    if (message.key) {
      switch (message.key) {
        case ConnectionEvents.ConnectionInfo:
          if (message.data) {
            const connection = message.data;
            if (connection) {
              console.assert(connection.id !== void 0 && connection.id !== null && connection.id.length > 0, "server did not send connection id", connection.id);
              console.debug("Your id is: " + connection.id, this.context.alias ?? "");
              this._connectionId = connection.id;
            }
          } else
            console.warn("Expected connection id in " + message.key);
          break;
        case RoomEvents.JoinedRoom:
          if (debugNet)
            console.log(message);
          if (message) {
            this._isInRoom = true;
            const model3 = message;
            this._currentRoomName = model3.room;
            this._currentRoomViewId = model3.viewId;
            this._currentRoomAllowEditing = model3.allowEditing ?? true;
            this._currentInRoom.length = 0;
            this._currentInRoom.push(...model3.inRoom);
            if (debugnetBin || isDevEnvironment())
              console.debug("Joined Needle Engine Room: " + model3.room);
            const viewUrl = new URL(window.location.href);
            if (viewUrl.searchParams.has("room")) {
              viewUrl.searchParams.delete("room");
            }
            viewUrl.searchParams.set("view", this._currentRoomViewId);
            console.debug(`Room view id: ${this._currentRoomViewId}
${viewUrl.href}`);
          }
          this.onSendQueued(SendQueue.OnRoomJoin);
          break;
        case RoomEvents.LeftRoom:
          const model2 = message;
          if (model2.room === this.currentRoomName) {
            this._isInRoom = false;
            this._currentRoomName = null;
            this._currentInRoom.length = 0;
          }
          break;
        case RoomEvents.UserJoinedRoom:
          if (message.data) {
            const model3 = message.data;
            this._currentInRoom.push(model3.userId);
            if (debugNet)
              console.log(model3.userId + " joined", "now in room:", this._currentInRoom);
          }
          break;
        case RoomEvents.UserLeftRoom:
          if (message.data) {
            const model3 = message.data;
            const index = this._currentInRoom.indexOf(model3.userId);
            if (index >= 0) {
              if (debugNet)
                console.log(model3.userId + " left", "now in room:", this._currentInRoom);
              this._currentInRoom.splice(index, 1);
            }
            if (model3.userId === this.connectionId) {
              console.log("you left the room");
            }
          }
          break;
        case "all-room-state-deleted":
          if (debugNet)
            console.log("RECEIVED all-room-state-deleted");
          this._state = {};
          break;
        case "ping":
        case "pong":
          const time = (_a2 = message.data) == null ? void 0 : _a2.time;
          if (time) {
            this._currentDelay = this.context.time.time - time;
          }
          if (debugNet)
            console.log("Current latency: " + this._currentDelay.toFixed(4) + " sec", "Clients in room: " + ((_b = this._currentInRoom) == null ? void 0 : _b.length));
          break;
      }
    }
    const model = message.data;
    if (model) {
      this._state[model.guid] = model;
    }
    let listeners = this._listeners[message.key];
    if (listeners) {
      listeners = [...listeners];
      for (const listener of listeners) {
        try {
          listener(message.data);
        } catch (err) {
          console.error('Error invoking callback for "' + message.key + '"', err);
        }
      }
    }
  }
  toMessage(key, data) {
    return {
      key,
      data
    };
  }
  sendWithWebsocket(key, data, queue = SendQueue.OnRoomJoin) {
    if (!this._ws) {
      const arr = this._waitingForSocket[queue] || [];
      arr.push(() => this.sendWithWebsocket(key, data, queue));
      this._waitingForSocket[queue] = arr;
      return;
    }
    const str = JSON.stringify(this.toMessage(key, data));
    if (debugNet)
      console.log(">>", key);
    this._ws.send(str);
  }
  onSendQueued(queue) {
    const queued = this._waitingForSocket[queue];
    if (queued) {
      for (const callback of queued) {
        callback();
      }
      queued.length = 0;
    }
  }
};

// node_modules/@needle-tools/engine/lib/engine/xr/NeedleXRSync.js
var debug8 = getParam("debugwebxr");
var XRUserState = class {
  constructor(userId, context) {
    __publicField(this, "controllerStates", []);
    __publicField(this, "userId");
    __publicField(this, "context");
    __publicField(this, "userStateEvtName");
    __publicField(this, "onReceivedControllerState", (state) => {
      if (debug8)
        console.log(`XRSync: Received change for ${this.userId}: ${state.type} ${state.handedness}; tracked=${state.isTracking}`);
      let found = false;
      for (let i = 0; i < this.controllerStates.length; i++) {
        const ctrl = this.controllerStates[i];
        if (ctrl.index === state.index) {
          this.controllerStates[i] = state;
          found = true;
          break;
        }
      }
      if (!found) {
        this.controllerStates.push(state);
      }
    });
    this.userId = userId;
    this.context = context;
    this.userStateEvtName = "xr-sync-user-state-" + userId;
    this.context.connection.beginListen(this.userStateEvtName, this.onReceivedControllerState);
  }
  dispose() {
    this.context.connection.stopListen(this.userStateEvtName, this.onReceivedControllerState);
  }
  update(session) {
    if (this.context.connection.isConnected == false)
      return;
    for (let i = this.controllerStates.length - 1; i >= 0; i--) {
      const state = this.controllerStates[i];
      let foundController = false;
      for (let i2 = 0; i2 < session.controllers.length; i2++) {
        const ctrl = session.controllers[i2];
        if (ctrl.index === state.index) {
          foundController = true;
        }
      }
      if (!foundController) {
        if (debug8)
          console.log(`XRSync: ${state.type} ${state.handedness} removed`, state.index);
        this.controllerStates.splice(i, 1);
        this.sendControllerRemoved(state);
      }
    }
    for (const ctrl of session.controllers) {
      this.updateControllerStates(ctrl);
    }
  }
  onExitXR(_session) {
    for (const state of this.controllerStates) {
      this.sendControllerRemoved(state);
    }
    this.controllerStates.length = 0;
  }
  sendControllerRemoved(state) {
    state.isTracking = false;
    state.guid = "";
    this.context.connection.send(this.userStateEvtName, state);
    this.context.connection.sendDeleteRemoteState(state.guid);
  }
  updateControllerStates(ctrl) {
    const existing = this.controllerStates.find((x2) => x2.index === ctrl.index);
    if (existing) {
      let hasChanged = false;
      hasChanged || (hasChanged = existing.isTracking != ctrl.isTracking);
      if (hasChanged) {
        existing.isTracking = ctrl.isTracking;
        this.context.connection.send(this.userStateEvtName, existing);
      }
    } else {
      const state = {
        guid: this.userId + "-" + ctrl.index,
        isTracking: ctrl.isTracking,
        handedness: ctrl.side,
        index: ctrl.index,
        type: ctrl.hand ? "hand" : "controller"
      };
      this.controllerStates.push(state);
      this.context.connection.send(this.userStateEvtName, state);
      if (debug8)
        console.log(`XRSync: ${state.type} ${state.handedness} added`, state.index);
    }
  }
};
var NeedleXRSync = class {
  constructor(context) {
    __publicField(this, "context");
    __publicField(this, "onJoinedRoom", () => {
      if (this.context.connection.connectionId) {
        if (!this._states.has(this.context.connection.connectionId)) {
          if (debug8)
            console.log("XRSync: Local user joined room", this.context.connection.connectionId);
          this._states.set(this.context.connection.connectionId, new XRUserState(this.context.connection.connectionId, this.context));
        }
        for (const user of this.context.connection.usersInRoom()) {
          if (!this._states.has(user)) {
            this._states.set(user, new XRUserState(user, this.context));
          }
        }
      }
    });
    __publicField(this, "onLeftRoom", () => {
      if (this.context.connection.connectionId) {
        if (!this._states.has(this.context.connection.connectionId)) {
          const state = this._states.get(this.context.connection.connectionId);
          state == null ? void 0 : state.dispose();
          this._states.delete(this.context.connection.connectionId);
        }
      }
    });
    __publicField(this, "onOtherUserJoinedRoom", (evt) => {
      const userId = evt.userId;
      if (!this._states.has(userId)) {
        if (debug8)
          console.log("XRSync: Remote user joined room", userId);
        this._states.set(userId, new XRUserState(userId, this.context));
      }
    });
    __publicField(this, "onOtherUserLeftRoom", (evt) => {
      const userId = evt.userId;
      if (!this._states.has(userId)) {
        const state = this._states.get(userId);
        state == null ? void 0 : state.dispose();
        this._states.delete(userId);
      }
    });
    __publicField(this, "_states", /* @__PURE__ */ new Map());
    this.context = context;
    this.context.connection.beginListen(RoomEvents.JoinedRoom, this.onJoinedRoom);
    this.context.connection.beginListen(RoomEvents.LeftRoom, this.onLeftRoom);
    this.context.connection.beginListen(RoomEvents.UserJoinedRoom, this.onOtherUserJoinedRoom);
    this.context.connection.beginListen(RoomEvents.UserLeftRoom, this.onOtherUserLeftRoom);
  }
  hasState(userId) {
    if (!userId)
      return false;
    return this._states.has(userId);
  }
  /** Is the left controller or hand tracked */
  isTracking(userId, handedness) {
    if (!userId)
      return void 0;
    const user = this._states.get(userId);
    if (!user)
      return void 0;
    const ctrl = user.controllerStates.find((x2) => x2.handedness === handedness);
    return (ctrl == null ? void 0 : ctrl.isTracking) || false;
  }
  /** Is it hand tracking or a controller */
  getDeviceType(userId, handedness) {
    if (!userId)
      return void 0;
    const user = this._states.get(userId);
    if (!user)
      return void 0;
    const ctrl = user.controllerStates.find((x2) => x2.handedness === handedness);
    return (ctrl == null ? void 0 : ctrl.type) || "unknown";
  }
  destroy() {
    this.context.connection.stopListen(RoomEvents.JoinedRoom, this.onJoinedRoom);
    this.context.connection.stopListen(RoomEvents.LeftRoom, this.onLeftRoom);
    this.context.connection.stopListen(RoomEvents.UserJoinedRoom, this.onOtherUserJoinedRoom);
    this.context.connection.stopListen(RoomEvents.UserLeftRoom, this.onOtherUserLeftRoom);
  }
  onUpdate(session) {
    if (this.context.connection.isConnected && this.context.connection.connectionId) {
      const localState = this._states.get(this.context.connection.connectionId);
      localState == null ? void 0 : localState.update(session);
    }
  }
  onExitXR(session) {
    if (this.context.connection.isConnected && this.context.connection.connectionId) {
      const localState = this._states.get(this.context.connection.connectionId);
      localState == null ? void 0 : localState.onExitXR(session);
    }
  }
};

// node_modules/@needle-tools/engine/lib/engine/xr/SceneTransition.js
var SceneTransition = class {
  constructor() {
    __publicField(this, "_fadeToColorQuad");
    __publicField(this, "_fadeToColorMaterial");
    __publicField(this, "_requestedFadeValue", 0);
    __publicField(this, "_transitionPromise", null);
    __publicField(this, "_transitionResolve", null);
    this._fadeToColorMaterial = new MeshBasicMaterial({
      color: 0,
      transparent: true,
      depthTest: false,
      fog: false,
      side: DoubleSide
    });
    this._fadeToColorQuad = new Mesh(new PlaneGeometry(10, 10), this._fadeToColorMaterial);
  }
  dispose() {
    this._fadeToColorQuad.geometry.dispose();
    this._fadeToColorMaterial.dispose();
  }
  update(camera, dt) {
    const quad = this._fadeToColorQuad;
    const mat = this._fadeToColorMaterial;
    if (quad.parent !== camera && mat.opacity > 0) {
      camera.add(quad);
    } else if (mat.opacity === 0) {
      quad.removeFromParent();
    }
    quad.layers.set(2);
    quad.material = this._fadeToColorMaterial;
    quad.position.z = -1;
    quad.renderOrder = Infinity;
    const fadeValue = this._requestedFadeValue;
    mat.opacity = Mathf.lerp(mat.opacity, fadeValue, dt / 0.03);
    if (Math.abs(mat.opacity - fadeValue) <= 0.01) {
      if (this._transitionResolve) {
        this._transitionResolve();
        this._transitionResolve = null;
        this._transitionPromise = null;
        this._requestedFadeValue = 0;
      }
    }
  }
  remove() {
    this._fadeToColorQuad.removeFromParent();
  }
  /** Call to fade rendering to black for a short moment (the returned promise will be resolved when fully black)
   * This can be used to mask scene transitions or teleportation
   * @returns a promise that is resolved when the screen is fully black
   * @example `fadeTransition().then(() => { <fully_black> })`
  */
  fadeTransition() {
    if (this._transitionPromise)
      return this._transitionPromise;
    this._requestedFadeValue = 1;
    const promise = new Promise((resolve2) => {
      this._transitionResolve = resolve2;
    });
    this._transitionPromise = promise;
    return promise;
  }
};

// node_modules/three/examples/jsm/geometries/TextGeometry.js
var TextGeometry = class extends ExtrudeGeometry {
  constructor(text, parameters = {}) {
    const font = parameters.font;
    if (font === void 0) {
      super();
    } else {
      const shapes = font.generateShapes(text, parameters.size);
      if (parameters.depth === void 0 && parameters.height !== void 0) {
        console.warn("THREE.TextGeometry: .height is now depreciated. Please use .depth instead");
      }
      parameters.depth = parameters.depth !== void 0 ? parameters.depth : parameters.height !== void 0 ? parameters.height : 50;
      if (parameters.bevelThickness === void 0)
        parameters.bevelThickness = 10;
      if (parameters.bevelSize === void 0)
        parameters.bevelSize = 8;
      if (parameters.bevelEnabled === void 0)
        parameters.bevelEnabled = false;
      super(shapes, parameters);
    }
    this.type = "TextGeometry";
  }
};

// node_modules/three/examples/jsm/loaders/FontLoader.js
var FontLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad2, onProgress, onError2) {
    const scope = this;
    const loader2 = new FileLoader(this.manager);
    loader2.setPath(this.path);
    loader2.setRequestHeader(this.requestHeader);
    loader2.setWithCredentials(this.withCredentials);
    loader2.load(url, function(text) {
      const font = scope.parse(JSON.parse(text));
      if (onLoad2)
        onLoad2(font);
    }, onProgress, onError2);
  }
  parse(json) {
    return new Font(json);
  }
};
var Font = class {
  constructor(data) {
    this.isFont = true;
    this.type = "Font";
    this.data = data;
  }
  generateShapes(text, size = 100) {
    const shapes = [];
    const paths = createPaths(text, size, this.data);
    for (let p = 0, pl = paths.length; p < pl; p++) {
      shapes.push(...paths[p].toShapes());
    }
    return shapes;
  }
};
function createPaths(text, size, data) {
  const chars = Array.from(text);
  const scale = size / data.resolution;
  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
  const paths = [];
  let offsetX = 0, offsetY = 0;
  for (let i = 0; i < chars.length; i++) {
    const char = chars[i];
    if (char === "\n") {
      offsetX = 0;
      offsetY -= line_height;
    } else {
      const ret = createPath(char, scale, offsetX, offsetY, data);
      offsetX += ret.offsetX;
      paths.push(ret.path);
    }
  }
  return paths;
}
function createPath(char, scale, offsetX, offsetY, data) {
  const glyph = data.glyphs[char] || data.glyphs["?"];
  if (!glyph) {
    console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + ".");
    return;
  }
  const path = new ShapePath();
  let x2, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
  if (glyph.o) {
    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
    for (let i = 0, l = outline.length; i < l; ) {
      const action = outline[i++];
      switch (action) {
        case "m":
          x2 = outline[i++] * scale + offsetX;
          y = outline[i++] * scale + offsetY;
          path.moveTo(x2, y);
          break;
        case "l":
          x2 = outline[i++] * scale + offsetX;
          y = outline[i++] * scale + offsetY;
          path.lineTo(x2, y);
          break;
        case "q":
          cpx = outline[i++] * scale + offsetX;
          cpy = outline[i++] * scale + offsetY;
          cpx1 = outline[i++] * scale + offsetX;
          cpy1 = outline[i++] * scale + offsetY;
          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
          break;
        case "b":
          cpx = outline[i++] * scale + offsetX;
          cpy = outline[i++] * scale + offsetY;
          cpx1 = outline[i++] * scale + offsetX;
          cpy1 = outline[i++] * scale + offsetY;
          cpx2 = outline[i++] * scale + offsetX;
          cpy2 = outline[i++] * scale + offsetY;
          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
          break;
      }
    }
  }
  return { offsetX: glyph.ha * scale, path };
}

// node_modules/@needle-tools/engine/lib/engine/engine_create_objects.js
var PrimitiveType;
(function(PrimitiveType2) {
  PrimitiveType2[PrimitiveType2["Quad"] = 0] = "Quad";
  PrimitiveType2[PrimitiveType2["Cube"] = 1] = "Cube";
  PrimitiveType2[PrimitiveType2["Sphere"] = 2] = "Sphere";
  PrimitiveType2[PrimitiveType2["RoundedCube"] = 10] = "RoundedCube";
})(PrimitiveType || (PrimitiveType = {}));
var _createTextGeometry, createTextGeometry_fn;
var ObjectUtils = class {
  /**
   * Creates a 3D text object
   * @param text The text to display
   * @param opts Options to create the object
   */
  static createText(text, opts) {
    let geometry = null;
    const font = (opts == null ? void 0 : opts.font) || loadFont((opts == null ? void 0 : opts.familyFamily) || null);
    if (font instanceof Font) {
      geometry = __privateMethod(this, _createTextGeometry, createTextGeometry_fn).call(this, text, font, opts);
    } else if (geometry == null) {
      geometry = new BufferGeometry();
    }
    const color2 = (opts == null ? void 0 : opts.color) || 16777215;
    const mesh = new Mesh(geometry, (opts == null ? void 0 : opts.material) ?? new MeshStandardMaterial({ color: color2 }));
    this.applyDefaultObjectOptions(mesh, opts);
    if (font instanceof Promise) {
      font.then((res) => {
        mesh.geometry = __privateMethod(this, _createTextGeometry, createTextGeometry_fn).call(this, text, res, opts);
        if (opts == null ? void 0 : opts.onGeometry)
          opts.onGeometry(mesh);
      });
    } else {
      if (opts == null ? void 0 : opts.onGeometry)
        opts.onGeometry(mesh);
    }
    return mesh;
  }
  /**
   * Creates an occluder object that only render depth but not color
   * @param type The type of primitive to create
   * @returns The created object
   */
  static createOccluder(type) {
    const occluderMaterial = new MeshBasicMaterial({ colorWrite: false, depthWrite: true, side: DoubleSide });
    return this.createPrimitive(type, { material: occluderMaterial });
  }
  static createPrimitive(type, opts) {
    let obj;
    const color2 = (opts == null ? void 0 : opts.color) || 16777215;
    switch (type) {
      case "Quad":
      case PrimitiveType.Quad:
        {
          const quadGeo = new PlaneGeometry(1, 1, 1, 1);
          const mat = (opts == null ? void 0 : opts.material) ?? new MeshStandardMaterial({ color: color2 });
          if ((opts == null ? void 0 : opts.texture) && "map" in mat)
            mat.map = opts.texture;
          obj = new Mesh(quadGeo, mat);
          obj.name = "Quad";
        }
        break;
      case "Cube":
      case PrimitiveType.Cube:
        {
          const boxGeo = new BoxGeometry(1, 1, 1);
          const mat = (opts == null ? void 0 : opts.material) ?? new MeshStandardMaterial({ color: color2 });
          if ((opts == null ? void 0 : opts.texture) && "map" in mat)
            mat.map = opts.texture;
          obj = new Mesh(boxGeo, mat);
          obj.name = "Cube";
        }
        break;
      case PrimitiveType.RoundedCube:
      case "RoundedCube":
        {
          const boxGeo = createBoxWithRoundedEdges(1, 1, 1, 0.1, 2);
          const mat = (opts == null ? void 0 : opts.material) ?? new MeshStandardMaterial({ color: color2 });
          if ((opts == null ? void 0 : opts.texture) && "map" in mat)
            mat.map = opts.texture;
          obj = new Mesh(boxGeo, mat);
          obj.name = "RoundedCube";
        }
        break;
      case "Sphere":
      case PrimitiveType.Sphere:
        {
          const sphereGeo = new SphereGeometry(0.5, 16, 16);
          const mat = (opts == null ? void 0 : opts.material) ?? new MeshStandardMaterial({ color: color2 });
          if ((opts == null ? void 0 : opts.texture) && "map" in mat)
            mat.map = opts.texture;
          obj = new Mesh(sphereGeo, mat);
          obj.name = "Sphere";
        }
        break;
      case "ShaderBall":
        {
          obj = new Group();
          obj.name = "ShaderBall";
          loadShaderball(obj, opts);
        }
        break;
    }
    this.applyDefaultObjectOptions(obj, opts);
    return obj;
  }
  /**
   * Creates a Sprite object
   * @param opts Options to create the object
   * @returns The created object
   */
  static createSprite(opts) {
    const color2 = 16777215;
    const mat = new SpriteMaterial({ color: color2 });
    if ((opts == null ? void 0 : opts.texture) && "map" in mat)
      mat.map = opts.texture;
    const sprite = new Sprite(mat);
    this.applyDefaultObjectOptions(sprite, opts);
    return sprite;
  }
  static applyDefaultObjectOptions(obj, opts) {
    obj.receiveShadow = true;
    obj.castShadow = true;
    if (opts == null ? void 0 : opts.name)
      obj.name = opts.name;
    if (opts == null ? void 0 : opts.position) {
      if (Array.isArray(opts.position))
        obj.position.set(opts.position[0], opts.position[1], opts.position[2]);
      else
        obj.position.set(opts.position.x, opts.position.y, opts.position.z);
    }
    if (opts == null ? void 0 : opts.rotation) {
      if (Array.isArray(opts.rotation))
        obj.rotation.set(opts.rotation[0], opts.rotation[1], opts.rotation[2]);
      else
        obj.rotation.set(opts.rotation.x, opts.rotation.y, opts.rotation.z);
    }
    if (opts == null ? void 0 : opts.scale) {
      if (typeof opts.scale === "number")
        obj.scale.set(opts.scale, opts.scale, opts.scale);
      else
        obj.scale.set(opts.scale.x, opts.scale.y, opts.scale.z);
    }
    if ((opts == null ? void 0 : opts.receiveShadow) != void 0) {
      obj.receiveShadow = opts.receiveShadow;
    }
    if ((opts == null ? void 0 : opts.castShadow) != void 0) {
      obj.castShadow = opts.castShadow;
    }
    if (opts == null ? void 0 : opts.parent) {
      opts.parent.add(obj);
    }
  }
};
_createTextGeometry = new WeakSet();
createTextGeometry_fn = function(text, font, opts) {
  const depth = (opts == null ? void 0 : opts.depth) || 0.1;
  const geo = new TextGeometry(text, {
    font,
    size: 1,
    depth,
    height: depth,
    bevelEnabled: (opts == null ? void 0 : opts.bevel) || false,
    bevelThickness: 0.01,
    bevelOffset: 0.01,
    bevelSize: 0.01
  });
  return geo;
};
__privateAdd(ObjectUtils, _createTextGeometry);
function createBoxWithRoundedEdges(width, height, _depth, radius0, smoothness) {
  const shape = new Shape();
  const eps = 1e-5;
  const radius = radius0 - eps;
  shape.absarc(eps, eps, eps, -Math.PI / 2, -Math.PI, true);
  shape.absarc(eps, height - radius * 2, eps, Math.PI, Math.PI / 2, true);
  shape.absarc(width - radius * 2, height - radius * 2, eps, Math.PI / 2, 0, true);
  shape.absarc(width - radius * 2, eps, eps, 0, -Math.PI / 2, true);
  const geometry = new ExtrudeGeometry(shape, {
    bevelEnabled: true,
    bevelSegments: smoothness * 2,
    steps: 1,
    bevelSize: radius,
    bevelThickness: radius0,
    curveSegments: smoothness
  });
  geometry.scale(1, 1, 1 - radius0);
  geometry.center();
  geometry.computeVertexNormals();
  return geometry;
}
var fontsDict = /* @__PURE__ */ new Map();
function loadFont(family) {
  let url = "";
  switch (family) {
    default:
    case "OpenSans":
      url = "https://cdn.needle.tools/static/fonts/facetype/Open Sans_Regular_ascii.json";
      break;
    case "Helvetiker":
      url = "https://raw.githubusercontent.com/mrdoob/three.js/master/examples/fonts/helvetiker_regular.typeface.json";
      break;
  }
  if (fontsDict.has(url)) {
    const res = fontsDict.get(url);
    if (res)
      return res;
  }
  const loader2 = new FontLoader();
  const promise = new Promise((resolve2, reject) => {
    loader2.load(url, (res) => {
      fontsDict.set(url, res);
      resolve2(res);
    }, void 0, reject);
  });
  fontsDict.set(url, promise);
  return promise;
}
var __shaderballIsLoading = false;
var __shaderballPromise = null;
function loadShaderball(group, opts) {
  if (__shaderballPromise === null) {
    const url = "https://cdn.needle.tools/static/models/shaderball.glb";
    const loader2 = new GLTFLoader();
    const loaders2 = createLoaders(null);
    loader2.setDRACOLoader(loaders2.dracoLoader);
    loader2.setKTX2Loader(loaders2.ktx2Loader);
    __shaderballIsLoading = true;
    __shaderballPromise = loader2.loadAsync(url).then((res) => {
      const scene = res.scene;
      scene.position.y -= 0.5;
      return scene;
    }).catch((err) => {
      console.warn("Failed to load shaderball mesh: " + err.message);
      return createShaderballPlaceholder();
    }).finally(() => {
      __shaderballIsLoading = false;
    });
  }
  if (__shaderballIsLoading) {
    const placeholder = createShaderballPlaceholder();
    placeholder.name = "ShaderBall-Placeholder";
    const mesh = placeholder.children[0];
    if ((mesh == null ? void 0 : mesh.type) === "Mesh")
      updateShaderballMaterial(mesh, opts);
    group.add(placeholder);
  }
  __shaderballPromise.then((res) => {
    group.children.forEach((c2) => {
      if (c2.name === "ShaderBall-Placeholder")
        group.remove(c2);
    });
    const instance = res.clone();
    const mesh = instance.children[0];
    if ((mesh == null ? void 0 : mesh.type) === "Mesh") {
      updateShaderballMaterial(mesh, opts);
    }
    group.add(instance);
  });
}
function updateShaderballMaterial(mesh, opts) {
  var _a2;
  const needCustomMaterial = (opts == null ? void 0 : opts.color) || (opts == null ? void 0 : opts.material) || (opts == null ? void 0 : opts.texture);
  if (needCustomMaterial) {
    const mat = (opts == null ? void 0 : opts.material) ?? ((_a2 = mesh.material) == null ? void 0 : _a2.clone()) ?? new MeshStandardMaterial();
    if (opts.color && "color" in mat && mat.color instanceof Color)
      mat.color.set(opts.color);
    if ((opts == null ? void 0 : opts.texture) && "map" in mat)
      mat.map = opts.texture;
    mesh.material = mat;
  }
}
function createShaderballPlaceholder() {
  return new Group().add(ObjectUtils.createPrimitive("Sphere", { material: new MeshBasicMaterial({ transparent: true, opacity: 0.1 }) }));
}

// node_modules/@needle-tools/engine/lib/engine/xr/TempXRContext.js
var _TemporaryXRContext = class {
  constructor(mode, init, session) {
    __publicField(this, "_session");
    __publicField(this, "_mode");
    __publicField(this, "_init");
    __publicField(this, "_renderer");
    __publicField(this, "_camera");
    __publicField(this, "_scene");
    __publicField(this, "onEnd", () => {
      var _a2;
      (_a2 = this._session) == null ? void 0 : _a2.removeEventListener("end", this.onEnd);
      this._renderer.setAnimationLoop(null);
      this._renderer.dispose();
      this._scene.clear();
    });
    __publicField(this, "_lastTime", 0);
    __publicField(this, "onFrame", (time, _frame2) => {
      const dt = time - this._lastTime;
      this.update(time, dt);
      if (this._camera.parent !== this._scene) {
        this._scene.add(this._camera);
      }
      this._renderer.render(this._scene, this._camera);
    });
    __publicField(this, "_objects", []);
    this._mode = mode;
    this._init = init;
    this._session = session;
    this._session.addEventListener("end", this.onEnd);
    this._renderer = new WebGLRenderer({ alpha: true });
    this._renderer.setAnimationLoop(this.onFrame);
    this._renderer.xr.setSession(session);
    this._renderer.xr.enabled = true;
    this._camera = new PerspectiveCamera();
    this._scene = new Scene();
    this._scene.fog = new Fog(4473924, 10, 250);
    this._scene.add(this._camera);
    this.setupScene();
  }
  static get active() {
    return this._active;
  }
  static async start(mode, init) {
    if (this._active) {
      console.error("Cannot start a new XR session while one is already active");
      return null;
    }
    if (this._requestInFlight) {
      console.error("Cannot start a new XR session while a request is already in flight");
      return null;
    }
    if ("xr" in navigator && navigator.xr) {
      if (!init) {
        console.error("XRSessionInit must be provided");
        return null;
      }
      this._requestInFlight = true;
      const session = await navigator.xr.requestSession(mode, init);
      session.addEventListener("end", () => {
        this._active = null;
      });
      if (!this._requestInFlight) {
        session.end();
        return null;
      }
      this._requestInFlight = false;
      this._active = new _TemporaryXRContext(mode, init, session);
      return this._active;
    }
    return null;
  }
  static async handoff() {
    if (this._active) {
      return this._active.handoff();
    }
    return null;
  }
  static async stop() {
    this._requestInFlight = false;
    if (this._active) {
      await this._active.end();
      await delay(100);
    }
    this._active = null;
  }
  get isAR() {
    return this._mode === "immersive-ar";
  }
  end() {
    if (!this._session)
      return Promise.resolve();
    return this._session.end();
  }
  /** returns the session and session info and stops the temporary rendering */
  async handoff() {
    if (!this._session)
      throw new Error("Cannot handoff a session that has already ended");
    const info = {
      session: this._session,
      mode: this._mode,
      init: this._init
    };
    await this.onBeforeHandoff();
    this.onEnd();
    this._session = null;
    return info;
  }
  /** can be used to prepare the user or fade to black */
  async onBeforeHandoff() {
    await delay(1e3);
    this._scene.clear();
  }
  setupScene() {
    this._scene.background = new Color(0);
    this._scene.add(new GridHelper(5, 10, 1118481, 1118481));
    const light = new DirectionalLight(16777215, 1);
    light.position.set(0, 20, 0);
    light.castShadow = false;
    this._scene.add(light);
    const light2 = new DirectionalLight(16777215, 1);
    light2.position.set(0, -1, 0);
    light2.castShadow = false;
    this._scene.add(light2);
    const light3 = new PointLight(16777215, 1, 100, 1);
    light3.position.set(0, 2, 0);
    light3.castShadow = false;
    light3.distance = 200;
    this._scene.add(light3);
    const range = 50;
    for (let i = 0; i < 100; i++) {
      const material = new MeshStandardMaterial({
        color: 2236962,
        metalness: 1,
        roughness: 0.8
      });
      if (this.isAR) {
        material.emissive = new Color(Math.random(), Math.random(), Math.random());
        material.emissiveIntensity = Math.random();
      }
      const type = Mathf.random(0, 1) > 0.5 ? PrimitiveType.Sphere : PrimitiveType.Cube;
      const obj = ObjectUtils.createPrimitive(type, {
        material
      });
      obj.position.x = Mathf.random(-range, range);
      obj.position.y = Mathf.random(-2, range);
      obj.position.z = Mathf.random(-range, range);
      obj.rotation.x = Mathf.random(0, Math.PI * 2);
      obj.rotation.y = Mathf.random(0, Math.PI * 2);
      obj.rotation.z = Mathf.random(0, Math.PI * 2);
      obj.scale.multiplyScalar(0.5 + Math.random() * 10);
      const dist = obj.position.distanceTo(this._camera.position) - obj.scale.x;
      if (dist < 1) {
        obj.position.multiplyScalar(1 + 1 / dist);
      }
      this._objects.push(obj);
      this._scene.add(obj);
    }
  }
  update(time, _deltaTime) {
    const speed = time * 4e-4;
    for (let i = 0; i < this._objects.length; i++) {
      const obj = this._objects[i];
      obj.position.y += Math.sin(speed + i * 0.5) * 5e-3;
      obj.rotateY(2e-3);
    }
  }
};
var TemporaryXRContext = _TemporaryXRContext;
__publicField(TemporaryXRContext, "_active", null);
__publicField(TemporaryXRContext, "_requestInFlight", false);

// node_modules/@needle-tools/engine/lib/engine/xr/usdz.js
var InternalUSDZRegistry;
(function(InternalUSDZRegistry2) {
  const usdzExporter = [];
  function exportAndOpen() {
    if (!(usdzExporter == null ? void 0 : usdzExporter.length))
      return false;
    for (const exp of usdzExporter) {
      exp.exportAndOpen();
    }
    return true;
  }
  InternalUSDZRegistry2.exportAndOpen = exportAndOpen;
  function registerExporter(exporter) {
    usdzExporter.push(exporter);
  }
  InternalUSDZRegistry2.registerExporter = registerExporter;
  function unregisterExporter(exporter) {
    if (!usdzExporter)
      return;
    const index = usdzExporter.indexOf(exporter);
    if (index >= 0) {
      usdzExporter.splice(index, 1);
    }
  }
  InternalUSDZRegistry2.unregisterExporter = unregisterExporter;
})(InternalUSDZRegistry || (InternalUSDZRegistry = {}));

// node_modules/@needle-tools/engine/lib/engine/xr/NeedleXRSession.js
var measure_SessionStartedMarker = "NeedleXRSession onStart";
var measure_SessionEndedMarker = "NeedleXRSession onEnd";
var debug9 = getParam("debugwebxr");
var debugFPS = getParam("stats");
var debugFPSFramesSinceLastUpdate = 0;
function getDOMOverlayElement(domElement) {
  let arOverlayElement = null;
  const element = domElement;
  if (element.getAROverlayContainer)
    arOverlayElement = element.getAROverlayContainer();
  else
    arOverlayElement = domElement;
  return arOverlayElement;
}
handleSessionGranted();
async function handleSessionGranted() {
  var _a2;
  if (getParam("debugasap")) {
    let asapSession = globalThis["needle:XRSession"];
    if (asapSession instanceof Promise) {
      delete globalThis["needle:XRSession"];
      ContextRegistry.addContextCreatedCallback(async (cb) => {
        if (!asapSession)
          return;
        enableSpatialConsole(true);
        const session = await asapSession;
        if (session) {
          const sessionInit = NeedleXRSession.getDefaultSessionInit("immersive-vr");
          NeedleXRSession.setSession("immersive-vr", session, sessionInit, cb.context);
        } else {
          console.error("NeedleXRSession: ASAP session was rejected");
        }
        asapSession = void 0;
      });
      return;
    }
  }
  if ("xr" in navigator) {
    if (/WebXRViewer\//i.test(navigator.userAgent)) {
      console.warn("WebXRViewer does not support addEventListener");
      return;
    }
    (_a2 = navigator.xr) == null ? void 0 : _a2.addEventListener("sessiongranted", async () => {
      enableSpatialConsole(true);
      console.log("Received Session Granted...");
      await delay(100);
      const lastSessionMode = sessionStorage.getItem("needle_xr_session_mode");
      const lastSessionInit = sessionStorage.getItem("needle_xr_session_init") ?? null;
      const init = lastSessionInit ? JSON.parse(lastSessionInit) : null;
      let info = null;
      if (contextIsLoading()) {
        await TemporaryXRContext.start(lastSessionMode || "immersive-vr", init || NeedleXRSession.getDefaultSessionInit("immersive-vr"));
        await waitForContextLoadingFinished();
        info = await TemporaryXRContext.handoff();
      }
      if (info) {
        NeedleXRSession.setSession(info.mode, info.session, info.init, Context.Current);
      } else if (lastSessionMode && lastSessionInit) {
        console.log("Session Granted: Restore last session");
        const init2 = JSON.parse(lastSessionInit);
        NeedleXRSession.start(lastSessionMode, init2).catch((e) => console.warn(e));
      } else {
        NeedleXRSession.start("immersive-vr").catch((e) => console.warn("Session Granted failed:", e));
      }
    }, { once: true });
  }
}
function saveSessionInfo(mode, init) {
  sessionStorage.setItem("needle_xr_session_mode", mode);
  sessionStorage.setItem("needle_xr_session_init", JSON.stringify(init));
}
function deleteSessionInfo() {
  sessionStorage.removeItem("needle_xr_session_mode");
  sessionStorage.removeItem("needle_xr_session_init");
}
var contexts_loading = /* @__PURE__ */ new Set();
ContextRegistry.registerCallback(ContextEvent.ContextCreationStart, async (cb) => {
  contexts_loading.add(cb.context);
});
ContextRegistry.registerCallback(ContextEvent.ContextCreated, async (cb) => {
  contexts_loading.delete(cb.context);
});
function contextIsLoading() {
  return contexts_loading.size > 0;
}
function waitForContextLoadingFinished() {
  return new Promise((res) => {
    const startTime = Date.now();
    const interval = setInterval(() => {
      if (!contextIsLoading() || Date.now() - startTime > 6e4) {
        clearInterval(interval);
        res();
      }
    }, 100);
  });
}
if (DeviceUtilities.isDesktop() && isDevEnvironment()) {
  window.addEventListener("keydown", (evt) => {
    if (evt.key === "x" || evt.key === "Escape") {
      if (NeedleXRSession.active) {
        NeedleXRSession.stop();
      }
    }
  });
}
var _NeedleXRSession = class {
  constructor(mode, session, context, extra) {
    /** The needle engine context this session was started from */
    __publicField(this, "context");
    /**
     * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSession
     */
    __publicField(this, "session");
    /** XR Session Mode: AR or VR */
    __publicField(this, "mode");
    /** The currently active/connected controllers */
    __publicField(this, "controllers", []);
    __publicField(this, "_rigScale", 1);
    __publicField(this, "_lastRigScaleUpdate", -1);
    __publicField(this, "_rigs", []);
    __publicField(this, "_viewerHitTestSource", null);
    /** this is the implictly created XR rig */
    __publicField(this, "_defaultRig");
    /** all scripts that receive some sort of XR update event */
    __publicField(this, "_xr_scripts");
    /** scripts that have onUpdateXR event methods */
    __publicField(this, "_xr_update_scripts", []);
    /** scripts that are in the scene but inactive (e.g. disabled parent gameObject) */
    __publicField(this, "_inactive_scripts", []);
    __publicField(this, "_controllerAdded");
    __publicField(this, "_controllerRemoved");
    __publicField(this, "_originalCameraWorldPosition");
    __publicField(this, "_originalCameraWorldRotation");
    __publicField(this, "_originalCameraWorldScale");
    __publicField(this, "_originalCameraParent");
    /** we store the main camera reference here each frame to make sure we have a rendering camera
     * this e.g. the case when the XR rig with the camera gets disabled (and thus this.context.mainCamera is unassigned)
     */
    __publicField(this, "_mainCamera", null);
    /** called when renderer.setSession is fulfilled */
    __publicField(this, "onRendererSessionSet", () => {
      var _a2;
      if (!this.running)
        return;
      this.context.renderer.xr.enabled = true;
      this.context.renderer.xr.updateCamera(this.context.mainCamera);
      (_a2 = this.context.mainCameraComponent) == null ? void 0 : _a2.applyClearFlags();
    });
    __publicField(this, "onInputSourceAdded", (newInputSource) => {
      if (newInputSource.targetRayMode === "screen") {
        return;
      }
      let index = 0;
      for (let i = 0; i < this.session.inputSources.length; i++) {
        if (this.session.inputSources[i] === newInputSource) {
          index = i;
          break;
        }
      }
      if (this.controllers.find((c2) => c2.inputSource === newInputSource)) {
        console.debug("Controller already exists for input source", index);
        return;
      } else if (this._newControllers.find((c2) => c2.inputSource === newInputSource)) {
        console.debug("Controller already registered for input source", index);
        return;
      }
      const newController = new NeedleXRController(this, newInputSource, index);
      this._newControllers.push(newController);
    });
    __publicField(this, "_ended", false);
    __publicField(this, "_newControllers", []);
    __publicField(this, "onEnd", (_evt) => {
      var _a2, _b, _c;
      if (this._ended)
        return;
      this._ended = true;
      console.debug("XR Session ended");
      deleteSessionInfo();
      this.onAfterRender();
      this.revertCustomForward();
      this._didStart = false;
      this._previousCameraParent = null;
      unregisterFrameEventCallback(this.onBefore, FrameEvent.LateUpdate);
      const index = this.context.pre_render_callbacks.indexOf(this.onBeforeRender);
      if (index >= 0)
        this.context.pre_render_callbacks.splice(index, 1);
      const index2 = this.context.post_render_callbacks.indexOf(this.onAfterRender);
      if (index2 >= 0)
        this.context.post_render_callbacks.splice(index2, 1);
      this.context.xr = null;
      this.context.renderer.xr.enabled = false;
      this.context.pre_update_oneshot_callbacks.push(() => {
        var _a3, _b2;
        (_a3 = this.context.mainCameraComponent) == null ? void 0 : _a3.applyClearFlags();
        (_b2 = this.context.mainCameraComponent) == null ? void 0 : _b2.applyClippingPlane();
      });
      invokeXRSessionEnd({ session: this });
      for (const listener of _NeedleXRSession._xrEndListeners) {
        listener({ xr: this });
      }
      const copy = [...this.controllers];
      for (let i = 0; i < copy.length; i++) {
        this.disconnectInputSource(copy[i].inputSource);
      }
      this._newControllers.length = 0;
      this.controllers.length = 0;
      for (const listener of this._xr_scripts) {
        (_a2 = listener == null ? void 0 : listener.onLeaveXR) == null ? void 0 : _a2.call(listener, { xr: this });
      }
      (_b = this.sync) == null ? void 0 : _b.onExitXR(this);
      if (this.context.mainCamera) {
        (_c = this._originalCameraParent) == null ? void 0 : _c.add(this.context.mainCamera);
        if (this._originalCameraWorldPosition) {
          setWorldPosition(this.context.mainCamera, this._originalCameraWorldPosition);
        }
        if (this._originalCameraWorldRotation) {
          setWorldQuaternion(this.context.mainCamera, this._originalCameraWorldRotation);
        }
        if (this._originalCameraWorldScale) {
          setWorldScale(this.context.mainCamera, this._originalCameraWorldScale);
        }
      }
      this.context.requestSizeUpdate();
      this._defaultRig.gameObject.removeFromParent();
      enableSpatialConsole(false);
      performance.mark(measure_SessionEndedMarker);
      performance.measure("NeedleXRSession", measure_SessionStartedMarker, measure_SessionEndedMarker);
    });
    __publicField(this, "_didStart", false);
    /** Called every frame by the engine */
    __publicField(this, "onBefore", (context) => {
      var _a2, _b, _c, _d, _e, _f, _g, _h;
      const frame = context.xrFrame;
      if (!frame)
        return;
      performance.mark("NeedleXRSession onBefore start");
      this.context.xr = this;
      if (this.context.mainCameraComponent && this.context.mainCameraComponent !== this._mainCamera) {
        this._mainCamera = this.context.mainCameraComponent;
      }
      if (((_a2 = this.rig) == null ? void 0 : _a2.isActive) == false) {
        if (debug9)
          console.warn("Latest rig is not active - trying to activate a different rig", this.rig);
        this.updateActiveXRRig();
      }
      if (this.rig && ((_b = this._mainCamera) == null ? void 0 : _b.gameObject)) {
        const currentParent = (_d = (_c = this._mainCamera) == null ? void 0 : _c.gameObject) == null ? void 0 : _d.parent;
        if (currentParent !== this.rig.gameObject) {
          this.rig.gameObject.add((_e = this._mainCamera) == null ? void 0 : _e.gameObject);
        }
      }
      this.internalUpdateState();
      this.applyCustomForward();
      const args = { xr: this };
      if (!this._didStart) {
        this._didStart = true;
        if (this.mode === "immersive-vr") {
          const bounds = getBoundingBox(this.context.scene.children);
          if (bounds) {
            const size = bounds.getSize(getTempVector());
            if (size.length() > 0) {
              const rigobject = this._defaultRig.gameObject;
              rigobject.position.set(bounds.min.x + size.x * 0.5, bounds.min.y, bounds.max.z + size.z * 0.5 + 1.5);
              const centerLook = bounds.getCenter(getTempVector());
              centerLook.y = rigobject.position.y;
              rigobject.lookAt(centerLook);
            }
          }
        }
        invokeXRSessionStart({ session: this });
        for (const listener of _NeedleXRSession._xrStartListeners) {
          listener(args);
        }
        const copy = [...this._xr_scripts];
        if (debug9)
          console.log("NeedleXRSession start, handle scripts:", copy);
        for (const script of copy) {
          if (script.destroyed) {
            this._script_to_remove.push(script);
            continue;
          }
          if (!script.activeAndEnabled) {
            this.markInactive(script);
            continue;
          }
          this.invokeCallback_EnterXR(script);
          for (const controller of this.controllers) {
            this.invokeCallback_ControllerAdded(script, controller);
          }
        }
      } else if (this.context.new_scripts_xr.length > 0) {
        const copy = [...this.context.new_scripts_xr];
        for (let i = 0; i < copy.length; i++) {
          const script = this.context.new_scripts_xr[i];
          if (!script || script.destroyed || ((_f = script.supportsXR) == null ? void 0 : _f.call(script, this.mode)) == false) {
            this.context.new_scripts_xr.splice(i, 1);
            continue;
          }
          if (!script.activeAndEnabled) {
            this.context.new_scripts_xr.splice(i, 1);
            this.markInactive(script);
            continue;
          }
          if (this.addScript(script)) {
            this.invokeCallback_EnterXR(script);
            for (const controller of this.controllers) {
              this.invokeCallback_ControllerAdded(script, controller);
            }
          }
        }
      }
      this.syncCameraCullingMask();
      for (const controller of this.controllers) {
        controller.onUpdate(frame);
      }
      if (this._newControllers.length > 0) {
        const copy = [...this._newControllers];
        this._newControllers.length = 0;
        for (const controller of copy) {
          if (!controller.connected) {
            console.warn("New controller is not connected", controller);
            continue;
          }
          this.controllers.push(controller);
          for (const script of this._xr_scripts) {
            if (script.destroyed) {
              this._script_to_remove.push(script);
              continue;
            }
            if (script.activeAndEnabled === false) {
              continue;
            }
            this.invokeCallback_ControllerAdded(script, controller);
          }
        }
        this.controllers.sort((a, b) => a.index - b.index);
      }
      if (debug9 && this.context.time.frame % 30 === 0 && this.controllers.length <= 0 && this.session.inputSources.length > 0) {
        enableSpatialConsole(true);
        console.error("XRControllers are not added but inputSources are present");
      }
      performance.mark("NeedleXRSession update scripts start");
      for (const script of this._xr_update_scripts) {
        if (script.destroyed === true) {
          this._script_to_remove.push(script);
          continue;
        }
        if (script.activeAndEnabled === false) {
          this.markInactive(script);
          continue;
        }
        if (script.onUpdateXR)
          script.onUpdateXR(args);
      }
      performance.mark("NeedleXRSession update scripts end");
      performance.measure("NeedleXRSession update scripts", "NeedleXRSession update scripts start", "NeedleXRSession update scripts end");
      this.handleInactiveScripts();
      if (this._script_to_remove.length > 0) {
        const unique = [...new Set(this._script_to_remove)];
        this._script_to_remove.length = 0;
        for (const script of unique) {
          if (!script.destroyed && this.running) {
            (_g = script.onLeaveXR) == null ? void 0 : _g.call(script, args);
          }
          this.removeScript(script);
        }
      }
      (_h = this.sync) == null ? void 0 : _h.onUpdate(this);
      this.onRenderDebug();
      performance.mark("NeedleXRSession onBefore end");
      performance.measure("NE XR frame", "NeedleXRSession onBefore start", "NeedleXRSession onBefore end");
    });
    __publicField(this, "onBeforeRender", () => {
      if (this.context.mainCamera)
        this.updateFade(this.context.mainCamera);
    });
    __publicField(this, "onAfterRender", () => {
      this.onUpdateFade_PostRender();
      if (DeviceUtilities.isDesktop() || !this["_renderOnceOnDevice"]) {
        const renderer = this.context.renderer;
        if (renderer.xr.isPresenting && this.context.mainCamera) {
          this["_renderOnceOnDevice"] = true;
          const wasXr = renderer.xr.enabled;
          const previousRenderTarget = renderer.getRenderTarget();
          const previousBackground = this.context.scene.background;
          renderer.xr.enabled = false;
          renderer.setRenderTarget(null);
          if (this.isPassThrough)
            this.context.scene.background = null;
          if (this.context.composer) {
            this.context.composer.render(this.context.time.deltaTime);
          } else {
            renderer.render(this.context.scene, this.context.mainCamera);
          }
          renderer.xr.enabled = wasXr;
          renderer.setRenderTarget(previousRenderTarget);
          this.context.scene.background = previousBackground;
        }
      }
    });
    __publicField(this, "_script_to_remove", []);
    __publicField(this, "_camera");
    __publicField(this, "_cameraRenderParent", new Object3D().rotateY(Math.PI));
    __publicField(this, "_previousCameraParent");
    __publicField(this, "_customforward", true);
    __publicField(this, "originalCameraNearPlane");
    __publicField(this, "_viewerPose");
    __publicField(this, "_transformOrientation", new Quaternion());
    __publicField(this, "_transformPosition", new Vector32());
    // TODO: for scene transitions (e.g. SceneSwitcher) where creating the scene might take a few moments we might want more control over when/how this fading occurs and how long the scene stays black
    __publicField(this, "_transition");
    var _a2, _b;
    performance.mark(measure_SessionStartedMarker);
    saveSessionInfo(mode, extra.init);
    this.session = session;
    this.mode = mode;
    this.context = context;
    if (debug9 || getParam("console"))
      enableSpatialConsole(true);
    this._xr_scripts = [...extra.scripts];
    this._xr_update_scripts = this._xr_scripts.filter((e) => typeof e.onUpdateXR === "function");
    this._controllerAdded = extra.controller_added;
    this._controllerRemoved = extra.controller_removed;
    registerFrameEventCallback(this.onBefore, FrameEvent.LateUpdate);
    this.context.pre_render_callbacks.push(this.onBeforeRender);
    this.context.post_render_callbacks.push(this.onAfterRender);
    if (((_a2 = extra.init.optionalFeatures) == null ? void 0 : _a2.includes("hit-test")) || ((_b = extra.init.requiredFeatures) == null ? void 0 : _b.includes("hit-test"))) {
      session.requestReferenceSpace("viewer").then((referenceSpace) => {
        var _a3, _b2;
        return (_b2 = (_a3 = session.requestHitTestSource) == null ? void 0 : _a3.call(session, { space: referenceSpace })) == null ? void 0 : _b2.then((source) => {
          return this._viewerHitTestSource = source;
        }).catch((e) => console.error(e));
      }).catch((e) => console.error(e));
    }
    if (this.context.mainCamera) {
      this._originalCameraWorldPosition = getWorldPosition(this.context.mainCamera, new Vector32());
      this._originalCameraWorldRotation = getWorldQuaternion(this.context.mainCamera, new Quaternion());
      this._originalCameraWorldScale = getWorldScale(this.context.mainCamera, new Vector32());
      this._originalCameraParent = this.context.mainCamera.parent;
    }
    this._defaultRig = new ImplictXRRig();
    this.context.scene.add(this._defaultRig.gameObject);
    this.addRig(this._defaultRig);
    for (let i = 0; i < session.inputSources.length; i++) {
      const inputSource = session.inputSources[i];
      if (!inputSource.handedness) {
        console.warn("Input source in xr session has no handedness - ignoring", i);
        continue;
      }
      this.onInputSourceAdded(inputSource);
    }
    this.session.addEventListener("end", this.onEnd);
    this.session.addEventListener(
      "inputsourceschange",
      /* @ts-ignore (ignore CI XRInputSourceChangeEvent mismatch) */
      (evt) => {
        for (const removedInputSource of evt.removed) {
          this.disconnectInputSource(removedInputSource);
        }
        for (const newInputSource of evt.added) {
          this.onInputSourceAdded(newInputSource);
        }
      }
    );
    this.context.xr = this;
    this.context.renderer.xr.setSession(this.session).then(this.onRendererSessionSet);
    if ("controllerAutoUpdate" in this.context.renderer.xr) {
      console.debug("Disabling three.js controllerAutoUpdate");
      this.context.renderer.xr.controllerAutoUpdate = false;
    } else if (debug9) {
      console.warn("controllerAutoUpdate is not available in three.js - cannot disable it");
    }
  }
  static getXRSync(context) {
    if (!this._sync)
      this._sync = new NeedleXRSync(context);
    return this._sync;
  }
  static get currentSessionRequest() {
    return this._currentSessionRequestMode;
  }
  /**
   * @returns the active @type {NeedleXRSession} (if any active) or null
   */
  static get active() {
    return this._activeSession;
  }
  /** The active xr session mode (if any xr session is active)
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSessionMode
  */
  static get activeMode() {
    var _a2;
    return ((_a2 = this._activeSession) == null ? void 0 : _a2.mode) ?? null;
  }
  /** XRSystem via navigator.xr access
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSystem
   */
  static get xrSystem() {
    return "xr" in navigator ? navigator.xr : void 0;
  }
  /**
   * @returns true if the browser supports WebXR (`immersive-vr` or `immersive-ar`)
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSystem/isSessionSupported
   */
  static isXRSupported() {
    return Promise.all([this.isVRSupported(), this.isARSupported()]).then((res) => res.some((e) => e)).catch(() => false);
  }
  /**
   * @returns true if the browser supports immersive-vr (WebXR)
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSystem/isSessionSupported
   */
  static isVRSupported() {
    return this.isSessionSupported("immersive-vr");
  }
  /**
   * @returns true if the browser supports immersive-ar (WebXR)
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSystem/isSessionSupported
  */
  static isARSupported() {
    return this.isSessionSupported("immersive-ar");
  }
  /**
   * @param mode The XRSessionMode to check if it is supported
   * @returns true if the browser supports the given XRSessionMode
   */
  static isSessionSupported(mode) {
    var _a2;
    return ((_a2 = this.xrSystem) == null ? void 0 : _a2.isSessionSupported(mode).catch((err) => {
      if (debug9)
        console.error(err);
      return false;
    })) ?? Promise.resolve(false);
  }
  /** Register to listen to XRSession start events. Unsubscribe with `offXRSessionStart` */
  static onSessionRequestStart(evt) {
    this._sessionRequestStartListeners.push(evt);
  }
  /** Unsubscribe from request start evt. Register with `onSessionRequestStart` */
  static offSessionRequestStart(evt) {
    const index = this._sessionRequestStartListeners.indexOf(evt);
    if (index >= 0)
      this._sessionRequestStartListeners.splice(index, 1);
  }
  /** Called after the session request has finished */
  static onSessionRequestEnd(evt) {
    this._sessionRequestEndListeners.push(evt);
  }
  /** Unsubscribe from request end evt */
  static offSessionRequestEnd(evt) {
    const index = this._sessionRequestEndListeners.indexOf(evt);
    if (index >= 0)
      this._sessionRequestEndListeners.splice(index, 1);
  }
  /** Listen to XR session started. Unsubscribe with `offXRSessionStart` */
  static onXRSessionStart(evt) {
    this._xrStartListeners.push(evt);
  }
  /** Unsubscribe from XRSession started events */
  static offXRSessionStart(evt) {
    const index = this._xrStartListeners.indexOf(evt);
    if (index >= 0)
      this._xrStartListeners.splice(index, 1);
  }
  /** Listen to XR session ended. Unsubscribe with `offXRSessionEnd` */
  static onXRSessionEnd(evt) {
    this._xrEndListeners.push(evt);
  }
  /** Unsubscribe from XRSession started events */
  static offXRSessionEnd(evt) {
    const index = this._xrEndListeners.indexOf(evt);
    if (index >= 0)
      this._xrEndListeners.splice(index, 1);
  }
  /** Listen to controller added events.
   * Events are cleared when starting a new session
   **/
  static onControllerAdded(evt) {
    this._controllerAddedListeners.push(evt);
  }
  /** Unsubscribe from controller added evts */
  static offControllerAdded(evt) {
    const index = this._controllerAddedListeners.indexOf(evt);
    if (index >= 0)
      this._controllerAddedListeners.splice(index, 1);
  }
  /** Listen to controller removed events
   * Events are cleared when starting a new session
   **/
  static onControllerRemoved(evt) {
    this._controllerRemovedListeners.push(evt);
  }
  /** Unsubscribe from controller removed events */
  static offControllerRemoved(evt) {
    const index = this._controllerRemovedListeners.indexOf(evt);
    if (index >= 0)
      this._controllerRemovedListeners.splice(index, 1);
  }
  /** If the browser supports offerSession - creating a VR or AR button in the browser navigation bar */
  static offerSession(mode, init, context) {
    if ("xr" in navigator && navigator.xr && "offerSession" in navigator.xr) {
      if (typeof navigator.xr.offerSession === "function") {
        console.log("WebXR offerSession is available - requesting mode: " + mode);
        if (init == "default") {
          init = this.getDefaultSessionInit(mode);
        }
        navigator.xr.offerSession(mode, {
          ...init
        }).then((session) => {
          return _NeedleXRSession.setSession(mode, session, init, context);
        }).catch((_) => {
          console.log("XRSession offer rejected (perhaps because another call to offerSession was made or a call to requestSession was made)");
        });
      }
      return true;
    }
    return false;
  }
  /** @returns a new XRSession init object with defaults */
  static getDefaultSessionInit(mode) {
    switch (mode) {
      case "immersive-ar":
        return {
          optionalFeatures: ["anchors", "local-floor", "hand-tracking", "layers", "dom-overlay", "hit-test", "unbounded"]
        };
      case "immersive-vr":
        return {
          optionalFeatures: ["local-floor", "bounded-floor", "hand-tracking", "high-fixed-foveation-level", "layers"]
        };
      default:
        console.warn("No default session init for mode", mode);
        return {};
    }
  }
  /** start a new webXR session (make sure to stop already running sessions before calling this method)
   * @param mode The XRSessionMode to start (e.g. `immersive-vr` or `immersive-ar`) or `ar` to start `immersive-ar` on supported devices OR on iOS devices it will export an interactive USDZ and open in Quicklook.
   * Get more information about WebXR modes: https://developer.mozilla.org/en-US/docs/Web/API/XRSessionMode
   * @param init The XRSessionInit to use (optional), docs: https://developer.mozilla.org/en-US/docs/Web/API/XRSessionInit
   * @param context The Needle Engine context to use
   */
  static async start(mode, init, context) {
    var _a2, _b, _c, _d;
    if (DeviceUtilities.isiOS()) {
      if (mode === "ar") {
        const arSupported = await this.isARSupported();
        if (!arSupported) {
          InternalUSDZRegistry.exportAndOpen();
          return null;
        } else {
          mode = "immersive-ar";
        }
      }
    } else if (mode == "ar") {
      mode = "immersive-ar";
    }
    if (isDevEnvironment() && getParam("debugxrpreroom")) {
      console.warn("Debug: Starting temporary XR session");
      await TemporaryXRContext.start(mode, init || _NeedleXRSession.getDefaultSessionInit(mode));
      return null;
    }
    if (this._currentSessionRequest) {
      console.warn("A XRSession is already being requested");
      if (debug9 || isDevEnvironment())
        showBalloonWarning("A XRSession is already being requested");
      return this._currentSessionRequest.then(() => this._activeSession);
    }
    if (this._activeSession) {
      console.error("A XRSession is already running");
      return this._activeSession;
    }
    if (!context)
      context = Context.Current;
    if (!context)
      context = ContextRegistry.All[0];
    if (!context)
      throw new Error("No Needle Engine Context found");
    performance.mark("NeedleXRSession start");
    if (!init)
      init = {};
    switch (mode) {
      case "immersive-ar":
        {
          const supported = await ((_a2 = this.xrSystem) == null ? void 0 : _a2.isSessionSupported("immersive-ar"));
          if (supported !== true) {
            console.error(mode + " is not supported by this browser.");
            return null;
          }
          const defaultInit = this.getDefaultSessionInit(mode);
          const domOverlayElement = getDOMOverlayElement(context.domElement);
          if (domOverlayElement && !DeviceUtilities.isQuest()) {
            defaultInit.domOverlay = { root: domOverlayElement };
            defaultInit.optionalFeatures.push("dom-overlay");
          }
          init = {
            ...defaultInit,
            ...init
          };
        }
        break;
      case "immersive-vr":
        {
          const supported = await ((_b = this.xrSystem) == null ? void 0 : _b.isSessionSupported("immersive-vr"));
          if (supported !== true) {
            console.error(mode + " is not supported by this browser.");
            return null;
          }
          const defaultInit = this.getDefaultSessionInit(mode);
          init = {
            ...defaultInit,
            ...init
          };
        }
        break;
      default:
        console.warn("No default session init for mode", mode);
        break;
    }
    init.optionalFeatures ?? (init.optionalFeatures = []);
    init.requiredFeatures ?? (init.requiredFeatures = []);
    await TemporaryXRContext.stop();
    const scripts = mode == "immersive-ar" ? context.scripts_immersive_ar : context.scripts_immersive_vr;
    if (debug9)
      console.log(`%cRequesting ${mode} session`, "font-weight:bold;", init, scripts);
    else
      console.log(`%cRequesting ${mode} session`, "font-weight:bold;");
    for (const script of scripts) {
      if (script.onBeforeXR)
        script.onBeforeXR(mode, init);
    }
    for (const listener of this._sessionRequestStartListeners) {
      listener({ mode, init });
    }
    if (debug9)
      showBalloonMessage("Requesting " + mode + " session (" + Date.now() + ")");
    this._currentSessionRequest = (_c = navigator.xr) == null ? void 0 : _c.requestSession(mode, init);
    this._currentSessionRequestMode = mode;
    const newSession = await ((_d = this._currentSessionRequest) == null ? void 0 : _d.catch((e) => {
      console.error(e, "Code: " + e.code);
      if (e.code === 9)
        showBalloonWarning("Make sure your device has the required permissions (e.g. camera access)");
      console.log("If the specified XR configuration is not supported (e.g. entering AR doesnt work) - make sure you access the website on a secure connection (HTTPS) and your device has the required permissions (e.g. camera access)");
      const notSecure = location.protocol === "http:";
      if (notSecure)
        showBalloonWarning("XR requires a secure connection (HTTPS)");
    }));
    this._currentSessionRequest = void 0;
    this._currentSessionRequestMode = null;
    for (const listener of this._sessionRequestEndListeners) {
      listener({ mode, init, newSession: newSession || null });
    }
    if (!newSession) {
      console.warn("XR Session request was rejected");
      return null;
    }
    const session = this.setSession(mode, newSession, init, context);
    performance.mark("NeedleXRSession end");
    performance.measure("NeedleXRSession Startup", "NeedleXRSession start", "NeedleXRSession end");
    return session;
  }
  static setSession(mode, session, init, context) {
    if (this._activeSession) {
      console.error("A XRSession is already running");
      return this._activeSession;
    }
    const scripts = mode == "immersive-ar" ? context.scripts_immersive_ar : context.scripts_immersive_vr;
    this._activeSession = new _NeedleXRSession(mode, session, context, {
      scripts,
      controller_added: this._controllerAddedListeners,
      controller_removed: this._controllerRemovedListeners,
      init
    });
    session.addEventListener("end", this.onEnd);
    if (debug9)
      console.log(`%cStarted ${mode} session`, "font-weight:bold;", scripts);
    else
      console.log(`%cStarted ${mode} session`, "font-weight:bold;");
    return this._activeSession;
  }
  /** stops the active XR session */
  static stop() {
    var _a2;
    (_a2 = this._activeSession) == null ? void 0 : _a2.end();
  }
  get sync() {
    return _NeedleXRSession._sync;
  }
  /** Returns true if the xr session is still active */
  get running() {
    return !this._ended && this.session != null;
  }
  /**
   * The XRSession interface's read-only interactionMode property describes the best space (according to the user agent) for the application to draw an interactive UI for the current session.
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSession/interactionMode
   */
  get interactionMode() {
    return this.session["interactionMode"];
  }
  /**
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSession/visibilityState
   * @returns {XRVisibilityState} The visibility state of the XRSession
   */
  get visibilityState() {
    return this.session.visibilityState;
  }
  /**
   * Check if the session is `visible-blurred` - this means e.g. the keyboard is shown
   */
  get isVisibleBlurred() {
    return this.session.visibilityState === "visible-blurred";
  }
  /**
   * Check if the session has system keyboard support
   */
  get isSystemKeyboardSupported() {
    return this.session.isSystemKeyboardSupported;
  }
  /**
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSession/environmentBlendMode
   */
  get environmentBlendMode() {
    return this.session.environmentBlendMode;
  }
  /**
   * The current XR frame
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRFrame
   */
  get frame() {
    return this.context.xrFrame;
  }
  /** shorthand to query the left controller. Use `controllers` to get access to all connected controllers */
  get leftController() {
    return this.controllers.find((c2) => c2.side === "left");
  }
  /** shorthand to query the right controller. Use `controllers` to get access to all connected controllers */
  get rightController() {
    return this.controllers.find((c2) => c2.side === "right");
  }
  /** @returns the given controller if it is connected */
  getController(side) {
    if (typeof side === "number")
      return this.controllers[side] || null;
    return this.controllers.find((c2) => c2.side === side) || null;
  }
  /** Returns true if running in pass through mode in immersive AR (e.g. user is wearing a headset while in AR) */
  get isPassThrough() {
    if (this.environmentBlendMode !== "opaque" && this.interactionMode === "world-space")
      return true;
    if (this.mode === "immersive-ar" && this.environmentBlendMode !== "opaque") {
      if (this.controllers.some((c2) => c2.inputSource.targetRayMode === "tracked-pointer"))
        return true;
    }
    if (isDevEnvironment() && DeviceUtilities.isDesktop() && this.mode === "immersive-ar") {
      return true;
    }
    return false;
  }
  get isAR() {
    return this.mode === "immersive-ar";
  }
  get isVR() {
    return this.mode === "immersive-vr";
  }
  /** If the AR mode is not immersive (meaning the user is e.g. holding a phone instead of wearing a AR passthrough headset) */
  get isScreenBasedAR() {
    return this.isAR && !this.isPassThrough;
  }
  get posePosition() {
    return this._transformPosition;
  }
  get poseOrientation() {
    return this._transformOrientation;
  }
  /** @returns the context.renderer.xr.getReferenceSpace() result */
  get referenceSpace() {
    return this.context.renderer.xr.getReferenceSpace();
  }
  /** @returns the XRFrame `viewerpose` using the xr `referenceSpace` */
  get viewerPose() {
    return this._viewerPose;
  }
  /** @returns `true` if any image is currently being tracked */
  /** returns true if images are currently being tracked */
  get isTrackingImages() {
    if (this.frame && "getImageTrackingResults" in this.frame && typeof this.frame.getImageTrackingResults === "function") {
      try {
        const trackingResult = this.frame.getImageTrackingResults();
        for (const result of trackingResult) {
          const state = result.trackingState;
          if (state === "tracked")
            return true;
        }
      } catch {
        return false;
      }
    }
    return false;
  }
  /** The currently active XR rig */
  get rig() {
    const rig = this._rigs[0] ?? null;
    if ((rig == null ? void 0 : rig.gameObject) && isDestroyed(rig.gameObject) || (rig == null ? void 0 : rig.isActive) === false) {
      this.updateActiveXRRig();
      return this._rigs[0] ?? null;
    }
    return rig;
  }
  /** get the XR rig worldscale */
  get rigScale() {
    if (!this._rigs[0])
      return 1;
    if (this._lastRigScaleUpdate !== this.context.time.frame) {
      this._lastRigScaleUpdate = this.context.time.frame;
      this._rigScale = this._rigs[0].gameObject.worldScale.x;
    }
    return this._rigScale;
  }
  /** add a rig to the available XR rigs - if it's priority is higher than the currently active rig it will be enabled */
  addRig(rig) {
    const i = this._rigs.indexOf(rig);
    if (i >= 0)
      return;
    if (rig.priority === void 0)
      rig.priority = 0;
    this._rigs.push(rig);
    this.updateActiveXRRig();
  }
  /** Remove a rig from the available XR Rigs */
  removeRig(rig) {
    const i = this._rigs.indexOf(rig);
    if (i === -1)
      return;
    this._rigs.splice(i, 1);
    this.updateActiveXRRig();
  }
  /** Sets a XRRig to be active which will parent the camera to this rig */
  setRigActive(rig) {
    const i = this._rigs.indexOf(rig);
    this._rigs.splice(i, 1);
    this._rigs.unshift(rig);
    this.updateActiveXRRig();
  }
  /**
   * @returns the user position in the rig space
   */
  getUserOffsetInRig() {
    var _a2;
    const positionInRig = (_a2 = this.context.mainCamera) == null ? void 0 : _a2.position;
    if (!positionInRig || !this.rig)
      return getTempVector(0, 0, 0);
    const vec2 = getTempVector(positionInRig);
    vec2.x *= -1;
    vec2.z *= -1;
    vec2.applyQuaternion(getTempQuaternion(this.rig.gameObject.quaternion));
    return vec2;
  }
  updateActiveXRRig() {
    const previouslyActiveRig = this._rigs[0] ?? null;
    if (this._defaultRig.gameObject.parent !== this.context.scene)
      this.context.scene.add(this._defaultRig.gameObject);
    this._defaultRig.gameObject.visible = true;
    if (!this._rigs.includes(this._defaultRig))
      this._rigs.push(this._defaultRig);
    let highestPriorityRig = this._rigs[0];
    if (highestPriorityRig && highestPriorityRig.priority === void 0)
      highestPriorityRig.priority = 0;
    for (let i = 1; i < this._rigs.length; i++) {
      const rig = this._rigs[i];
      if (!rig.isActive)
        continue;
      if (isDestroyed(rig.gameObject)) {
        this._rigs.splice(i, 1);
        i--;
        continue;
      }
      if (!highestPriorityRig || highestPriorityRig.isActive === false || rig.priority !== void 0 && rig.priority > highestPriorityRig.priority) {
        highestPriorityRig = rig;
      }
    }
    if (previouslyActiveRig !== highestPriorityRig) {
      const index = this._rigs.indexOf(highestPriorityRig);
      if (index >= 0)
        this._rigs.splice(index, 1);
      this._rigs.unshift(highestPriorityRig);
    }
    if (debug9) {
      if (previouslyActiveRig === highestPriorityRig)
        console.log("Updated Active XR Rig:", highestPriorityRig, "prev:", previouslyActiveRig);
      else
        console.log("Updated Active XRRig:", highestPriorityRig, " (the same as before)");
    }
  }
  /** Returns a XR hit test result (if hit-testing is available) in rig space
   * @param source If provided, the hit test will be performed for the given controller
  */
  getHitTest(source) {
    if (source) {
      return this.getControllerHitTest(source);
    }
    if (!this._viewerHitTestSource)
      return null;
    const hitTestSource = this._viewerHitTestSource;
    const hitTestResults = this.frame.getHitTestResults(hitTestSource);
    if (hitTestResults.length > 0) {
      const hit = hitTestResults[0];
      return this.convertHitTestResult(hit);
    }
    return null;
  }
  getControllerHitTest(controller) {
    const hitTestSource = controller.getHitTestSource();
    if (!hitTestSource)
      return null;
    const res = this.frame.getHitTestResultsForTransientInput(hitTestSource);
    for (const result of res) {
      if (result.inputSource === controller.inputSource) {
        for (const hit of result.results) {
          return this.convertHitTestResult(hit);
        }
      }
    }
    return null;
  }
  convertHitTestResult(result) {
    const referenceSpace = this.context.renderer.xr.getReferenceSpace();
    const pose = referenceSpace && result.getPose(referenceSpace);
    if (pose) {
      const pos = getTempVector(pose.transform.position);
      const rot = getTempQuaternion(pose.transform.orientation);
      const camera = this.context.mainCamera;
      if ((camera == null ? void 0 : camera.parent) !== this._cameraRenderParent) {
        pos.applyMatrix4(flipForwardMatrix);
      }
      if (camera == null ? void 0 : camera.parent) {
        pos.applyMatrix4(camera.parent.matrixWorld);
        rot.multiply(flipForwardQuaternion);
        const parentRotation = getWorldQuaternion(camera.parent);
        parentRotation.premultiply(flipForwardQuaternion);
        rot.premultiply(parentRotation);
      }
      return { hit: result, position: pos, quaternion: rot };
    }
    return null;
  }
  /** convert a XRRigidTransform from XR session space to threejs / Needle Engine XR space */
  convertSpace(transform) {
    const pos = getTempVector(transform.position);
    pos.applyMatrix4(flipForwardMatrix);
    const rot = getTempQuaternion(transform.orientation);
    rot.premultiply(flipForwardQuaternion);
    return { position: pos, quaternion: rot };
  }
  /** Disconnects the controller, invokes events and notifies previou controller (if any) */
  disconnectInputSource(inputSource) {
    const handleRemove = (oldController, _array, i) => {
      if (oldController.inputSource === inputSource) {
        if (debug9)
          console.log("Disconnecting controller", oldController.index);
        this.controllers.splice(i, 1);
        this.invokeControllerEvent(oldController, this._controllerRemoved, "removed");
        const args = {
          xr: this,
          controller: oldController,
          change: "removed"
        };
        for (const script of this._xr_scripts) {
          if (script.onXRControllerRemoved)
            script.onXRControllerRemoved(args);
        }
        oldController.onDisconnected();
      }
    };
    for (let i = this.controllers.length - 1; i >= 0; i--) {
      const oldController = this.controllers[i];
      handleRemove(oldController, this.controllers, i);
    }
    for (let i = this._newControllers.length - 1; i >= 0; i--) {
      const oldController = this._newControllers[i];
      handleRemove(oldController, this._newControllers, i);
    }
  }
  /** End the XR Session */
  end() {
    if (this._ended)
      return;
    this.session.end().catch((e) => console.warn(e));
  }
  onRenderDebug() {
    if (debug9) {
      for (const controller of this.controllers) {
        controller.onRenderDebug();
      }
    }
    if ((debug9 || debugFPS) && this.rig) {
      debugFPSFramesSinceLastUpdate++;
      if (debugFPSFramesSinceLastUpdate >= 20) {
        const pos = this.rig.gameObject.worldPosition;
        const forward2 = this.rig.gameObject.worldForward;
        pos.add(forward2.multiplyScalar(1.5));
        const upwards = this.rig.gameObject.worldUp;
        pos.add(upwards.multiplyScalar(2.5));
        let debugLabel = "";
        debugLabel += `${this.context.time.smoothedFps.toFixed(0)} FPS`;
        debugLabel += `, calls: ${this.context.renderer.info.render.calls}, tris: ${this.context.renderer.info.render.triangles.toLocaleString()}`;
        if (debug9 || debugFPS) {
          for (const ctrl of this.controllers) {
            debugLabel += `
${ctrl.hand ? "hand" : "ctrl"} ${ctrl.inputSource.handedness}[${ctrl.index}] con:${ctrl.connected} tr:${ctrl.isTracking} hts:${ctrl.hasHitTestSource ? "yes" : "no"}`;
          }
        }
        debugFPSFramesSinceLastUpdate = 0;
        Gizmos.DrawLabel(pos, debugLabel, void 0, 1 / 60 * 20);
      }
    }
  }
  /** register a new XR script if it hasnt added yet */
  addScript(script) {
    if (this._xr_scripts.includes(script))
      return false;
    if (debug9)
      console.log("Register new XRScript", script);
    this._xr_scripts.push(script);
    if (typeof script.onUpdateXR === "function") {
      this._xr_update_scripts.push(script);
    }
    return true;
  }
  /** mark a script as inactive and invokes callbacks */
  markInactive(script) {
    if (this._inactive_scripts.indexOf(script) >= 0)
      return;
    this.removeScript(script, false);
    this._inactive_scripts.push(script);
    for (const ctrl of this.controllers)
      this.invokeCallback_ControllerRemoved(script, ctrl);
    this.invokeCallback_LeaveXR(script);
  }
  handleInactiveScripts() {
    if (this._inactive_scripts.length > 0) {
      for (let i = this._inactive_scripts.length - 1; i >= 0; i--) {
        const script = this._inactive_scripts[i];
        if (script.activeAndEnabled) {
          this._inactive_scripts.splice(i, 1);
          this.addScript(script);
          this.invokeCallback_EnterXR(script);
          for (const ctrl of this.controllers)
            this.invokeCallback_ControllerAdded(script, ctrl);
        }
      }
    }
  }
  removeScript(script, removeCompletely = true) {
    if (debug9)
      console.log("Remove XRScript", script);
    const index = this._xr_scripts.indexOf(script);
    if (index >= 0)
      this._xr_scripts.splice(index, 1);
    const index2 = this._xr_update_scripts.indexOf(script);
    if (index2 >= 0)
      this._xr_update_scripts.splice(index2, 1);
    if (removeCompletely) {
      const index3 = this._inactive_scripts.indexOf(script);
      if (index3 >= 0)
        this._inactive_scripts.splice(index3, 1);
    }
  }
  invokeCallback_EnterXR(script) {
    if (script.onEnterXR) {
      script.onEnterXR({ xr: this });
    }
  }
  invokeCallback_ControllerAdded(script, controller) {
    if (script.onXRControllerAdded) {
      script.onXRControllerAdded({ xr: this, controller, change: "added" });
    }
  }
  invokeCallback_ControllerRemoved(script, controller) {
    if (script.onXRControllerRemoved) {
      script.onXRControllerRemoved({ xr: this, controller, change: "removed" });
    }
  }
  invokeCallback_LeaveXR(script) {
    if (script.onLeaveXR && !script.destroyed) {
      script.onLeaveXR({ xr: this });
    }
  }
  syncCameraCullingMask() {
    var _a2;
    const cam = this.context.xrCamera;
    const cull = (_a2 = this.context.mainCameraComponent) == null ? void 0 : _a2.cullingMask;
    if (cam && cull !== void 0) {
      for (const c2 of cam.cameras) {
        c2.layers.mask = cull;
      }
      cam.layers.mask = cull;
    } else if (cam) {
      for (const c2 of cam.cameras) {
        c2.layers.enableAll();
      }
      cam.layers.enableAll();
    }
  }
  invokeControllerEvent(controller, listeners, change) {
    for (let i = listeners.length - 1; i >= 0; i--) {
      const listener = listeners[i];
      if (!listener)
        continue;
      try {
        listener({
          xr: this,
          controller,
          change
        });
      } catch (e) {
        console.error(e);
      }
    }
  }
  /** This is used to have the XR system camera look into threejs Z forward direction (instead of -z) */
  applyCustomForward() {
    var _a2;
    if (this.context.mainCamera && this._customforward) {
      this._camera = this.context.mainCamera;
      if (this._camera.parent !== this._cameraRenderParent) {
        this._previousCameraParent = this._camera.parent;
        (_a2 = this._previousCameraParent) == null ? void 0 : _a2.add(this._cameraRenderParent);
      }
      this._cameraRenderParent.name = "XR Camera Render Parent";
      this._cameraRenderParent.add(this._camera);
      let minNearPlane = 0.02;
      if (this.rig) {
        const rigWorldScale = getWorldScale(this.rig.gameObject);
        minNearPlane *= rigWorldScale.x;
      }
      if (this._camera instanceof PerspectiveCamera && this._camera.near > minNearPlane) {
        this.originalCameraNearPlane = this._camera.near;
        this._camera.near = minNearPlane;
      }
    }
  }
  revertCustomForward() {
    if (this._camera && this._previousCameraParent) {
      this._previousCameraParent.add(this._camera);
    }
    this._previousCameraParent = null;
    if (this._camera instanceof PerspectiveCamera && this.originalCameraNearPlane != void 0) {
      this._camera.near = this.originalCameraNearPlane;
    }
  }
  internalUpdateState() {
    const referenceSpace = this.context.renderer.xr.getReferenceSpace();
    if (!referenceSpace) {
      this._viewerPose = void 0;
      return;
    }
    this._viewerPose = this.frame.getViewerPose(referenceSpace);
    if (this._viewerPose) {
      const transform = this._viewerPose.transform;
      this._transformPosition.set(transform.position.x, transform.position.y, transform.position.z);
      this._transformOrientation.set(transform.orientation.x, transform.orientation.y, transform.orientation.z, transform.orientation.w);
    }
  }
  get transition() {
    if (!this._transition)
      this._transition = new SceneTransition();
    return this._transition;
  }
  /** Call to fade rendering to black for a short moment (the returned promise will be resolved when fully black)
   * This can be used to mask scene transitions or teleportation
   * @returns a promise that is resolved when the screen is fully black
   * @example `fadeTransition().then(() => { <fully_black> })`
  */
  fadeTransition() {
    if (!this._transition)
      this._transition = new SceneTransition();
    return this._transition.fadeTransition();
  }
  /** e.g. FadeToBlack */
  updateFade(camera) {
    if (this._transition && camera instanceof PerspectiveCamera)
      this._transition.update(camera, this.context.time.deltaTime);
  }
  onUpdateFade_PostRender() {
    var _a2;
    (_a2 = this._transition) == null ? void 0 : _a2.remove();
  }
};
var NeedleXRSession = _NeedleXRSession;
__publicField(NeedleXRSession, "_sync", null);
__publicField(NeedleXRSession, "_currentSessionRequestMode", null);
__publicField(NeedleXRSession, "_currentSessionRequest");
__publicField(NeedleXRSession, "_activeSession");
__publicField(NeedleXRSession, "_sessionRequestStartListeners", []);
__publicField(NeedleXRSession, "_sessionRequestEndListeners", []);
__publicField(NeedleXRSession, "_xrStartListeners", []);
__publicField(NeedleXRSession, "_xrEndListeners", []);
__publicField(NeedleXRSession, "_controllerAddedListeners", []);
__publicField(NeedleXRSession, "_controllerRemovedListeners", []);
__publicField(NeedleXRSession, "onEnd", () => {
  if (debug9)
    console.log("XR Session ended");
  _NeedleXRSession._activeSession = null;
});

// node_modules/@needle-tools/engine/lib/engine/xr/utils.js
var debug10 = getParam("debugwebxr");
var NeedleXRUtils = class {
  /** Searches the hierarchy for objects following a specific naming scheme */
  static tryFindAvatarObjects(obj, sourceId, result) {
    if (result.head && result.leftHand && result.rightHand)
      return;
    const name = obj.name.toLocaleLowerCase();
    if (!result.head && name.includes("head")) {
      if (debug10)
        console.log("FOUND AVATAR HEAD", obj.name);
      result.head = new AssetReference("", sourceId, obj);
    }
    if (name.includes("hand")) {
      if (!result.leftHand && name.includes("left")) {
        if (debug10)
          console.log("FOUND AVATAR LEFT HAND", obj.name);
        result.leftHand = new AssetReference("", sourceId, obj);
      }
      if (!result.rightHand && name.includes("right")) {
        if (debug10)
          console.log("FOUND AVATAR RIGHT HAND", obj.name);
        result.rightHand = new AssetReference("", sourceId, obj);
      }
    }
    for (let i = 0; i < obj.children.length; i++) {
      if (result.head && result.leftHand && result.rightHand)
        return;
      const child = obj.children[i];
      this.tryFindAvatarObjects(child, sourceId, result);
    }
  }
};

// node_modules/@needle-tools/engine/lib/engine/engine_gizmos.js
var _tmp = new Vector32();
var _tmp2 = new Vector32();
var _quat = new Quaternion();
var debug11 = getParam("debuggizmos");
var defaultColor = 8947848;
var circleSegments = 32;
var _Gizmos = class {
  constructor() {
  }
  /**
   * Returns true if a given object is a gizmo
   */
  static isGizmo(obj) {
    return obj[$cacheSymbol] !== void 0;
  }
  /**
   * Draw a label in the scene or attached to an object (if a parent is provided)
   * @returns a handle to the label that can be used to change the text
   */
  static DrawLabel(position, text, size = 0.05, duration = 0, color2, backgroundColor, parent) {
    var _a2;
    if (!_Gizmos.enabled)
      return null;
    if (!color2)
      color2 = defaultColor;
    const rigScale = ((_a2 = NeedleXRSession.active) == null ? void 0 : _a2.rigScale) ?? 1;
    const element = Internal.getTextLabel(duration, text, size * rigScale, color2, backgroundColor);
    if (parent instanceof Object3D)
      parent.add(element);
    element.position.x = position.x;
    element.position.y = position.y;
    element.position.z = position.z;
    return element;
  }
  static DrawRay(origin, dir, color2 = defaultColor, duration = 0, depthTest = true) {
    if (!_Gizmos.enabled)
      return;
    const obj = Internal.getLine(duration);
    const positions = obj.geometry.getAttribute("position");
    positions.setXYZ(0, origin.x, origin.y, origin.z);
    _tmp.set(dir.x, dir.y, dir.z).multiplyScalar(999999999);
    positions.setXYZ(1, origin.x + _tmp.x, origin.y + _tmp.y, origin.z + _tmp.z);
    positions.needsUpdate = true;
    obj.material["color"].set(color2);
    obj.material["depthTest"] = depthTest;
    obj.material["depthWrite"] = false;
  }
  static DrawDirection(pt, direction, color2 = defaultColor, duration = 0, depthTest = true, lengthFactor = 1) {
    if (!_Gizmos.enabled)
      return;
    const obj = Internal.getLine(duration);
    const positions = obj.geometry.getAttribute("position");
    positions.setXYZ(0, pt.x, pt.y, pt.z);
    if (direction["w"] !== void 0) {
      _tmp.set(0, 0, -lengthFactor);
      _quat.set(direction["x"], direction["y"], direction["z"], direction["w"]);
      _tmp.applyQuaternion(_quat);
    } else {
      _tmp.set(direction.x, direction.y, direction.z);
      _tmp.multiplyScalar(lengthFactor);
    }
    positions.setXYZ(1, pt.x + _tmp.x, pt.y + _tmp.y, pt.z + _tmp.z);
    positions.needsUpdate = true;
    obj.material["color"].set(color2);
    obj.material["depthTest"] = depthTest;
    obj.material["depthWrite"] = false;
  }
  static DrawLine(pt0, pt1, color2 = defaultColor, duration = 0, depthTest = true) {
    if (!_Gizmos.enabled)
      return;
    const obj = Internal.getLine(duration);
    const positions = obj.geometry.getAttribute("position");
    positions.setXYZ(0, pt0.x, pt0.y, pt0.z);
    positions.setXYZ(1, pt1.x, pt1.y, pt1.z);
    positions.needsUpdate = true;
    obj.material["color"].set(color2);
    obj.material["depthTest"] = depthTest;
    obj.material["depthWrite"] = false;
    obj.material["fog"] = false;
  }
  static DrawCircle(pt0, normal, radius, color2 = defaultColor, duration = 0, depthTest = true) {
    if (!_Gizmos.enabled)
      return;
    const obj = Internal.getCircle(duration);
    obj.position.set(pt0.x, pt0.y, pt0.z);
    obj.scale.set(radius, radius, radius);
    obj.quaternion.setFromUnitVectors(this._up, _tmp.set(normal.x, normal.y, normal.z).normalize());
    obj.material["color"].set(color2);
    obj.material["depthTest"] = depthTest;
    obj.material["depthWrite"] = false;
    obj.material["fog"] = false;
  }
  static DrawWireSphere(center, radius, color2 = defaultColor, duration = 0, depthTest = true) {
    if (!_Gizmos.enabled)
      return;
    const obj = Internal.getSphere(radius, duration, true);
    setWorldPositionXYZ(obj, center.x, center.y, center.z);
    obj.material["color"].set(color2);
    obj.material["depthTest"] = depthTest;
    obj.material["depthWrite"] = false;
    obj.material["fog"] = false;
  }
  static DrawSphere(center, radius, color2 = defaultColor, duration = 0, depthTest = true) {
    if (!_Gizmos.enabled)
      return;
    const obj = Internal.getSphere(radius, duration, false);
    setWorldPositionXYZ(obj, center.x, center.y, center.z);
    obj.material["color"].set(color2);
    obj.material["depthTest"] = depthTest;
    obj.material["depthWrite"] = false;
  }
  static DrawWireBox(center, size, color2 = defaultColor, duration = 0, depthTest = true) {
    if (!_Gizmos.enabled)
      return;
    const obj = Internal.getBox(duration);
    obj.position.set(center.x, center.y, center.z);
    obj.scale.set(size.x, size.y, size.z);
    obj.material["color"].set(color2);
    obj.material["depthTest"] = depthTest;
    obj.material["wireframe"] = true;
    obj.material["depthWrite"] = false;
    obj.material["fog"] = false;
  }
  static DrawWireBox3(box2, color2 = defaultColor, duration = 0, depthTest = true) {
    if (!_Gizmos.enabled)
      return;
    const obj = Internal.getBox(duration);
    obj.position.copy(box2.getCenter(_tmp));
    obj.scale.copy(box2.getSize(_tmp));
    obj.material["color"].set(color2);
    obj.material["depthTest"] = depthTest;
    obj.material["wireframe"] = true;
    obj.material["depthWrite"] = false;
    obj.material["fog"] = false;
  }
  static DrawArrow(pt0, pt1, color2 = defaultColor, duration = 0, depthTest = true, wireframe = false) {
    if (!_Gizmos.enabled)
      return;
    const obj = Internal.getArrowHead(duration);
    obj.position.set(pt1.x, pt1.y, pt1.z);
    obj.quaternion.setFromUnitVectors(this._up.set(0, 1, 0), _tmp.set(pt1.x, pt1.y, pt1.z).sub(_tmp2.set(pt0.x, pt0.y, pt0.z)).normalize());
    const dist = _tmp.set(pt1.x, pt1.y, pt1.z).sub(_tmp2.set(pt0.x, pt0.y, pt0.z)).length();
    const scale = dist * 0.1;
    obj.scale.set(scale, scale, scale);
    obj.material["color"].set(color2);
    obj.material["depthTest"] = depthTest;
    obj.material["wireframe"] = wireframe;
    this.DrawLine(pt0, pt1, color2, duration, depthTest);
  }
  /**
   * Render a wireframe mesh in the scene. The mesh will be removed after the given duration (if duration is 0 it will be rendered for one frame).
   * If a mesh object is provided then the mesh's matrixWorld and geometry will be used. Otherwise, the provided matrix and geometry will be used.
   * @param options the options for the wire mesh
   * @param options.duration the duration in seconds the mesh will be rendered. If 0 it will be rendered for one frame
   * @param options.color the color of the wire mesh
   * @param options.depthTest if true the wire mesh will be rendered with depth test
   * @param options.mesh the mesh object to render (if it is provided the matrix and geometry will be used)
   * @param options.matrix the matrix of the mesh to render
   * @param options.geometry the geometry of the mesh to render
   * @example
   * ```typescript
   * Gizmos.DrawWireMesh({ duration: 1, color: 0xff0000, mesh: myMesh });
   * ```
   */
  static DrawWireMesh(options) {
    const mesh = Internal.getMesh(options.duration ?? 0);
    if ("mesh" in options) {
      mesh.geometry = options.mesh.geometry;
      mesh.matrix.copy(options.mesh.matrixWorld);
    } else {
      mesh.geometry = options.geometry;
      mesh.matrix.copy(options.matrix);
    }
    mesh.matrixAutoUpdate = false;
    mesh.matrixWorldAutoUpdate = false;
    mesh.material["color"].set(options.color ?? defaultColor);
    mesh.material["depthTest"] = options.depthTest ?? true;
    mesh.material["wireframe"] = true;
  }
  /** Set visibility of all currently rendered gizmos */
  static setVisible(visible) {
    for (const obj of Internal.timedObjectsBuffer) {
      obj.visible = visible;
    }
  }
};
var Gizmos = _Gizmos;
/**
 * Allow creating gizmos
 * If disabled then no gizmos will be added to the scene anymore
 */
__publicField(Gizmos, "enabled", true);
__publicField(Gizmos, "_up", new Vector32(0, 1, 0));
var box = new BoxGeometry(1, 1, 1);
function CreateWireCube(col2 = null) {
  const color2 = new Color(col2 ?? 14540253);
  const edges2 = new EdgesGeometry(box);
  const line = new LineSegments(edges2, new LineBasicMaterial({ color: color2 }));
  return line;
}
var $cacheSymbol = Symbol("GizmoCache");
var Internal = class {
  static ensureFont() {
    let fontFamily = __webpack_exports__default.FontLibrary.getFontFamily(this.familyName);
    if (!fontFamily) {
      fontFamily = __webpack_exports__default.FontLibrary.addFontFamily(this.familyName);
      const variant = fontFamily.addVariant("normal", "normal", "https://uploads.needle.tools/include/font-msdf.json", "https://uploads.needle.tools/include/font.png");
      variant == null ? void 0 : variant.addEventListener("ready", () => {
        __webpack_exports__default.update();
      });
    }
  }
  static getTextLabel(duration, text, size, color2, backgroundColor) {
    this.ensureFont();
    let element = this.textLabelCache.pop();
    let opacity = 1;
    if (backgroundColor && typeof backgroundColor === "string" && (backgroundColor == null ? void 0 : backgroundColor.length) >= 8 && backgroundColor.startsWith("#")) {
      opacity = parseInt(backgroundColor.substring(7), 16) / 255;
      backgroundColor = backgroundColor.substring(0, 7);
      if (debug11)
        console.log(backgroundColor, opacity);
    } else if (typeof backgroundColor === "object" && backgroundColor["a"] !== void 0) {
      opacity = backgroundColor["a"];
    }
    const props = {
      boxSizing: "border-box",
      fontFamily: this.familyName,
      width: "auto",
      fontSize: size,
      color: color2,
      lineHeight: 1,
      backgroundColor: backgroundColor ?? void 0,
      backgroundOpacity: opacity,
      textContent: text,
      borderRadius: 0.5 * size,
      padding: 0.8 * size,
      whiteSpace: "pre",
      offset: 0.05 * size
    };
    if (!element) {
      element = new __webpack_exports__Text(props);
      const global2 = this;
      const labelHandle = element;
      labelHandle.setText = function(str) {
        this.set({ textContent: str });
        global2.tmuiNeedsUpdate = true;
      };
    } else {
      element.set(props);
    }
    this.tmuiNeedsUpdate = true;
    this.registerTimedObject(Context.Current, element, duration, this.textLabelCache);
    return element;
  }
  static getBox(duration) {
    let box2 = this.boxesCache.pop();
    if (!box2) {
      const geo = new BoxGeometry(1, 1, 1);
      box2 = new Mesh(geo);
    }
    this.registerTimedObject(Context.Current, box2, duration, this.boxesCache);
    return box2;
  }
  static getLine(duration) {
    let line = this.linesCache.pop();
    if (!line) {
      line = new Line();
      let positions = line.geometry.getAttribute("position");
      if (!positions) {
        positions = new BufferAttribute2(new Float32Array(2 * 3), 3);
        line.geometry.setAttribute("position", positions);
      }
    }
    line.frustumCulled = false;
    this.registerTimedObject(Context.Current, line, duration, this.linesCache);
    return line;
  }
  static getCircle(duration) {
    let circle = this.circlesCache.pop();
    if (!circle) {
      circle = new Line();
      let positions = circle.geometry.getAttribute("position");
      if (!positions) {
        positions = new BufferAttribute2(new Float32Array(circleSegments * 3), 3);
        circle.geometry.setAttribute("position", positions);
        const calcVec1 = getTempVector(0, 1, 0);
        const up2 = getTempVector(0, 0, 1);
        const calcVec2 = getTempVector(up2);
        calcVec2.cross(calcVec1).normalize();
        const right = getTempVector(calcVec2);
        const angleStep = Math.PI * 2 / (circleSegments - 1);
        for (let i = 0; i < circleSegments + 1; i++) {
          const angle = angleStep * i;
          calcVec1.copy(right).multiplyScalar(Math.cos(angle) * 1);
          calcVec2.copy(up2).multiplyScalar(Math.sin(angle) * 1);
          const pos = calcVec1.add(calcVec2);
          positions.setXYZ(i, pos.x, pos.y, pos.z);
        }
      }
    }
    circle.frustumCulled = false;
    this.registerTimedObject(Context.Current, circle, duration, this.circlesCache);
    return circle;
  }
  static getSphere(radius, duration, wireframe) {
    let sphere = this.spheresCache.pop();
    if (!sphere) {
      sphere = new Mesh(new SphereGeometry(1, 8, 8));
    }
    sphere.scale.set(radius, radius, radius);
    sphere.material["wireframe"] = wireframe;
    this.registerTimedObject(Context.Current, sphere, duration, this.spheresCache);
    return sphere;
  }
  static getArrowHead(duration) {
    let arrowHead = this.arrowHeadsCache.pop();
    if (!arrowHead) {
      arrowHead = new Mesh(new CylinderGeometry(0, 0.5, 1, 8));
    }
    this.registerTimedObject(Context.Current, arrowHead, duration, this.arrowHeadsCache);
    return arrowHead;
  }
  static getMesh(duration) {
    let mesh = this.mesh.pop();
    if (!mesh) {
      mesh = new Mesh();
      mesh.material = new MeshBasicMaterial();
    }
    this.registerTimedObject(Context.Current, mesh, duration, this.mesh);
    return mesh;
  }
  static registerTimedObject(context, object, duration, cache) {
    if (!context) {
      console.error("No Needle Engine context available. Did you call a Gizmos function in global scope?");
      return;
    }
    const beforeRender = this.contextBeforeRenderCallbacks.get(context);
    const postRender = this.contextPostRenderCallbacks.get(context);
    if (!beforeRender) {
      const cb = () => {
        this.onBeforeRender(context, this.timedObjectsBuffer);
      };
      this.contextBeforeRenderCallbacks.set(context, cb);
      context.pre_render_callbacks.push(cb);
    } else if (context.pre_render_callbacks[context.pre_render_callbacks.length - 1] !== beforeRender) {
      const index = context.pre_render_callbacks.indexOf(beforeRender);
      if (index >= 0) {
        context.pre_render_callbacks.splice(index, 1);
      }
      context.pre_render_callbacks.push(beforeRender);
    }
    if (!postRender) {
      const cb = () => {
        this.onPostRender(context, this.timedObjectsBuffer, this.timesBuffer);
      };
      this.contextPostRenderCallbacks.set(context, cb);
      context.post_render_callbacks.push(cb);
    } else if (context.post_render_callbacks[context.post_render_callbacks.length - 1] !== postRender) {
      const index = context.post_render_callbacks.indexOf(postRender);
      if (index >= 0) {
        context.post_render_callbacks.splice(index, 1);
      }
      context.post_render_callbacks.push(postRender);
    }
    object.traverse((obj) => {
      obj.layers.disableAll();
      obj.layers.enable(2);
    });
    object.renderOrder = 999999;
    object[$cacheSymbol] = cache;
    object.castShadow = false;
    object.receiveShadow = false;
    object["isGizmo"] = true;
    this.timedObjectsBuffer.push(object);
    this.timesBuffer.push(Context.Current.time.realtimeSinceStartup + duration);
    context.scene.add(object);
  }
  static onBeforeRender(ctx, objects) {
    if (this.tmuiNeedsUpdate) {
      this.tmuiNeedsUpdate = false;
      __webpack_exports__default.update();
    }
    for (let i = 0; i < objects.length; i++) {
      const obj = objects[i];
      if (ctx.mainCamera && obj instanceof __webpack_exports__default.MeshUIBaseElement) {
        if (isDestroyed(obj)) {
          continue;
        }
        const isInXR = ctx.isInVR;
        const keepUp = false;
        const copyRotation = !isInXR;
        lookAtObject(obj, ctx.mainCamera, keepUp, copyRotation);
      }
    }
  }
  static onPostRender(ctx, objects, times) {
    const time = ctx.time.realtimeSinceStartup;
    for (let i = objects.length - 1; i >= 0; i--) {
      const obj = objects[i];
      if (time >= times[i] - 1e-6) {
        objects.splice(i, 1);
        times.splice(i, 1);
        obj.removeFromParent();
        if (isDestroyed(obj) != true) {
          const cache = obj[$cacheSymbol];
          cache.push(obj);
        }
      }
    }
  }
};
// private static createdLines: number = 0;
__publicField(Internal, "familyName", "needle-gizmos");
__publicField(Internal, "linesCache", []);
__publicField(Internal, "circlesCache", []);
__publicField(Internal, "spheresCache", []);
__publicField(Internal, "boxesCache", []);
__publicField(Internal, "arrowHeadsCache", []);
__publicField(Internal, "mesh", []);
__publicField(Internal, "textLabelCache", []);
__publicField(Internal, "timedObjectsBuffer", new Array());
__publicField(Internal, "timesBuffer", new Array());
__publicField(Internal, "contextPostRenderCallbacks", /* @__PURE__ */ new Map());
__publicField(Internal, "contextBeforeRenderCallbacks", /* @__PURE__ */ new Map());
__publicField(Internal, "tmuiNeedsUpdate", false);

// node_modules/@needle-tools/engine/lib/engine/engine_physics.js
var debugPhysics = getParam("debugphysics");
var layerMaskHelper = new Layers();
var RaycastOptions = class {
  constructor() {
    __publicField(this, "ray");
    __publicField(this, "cam");
    __publicField(this, "screenPoint");
    __publicField(this, "raycaster");
    __publicField(this, "results");
    __publicField(this, "targets");
    __publicField(this, "recursive", true);
    __publicField(this, "minDistance");
    __publicField(this, "maxDistance");
    __publicField(this, "lineThreshold");
    __publicField(this, "layerMask");
    __publicField(this, "ignore");
    __publicField(this, "testObject");
    __publicField(this, "useAcceleratedRaycast");
  }
  screenPointFromOffset(ox, oy) {
    if (this.screenPoint === void 0)
      this.screenPoint = new Vector2();
    this.screenPoint.x = ox / window.innerWidth * 2 - 1;
    this.screenPoint.y = -(oy / window.innerHeight) * 2 + 1;
  }
  /** sets one layer for raycasting (e.g. layer 4, only objects on layer 4 will then be hit) */
  setLayer(layer) {
    layerMaskHelper.set(layer);
    this.layerMask = layerMaskHelper;
  }
  /** sets the layer.mask value directly, use setLayer if you want to set e.g. an individual layer only active. See https://threejs.org/docs/#api/en/core/Layers for more information about layers */
  setMask(mask) {
    if (!this.layerMask)
      this.layerMask = new Layers();
    const lm = this.layerMask;
    if (lm)
      lm.mask = mask;
    else
      this.layerMask = mask;
  }
};
__publicField(RaycastOptions, "AllLayers", 4294967295);
var SphereIntersection = class {
  constructor(object, distance, point) {
    __publicField(this, "distance");
    __publicField(this, "point");
    __publicField(this, "object");
    this.object = object;
    this.distance = distance;
    this.point = point;
  }
};
var _Physics = class {
  constructor(context) {
    __publicField(this, "context");
    __publicField(this, "engine");
    // raycasting
    __publicField(this, "raycaster", new Raycaster());
    __publicField(this, "defaultRaycastOptions", new RaycastOptions());
    __publicField(this, "targetBuffer", new Array(1));
    __publicField(this, "defaultThresholds", {
      Mesh: {},
      Line: { threshold: -1 },
      LOD: {},
      Points: { threshold: 0 },
      Sprite: {}
    });
    __publicField(this, "sphereResults", new Array());
    __publicField(this, "sphereMask", new Layers());
    __publicField(this, "sphere", new Sphere());
    __publicField(this, "tempBoundingBox", new Box3());
    this.context = context;
  }
  /**
   * Returns true if raycasting is currently happening
   */
  static get raycasting() {
    return this._raycasting > 0;
  }
  /**@deprecated use `this.context.physics.engine.raycast` {@link IPhysicsEngine.raycast} */
  raycastPhysicsFast(origin, direction = void 0, maxDistance = Infinity, solid = true) {
    var _a2;
    return ((_a2 = this.context.physics.engine) == null ? void 0 : _a2.raycast(origin, direction, { maxDistance, solid })) ?? null;
  }
  /**@deprecated use `this.context.physics.engine.raycastAndGetNormal` {@link IPhysicsEngine.raycastAndGetNormal} */
  raycastPhysicsFastAndGetNormal(origin, direction = void 0, maxDistance = Infinity, solid = true) {
    var _a2;
    return ((_a2 = this.context.physics.engine) == null ? void 0 : _a2.raycastAndGetNormal(origin, direction, { maxDistance, solid })) ?? null;
  }
  /**@deprecated use this.context.physics.engine.sphereOverlap */
  sphereOverlapPhysics(point, radius) {
    var _a2;
    return ((_a2 = this.context.physics.engine) == null ? void 0 : _a2.sphereOverlap(point, radius)) ?? null;
  }
  /** Test overlapping of a sphere with the threejs geometry. This does not use colliders. This does not return an exact intersection point (intersections returned contain the object and the world position of the object that is being hit)
   * For a more accurate test use the physics engine's collider overlap test (see sphereOverlapPhysics)
   * @param spherePos the center of the sphere in world space
   * @param radius the radius of the sphere
   * @param traverseChildsAfterHit if false it will stop after the first hit. If true it will continue to traverse and add all hits to the result array
   * @param bvh use MeshBVH for raycasting. This is faster than the default threejs raycaster but uses more memory.
   * @param shouldRaycast optional callback to filter objects. Return `false` to ignore the object completely or `"continue in children"` to skip the object but continue to traverse its children (if you do raycast with `recursive` enabled)
   */
  sphereOverlap(spherePos, radius, traverseChildsAfterHit = true, bvh = false, shouldRaycast = null) {
    this.sphereResults.length = 0;
    if (!this.context.scene)
      return this.sphereResults;
    const mask = this.sphereMask;
    mask.enableAll();
    mask.disable(2);
    for (const ch of this.context.scene.children) {
      this.intersectSphere(ch, spherePos, radius, mask, this.sphereResults, traverseChildsAfterHit, bvh, shouldRaycast);
    }
    return this.sphereResults.sort((a, b) => a.distance - b.distance);
  }
  raycastFromRay(ray, options = null) {
    const opts = options ?? this.defaultRaycastOptions;
    opts.ray = ray;
    const res = this.raycast(opts);
    if (opts === this.defaultRaycastOptions)
      opts.ray = void 0;
    return res;
  }
  /** raycast against rendered three objects. This might be very slow depending on your scene complexity.
   * We recommend setting objects to IgnoreRaycast layer (2) when you don't need them to be raycasted.
   * Raycasting SkinnedMeshes is specially expensive.
   * Use raycastPhysics for raycasting against physic colliders only. Depending on your scenario this might be faster.
   * @param options raycast options. If null, default options will be used.
   */
  raycast(options = null) {
    if (debugPhysics) {
      performance.mark("raycast.start");
    }
    if (!options)
      options = this.defaultRaycastOptions;
    const mp = options.screenPoint ?? this.context.input.mousePositionRC;
    const rc = options.raycaster ?? this.raycaster;
    rc.near = options.minDistance ?? 0;
    rc.far = options.maxDistance ?? Infinity;
    rc.params = this.defaultThresholds;
    if (options.lineThreshold === void 0)
      options.lineThreshold = -1;
    rc.params.Line = { threshold: options.lineThreshold };
    if (options.ray) {
      rc.ray.copy(options.ray);
    } else {
      const cam = options.cam ?? this.context.mainCamera;
      if (!cam) {
        if (debugPhysics)
          console.error("Can not perform raycast - no main camera found");
        if (this.defaultRaycastOptions.results)
          this.defaultRaycastOptions.results.length = 0;
        return this.defaultRaycastOptions.results ?? [];
      }
      const xrCam = this.context.xrCamera;
      if (this.context.isInXR && xrCam instanceof ArrayCamera && xrCam.cameras.length > 0) {
        rc.setFromCamera(mp, xrCam.cameras[0]);
      } else {
        rc.setFromCamera(mp, cam);
      }
    }
    let targets = options.targets;
    if (!targets) {
      targets = this.targetBuffer;
      targets.length = 1;
      targets[0] = this.context.scene;
    }
    let results = options.results;
    if (this.defaultRaycastOptions.results)
      this.defaultRaycastOptions.results.length = 0;
    if (!results) {
      if (!this.defaultRaycastOptions.results)
        this.defaultRaycastOptions.results = new Array();
      results = this.defaultRaycastOptions.results;
    }
    if (options.layerMask !== void 0) {
      if (options.layerMask instanceof Layers)
        rc.layers.mask = options.layerMask.mask;
      else
        rc.layers.mask = options.layerMask;
    } else {
      rc.layers.enableAll();
      rc.layers.disable(2);
    }
    if (debugPhysics) {
      console.time("raycast");
    }
    results.length = 0;
    _Physics._raycasting++;
    this.intersect(this.raycaster, targets, results, options);
    results.sort((a, b) => a.distance - b.distance);
    const ignorelist = options.ignore;
    if (ignorelist !== void 0 && ignorelist.length > 0) {
      results = results.filter((r) => !ignorelist.includes(r.object));
    }
    _Physics._raycasting--;
    if (debugPhysics) {
      console.timeEnd("raycast");
      console.warn("#" + this.context.time.frame + ", hits:", (results == null ? void 0 : results.length) ? [...results] : "nothing");
      performance.mark("raycast.end");
      performance.measure("raycast", "raycast.start", "raycast.end");
    }
    return results;
  }
  intersect(raycaster, objects, results, options) {
    var _a2, _b, _c;
    for (const obj of objects) {
      if (!obj)
        continue;
      if (obj.visible === false)
        continue;
      if (Gizmos.isGizmo(obj))
        continue;
      if (options.lineThreshold !== void 0 && options.lineThreshold < 0) {
        if (obj instanceof Line) {
          continue;
        }
      }
      let shouldIntersectObject = true;
      const mesh = obj;
      const geo = mesh.geometry;
      if (options.testObject) {
        const testResult = (_a2 = options.testObject) == null ? void 0 : _a2.call(options, obj);
        if (testResult === false) {
          continue;
        } else if (testResult === "continue in children") {
          shouldIntersectObject = false;
        }
      }
      if (shouldIntersectObject) {
        if (!geo) {
          shouldIntersectObject = false;
        } else if (!canRaycastGeometry(geo)) {
          shouldIntersectObject = false;
        }
      }
      if (shouldIntersectObject) {
        const raycastMesh = getRaycastMesh(obj);
        if (raycastMesh)
          mesh.geometry = raycastMesh;
        const lastResultsCount = results.length;
        let usePrecise = true;
        if (options.precise === false)
          usePrecise = false;
        usePrecise || (usePrecise = ((_c = (_b = geo.getAttribute("position")) == null ? void 0 : _b.array) == null ? void 0 : _c.length) < 64);
        if (mesh instanceof GroundedSkybox) {
          usePrecise = false;
        }
        if (!usePrecise && customRaycast(mesh, raycaster, results)) {
        } else if (options.useAcceleratedRaycast !== false) {
          NEMeshBVH.runMeshBVHRaycast(raycaster, mesh, results, this.context);
        } else {
          raycaster.intersectObject(mesh, false, results);
        }
        if (debugPhysics && results.length != lastResultsCount) {
          const latestResult = results[results.length - 1];
          const col2 = raycastMesh ? 8969557 : 7798784;
          Gizmos.DrawWireSphere(latestResult.point, 0.1, col2, 1, false);
          Gizmos.DrawWireMesh({ mesh: obj, depthTest: false, duration: 0.2, color: col2 });
        }
        mesh.geometry = geo;
      }
      if (options.recursive !== false) {
        this.intersect(raycaster, obj.children, results, options);
      }
    }
    return results;
  }
  intersectSphere(obj, spherePos, radius, mask, results, traverseChildsAfterHit, useBvh, shouldRaycast) {
    let shouldIntersectObject = obj && obj.isMesh && obj.layers.test(mask) && !Gizmos.isGizmo(obj);
    shouldIntersectObject && (shouldIntersectObject = obj.visible);
    shouldIntersectObject && (shouldIntersectObject = !(obj instanceof Line));
    shouldIntersectObject && (shouldIntersectObject = !(obj instanceof GroundedSkybox));
    const mesh = obj;
    const geo = mesh.geometry;
    if (shouldIntersectObject && shouldRaycast) {
      const testResult = shouldRaycast(obj);
      if (testResult === false) {
        return;
      } else if (testResult === "continue in children") {
        shouldIntersectObject = false;
      }
    }
    if (!geo) {
      shouldIntersectObject = false;
    } else if (!canRaycastGeometry(geo)) {
      shouldIntersectObject = false;
    }
    if (shouldIntersectObject) {
      if (useBvh) {
        const sphere = this.sphere;
        sphere.center.copy(spherePos);
        sphere.radius = radius;
        const previousResults = results.length;
        NEMeshBVH.runMeshBVHRaycast(this.sphere, mesh, results, this.context);
        if (previousResults != results.length && !traverseChildsAfterHit) {
          return;
        }
      } else {
        if (!geo.boundingBox)
          geo.computeBoundingBox();
        if (geo.boundingBox) {
          if (mesh.matrixWorldNeedsUpdate)
            mesh.updateWorldMatrix(false, false);
          const test = this.tempBoundingBox.copy(geo.boundingBox).applyMatrix4(mesh.matrixWorld);
          const sphere = this.sphere;
          sphere.center.copy(spherePos);
          sphere.radius = radius;
          if (sphere.intersectsBox(test)) {
            const wp = getWorldPosition(obj);
            const dist = wp.distanceTo(sphere.center);
            const int = new SphereIntersection(obj, dist, wp);
            results.push(int);
            if (!traverseChildsAfterHit)
              return;
          }
        }
      }
    }
    if (obj.children) {
      for (const ch of obj.children) {
        const len = results.length;
        this.intersectSphere(ch, spherePos, radius, mask, results, traverseChildsAfterHit, useBvh, shouldRaycast);
        if (len != results.length && !traverseChildsAfterHit)
          return;
      }
    }
  }
};
var Physics = _Physics;
__publicField(Physics, "_raycasting", 0);
function canRaycastGeometry(geo) {
  if (geo.index && geo.index.array.length < 3)
    return false;
  return true;
}
var tempSphere = new Sphere();
var tempPlane = new Plane();
var normalUpMatrix = new Matrix3();
function customRaycast(mesh, raycaster, results) {
  const originalComputeIntersectionsFn = mesh["_computeIntersections"];
  if (!originalComputeIntersectionsFn) {
    return false;
  }
  let computeCustomIntersectionFn = mesh["_computeIntersections:Needle"];
  if (!computeCustomIntersectionFn) {
    computeCustomIntersectionFn = mesh["_computeIntersections:Needle"] = function(raycaster2, intersects, _rayLocalSpace) {
      const self2 = this;
      const boundingSphere = self2.geometry.boundingSphere;
      if (boundingSphere) {
        if (self2 instanceof GroundedSkybox) {
          tempPlane.setFromNormalAndCoplanarPoint(getTempVector(0, 1, 0), getTempVector(0, -self2.position.y, 0));
          tempPlane.applyMatrix4(self2.matrixWorld, normalUpMatrix);
          const point2 = raycaster2.ray.intersectPlane(tempPlane, getTempVector());
          if (point2) {
            tempSphere.copy(boundingSphere);
            tempSphere.applyMatrix4(self2.matrixWorld);
            const dir = getTempVector(point2).sub(raycaster2.ray.origin);
            const distance = dir.length();
            const groundProjectionFloorRadius = tempSphere.radius * 0.5;
            if (distance < groundProjectionFloorRadius)
              intersects.push({ distance, point: point2, object: self2, normal: tempPlane.normal.clone() });
          }
          return;
        }
        tempSphere.copy(boundingSphere);
        tempSphere.applyMatrix4(self2.matrixWorld);
        const point = raycaster2.ray.intersectSphere(tempSphere, getTempVector());
        if (point) {
          const dir = getTempVector(point).sub(raycaster2.ray.origin);
          const distance = dir.length();
          if (distance > tempSphere.radius) {
            const normal = dir.clone().normalize();
            intersects.push({ distance, point, object: self2, normal });
          }
        }
      }
    };
  }
  mesh["_computeIntersections"] = computeCustomIntersectionFn;
  raycaster.intersectObject(mesh, false, results);
  mesh["_computeIntersections"] = originalComputeIntersectionsFn;
  return true;
}
var NEMeshBVH;
(function(NEMeshBVH2) {
  function runMeshBVHRaycast(method, mesh, results, context) {
    var _a2, _b, _c;
    if (!mesh.geometry) {
      return false;
    }
    if (!mesh.geometry.hasAttribute("position")) {
      return false;
    }
    const geom = mesh.geometry;
    if (mesh == null ? void 0 : mesh.isSkinnedMesh) {
      const skinnedMesh = mesh;
      const skinnedMeshBVHNeedsUpdate = skinnedMesh.bvhNeedsUpdate;
      if (!skinnedMesh.staticGenerator) {
        loadMeshBVHLibrary();
        if (_StaticGeometryGenerator) {
          skinnedMesh.staticGenerator = new _StaticGeometryGenerator(mesh);
          skinnedMesh.staticGenerator.applyWorldTransforms = false;
          skinnedMesh.staticGeometry = skinnedMesh.staticGenerator.generate();
          geom.boundsTree = _computeBoundsTree == null ? void 0 : _computeBoundsTree.call(skinnedMesh.staticGeometry);
          skinnedMesh.staticGeometryLastUpdate = performance.now() + Math.random() * 200;
          if (skinnedMesh.autoUpdateMeshBVH === void 0)
            skinnedMesh.autoUpdateMeshBVH = false;
        }
      } else if (geom.boundsTree && (skinnedMesh.autoUpdateMeshBVH === true || skinnedMeshBVHNeedsUpdate === true)) {
        const now = performance.now();
        const timeSinceLastUpdate = now - skinnedMesh.staticGeometryLastUpdate;
        if (skinnedMeshBVHNeedsUpdate || timeSinceLastUpdate > 100) {
          skinnedMesh.bvhNeedsUpdate = false;
          skinnedMesh.staticGeometryLastUpdate = now;
          (_a2 = skinnedMesh.staticGenerator) == null ? void 0 : _a2.generate(skinnedMesh.staticGeometry);
          geom.boundsTree.refit();
        }
      }
    } else if (!geom.boundsTree) {
      if (!didSetupWorker)
        internalSetupWorker();
      let canUseWorker = true;
      if (context.xr) {
        canUseWorker = false;
      } else if (geom[canUseWorkerSymbol] === false) {
        canUseWorker = false;
      } else if (((_b = geom.getAttribute("position")) == null ? void 0 : _b["isInterleavedBufferAttribute"]) || geom.index && ((_c = geom.index) == null ? void 0 : _c["isInterleavedBufferAttribute"])) {
        canUseWorker = false;
      }
      if (canUseWorker && _GenerateMeshBVHWorker) {
        if (geom[workerTaskSymbol] === void 0) {
          let workerInstance = null;
          if (availableWorkers.length > 0) {
            const available = availableWorkers.shift();
            if (available && !available.running) {
              workerInstance = available;
            }
          }
          if (!workerInstance && workerInstances.length < 3) {
            workerInstance = new _GenerateMeshBVHWorker();
            workerInstances.push(workerInstance);
          }
          if (workerInstance != null && !workerInstance.running) {
            const name = mesh.name;
            if (debugPhysics)
              console.log("<<<< worker start", name, workerInstance);
            geom[workerTaskSymbol] = "queued";
            performance.mark("bvh.create.start");
            const copy = geom.clone();
            try {
              workerInstance.generate(copy).then((bvh) => {
                geom[workerTaskSymbol] = "done";
                geom.boundsTree = bvh;
              }).catch((err) => {
                geom[workerTaskSymbol] = "failed - " + (err == null ? void 0 : err.message);
                geom[canUseWorkerSymbol] = false;
                if (debugPhysics)
                  console.error("Failed to generate mesh bvh on worker", err);
              }).finally(() => {
                if (debugPhysics)
                  console.log(">>>>> worker done", name, { hasBoundsTre: geom.boundsTree != void 0 });
                availableWorkers.push(workerInstance);
                copy.dispose();
                performance.mark("bvh.create.end");
                performance.measure("bvh.create (worker)", "bvh.create.start", "bvh.create.end");
              });
            } catch (err) {
              console.error("Failed to generate mesh bvh on worker", err);
            }
          } else {
            if (debugPhysics)
              console.warn("No worker available");
          }
        }
      } else if (!isRequestingWorker || !canUseWorker) {
        loadMeshBVHLibrary();
        if (_MeshBVH) {
          performance.mark("bvh.create.start");
          geom.boundsTree = new _MeshBVH(geom);
          performance.mark("bvh.create.end");
          performance.measure("bvh.create", "bvh.create.start", "bvh.create.end");
        }
      }
    }
    if (method instanceof Raycaster) {
      const raycaster = method;
      const raycastMesh = mesh.raycast;
      if (geom.boundsTree) {
        loadMeshBVHLibrary();
        if (_acceleratedRaycast) {
          if (!mesh.acceleratedRaycast) {
            mesh.acceleratedRaycast = _acceleratedRaycast.bind(mesh);
            if (debugPhysics)
              console.debug(`Physics: bind acceleratedRaycast fn to "${mesh.name}"`);
          }
          mesh.raycast = mesh.acceleratedRaycast;
        }
      } else {
        if (debugPhysics)
          console.warn("No bounds tree found for mesh", mesh.name, { workerTask: geom[workerTaskSymbol], hasAcceleratedRaycast: _acceleratedRaycast != null });
      }
      const prevFirstHitOnly = raycaster.firstHitOnly;
      raycaster.firstHitOnly = false;
      raycaster.intersectObject(mesh, false, results);
      raycaster.firstHitOnly = prevFirstHitOnly;
      mesh.raycast = raycastMesh;
      return true;
    } else if (method instanceof Sphere) {
      const bvh = geom.boundsTree;
      if (bvh) {
        const sphere = method;
        invMat.copy(mesh.matrixWorld).invert();
        sphere.applyMatrix4(invMat);
        const intersects = bvh.intersectsSphere(sphere);
        if (intersects) {
          const worldpos = getWorldPosition(mesh);
          const distance = worldpos.distanceTo(sphere.center);
          const intersection = new SphereIntersection(mesh, distance, worldpos);
          results.push(intersection);
        }
      }
      return true;
    }
    return false;
  }
  NEMeshBVH2.runMeshBVHRaycast = runMeshBVHRaycast;
  let didLoadMeshBVHLibrary = false;
  let _acceleratedRaycast = null;
  let _MeshBVH = null;
  let _StaticGeometryGenerator = null;
  let _computeBoundsTree = null;
  function loadMeshBVHLibrary() {
    if (didLoadMeshBVHLibrary)
      return;
    didLoadMeshBVHLibrary = true;
    import("three-mesh-bvh").then((res) => {
      _acceleratedRaycast = res.acceleratedRaycast;
      _MeshBVH = res.MeshBVH;
      _StaticGeometryGenerator = res.StaticGeometryGenerator;
      _computeBoundsTree = res.computeBoundsTree;
    }).catch((_err) => {
      if (debugPhysics || isDevEnvironment()) {
        console.error("Failed to load BVH library...", _err.message);
      }
    });
  }
  const invMat = new Matrix4();
  let didSetupWorker = false;
  let isRequestingWorker = false;
  let _GenerateMeshBVHWorker = null;
  const workerTaskSymbol = Symbol("Needle:MeshBVH-Worker");
  const canUseWorkerSymbol = Symbol("Needle:MeshBVH-CanUseWorker");
  const workerInstances = [];
  const availableWorkers = [];
  function internalSetupWorker() {
    didSetupWorker = true;
    isRequestingWorker = true;
    import("./GenerateMeshBVHWorker-BEJWJCO3.js").then((res) => {
      _GenerateMeshBVHWorker = res.GenerateMeshBVHWorker;
    }).catch((_err) => {
      if (debugPhysics || isDevEnvironment()) {
        console.warn("Failed to setup mesh bvh worker");
      }
    }).finally(() => {
      isRequestingWorker = false;
    });
  }
})(NEMeshBVH || (NEMeshBVH = {}));

// node_modules/@needle-tools/engine/lib/engine/extensions/usage_tracker.js
var $loadingId = Symbol("gltf-loader-internal-usage-tracker");
var debug12 = getParam("debugusers");
var _InternalUsageTrackerPlugin = class {
  constructor(parser) {
    __publicField(this, "parser");
    __publicField(this, "_getDependency");
    __publicField(this, "_loadingId");
    __publicField(this, "_loadedObjects", /* @__PURE__ */ new Set());
    this.parser = parser;
    this._getDependency = this.parser.getDependency;
    this._loadingId = Date.now().toString();
  }
  get name() {
    return "NEEDLE_internal_usage_tracker";
  }
  static isLoading(object) {
    return _InternalUsageTrackerPlugin._loadingProcesses > 0;
    return object[$loadingId] !== void 0;
  }
  beforeRoot() {
    _InternalUsageTrackerPlugin._loadingProcesses++;
    const self2 = this;
    const getDependency = this._getDependency;
    this.parser.getDependency = function(type, index) {
      const promise = getDependency.call(this, type, index);
      promise.then((result) => {
        if (result) {
          self2._loadedObjects.add(result);
          result[$loadingId] = self2._loadingId;
        }
        return result;
      });
      return promise;
    };
    return null;
  }
  afterRoot(_result) {
    _InternalUsageTrackerPlugin._loadingProcesses--;
    this.parser.getDependency = this._getDependency;
    for (const loaded of this._loadedObjects) {
      delete loaded[$loadingId];
      if (loaded instanceof Object3D) {
        if (!loaded.parent) {
          if (loaded instanceof Mesh) {
            setTimeout(() => {
              if (debug12)
                console.warn("> GLTF LOADER: Mesh not used in scene!", loaded);
              loaded.material = null;
              loaded.geometry = null;
            }, 1e3);
          }
        }
      }
    }
    return null;
  }
};
var InternalUsageTrackerPlugin = _InternalUsageTrackerPlugin;
__publicField(InternalUsageTrackerPlugin, "_loadingProcesses", 0);

// node_modules/@needle-tools/engine/lib/engine/engine_assetdatabase.js
var AssetDatabase = class {
  constructor() {
    window.addEventListener("unhandledrejection", (event) => {
      var _a2;
      if (event.defaultPrevented)
        return;
      const pathArray = (_a2 = event == null ? void 0 : event.reason) == null ? void 0 : _a2.path;
      if (pathArray) {
        const source = pathArray[0];
        if (source && source.tagName === "IMG") {
          console.warn("Could not load image:\n" + source.src);
          event.preventDefault();
        }
      }
    });
  }
};
var trackUsageParam = getParam("trackresources");
function autoDispose() {
  return trackUsageParam === "dispose";
}
var allowUsageTracking = true;
if (trackUsageParam === 0)
  allowUsageTracking = false;
function setResourceTrackingEnabled(enabled) {
  allowUsageTracking = enabled;
}
function isResourceTrackingEnabled() {
  return allowUsageTracking;
}
var $disposable = Symbol("disposable");
function setDisposable(obj, disposable) {
  if (!obj)
    return;
  obj[$disposable] = disposable;
  if (debug13)
    console.warn("Set disposable", disposable, obj);
}
var $disposed = Symbol("disposed");
function isDisposed(obj) {
  return obj[$disposed] === true;
}
function disposeObjectResources(obj) {
  var _a2;
  if (!obj)
    return;
  if (obj[$disposable] === false) {
    if (debug13)
      console.warn("Object is marked as not disposable", obj);
    return;
  }
  obj[$disposed] = true;
  if (obj instanceof Scene) {
    disposeObjectResources(obj.environment);
    disposeObjectResources(obj.background);
    disposeObjectResources(obj.customDepthMaterial);
    disposeObjectResources(obj.customDistanceMaterial);
  } else if (obj instanceof SkinnedMesh) {
    disposeObjectResources(obj.geometry);
    disposeObjectResources(obj.material);
    disposeObjectResources(obj.skeleton);
    disposeObjectResources(obj.bindMatrix);
    disposeObjectResources(obj.bindMatrixInverse);
    disposeObjectResources(obj.customDepthMaterial);
    disposeObjectResources(obj.customDistanceMaterial);
    obj.geometry = null;
    obj.material = null;
    obj.visible = false;
  } else if (obj instanceof Mesh) {
    disposeObjectResources(obj.geometry);
    disposeObjectResources(obj.material);
    disposeObjectResources(obj.customDepthMaterial);
    disposeObjectResources(obj.customDistanceMaterial);
    obj.geometry = null;
    obj.material = null;
    obj.visible = false;
  } else if (obj instanceof BufferGeometry) {
    free(obj);
    for (const key of Object.keys(obj.attributes)) {
      const value = obj.attributes[key];
      disposeObjectResources(value);
    }
  } else if (obj instanceof BufferAttribute2 || obj instanceof InterleavedBufferAttribute2) {
    if (debug13)
      console.warn("BufferAttribute dispose not supported", obj.count);
  } else if (obj instanceof Array) {
    for (const entry of obj) {
      if (entry instanceof Material)
        disposeObjectResources(entry);
    }
  } else if (obj instanceof Material) {
    free(obj);
    for (const key of Object.keys(obj)) {
      const value = obj[key];
      if (value instanceof Texture) {
        disposeObjectResources(value);
        obj[key] = null;
      }
    }
    const uniforms = obj["uniforms"];
    if (uniforms) {
      for (const key of Object.keys(uniforms)) {
        const value = uniforms[key];
        if (value instanceof Texture) {
          disposeObjectResources(value);
          uniforms[key] = null;
        } else if (value instanceof Uniform$1) {
          disposeObjectResources(value.value);
          value.value = null;
        }
      }
    }
  } else if (obj instanceof Texture) {
    free(obj);
    free(obj.source);
    if (((_a2 = obj.source) == null ? void 0 : _a2.data) instanceof ImageBitmap) {
      free(obj.source.data);
    }
  } else if (obj instanceof Skeleton) {
    free(obj.boneTexture);
    obj.boneTexture = null;
  } else if (obj instanceof Bone) {
  } else {
    if (!(obj instanceof Object3D) && debug13)
      console.warn("Unknown object type", obj);
  }
}
function free(obj) {
  if (!obj) {
    return;
  }
  if (debug13 || autoDispose() || trackUsageParam)
    console.warn("🧨 FREE", obj);
  if (obj instanceof ImageBitmap) {
    obj.close();
  } else if (obj instanceof Source) {
    obj.data = null;
  } else {
    obj.dispose();
  }
}
function __internalNotifyObjectDestroyed(obj) {
  if (obj instanceof Mesh || obj instanceof SkinnedMesh) {
    obj.material = null;
    obj.geometry = null;
  }
}
var usersBuffer = /* @__PURE__ */ new Set();
function findResourceUsers(object, recursive, predicate = null, set2) {
  if (!set2) {
    set2 = usersBuffer;
    set2.clear();
  }
  if (!object)
    return set2;
  const users = object[$objectUsersKey];
  if (users) {
    for (const user of users) {
      if (set2.has(user))
        continue;
      if ((predicate == null ? void 0 : predicate.call(null, user)) === false)
        continue;
      set2.add(user);
      if (recursive)
        findResourceUsers(user, true, predicate, set2);
    }
  }
  return set2;
}
function getResourceUserCount(object) {
  return object[$objectUsersCountKey];
}
var debug13 = getParam("debugresourceusers") || getParam("debugmemory");
var $objectUsersKey = Symbol("needle-resource-users");
var $objectUsersCountKey = Symbol("needle-resource-users-count");
function trackValueChange(prototype, fieldName) {
  addPatch(prototype, fieldName, function(oldValue, newValue) {
    if (allowUsageTracking && !Physics.raycasting) {
      updateUsers($objectUsersKey, this, oldValue, false);
      updateUsers($objectUsersKey, this, newValue, true);
    }
  });
}
if (allowUsageTracking) {
  trackValueChange(Mesh.prototype, "material");
  trackValueChange(Mesh.prototype, "geometry");
  trackValueChange(Material.prototype, "map");
  trackValueChange(Material.prototype, "bumpMap");
  trackValueChange(Material.prototype, "alphaMap");
  trackValueChange(Material.prototype, "normalMap");
  trackValueChange(Material.prototype, "displacementMap");
  trackValueChange(Material.prototype, "roughnessMap");
  trackValueChange(Material.prototype, "metalnessMap");
  trackValueChange(Material.prototype, "emissiveMap");
  trackValueChange(Material.prototype, "specularMap");
  trackValueChange(Material.prototype, "envMap");
  trackValueChange(Material.prototype, "lightMap");
  trackValueChange(Material.prototype, "aoMap");
  trackValueChange(Material.prototype, "gradientMap");
}
function onDispose(obj) {
  if (allowUsageTracking === false)
    return;
  const users = obj[$objectUsersKey];
  if (users) {
    for (const user of users) {
      updateUsers($objectUsersKey, user, obj, false);
    }
  }
}
if (allowUsageTracking) {
  addPatch(Material.prototype, "dispose", function() {
    onDispose(this);
  });
}
var noUpdateScope = 0;
function updateUsers(symbol, user, object, added) {
  if (noUpdateScope > 0)
    return;
  if (Array.isArray(object)) {
    for (const m2 of object) {
      updateUsers(symbol, user, m2, added);
    }
    return;
  }
  if (!object)
    return;
  let users = object[symbol];
  if (!users)
    users = /* @__PURE__ */ new Set();
  if (added) {
    if (user && !users.has(user)) {
      users.add(user);
      let count = object[$objectUsersCountKey] || 0;
      count += 1;
      object[$objectUsersCountKey] = count;
      if (debug13)
        console.warn(`🟢 Added user of "${object["type"]}"`, user, object, count, "users:", users);
    }
  } else {
    if (user && users.has(user)) {
      users.delete(user);
      let count = object[$objectUsersCountKey] || 0;
      if (count > 0) {
        count -= 1;
        object[$objectUsersCountKey] = count;
      }
      if (debug13)
        console.warn(`🔴 Removed user of "${object["type"]}"`, user, object, count, "users:", users);
      if (count <= 0) {
        if (!InternalUsageTrackerPlugin.isLoading(object)) {
          if (trackUsageParam)
            console.warn(`🔴 Removed all user of "${object["type"]}"`, object);
          if (autoDispose())
            disposeObjectResources(object);
        }
      }
    }
  }
  object[symbol] = users;
}
try {
  addPatch(WebGLRenderer.prototype, "render", function() {
    noUpdateScope++;
  }, function() {
    noUpdateScope--;
  });
} catch (e) {
  console.warn("Could not wrap WebGLRenderer.render", e);
}

// node_modules/@needle-tools/engine/lib/engine/engine_components_internal.js
var debug14 = getParam("debugcomponentevents");
var ComponentLifecycleEvents = class {
  static addComponentLifecylceEventListener(evt, cb) {
    if (this.eventListeners.has(evt)) {
      this.eventListeners.set(evt, []);
    }
    let arr = this.eventListeners.get(evt);
    if (!arr)
      arr = [];
    arr.push(cb);
    this.eventListeners.set(evt, arr);
    if (debug14)
      console.log("Added event listener for " + evt, this.eventListeners);
  }
  static removeComponentLifecylceEventListener(evt, cb) {
    const listeners = this.eventListeners.get(evt);
    if (!listeners)
      return;
    const index = listeners.indexOf(cb);
    if (index < 0)
      return;
    listeners.splice(index, 1);
  }
  static dispatchComponentLifecycleEvent(evt, data) {
    const listeners = this.eventListeners.get(evt);
    if (debug14)
      console.log("Dispatching event " + evt, listeners);
    if (!listeners)
      return;
    for (const listener of listeners) {
      listener(data);
    }
  }
};
__publicField(ComponentLifecycleEvents, "eventListeners", /* @__PURE__ */ new Map());

// node_modules/@needle-tools/engine/lib/engine/engine_instancing.js
var NEED_UPDATE_INSTANCE_KEY = Symbol("NEEDLE_NEED_UPDATE_INSTANCE");
var $isUsingInstancing = Symbol("isUsingInstancing");
var $instancingRenderer = Symbol("instancingRenderer");
var $instancingAutoUpdateBounds = Symbol("instancingAutoUpdateBounds");
var InstancingUtil = class {
  /** Is this object rendered using a InstancedMesh */
  static isUsingInstancing(instance) {
    return instance[$isUsingInstancing] === true;
  }
  /** Returns the instanced mesh IF the object is rendered by an instanced mesh
   * @link https://threejs.org/docs/#api/en/objects/InstancedMesh
   */
  static getRenderer(instance) {
    return instance[$instancingRenderer] || null;
  }
  setAutoUpdateBounds(instance, value) {
    const renderer = InstancingUtil.getRenderer(instance);
    if (renderer) {
      renderer[$instancingAutoUpdateBounds] = value;
    }
  }
  // TODO: change this so it does not set matrix world directly but some flag that is only used by instancing
  /** Mark an instanced object dirty so the instance matrix will be updated */
  static markDirty(go, recursive = true) {
    if (!go)
      return;
    if (this.isUsingInstancing(go)) {
      go[NEED_UPDATE_INSTANCE_KEY] = true;
      go.matrixWorldNeedsUpdate = true;
    }
    if (recursive) {
      for (const child of go.children) {
        InstancingUtil.markDirty(child, true);
      }
    }
  }
};

// node_modules/@needle-tools/engine/lib/engine/engine_generic_utils.js
function safeInvoke(fun, args) {
  try {
    if (args)
      fun(args);
    else
      fun();
  } catch (err) {
    console.error(err);
    return false;
  }
  return true;
}

// node_modules/@needle-tools/engine/lib/engine/engine_mainloop_utils.js
var debug15 = getParam("debugnewscripts");
var debugHierarchy = getParam("debughierarchy");
var new_scripts_buffer = [];
function hasNewScripts() {
  return new_scripts_buffer.length > 0;
}
function processNewScripts(context) {
  if (context.new_scripts.length <= 0)
    return;
  if (debug15)
    console.log("Register new components", context.new_scripts.length, [...context.new_scripts], context.alias ? "element: " + context.alias : context["hash"], context);
  if (context.new_scripts_pre_setup_callbacks.length > 0) {
    for (const cb of context.new_scripts_pre_setup_callbacks) {
      if (!cb)
        continue;
      cb();
    }
    context.new_scripts_pre_setup_callbacks.length = 0;
  }
  new_scripts_buffer.length = 0;
  if (context.new_scripts.length > 0) {
    new_scripts_buffer.push(...context.new_scripts);
  }
  context.new_scripts.length = 0;
  for (let i = 0; i < new_scripts_buffer.length; i++) {
    try {
      const script = new_scripts_buffer[i];
      if (script.isComponent !== true) {
        if (isDevEnvironment() || debug15)
          console.error('Registered script is not a Needle Engine component. \nThe script will be ignored. Please make sure your component extends "Behaviour" imported from "@needle-tools/engine"\n', script);
        new_scripts_buffer.splice(i, 1);
        i--;
        continue;
      }
      if (script.destroyed)
        continue;
      if (!script.gameObject) {
        console.warn("Component can not be initialized: no GameObject assigned.\nDid you add and remove a component in the same frame?");
        new_scripts_buffer.splice(i, 1);
        i--;
        continue;
      }
      script.context = context;
      updateActiveInHierarchyWithoutEventCall(script.gameObject);
      addScriptToArrays(script, context);
    } catch (err) {
      console.error(err);
      removeScriptFromContext(new_scripts_buffer[i], context);
      new_scripts_buffer.splice(i, 1);
      i--;
    }
  }
  for (let i = 0; i < new_scripts_buffer.length; i++) {
    try {
      const script = new_scripts_buffer[i];
      if (script.destroyed) {
        removeScriptFromContext(new_scripts_buffer[i], context);
        new_scripts_buffer.splice(i, 1);
        i--;
        continue;
      }
      if (script.registering) {
        try {
          script.registering();
        } catch (err) {
          console.error(err);
        }
      }
      if (script.__internalAwake !== void 0) {
        if (!script.gameObject) {
          console.error("Calling awake for a component without a GameObject", script, script.gameObject);
        }
        updateActiveInHierarchyWithoutEventCall(script.gameObject);
        if (script.activeAndEnabled)
          safeInvoke(script.__internalAwake.bind(script));
      }
    } catch (err) {
      console.error(err);
      removeScriptFromContext(new_scripts_buffer[i], context);
      new_scripts_buffer.splice(i, 1);
      i--;
    }
  }
  for (let i = 0; i < new_scripts_buffer.length; i++) {
    try {
      const script = new_scripts_buffer[i];
      if (script.destroyed)
        continue;
      if (script.enabled === false)
        continue;
      updateActiveInHierarchyWithoutEventCall(script.gameObject);
      if (script.activeAndEnabled === false)
        continue;
      if (script.__internalEnable !== void 0) {
        script.enabled = true;
        safeInvoke(script.__internalEnable.bind(script));
      }
    } catch (err) {
      console.error(err);
      removeScriptFromContext(new_scripts_buffer[i], context);
      new_scripts_buffer.splice(i, 1);
      i--;
    }
  }
  for (let i = 0; i < new_scripts_buffer.length; i++) {
    try {
      const script = new_scripts_buffer[i];
      if (script.destroyed)
        continue;
      if (!script.gameObject)
        continue;
      context.new_script_start.push(script);
    } catch (err) {
      console.error(err);
      removeScriptFromContext(new_scripts_buffer[i], context);
      new_scripts_buffer.splice(i, 1);
      i--;
    }
  }
  new_scripts_buffer.length = 0;
  for (const cb of context.new_scripts_post_setup_callbacks) {
    if (cb)
      cb();
  }
  context.new_scripts_post_setup_callbacks.length = 0;
}
function processRemoveFromScene(script) {
  if (!script)
    return;
  script.__internalDisable(true);
  removeScriptFromContext(script, script.context);
}
function processStart(context, object) {
  for (let i = 0; i < context.new_script_start.length; i++) {
    try {
      const script = context.new_script_start[i];
      if (object !== void 0 && script.gameObject !== object)
        continue;
      if (script.destroyed)
        continue;
      if (script.activeAndEnabled === false) {
        continue;
      }
      safeInvoke(script.__internalAwake.bind(script));
      if (script.enabled) {
        safeInvoke(script.__internalEnable.bind(script));
        safeInvoke(script.__internalStart.bind(script));
        context.new_script_start.splice(i, 1);
        i--;
      }
    } catch (err) {
      console.error(err);
      removeScriptFromContext(context.new_script_start[i], context);
      context.new_script_start.splice(i, 1);
      i--;
    }
  }
}
function addScriptToArrays(script, context) {
  const index = context.scripts.indexOf(script);
  if (index !== -1)
    return;
  context.scripts.push(script);
  if (script.earlyUpdate)
    context.scripts_earlyUpdate.push(script);
  if (script.update)
    context.scripts_update.push(script);
  if (script.lateUpdate)
    context.scripts_lateUpdate.push(script);
  if (script.onBeforeRender)
    context.scripts_onBeforeRender.push(script);
  if (script.onAfterRender)
    context.scripts_onAfterRender.push(script);
  if (script.onPausedChanged)
    context.scripts_pausedChanged.push(script);
  if (isNeedleXRSessionEventReceiver(script, null))
    context.new_scripts_xr.push(script);
  if (isNeedleXRSessionEventReceiver(script, "immersive-vr"))
    context.scripts_immersive_vr.push(script);
  if (isNeedleXRSessionEventReceiver(script, "immersive-ar"))
    context.scripts_immersive_ar.push(script);
}
function removeScriptFromContext(script, context) {
  removeFromArray(script, context.new_scripts);
  removeFromArray(script, context.new_script_start);
  removeFromArray(script, context.scripts);
  removeFromArray(script, context.scripts_earlyUpdate);
  removeFromArray(script, context.scripts_update);
  removeFromArray(script, context.scripts_lateUpdate);
  removeFromArray(script, context.scripts_onBeforeRender);
  removeFromArray(script, context.scripts_onAfterRender);
  removeFromArray(script, context.scripts_pausedChanged);
  removeFromArray(script, context.new_scripts_xr);
  removeFromArray(script, context.scripts_immersive_vr);
  removeFromArray(script, context.scripts_immersive_ar);
  context.stopAllCoroutinesFrom(script);
}
function removeFromArray(script, array) {
  const index = array.indexOf(script);
  if (index >= 0)
    array.splice(index, 1);
}
function isNeedleXRSessionEventReceiver(script, mode) {
  var _a2;
  if (script) {
    const i = script;
    if (i.onBeforeXR || i.onEnterXR || i.onUpdateXR || i.onLeaveXR || i.onXRControllerAdded || i.onXRControllerRemoved) {
      if (mode != null) {
        if (((_a2 = i.supportsXR) == null ? void 0 : _a2.call(i, mode)) === false)
          return false;
      }
      return true;
    }
  }
  return false;
}
function updateIsActive(obj) {
  if (!obj)
    obj = ContextRegistry.Current.scene;
  if (!obj) {
    console.trace("Invalid call - no current context.");
    return;
  }
  const activeSelf = isActiveSelf(obj);
  const wasSuccessful = updateIsActiveInHierarchyRecursiveRuntime(obj, activeSelf, true);
  if (!wasSuccessful) {
    if (debug15 || isDevEnvironment()) {
      console.error('Error updating hierarchy\nDo you have circular references in your project? <a target="_blank" href="https://docs.needle.tools/circular-reference"> Click here for more information.', obj);
    } else
      console.error('Failed to update active state in hierarchy of "' + obj.name + '"', obj);
    console.warn(" ↑ this error might be caused by circular references. Please make sure you don't have files with circular references (e.g. one GLB 1 is loading GLB 2 which is then loading GLB 1 again).");
  }
}
function updateIsActiveInHierarchyRecursiveRuntime(go, activeInHierarchy, allowEventCall, level = 0) {
  if (level > 1e3) {
    console.warn("Hierarchy is too deep (> 1000 level) - will abort updating active state");
    return false;
  }
  const isActive = isActiveSelf(go);
  if (activeInHierarchy) {
    activeInHierarchy = isActive;
    if (activeInHierarchy && go.parent) {
      const parent = go.parent;
      activeInHierarchy = parent[activeInHierarchyFieldName];
      if (activeInHierarchy === void 0) {
        if (parent instanceof Scene) {
        } else {
          activeInHierarchy = true;
        }
      }
    }
  }
  const prevActive = go[activeInHierarchyFieldName];
  const changed = prevActive !== activeInHierarchy;
  go[activeInHierarchyFieldName] = activeInHierarchy;
  if (changed) {
    if (debugHierarchy)
      console.warn("ACTIVE CHANGE", go.name, isActive, go.visible, activeInHierarchy, "changed?" + changed, go);
    if (allowEventCall) {
      perComponent(go, (comp) => {
        if (activeInHierarchy) {
          if (comp.enabled) {
            safeInvoke(comp.__internalAwake.bind(comp));
            if (comp.enabled) {
              comp["__didEnable"] = true;
              comp.onEnable();
            }
          }
        } else {
          if (comp["__didAwake"] && comp.enabled) {
            comp["__didEnable"] = false;
            comp.onDisable();
          }
        }
      });
    }
  }
  let success = true;
  if (go.children) {
    const nextLevel = level + 1;
    for (const ch of go.children) {
      const res = updateIsActiveInHierarchyRecursiveRuntime(ch, activeInHierarchy, allowEventCall, nextLevel);
      if (res === false)
        success = false;
    }
  }
  return success;
}
function updateActiveInHierarchyWithoutEventCall(go) {
  let activeInHierarchy = true;
  let current = go;
  let foundScene = false;
  while (current) {
    if (!current)
      break;
    if (current.type === "Scene")
      foundScene = true;
    if (!isActiveSelf(current)) {
      activeInHierarchy = false;
      break;
    }
    current = current.parent;
  }
  if (!go) {
    console.error("GO is null");
    return;
  }
  go[activeInHierarchyFieldName] = activeInHierarchy && foundScene;
}
function perComponent(go, evt) {
  var _a2;
  if ((_a2 = go.userData) == null ? void 0 : _a2.components) {
    for (const comp of go.userData.components) {
      evt(comp);
    }
  }
}
var prewarmList = /* @__PURE__ */ new Map();
var $prewarmedFlag = Symbol("prewarmFlag");
var $waitingForPrewarm = Symbol("waitingForPrewarm");
var debugPrewarm = getParam("debugprewarm");
function registerPrewarmObject(obj, context) {
  if (!obj)
    return;
  if (obj[$prewarmedFlag] === true)
    return;
  if (obj[$waitingForPrewarm] === true)
    return;
  if (!prewarmList.has(context)) {
    prewarmList.set(context, []);
  }
  obj[$waitingForPrewarm] = true;
  const list = prewarmList.get(context);
  list.push(obj);
  if (debugPrewarm)
    console.debug("register prewarm", obj.name);
}
var prewarmTarget = null;
var prewarmCamera = null;
function runPrewarm(context) {
  if (!context)
    return;
  const list = prewarmList.get(context);
  if (!(list == null ? void 0 : list.length))
    return;
  const cam = context.mainCamera;
  if (cam) {
    if (debugPrewarm)
      console.log("prewarm", list.length, "objects", [...list]);
    const renderer = context.renderer;
    if (renderer.compile) {
      const scene = context.scene;
      renderer.compile(scene, cam);
      prewarmTarget ?? (prewarmTarget = new WebGLCubeRenderTarget(64));
      prewarmCamera ?? (prewarmCamera = new CubeCamera(1e-3, 9999999, prewarmTarget));
      prewarmCamera.update(renderer, scene);
      for (const obj of list) {
        obj[$prewarmedFlag] = true;
        obj[$waitingForPrewarm] = false;
      }
      list.length = 0;
      if (debugPrewarm)
        console.log("prewarm done");
    }
  }
}

// node_modules/uuid/dist/esm-browser/rng.js
var rnds8 = new Uint8Array(16);

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v4;
  const arr = new Uint8Array(16);
  arr[0] = (v4 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v4 >>> 16 & 255;
  arr[2] = v4 >>> 8 & 255;
  arr[3] = v4 & 255;
  arr[4] = (v4 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v4 & 255;
  arr[6] = (v4 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v4 & 255;
  arr[8] = (v4 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v4 & 255;
  arr[10] = (v4 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v4 / 4294967296 & 255;
  arr[12] = v4 >>> 24 & 255;
  arr[13] = v4 >>> 16 & 255;
  arr[14] = v4 >>> 8 & 255;
  arr[15] = v4 & 255;
  return arr;
}
var parse_default = parse;

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name, version2, hashfunc) {
  function generateUUID2(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID2.name = name;
  } catch (err) {
  }
  generateUUID2.DNS = DNS;
  generateUUID2.URL = URL2;
  return generateUUID2;
}

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (let i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = "0123456789abcdef";
  for (let i = 0; i < length32; i += 8) {
    const x2 = input[i >> 5] >>> i % 32 & 255;
    const hex = parseInt(hexTab.charAt(x2 >>> 4 & 15) + hexTab.charAt(x2 & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x2, len) {
  x2[len >> 5] |= 128 << len % 32;
  x2[getOutputLength(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c2 = -1732584194;
  let d = 271733878;
  for (let i = 0; i < x2.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c2;
    const oldd = d;
    a = md5ff(a, b, c2, d, x2[i], 7, -680876936);
    d = md5ff(d, a, b, c2, x2[i + 1], 12, -389564586);
    c2 = md5ff(c2, d, a, b, x2[i + 2], 17, 606105819);
    b = md5ff(b, c2, d, a, x2[i + 3], 22, -1044525330);
    a = md5ff(a, b, c2, d, x2[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c2, x2[i + 5], 12, 1200080426);
    c2 = md5ff(c2, d, a, b, x2[i + 6], 17, -1473231341);
    b = md5ff(b, c2, d, a, x2[i + 7], 22, -45705983);
    a = md5ff(a, b, c2, d, x2[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c2, x2[i + 9], 12, -1958414417);
    c2 = md5ff(c2, d, a, b, x2[i + 10], 17, -42063);
    b = md5ff(b, c2, d, a, x2[i + 11], 22, -1990404162);
    a = md5ff(a, b, c2, d, x2[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c2, x2[i + 13], 12, -40341101);
    c2 = md5ff(c2, d, a, b, x2[i + 14], 17, -1502002290);
    b = md5ff(b, c2, d, a, x2[i + 15], 22, 1236535329);
    a = md5gg(a, b, c2, d, x2[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c2, x2[i + 6], 9, -1069501632);
    c2 = md5gg(c2, d, a, b, x2[i + 11], 14, 643717713);
    b = md5gg(b, c2, d, a, x2[i], 20, -373897302);
    a = md5gg(a, b, c2, d, x2[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c2, x2[i + 10], 9, 38016083);
    c2 = md5gg(c2, d, a, b, x2[i + 15], 14, -660478335);
    b = md5gg(b, c2, d, a, x2[i + 4], 20, -405537848);
    a = md5gg(a, b, c2, d, x2[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c2, x2[i + 14], 9, -1019803690);
    c2 = md5gg(c2, d, a, b, x2[i + 3], 14, -187363961);
    b = md5gg(b, c2, d, a, x2[i + 8], 20, 1163531501);
    a = md5gg(a, b, c2, d, x2[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c2, x2[i + 2], 9, -51403784);
    c2 = md5gg(c2, d, a, b, x2[i + 7], 14, 1735328473);
    b = md5gg(b, c2, d, a, x2[i + 12], 20, -1926607734);
    a = md5hh(a, b, c2, d, x2[i + 5], 4, -378558);
    d = md5hh(d, a, b, c2, x2[i + 8], 11, -2022574463);
    c2 = md5hh(c2, d, a, b, x2[i + 11], 16, 1839030562);
    b = md5hh(b, c2, d, a, x2[i + 14], 23, -35309556);
    a = md5hh(a, b, c2, d, x2[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c2, x2[i + 4], 11, 1272893353);
    c2 = md5hh(c2, d, a, b, x2[i + 7], 16, -155497632);
    b = md5hh(b, c2, d, a, x2[i + 10], 23, -1094730640);
    a = md5hh(a, b, c2, d, x2[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c2, x2[i], 11, -358537222);
    c2 = md5hh(c2, d, a, b, x2[i + 3], 16, -722521979);
    b = md5hh(b, c2, d, a, x2[i + 6], 23, 76029189);
    a = md5hh(a, b, c2, d, x2[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c2, x2[i + 12], 11, -421815835);
    c2 = md5hh(c2, d, a, b, x2[i + 15], 16, 530742520);
    b = md5hh(b, c2, d, a, x2[i + 2], 23, -995338651);
    a = md5ii(a, b, c2, d, x2[i], 6, -198630844);
    d = md5ii(d, a, b, c2, x2[i + 7], 10, 1126891415);
    c2 = md5ii(c2, d, a, b, x2[i + 14], 15, -1416354905);
    b = md5ii(b, c2, d, a, x2[i + 5], 21, -57434055);
    a = md5ii(a, b, c2, d, x2[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c2, x2[i + 3], 10, -1894986606);
    c2 = md5ii(c2, d, a, b, x2[i + 10], 15, -1051523);
    b = md5ii(b, c2, d, a, x2[i + 1], 21, -2054922799);
    a = md5ii(a, b, c2, d, x2[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c2, x2[i + 15], 10, -30611744);
    c2 = md5ii(c2, d, a, b, x2[i + 6], 15, -1560198380);
    b = md5ii(b, c2, d, a, x2[i + 13], 21, 1309151649);
    a = md5ii(a, b, c2, d, x2[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c2, x2[i + 11], 10, -1120210379);
    c2 = md5ii(c2, d, a, b, x2[i + 2], 15, 718787259);
    b = md5ii(b, c2, d, a, x2[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c2 = safeAdd(c2, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c2, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));
  for (let i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output;
}
function safeAdd(x2, y) {
  const lsw = (x2 & 65535) + (y & 65535);
  const msw = (x2 >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x2, s, t2) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x2, t2)), s), b);
}
function md5ff(a, b, c2, d, x2, s, t2) {
  return md5cmn(b & c2 | ~b & d, a, b, x2, s, t2);
}
function md5gg(a, b, c2, d, x2, s, t2) {
  return md5cmn(b & d | c2 & ~d, a, b, x2, s, t2);
}
function md5hh(a, b, c2, d, x2, s, t2) {
  return md5cmn(b ^ c2 ^ d, a, b, x2, s, t2);
}
function md5ii(a, b, c2, d, x2, s, t2) {
  return md5cmn(c2 ^ (b | ~d), a, b, x2, s, t2);
}
var md5_default = md5;

// node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35("v3", 48, md5_default);

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);

// node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x2, y, z) {
  switch (s) {
    case 0:
      return x2 & y ^ ~x2 & z;
    case 1:
      return x2 ^ y ^ z;
    case 2:
      return x2 & y ^ x2 & z ^ y & z;
    case 3:
      return x2 ^ y ^ z;
  }
}
function ROTL(x2, n2) {
  return x2 << n2 | x2 >>> 32 - n2;
}
function sha1(bytes) {
  const K = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (let i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);
  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }
    M[i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);
    for (let t2 = 0; t2 < 16; ++t2) {
      W[t2] = M[i][t2];
    }
    for (let t2 = 16; t2 < 80; ++t2) {
      W[t2] = ROTL(W[t2 - 3] ^ W[t2 - 8] ^ W[t2 - 14] ^ W[t2 - 16], 1);
    }
    let a = H[0];
    let b = H[1];
    let c2 = H[2];
    let d = H[3];
    let e = H[4];
    for (let t2 = 0; t2 < 80; ++t2) {
      const s = Math.floor(t2 / 20);
      const T3 = ROTL(a, 5) + f(s, b, c2, d) + e + K[s] + W[t2] >>> 0;
      e = d;
      d = c2;
      c2 = ROTL(b, 30) >>> 0;
      b = a;
      a = T3;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c2 >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default = sha1;

// node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35("v5", 80, sha1_default);
var v5_default = v5;

// node_modules/@needle-tools/engine/lib/engine/engine_networking_instantiate.js
ContextRegistry.registerCallback(ContextEvent.ContextCreated, (evt) => {
  const context = evt.context;
  beginListenInstantiate(context);
  beginListenDestroy(context);
});
var debug16 = getParam("debugcomponents");
var ID_NAMESPACE = "eff8ba80-635d-11ec-90d6-0242ac120003";
var InstantiateIdProvider = class {
  constructor(seed) {
    __publicField(this, "_originalSeed");
    __publicField(this, "_seed");
    if (typeof seed === "string") {
      seed = InstantiateIdProvider.hash(seed);
    }
    this._originalSeed = seed;
    this._seed = seed;
  }
  get seed() {
    return this._seed;
  }
  set seed(val) {
    this._seed = val;
  }
  reset() {
    this._seed = this._originalSeed;
  }
  generateUUID(str) {
    if (typeof str === "string") {
      return v5_default(str, ID_NAMESPACE);
    }
    const s = this._seed;
    this._seed -= 1;
    return v5_default(s.toString(), ID_NAMESPACE);
  }
  initialize(strOrNumber) {
    if (typeof strOrNumber === "string") {
      this._seed = InstantiateIdProvider.hash(strOrNumber);
    } else {
      this._seed = strOrNumber;
    }
  }
  static createFromString(str) {
    return new InstantiateIdProvider(this.hash(str));
  }
  static hash(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      hash = str.charCodeAt(i) + ((hash << 5) - hash);
    }
    return hash;
  }
};
var InstantiateEvent;
(function(InstantiateEvent2) {
  InstantiateEvent2["NewInstanceCreated"] = "new-instance-created";
  InstantiateEvent2["InstanceDestroyed"] = "instance-destroyed";
})(InstantiateEvent || (InstantiateEvent = {}));
var DestroyInstanceModel = class {
  constructor(guid) {
    __publicField(this, "guid");
    __publicField(this, "dontSave");
    this.guid = guid;
  }
};
function syncDestroy(obj, con, recursive = true, opts) {
  if (!obj)
    return;
  const go = obj;
  destroy(obj, recursive);
  if (!con) {
    console.warn("Can not send destroy: No networking connection provided", obj.guid);
    return;
  }
  if (!con.isConnected) {
    if (isDevEnvironment())
      console.debug("Can not send destroy: not connected", obj.guid);
    return;
  }
  let guid = obj.guid;
  if (!guid && go.uuid) {
    guid = go.uuid;
  }
  if (!guid) {
    console.warn("Can not send destroy: failed to find guid", obj);
    return;
  }
  sendDestroyed(guid, con, opts);
}
function sendDestroyed(guid, con, opts) {
  const model = new DestroyInstanceModel(guid);
  if ((opts == null ? void 0 : opts.saveInRoom) === false) {
    model.dontSave = true;
  }
  con.send(InstantiateEvent.InstanceDestroyed, model, SendQueue.Queued);
}
function beginListenDestroy(context) {
  context.connection.beginListen(InstantiateEvent.InstanceDestroyed, (data) => {
    if (debug16)
      console.log("[Remote] Destroyed", context.scene, data);
    const obj = findByGuid(data.guid, context.scene);
    if (obj)
      destroy(obj);
  });
}
var HostData = class {
  constructor(filename, hash, size) {
    /** File to download */
    __publicField(this, "filename");
    /** Checksum to verify its the correct file */
    __publicField(this, "hash");
    /** Expected size of the referenced file and its dependencies */
    __publicField(this, "size");
    this.filename = filename;
    this.hash = hash;
    this.size = size;
  }
};
var NewInstanceModel = class {
  constructor(originalGuid, newGuid) {
    __publicField(this, "guid");
    __publicField(this, "originalGuid");
    __publicField(this, "seed");
    __publicField(this, "visible");
    __publicField(this, "hostData");
    __publicField(this, "dontSave");
    __publicField(this, "parent");
    __publicField(this, "position");
    __publicField(this, "rotation");
    __publicField(this, "scale");
    /** Set to true to prevent this model from being instantiated */
    __publicField(this, "preventCreation");
    /**
     * When set this will delete the server state when the user disconnects
     */
    __publicField(this, "deleteStateOnDisconnect");
    this.originalGuid = originalGuid;
    this.guid = newGuid;
  }
};
function syncInstantiate(object, opts, hostData, save) {
  var _a2, _b;
  const obj = object;
  if (!obj.guid) {
    console.warn("Can not instantiate: No guid", obj);
    return null;
  }
  if (!opts.context)
    opts.context = Context.Current;
  if (!opts.context) {
    console.error("Missing network instantiate options / reference to network connection in sync instantiate");
    return null;
  }
  const originalOpts = opts ? { ...opts } : null;
  const { instance, seed } = instantiateSeeded(obj, opts);
  if (instance) {
    const go = instance;
    if (go.guid) {
      if (debug16)
        console.log("[Local] new instance", "gameobject:", instance == null ? void 0 : instance.guid);
      const model = new NewInstanceModel(obj.guid, go.guid);
      model.seed = seed;
      if (opts.deleteOnDisconnect === true)
        model.deleteStateOnDisconnect = true;
      if (originalOpts) {
        if (originalOpts.position)
          model.position = { x: originalOpts.position.x, y: originalOpts.position.y, z: originalOpts.position.z };
        if (originalOpts.rotation)
          model.rotation = { x: originalOpts.rotation.x, y: originalOpts.rotation.y, z: originalOpts.rotation.z, w: originalOpts.rotation.w };
        if (originalOpts.scale)
          model.scale = { x: originalOpts.scale.x, y: originalOpts.scale.y, z: originalOpts.scale.z };
      }
      if (!model.position)
        model.position = { x: go.position.x, y: go.position.y, z: go.position.z };
      if (!model.rotation)
        model.rotation = { x: go.quaternion.x, y: go.quaternion.y, z: go.quaternion.z, w: go.quaternion.w };
      if (!model.scale)
        model.scale = { x: go.scale.x, y: go.scale.y, z: go.scale.z };
      model.visible = obj.visible;
      if (originalOpts == null ? void 0 : originalOpts.parent) {
        if (typeof originalOpts.parent === "string")
          model.parent = originalOpts.parent;
        else
          model.parent = originalOpts.parent["guid"];
      }
      model.hostData = hostData;
      if (save === false)
        model.dontSave = true;
      const con = (_a2 = opts == null ? void 0 : opts.context) == null ? void 0 : _a2.connection;
      if (!con && isDevEnvironment())
        console.debug("Object will be instantiated but it will not be synced: not connected", obj.guid);
      if (opts.context.connection.isInRoom)
        syncedInstantiated.push(new WeakRef(go));
      (_b = opts == null ? void 0 : opts.context) == null ? void 0 : _b.connection.send(InstantiateEvent.NewInstanceCreated, model);
    } else
      console.warn("Missing guid, can not send new instance event", go);
  }
  return instance;
}
function generateSeed() {
  return Math.random() * 9999999;
}
var syncedInstantiated = new Array();
function beginListenInstantiate(context) {
  context.connection.beginListen(InstantiateEvent.NewInstanceCreated, async (model) => {
    const obj = await tryResolvePrefab(model.originalGuid, context.scene);
    if (model.preventCreation === true) {
      return;
    }
    if (!obj) {
      console.warn("could not find object that was instantiated: " + model.guid);
      return;
    }
    const options = new InstantiateOptions();
    if (model.position)
      options.position = new Vector32(model.position.x, model.position.y, model.position.z);
    if (model.rotation)
      options.rotation = new Quaternion(model.rotation.x, model.rotation.y, model.rotation.z, model.rotation.w);
    if (model.scale)
      options.scale = new Vector32(model.scale.x, model.scale.y, model.scale.z);
    options.parent = model.parent;
    if (model.seed)
      options.idProvider = new InstantiateIdProvider(model.seed);
    options.visible = model.visible;
    options.context = context;
    if (debug16 && context.alias)
      console.log("[Remote] instantiate in: " + context.alias);
    const inst = instantiate(obj, options);
    syncedInstantiated.push(new WeakRef(inst));
    if (inst) {
      if (model.parent === "scene")
        context.scene.add(inst);
      if (debug16)
        console.log("[Remote] new instance", "gameobject:", inst == null ? void 0 : inst.guid, obj);
    }
  });
  context.connection.beginListen("left-room", () => {
    if (syncedInstantiated.length > 0)
      console.debug(`Left networking room, cleaning up ${syncedInstantiated.length} instantiated objects`);
    for (const prev of syncedInstantiated) {
      const obj = prev.deref();
      if (obj)
        obj.destroy();
    }
    syncedInstantiated.length = 0;
  });
}
function instantiateSeeded(obj, opts) {
  const seed = generateSeed();
  const options = opts ?? new InstantiateOptions();
  options.idProvider = new InstantiateIdProvider(seed);
  const instance = instantiate(obj, options);
  return { seed, instance };
}
var registeredPrefabProviders = {};
function registerPrefabProvider(key, fn2) {
  registeredPrefabProviders[key] = fn2;
}
async function tryResolvePrefab(guid, obj) {
  const prov = registeredPrefabProviders[guid];
  if (prov !== null && prov !== void 0) {
    const res = await prov(guid);
    if (res)
      return res;
  }
  return tryFindObjectByGuid(guid, obj);
}
function tryFindObjectByGuid(guid, obj) {
  if (obj === null)
    return null;
  if (!guid)
    return null;
  if (obj["guid"] === guid) {
    return obj;
  }
  if (obj.children) {
    for (const ch of obj.children) {
      const found = tryFindObjectByGuid(guid, ch);
      if (found) {
        return found;
      }
    }
  }
  return null;
}

// node_modules/@needle-tools/engine/lib/engine/engine_default_parameters.js
var showGizmos = getParam("gizmos");
var debugExtension = getParam("debugextension");

// node_modules/@needle-tools/engine/lib/engine/engine_typestore.js
var debug17 = getParam("debugtypes");
var _TypeStore = class {
  constructor() {
    __publicField(this, "_types", /* @__PURE__ */ new Map());
    if (debug17)
      console.warn("TypeStore: Created", this);
  }
  /**
   * add a type to the store
   */
  add(key, type) {
    if (debug17)
      console.warn("ADD TYPE", key);
    const existing = this._types.get(key);
    if (!existing)
      this._types.set(key, type);
    else {
      if (debug17) {
        if (existing !== type) {
          console.warn("Type name exists multiple times in your project and may lead to runtime errors:", key);
        }
      }
    }
  }
  /**
   * @returns the type for the given key if registered
   */
  get(key) {
    return this._types.get(key) || null;
  }
  /**
   * @returns the key/name for the given type if registered
   */
  getKey(type) {
    for (const [key, value] of this._types) {
      if (value === type)
        return key;
    }
    return null;
  }
};
var $BuiltInTypeFlag = Symbol("BuiltInType");
var TypeStore = new _TypeStore();
var registerType = function(constructor) {
  if (!TypeStore.get(constructor.name))
    TypeStore.add(constructor.name, constructor);
};

// node_modules/@needle-tools/engine/lib/engine/extensions/extension_utils.js
var debug18 = getParam("debugresolvedependencies");
var rootExtensionPrefix = ["/extensions/", "extensions/"];
var defaultDependencies = [
  { prefix: "/nodes/", dependencyName: "node" },
  { prefix: "/meshes/", dependencyName: "mesh" },
  { prefix: "/materials/", dependencyName: "material" },
  { prefix: "/textures/", dependencyName: "texture" },
  { prefix: "/animations/", dependencyName: "animation" },
  // legacy support
  { prefix: "nodes/", dependencyName: "node" },
  { prefix: "meshes/", dependencyName: "mesh" },
  { prefix: "materials/", dependencyName: "material" },
  { prefix: "textures/", dependencyName: "texture" },
  { prefix: "animations/", dependencyName: "animation" }
];
async function resolveReferences(parser, obj) {
  if (debug18)
    console.log(parser, obj);
  const arr = [];
  internalResolve(defaultDependencies, parser, obj, arr);
  const res = await Promise.all(arr);
  if (typeof obj === "string" && res.length === 1) {
    return res[0];
  }
  return res;
}
function compareAssociation(obj1, obj2) {
  if (!obj1 || !obj2)
    return false;
  if (obj1["needle:identifier"] != void 0 && obj2["needle:identifier"] != void 0)
    return obj1["needle:identifier"] === obj2["needle:identifier"];
  return false;
}
function maskGltfAssociation(obj, identifier) {
  obj["needle:identifier"] = identifier;
}
function internalResolve(paths, parser, obj, promises) {
  if (typeof obj === "object" && obj !== void 0 && obj !== null) {
    for (const key of Object.keys(obj)) {
      const val = obj[key];
      if (typeof val === "string") {
        const ext = resolveExtension(parser, val);
        if (ext !== null && ext !== void 0) {
          if (typeof ext.then === "function")
            promises.push(ext.then((res) => obj[key] = res));
          else
            obj[key] = ext;
        } else {
          const res = tryResolveDependency(paths, parser, val);
          if (res) {
            promises.push(res.then((res2) => {
              obj[key] = res2;
              return res2;
            }));
            continue;
          }
        }
      } else if (Array.isArray(val)) {
        for (let i = 0; i < val.length; i++) {
          const entry = val[i];
          const ext = resolveExtension(parser, entry);
          if (ext !== null) {
            if (typeof ext.then === "function")
              promises.push(ext.then((res) => val[i] = res));
            else
              val[i] = ext;
            continue;
          }
          for (const dep of paths) {
            const index = tryGetIndex(dep.prefix, entry);
            if (index >= 0) {
              if (debug18)
                console.log(dep, index, dep.dependencyName);
              promises.push(parser.getDependency(dep.dependencyName, index).then((res) => val[i] = res));
              break;
            }
          }
          if (typeof entry === "object") {
            internalResolve(paths, parser, entry, promises);
          }
        }
      } else if (typeof val === "object") {
        internalResolve(paths, parser, val, promises);
      }
    }
  } else if (typeof obj === "string") {
    const res = tryResolveDependency(paths, parser, obj);
    if (res)
      promises.push(res);
  }
}
function resolveExtension(parser, str) {
  if (parser && parser.plugins && typeof str === "string") {
    for (const prefix2 of rootExtensionPrefix) {
      if (str.startsWith(prefix2)) {
        let name = str.substring(prefix2.length);
        const endIndex = name.indexOf("/");
        if (endIndex >= 0)
          name = name.substring(0, endIndex);
        const ext = parser.plugins[name];
        if (debugExtension)
          console.log(name, ext);
        if (typeof (ext == null ? void 0 : ext.resolve) === "function") {
          const path = str.substring(prefix2.length + name.length + 1);
          return ext.resolve(parser, path);
        }
        break;
      }
    }
  }
  return null;
}
function tryResolveDependency(paths, parser, str) {
  for (const dep of paths) {
    const index = tryGetIndex(dep.prefix, str);
    if (index >= 0) {
      if (debug18)
        console.warn("GET DEPENDENCY", dep, index, dep.dependencyName);
      return parser.getDependency(dep.dependencyName, index);
    }
  }
  return null;
}
function tryGetIndex(prefix2, str) {
  if (typeof str === "string" && str.startsWith(prefix2)) {
    const part = str.substring(prefix2.length);
    const index = Number.parseInt(part);
    if (index >= 0) {
      return index;
    }
  }
  return -1;
}

// node_modules/@needle-tools/engine/lib/engine/extensions/NEEDLE_persistent_assets.js
var EXTENSION_NAME2 = "NEEDLE_persistent_assets";
function isPersistentAsset(asset) {
  return (asset == null ? void 0 : asset.___persistentAsset) === true;
}
var NEEDLE_persistent_assets = class {
  constructor(parser) {
    __publicField(this, "parser");
    this.parser = parser;
  }
  get name() {
    return EXTENSION_NAME2;
  }
  async afterRoot(_result) {
    var _a2, _b;
    if (!((_b = (_a2 = this.parser) == null ? void 0 : _a2.json) == null ? void 0 : _b.extensions))
      return;
    const ext = this.parser.json.extensions[EXTENSION_NAME2];
    if (!ext)
      return;
    if (debugExtension)
      console.log(ext);
    const promises = new Array();
    for (const e of ext == null ? void 0 : ext.assets) {
      const p = resolveReferences(this.parser, e);
      if (p) {
        promises.push(p);
      }
    }
    await Promise.all(promises);
  }
  resolve(parser, path) {
    const index = Number.parseInt(path);
    if (index >= 0) {
      if (debugExtension)
        console.log(path);
      const ext = parser.json.extensions[EXTENSION_NAME2];
      if (ext) {
        const asset = ext == null ? void 0 : ext.assets[index];
        if (asset) {
          if (typeof asset === "object") {
            asset.___persistentAsset = true;
            const assetTypeInfo = asset["__type"];
            if (assetTypeInfo) {
              const type = TypeStore.get(assetTypeInfo);
              if (type) {
              }
            }
          }
        }
        return asset;
      }
    }
    return null;
  }
};

// node_modules/@needle-tools/engine/lib/engine/engine_serialization_core.js
var debug19 = getParam("debugserializer");
var SerializationHelper = class {
  constructor() {
    /** type > serializer map */
    __publicField(this, "typeMap", /* @__PURE__ */ new Map());
  }
  register(type, ser) {
    if (this.typeMap.has(type)) {
      const existing = this.typeMap.get(type);
      if (existing === ser)
        return;
      if (debug19)
        console.warn("Type: " + type + " is already registered", ser, existing);
    }
    if (debug19)
      console.log("Register type serializer", ser.name, ser, type);
    this.typeMap.set(type, ser);
  }
  getSerializer(type) {
    if (!type)
      return void 0;
    return this.typeMap.get(type);
  }
  getSerializerForConstructor(type, level = 0) {
    if (level > 20)
      return void 0;
    if (!type || !type.constructor) {
      if (debug19)
        console.log("invalid type");
      return void 0;
    }
    const name = type.name;
    const res = this.getSerializer(type);
    if (res !== void 0) {
      if (debug19)
        console.log("FOUND SERIALIZER", res == null ? void 0 : res.name, type.name, type.constructor.name, "for type: " + name, res, type, this.typeMap);
      return res;
    }
    const parent = Object.getPrototypeOf(type);
    if (parent && parent !== type) {
      const resultFromChildren = this.getSerializerForConstructor(parent, ++level);
      if (resultFromChildren) {
        const prot = parent.constructor || parent.prototype;
        if (debug19)
          console.log("FOUND SERIALIZER(in constructor) " + prot.constructor.name, prot.name, prot, resultFromChildren);
        this.register(prot, resultFromChildren);
      }
      return resultFromChildren;
    }
    if (debug19)
      console.warn("No serializer found for " + name, type, type.name, type.constructor.name);
    return void 0;
  }
};
var helper = new SerializationHelper();
var TypeSerializer = class {
  // register<T>(c: Constructor<T> | Constructor<T>[])
  // {
  //     if (Array.isArray(c)) {
  //         for (const t of c) {
  //             helper.register(t.name, this);
  //         }
  //     }
  //     else {
  //         helper.register(c.name, this);
  //     }
  // }
  constructor(type, name) {
    __publicField(this, "name");
    this.name = name;
    if (Array.isArray(type)) {
      for (const key of type) {
        helper.register(key, this);
      }
    } else
      helper.register(type, this);
  }
};
var ImplementationInformation = class {
  constructor() {
    __publicField(this, "isDevMode", isLocalNetwork());
    __publicField(this, "cache", {});
  }
  /** only call when assigning values for the very first time */
  registerDefinedKeys(typeName, type) {
    if (!this.isDevMode)
      return;
    if (this.cache[typeName] === void 0) {
      this.cache[typeName] = Object.keys(type);
      const serializable2 = type;
      if (serializable2.$serializedTypes) {
        const keys = Object.keys(serializable2.$serializedTypes);
        if (keys)
          this.cache[typeName].push(...Object.keys(serializable2.$serializedTypes));
      }
      if (debug19)
        console.log("registerDefinedKeys for " + typeName, this.cache[typeName], type);
    }
  }
  getDefinedKey(typeName, key) {
    if (this.cache[typeName] === void 0)
      return false;
    const keys = this.cache[typeName];
    const res = keys.includes(key);
    return res;
  }
};
var SerializationContext = class {
  constructor(root) {
    __publicField(this, "root");
    __publicField(this, "gltf");
    /** the url of the glb that is currently being loaded */
    __publicField(this, "gltfId");
    __publicField(this, "object");
    __publicField(this, "target");
    __publicField(this, "nodeId");
    __publicField(this, "nodeToObject");
    __publicField(this, "objectToNode");
    __publicField(this, "context");
    __publicField(this, "path");
    __publicField(this, "type");
    /** the serializable attribute for this field (target.path) */
    __publicField(this, "serializable");
    /** holds information if a field was undefined before serialization. This gives us info if we might want to warn the user about missing attributes */
    __publicField(this, "implementationInformation");
    this.root = root;
  }
};
function serializeObject(obj, context) {
  const types = obj.$serializedTypes;
  if (types === void 0)
    return null;
  const res = {};
  for (const key in types) {
    const val = obj[key];
    if (val !== void 0 && val !== null && typeof val === "object") {
      const ser = helper.getSerializerForConstructor(val);
      if (ser) {
        res[key] = ser.onSerialize(val, context);
        continue;
      }
    }
    res[key] = val;
  }
  function getComponentName(component) {
    const typeNames = TypeStore["_types"];
    for (const [typeName, typeVal] of typeNames) {
      if (typeVal === obj.constructor) {
        return typeName;
      }
    }
    return component.__name || component.constructor.name;
  }
  res["name"] = getComponentName(obj);
  if (typeof obj["guid"] === "string")
    res["guid"] = obj["guid"];
  return res;
}
var buffer = [];
function collectSerializedTypesInBaseTypes(obj, typeInfoObject) {
  if (!obj)
    return typeInfoObject;
  if (typeof obj.$serializedTypes === "object") {
    if (!typeInfoObject)
      typeInfoObject = {};
    Object.assign(typeInfoObject, obj.$serializedTypes);
  }
  const parentTarget = Object.getPrototypeOf(obj);
  return collectSerializedTypesInBaseTypes(parentTarget, typeInfoObject);
}
function deserializeObject(obj, serializedData, context) {
  if (!obj)
    return false;
  context.target = obj;
  if (obj.onBeforeDeserialize !== void 0) {
    const res = obj.onBeforeDeserialize(serializedData, context);
    if (typeof res === "boolean")
      return res;
  }
  const typeInfo = collectSerializedTypesInBaseTypes(obj);
  if (serializedData) {
    if (typeof serializedData["guid"] === "string")
      obj["guid"] = serializedData["guid"];
    if (typeInfo) {
      for (const key in typeInfo) {
        let tryResolve = function(typeInfoOrConstructor) {
          const typeInformationOrConstructor = typeInfoOrConstructor;
          const type = typeInformationOrConstructor.type;
          if (type) {
            return deserializeObjectWithType(data, type, context, void 0, obj[key]);
          } else {
            const constructor = typeInfoOrConstructor;
            return deserializeObjectWithType(data, constructor, context, void 0, obj[key]);
          }
        };
        const serializedEntryInfo = typeInfo[key];
        const data = serializedData[key];
        if (debug19)
          console.log(key, data, obj, serializedEntryInfo);
        if (obj[key] !== void 0 && data === void 0) {
          continue;
        }
        context.type = void 0;
        context.path = key;
        context.serializable = serializedEntryInfo;
        if (obj.onBeforeDeserializeMember !== void 0) {
          if (obj.onBeforeDeserializeMember(key, data, context) === true)
            continue;
        }
        if (serializedEntryInfo === null) {
          obj[key] = data;
        } else {
          if (Array.isArray(serializedEntryInfo)) {
            for (let i = 0; i < serializedEntryInfo.length; i++) {
              const typeInfoOrConstructor = serializedEntryInfo[i];
              const res = tryResolve(typeInfoOrConstructor);
              if (res !== void 0 || i === serializedEntryInfo.length - 1) {
                obj[key] = res;
                break;
              }
            }
          } else {
            obj[key] = tryResolve(serializedEntryInfo);
          }
          buffer.length = 0;
        }
        if (obj.onAfterDeserializeMember !== void 0) {
          obj.onAfterDeserializeMember(key, data, context);
        }
      }
    }
    implictlyAssignPrimitiveTypes(obj, serializedData);
  }
  checkObjectAssignments(obj, serializedData, context.implementationInformation);
  if (obj.onAfterDeserialize !== void 0) {
    obj.onAfterDeserialize(serializedData, context);
  }
  return true;
}
var blockChecks = getParam("noerrors");
function checkObjectAssignments(obj, serializedData, implementationInformation) {
  var _a2, _b;
  if (blockChecks)
    return;
  if (!serializedData)
    return;
  if (!isLocalNetwork())
    return;
  if (!obj)
    return;
  if (obj.constructor && obj.constructor[$BuiltInTypeFlag] === true)
    return;
  const typeName = (_a2 = obj.constructor) == null ? void 0 : _a2.name;
  const ownKeys = Object.getOwnPropertyNames(serializedData);
  for (const key of ownKeys) {
    if (key === "sourceId")
      continue;
    const value = obj[key];
    if (value == null)
      continue;
    const serialized = serializedData[key];
    if ((implementationInformation == null ? void 0 : implementationInformation.getDefinedKey(typeName, key)) === false) {
      const firstCharUppercase = key.charAt(0).toUpperCase() + key.slice(1);
      if (implementationInformation.getDefinedKey(typeName, firstCharUppercase)) {
        addLog(LogType.Warn, '<strong>Please rename</strong> "' + firstCharUppercase + '" to "' + key + '" in ' + typeName);
        console.warn('Please use lowercase for field: "' + firstCharUppercase + '" in ' + typeName, serialized, obj);
      }
      continue;
    }
    if (serialized === void 0 || serialized === null)
      continue;
    if (typeof serialized === "object") {
      if (value === void 0 || !value.isObject3D) {
        if (typeof serialized["node"] === "number" || typeof serialized["guid"] === "string") {
          if (serialized["could_not_resolve"]) {
            continue;
          }
          const hasOtherKeys = value !== void 0 && Object.keys(value).length > 1;
          if (!hasOtherKeys) {
            addLog(LogType.Warn, `<strong>Missing serialization for object reference!</strong>

Please change to: 
@serializable(Object3D)
${key}? : Object3D;

in script ${typeName}.ts
<a href="https://docs.needle.tools/serializable" target="_blank">documentation</a>`);
            console.warn(typeName, key, obj[key], obj);
            continue;
          }
        } else if (!Array.isArray(value)) {
          const valueName = (_b = value.constructor) == null ? void 0 : _b.name;
          if (valueName === "Object") {
            if (!value.constructor["did_warn:missing_serializable"]) {
              value.constructor["did_warn:missing_serializable"] = true;
              const warning = 'You might be missing a @serializable(Type) decorator for field "' + key + '" in ' + typeName + ".ts";
              console.warn(warning + `
${key}:`, serialized, valueName);
              addLog(LogType.Warn, "Dev Warning: Are you missing a type in @serializable? Please check the browser console for details");
            }
          }
        }
      }
    }
    if (typeof value === "string") {
      if (typeof serialized === "string" && (serialized.endsWith(".gltf") || serialized.endsWith(".glb"))) {
        addLog(LogType.Warn, `<strong>Missing serialization for object reference!</strong>

Please change to: 
@serializable(AssetReference)
${key}? : AssetReference;

in script ${typeName}.ts
<a href="https://docs.needle.tools/serializable" target="_blank">documentation</a>`);
        console.warn(typeName, key, obj[key], obj);
        continue;
      }
    }
  }
}
function implictlyAssignPrimitiveTypes(obj, serializedData) {
  for (const key of Object.keys(serializedData)) {
    const data = serializedData[key];
    if (typeof data === "object" && data !== null && data !== void 0) {
      const member = obj[key];
      if (!member) {
        if (debug19)
          console.log(key, "is undefined on", obj);
        continue;
      }
      for (const key2 of Object.keys(data)) {
        const targetMember = member[key2];
        if (targetMember !== void 0)
          continue;
        if (isPrimitiveType(data[key2]) && !isPrimitiveType(member)) {
          const prop = tryFindPropertyDescriptor(member, key2);
          if (prop && ((prop == null ? void 0 : prop.writable) === void 0 || (prop == null ? void 0 : prop.writable) === false) && prop.set === void 0) {
            if (debug19)
              console.warn('Property is not writable "' + key2 + '"', member, prop, data[key2], member[key2]);
            continue;
          }
          member[key2] = data[key2];
        }
      }
    }
  }
}
function tryFindPropertyDescriptor(obj, key) {
  while (obj) {
    const desc = Object.getOwnPropertyDescriptor(obj, key);
    if (desc)
      return desc;
    obj = Object.getPrototypeOf(obj);
  }
  return void 0;
}
function isPrimitiveType(val) {
  switch (typeof val) {
    case "number":
    case "string":
    case "boolean":
      return true;
  }
  return false;
}
function deserializeObjectWithType(data, typeOrConstructor, context, typeContext, currentValue) {
  let typeIsFunction = typeof typeOrConstructor === "function" && typeOrConstructor.prototype === void 0;
  let type = typeOrConstructor;
  if (typeIsFunction) {
    try {
      const resolvedType = typeOrConstructor == null ? void 0 : typeOrConstructor.call(typeOrConstructor, currentValue);
      type = resolvedType;
      typeIsFunction = false;
      if (type === null || type === void 0)
        return;
    } catch (err) {
      console.error("Error in callback", err, data);
    }
  }
  context.type = type;
  if (!typeIsFunction && currentValue instanceof type)
    return currentValue;
  if (!typeContext) {
    typeContext = {
      serializer: helper.getSerializerForConstructor(type)
    };
  }
  if (currentValue && typeof currentValue === "object" && isPersistentAsset(currentValue)) {
    if (currentValue["__concreteInstance"]) {
      return currentValue["__concreteInstance"];
    }
    const serializableInstance2 = currentValue;
    if (!serializableInstance2.$serializedTypes && type.prototype.$serializedTypes)
      serializableInstance2.$serializedTypes = type.prototype.$serializedTypes;
    if (serializableInstance2.$serializedTypes) {
      deserializeObject(serializableInstance2, data, context);
    }
    if (currentValue && type !== void 0) {
      try {
        let instance2 = null;
        if (typeContext.serializer) {
          instance2 = typeContext.serializer.onDeserialize(data, context);
        }
        if (!instance2) {
          instance2 = new type();
          if (debugExtension)
            console.log("Create concrete instance for persistent asset", currentValue, "instance:", instance2);
          assign(instance2, currentValue);
        }
        currentValue["__concreteInstance"] = instance2;
        currentValue = instance2;
      } catch (err) {
        console.error("Error creating instance or creating values on instance", err, currentValue, type);
      }
    }
    return currentValue;
  }
  if (Array.isArray(data)) {
    const newArr = [];
    for (let i = 0; i < data.length; i++) {
      const obj = data[i];
      const res = deserializeObjectWithType(obj, typeOrConstructor, context, typeContext, obj);
      newArr.push(res);
    }
    return newArr;
  }
  const ser = typeContext == null ? void 0 : typeContext.serializer;
  if (ser) {
    return ser.onDeserialize(data, context);
  }
  let instance = void 0;
  if (data && (data.isMaterial || data.isTexture || data.isObject3D || data instanceof AnimationClip)) {
    instance = data;
  } else {
    if (data === void 0)
      return void 0;
    if (data === null) {
      if (type === Material || type === Texture || type === Mesh || type === AnimationClip) {
        return null;
      }
    }
    try {
      instance = new type(...setBuffer(data));
    } catch (err) {
      console.error("Error creating " + context.path, context.target, err);
      return;
    }
  }
  const serializableInstance = instance;
  if (serializableInstance.$serializedTypes) {
    deserializeObject(serializableInstance, data, context);
  }
  return instance;
}
function setBuffer(value) {
  buffer.length = 0;
  if (typeof value === "object" && value !== null && value !== void 0) {
    for (const key of Object.keys(value)) {
      buffer.push(value[key]);
    }
  }
  return buffer;
}
var $isAssigningProperties = Symbol("assigned component properties");
function assign(target, source, info) {
  var _a2;
  if (source === void 0 || source === null)
    return;
  if (target === void 0 || target === null)
    return;
  const onlyDeclared = false;
  target[$isAssigningProperties] = true;
  const typeName = ((_a2 = target.constructor) == null ? void 0 : _a2.name) ?? "unknown";
  info == null ? void 0 : info.registerDefinedKeys(typeName, target);
  for (const key of Object.keys(source)) {
    const desc = getPropertyDescriptor(target, key);
    if (onlyDeclared && desc === void 0)
      continue;
    if (typeof (desc == null ? void 0 : desc.value) == "function") {
      continue;
    }
    if (!desc || desc.writable === true) {
      target[key] = source[key];
    } else if ((desc == null ? void 0 : desc.set) !== void 0) {
      target[key] = source[key];
    }
  }
  delete target[$isAssigningProperties];
}
function getPropertyDescriptor(obj, prop) {
  let desc;
  do {
    desc = Object.getOwnPropertyDescriptor(obj, prop);
  } while (!desc && (obj = Object.getPrototypeOf(obj)));
  return desc;
}

// node_modules/@needle-tools/engine/lib/engine/js-extensions/Layers.js
var $customVisibilityFlag = Symbol("customVisibilityFlag");
function setCustomVisibility(obj, visible) {
  obj.layers[$customVisibilityFlag] = visible;
}
var $didPatch = Symbol("DidPatchLayers");
function patchLayers() {
  const prot = Layers.prototype;
  if (prot[$didPatch])
    return;
  prot[$didPatch] = true;
  const origTest = prot.test;
  prot.test = function(layer) {
    if (this[$customVisibilityFlag] === false)
      return false;
    return origTest.call(this, layer);
  };
}
patchLayers();

// node_modules/@needle-tools/engine/lib/engine/js-extensions/Camera.js
Object.defineProperty(PerspectiveCamera.prototype, "fov", {
  get: function() {
    return this._fov;
    ;
  },
  set: function(val) {
    const changed = val !== this._fov;
    this._fov = val;
    if (changed && this.view !== void 0)
      this.updateProjectionMatrix();
  },
  configurable: true
});
Object.defineProperty(PerspectiveCamera.prototype, "near", {
  get: function() {
    return this._near;
  },
  set: function(val) {
    const changed = val !== this._near;
    this._near = val;
    if (changed && this.view !== void 0)
      this.updateProjectionMatrix();
  },
  configurable: true
});
Object.defineProperty(PerspectiveCamera.prototype, "far", {
  get: function() {
    return this._far;
  },
  set: function(val) {
    const changed = val !== this._far;
    this._far = val;
    if (changed && this.view !== void 0)
      this.updateProjectionMatrix();
  },
  configurable: true
});

// node_modules/@needle-tools/engine/lib/engine/js-extensions/ExtensionUtils.js
var handlers = /* @__PURE__ */ new Map();
function applyPrototypeExtensions(obj, prototype) {
  if (!obj)
    return;
  if (!prototype) {
    console.warn("No prototype found", obj, obj.prototype, obj.constructor);
    return;
  }
  const handler = handlers.get(prototype);
  if (handler) {
    handler.apply(obj);
  }
}
function registerPrototypeExtensions(type) {
  const handler = createPrototypeExtensionHandler(type.prototype);
  handlers.set(type, handler);
}
function createPrototypeExtensionHandler(prototype) {
  return new ApplyPrototypeExtension(prototype);
}
var ApplyPrototypeExtension = class {
  constructor(prototype) {
    __publicField(this, "$symbol");
    __publicField(this, "extensions");
    __publicField(this, "descriptors");
    this.$symbol = Symbol("prototype-extension");
    this.extensions = Object.keys(prototype);
    this.descriptors = new Array();
    for (let i = 0; i < this.extensions.length; i++) {
      const key = this.extensions[i];
      const descriptor = Object.getOwnPropertyDescriptor(prototype, key);
      if (descriptor) {
        this.descriptors.push(descriptor);
      }
    }
  }
  apply(object) {
    if (object[this.$symbol])
      return;
    object[this.$symbol] = true;
    for (let i = 0; i < this.extensions.length; i++) {
      const key = this.extensions[i];
      const desc = this.descriptors[i];
      if (desc) {
        Object.defineProperty(object, key, desc);
      }
    }
  }
};

// node_modules/three/examples/jsm/controls/TransformControls.js
var _raycaster = new Raycaster();
var _tempVector = new Vector32();
var _tempVector2 = new Vector32();
var _tempQuaternion = new Quaternion();
var _unit = {
  X: new Vector32(1, 0, 0),
  Y: new Vector32(0, 1, 0),
  Z: new Vector32(0, 0, 1)
};
var _changeEvent = { type: "change" };
var _mouseDownEvent = { type: "mouseDown", mode: null };
var _mouseUpEvent = { type: "mouseUp", mode: null };
var _objectChangeEvent = { type: "objectChange" };
var TransformControls = class extends Controls {
  constructor(camera, domElement = null) {
    super(void 0, domElement);
    const root = new TransformControlsRoot(this);
    this._root = root;
    const gizmo = new TransformControlsGizmo();
    this._gizmo = gizmo;
    root.add(gizmo);
    const plane = new TransformControlsPlane();
    this._plane = plane;
    root.add(plane);
    const scope = this;
    function defineProperty(propName, defaultValue) {
      let propValue = defaultValue;
      Object.defineProperty(scope, propName, {
        get: function() {
          return propValue !== void 0 ? propValue : defaultValue;
        },
        set: function(value) {
          if (propValue !== value) {
            propValue = value;
            plane[propName] = value;
            gizmo[propName] = value;
            scope.dispatchEvent({ type: propName + "-changed", value });
            scope.dispatchEvent(_changeEvent);
          }
        }
      });
      scope[propName] = defaultValue;
      plane[propName] = defaultValue;
      gizmo[propName] = defaultValue;
    }
    defineProperty("camera", camera);
    defineProperty("object", void 0);
    defineProperty("enabled", true);
    defineProperty("axis", null);
    defineProperty("mode", "translate");
    defineProperty("translationSnap", null);
    defineProperty("rotationSnap", null);
    defineProperty("scaleSnap", null);
    defineProperty("space", "world");
    defineProperty("size", 1);
    defineProperty("dragging", false);
    defineProperty("showX", true);
    defineProperty("showY", true);
    defineProperty("showZ", true);
    const worldPosition = new Vector32();
    const worldPositionStart = new Vector32();
    const worldQuaternion = new Quaternion();
    const worldQuaternionStart = new Quaternion();
    const cameraPosition = new Vector32();
    const cameraQuaternion = new Quaternion();
    const pointStart = new Vector32();
    const pointEnd = new Vector32();
    const rotationAxis = new Vector32();
    const rotationAngle = 0;
    const eye = new Vector32();
    defineProperty("worldPosition", worldPosition);
    defineProperty("worldPositionStart", worldPositionStart);
    defineProperty("worldQuaternion", worldQuaternion);
    defineProperty("worldQuaternionStart", worldQuaternionStart);
    defineProperty("cameraPosition", cameraPosition);
    defineProperty("cameraQuaternion", cameraQuaternion);
    defineProperty("pointStart", pointStart);
    defineProperty("pointEnd", pointEnd);
    defineProperty("rotationAxis", rotationAxis);
    defineProperty("rotationAngle", rotationAngle);
    defineProperty("eye", eye);
    this._offset = new Vector32();
    this._startNorm = new Vector32();
    this._endNorm = new Vector32();
    this._cameraScale = new Vector32();
    this._parentPosition = new Vector32();
    this._parentQuaternion = new Quaternion();
    this._parentQuaternionInv = new Quaternion();
    this._parentScale = new Vector32();
    this._worldScaleStart = new Vector32();
    this._worldQuaternionInv = new Quaternion();
    this._worldScale = new Vector32();
    this._positionStart = new Vector32();
    this._quaternionStart = new Quaternion();
    this._scaleStart = new Vector32();
    this._getPointer = getPointer.bind(this);
    this._onPointerDown = onPointerDown.bind(this);
    this._onPointerHover = onPointerHover.bind(this);
    this._onPointerMove = onPointerMove.bind(this);
    this._onPointerUp = onPointerUp.bind(this);
    if (domElement !== null) {
      this.connect();
    }
  }
  connect() {
    this.domElement.addEventListener("pointerdown", this._onPointerDown);
    this.domElement.addEventListener("pointermove", this._onPointerHover);
    this.domElement.addEventListener("pointerup", this._onPointerUp);
    this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown);
    this.domElement.removeEventListener("pointermove", this._onPointerHover);
    this.domElement.removeEventListener("pointermove", this._onPointerMove);
    this.domElement.removeEventListener("pointerup", this._onPointerUp);
    this.domElement.style.touchAction = "auto";
  }
  getHelper() {
    return this._root;
  }
  pointerHover(pointer) {
    if (this.object === void 0 || this.dragging === true)
      return;
    if (pointer !== null)
      _raycaster.setFromCamera(pointer, this.camera);
    const intersect = intersectObjectWithRay(this._gizmo.picker[this.mode], _raycaster);
    if (intersect) {
      this.axis = intersect.object.name;
    } else {
      this.axis = null;
    }
  }
  pointerDown(pointer) {
    if (this.object === void 0 || this.dragging === true || pointer != null && pointer.button !== 0)
      return;
    if (this.axis !== null) {
      if (pointer !== null)
        _raycaster.setFromCamera(pointer, this.camera);
      const planeIntersect = intersectObjectWithRay(this._plane, _raycaster, true);
      if (planeIntersect) {
        this.object.updateMatrixWorld();
        this.object.parent.updateMatrixWorld();
        this._positionStart.copy(this.object.position);
        this._quaternionStart.copy(this.object.quaternion);
        this._scaleStart.copy(this.object.scale);
        this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart);
        this.pointStart.copy(planeIntersect.point).sub(this.worldPositionStart);
      }
      this.dragging = true;
      _mouseDownEvent.mode = this.mode;
      this.dispatchEvent(_mouseDownEvent);
    }
  }
  pointerMove(pointer) {
    const axis = this.axis;
    const mode = this.mode;
    const object = this.object;
    let space = this.space;
    if (mode === "scale") {
      space = "local";
    } else if (axis === "E" || axis === "XYZE" || axis === "XYZ") {
      space = "world";
    }
    if (object === void 0 || axis === null || this.dragging === false || pointer !== null && pointer.button !== -1)
      return;
    if (pointer !== null)
      _raycaster.setFromCamera(pointer, this.camera);
    const planeIntersect = intersectObjectWithRay(this._plane, _raycaster, true);
    if (!planeIntersect)
      return;
    this.pointEnd.copy(planeIntersect.point).sub(this.worldPositionStart);
    if (mode === "translate") {
      this._offset.copy(this.pointEnd).sub(this.pointStart);
      if (space === "local" && axis !== "XYZ") {
        this._offset.applyQuaternion(this._worldQuaternionInv);
      }
      if (axis.indexOf("X") === -1)
        this._offset.x = 0;
      if (axis.indexOf("Y") === -1)
        this._offset.y = 0;
      if (axis.indexOf("Z") === -1)
        this._offset.z = 0;
      if (space === "local" && axis !== "XYZ") {
        this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale);
      } else {
        this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale);
      }
      object.position.copy(this._offset).add(this._positionStart);
      if (this.translationSnap) {
        if (space === "local") {
          object.position.applyQuaternion(_tempQuaternion.copy(this._quaternionStart).invert());
          if (axis.search("X") !== -1) {
            object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Y") !== -1) {
            object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Z") !== -1) {
            object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;
          }
          object.position.applyQuaternion(this._quaternionStart);
        }
        if (space === "world") {
          if (object.parent) {
            object.position.add(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));
          }
          if (axis.search("X") !== -1) {
            object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Y") !== -1) {
            object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Z") !== -1) {
            object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;
          }
          if (object.parent) {
            object.position.sub(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));
          }
        }
      }
    } else if (mode === "scale") {
      if (axis.search("XYZ") !== -1) {
        let d = this.pointEnd.length() / this.pointStart.length();
        if (this.pointEnd.dot(this.pointStart) < 0)
          d *= -1;
        _tempVector2.set(d, d, d);
      } else {
        _tempVector.copy(this.pointStart);
        _tempVector2.copy(this.pointEnd);
        _tempVector.applyQuaternion(this._worldQuaternionInv);
        _tempVector2.applyQuaternion(this._worldQuaternionInv);
        _tempVector2.divide(_tempVector);
        if (axis.search("X") === -1) {
          _tempVector2.x = 1;
        }
        if (axis.search("Y") === -1) {
          _tempVector2.y = 1;
        }
        if (axis.search("Z") === -1) {
          _tempVector2.z = 1;
        }
      }
      object.scale.copy(this._scaleStart).multiply(_tempVector2);
      if (this.scaleSnap) {
        if (axis.search("X") !== -1) {
          object.scale.x = Math.round(object.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
        if (axis.search("Y") !== -1) {
          object.scale.y = Math.round(object.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
        if (axis.search("Z") !== -1) {
          object.scale.z = Math.round(object.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
      }
    } else if (mode === "rotate") {
      this._offset.copy(this.pointEnd).sub(this.pointStart);
      const ROTATION_SPEED = 20 / this.worldPosition.distanceTo(_tempVector.setFromMatrixPosition(this.camera.matrixWorld));
      let _inPlaneRotation = false;
      if (axis === "XYZE") {
        this.rotationAxis.copy(this._offset).cross(this.eye).normalize();
        this.rotationAngle = this._offset.dot(_tempVector.copy(this.rotationAxis).cross(this.eye)) * ROTATION_SPEED;
      } else if (axis === "X" || axis === "Y" || axis === "Z") {
        this.rotationAxis.copy(_unit[axis]);
        _tempVector.copy(_unit[axis]);
        if (space === "local") {
          _tempVector.applyQuaternion(this.worldQuaternion);
        }
        _tempVector.cross(this.eye);
        if (_tempVector.length() === 0) {
          _inPlaneRotation = true;
        } else {
          this.rotationAngle = this._offset.dot(_tempVector.normalize()) * ROTATION_SPEED;
        }
      }
      if (axis === "E" || _inPlaneRotation) {
        this.rotationAxis.copy(this.eye);
        this.rotationAngle = this.pointEnd.angleTo(this.pointStart);
        this._startNorm.copy(this.pointStart).normalize();
        this._endNorm.copy(this.pointEnd).normalize();
        this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1;
      }
      if (this.rotationSnap)
        this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap;
      if (space === "local" && axis !== "E" && axis !== "XYZE") {
        object.quaternion.copy(this._quaternionStart);
        object.quaternion.multiply(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize();
      } else {
        this.rotationAxis.applyQuaternion(this._parentQuaternionInv);
        object.quaternion.copy(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle));
        object.quaternion.multiply(this._quaternionStart).normalize();
      }
    }
    this.dispatchEvent(_changeEvent);
    this.dispatchEvent(_objectChangeEvent);
  }
  pointerUp(pointer) {
    if (pointer !== null && pointer.button !== 0)
      return;
    if (this.dragging && this.axis !== null) {
      _mouseUpEvent.mode = this.mode;
      this.dispatchEvent(_mouseUpEvent);
    }
    this.dragging = false;
    this.axis = null;
  }
  dispose() {
    this.disconnect();
    this.traverse(function(child) {
      if (child.geometry)
        child.geometry.dispose();
      if (child.material)
        child.material.dispose();
    });
  }
  // Set current object
  attach(object) {
    this.object = object;
    this._root.visible = true;
    return this;
  }
  // Detach from object
  detach() {
    this.object = void 0;
    this.axis = null;
    this._root.visible = false;
    return this;
  }
  reset() {
    if (!this.enabled)
      return;
    if (this.dragging) {
      this.object.position.copy(this._positionStart);
      this.object.quaternion.copy(this._quaternionStart);
      this.object.scale.copy(this._scaleStart);
      this.dispatchEvent(_changeEvent);
      this.dispatchEvent(_objectChangeEvent);
      this.pointStart.copy(this.pointEnd);
    }
  }
  getRaycaster() {
    return _raycaster;
  }
  // TODO: deprecate
  getMode() {
    return this.mode;
  }
  setMode(mode) {
    this.mode = mode;
  }
  setTranslationSnap(translationSnap) {
    this.translationSnap = translationSnap;
  }
  setRotationSnap(rotationSnap) {
    this.rotationSnap = rotationSnap;
  }
  setScaleSnap(scaleSnap) {
    this.scaleSnap = scaleSnap;
  }
  setSize(size) {
    this.size = size;
  }
  setSpace(space) {
    this.space = space;
  }
};
function getPointer(event) {
  if (this.domElement.ownerDocument.pointerLockElement) {
    return {
      x: 0,
      y: 0,
      button: event.button
    };
  } else {
    const rect = this.domElement.getBoundingClientRect();
    return {
      x: (event.clientX - rect.left) / rect.width * 2 - 1,
      y: -(event.clientY - rect.top) / rect.height * 2 + 1,
      button: event.button
    };
  }
}
function onPointerHover(event) {
  if (!this.enabled)
    return;
  switch (event.pointerType) {
    case "mouse":
    case "pen":
      this.pointerHover(this._getPointer(event));
      break;
  }
}
function onPointerDown(event) {
  if (!this.enabled)
    return;
  if (!document.pointerLockElement) {
    this.domElement.setPointerCapture(event.pointerId);
  }
  this.domElement.addEventListener("pointermove", this._onPointerMove);
  this.pointerHover(this._getPointer(event));
  this.pointerDown(this._getPointer(event));
}
function onPointerMove(event) {
  if (!this.enabled)
    return;
  this.pointerMove(this._getPointer(event));
}
function onPointerUp(event) {
  if (!this.enabled)
    return;
  this.domElement.releasePointerCapture(event.pointerId);
  this.domElement.removeEventListener("pointermove", this._onPointerMove);
  this.pointerUp(this._getPointer(event));
}
function intersectObjectWithRay(object, raycaster, includeInvisible) {
  const allIntersections = raycaster.intersectObject(object, true);
  for (let i = 0; i < allIntersections.length; i++) {
    if (allIntersections[i].object.visible || includeInvisible) {
      return allIntersections[i];
    }
  }
  return false;
}
var _tempEuler = new Euler();
var _alignVector = new Vector32(0, 1, 0);
var _zeroVector = new Vector32(0, 0, 0);
var _lookAtMatrix = new Matrix4();
var _tempQuaternion2 = new Quaternion();
var _identityQuaternion = new Quaternion();
var _dirVector = new Vector32();
var _tempMatrix = new Matrix4();
var _unitX = new Vector32(1, 0, 0);
var _unitY = new Vector32(0, 1, 0);
var _unitZ = new Vector32(0, 0, 1);
var _v1 = new Vector32();
var _v2 = new Vector32();
var _v3 = new Vector32();
var TransformControlsRoot = class extends Object3D {
  constructor(controls) {
    super();
    this.isTransformControlsRoot = true;
    this.controls = controls;
    this.visible = false;
  }
  // updateMatrixWorld updates key transformation variables
  updateMatrixWorld(force) {
    const controls = this.controls;
    if (controls.object !== void 0) {
      controls.object.updateMatrixWorld();
      if (controls.object.parent === null) {
        console.error("TransformControls: The attached 3D object must be a part of the scene graph.");
      } else {
        controls.object.parent.matrixWorld.decompose(controls._parentPosition, controls._parentQuaternion, controls._parentScale);
      }
      controls.object.matrixWorld.decompose(controls.worldPosition, controls.worldQuaternion, controls._worldScale);
      controls._parentQuaternionInv.copy(controls._parentQuaternion).invert();
      controls._worldQuaternionInv.copy(controls.worldQuaternion).invert();
    }
    controls.camera.updateMatrixWorld();
    controls.camera.matrixWorld.decompose(controls.cameraPosition, controls.cameraQuaternion, controls._cameraScale);
    if (controls.camera.isOrthographicCamera) {
      controls.camera.getWorldDirection(controls.eye).negate();
    } else {
      controls.eye.copy(controls.cameraPosition).sub(controls.worldPosition).normalize();
    }
    super.updateMatrixWorld(force);
  }
};
var TransformControlsGizmo = class extends Object3D {
  constructor() {
    super();
    this.isTransformControlsGizmo = true;
    this.type = "TransformControlsGizmo";
    const gizmoMaterial = new MeshBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    });
    const gizmoLineMaterial = new LineBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    });
    const matInvisible = gizmoMaterial.clone();
    matInvisible.opacity = 0.15;
    const matHelper = gizmoLineMaterial.clone();
    matHelper.opacity = 0.5;
    const matRed = gizmoMaterial.clone();
    matRed.color.setHex(16711680);
    const matGreen = gizmoMaterial.clone();
    matGreen.color.setHex(65280);
    const matBlue = gizmoMaterial.clone();
    matBlue.color.setHex(255);
    const matRedTransparent = gizmoMaterial.clone();
    matRedTransparent.color.setHex(16711680);
    matRedTransparent.opacity = 0.5;
    const matGreenTransparent = gizmoMaterial.clone();
    matGreenTransparent.color.setHex(65280);
    matGreenTransparent.opacity = 0.5;
    const matBlueTransparent = gizmoMaterial.clone();
    matBlueTransparent.color.setHex(255);
    matBlueTransparent.opacity = 0.5;
    const matWhiteTransparent = gizmoMaterial.clone();
    matWhiteTransparent.opacity = 0.25;
    const matYellowTransparent = gizmoMaterial.clone();
    matYellowTransparent.color.setHex(16776960);
    matYellowTransparent.opacity = 0.25;
    const matYellow = gizmoMaterial.clone();
    matYellow.color.setHex(16776960);
    const matGray = gizmoMaterial.clone();
    matGray.color.setHex(7895160);
    const arrowGeometry = new CylinderGeometry(0, 0.04, 0.1, 12);
    arrowGeometry.translate(0, 0.05, 0);
    const scaleHandleGeometry = new BoxGeometry(0.08, 0.08, 0.08);
    scaleHandleGeometry.translate(0, 0.04, 0);
    const lineGeometry = new BufferGeometry();
    lineGeometry.setAttribute("position", new Float32BufferAttribute2([0, 0, 0, 1, 0, 0], 3));
    const lineGeometry2 = new CylinderGeometry(75e-4, 75e-4, 0.5, 3);
    lineGeometry2.translate(0, 0.25, 0);
    function CircleGeometry(radius, arc) {
      const geometry = new TorusGeometry(radius, 75e-4, 3, 64, arc * Math.PI * 2);
      geometry.rotateY(Math.PI / 2);
      geometry.rotateX(Math.PI / 2);
      return geometry;
    }
    function TranslateHelperGeometry() {
      const geometry = new BufferGeometry();
      geometry.setAttribute("position", new Float32BufferAttribute2([0, 0, 0, 1, 1, 1], 3));
      return geometry;
    }
    const gizmoTranslate = {
      X: [
        [new Mesh(arrowGeometry, matRed), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(arrowGeometry, matRed), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new Mesh(lineGeometry2, matRed), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(arrowGeometry, matGreen), [0, 0.5, 0]],
        [new Mesh(arrowGeometry, matGreen), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new Mesh(lineGeometry2, matGreen)]
      ],
      Z: [
        [new Mesh(arrowGeometry, matBlue), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(arrowGeometry, matBlue), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new Mesh(lineGeometry2, matBlue), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.1, 0), matWhiteTransparent.clone()), [0, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matBlueTransparent.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matRedTransparent.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matGreenTransparent.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    };
    const pickerTranslate = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.2, 0), matInvisible)]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    };
    const helperTranslate = {
      START: [
        [new Mesh(new OctahedronGeometry(0.01, 2), matHelper), null, null, null, "helper"]
      ],
      END: [
        [new Mesh(new OctahedronGeometry(0.01, 2), matHelper), null, null, null, "helper"]
      ],
      DELTA: [
        [new Line(TranslateHelperGeometry(), matHelper), null, null, null, "helper"]
      ],
      X: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(lineGeometry, matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(lineGeometry, matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    const gizmoRotate = {
      XYZE: [
        [new Mesh(CircleGeometry(0.5, 1), matGray), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new Mesh(CircleGeometry(0.5, 0.5), matRed)]
      ],
      Y: [
        [new Mesh(CircleGeometry(0.5, 0.5), matGreen), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new Mesh(CircleGeometry(0.5, 0.5), matBlue), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new Mesh(CircleGeometry(0.75, 1), matYellowTransparent), null, [0, Math.PI / 2, 0]]
      ]
    };
    const helperRotate = {
      AXIS: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    };
    const pickerRotate = {
      XYZE: [
        [new Mesh(new SphereGeometry(0.25, 10, 8), matInvisible)]
      ],
      X: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new Mesh(new TorusGeometry(0.75, 0.1, 2, 24), matInvisible)]
      ]
    };
    const gizmoScale = {
      X: [
        [new Mesh(scaleHandleGeometry, matRed), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(lineGeometry2, matRed), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(scaleHandleGeometry, matRed), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(scaleHandleGeometry, matGreen), [0, 0.5, 0]],
        [new Mesh(lineGeometry2, matGreen)],
        [new Mesh(scaleHandleGeometry, matGreen), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(scaleHandleGeometry, matBlue), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(lineGeometry2, matBlue), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new Mesh(scaleHandleGeometry, matBlue), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matBlueTransparent), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matRedTransparent), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matGreenTransparent), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.1, 0.1, 0.1), matWhiteTransparent.clone())]
      ]
    };
    const pickerScale = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.2), matInvisible), [0, 0, 0]]
      ]
    };
    const helperScale = {
      X: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(lineGeometry, matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(lineGeometry, matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function setupGizmo(gizmoMap) {
      const gizmo = new Object3D();
      for (const name in gizmoMap) {
        for (let i = gizmoMap[name].length; i--; ) {
          const object = gizmoMap[name][i][0].clone();
          const position = gizmoMap[name][i][1];
          const rotation = gizmoMap[name][i][2];
          const scale = gizmoMap[name][i][3];
          const tag = gizmoMap[name][i][4];
          object.name = name;
          object.tag = tag;
          if (position) {
            object.position.set(position[0], position[1], position[2]);
          }
          if (rotation) {
            object.rotation.set(rotation[0], rotation[1], rotation[2]);
          }
          if (scale) {
            object.scale.set(scale[0], scale[1], scale[2]);
          }
          object.updateMatrix();
          const tempGeometry = object.geometry.clone();
          tempGeometry.applyMatrix4(object.matrix);
          object.geometry = tempGeometry;
          object.renderOrder = Infinity;
          object.position.set(0, 0, 0);
          object.rotation.set(0, 0, 0);
          object.scale.set(1, 1, 1);
          gizmo.add(object);
        }
      }
      return gizmo;
    }
    this.gizmo = {};
    this.picker = {};
    this.helper = {};
    this.add(this.gizmo["translate"] = setupGizmo(gizmoTranslate));
    this.add(this.gizmo["rotate"] = setupGizmo(gizmoRotate));
    this.add(this.gizmo["scale"] = setupGizmo(gizmoScale));
    this.add(this.picker["translate"] = setupGizmo(pickerTranslate));
    this.add(this.picker["rotate"] = setupGizmo(pickerRotate));
    this.add(this.picker["scale"] = setupGizmo(pickerScale));
    this.add(this.helper["translate"] = setupGizmo(helperTranslate));
    this.add(this.helper["rotate"] = setupGizmo(helperRotate));
    this.add(this.helper["scale"] = setupGizmo(helperScale));
    this.picker["translate"].visible = false;
    this.picker["rotate"].visible = false;
    this.picker["scale"].visible = false;
  }
  // updateMatrixWorld will update transformations and appearance of individual handles
  updateMatrixWorld(force) {
    const space = this.mode === "scale" ? "local" : this.space;
    const quaternion = space === "local" ? this.worldQuaternion : _identityQuaternion;
    this.gizmo["translate"].visible = this.mode === "translate";
    this.gizmo["rotate"].visible = this.mode === "rotate";
    this.gizmo["scale"].visible = this.mode === "scale";
    this.helper["translate"].visible = this.mode === "translate";
    this.helper["rotate"].visible = this.mode === "rotate";
    this.helper["scale"].visible = this.mode === "scale";
    let handles = [];
    handles = handles.concat(this.picker[this.mode].children);
    handles = handles.concat(this.gizmo[this.mode].children);
    handles = handles.concat(this.helper[this.mode].children);
    for (let i = 0; i < handles.length; i++) {
      const handle = handles[i];
      handle.visible = true;
      handle.rotation.set(0, 0, 0);
      handle.position.copy(this.worldPosition);
      let factor;
      if (this.camera.isOrthographicCamera) {
        factor = (this.camera.top - this.camera.bottom) / this.camera.zoom;
      } else {
        factor = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7);
      }
      handle.scale.set(1, 1, 1).multiplyScalar(factor * this.size / 4);
      if (handle.tag === "helper") {
        handle.visible = false;
        if (handle.name === "AXIS") {
          handle.visible = !!this.axis;
          if (this.axis === "X") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, 0, 0));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "Y") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, 0, Math.PI / 2));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "Z") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "XYZE") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0));
            _alignVector.copy(this.rotationAxis);
            handle.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(_zeroVector, _alignVector, _unitY));
            handle.quaternion.multiply(_tempQuaternion);
            handle.visible = this.dragging;
          }
          if (this.axis === "E") {
            handle.visible = false;
          }
        } else if (handle.name === "START") {
          handle.position.copy(this.worldPositionStart);
          handle.visible = this.dragging;
        } else if (handle.name === "END") {
          handle.position.copy(this.worldPosition);
          handle.visible = this.dragging;
        } else if (handle.name === "DELTA") {
          handle.position.copy(this.worldPositionStart);
          handle.quaternion.copy(this.worldQuaternionStart);
          _tempVector.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1);
          _tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert());
          handle.scale.copy(_tempVector);
          handle.visible = this.dragging;
        } else {
          handle.quaternion.copy(quaternion);
          if (this.dragging) {
            handle.position.copy(this.worldPositionStart);
          } else {
            handle.position.copy(this.worldPosition);
          }
          if (this.axis) {
            handle.visible = this.axis.search(handle.name) !== -1;
          }
        }
        continue;
      }
      handle.quaternion.copy(quaternion);
      if (this.mode === "translate" || this.mode === "scale") {
        const AXIS_HIDE_THRESHOLD = 0.99;
        const PLANE_HIDE_THRESHOLD = 0.2;
        if (handle.name === "X") {
          if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "Y") {
          if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "Z") {
          if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "XY") {
          if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "YZ") {
          if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "XZ") {
          if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
      } else if (this.mode === "rotate") {
        _tempQuaternion2.copy(quaternion);
        _alignVector.copy(this.eye).applyQuaternion(_tempQuaternion.copy(quaternion).invert());
        if (handle.name.search("E") !== -1) {
          handle.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(this.eye, _zeroVector, _unitY));
        }
        if (handle.name === "X") {
          _tempQuaternion.setFromAxisAngle(_unitX, Math.atan2(-_alignVector.y, _alignVector.z));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
        if (handle.name === "Y") {
          _tempQuaternion.setFromAxisAngle(_unitY, Math.atan2(_alignVector.x, _alignVector.z));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
        if (handle.name === "Z") {
          _tempQuaternion.setFromAxisAngle(_unitZ, Math.atan2(_alignVector.y, _alignVector.x));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
      }
      handle.visible = handle.visible && (handle.name.indexOf("X") === -1 || this.showX);
      handle.visible = handle.visible && (handle.name.indexOf("Y") === -1 || this.showY);
      handle.visible = handle.visible && (handle.name.indexOf("Z") === -1 || this.showZ);
      handle.visible = handle.visible && (handle.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ);
      handle.material._color = handle.material._color || handle.material.color.clone();
      handle.material._opacity = handle.material._opacity || handle.material.opacity;
      handle.material.color.copy(handle.material._color);
      handle.material.opacity = handle.material._opacity;
      if (this.enabled && this.axis) {
        if (handle.name === this.axis) {
          handle.material.color.setHex(16776960);
          handle.material.opacity = 1;
        } else if (this.axis.split("").some(function(a) {
          return handle.name === a;
        })) {
          handle.material.color.setHex(16776960);
          handle.material.opacity = 1;
        }
      }
    }
    super.updateMatrixWorld(force);
  }
};
var TransformControlsPlane = class extends Mesh {
  constructor() {
    super(
      new PlaneGeometry(1e5, 1e5, 2, 2),
      new MeshBasicMaterial({ visible: false, wireframe: true, side: DoubleSide, transparent: true, opacity: 0.1, toneMapped: false })
    );
    this.isTransformControlsPlane = true;
    this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(force) {
    let space = this.space;
    this.position.copy(this.worldPosition);
    if (this.mode === "scale")
      space = "local";
    _v1.copy(_unitX).applyQuaternion(space === "local" ? this.worldQuaternion : _identityQuaternion);
    _v2.copy(_unitY).applyQuaternion(space === "local" ? this.worldQuaternion : _identityQuaternion);
    _v3.copy(_unitZ).applyQuaternion(space === "local" ? this.worldQuaternion : _identityQuaternion);
    _alignVector.copy(_v2);
    switch (this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            _alignVector.copy(this.eye).cross(_v1);
            _dirVector.copy(_v1).cross(_alignVector);
            break;
          case "Y":
            _alignVector.copy(this.eye).cross(_v2);
            _dirVector.copy(_v2).cross(_alignVector);
            break;
          case "Z":
            _alignVector.copy(this.eye).cross(_v3);
            _dirVector.copy(_v3).cross(_alignVector);
            break;
          case "XY":
            _dirVector.copy(_v3);
            break;
          case "YZ":
            _dirVector.copy(_v1);
            break;
          case "XZ":
            _alignVector.copy(_v3);
            _dirVector.copy(_v2);
            break;
          case "XYZ":
          case "E":
            _dirVector.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        _dirVector.set(0, 0, 0);
    }
    if (_dirVector.length() === 0) {
      this.quaternion.copy(this.cameraQuaternion);
    } else {
      _tempMatrix.lookAt(_tempVector.set(0, 0, 0), _dirVector, _alignVector);
      this.quaternion.setFromRotationMatrix(_tempMatrix);
    }
    super.updateMatrixWorld(force);
  }
};

// node_modules/@needle-tools/engine/lib/engine/engine_components.js
var debug20 = getParam("debuggetcomponent");
var debugEnabled = () => {
  return debug20 || globalThis["NEEDLE_DEBUG_GETCOMPONENT"] === true;
};
function tryGetObject(obj) {
  if (obj === null || obj === void 0)
    return obj;
  if (obj.isObject3D)
    return obj;
  if (obj.object && obj.object.isObject3D)
    return obj.object;
  return obj;
}
function removeComponent(go, componentInstance) {
  if (!go)
    return componentInstance;
  if (!go.userData.components)
    return componentInstance;
  const index = go.userData.components.indexOf(componentInstance);
  if (index < 0)
    return componentInstance;
  ComponentLifecycleEvents.dispatchComponentLifecycleEvent("removing-component", componentInstance);
  componentInstance.gameObject = null;
  go.userData.components.splice(index, 1);
  return componentInstance;
}
function getOrAddComponent(go, typeName, init) {
  const comp = getComponent(go, typeName);
  if (comp)
    return comp;
  return addComponent(go, typeName, init);
}
var idProvider = new InstantiateIdProvider("addComponentIdProvider");
function addNewComponent(obj, componentInstance, callAwake = true) {
  if (!obj) {
    new Error("Can not add componet to null object");
  }
  if (!obj.userData)
    obj.userData = {};
  if (!obj.userData.components)
    obj.userData.components = [];
  obj.userData.components.push(componentInstance);
  componentInstance.gameObject = obj;
  if (componentInstance.guid === void 0 || componentInstance.guid === "invalid") {
    componentInstance.guid = idProvider.generateUUID();
  }
  apply(obj);
  registerComponent(componentInstance, componentInstance.context);
  try {
    if (callAwake && componentInstance.__internalAwake) {
      updateActiveInHierarchyWithoutEventCall(obj);
      if (componentInstance.activeAndEnabled)
        componentInstance.__internalAwake();
    }
    ComponentLifecycleEvents.dispatchComponentLifecycleEvent("component-added", componentInstance);
  } catch (err) {
    console.error(err);
  }
  return componentInstance;
}
function addComponent(obj, componentInstance, init, opts) {
  if (typeof componentInstance === "function") {
    const instance = new componentInstance();
    if (init)
      instance.__internalNewInstanceCreated(init);
    let callAwake = true;
    if ((opts == null ? void 0 : opts.callAwake) != void 0)
      callAwake = opts.callAwake;
    return addNewComponent(obj, instance, callAwake);
  }
  if (componentInstance.destroyed) {
    console.warn("Can not move/add a destroyed component", componentInstance);
    return componentInstance;
  }
  if (componentInstance.gameObject === obj)
    return componentInstance;
  if (componentInstance.gameObject && componentInstance.gameObject.userData.components) {
    const index = componentInstance.gameObject.userData.components.indexOf(componentInstance);
    componentInstance.gameObject.userData.components.splice(index, 1);
  }
  if (!obj.userData.components)
    obj.userData.components = [];
  else if (obj.userData.components.includes(componentInstance))
    return componentInstance;
  obj.userData.components.push(componentInstance);
  componentInstance.gameObject = obj;
  if (componentInstance.guid === void 0 || componentInstance.guid === "invalid") {
    componentInstance.guid = idProvider.generateUUID();
  }
  if (init)
    componentInstance._internalInit(init);
  registerComponent(componentInstance, componentInstance.context);
  return componentInstance;
}
function destroyComponentInstance(componentInstance) {
  if (componentInstance.gameObject && componentInstance.gameObject.userData.components) {
    const index = componentInstance.gameObject.userData.components.indexOf(componentInstance);
    componentInstance.gameObject.userData.components.splice(index, 1);
  }
  if (componentInstance.__internalDisable)
    componentInstance.__internalDisable();
  removeScriptFromContext(componentInstance, componentInstance.context ?? Context.Current);
  componentInstance.destroy();
  componentInstance.gameObject = null;
}
var didWarnAboutComponentAccess = false;
function onGetComponent(obj, componentType, arr) {
  var _a2;
  if (obj === null || obj === void 0)
    return null;
  if (!obj.isObject3D) {
    console.error("Object is not object3D");
    return null;
  }
  if (!((_a2 = obj == null ? void 0 : obj.userData) == null ? void 0 : _a2.components))
    return null;
  if (typeof componentType === "string") {
    if (!didWarnAboutComponentAccess) {
      didWarnAboutComponentAccess = true;
      console.warn(`Accessing components by name is not supported.
Please use the component type instead. This may keep working in local development but it will fail when bundling your application.

You can import other modules your main module to get access to types
or if you use npmdefs you can make types available globally using globalThis:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis`, componentType);
    }
  }
  if (debugEnabled())
    console.log("[onGetComponent] FIND", componentType);
  if (componentType === void 0 || componentType === null)
    return null;
  for (let i = 0; i < obj.userData.components.length; i++) {
    const component = obj.userData.components[i];
    let prototype = Object.getPrototypeOf(component);
    while (prototype) {
      if (prototype === componentType.prototype) {
        if (debugEnabled())
          console.log("[onGetComponent] MATCH BY PROTOYPE", prototype);
        if (arr)
          arr.push(component);
        else
          return component;
      }
      prototype = Object.getPrototypeOf(prototype);
    }
  }
  if (!arr)
    return null;
  return arr;
}
function getComponent(obj, componentType) {
  const result = onGetComponent(obj, componentType);
  if (!result)
    return null;
  if (Array.isArray(result))
    return result[0];
  return result;
}
function getComponents(obj, componentType, arr, clearArray = true) {
  if (!arr)
    arr = [];
  if (clearArray)
    arr.length = 0;
  onGetComponent(obj, componentType, arr);
  return arr;
}
function getComponentInChildren(obj, componentType, includeInactive) {
  var _a2;
  const res = getComponent(obj, componentType);
  if (includeInactive === false && (res == null ? void 0 : res.enabled) === false)
    return null;
  if (res)
    return res;
  for (let i = 0; i < ((_a2 = obj == null ? void 0 : obj.children) == null ? void 0 : _a2.length); i++) {
    const res2 = getComponentInChildren(obj.children[i], componentType);
    if (res2)
      return res2;
  }
  return null;
}
function getComponentsInChildren(obj, componentType, arr, clearArray = true) {
  var _a2;
  if (!arr)
    arr = [];
  if (clearArray)
    arr.length = 0;
  getComponents(obj, componentType, arr, false);
  for (let i = 0; i < ((_a2 = obj == null ? void 0 : obj.children) == null ? void 0 : _a2.length); i++) {
    getComponentsInChildren(obj.children[i], componentType, arr, false);
  }
  return arr;
}
function getComponentInParent(obj, componentType) {
  if (!obj)
    return null;
  if (Array.isArray(obj)) {
    for (let i = 0; i < obj.length; i++) {
      const o = tryGetObject(obj[i]);
      const res2 = getComponentInParent(o, componentType);
      if (res2)
        return res2;
    }
    return null;
  }
  const res = getComponent(obj, componentType);
  if (res)
    return res;
  if (obj.parent)
    return getComponentInParent(obj.parent, componentType);
  return null;
}
function getComponentsInParent(obj, componentType, arr, clearArray = true) {
  if (!arr)
    arr = [];
  if (clearArray)
    arr.length = 0;
  if (!obj)
    return arr;
  getComponents(obj, componentType, arr, false);
  if (obj.parent)
    return getComponentsInParent(obj.parent, componentType, arr, false);
  return arr;
}
function findObjectOfType(type, contextOrScene = void 0, includeInactive = true) {
  if (!type)
    return null;
  if (!contextOrScene) {
    contextOrScene = Context.Current;
    if (!contextOrScene) {
      console.error("Can not search object without any needle context or scene!!!");
      return null;
    }
  }
  let scene = contextOrScene;
  if (!scene.isScene)
    scene = contextOrScene == null ? void 0 : contextOrScene.scene;
  if (!scene)
    return null;
  for (const i in scene.children) {
    const child = scene.children[i];
    if (includeInactive === false && child[activeInHierarchyFieldName] === false)
      continue;
    const res = getComponentInChildren(child, type);
    if (res)
      return res;
  }
  return null;
}
function findObjectsOfType(type, array, contextOrScene = void 0) {
  if (!type)
    return array ?? [];
  if (!array)
    array = [];
  array.length = 0;
  if (!contextOrScene) {
    contextOrScene = Context.Current;
    if (!contextOrScene) {
      console.error("Can not search object without any needle context or scene!!!");
      return array;
    }
  }
  if ("scene" in contextOrScene)
    contextOrScene = contextOrScene.scene;
  const scene = contextOrScene;
  if (!scene)
    return array;
  for (const i in scene.children) {
    const child = scene.children[i];
    getComponentsInChildren(child, type, array, false);
  }
  return array;
}

// node_modules/@needle-tools/engine/lib/engine/js-extensions/Object3D.js
function apply(object) {
  if (object && object.isObject3D === true) {
    applyPrototypeExtensions(object, Object3D);
  }
}
Object3D.prototype["SetActive"] = function(active) {
  this.visible = active;
};
Object3D.prototype["setActive"] = function(active) {
  this.visible = active;
};
Object3D.prototype["destroy"] = function() {
  destroy(this);
};
Object3D.prototype["addComponent"] = function(comp, init) {
  return addComponent(this, comp, init);
};
Object3D.prototype["addNewComponent"] = function(type, init) {
  return addComponent(this, type, init);
};
Object3D.prototype["removeComponent"] = function(inst) {
  return removeComponent(this, inst);
};
Object3D.prototype["getOrAddComponent"] = function(typeName, init) {
  return getOrAddComponent(this, typeName, init);
};
Object3D.prototype["getComponent"] = function(type) {
  return getComponent(this, type);
};
Object3D.prototype["getComponents"] = function(type, arr) {
  return getComponents(this, type, arr);
};
Object3D.prototype["getComponentInChildren"] = function(type) {
  return getComponentInChildren(this, type);
};
Object3D.prototype["getComponentsInChildren"] = function(type, arr) {
  return getComponentsInChildren(this, type, arr);
};
Object3D.prototype["getComponentInParent"] = function(type) {
  return getComponentInParent(this, type);
};
Object3D.prototype["getComponentsInParent"] = function(type, arr) {
  return getComponentsInParent(this, type, arr);
};
if (!Object.getOwnPropertyDescriptor(Object3D.prototype, "activeSelf")) {
  Object.defineProperty(Object3D.prototype, "activeSelf", {
    get: function() {
      return isActiveSelf(this);
    },
    set: function(val) {
      setActive(this, val);
    }
  });
}
if (!Object.getOwnPropertyDescriptor(Object3D.prototype, "worldPosition")) {
  Object.defineProperty(Object3D.prototype, "worldPosition", {
    get: function() {
      if (this instanceof TransformControlsGizmo) {
        return getWorldPosition(this["object"]);
      }
      return getWorldPosition(this);
    },
    set: function(val) {
      setWorldPosition(this, val);
    }
  });
}
if (!Object.getOwnPropertyDescriptor(Object3D.prototype, "worldQuaternion")) {
  Object.defineProperty(Object3D.prototype, "worldQuaternion", {
    get: function() {
      if (this instanceof TransformControlsGizmo) {
        return getWorldQuaternion(this["object"]);
      }
      return getWorldQuaternion(this);
    },
    set: function(val) {
      setWorldQuaternion(this, val);
    }
  });
}
if (!Object.getOwnPropertyDescriptor(Object3D.prototype, "worldRotation")) {
  Object.defineProperty(Object3D.prototype, "worldRotation", {
    get: function() {
      return getWorldRotation(this);
    },
    set: function(val) {
      setWorldRotation(this, val);
    }
  });
}
if (!Object.getOwnPropertyDescriptor(Object3D.prototype, "worldScale")) {
  Object.defineProperty(Object3D.prototype, "worldScale", {
    get: function() {
      return getWorldScale(this);
    },
    set: function(val) {
      setWorldScale(this, val);
    }
  });
}
if (!Object.getOwnPropertyDescriptor(Object3D.prototype, "worldForward")) {
  Object.defineProperty(Object3D.prototype, "worldForward", {
    get: function() {
      return getTempVector().set(0, 0, 1).applyQuaternion(getWorldQuaternion(this));
    }
  });
}
if (!Object.getOwnPropertyDescriptor(Object3D.prototype, "worldRight")) {
  Object.defineProperty(Object3D.prototype, "worldRight", {
    get: function() {
      return getTempVector().set(1, 0, 0).applyQuaternion(getWorldQuaternion(this));
    }
  });
}
if (!Object.getOwnPropertyDescriptor(Object3D.prototype, "worldUp")) {
  Object.defineProperty(Object3D.prototype, "worldUp", {
    get: function() {
      return getTempVector().set(0, 1, 0).applyQuaternion(getWorldQuaternion(this));
    }
  });
}
registerPrototypeExtensions(Object3D);

// node_modules/@needle-tools/engine/lib/engine/js-extensions/RGBAColor.js
var RGBAColor = class extends Color {
  constructor(r, g3, b, a) {
    var __super = (...args) => {
      super(...args);
      __publicField(this, "alpha", 1);
    };
    if (g3 != void 0 && b != void 0) {
      __super(r, g3, b);
      this.alpha = a;
    } else {
      __super(r);
      this.alpha = 1;
    }
  }
  get isRGBAColor() {
    return true;
  }
  set a(val) {
    this.alpha = val;
  }
  get a() {
    return this.alpha;
  }
  clone() {
    const cloned = super.clone();
    cloned.alpha = this.alpha;
    return cloned;
  }
  copy(col2) {
    this.r = col2.r;
    this.g = col2.g;
    this.b = col2.b;
    if ("alpha" in col2 && typeof col2.alpha === "number") {
      this.alpha = col2.alpha;
    } else if (typeof col2["a"] === "number")
      this.alpha = col2["a"];
    return this;
  }
  lerp(color2, alpha) {
    const rgba = color2;
    if (rgba.alpha != void 0)
      this.alpha = Mathf.lerp(this.alpha, rgba.alpha, alpha);
    return super.lerp(color2, alpha);
  }
  lerpColors(color1, color2, alpha) {
    const rgba1 = color1;
    const rgba2 = color2;
    if (rgba1.alpha != void 0 && rgba2.alpha != void 0)
      this.alpha = Mathf.lerp(rgba1.alpha, rgba2.alpha, alpha);
    return super.lerpColors(color1, color2, alpha);
  }
  multiply(color2) {
    const rgba = color2;
    if (rgba.alpha != void 0)
      this.alpha = this.alpha * rgba.alpha;
    return super.multiply(color2);
  }
  fromArray(array, offset = 0) {
    this.alpha = array[offset + 3];
    return super.fromArray(array, offset);
  }
};

// node_modules/@needle-tools/engine/lib/engine/engine_gameobject.js
var debug21 = getParam("debuggetcomponent");
var debugInstantiate = getParam("debuginstantiate");
var HideFlags;
(function(HideFlags2) {
  HideFlags2[HideFlags2["None"] = 0] = "None";
  HideFlags2[HideFlags2["HideInHierarchy"] = 1] = "HideInHierarchy";
  HideFlags2[HideFlags2["HideInInspector"] = 2] = "HideInInspector";
  HideFlags2[HideFlags2["DontSaveInEditor"] = 4] = "DontSaveInEditor";
  HideFlags2[HideFlags2["NotEditable"] = 8] = "NotEditable";
  HideFlags2[HideFlags2["DontSaveInBuild"] = 16] = "DontSaveInBuild";
  HideFlags2[HideFlags2["DontUnloadUnusedAsset"] = 32] = "DontUnloadUnusedAsset";
  HideFlags2[HideFlags2["DontSave"] = 52] = "DontSave";
  HideFlags2[HideFlags2["HideAndDontSave"] = 61] = "HideAndDontSave";
})(HideFlags || (HideFlags = {}));
var InstantiateOptions = class {
  constructor() {
    __publicField(this, "idProvider");
    __publicField(this, "parent");
    __publicField(this, "keepWorldPosition");
    __publicField(this, "position");
    __publicField(this, "rotation");
    __publicField(this, "scale");
    __publicField(this, "visible");
    __publicField(this, "context");
    __publicField(this, "components");
  }
  clone() {
    var _a2, _b, _c;
    const clone = new InstantiateOptions();
    clone.idProvider = this.idProvider;
    clone.parent = this.parent;
    clone.keepWorldPosition = this.keepWorldPosition;
    clone.position = (_a2 = this.position) == null ? void 0 : _a2.clone();
    clone.rotation = (_b = this.rotation) == null ? void 0 : _b.clone();
    clone.scale = (_c = this.scale) == null ? void 0 : _c.clone();
    clone.visible = this.visible;
    clone.context = this.context;
    clone.components = this.components;
    return clone;
  }
  /** Copy fields from another object, clone field references */
  cloneAssign(other) {
    var _a2, _b, _c;
    this.idProvider = other.idProvider;
    this.parent = other.parent;
    this.keepWorldPosition = other.keepWorldPosition;
    this.position = (_a2 = other.position) == null ? void 0 : _a2.clone();
    this.rotation = (_b = other.rotation) == null ? void 0 : _b.clone();
    this.scale = (_c = other.scale) == null ? void 0 : _c.clone();
    this.visible = other.visible;
    this.context = other.context;
    this.components = other.components;
  }
};
var $isActive = Symbol("isActive");
function isActiveSelf(go) {
  return go.visible;
}
function setActive(go, active) {
  if (typeof active === "number")
    active = active > 0.5;
  go.visible = active;
  return go.visible;
}
function isActiveInHierarchy(go) {
  return go[activeInHierarchyFieldName] || isUsingInstancing(go);
}
function markAsInstancedRendered(go, instanced) {
  go[$isUsingInstancing] = instanced;
}
function isUsingInstancing(instance) {
  return InstancingUtil.isUsingInstancing(instance);
}
function findByGuid(guid, hierarchy) {
  return tryFindObject(guid, hierarchy, true, true);
}
var $isDestroyed = Symbol("isDestroyed");
function isDestroyed(go) {
  return go[$isDestroyed];
}
function setDestroyed(go, value) {
  go[$isDestroyed] = value;
}
var $isDontDestroy = Symbol("isDontDestroy");
function setDontDestroy(instance, value = true) {
  instance[$isDontDestroy] = value;
}
var destroyed_components = [];
var destroyed_objects = [];
function destroy(instance, recursive = true, dispose = false) {
  destroyed_components.length = 0;
  destroyed_objects.length = 0;
  internalDestroy(instance, recursive, true);
  for (const comp of destroyed_components) {
    comp.gameObject = null;
    comp.context = null;
  }
  for (const obj of destroyed_objects) {
    setDestroyed(obj, true);
    if (dispose) {
      disposeObjectResources(obj);
    }
    __internalNotifyObjectDestroyed(obj);
  }
  destroyed_objects.length = 0;
  destroyed_components.length = 0;
}
function internalDestroy(instance, recursive = true, isRoot = true) {
  var _a2;
  if (instance === null || instance === void 0)
    return;
  const comp = instance;
  if (comp.isComponent) {
    if (comp[$isDontDestroy])
      return;
    destroyed_components.push(comp);
    const go = comp.gameObject;
    comp.__internalDisable();
    comp.__internalDestroy();
    comp.gameObject = go;
    return;
  }
  if (instance[$isDontDestroy])
    return;
  const obj = instance;
  if (debug21)
    console.log(obj);
  destroyed_objects.push(obj);
  const components = (_a2 = obj.userData) == null ? void 0 : _a2.components;
  if (components != null && Array.isArray(components)) {
    let lastLength = components.length;
    for (let i = 0; i < components.length; i++) {
      const comp2 = components[i];
      internalDestroy(comp2, recursive, false);
      if (components.length < lastLength) {
        lastLength = components.length;
        i--;
      }
    }
  }
  if (recursive && obj.children) {
    for (const ch of obj.children) {
      internalDestroy(ch, recursive, false);
    }
  }
  if (isRoot)
    obj.removeFromParent();
}
function foreachComponent(instance, cb, recursive = true) {
  return internalForEachComponent(instance, cb, recursive);
}
function* foreachComponentEnumerator(instance, type, includeChildren = false, maxLevel = 999, _currentLevel = 0) {
  if (!(instance == null ? void 0 : instance.userData.components))
    return;
  if (_currentLevel > maxLevel)
    return;
  for (const comp of instance.userData.components) {
    if (type && (comp == null ? void 0 : comp.isComponent) === true && comp instanceof type) {
      yield comp;
    } else {
      yield comp;
    }
  }
  if (includeChildren === true) {
    for (const ch of instance.children) {
      yield* foreachComponentEnumerator(ch, type, true, maxLevel, _currentLevel + 1);
    }
  }
}
function internalForEachComponent(instance, cb, recursive, level = 0) {
  var _a2;
  if (!instance)
    return;
  if (!instance.isObject3D) {
    new Error("Expected Object3D but got " + instance);
  }
  if (level > 1e3) {
    console.warn("Failed to iterate components: too many levels");
    return;
  }
  if ((_a2 = instance.userData) == null ? void 0 : _a2.components) {
    for (let i = 0; i < instance.userData.components.length; i++) {
      const comp = instance.userData.components[i];
      if ((comp == null ? void 0 : comp.isComponent) === true) {
        const res = cb(comp);
        if (res !== void 0)
          return res;
      }
    }
  }
  if (recursive && instance.children) {
    const nextLevel = level + 1;
    for (let i = 0; i < instance.children.length; i++) {
      const child = instance.children[i];
      if (!child)
        continue;
      const res = internalForEachComponent(child, cb, recursive, nextLevel);
      if (res !== void 0)
        return res;
    }
  }
}
function instantiate(instance, opts = null) {
  let options = null;
  if (opts !== null) {
    if (opts["x"] !== void 0) {
      options = new InstantiateOptions();
      options.position = opts;
    } else {
      options = opts;
    }
  }
  let context = Context.Current;
  if (options == null ? void 0 : options.context)
    context = options.context;
  if (debug21 && context.alias)
    console.log("context", context.alias);
  if (options && !options.idProvider) {
    options.idProvider = new InstantiateIdProvider(Date.now());
  }
  const components = [];
  const goMapping = {};
  const skinnedMeshes = {};
  const clone = internalInstantiate(context, instance, options, components, goMapping, skinnedMeshes);
  if (clone) {
    resolveReferences2(goMapping);
    resolveAndBindSkinnedMeshBones(skinnedMeshes, goMapping);
  }
  if (debug21) {
    logHierarchy(instance, true);
    logHierarchy(clone, true);
  }
  const guidsMap = {};
  if ((options == null ? void 0 : options.components) !== false) {
    for (const i in components) {
      const copy = components[i];
      const oldGuid = copy.guid;
      if (options && options.idProvider) {
        copy.guid = options.idProvider.generateUUID();
        guidsMap[oldGuid] = copy.guid;
        if (debug21)
          console.log(copy.name, copy.guid);
      }
      registerComponent(copy, context);
      if (copy.__internalNewInstanceCreated)
        copy.__internalNewInstanceCreated();
    }
    for (const i in components) {
      const copy = components[i];
      if (copy.resolveGuids)
        copy.resolveGuids(guidsMap);
      if (copy.enabled === false)
        continue;
      else
        copy.enabled = true;
    }
    processNewScripts(context);
  }
  return clone;
}
function internalInstantiate(context, instance, opts, componentsList, objectsMap, skinnedMeshesMap) {
  var _a2;
  if (!instance)
    return null;
  const userData = instance.userData;
  instance.userData = {};
  const children = instance.children;
  instance.children = [];
  const clone = instance.clone(false);
  apply(clone);
  instance.userData = userData;
  instance.children = children;
  objectsMap[instance.uuid] = { original: instance, clone };
  if (debugInstantiate)
    console.log("ADD", instance, clone);
  if (instance.type === "SkinnedMesh") {
    skinnedMeshesMap[instance.uuid] = { original: instance, clone };
  }
  if ((opts == null ? void 0 : opts.visible) !== void 0)
    clone.visible = opts.visible;
  if (opts == null ? void 0 : opts.idProvider) {
    clone.uuid = opts.idProvider.generateUUID();
    const cloneGo = clone;
    if (cloneGo)
      cloneGo.guid = clone.uuid;
  }
  if (instance.animations && instance.animations.length > 0) {
    clone.animations = [...instance.animations];
  }
  const parent = instance.parent;
  if (parent) {
    parent.add(clone);
  }
  if (opts == null ? void 0 : opts.position) {
    setWorldPosition(clone, opts.position);
  } else
    clone.position.copy(instance.position);
  if (opts == null ? void 0 : opts.rotation) {
    setWorldQuaternion(clone, opts.rotation);
  } else
    clone.quaternion.copy(instance.quaternion);
  if (opts == null ? void 0 : opts.scale) {
    clone.scale.copy(opts.scale);
  } else
    clone.scale.copy(instance.scale);
  if ((opts == null ? void 0 : opts.parent) && opts.parent !== "scene") {
    let requestedParent = null;
    if (typeof opts.parent === "string") {
      requestedParent = tryFindObject(opts.parent, context.scene, true);
    } else {
      requestedParent = opts.parent;
    }
    if (requestedParent) {
      const func = opts.keepWorldPosition === true ? requestedParent.attach : requestedParent.add;
      if (!func)
        console.error("Invalid parent object", requestedParent, "received when instantiating:", instance);
      else
        func.call(requestedParent, clone);
    } else
      console.warn("could not find parent:", opts.parent);
  }
  for (const [key, value] of Object.entries(instance.userData)) {
    if (key === "components")
      continue;
    clone.userData[key] = value;
  }
  if ((_a2 = instance.userData) == null ? void 0 : _a2.components) {
    const components = instance.userData.components;
    const newComponents = [];
    clone.userData.components = newComponents;
    for (let i = 0; i < components.length; i++) {
      const comp = components[i];
      const copy = new comp.constructor();
      assign(copy, comp);
      if (comp[editorGuidKeyName] !== void 0)
        copy[editorGuidKeyName] = comp[editorGuidKeyName];
      newComponents.push(copy);
      copy.gameObject = clone;
      componentsList.push(copy);
      objectsMap[comp.guid] = { original: comp, clone: copy };
      ComponentLifecycleEvents.dispatchComponentLifecycleEvent("component-added", copy);
    }
  }
  if (opts) {
    opts.position = void 0;
    opts.rotation = void 0;
    opts.scale = void 0;
    opts.parent = void 0;
  }
  for (const ch in instance.children) {
    const child = instance.children[ch];
    const newChild = internalInstantiate(context, child, opts, componentsList, objectsMap, skinnedMeshesMap);
    if (newChild)
      clone.add(newChild);
  }
  return clone;
}
function resolveAndBindSkinnedMeshBones(skinnedMeshes, newObjectsMap) {
  for (const key in skinnedMeshes) {
    const val = skinnedMeshes[key];
    const original = val.original;
    const originalSkeleton = original.skeleton;
    const clone = val.clone;
    if (!originalSkeleton) {
      console.warn("Skinned mesh has no skeleton?", val);
      continue;
    }
    const originalBones = originalSkeleton.bones;
    const clonedSkeleton = clone.skeleton.clone();
    clone.skeleton = clonedSkeleton;
    clone.bindMatrix.clone().copy(original.bindMatrix);
    clone.bindMatrixInverse.copy(original.bindMatrixInverse);
    const bones = [];
    clonedSkeleton.bones = bones;
    for (let i = 0; i < originalBones.length; i++) {
      const bone = originalBones[i];
      const newBoneInfo = newObjectsMap[bone.uuid];
      const clonedBone = newBoneInfo.clone;
      bones.push(clonedBone);
    }
  }
  for (const key in skinnedMeshes) {
    const clone = skinnedMeshes[key].clone;
    clone.skeleton.update();
    clone.bind(clone.skeleton, clone.bindMatrix);
    clone.updateMatrixWorld(true);
  }
}
function resolveReferences2(newObjectsMap) {
  var _a2;
  for (const key in newObjectsMap) {
    const val = newObjectsMap[key];
    const clone = val.clone;
    if ((clone == null ? void 0 : clone.isObject3D) && ((_a2 = clone == null ? void 0 : clone.userData) == null ? void 0 : _a2.components)) {
      for (let i = 0; i < clone.userData.components.length; i++) {
        const copy = clone.userData.components[i];
        const entries = Object.entries(copy);
        for (const [key2, value] of entries) {
          if (Array.isArray(value)) {
            const clonedArray = [];
            copy[key2] = clonedArray;
            for (let i2 = 0; i2 < value.length; i2++) {
              const entry = value[i2];
              if (typeof entry !== "object") {
                clonedArray.push(entry);
                continue;
              }
              const res = postProcessNewInstance(copy, key2, entry, newObjectsMap);
              if (res !== void 0)
                clonedArray.push(res);
              else
                clonedArray.push(entry);
            }
          } else if (typeof value === "object") {
            const res = postProcessNewInstance(copy, key2, value, newObjectsMap);
            if (res !== void 0) {
              copy[key2] = res;
            }
          }
        }
      }
    }
  }
}
function postProcessNewInstance(copy, key, value, newObjectsMap) {
  var _a2, _b;
  if (value === null || value === void 0)
    return;
  if (value.isComponent === true) {
    const originalGameObjectReference = value["gameObject"];
    if (originalGameObjectReference) {
      const id = originalGameObjectReference.uuid;
      const newGameObject = (_a2 = newObjectsMap[id]) == null ? void 0 : _a2.clone;
      if (!newGameObject) {
        if (debugInstantiate)
          console.log("reference did not change", key, copy, value);
        return;
      }
      const index = originalGameObjectReference.userData.components.indexOf(value);
      if (index >= 0 && newGameObject.isObject3D) {
        if (debugInstantiate)
          console.log(key, id);
        const found = newGameObject.userData.components[index];
        return found;
      } else {
        console.warn("could not find component", key, value);
      }
    }
  } else if (value.isObject3D === true) {
    if (key === "gameObject")
      return;
    const originalGameObjectReference = value;
    if (originalGameObjectReference) {
      const id = originalGameObjectReference.uuid;
      const newGameObject = (_b = newObjectsMap[id]) == null ? void 0 : _b.clone;
      if (newGameObject) {
        if (debugInstantiate)
          console.log(key, "old", value, "new", newGameObject);
        return newGameObject;
      }
    }
  } else {
    if (value.isVector4 || value.isVector3 || value.isVector2 || value.isQuaternion || value.isEuler) {
      return value.clone();
    } else if (value.isColor === true) {
      return value.clone();
    } else if (value.isEventList === true) {
      const copy2 = value.__internalOnInstantiate(newObjectsMap);
      return copy2;
    }
  }
}

// node_modules/@needle-tools/engine/lib/engine/engine_networking_blob.js
var import_md52 = __toESM(require_md5(), 1);
var BlobStorage;
(function(BlobStorage2) {
  const maxSizeInMB = 50;
  const maxFreeSizeInMB = 5;
  BlobStorage2.baseUrl = "https://networking.needle.tools";
  function hashMD5(buffer2) {
    return (0, import_md52.default)(new Uint8Array(buffer2));
  }
  BlobStorage2.hashMD5 = hashMD5;
  function hashMD5_Base64(buffer2) {
    const bytes = (0, import_md52.default)(new Uint8Array(buffer2), { encoding: "binary", asBytes: true });
    return btoa(String.fromCharCode(...bytes));
  }
  BlobStorage2.hashMD5_Base64 = hashMD5_Base64;
  function hashSha256(buffer2) {
    const bytes = new Uint8Array(buffer2);
    const hash = crypto.subtle.digest("SHA-256", bytes).then((res) => {
      return btoa(String.fromCharCode(...new Uint8Array(res)));
    });
    return hash;
  }
  BlobStorage2.hashSha256 = hashSha256;
  function canUpload(info) {
    const sizeInMB = info.filesize / 1024 / 1024;
    if (hasCommercialLicense()) {
      return sizeInMB < maxSizeInMB;
    }
    return sizeInMB < maxFreeSizeInMB;
  }
  BlobStorage2.canUpload = canUpload;
  async function upload(file, opts) {
    var _a2;
    const _baseUrl = BlobStorage2.baseUrl;
    if (!_baseUrl) {
      console.error("Blob storage base url is not set");
      return null;
    } else if (!file.name) {
      console.error("Upload: file name is missing");
      return null;
    }
    let arrayBuffer = null;
    if (file instanceof File) {
      arrayBuffer = await file.arrayBuffer();
    } else {
      arrayBuffer = file.data;
    }
    const filesize = arrayBuffer.byteLength;
    const filesizeInMB = filesize / 1024 / 1024;
    if (filesizeInMB > maxSizeInMB) {
      if ((opts == null ? void 0 : opts.silent) !== true)
        showBalloonWarning(`File (${filesizeInMB.toFixed(1)}MB) is too large for uploading (see console for details)`);
      console.warn(`Your file is too large for uploading (${filesizeInMB.toFixed(1)}MB). Max allowed size is ${maxSizeInMB}MB`);
      return null;
    } else if (!hasCommercialLicense() && filesizeInMB > maxFreeSizeInMB) {
      if ((opts == null ? void 0 : opts.silent) !== true)
        showBalloonWarning(`File is too large for uploading. Please get a <a href="https://needle.tools/pricing" target="_blank">commercial license</a> to upload files larger than 5MB`);
      console.warn(`Your file is too large for uploading (${filesizeInMB.toFixed(1)}MB). Max size is 5MB for non-commercial users. Please get a commercial license at https://needle.tools/pricing for larger files (up to 50MB)`);
      return null;
    } else if (filesize < 1) {
      console.warn(`Your file is too small for uploading (${filesizeInMB.toFixed(1)}MB). Min size is 1 byte`);
      return null;
    }
    const hash = hashMD5_Base64(arrayBuffer);
    const headers = {
      filename: file.name,
      "Content-Md5": hash,
      // "x-amz-checksum-sha256": checksum,
      // "X-Amz-Content-Sha256": checksum,
      "Content-Type": file.type || "application/octet-stream",
      "FileSize": filesize.toString(),
      // enforced by the server
      "Content-Disposition": `attachment; filename="${file.name}"`,
      // enforced by the server
      "x-amz-server-side-encryption": "AES256"
    };
    const uploadResult = await fetch(_baseUrl + "/api/needle/blob", {
      method: "POST",
      headers,
      signal: opts == null ? void 0 : opts.abort
    }).then((res) => res.json()).catch((err) => {
      console.error(err);
      return null;
    });
    if (uploadResult == null) {
      console.warn("Upload failed...");
      return null;
    } else if ("error" in uploadResult) {
      console.error(uploadResult.error);
      return null;
    } else if ("upload" in uploadResult && uploadResult.upload) {
      let tryUpload = function(url) {
        var _a3;
        (_a3 = opts == null ? void 0 : opts.onProgress) == null ? void 0 : _a3.call(null, { progress01: 0, state: "inprogress" });
        const uploadRes = fetch(url, {
          method: "PUT",
          headers,
          body: arrayBuffer,
          signal: opts == null ? void 0 : opts.abort
        }).then((res) => {
          var _a4;
          (_a4 = opts == null ? void 0 : opts.onProgress) == null ? void 0 : _a4.call(null, { progress01: 1, state: "finished" });
          return res;
        }).catch((err) => {
          return err;
        });
        return uploadRes;
      };
      console.debug("Uploading file", uploadResult.upload);
      let didUpload = false;
      let error = null;
      for (let i = 0; i < 3; i++) {
        try {
          if (didUpload)
            break;
          if ((_a2 = opts == null ? void 0 : opts.abort) == null ? void 0 : _a2.aborted) {
            console.debug("Aborted upload");
            return null;
          }
          const res = await tryUpload(uploadResult.upload);
          if (res instanceof Error) {
            error = res;
            await delay(1e3 * i);
          } else if (res.ok) {
            console.debug("File uploaded successfully");
            didUpload = true;
          }
        } catch (err) {
          console.error(err);
        }
      }
      if (!didUpload) {
        console.error((error == null ? void 0 : error.message) || "Failed to upload file");
        return null;
      }
    }
    if ("download" in uploadResult) {
      const downloadUrl = _baseUrl + uploadResult.download;
      console.debug("File found in blob storage", downloadUrl);
      return {
        key: uploadResult.key,
        success: true,
        download_url: downloadUrl
      };
    }
    return null;
  }
  BlobStorage2.upload = upload;
  function getBlobUrlForKey(key) {
    return `${BlobStorage2.baseUrl}/api/needle/blob/${key}`;
  }
  BlobStorage2.getBlobUrlForKey = getBlobUrlForKey;
  async function download(url, progressCallback) {
    var _a2;
    const response = await fetch(url);
    const reader = (_a2 = response.body) == null ? void 0 : _a2.getReader();
    const contentLength = response.headers.get("Content-Length");
    const total = contentLength ? parseInt(contentLength) : 0;
    if (!reader)
      return null;
    let received = 0;
    const chunks = [];
    while (true) {
      const { done, value } = await reader.read();
      if (value) {
        chunks.push(value);
        received += value.length;
        progressCallback == null ? void 0 : progressCallback.call(null, new ProgressEvent("progress", { loaded: received, total }));
      }
      if (done) {
        break;
      }
    }
    const final = new Uint8Array(received);
    let position = 0;
    for (const chunk of chunks) {
      final.set(chunk, position);
      position += chunk.length;
    }
    return final;
  }
  BlobStorage2.download = download;
})(BlobStorage || (BlobStorage = {}));

// node_modules/@needle-tools/engine/lib/engine/engine_addressables.js
var debug22 = getParam("debugaddressables");
var Addressables = class {
  /** @internal */
  constructor(context) {
    __publicField(this, "_context");
    __publicField(this, "_assetReferences", {});
    __publicField(this, "preUpdate", () => {
    });
    this._context = context;
    this._context.pre_update_callbacks.push(this.preUpdate);
  }
  /** @internal */
  dispose() {
    const preUpdateIndex = this._context.pre_update_callbacks.indexOf(this.preUpdate);
    if (preUpdateIndex >= 0) {
      this._context.pre_update_callbacks.splice(preUpdateIndex, 1);
    }
    for (const key in this._assetReferences) {
      const ref = this._assetReferences[key];
      ref == null ? void 0 : ref.unload();
    }
    this._assetReferences = {};
  }
  /**
   * Find a registered AssetReference by its URL
   */
  findAssetReference(url) {
    return this._assetReferences[url] || null;
  }
  /**
   * Register an asset reference
   * @internal
   */
  registerAssetReference(ref) {
    if (!ref.url)
      return ref;
    if (!this._assetReferences[ref.url]) {
      this._assetReferences[ref.url] = ref;
    } else {
      console.warn("Asset reference already registered", ref);
    }
    return ref;
  }
  /** @internal */
  unregisterAssetReference(ref) {
    if (!ref.url)
      return;
    delete this._assetReferences[ref.url];
  }
};
var $assetReference = Symbol("assetReference");
var _AssetReference = class {
  /** @internal */
  constructor(uri, hash, asset = null) {
    __publicField(this, "_loading");
    __publicField(this, "_asset");
    __publicField(this, "_glbRoot");
    __publicField(this, "_url");
    __publicField(this, "_progressListeners", []);
    __publicField(this, "_hash");
    __publicField(this, "_hashedUri");
    __publicField(this, "_isLoadingRawBinary", false);
    __publicField(this, "_rawBinary");
    this._url = uri;
    this._hash = hash;
    if (uri.includes("?v="))
      this._hashedUri = uri;
    else
      this._hashedUri = hash ? uri + "?v=" + hash : uri;
    if (asset !== null)
      this.asset = asset;
    registerPrefabProvider(this._url, this.onResolvePrefab.bind(this));
  }
  /**
   * Get an AssetReference for a URL to be easily loaded.
   * AssetReferences are cached so calling this method multiple times with the same arguments will always return the same AssetReference.
   * @param url The URL of the asset to load. The url can be relative or absolute.
   * @param context The context to use for loading the asset
   * @returns the AssetReference for the URL
   */
  static getOrCreateFromUrl(url, context) {
    if (!context) {
      context = Context.Current;
      if (!context)
        throw new Error('Context is required when sourceId is a string. When you call this method from a component you can call it with "getOrCreate(this, url)" where "this" is the component.');
    }
    const addressables = context.addressables;
    const existing = addressables.findAssetReference(url);
    if (existing)
      return existing;
    const ref = new _AssetReference(url, context.hash);
    addressables.registerAssetReference(ref);
    return ref;
  }
  /**
   * Get an AssetReference for a URL to be easily loaded.
   * AssetReferences are cached so calling this method multiple times with the same arguments will always return the same AssetReference.
   */
  static getOrCreate(sourceId, url, context) {
    if (typeof sourceId === "string") {
      if (!context) {
        context = Context.Current;
        if (!context)
          throw new Error('Context is required when sourceId is a string. When you call this method from a component you can call it with "getOrCreate(this, url)" where "this" is the component.');
      }
    } else {
      context = sourceId.context;
      sourceId = sourceId.sourceId;
    }
    const fullPath = resolveUrl(sourceId, url);
    if (debug22)
      console.log("GetOrCreate Addressable from", sourceId, url, "FinalPath=", fullPath);
    const addressables = context.addressables;
    const existing = addressables.findAssetReference(fullPath);
    if (existing)
      return existing;
    const ref = new _AssetReference(fullPath, context.hash);
    addressables.registerAssetReference(ref);
    return ref;
  }
  /** The loaded asset */
  get asset() {
    return this._glbRoot ?? this._asset;
  }
  set asset(val) {
    this._asset = val;
  }
  /** The url of the loaded asset (or the asset to be loaded)
   * @deprecated use url */
  get uri() {
    return this._url;
  }
  /** The url of the loaded asset (or the asset to be loaded) */
  get url() {
    return this._url;
  }
  /**
   * @returns true if the uri is a valid URL (http, https, blob)
   */
  get hasUrl() {
    return this._url !== void 0 && (this._url.startsWith("http") || this._url.startsWith("blob:") || this._url.startsWith("www.") || this._url.includes("/"));
  }
  /**
   * This is the loaded asset root object. If the asset is a glb/gltf file this will be the {@link three#Scene} object.
   */
  get rawAsset() {
    return this._asset;
  }
  async onResolvePrefab(url) {
    if (url === this.url) {
      if (this.mustLoad)
        await this.loadAssetAsync();
      if (this.asset) {
        return this.asset;
      }
    }
    return null;
  }
  get mustLoad() {
    return !this.asset || this.asset.__destroyed === true || isDestroyed(this.asset) === true;
  }
  /**
   * @returns `true` if the asset has been loaded (via preload) or if it exists already (assigned to `asset`) */
  isLoaded() {
    return this._rawBinary || this.asset !== void 0;
  }
  /** frees previously allocated memory and destroys the current `asset` instance (if any) */
  unload() {
    if (this.asset) {
      if (debug22)
        console.log("Unload", this.asset);
      if (this.asset.scene)
        destroy(this.asset.scene, true, true);
      destroy(this.asset, true, true);
    }
    this.asset = null;
    this._rawBinary = void 0;
    this._glbRoot = null;
    this._loading = void 0;
    if (Context.Current) {
      Context.Current.addressables.unregisterAssetReference(this);
    }
  }
  /** loads the asset binary without creating an instance */
  async preload() {
    if (!this.mustLoad)
      return null;
    if (this._isLoadingRawBinary)
      return null;
    if (this._rawBinary !== void 0)
      return this._rawBinary;
    this._isLoadingRawBinary = true;
    if (debug22)
      console.log("Preload", this._hashedUri);
    const res = await BlobStorage.download(this._hashedUri, (p) => {
      this.raiseProgressEvent(p);
    });
    this._rawBinary = (res == null ? void 0 : res.buffer) ?? null;
    this._isLoadingRawBinary = false;
    return this._rawBinary;
  }
  // TODO: we need a way to abort loading a resource
  /** Loads the asset and creates one instance (assigned to `asset`)
   * @returns the loaded asset
   */
  async loadAssetAsync(prog) {
    if (debug22)
      console.log("loadAssetAsync", this.url);
    if (!this.mustLoad)
      return this.asset;
    if (prog)
      this._progressListeners.push(prog);
    if (this._loading !== void 0) {
      return this._loading.then((_) => this.asset);
    }
    const context = Context.Current;
    if (this._rawBinary) {
      this._loading = getLoader().parseSync(context, this._rawBinary, this.url, null);
      this.raiseProgressEvent(new ProgressEvent("progress", { loaded: this._rawBinary.byteLength, total: this._rawBinary.byteLength }));
    } else {
      if (debug22)
        console.log("Load async", this.url);
      this._loading = getLoader().loadSync(context, this._hashedUri, this.url, null, (prog2) => {
        this.raiseProgressEvent(prog2);
      });
    }
    const res = await this._loading;
    this._progressListeners.length = 0;
    this._glbRoot = this.tryGetActualGameObjectRoot(res);
    this._loading = void 0;
    if (res) {
      res[$assetReference] = this;
      if (this._glbRoot)
        this._glbRoot[$assetReference] = this;
      if (this.asset)
        this.asset[$assetReference] = this;
      processNewScripts(context);
      if (res.scene !== void 0) {
        this.asset = res;
      }
      return this.asset;
    }
  }
  /** loads and returns a new instance of `asset` */
  async instantiate(parent) {
    return this.onInstantiate(parent, false);
  }
  /** loads and returns a new instance of `asset` - this call is networked so an instance will be created on all connected users */
  async instantiateSynced(parent, saveOnServer = true) {
    return this.onInstantiate(parent, true, saveOnServer);
  }
  beginListenDownload(evt) {
    if (this._progressListeners.indexOf(evt) < 0)
      this._progressListeners.push(evt);
  }
  endListenDownload(evt) {
    const index = this._progressListeners.indexOf(evt);
    if (index >= 0) {
      this._progressListeners.splice(index, 1);
    }
  }
  raiseProgressEvent(prog) {
    for (const list of this._progressListeners) {
      list(this, prog);
    }
  }
  async onInstantiate(opts, networked = false, saveOnServer) {
    const context = Context.Current;
    const options = new InstantiateOptions();
    if (opts instanceof Object3D) {
      options.parent = opts;
    } else if (opts) {
      Object.assign(options, opts);
      options.cloneAssign(opts);
    }
    if (!options.parent)
      options.parent = context.scene;
    if (this.mustLoad) {
      await this.loadAssetAsync();
    }
    if (debug22)
      console.log("Instantiate", this.url, "parent:", opts);
    if (this.asset) {
      if (debug22)
        console.log("Add to scene", this.asset);
      let count = _AssetReference.currentlyInstantiating.get(this.url);
      if (count !== void 0 && count >= 1e4) {
        console.error("Recursive or too many instantiations of " + this.url + " in the same frame (" + count + ")");
        return null;
      }
      try {
        if (count === void 0)
          count = 0;
        count += 1;
        _AssetReference.currentlyInstantiating.set(this.url, count);
        if (networked) {
          options.context = context;
          const prefab = this.asset;
          prefab.guid = this.url;
          const instance = syncInstantiate(prefab, options, void 0, saveOnServer);
          if (instance) {
            return instance;
          }
        } else {
          const instance = instantiate(this.asset, options);
          if (instance) {
            return instance;
          }
        }
      } finally {
        context.post_render_callbacks.push(() => {
          if (count === void 0 || count < 0)
            count = 0;
          else
            count -= 1;
          _AssetReference.currentlyInstantiating.set(this.url, count);
        });
      }
    } else if (debug22)
      console.warn("Failed to load asset", this.url);
    return null;
  }
  /**
   * try to ignore the intermediate created object
   * because it causes trouble if we instantiate an assetreference per player
   * and call destroy on the player marker root
   * @returns the scene root object if the asset was a glb/gltf
   */
  tryGetActualGameObjectRoot(asset) {
    if (asset && asset.scene) {
      const scene = asset.scene;
      if (scene.isGroup && scene.children.length === 1 && scene.children[0].name + "glb" === scene.name) {
        const root = scene.children[0];
        return root;
      } else
        return scene;
    }
    return null;
  }
};
var AssetReference = _AssetReference;
__publicField(AssetReference, "currentlyInstantiating", /* @__PURE__ */ new Map());
var AddressableSerializer = class extends TypeSerializer {
  constructor() {
    super([AssetReference], "AssetReferenceSerializer");
  }
  onSerialize(data, _context) {
    if (data && data.uri !== void 0 && typeof data.uri === "string") {
      return data.uri;
    }
  }
  onDeserialize(data, context) {
    if (typeof data === "string") {
      if (!context.context) {
        console.error("Missing context");
        return null;
      }
      if (!context.gltfId) {
        console.error("Missing source id");
        return null;
      }
      const ref = AssetReference.getOrCreate(context.gltfId, data, context.context);
      return ref;
    } else if (data instanceof Object3D) {
      if (!context.context) {
        console.error("Missing context");
        return null;
      }
      if (!context.gltfId) {
        console.error("Missing source id");
        return null;
      }
      const obj = data;
      const ctx = context.context;
      const guid = obj["guid"] ?? obj.uuid;
      const existing = ctx.addressables.findAssetReference(guid);
      if (existing)
        return existing;
      const ref = new AssetReference(guid, void 0, obj);
      ctx.addressables.registerAssetReference(ref);
      return ref;
    }
    return null;
  }
};
new AddressableSerializer();
var failedTexturePromise = Promise.resolve(null);
var _ImageReference = class {
  constructor(url) {
    __publicField(this, "url");
    __publicField(this, "_bitmap");
    __publicField(this, "_bitmapObject");
    __publicField(this, "loader", null);
    this.url = url;
  }
  static getOrCreate(url) {
    let ref = _ImageReference.imageReferences.get(url);
    if (!ref) {
      ref = new _ImageReference(url);
      _ImageReference.imageReferences.set(url, ref);
    }
    return ref;
  }
  dispose() {
    if (this._bitmapObject) {
      this._bitmapObject.close();
    }
    this._bitmap = void 0;
  }
  createHTMLImage() {
    const img = new Image();
    img.src = this.url;
    return img;
  }
  createTexture() {
    if (!this.url)
      return failedTexturePromise;
    if (!this.loader)
      this.loader = new TextureLoader();
    this.loader.setCrossOrigin("anonymous");
    return this.loader.loadAsync(this.url);
  }
  /** Loads the bitmap data of the image */
  getBitmap() {
    if (this._bitmap)
      return this._bitmap;
    this._bitmap = new Promise((res, _) => {
      const imageElement = document.createElement("img");
      imageElement.addEventListener("load", () => {
        this._bitmap = createImageBitmap(imageElement).then((bitmap) => {
          this._bitmapObject = bitmap;
          res(bitmap);
          return bitmap;
        });
      });
      imageElement.addEventListener("error", (err) => {
        console.error("Failed to load image:" + this.url, err);
        res(null);
      });
      imageElement.src = this.url;
    });
    return this._bitmap;
  }
};
var ImageReference = _ImageReference;
__publicField(ImageReference, "imageReferences", /* @__PURE__ */ new Map());
var ImageReferenceSerializer = class extends TypeSerializer {
  constructor() {
    super([ImageReference], "ImageReferenceSerializer");
  }
  onSerialize(_data, _context) {
    return null;
  }
  onDeserialize(data, _context) {
    if (typeof data === "string") {
      const url = resolveUrl(_context.gltfId, data);
      return ImageReference.getOrCreate(url);
    }
    return void 0;
  }
};
new ImageReferenceSerializer();
var _FileReference = class {
  constructor(url) {
    /** The resolved url to the file */
    __publicField(this, "url");
    __publicField(this, "res");
    this.url = url;
  }
  static getOrCreate(url) {
    let ref = _FileReference.cache.get(url);
    if (!ref) {
      ref = new _FileReference(url);
      _FileReference.cache.set(url, ref);
    }
    return ref;
  }
  /** Load the file binary data
   * @returns a promise that resolves to the binary data of the file. Make sure to await this request or use `.then(res => {...})` to get the result.
   */
  async loadRaw() {
    if (!this.res)
      this.res = fetch(this.url);
    return this.res.then((res) => res.blob());
  }
  /** Load the file as text (if the referenced file is a text file like a .txt or .json file)
   * @returns a promise that resolves to the text data of the file. Make sure to await this request or use `.then(res => {...})` to get the result. If the format is json you can use `JSON.parse(result)` to convert it to a json object
   */
  async loadText() {
    if (!this.res)
      this.res = fetch(this.url);
    return this.res.then((res) => res.text());
  }
};
var FileReference = _FileReference;
__publicField(FileReference, "cache", /* @__PURE__ */ new Map());
var FileReferenceSerializer = class extends TypeSerializer {
  constructor() {
    super([FileReference], "FileReferenceSerializer");
  }
  onSerialize(_data, _context) {
    return null;
  }
  onDeserialize(data, _context) {
    if (typeof data === "string") {
      const url = resolveUrl(_context.gltfId, data);
      return FileReference.getOrCreate(url);
    }
    return void 0;
  }
};
new FileReferenceSerializer();

// node_modules/@needle-tools/engine/lib/engine/engine_animation.js
var AnimationsRegistry = class {
  constructor(context) {
    __publicField(this, "context");
    __publicField(this, "mixers", []);
    this.context = context;
  }
  /** @hidden @internal */
  onDestroy() {
    this.mixers.forEach((mixer) => mixer.stopAllAction());
    this.mixers.length = 0;
  }
  /**
   * Register an animation mixer instance.
   */
  registerAnimationMixer(mixer) {
    if (!mixer) {
      console.warn("AnimationsRegistry.registerAnimationMixer called with null or undefined mixer");
      return;
    }
    if (this.mixers.includes(mixer))
      return;
    this.mixers.push(mixer);
  }
  /**
   * Unregister an animation mixer instance.
   */
  unregisterAnimationMixer(mixer) {
    if (!mixer) {
      console.warn("AnimationsRegistry.unregisterAnimationMixer called with null or undefined mixer");
      return;
    }
    const index = this.mixers.indexOf(mixer);
    if (index === -1)
      return;
    this.mixers.splice(index, 1);
  }
};
var AnimationUtils = class {
  /**
   * Tries to get the animation actions from an animation mixer.
   * @param mixer The animation mixer to get the actions from
   * @returns The actions or null if the mixer is invalid
   */
  static tryGetActionsFromMixer(mixer) {
    const actions = mixer["_actions"];
    if (!actions)
      return null;
    return actions;
  }
  static tryGetAnimationClipsFromObjectHierarchy(obj, target) {
    if (!target)
      target = new Array();
    if (!obj) {
      return target;
    } else if (obj.animations) {
      target.push(...obj.animations);
    }
    if (obj.children) {
      for (const child of obj.children) {
        this.tryGetAnimationClipsFromObjectHierarchy(child, target);
      }
    }
    return target;
  }
  /**
   * Assigns animations from a GLTF file to the objects in the scene.
   * This method will look for objects in the scene that have animations and assign them to the correct objects.
   * @param file The GLTF file to assign the animations from
   */
  static assignAnimationsFromFile(file, opts) {
    if (!file || !file.animations) {
      console.debug("No animations found in file");
      return;
    }
    for (let i = 0; i < file.animations.length; i++) {
      const animation = file.animations[i];
      if (!animation.tracks || animation.tracks.length <= 0) {
        console.warn("Animation has no tracks");
        continue;
      }
      for (const t2 in animation.tracks) {
        const track = animation.tracks[t2];
        const parsedPath = PropertyBinding.parseTrackName(track.name);
        let obj = PropertyBinding.findNode(file.scene, parsedPath.nodeName);
        if (!obj) {
          const objectName = track["__objectName"] ?? track.name.substring(0, track.name.indexOf("."));
          obj = file.scene.getObjectByProperty("uuid", objectName);
          if (!obj) {
            continue;
          }
        }
        let animationComponent = findAnimationGameObjectInParent(obj);
        if (!animationComponent) {
          if (!(opts == null ? void 0 : opts.createAnimationComponent)) {
            console.warn("No AnimationComponent found in parent hierarchy of object and no 'createAnimationComponent' callback was provided in options.");
            continue;
          }
          animationComponent = opts.createAnimationComponent(file.scene, animation);
        }
        if (animationComponent.addClip) {
          animationComponent.addClip(animation);
        }
      }
    }
    function findAnimationGameObjectInParent(obj) {
      var _a2;
      if (!obj)
        return null;
      const components = (_a2 = obj.userData) == null ? void 0 : _a2.components;
      if (components && components.length > 0) {
        for (let i = 0; i < components.length; i++) {
          const component = components[i];
          if (component.isAnimationComponent === true) {
            return obj;
          }
        }
      }
      return findAnimationGameObjectInParent(obj.parent);
    }
  }
};

// node_modules/@needle-tools/engine/lib/engine/engine_application.js
var ApplicationEvents;
(function(ApplicationEvents2) {
  ApplicationEvents2["Visible"] = "application-visible";
  ApplicationEvents2["Hidden"] = "application-hidden";
  ApplicationEvents2["MuteChanged"] = "application-mutechanged";
})(ApplicationEvents || (ApplicationEvents = {}));
var userInteractionRegistered = false;
var userInteractionCallbacks = [];
function onUserInteraction() {
  if (userInteractionRegistered)
    return;
  if (isDevEnvironment())
    console.debug("User interaction registered: audio can now be played");
  userInteractionRegistered = true;
  const copy = [...userInteractionCallbacks];
  userInteractionCallbacks.length = 0;
  copy.forEach((cb) => cb());
}
document.addEventListener("mousedown", onUserInteraction);
document.addEventListener("pointerup", onUserInteraction);
document.addEventListener("click", onUserInteraction);
document.addEventListener("dragstart", onUserInteraction);
document.addEventListener("touchend", onUserInteraction);
document.addEventListener("keydown", onUserInteraction);
NeedleXRSession.onXRSessionStart(() => {
  onUserInteraction();
});
var _Application = class extends EventTarget {
  /** @internal */
  constructor(context) {
    super();
    __publicField(this, "_mute", false);
    __publicField(this, "context");
    __publicField(this, "_isVisible", true);
    this.context = context;
    window.addEventListener("visibilitychange", this.onVisiblityChanged.bind(this), false);
  }
  static get userInteractionRegistered() {
    return userInteractionRegistered;
  }
  /**
   * Register a callback that will be called when the user interacts with the page (click, touch, keypress, etc).
   * If the user has already interacted with the page, the callback will be called immediately.
   * This can be used to wait for user interaction before playing audio, for example.
   */
  static registerWaitForInteraction(cb) {
    if (cb !== null) {
      if (userInteractionRegistered) {
        cb();
        return;
      }
      if (userInteractionCallbacks.indexOf(cb) === -1)
        userInteractionCallbacks.push(cb);
    }
  }
  /**
   * Unregister a callback that was previously registered with registerWaitForInteraction.
   */
  static unregisterWaitForInteraction(cb) {
    const index = userInteractionCallbacks.indexOf(cb);
    if (index !== -1) {
      userInteractionCallbacks.splice(index, 1);
    }
  }
  /** audio muted? */
  get muted() {
    return this._mute;
  }
  /** set global audio mute */
  set muted(value) {
    if (value === this._mute)
      return;
    this._mute = value;
    this.dispatchEvent(new Event(ApplicationEvents.MuteChanged));
  }
  /** @returns true if the document is focused */
  get hasFocus() {
    return document.hasFocus();
  }
  /**
   * @returns true if the application is currently visible (it's tab is active and not minimized)
   */
  get isVisible() {
    return this._isVisible;
  }
  onVisiblityChanged(evt) {
    switch (evt.target.visibilityState) {
      case "hidden":
        this._isVisible = false;
        this.dispatchEvent(new Event(ApplicationEvents.Hidden));
        break;
      case "visible":
        this._isVisible = true;
        this.dispatchEvent(new Event(ApplicationEvents.Visible));
        break;
    }
  }
};
var Application = _Application;
/**  @deprecated use Application.registerWaitForInteraction instead */
__publicField(Application, "registerWaitForAllowAudio", _Application.registerWaitForInteraction);

// node_modules/@needle-tools/engine/lib/engine/engine_coroutine.js
function* WaitForSeconds(seconds, context = null) {
  const time = context ? context.time : Context.Current.time;
  const start = time.time;
  while (time.time - start < seconds) {
    yield;
  }
}
function* WaitForFrames(frames) {
  for (let i = 0; i < frames; i++) {
    yield;
  }
}
function* WaitForPromise(promise) {
  let isRunning = true;
  promise.then(() => isRunning = false);
  promise.catch(() => isRunning = false);
  while (isRunning) {
    yield;
  }
}

// node_modules/@needle-tools/engine/lib/engine/extensions/NEEDLE_lightmaps.js
var EXTENSION_NAME3 = "NEEDLE_lightmaps";
var debug23 = getParam("debuglightmapsextension") || getParam("debuglightmaps");
var LightmapType;
(function(LightmapType2) {
  LightmapType2[LightmapType2["Lightmap"] = 0] = "Lightmap";
  LightmapType2[LightmapType2["Skybox"] = 1] = "Skybox";
  LightmapType2[LightmapType2["Reflection"] = 2] = "Reflection";
})(LightmapType || (LightmapType = {}));
var NEEDLE_lightmaps = class {
  constructor(parser, reg, source) {
    __publicField(this, "parser");
    __publicField(this, "registry");
    __publicField(this, "source");
    this.parser = parser;
    this.registry = reg;
    this.source = source;
  }
  get name() {
    return EXTENSION_NAME3;
  }
  afterRoot(_result) {
    const extensions = this.parser.json.extensions;
    if (extensions) {
      const ext = extensions[EXTENSION_NAME3];
      if (ext) {
        const arr = ext.textures;
        if (!(arr == null ? void 0 : arr.length)) {
          return null;
        }
        if (debug23)
          console.log(ext);
        return new Promise(async (resolve2, _reject) => {
          const dependencies = [];
          for (const entry of arr) {
            if (entry.pointer) {
              if (debug23)
                console.log(entry);
              let res = null;
              if (entry.pointer.startsWith("/textures/")) {
                if (debug23)
                  console.log("Load texture from gltf", entry.pointer);
                res = resolveReferences(this.parser, entry.pointer).then((res2) => this.resolveTexture(entry, res2));
              } else if (typeof entry.pointer === "string") {
                if (debug23)
                  console.log("Load texture from path", entry.pointer);
                const path = resolveUrl(this.source, entry.pointer);
                let loader2;
                if (path.endsWith(".exr"))
                  loader2 = new EXRLoader(this.parser.options.manager);
                else if (path.endsWith(".hdr"))
                  loader2 = new RGBELoader(this.parser.options.manager);
                else
                  loader2 = new TextureLoader(this.parser.options.manager);
                res = loader2.loadAsync(path, void 0).then((res2) => this.resolveTexture(entry, res2));
              } else if (entry.pointer === void 0) {
              }
              if (res)
                dependencies.push(res);
            }
          }
          const results = await PromiseAllWithErrors(dependencies);
          if (results == null ? void 0 : results.anyFailed) {
            if (isDevEnvironment())
              console.error("Failed to load lightmap extension", results);
          }
          resolve2();
        });
      }
    }
    return null;
  }
  resolveTexture(entry, res) {
    const tex = res;
    if (debug23)
      console.log("Lightmap loaded:", tex);
    if (tex == null ? void 0 : tex.isTexture) {
      if (!this.registry)
        console.log(LightmapType[entry.type], entry.pointer, tex);
      else {
        tex.colorSpace = LinearSRGBColorSpace;
        this.registry.registerTexture(this.source, entry.type, tex, entry.index);
      }
    }
  }
};

// node_modules/@needle-tools/engine/lib/engine/engine_lightdata.js
var debugLightmap = getParam("debuglightmaps") ? true : false;
var LightDataRegistry = class {
  constructor(context) {
    __publicField(this, "_context");
    __publicField(this, "_lightmaps", /* @__PURE__ */ new Map());
    this._context = context;
  }
  clear() {
    this._lightmaps.clear();
  }
  registerTexture(sourceId, type, tex, index) {
    if (debugLightmap)
      console.log("Registering ", LightmapType[type] + ' "' + sourceId + '"', tex);
    if (!this._lightmaps.has(sourceId))
      this._lightmaps.set(sourceId, /* @__PURE__ */ new Map());
    const map = this._lightmaps.get(sourceId);
    const arr = (map == null ? void 0 : map.get(type)) ?? [];
    if (arr.length < index)
      arr.length = index + 1;
    arr[index] = tex;
    map == null ? void 0 : map.set(type, arr);
  }
  tryGetLightmap(sourceId, index = 0) {
    return this.tryGet(sourceId, LightmapType.Lightmap, index);
  }
  tryGetSkybox(sourceId) {
    return this.tryGet(sourceId, LightmapType.Skybox, 0);
  }
  tryGetReflection(sourceId) {
    return this.tryGet(sourceId, LightmapType.Reflection, 0);
  }
  tryGet(sourceId, type, index) {
    if (!sourceId) {
      if (debugLightmap)
        console.warn("Missing source id");
      return null;
    }
    const entry = this._lightmaps.get(sourceId);
    if (!entry)
      return null;
    const arr = entry.get(type);
    if (arr === void 0)
      return null;
    if (!(arr == null ? void 0 : arr.length) || arr.length <= index)
      return null;
    return arr[index];
  }
};
ShaderChunk.lights_fragment_maps = ShaderChunk.lights_fragment_maps.replace("vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );", `
    vec2 lUv = vLightMapUv.xy * lightmapScaleOffset.xy + vec2(lightmapScaleOffset.z, (1. - (lightmapScaleOffset.y + lightmapScaleOffset.w)));
    vec4 lightMapTexel = texture2D( lightMap, lUv);
    // The range of RGBM lightmaps goes from 0 to 34.49 (5^2.2) in linear space, and from 0 to 5 in gamma space.
    lightMapTexel.rgb *= lightMapTexel.a * 8.; // no idea where that "8" comes from... heuristically derived
    lightMapTexel.a = 1.;
    lightMapTexel = conv_sRGBToLinear(lightMapTexel);
    `);
ShaderChunk.lightmap_pars_fragment = `
    #ifdef USE_LIGHTMAP
        uniform sampler2D lightMap;
        uniform float lightMapIntensity;
        uniform vec4 lightmapScaleOffset;
        
        // took from threejs 05fc79cd52b79e8c3e8dec1e7dca72c5c39983a4
        vec4 conv_sRGBToLinear( in vec4 value ) {
            return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
        }
    #endif
    `;
ShaderChunk.lights_fragment_begin = ShaderChunk.lights_fragment_begin.replace("irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );", `
#if defined(USE_LIGHTMAP)
irradiance += 0.;
#else
irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
#endif`);
UniformsLib.lightmap["lightmapScaleOffset"] = { value: new Vector4(1, 1, 0, 0) };

// node_modules/@needle-tools/engine/lib/engine/engine_lods.js
var debug24 = getParam("debugprogressive");
var _tempBox = new Box3();
var _tempSphere = new Sphere();
var LODsManager2 = class {
  constructor(context) {
    __publicField(this, "context");
    __publicField(this, "_lodsManager");
    this.context = context;
  }
  /**
   * The internal LODs manager. See @needle-tools/gltf-progressive for more information.
   * @link https://npmjs.com/package/@needle-tools/gltf-progressive
   */
  get manager() {
    return this._lodsManager;
  }
  /**
   * The target triangle density is the desired max amount of triangles on screen when the mesh is filling the screen.
   * @default 200_000
   */
  get targetTriangleDensity() {
    var _a2;
    return ((_a2 = this._lodsManager) == null ? void 0 : _a2.targetTriangleDensity) ?? -1;
  }
  set targetTriangleDensity(value) {
    if (!this._lodsManager) {
      return;
    }
    this._lodsManager.targetTriangleDensity = value;
  }
  /** @internal */
  setRenderer(renderer) {
    var _a2;
    (_a2 = this._lodsManager) == null ? void 0 : _a2.disable();
    LODsManager.removePlugin(this);
    LODsManager.addPlugin(this);
    LODsManager.debugDrawLine = Gizmos.DrawLine;
    this._lodsManager = LODsManager.get(renderer);
    this._lodsManager.enable();
  }
  disable() {
    var _a2;
    (_a2 = this._lodsManager) == null ? void 0 : _a2.disable();
    LODsManager.removePlugin(this);
  }
  /** @internal */
  onAfterUpdatedLOD(_renderer3, _scene, camera, mesh, level) {
    if (debug24)
      this.onRenderDebug(camera, mesh, level);
  }
  onRenderDebug(camera, mesh, results) {
    var _a2, _b, _c;
    if (!mesh.geometry)
      return;
    if (!NEEDLE_progressive.hasLODLevelAvailable(mesh.geometry) && !NEEDLE_progressive.hasLODLevelAvailable(mesh.material))
      return;
    const state = LODsManager.getObjectLODState(mesh);
    if (!state)
      return;
    let level = results.mesh_lod;
    const changed = results.mesh_lod != state.lastLodLevel_Mesh || results.texture_lod != state.lastLodLevel_Texture;
    if (debug24 && mesh.geometry.boundingSphere) {
      const bounds = mesh.geometry.boundingSphere;
      _tempSphere.copy(bounds);
      _tempSphere.applyMatrix4(mesh.matrixWorld);
      const boundsCenter = _tempSphere.center;
      const radius = _tempSphere.radius;
      const colors = ["#76c43e", "#bcc43e", "#c4ac3e", "#c4673e", "#ff3e3e"];
      if (changed) {
        Gizmos.DrawWireSphere(boundsCenter, radius, colors[level], 0.1);
      } else {
        const triangleCount = ((_a2 = mesh.geometry.index) == null ? void 0 : _a2.count) ?? 0 / 3;
        const lods = (_b = NEEDLE_progressive.getMeshLODInformation(mesh.geometry)) == null ? void 0 : _b.lods;
        level = lods ? Math.min((lods == null ? void 0 : lods.length) - 1, level) : 0;
        let allLods = "";
        if (lods && state.lastScreenCoverage > 0) {
          for (let i = 0; i < lods.length; i++) {
            const d = lods[i].density;
            const last = i == lods.length - 1;
            allLods += d.toFixed(0) + ">" + (d / state.lastScreenCoverage).toFixed(0) + (last ? "" : ",");
          }
        }
        const density = lods ? (_c = lods[level]) == null ? void 0 : _c.density : -1;
        let text = "LOD " + results.mesh_lod + "\nTEX " + results.texture_lod;
        if (debug24 == "density") {
          text += "\n" + triangleCount + " tris\n" + (density / state.lastScreenCoverage).toFixed(0) + " dens\n" + (state.lastScreenCoverage * 100).toFixed(1) + "% cov\n" + (state.lastCentrality * 100).toFixed(1) + "% centr\n" + (_tempBox.min.x.toFixed(2) + "-" + _tempBox.max.x.toFixed(2) + "x" + _tempBox.min.y.toFixed(2) + "-" + _tempBox.max.y.toFixed(2)) + " scr";
        }
        if (state.lastScreenCoverage > 0.1) {
          const cam = camera;
          const camForward = cam.worldForward;
          const camWorld = cam.worldPosition;
          const fwd = getTempVector(camForward);
          const pos = fwd.multiplyScalar(radius * 0.7).add(boundsCenter);
          const distance = pos.distanceTo(camWorld);
          const col2 = colors[Math.min(colors.length - 1, Math.max(0, level))] + "88";
          const windowScale = this.context.domHeight > 0 ? screen.height / this.context.domHeight : 1;
          const fieldOfViewScale = camera.isPerspectiveCamera ? Math.tan(camera.fov * Math.PI / 180 / 2) : 1;
          Gizmos.DrawLabel(pos, text, distance * 0.012 * windowScale * fieldOfViewScale, void 0, 16777215, col2);
        }
      }
    }
  }
};

// node_modules/@needle-tools/engine/lib/engine/engine_playerview.js
var debug25 = getParam("debugplayerview");
var ViewDevice;
(function(ViewDevice2) {
  ViewDevice2["Browser"] = "browser";
  ViewDevice2["Headset"] = "headset";
  ViewDevice2["Handheld"] = "handheld";
})(ViewDevice || (ViewDevice = {}));
var PlayerView = class {
  constructor(userId, context) {
    __publicField(this, "userId");
    __publicField(this, "context");
    __publicField(this, "viewDevice", ViewDevice.Browser);
    __publicField(this, "removed", false);
    __publicField(this, "_object");
    this.userId = userId;
    this.context = context;
  }
  get currentObject() {
    return this._object;
  }
  set currentObject(obj) {
    this._object = obj;
  }
  get isConnected() {
    return this.context.connection.userIsInRoom(this.userId);
  }
};
var PlayerViewManager = class {
  constructor(context) {
    __publicField(this, "context");
    __publicField(this, "playerViews", /* @__PURE__ */ new Map());
    this.context = context;
  }
  setPlayerView(id, obj, device) {
    let view = this.playerViews.get(id);
    if (!view) {
      view = new PlayerView(id, this.context);
      this.playerViews.set(id, view);
    }
    view.viewDevice = device;
    view.currentObject = obj;
    view.removed = false;
  }
  getPlayerView(id) {
    if (!id)
      return void 0;
    if (!this.context.connection.userIsInRoom(id)) {
      this.playerViews.delete(id);
      return void 0;
    }
    const view = this.playerViews.get(id);
    return view;
  }
  removePlayerView(id, device) {
    const view = this.playerViews.get(id);
    if ((view == null ? void 0 : view.viewDevice) === device) {
      if (debug25)
        console.log("REMOVE", id);
      view.removed = true;
      this.playerViews.delete(id);
    }
  }
};

// node_modules/@needle-tools/engine/lib/engine/engine_fileloader.js
var loader = new FileLoader();
async function loadFileAsync(url) {
  return new Promise((resolve2, reject) => {
    loader.load(url, resolve2, void 0, reject);
  });
}

// node_modules/@needle-tools/engine/lib/engine/engine_shaders.js
var white = new Uint8Array(4);
white[0] = 255;
white[1] = 255;
white[2] = 255;
white[3] = 255;
var whiteDefaultTexture = new DataTexture(white, 1, 1, RGBAFormat);
function createFlatTexture(col2, size = 1) {
  const hasAlpha = "alpha" in col2;
  const length = size * size;
  const data = new Uint8Array(4 * length);
  const r = Math.floor(col2.r * 255);
  const g3 = Math.floor(col2.g * 255);
  const b = Math.floor(col2.b * 255);
  for (let i = 0; i < length; i++) {
    const k = i * 4;
    data[k + 0] = r;
    data[k + 1] = g3;
    data[k + 2] = b;
    if (hasAlpha)
      data[k + 3] = Math.floor(col2.alpha * 255);
    else
      data[k + 3] = 255;
  }
  const tex = new DataTexture(data, size, size);
  tex.needsUpdate = true;
  return tex;
}
function createTrilightTexture(col0, col1, col2, width = 1, height = 3) {
  const hasAlpha = false;
  const channels = 4;
  const length = width * height;
  const colors = [col0, col1, col2];
  const colorCount = colors.length;
  const data = new Uint8Array(channels * colorCount * length);
  const col3 = new Color();
  for (let y = 0; y < height; y++) {
    const colorIndex = Math.floor(y / height * colorCount);
    const nextIndex = Mathf.clamp(colorIndex + 1, 0, colorCount - 1);
    const col02 = colors[colorIndex];
    const col12 = colors[nextIndex];
    const t2 = y / height * colorCount % 1;
    col3.lerpColors(col02, col12, t2);
    const r = Math.floor(col3.r * 255);
    const g3 = Math.floor(col3.g * 255);
    const b = Math.floor(col3.b * 255);
    for (let x2 = 0; x2 < width; x2++) {
      const k = (y * width + x2) * channels;
      data[k + 0] = r;
      data[k + 1] = g3;
      data[k + 2] = b;
      data[k + 3] = 255;
    }
  }
  const tex = new DataTexture(data, width, height);
  tex.needsUpdate = true;
  return tex;
}
var Stage;
(function(Stage2) {
  Stage2[Stage2["Vertex"] = 0] = "Vertex";
  Stage2[Stage2["Fragment"] = 1] = "Fragment";
})(Stage || (Stage = {}));
var UnityShaderStage = class {
  constructor(stage, code) {
    __publicField(this, "stage");
    __publicField(this, "code");
    this.stage = stage;
    this.code = code;
  }
};
var ShaderLib2 = class {
  constructor() {
    __publicField(this, "loaded", /* @__PURE__ */ new Map());
  }
  async loadShader(url) {
    const text = await loadFileAsync(url);
    const shader = JSON.parse(text);
    return shader;
  }
  async load(stage, url) {
    if (this.loaded.has(url)) {
      return new Promise((res, rej) => {
        const obj = this.loaded.get(url);
        if (obj)
          res(obj);
        else
          rej("Shader not found");
      });
    }
    const text = await loadFileAsync(url);
    const entry = new UnityShaderStage(stage, text);
    this.loaded.set(url, entry);
    return entry;
  }
};
var lib = new ShaderLib2();
function ToUnityMatrixArray(mat, buffer2) {
  const arr = mat.elements;
  if (!buffer2)
    buffer2 = [];
  buffer2.length = 0;
  for (let i = 0; i < 16; i += 4) {
    const col1 = arr[i];
    const col2 = arr[i + 1];
    const col3 = arr[i + 2];
    const col4 = arr[i + 3];
    const el = new Vector4(col1, col2, col3, col4);
    buffer2.push(el);
  }
  return buffer2;
}
var noAmbientLight = [];
var copyBuffer = [];
function SetUnitySphericalHarmonics(obj, array) {
  if (noAmbientLight.length === 0) {
    for (let i = 0; i < 27; i++)
      noAmbientLight.push(0);
  }
  if (!array)
    array = noAmbientLight;
  for (let i = 0; i < 27; i++)
    copyBuffer[i] = array[i];
  array = copyBuffer;
  obj["unity_SHAr"] = { value: new Vector4(array[9], array[3], array[6], array[0]) };
  obj["unity_SHBr"] = { value: new Vector4(array[12], array[15], array[18], array[21]) };
  obj["unity_SHAg"] = { value: new Vector4(array[10], array[4], array[7], array[1]) };
  obj["unity_SHBg"] = { value: new Vector4(array[13], array[16], array[19], array[22]) };
  obj["unity_SHAb"] = { value: new Vector4(array[11], array[5], array[8], array[2]) };
  obj["unity_SHBb"] = { value: new Vector4(array[14], array[17], array[20], array[23]) };
  obj["unity_SHC"] = { value: new Vector4(array[24], array[25], array[26], 1) };
}
var ShaderBundle = class {
  constructor(vertexShader2, fragmentShader2, technique) {
    __publicField(this, "vertexShader");
    __publicField(this, "fragmentShader");
    __publicField(this, "technique");
    this.vertexShader = vertexShader2;
    this.fragmentShader = fragmentShader2;
    this.technique = technique;
  }
};
async function FindShaderTechniques(shaderData, id) {
  if (!shaderData) {
    console.error("Can not find technique: no shader data");
    return null;
  }
  const program2 = shaderData.programs[id];
  const vertId = program2.vertexShader;
  const fragId = program2.fragmentShader;
  if (vertId !== void 0 && fragId !== void 0) {
    const vertShader = shaderData.shaders[vertId];
    const fragShader = shaderData.shaders[fragId];
    if (vertShader.uri && fragShader.uri || vertShader.code && fragShader.code) {
      if (!vertShader.code && vertShader.uri)
        await loadShaderCode(vertShader);
      if (!fragShader.code && fragShader.uri)
        await loadShaderCode(fragShader);
      if (!vertShader.code || !fragShader.code)
        return null;
      const technique = shaderData.techniques[id];
      return new ShaderBundle(vertShader.code, fragShader.code, technique);
    }
  }
  console.error("Shader technique not found", id);
  return null;
}
async function loadShaderCode(shader) {
  const uri = shader.uri;
  if (!uri)
    return;
  if (uri.endsWith(".glsl")) {
    const loader2 = new FileLoader();
    const code = await loader2.loadAsync(uri);
    shader.code = code.toString();
  } else {
    shader.code = b64DecodeUnicode(shader.uri);
  }
}
function b64DecodeUnicode(str) {
  return decodeURIComponent(Array.prototype.map.call(atob(str), function(c2) {
    return "%" + ("00" + c2.charCodeAt(0).toString(16)).slice(-2);
  }).join(""));
}

// node_modules/@needle-tools/engine/lib/engine/engine_scenelighting.js
var debug26 = getParam("debugenvlight");
var AmbientMode;
(function(AmbientMode2) {
  AmbientMode2[AmbientMode2["Skybox"] = 0] = "Skybox";
  AmbientMode2[AmbientMode2["Trilight"] = 1] = "Trilight";
  AmbientMode2[AmbientMode2["Flat"] = 3] = "Flat";
  AmbientMode2[AmbientMode2["Custom"] = 4] = "Custom";
})(AmbientMode || (AmbientMode = {}));
var DefaultReflectionMode;
(function(DefaultReflectionMode2) {
  DefaultReflectionMode2[DefaultReflectionMode2["Skybox"] = 0] = "Skybox";
  DefaultReflectionMode2[DefaultReflectionMode2["Custom"] = 1] = "Custom";
})(DefaultReflectionMode || (DefaultReflectionMode = {}));
var RendererData = class {
  constructor(context) {
    __publicField(this, "context");
    __publicField(this, "_currentLightSettingsId");
    __publicField(this, "_sceneLightSettings");
    __publicField(this, "_timevec4", new Vector4());
    __publicField(this, "__currentReflectionId", null);
    __publicField(this, "_lighting", {});
    this.context = context;
    this.context.pre_update_callbacks.push(this.preUpdate.bind(this));
  }
  preUpdate() {
    const time = this.context.time;
    this._timevec4.x = time.time;
    this._timevec4.y = Math.sin(time.time);
    this._timevec4.z = Math.cos(time.time);
    this._timevec4.w = time.deltaTime;
  }
  /** Time data used for custom shaders
   * x: time
   * y: sin(time)
   * z: cos(time)
   * w: deltaTime
   */
  get timeVec4() {
    return this._timevec4;
  }
  /** the current environment intensity */
  get environmentIntensity() {
    if (!this._sceneLightSettings)
      return 1;
    if (!this._currentLightSettingsId)
      return 1;
    const settings = this._sceneLightSettings.get(this._currentLightSettingsId);
    if (settings)
      return settings.ambientIntensity;
    return 1;
  }
  /** Get all currently registered scene light settings */
  get sceneLightSettings() {
    var _a2;
    return (_a2 = this._sceneLightSettings) == null ? void 0 : _a2.values();
  }
  /** set the scene lighting from a specific scene. Will disable any previously enabled lighting settings */
  enable(sourceId) {
    var _a2;
    if (sourceId instanceof AssetReference)
      sourceId = sourceId.url;
    const settings = (_a2 = this._sceneLightSettings) == null ? void 0 : _a2.get(sourceId);
    if (!settings) {
      if (debug26)
        console.warn("No light settings found for", sourceId);
      return false;
    }
    if (debug26)
      console.log("Enable scene light settings", sourceId, settings);
    if (sourceId !== this._currentLightSettingsId && this._currentLightSettingsId) {
      this.disable(this._currentLightSettingsId);
    }
    this._currentLightSettingsId = sourceId;
    settings.enabled = true;
    return true;
  }
  /** disable the lighting of a specific scene, will only have any effect if it is currently active */
  disable(sourceId) {
    var _a2;
    if (sourceId instanceof AssetReference)
      sourceId = sourceId.url;
    if (sourceId === null || sourceId === void 0)
      return false;
    const settings = (_a2 = this._sceneLightSettings) == null ? void 0 : _a2.get(sourceId);
    if (!settings) {
      return false;
    }
    if (debug26)
      console.log("Disable scene light settings", sourceId, settings);
    settings.enabled = false;
    return true;
  }
  /** Disables the currently active scene lighting (if any), returns the id of the previously active lighting */
  disableCurrent() {
    if (this._currentLightSettingsId) {
      const prev = this._currentLightSettingsId;
      this.disable(this._currentLightSettingsId);
      return prev;
    }
    return null;
  }
  /** @internal */
  internalRegisterSceneLightSettings(sceneLightSettings) {
    const sourceId = sceneLightSettings.sourceId;
    if (!sourceId) {
      console.error("Missing source id for scene light settings, can not register:", sceneLightSettings);
      return;
    }
    if (debug26)
      console.log("Register " + (sceneLightSettings == null ? void 0 : sceneLightSettings.sourceId) + " lighting", sceneLightSettings);
    if (!this._sceneLightSettings)
      this._sceneLightSettings = /* @__PURE__ */ new Map();
    this._sceneLightSettings.set(sourceId, sceneLightSettings);
  }
  /** @internal */
  internalUnregisterSceneLightSettings(sceneLightSettings) {
    const sourceId = sceneLightSettings.sourceId;
    if (!sourceId) {
      console.error("Missing source id for scene light settings, can not unregister:", sceneLightSettings);
      return;
    }
    if (debug26)
      console.log("Unregister " + (sceneLightSettings == null ? void 0 : sceneLightSettings.sourceId) + " lighting", sceneLightSettings);
    if (!this._sceneLightSettings)
      return;
    this._sceneLightSettings.delete(sourceId);
  }
  /** @internal */
  internalRegisterReflection(sourceId, reflectionTexture) {
    if (debug26)
      console.log("Register reflection", sourceId, reflectionTexture);
    const h = new LightData(this.context, reflectionTexture, 1);
    this._lighting[sourceId] = h;
  }
  /** @internal */
  internalGetReflection(sourceId) {
    return this._lighting[sourceId];
  }
  /** @internal */
  internalEnableReflection(sourceId) {
    var _a2;
    this.__currentReflectionId = sourceId;
    const settings = (_a2 = this._sceneLightSettings) == null ? void 0 : _a2.get(sourceId);
    if (debug26) {
      console.log("Enable reflection", sourceId, settings ? AmbientMode[settings.ambientMode] : "Unknown ambient mode", settings);
    }
    switch (settings == null ? void 0 : settings.ambientMode) {
      case AmbientMode.Skybox:
      case AmbientMode.Custom:
        const existing = this.internalGetReflection(sourceId);
        if (existing && existing.Source) {
          if (debug26)
            console.log("Setting environment reflection", existing);
          const scene = this.context.scene;
          const tex = existing.Source;
          tex.mapping = EquirectangularReflectionMapping;
          scene.environment = tex;
          return;
        } else if (debug26)
          console.warn("Could not find reflection for source", sourceId);
        break;
    }
    if ((settings == null ? void 0 : settings.environmentReflectionSource) === DefaultReflectionMode.Custom) {
      switch (settings == null ? void 0 : settings.ambientMode) {
        case AmbientMode.Trilight:
          if (settings.ambientTrilight) {
            const colors = settings.ambientTrilight;
            const tex = createTrilightTexture(colors[0], colors[1], colors[2], 64, 64);
            tex.colorSpace = SRGBColorSpace;
            tex.mapping = EquirectangularReflectionMapping;
            this.context.scene.environment = tex;
          } else
            console.error("Missing ambient trilight", settings.sourceId);
          return;
        case AmbientMode.Flat:
          if (settings.ambientLight) {
            const tex = createFlatTexture(settings.ambientLight, 64);
            tex.colorSpace = SRGBColorSpace;
            tex.mapping = EquirectangularReflectionMapping;
            this.context.scene.environment = tex;
          } else
            console.error("Missing ambientlight", settings.sourceId);
          return;
        default:
          return;
      }
    }
  }
  /** @internal */
  internalDisableReflection(sourceId) {
    if (sourceId && sourceId !== this.__currentReflectionId) {
      if (debug26)
        console.log("Not disabling reflection for", sourceId, "because it is not the current light settings id", this.__currentReflectionId);
      return;
    }
    if (debug26)
      console.log("Disable reflection", sourceId);
    const scene = this.context.scene;
    scene.environment = null;
  }
};
var LightData = class {
  // private _sphericalHarmonicsArray?: number[];
  // private _context: Context;
  // private _sphericalHarmonics: SphericalHarmonics3 | null = null;
  // private _ambientScale: number = 1;
  // private _lightProbe?: LightProbe;
  constructor(_context, tex, _ambientScale = 1) {
    // get Array(): number[] | undefined { return this._sphericalHarmonicsArray; }
    __publicField(this, "_source");
    this._source = tex;
    tex.mapping = EquirectangularReflectionMapping;
  }
  get Source() {
    return this._source;
  }
};

// node_modules/@needle-tools/engine/lib/engine/engine_time.js
var timescaleUrl = getParam("timescale");
var timeScale = 1;
if (typeof timescaleUrl === "number")
  timeScale = timescaleUrl;
var Time = class {
  constructor() {
    __publicField(this, "_time", 0);
    __publicField(this, "_deltaTime", 0);
    __publicField(this, "_deltaTimeUnscaled", 0);
    /** The scale at which time passes. This can be used for slow motion effects or to speed up time. */
    __publicField(this, "timeScale", 1);
    __publicField(this, "_frame", 0);
    __publicField(this, "clock", new Clock());
    __publicField(this, "_smoothedFps", 0);
    __publicField(this, "_smoothedDeltaTime", 0);
    __publicField(this, "_fpsSamples", []);
    __publicField(this, "_fpsSampleIndex", 0);
    if (typeof timeScale === "number")
      this.timeScale = timeScale;
  }
  /** The time in seconds since the start of Needle Engine. */
  get time() {
    return this._time;
  }
  set time(value) {
    this._time = value;
  }
  /** The time in seconds it took to complete the last frame (Read Only). */
  get deltaTime() {
    return this._deltaTime;
  }
  set deltaTime(value) {
    this._deltaTime = value;
  }
  /** The time in seconds it took to complete the last frame (Read Only). Timescale is not applied. */
  get deltaTimeUnscaled() {
    return this._deltaTimeUnscaled;
  }
  /** same as frameCount */
  get frame() {
    return this._frame;
  }
  set frame(value) {
    this._frame = value;
  }
  /** The total number of frames that have passed (Read Only). Same as frame */
  get frameCount() {
    return this.frame;
  }
  /** The time in seconds it took to complete the last frame (Read Only). */
  get realtimeSinceStartup() {
    return this.clock.elapsedTime;
  }
  /** Approximated frames per second (Read Only). */
  get smoothedFps() {
    return this._smoothedFps;
  }
  /** The smoothed time in seconds it took to complete the last frame (Read Only). */
  get smoothedDeltaTime() {
    return 1 / this._smoothedFps;
  }
  /** Step the time. This is called automatically by the Needle Engine Context.
   * @internal
   */
  update() {
    this.deltaTime = this.clock.getDelta();
    this.deltaTime = Math.min(0.1, this.deltaTime);
    this._deltaTimeUnscaled = this.deltaTime;
    if (this.deltaTime <= 0)
      this.deltaTime = 1e-12;
    this.deltaTime *= this.timeScale;
    this.frame += 1;
    this.time += this.deltaTime;
    if (this._fpsSamples.length < 60)
      this._fpsSamples.push(this.deltaTime);
    else
      this._fpsSamples[this._fpsSampleIndex++ % 60] = this.deltaTime;
    let sum = 0;
    for (let i = 0; i < this._fpsSamples.length; i++)
      sum += this._fpsSamples[i];
    this._smoothedDeltaTime = sum / this._fpsSamples.length;
    this._smoothedFps = 1 / this._smoothedDeltaTime;
  }
};

// node_modules/@needle-tools/engine/lib/engine/engine_tonemapping.js
var patchedTonemapping = false;
function patchTonemapping(_ctx) {
  if (patchedTonemapping)
    return;
  patchedTonemapping = true;
  patchNeutral();
  patchAGX();
}
patchTonemapping();
function patchNeutral() {
  const commerceToneMapping = `
float startCompression = 0.8;
float desaturation = 0.5;
// Patched tonemapping function
vec3 NeutralToneMapping( vec3 color ) {
    color *= toneMappingExposure;
    
    float d = 1. - startCompression;
    // float peak = dot(color, vec3(0.299, 0.587, 0.114));
    float peak = max(color.r, max(color.g, color.b));
    if (peak < startCompression) return color;
    float newPeak = 1. - d * d / (peak + d - startCompression);
    float invPeak = 1. / peak;
    
    float extraBrightness = dot(color * (1. - startCompression * invPeak), vec3(1, 1, 1));
    
    color *= newPeak * invPeak;
    float g = 1. - 3. / (desaturation * extraBrightness + 3.);
    return mix(color, vec3(1, 1, 1), g);
}
`;
  const startStr = `vec3 NeutralToneMapping( vec3 color ) {`;
  const endStr = `return mix( color, vec3( newPeak ), g );
}`;
  const startIndex = ShaderChunk.tonemapping_pars_fragment.indexOf(startStr);
  const endIndex = ShaderChunk.tonemapping_pars_fragment.indexOf(endStr, startIndex);
  if (startIndex >= 0 && endIndex >= 0) {
    const existing = ShaderChunk.tonemapping_pars_fragment.substring(startIndex, endIndex + endStr.length);
    ShaderChunk.tonemapping_pars_fragment = ShaderChunk.tonemapping_pars_fragment.replace(existing, commerceToneMapping);
  } else if (isDevEnvironment()) {
    console.error("Couldn't find NeutralToneMapping in ShaderChunk.tonemapping_pars_fragment");
  }
}
function patchAGX() {
  const agxToneMapping = `
// 0: Default, 1: Golden, 2: Punchy
#define AGX_LOOK 0        

vec3 userSlope = vec3(1.0);
vec3 userOffset = vec3(0.0);
vec3 userPower = vec3(1.0);
float userSaturation = 1.0;

// Mean error^2: 3.6705141e-06
vec3 _agxDefaultContrastApprox(vec3 x) {
    vec3 x2 = x * x;
    vec3 x4 = x2 * x2;
    
    return  + 15.5     * x4 * x2
            - 40.14    * x4 * x
            + 31.96    * x4
            - 6.868    * x2 * x
            + 0.4298   * x2
            + 0.1191   * x
            - 0.00232;
}

vec3 _agx(vec3 val) {
    const mat3 agx_mat = mat3(
        0.842479062253094, 0.0423282422610123, 0.0423756549057051,
        0.0784335999999992,  0.878468636469772,  0.0784336,
        0.0792237451477643, 0.0791661274605434, 0.879142973793104);
    
    const float min_ev = -12.47393f;
    const float max_ev = 4.026069f;

    // val = pow(val, vec3(2.2)); 

    // Input transform (inset)
    val = agx_mat * val;
    
    // Log2 space encoding
    val = clamp(log2(val), min_ev, max_ev);
    val = (val - min_ev) / (max_ev - min_ev);
    
    // Apply sigmoid function approximation
    val = _agxDefaultContrastApprox(val);

    return val;
}

vec3 _agxEotf(vec3 val) {
    const mat3 agx_mat_inv = mat3(
        1.19687900512017, -0.0528968517574562, -0.0529716355144438,
        -0.0980208811401368, 1.15190312990417, -0.0980434501171241,
        -0.0990297440797205, -0.0989611768448433, 1.15107367264116);
        
    // Inverse input transform (outset)
    val = agx_mat_inv * val;
    
    // sRGB IEC 61966-2-1 2.2 Exponent Reference EOTF Display
    // NOTE: We're linearizing the output here. Comment/adjust when
    // *not* using a sRGB render target
    val = pow(val, vec3(2.2)); 

    return val;
}

vec3 _agxLook(vec3 val) {
    const vec3 lw = vec3(0.2126, 0.7152, 0.0722);
    float luma = dot(val, lw);
    
    // Default
    vec3 offset = vec3(0.0);
    vec3 slope = vec3(1.0);
    vec3 power = vec3(1.0);
    float sat = 1.0;
    
    #if AGX_LOOK == 1
    // Golden
    slope = vec3(1.0, 0.9, 0.5);
    power = vec3(0.8);
    sat = 0.8;
    #elif AGX_LOOK == 2
    // Punchy
    slope = vec3(1.0);
    power = vec3(1.35, 1.35, 1.35);
    sat = 1.4;
    #endif        
    
    // Needle
    slope = vec3(1.05);
    power = vec3(1.10, 1.10, 1.10);
    sat = 1.15;

    // User
    // slope = userSlope;
    // offset = userOffset;
    // power = userPower;
    // sat = userSaturation;
    
    // ASC CDL
    val = pow(val * slope + offset, power);
    return luma + sat * (val - luma);
}


vec3 AgXToneMapping( vec3 color ) {
    // apply AGX
    color *= toneMappingExposure;
    color = _agx(color);
    color = _agxLook(color); // Optional
    color = _agxEotf(color);
    return color;
`;
  const startString = `vec3 AgXToneMapping( vec3 color ) {`;
  const endString = `return color;`;
  const startIndex = ShaderChunk.tonemapping_pars_fragment.indexOf(startString);
  const endIndex = ShaderChunk.tonemapping_pars_fragment.indexOf(endString, startIndex);
  if (startIndex >= 0 && endIndex >= 0) {
    const existing = ShaderChunk.tonemapping_pars_fragment.substring(startIndex, endIndex + endString.length);
    ShaderChunk.tonemapping_pars_fragment = ShaderChunk.tonemapping_pars_fragment.replace(existing, agxToneMapping);
  } else if (isDevEnvironment()) {
    console.error("Couldn't find AgXToneMapping in ShaderChunk.tonemapping_pars_fragment");
  }
}

// node_modules/@needle-tools/engine/lib/engine/webcomponents/icons.js
function getIconElement(str) {
  const span = document.createElement("span");
  span.style.maxWidth = "48px";
  span.style.maxHeight = "48px";
  span.style.overflow = "hidden";
  span.classList.add("material-symbols-outlined", "notranslate");
  span.setAttribute("translate", "no");
  span.innerText = str;
  return span;
}
function isIconElement(element) {
  var _a2;
  const span = element;
  return ((_a2 = span.classList) == null ? void 0 : _a2.contains("material-symbols-outlined")) || false;
}
var textures = /* @__PURE__ */ new Map();
async function getIconTexture(str) {
  const fontname = "Material Symbols Outlined";
  if (!document.fonts.check(`1em '${fontname}'`)) {
    console.log("Font not loaded yet");
    await document.fonts.ready;
  }
  if (textures.has(str)) {
    return textures.get(str);
  }
  const canvas = document.createElement("canvas");
  const size = 48;
  canvas.width = size;
  canvas.height = size;
  const ctx = canvas.getContext("2d");
  if (ctx) {
    ctx.font = `${size}px '${fontname}'`;
    ctx.fillStyle = "black";
    ctx.fillText(str, 0, size);
    const data = canvas.toDataURL();
    const texture = new Texture();
    texture.name = str + " icon";
    texture.image = new Image();
    texture.image.src = data;
    texture.needsUpdate = true;
    textures.set(str, texture);
    return texture;
  }
  textures.set(str, null);
  return null;
}

// node_modules/@needle-tools/engine/lib/engine/webcomponents/buttons.js
var _ButtonsFactory = class {
  constructor() {
    __publicField(this, "_fullscreenButton");
    __publicField(this, "_muteButton");
    __publicField(this, "_qrButton");
  }
  /** Get access to the default HTML button factory.
   * Use this to get or create default Needle Engine buttons that can be added to your HTML UI
   * If you want to create a new factory and create new button instances instead of shared buttons, use `ButtonsFactory.create()` instead
   */
  static getOrCreate() {
    if (!this._instance) {
      this._instance = new _ButtonsFactory();
    }
    return this._instance;
  }
  /** create a new buttons factory */
  static create() {
    return new _ButtonsFactory();
  }
  /**
   * Get the fullscreen button (or undefined if it doesn't exist yet). Call {@link ButtonsFactory.createFullscreenButton} to get or create it
   */
  get fullscreenButton() {
    return this._fullscreenButton;
  }
  /** Create a fullscreen button (or return the existing one if it already exists) */
  createFullscreenButton(ctx) {
    if (this._fullscreenButton) {
      return this._fullscreenButton;
    }
    if (!document.fullscreenEnabled) {
      if (isDevEnvironment())
        console.warn("NeedleMenu: Fullscreen button could not be created, device doesn't support the Fullscreen API");
      return null;
    }
    const button = document.createElement("button");
    this._fullscreenButton = button;
    button.classList.add("fullscreen-button");
    button.title = "Click to enter fullscreen mode";
    const enterFullscreenIcon = getIconElement("fullscreen");
    const exitFullscreenIcon = getIconElement("fullscreen_exit");
    button.appendChild(enterFullscreenIcon);
    button.onclick = () => {
      if (document.fullscreenElement) {
        document.exitFullscreen();
      } else {
        if ("webkitRequestFullscreen" in ctx.domElement && typeof ctx.domElement["webkitRequestFullscreen"] === "function")
          ctx.domElement["webkitRequestFullscreen"]();
        else if ("requestFullscreen" in ctx.domElement)
          ctx.domElement.requestFullscreen();
      }
    };
    document.addEventListener("fullscreenchange", () => {
      if (document.fullscreenElement) {
        enterFullscreenIcon.remove();
        button.appendChild(exitFullscreenIcon);
        button.title = "Click to enter fullscreen mode";
      } else {
        exitFullscreenIcon.remove();
        button.appendChild(enterFullscreenIcon);
        button.title = "Click to exit fullscreen mode";
      }
    });
    globalThis.addEventListener("needle-xrsession-start", () => {
      button.style.display = "none";
    });
    globalThis.addEventListener("needle-xrsession-end", () => {
      button.style.display = "";
    });
    return button;
  }
  /** Get the mute button (or undefined if it doesn't exist yet). Call {@link ButtonsFactory.createMuteButton} to get or create it */
  get muteButton() {
    return this._muteButton;
  }
  /** Create a mute button (or return the existing one if it already exists) */
  createMuteButton(ctx) {
    if (this._muteButton) {
      return this._muteButton;
    }
    const button = document.createElement("button");
    this._muteButton = button;
    button.classList.add("mute-button");
    button.title = "Click to mute/unmute";
    const muteIcon = getIconElement("volume_off");
    const unmuteIcon = getIconElement("volume_up");
    if (ctx.application.muted) {
      button.appendChild(muteIcon);
    } else {
      button.appendChild(unmuteIcon);
    }
    button.onclick = () => {
      if (ctx.application.muted) {
        muteIcon.remove();
        button.appendChild(unmuteIcon);
        ctx.application.muted = false;
      } else {
        unmuteIcon.remove();
        button.appendChild(muteIcon);
        ctx.application.muted = true;
      }
    };
    return button;
  }
  /**
   * Get the QR code button (or undefined if it doesn't exist yet). Call {@link ButtonsFactory.createQRCode} to get or create it
   */
  get qrButton() {
    return this._qrButton;
  }
  /** Create a QR code button (or return the existing one if it already exists)
   * The QR code button will show a QR code that can be scanned to open the current page on a phone
   * The QR code will be generated with the current URL when the button is clicked
   * @returns the QR code button element
   */
  createQRCode() {
    if (this._qrButton)
      return this._qrButton;
    const qrCodeButton = document.createElement("button");
    this._qrButton = qrCodeButton;
    qrCodeButton.innerText = "QR Code";
    qrCodeButton.prepend(getIconElement("qr_code"));
    qrCodeButton.title = "Scan this QR code with your phone to open this page";
    this.hideElementDuringXRSession(qrCodeButton);
    const qrCodeContainer = document.createElement("div");
    qrCodeContainer.style.cssText = `
            position: fixed;
            display: inline-block;
            padding: 1rem;
            background-color: white;
            border-radius: 0.4rem;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 0 12px rgba(0, 0, 0, 0.2);
        `;
    const qrCodeElement = document.createElement("div");
    qrCodeElement.classList.add("qr-code-container");
    qrCodeContainer.appendChild(qrCodeElement);
    qrCodeButton.addEventListener("click", () => {
      if (qrCodeContainer.parentNode)
        return hideQRCode();
      if (window.location.href.includes("://localhost")) {
        showBalloonWarning("To access your website from another device in the same local network you have to use the IP address instead of localhost.");
      }
      showQRCode();
    });
    async function showQRCode() {
      await generateAndInsertQRCode();
      document.body.appendChild(qrCodeContainer);
      const containerRect = qrCodeElement.getBoundingClientRect();
      const buttonRect = qrCodeButton.getBoundingClientRect();
      qrCodeContainer.style.left = buttonRect.left + buttonRect.width * 0.5 - containerRect.width * 0.5 + "px";
      const isButtonInTopHalf = buttonRect.top < containerRect.height;
      if (isButtonInTopHalf)
        qrCodeContainer.style.top = `calc(${buttonRect.bottom}px + ${qrCodeContainer.style.padding} * .6)`;
      else
        qrCodeContainer.style.top = `calc(${buttonRect.top - containerRect.height}px - ${qrCodeContainer.style.padding} * 2.5)`;
      qrCodeContainer.style.opacity = "0";
      qrCodeContainer.style.pointerEvents = "all";
      qrCodeContainer.style.transition = "opacity 0.2s ease-in-out";
      setTimeout(() => {
        qrCodeContainer.style.opacity = "1";
        window.addEventListener("click", hideQRCode, { once: true });
      });
      window.addEventListener("resize", hideQRCode);
      window.addEventListener("scroll", hideQRCode);
      if (document.fullscreenElement) {
        document.fullscreenElement.appendChild(qrCodeContainer);
      } else
        document.body.appendChild(qrCodeContainer);
    }
    function hideQRCode() {
      qrCodeContainer.style.pointerEvents = "none";
      qrCodeContainer.style.transition = "opacity 0.2s";
      qrCodeContainer.style.opacity = "0";
      setTimeout(() => {
        var _a2;
        return (_a2 = qrCodeContainer.parentNode) == null ? void 0 : _a2.removeChild(qrCodeContainer);
      }, 500);
      window.removeEventListener("click", hideQRCode);
      window.removeEventListener("resize", hideQRCode);
      window.removeEventListener("scroll", hideQRCode);
    }
    ;
    async function generateAndInsertQRCode() {
      const size = 200;
      const code = await generateQRCode({
        text: window.location.href,
        width: size,
        height: size
      });
      qrCodeElement.innerHTML = "";
      qrCodeElement.appendChild(code);
    }
    qrCodeButton.addEventListener("pointerenter", () => {
      generateAndInsertQRCode();
    }, { once: true });
    return qrCodeButton;
  }
  hideElementDuringXRSession(element) {
    onXRSessionStart((_) => {
      element["previous-display"] = element.style.display;
      element.style.display = "none";
    });
    onXRSessionEnd((_) => {
      if (element["previous-display"] != void 0)
        element.style.display = element["previous-display"];
    });
  }
};
var ButtonsFactory = _ButtonsFactory;
__publicField(ButtonsFactory, "_instance");

// node_modules/@needle-tools/engine/lib/engine/webcomponents/fonts.js
function loadFont2(url, opts) {
  const element = (opts == null ? void 0 : opts.element) || document.head;
  const elements = Array.from(element.querySelectorAll(`link[rel=stylesheet][href*='${url}']`));
  if (elements.length <= 0) {
    const fontLink = document.createElement("link");
    fontLink.href = url;
    fontLink.rel = "stylesheet";
    element.appendChild(fontLink);
    elements.push(fontLink);
  }
  if (opts == null ? void 0 : opts.loadedCallback) {
    for (let i = 0; i < elements.length; i++) {
      if (opts == null ? void 0 : opts.loadedCallback) {
        const fontLink = elements[i];
        fontLink.addEventListener("load", opts.loadedCallback);
      }
    }
  }
}
function ensureFonts() {
  loadFont2("https://fonts.googleapis.com/css2?family=Roboto+Flex:opsz,wght@8..144,100..1000&display=swap");
}
var iconFontUrl = "https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0";

// node_modules/@needle-tools/engine/lib/engine/webcomponents/logo-element.js
var elementName = "needle-logo-element";
var NeedleLogoElement = class extends HTMLElement {
  constructor() {
    super();
    __publicField(this, "_root");
    __publicField(this, "wrapper");
    __publicField(this, "logoElement", document.createElement("img"));
    __publicField(this, "textElement", document.createElement("span"));
    this._root = this.attachShadow({ mode: "closed" });
    const template = document.createElement("template");
    template.innerHTML = `<style>
        :host {
            position: relative;
            min-width: fit-content;
            /* height: 100%; can not have height 100% because of align-items: stretch; in the parent */
            display: flex;
        }

        .wrapper {
            position: relative;
            display: grid;
            grid-template-columns: auto auto;
            padding: .1rem;
        }
        .wrapper:hover {
            cursor: pointer;
        }
        img {
            width: 95px;
            height: 100%;
            align-self: end;
            margin-left: 0.6rem;
        }
        span {
            font-size: 1rem;
            white-space: nowrap;
        }
        </style>
        <div class="wrapper">
            <img class="logo" src=${needleLogoSVG} />
        </div>
        `;
    this._root.appendChild(template.content.cloneNode(true));
    this.wrapper = this._root.querySelector(".wrapper");
    this._root.appendChild(this.wrapper);
    this.addEventListener("click", () => {
      globalThis.open("https://needle.tools", "_blank");
    });
    this.wrapper.setAttribute("title", "Made with Needle Engine");
  }
  static get elementName() {
    return elementName;
  }
  static create() {
    return document.createElement(elementName);
  }
  setLogoVisible(val) {
    this.logoElement.style.display = val ? "block" : "none";
  }
};
if (!customElements.get(elementName))
  customElements.define(elementName, NeedleLogoElement);

// node_modules/@needle-tools/engine/lib/engine/webcomponents/needle menu/needle-menu-spatial.js
var debug27 = getParam("debugspatialmenu");
var NeedleSpatialMenu = class {
  constructor(context, menu) {
    __publicField(this, "_context");
    __publicField(this, "needleMenu");
    __publicField(this, "htmlButtonsMap", /* @__PURE__ */ new Map());
    __publicField(this, "enabled", true);
    __publicField(this, "userRequestedMenu", false);
    __publicField(this, "uiisDirty", false);
    __publicField(this, "_showNeedleLogo");
    __publicField(this, "_wasInXR", false);
    __publicField(this, "preRender", () => {
      var _a2;
      if (!this.enabled) {
        (_a2 = this.menu) == null ? void 0 : _a2.removeFromParent();
        return;
      }
      if (debug27 && DeviceUtilities.isDesktop()) {
        this.updateMenu();
      }
      const xr = this._context.xr;
      if (!(xr == null ? void 0 : xr.running)) {
        if (this._wasInXR) {
          this._wasInXR = false;
          this.onExitXR();
        }
        return;
      }
      if (!this._wasInXR) {
        this._wasInXR = true;
        this.onEnterXR();
      }
      this.updateMenu();
    });
    __publicField(this, "_menuTarget", new Object3D());
    __publicField(this, "positionFilter", new OneEuroFilterXYZ(90, 0.5));
    __publicField(this, "familyName", "Needle Spatial Menu");
    __publicField(this, "menu");
    __publicField(this, "_poweredByNeedleElement");
    var _a2;
    this._context = context;
    this._context.pre_render_callbacks.push(this.preRender);
    this.needleMenu = menu;
    const optionsContainer = (_a2 = this.needleMenu.shadowRoot) == null ? void 0 : _a2.querySelector(".options");
    if (!optionsContainer) {
      console.error("Could not find options container in needle menu");
    } else {
      const watcher = new MutationObserver((mutations) => {
        if (!this.enabled)
          return;
        if (this._context.isInXR == false && !debug27)
          return;
        for (const mutation of mutations) {
          if (mutation.type === "childList") {
            mutation.addedNodes.forEach((node) => {
              this.createButtonFromHTMLNode(node);
            });
            mutation.removedNodes.forEach((node) => {
              const button = node;
              const spatialButton = this.htmlButtonsMap.get(button);
              if (spatialButton) {
                this.htmlButtonsMap.delete(button);
                spatialButton.remove();
                __webpack_exports__default.update();
              }
            });
          }
        }
      });
      watcher.observe(optionsContainer, { childList: true });
    }
  }
  setEnabled(enabled) {
    var _a2;
    this.enabled = enabled;
    if (!enabled)
      (_a2 = this.menu) == null ? void 0 : _a2.removeFromParent();
  }
  /** Bring up the spatial menu. This is typically invoked from a button click.
   * The menu will show at a lower height to be easily accessible.
   * @returns true if the menu was shown, false if it can't be shown because the menu has been disabled.
   */
  setDisplay(display) {
    if (!this.enabled)
      return false;
    this.userRequestedMenu = display;
    return true;
  }
  onDestroy() {
    const index = this._context.pre_render_callbacks.indexOf(this.preRender);
    if (index > -1) {
      this._context.pre_render_callbacks.splice(index, 1);
    }
  }
  markDirty() {
    this.uiisDirty = true;
  }
  showNeedleLogo(show) {
    this._showNeedleLogo = show;
  }
  onEnterXR() {
    var _a2;
    const nodes = (_a2 = this.needleMenu.shadowRoot) == null ? void 0 : _a2.querySelector(".options");
    if (nodes) {
      nodes.childNodes.forEach((node) => {
        this.createButtonFromHTMLNode(node);
      });
    }
  }
  onExitXR() {
    var _a2;
    (_a2 = this.menu) == null ? void 0 : _a2.removeFromParent();
  }
  createButtonFromHTMLNode(node) {
    const menu = this.getMenu();
    const existing = this.htmlButtonsMap.get(node);
    if (existing) {
      existing.add();
      return;
    }
    if (node instanceof HTMLButtonElement) {
      const spatialButton = this.createButton(menu, node);
      this.htmlButtonsMap.set(node, spatialButton);
      spatialButton.add();
    } else if (node instanceof HTMLSlotElement) {
      node.assignedNodes().forEach((node2) => {
        this.createButtonFromHTMLNode(node2);
      });
    }
  }
  updateMenu() {
    var _a2, _b;
    performance.mark("NeedleSpatialMenu updateMenu start");
    const menu = this.getMenu();
    this.handleNeedleWatermark();
    this._context.scene.add(menu);
    const camera = this._context.mainCamera;
    const xr = this._context.xr;
    const rigScale = (xr == null ? void 0 : xr.rigScale) || 1;
    if (camera) {
      const menuTargetPosition = camera.worldPosition;
      const fwd = camera.worldForward.multiplyScalar(-1);
      const showMenuThreshold = fwd.y > 0.6;
      const hideMenuThreshold = fwd.y > 0.4;
      const newVisibleState = (menu.visible ? hideMenuThreshold : showMenuThreshold) || this.userRequestedMenu;
      const becomesVisible = !menu.visible && newVisibleState;
      menu.visible = newVisibleState || DeviceUtilities.isDesktop() && debug27;
      fwd.multiplyScalar(3 * rigScale);
      menuTargetPosition.add(fwd);
      const testBecomesVisible = false;
      if (becomesVisible || testBecomesVisible) {
        menu.position.copy(this._menuTarget.position);
        menu.position.y += 0.25;
        this._menuTarget.position.copy(menu.position);
        this.positionFilter.reset(menu.position);
        menu.quaternion.copy(this._menuTarget.quaternion);
        this.markDirty();
      }
      const distFromForwardView = this._menuTarget.position.distanceTo(menuTargetPosition);
      if (becomesVisible || distFromForwardView > 1.5 * rigScale) {
        this.ensureRenderOnTop(this.menu);
        this._menuTarget.position.copy(menuTargetPosition);
        this._context.scene.add(this._menuTarget);
        lookAtObject(this._menuTarget, this._context.mainCamera, true, true);
        this._menuTarget.removeFromParent();
      }
      this.positionFilter.filter(this._menuTarget.position, menu.position, this._context.time.time);
      const step = 5;
      (_a2 = this.menu) == null ? void 0 : _a2.quaternion.slerp(this._menuTarget.quaternion, this._context.time.deltaTime * step);
      (_b = this.menu) == null ? void 0 : _b.scale.setScalar(rigScale);
    }
    if (this.uiisDirty) {
      performance.mark("SpatialMenu.update.uiisDirty.start");
      this.uiisDirty = false;
      __webpack_exports__default.update();
      performance.mark("SpatialMenu.update.uiisDirty.end");
      performance.measure("SpatialMenu.update.uiisDirty", "SpatialMenu.update.uiisDirty.start", "SpatialMenu.update.uiisDirty.end");
    }
    performance.mark("NeedleSpatialMenu updateMenu end");
    performance.measure("SpatialMenu.update", "NeedleSpatialMenu updateMenu start", "NeedleSpatialMenu updateMenu end");
  }
  ensureRenderOnTop(obj, level = 0) {
    if (obj instanceof Mesh) {
      obj.material.depthTest = false;
      obj.material.depthWrite = false;
    }
    obj.renderOrder = 1e3 + level * 2;
    for (const child of obj.children) {
      this.ensureRenderOnTop(child, level + 1);
    }
  }
  get isVisible() {
    var _a2;
    return (_a2 = this.menu) == null ? void 0 : _a2.visible;
  }
  getMenu() {
    if (this.menu) {
      return this.menu;
    }
    this.ensureFont();
    this.menu = new __webpack_exports__default.Block({
      boxSizing: "border-box",
      fontFamily: this.familyName,
      height: "auto",
      fontSize: 0.1,
      color: 0,
      lineHeight: 1,
      backgroundColor: 16777215,
      backgroundOpacity: 0.55,
      borderRadius: 1,
      whiteSpace: "pre-wrap",
      flexDirection: "row",
      alignItems: "center",
      padding: new Vector4(0, 0.05, 0, 0.05),
      borderColor: 0,
      borderOpacity: 0.05,
      borderWidth: 5e-3
    });
    const raycaster = TypeStore.get("ObjectRaycaster");
    if (raycaster)
      addNewComponent(this.menu, new raycaster());
    return this.menu;
  }
  handleNeedleWatermark() {
    var _a2;
    if (!this._poweredByNeedleElement) {
      this._poweredByNeedleElement = new __webpack_exports__default.Block({
        width: "auto",
        height: "auto",
        fontSize: 0.05,
        whiteSpace: "pre-wrap",
        flexDirection: "row",
        flexWrap: "wrap",
        justifyContent: "center",
        margin: 0.02,
        borderRadius: 0.02,
        padding: 0.02,
        backgroundColor: 16777215,
        backgroundOpacity: 1
      });
      this._poweredByNeedleElement["needle:use_eventsystem"] = true;
      const onClick = new OnClick(this._context, () => globalThis.open("https://needle.tools", "_self"));
      addNewComponent(this._poweredByNeedleElement, onClick);
      const firstLabel = new __webpack_exports__default.Text({
        textContent: "Powered by",
        width: "auto",
        height: "auto"
      });
      const secondLabel = new __webpack_exports__default.Text({
        textContent: "needle",
        width: "auto",
        height: "auto",
        fontSize: 0.07,
        margin: new Vector4(0, 0, 0, 0.02)
      });
      this._poweredByNeedleElement.add(firstLabel);
      this._poweredByNeedleElement.add(secondLabel);
      (_a2 = this.menu) == null ? void 0 : _a2.add(this._poweredByNeedleElement);
      this.markDirty();
      const textureLoader = new TextureLoader();
      textureLoader.load("./include/needle/poweredbyneedle.webp", (texture) => {
        var _a3;
        onClick.allowModifyUI = false;
        firstLabel.removeFromParent();
        secondLabel.removeFromParent();
        const aspect = texture.image.width / texture.image.height;
        (_a3 = this._poweredByNeedleElement) == null ? void 0 : _a3.set({
          backgroundImage: texture,
          backgroundOpacity: 1,
          width: 0.1 * aspect,
          height: 0.1
        });
        this.markDirty();
      });
    }
    if (this.menu) {
      const index = this.menu.children.indexOf(this._poweredByNeedleElement);
      if (!this._showNeedleLogo && hasProLicense()) {
        if (index >= 0) {
          this._poweredByNeedleElement.removeFromParent();
          this.markDirty();
        }
      } else {
        this._poweredByNeedleElement.visible = true;
        this.menu.add(this._poweredByNeedleElement);
        const newIndex = this.menu.children.indexOf(this._poweredByNeedleElement);
        if (index !== newIndex) {
          this.markDirty();
        }
      }
    }
  }
  ensureFont() {
    let fontFamily = __webpack_exports__default.FontLibrary.getFontFamily(this.familyName);
    if (!fontFamily) {
      fontFamily = __webpack_exports__default.FontLibrary.addFontFamily(this.familyName);
      const normal = fontFamily.addVariant("normal", "normal", "./include/needle/arial-msdf.json", "./include/needle/arial.png");
      normal == null ? void 0 : normal.addEventListener("ready", () => {
        this.markDirty();
      });
    }
  }
  createButton(menu, htmlButton) {
    const buttonParent = new __webpack_exports__default.Block({
      width: "auto",
      height: "auto",
      whiteSpace: "pre-wrap",
      flexDirection: "row",
      flexWrap: "wrap",
      justifyContent: "center",
      backgroundColor: 16777215,
      backgroundOpacity: 0,
      padding: 0.02,
      margin: 0.01,
      borderRadius: 0.02,
      cursor: "pointer",
      fontSize: 0.05
    });
    const text = new __webpack_exports__default.Text({
      textContent: "",
      width: "auto",
      justifyContent: "center",
      alignItems: "center",
      backgroundOpacity: 0,
      backgroundColor: 16777215,
      fontFamily: this.familyName,
      color: 0,
      borderRadius: 0.02,
      padding: 0.01
    });
    buttonParent.add(text);
    buttonParent["needle:use_eventsystem"] = true;
    const onClick = new OnClick(this._context, () => htmlButton.click());
    addNewComponent(buttonParent, onClick);
    const spatialButton = new SpatialButton(this, menu, htmlButton, buttonParent, text);
    return spatialButton;
  }
};
var SpatialButton = class {
  constructor(menu, root, htmlbutton, buttonContainer, buttonText) {
    __publicField(this, "menu");
    __publicField(this, "root");
    __publicField(this, "htmlbutton");
    __publicField(this, "spatialContainer");
    __publicField(this, "spatialText");
    __publicField(this, "spatialIcon");
    __publicField(this, "_lastText", "");
    __publicField(this, "_lastTexture");
    this.menu = menu;
    this.root = root;
    this.htmlbutton = htmlbutton;
    this.spatialContainer = buttonContainer;
    this.spatialText = buttonText;
    const styleObserver = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        if (mutation.type === "attributes") {
          if (mutation.attributeName === "style") {
            this.updateVisible();
          }
        } else if (mutation.type === "childList") {
          this.updateText();
        }
      }
    });
    styleObserver.observe(htmlbutton, { attributes: true, childList: true });
    this.updateText();
  }
  add() {
    if (this.spatialContainer.parent != this.root) {
      this.root.add(this.spatialContainer);
      this.menu.markDirty();
      this.updateVisible();
      this.updateText();
    }
  }
  remove() {
    if (this.spatialContainer.parent) {
      this.spatialContainer.removeFromParent();
      this.menu.markDirty();
    }
  }
  updateVisible() {
    const wasVisible = this.spatialContainer.visible;
    this.spatialContainer.visible = this.htmlbutton.style.display !== "none";
    if (wasVisible !== this.spatialContainer.visible) {
      this.menu.markDirty();
    }
  }
  updateText() {
    let newText = "";
    let iconToCreate = "";
    this.htmlbutton.childNodes.forEach((child) => {
      if (child.nodeType === Node.TEXT_NODE) {
        newText += child.textContent;
      } else if (child instanceof HTMLElement && isIconElement(child) && child.textContent) {
        iconToCreate = child.textContent;
      }
    });
    if (this._lastText !== newText) {
      this._lastText = newText;
      this.spatialText.name = newText;
      this.spatialText.set({ textContent: newText });
      this.menu.markDirty();
    }
    if (newText.length <= 0) {
      if (this.spatialText.parent) {
        this.spatialText.removeFromParent();
        this.menu.markDirty();
      }
    } else {
      if (!this.spatialText.parent) {
        this.spatialContainer.add(this.spatialText);
        this.menu.markDirty();
      }
    }
    if (iconToCreate) {
      this.createIcon(iconToCreate);
    }
  }
  async createIcon(str) {
    var _a2;
    if (!this.spatialIcon) {
      const texture = await getIconTexture(str);
      if (texture && !this.spatialIcon) {
        const size = 0.08;
        const icon = new __webpack_exports__default.Block({
          width: size,
          height: size,
          backgroundColor: 16777215,
          backgroundImage: texture,
          backgroundOpacity: 1,
          margin: new Vector4(0, 5e-3, 0, 0)
        });
        this.spatialIcon = icon;
        this.spatialContainer.add(icon);
        this.menu.markDirty();
      }
    }
    if (str != this._lastTexture) {
      this._lastTexture = str;
      const texture = await getIconTexture(str);
      if (texture) {
        (_a2 = this.spatialIcon) == null ? void 0 : _a2.set({ backgroundImage: texture });
        this.menu.markDirty();
      }
    }
    const index = this.spatialContainer.children.indexOf(this.spatialIcon);
    if (index > 0) {
      this.spatialContainer.children.splice(index, 1);
      this.spatialContainer.children.unshift(this.spatialIcon);
      this.menu.markDirty();
    }
  }
};
var OnClick = class {
  constructor(context, onclick) {
    __publicField(this, "isComponent", true);
    __publicField(this, "enabled", true);
    __publicField(this, "gameObject");
    __publicField(this, "allowModifyUI", true);
    __publicField(this, "context");
    __publicField(this, "onclick");
    this.context = context;
    this.onclick = onclick;
  }
  get activeAndEnabled() {
    return true;
  }
  __internalAwake() {
  }
  __internalEnable() {
  }
  __internalDisable() {
  }
  __internalStart() {
  }
  onEnable() {
  }
  onDisable() {
  }
  get element() {
    return this.gameObject;
  }
  onPointerEnter() {
    this.context.input.setCursorPointer();
    if (this.allowModifyUI) {
      this.element.set({ backgroundOpacity: 1 });
      __webpack_exports__default.update();
    }
  }
  onPointerExit() {
    this.context.input.setCursorNormal();
    if (this.allowModifyUI) {
      this.element.set({ backgroundOpacity: 0 });
      __webpack_exports__default.update();
    }
  }
  onPointerDown(e) {
    e.use();
  }
  onPointerUp(e) {
    e.use();
  }
  onPointerClick(e) {
    e.use();
    this.onclick();
  }
};

// node_modules/@needle-tools/engine/lib/engine/webcomponents/needle menu/needle-menu.js
var elementName2 = "needle-menu";
var debug28 = getParam("debugmenu");
var debugNonCommercial = getParam("debugnoncommercial");
var NeedleMenu = class {
  constructor(context) {
    __publicField(this, "_context");
    __publicField(this, "_menu");
    __publicField(this, "_spatialMenu");
    __publicField(this, "onPostMessage", (e) => {
      if (e.origin !== globalThis.location.origin)
        return;
      if (typeof e.data === "object") {
        const data = e.data;
        const type = data.type;
        if (type === "needle:menu") {
          const buttoninfo = data.button;
          if (buttoninfo) {
            if (!buttoninfo.label)
              return console.error("NeedleMenu: buttoninfo.label is required");
            if (!buttoninfo.onclick)
              return console.error("NeedleMenu: buttoninfo.onclick is required");
            const button = document.createElement("button");
            button.textContent = buttoninfo.label;
            if (buttoninfo.icon) {
              const icon = getIconElement(buttoninfo.icon);
              button.prepend(icon);
            }
            if (buttoninfo.priority) {
              button.setAttribute("priority", buttoninfo.priority.toString());
            }
            button.onclick = () => {
              if (buttoninfo.onclick) {
                const isLink = buttoninfo.onclick.startsWith("http") || buttoninfo.onclick.startsWith("www.");
                const target = buttoninfo.target || "_blank";
                if (isLink) {
                  globalThis.open(buttoninfo.onclick, target);
                } else
                  console.error("NeedleMenu: onclick is not a valid link", buttoninfo.onclick);
              }
            };
            this._menu.appendChild(button);
          } else if (debug28)
            console.error("NeedleMenu: unknown postMessage event", data);
        } else if (debug28)
          console.warn("NeedleMenu: unknown postMessage type", type, data);
      }
    });
    __publicField(this, "onStartXR", (args) => {
      if (args.session.isScreenBasedAR) {
        this._menu["previousParent"] = this._menu.parentNode;
        this._context.arOverlayElement.appendChild(this._menu);
        args.session.session.addEventListener("end", this.onExitXR);
        this._menu.closeFoldout();
      }
    });
    __publicField(this, "onExitXR", () => {
      if (this._menu["previousParent"]) {
        this._menu["previousParent"].appendChild(this._menu);
        delete this._menu["previousParent"];
      }
    });
    __publicField(this, "_muteButton");
    __publicField(this, "_fullscreenButton");
    this._menu = NeedleMenuElement.getOrCreate(context.domElement, context);
    this._context = context;
    this._spatialMenu = new NeedleSpatialMenu(context, this._menu);
    window.addEventListener("message", this.onPostMessage);
    onXRSessionStart(this.onStartXR);
  }
  /** @ignore internal method */
  onDestroy() {
    window.removeEventListener("message", this.onPostMessage);
    this._menu.remove();
    this._spatialMenu.onDestroy();
  }
  /** Experimental: Change the menu position to be at the top or the bottom of the needle engine webcomponent
   * @param position "top" or "bottom"
   */
  setPosition(position) {
    this._menu.setPosition(position);
  }
  /**
   * Call to show or hide the menu.
   * NOTE: Hiding the menu is a PRO feature and requires a needle engine license. Hiding the menu will not work in production without a license.
   */
  setVisible(visible) {
    this._menu.setVisible(visible);
  }
  /** When set to false, the Needle Engine logo will be hidden. Hiding the logo requires a needle engine license */
  showNeedleLogo(visible) {
    var _a2;
    this._menu.showNeedleLogo(visible);
    (_a2 = this._spatialMenu) == null ? void 0 : _a2.showNeedleLogo(visible);
  }
  /** When enabled=true the menu will be visible in VR/AR sessions */
  showSpatialMenu(enabled) {
    this._spatialMenu.setEnabled(enabled);
  }
  setSpatialMenuVisible(display) {
    this._spatialMenu.setDisplay(display);
  }
  get spatialMenuIsVisible() {
    return this._spatialMenu.isVisible;
  }
  /**
   * Call to add or remove a button to the menu to show a QR code for the current page
   * If enabled=true then a button will be added to the menu that will show a QR code for the current page when clicked.
   */
  showQRCodeButton(enabled) {
    if (enabled === "desktop-only") {
      enabled = !DeviceUtilities.isMobileDevice();
    }
    if (!enabled) {
      const button = ButtonsFactory.getOrCreate().qrButton;
      if (button)
        button.style.display = "none";
      return button ?? null;
    } else {
      const button = ButtonsFactory.getOrCreate().createQRCode();
      button.style.display = "";
      this._menu.appendChild(button);
      return button;
    }
  }
  /** Call to add or remove a button to the menu to mute or unmute the application
   * Clicking the button will mute or unmute the application
  */
  showAudioPlaybackOption(visible) {
    var _a2;
    if (!visible) {
      (_a2 = this._muteButton) == null ? void 0 : _a2.remove();
      return;
    }
    this._muteButton = ButtonsFactory.getOrCreate().createMuteButton(this._context);
    this._muteButton.setAttribute("priority", "100");
    this._menu.appendChild(this._muteButton);
  }
  showFullscreenOption(visible) {
    var _a2;
    if (!visible) {
      (_a2 = this._fullscreenButton) == null ? void 0 : _a2.remove();
      return;
    }
    this._fullscreenButton = ButtonsFactory.getOrCreate().createFullscreenButton(this._context);
    if (this._fullscreenButton) {
      this._fullscreenButton.setAttribute("priority", "150");
      this._menu.appendChild(this._fullscreenButton);
    }
  }
  appendChild(child) {
    return this._menu.appendChild(child);
  }
};
var _onClick, _onSetLogoVisible, onSetLogoVisible_fn;
var _NeedleMenuElement = class extends HTMLElement {
  constructor() {
    var _a2, _b, _c, _d, _e, _f;
    super();
    __privateAdd(this, _onSetLogoVisible);
    __publicField(this, "_domElement", null);
    __publicField(this, "_context", null);
    __publicField(this, "_sizeChangeInterval");
    __privateAdd(this, _onClick, (e) => {
      if (!e.defaultPrevented && e.target == this._domElement && (e instanceof PointerEvent && e.button === 0) && this.root.classList.contains("open")) {
        const rect = this.foldout.getBoundingClientRect();
        const pointerEvent = e;
        if (!(pointerEvent.clientX > rect.left && pointerEvent.clientX < rect.right && pointerEvent.clientY > rect.top && pointerEvent.clientY < rect.bottom)) {
          this.root.classList.toggle("open", false);
        }
      }
    });
    __publicField(this, "_userRequestedLogoVisible");
    __publicField(this, "_userRequestedMenuVisible");
    // private _root: ShadowRoot | null = null;
    __publicField(this, "root");
    /** wraps the whole content */
    __publicField(this, "wrapper");
    /** contains the buttons and dynamic elements */
    __publicField(this, "options");
    /** contains the needle-logo html element */
    __publicField(this, "logoContainer");
    __publicField(this, "compactMenuButton");
    __publicField(this, "foldout");
    __publicField(this, "_isHandlingChange", false);
    __publicField(this, "_didSort", /* @__PURE__ */ new Map());
    __publicField(this, "_lastAvailableWidthChange", 0);
    __publicField(this, "_timeoutHandle", 0);
    __publicField(this, "handleSizeChange", (_evt, forceOrEvent) => {
      if (!this._domElement)
        return;
      const width = this._domElement.clientWidth;
      if (width < 100) {
        clearTimeout(this._timeoutHandle);
        this.root.classList.add("compact");
        this.foldout.classList.add("floating-panel-style");
        return;
      }
      const padding = 20 * 2;
      const availableWidth = width - padding;
      if (!forceOrEvent && Math.abs(availableWidth - this._lastAvailableWidthChange) < 1)
        return;
      this._lastAvailableWidthChange = availableWidth;
      clearTimeout(this._timeoutHandle);
      this._timeoutHandle = setTimeout(() => {
        const spaceLeft = getSpaceLeft();
        if (spaceLeft < 0) {
          this.root.classList.add("compact");
          this.foldout.classList.add("floating-panel-style");
        } else if (spaceLeft > 0) {
          this.root.classList.remove("compact");
          this.foldout.classList.remove("floating-panel-style");
          if (getSpaceLeft() < 0) {
            this.root.classList.add("compact");
            this.foldout.classList.add("floating-panel-style");
          }
        }
      }, 5);
      const getCurrentWidth = () => {
        return this.options.clientWidth + this.logoContainer.clientWidth;
      };
      const getSpaceLeft = () => {
        return availableWidth - getCurrentWidth();
      };
    });
    const template = document.createElement("template");
    template.innerHTML = `<style>

        #root {
            position: absolute;
            width: auto;
            max-width: 95%;
            left: 50%;
            transform: translateX(-50%);
            top: min(20px, 10vh);
            padding: 0.3rem;
            display: flex;
            visibility: visible;
            flex-direction: row-reverse; /* if we overflow this should be right aligned so the logo is always visible */
            pointer-events: all;
            z-index: 1000;
        }

        /** hide the menu if it's empty **/
        #root.has-no-options.logo-hidden {
            display: none; 
        }

        /** using a div here because then we can change the class for placement **/
        #root.bottom {
            top: auto;
            bottom: min(30px, 10vh);
        }
        #root.top {
            top: calc(.7rem + env(safe-area-inset-top));
        }
        
        .wrapper {
            position: relative;
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: stretch;
            gap: 0px;
            padding: 0 0rem;
        }

        .wrapper > *, .options > button, .options > select, ::slotted(*) {
            position: relative;
            border: none;
            border-radius: 0;
            outline: 1px solid rgba(0,0,0,0);
            display: flex;
            justify-content: center;
            align-items: center;
            max-height: 2.3rem;
            max-width: 100%;

            /** basic font settings for all entries **/
            font-size: 1rem;
            font-family: 'Roboto Flex', sans-serif;
            font-optical-sizing: auto;
            font-weight: 500;
            font-weight: 200;
            font-variation-settings: "wdth" 100;
            color: rgb(20,20,20);
        }

        .floating-panel-style {
            background: rgba(255, 255, 255, .4);
            outline: rgb(0 0 0 / 5%) 1px solid;
            border: 1px solid rgba(255, 255, 255, .1);
            box-shadow: 0px 7px 0.5rem 0px rgb(0 0 0 / 6%), inset 0px 0px 1.3rem rgba(0,0,0,.05);
            border-radius: 1.5rem;
            /** 
             * to make nested background filter work 
             * https://stackoverflow.com/questions/60997948/backdrop-filter-not-working-for-nested-elements-in-chrome 
             **/
            &::before {
                content: '';
                position: absolute;
                width: 100%;
                height: 100%;
                top: 0;
                left: 0;
                z-index: -1;
                border-radius: 1.5rem;
                -webkit-backdrop-filter: blur(8px);
                backdrop-filter: blur(8px);
            }
        }

        a {
            color: inherit;
            text-decoration: none;
        }

        .options {
            display: flex;
            flex-direction: row;
            align-items: center;
        }

        .options > *, ::slotted(*) {
            max-height: 2.25rem;
            padding: .4rem .5rem;
        }
        
        :host .options > *, ::slotted(*) {
            background: transparent;
            border: none;
            white-space: nowrap;
            transition: all 0.1s linear .02s;
            border-radius: 1.5rem;
            user-select: none;
        }
        :host .options > *:hover, ::slotted(*:hover) {
            cursor: pointer;
            color: black;
            background: rgba(245, 245, 245, .8);
            box-shadow: inset 0 0 1rem rgba(0,0,30,.2);
            outline: rgba(0,0,0,.1) 1px solid;
        }
        :host .options > *:active, ::slotted(*:active) {
            background: rgba(255, 255, 255, .8);
            box-shadow: inset 0px 1px 1px rgba(255,255,255,.5), inset 0 0 2rem rgba(0,0,30,.2), inset 0px 2px 4px rgba(0,0,20,.5);
            transition: all 0.05s linear;
        }
        :host .options > *:focus, ::slotted(*:focus) {
            outline: rgba(255,255,255,.5) 1px solid;
        }
        :host .options > *:focus-visible, ::slotted(*:focus-visible) {
            outline: rgba(0,0,0,.5) 1px solid;
        }

        :host .options > *:disabled, ::slotted(*:disabled) {
            background: rgba(0,0,0,.05);
            color: rgba(60,60,60,.7);
            pointer-events: none;
        }

        button, ::slotted(button) {
            gap: 0.3rem;
        }

        /** XR button animation **/
        :host button.this-mode-is-requested {
            background: repeating-linear-gradient(to right, #fff 0%, #fff 40%, #aaffff 55%, #fff 80%);
            background-size: 200% auto;
            background-position: 0 100%;
            animation: AnimationName .7s ease infinite forwards;
        }
        :host button.other-mode-is-requested {
            opacity: .5;
        }
        
        @keyframes AnimationName {
            0% { background-position: 0% 0 }
            100% { background-position: -200% 0 }
        }




        .logo {
            cursor: pointer;
            padding-left: 0.6rem;
            padding-bottom: .02rem;
            margin-right: 0.5rem;
        }
        .logo-hidden {
            .logo {
                display: none;
            }
        }
        :host .has-options .logo {
            border-left: 1px solid rgba(40,40,40,.4);
            margin-left: 0.3rem;
            margin-right: 0.5rem;
        }

        .logo > span {
            white-space: nowrap;
        }



        /** COMPACT */

        /** Hide the menu button normally **/
        .compact-menu-button { display: none; }
        /** And show it when we're in compact mode **/
        .compact .compact-menu-button {
            position: relative;
            display: block;
            background: none;
            border: none;
            border-radius: 2rem;

            margin: 0;
            padding: 0 .3rem;
            padding-top: .2rem;

            z-index: 100;

            color: #000;

            &:hover {
                background: rgba(255,255,255,.2);
                cursor: pointer;
            }
            &:focus {
                outline: 1px solid rgba(255,255,255,.5);
            }
            &:focus-visible {
                outline: 1px solid rgba(0,0,0,.5);
            }
            & .expanded-click-area {
                position: absolute;
                left: 0;
                right: 0;
                top: 10%;
                bottom: 10%;
                transform: scale(1.8);
            }
        }  
        .has-no-options .compact-menu-button {
            display: none;
        }
        .open .compact-menu-button {
            background: rgba(255,255,255,.2);
        }
        .logo-visible .compact-menu-button { 
            margin-left: .2rem;
        }
        
        /** Open and hide menu **/
        .compact .foldout { 
            display: none;
        }
        .open .options, .open .foldout {
            display: flex;
            justify-content: center;
        }
        .compact .wrapper {
            padding: 0;
        }
        .compact .wrapper, .compact .options {
            height: auto;
            max-height: initial;
            flex-direction: row;
            gap: .12rem;
        }
        .compact .options { 
            flex-wrap: wrap;
            gap: .3rem;
        }
        .compact .top .options {
            height: auto;
            flex-direction: row;
        }
        .compact .bottom .wrapper {
            height: auto;
            flex-direction: column;
        }

        .compact .foldout {
            max-height: min(100ch, calc(100vh - 100px));
            overflow: auto;
            overflow-x: hidden;
            align-items: center;

            position: fixed;
            bottom: calc(100% + 5px);
            z-index: 100;
            width: auto;
            left: .2rem;
            right: .2rem;
            padding: .2rem;

        }
        .compact.logo-hidden .foldout {
            /** for when there's no logo we want to center the foldout **/
            min-width: 24ch;
            margin-left: 50%;
            transform: translateX(calc(-50% - .2rem));
        }
        
        .compact.top .foldout {
            top: calc(100% + 5px);
            bottom: auto;
        }

        ::-webkit-scrollbar {
            max-width: 7px;
            background: rgba(100,100,100,.2);
            border-radius: .2rem;
        }
        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, .3);
            border-radius: .2rem;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: rgb(150,150,150);
        }

        .compact .options > *, .compact .options > ::slotted(*) {
            font-size: 1.2rem;
            padding: .6rem .5rem;
            width: 100%;
        }
        .compact.has-options .logo {
            border: none;
            padding-left: 0;
            margin-left: 1rem;
            margin-bottom: .02rem;
        }
        .compact .options {
            /** e.g. if we have a very wide menu item like a select with long option names we don't want to overflow **/
            max-width: 100%;

            & > button, & > select {
                display: flex;
                flex-basis: 100%;
                min-height: 3rem;
            }
            & > button.row2 {
                //border: 1px solid red !important;
                display: flex;
                flex: 1;
                flex-basis: 30%;
            }
        }

        /** If there's really not enough space then just hide all options **/
        @media (max-width: 100px) or (max-height: 100px){
            .foldout {
                display: none !important;
            }
            .compact-menu-button {
                display: none !important;
            }
        }
        
        /* dark mode */
        /*
        @media (prefers-color-scheme: dark) {
            :host {
                background: rgba(0,0,0, .6);
            }
            :host button {
                color: rgba(200,200,200);
            }
            :host button:hover {
                background: rgba(100,100,100, .8);
            }
        }
        */

        </style>
        
        <div id="root" class="logo-visible floating-panel-style bottom">
            <div class="wrapper">
                <div class="foldout">
                    <div class="options" part="options">
                        <slot></slot>
                    </div>
                    <div class="options" part="options">
                        <slot name="end"></slot>
                    </div>
                </div>
                <div style="user-select:none" class="logo">
                    <span class="madewith notranslate">powered by</span>
                </div>
            </div>
            <button class="compact-menu-button">
                <div class="expanded-click-area"></div>
            </button>
        </div>
        `;
    const shadow = this.attachShadow({ mode: "open" });
    ensureFonts();
    loadFont2(iconFontUrl, { loadedCallback: () => {
      this.handleSizeChange();
    } });
    loadFont2(iconFontUrl, { element: shadow });
    const content = template.content.cloneNode(true);
    shadow == null ? void 0 : shadow.appendChild(content);
    this.root = shadow.querySelector("#root");
    this.wrapper = (_a2 = this.root) == null ? void 0 : _a2.querySelector(".wrapper");
    this.options = (_b = this.root) == null ? void 0 : _b.querySelector(".options");
    this.logoContainer = (_c = this.root) == null ? void 0 : _c.querySelector(".logo");
    this.compactMenuButton = (_d = this.root) == null ? void 0 : _d.querySelector(".compact-menu-button");
    this.compactMenuButton.append(getIconElement("more_vert"));
    this.foldout = (_e = this.root) == null ? void 0 : _e.querySelector(".foldout");
    (_f = this.root) == null ? void 0 : _f.appendChild(this.wrapper);
    this.wrapper.classList.add("wrapper");
    const logo = NeedleLogoElement.create();
    logo.style.minHeight = "1rem";
    this.logoContainer.append(logo);
    this.logoContainer.addEventListener("click", () => {
      globalThis.open("https://needle.tools", "_blank");
    });
    try {
      onLicenseCheckResultChanged((res) => {
        if (res == true && hasCommercialLicense() && !debugNonCommercial) {
          let visible = this._userRequestedLogoVisible;
          if (visible === void 0)
            visible = false;
          __privateMethod(this, _onSetLogoVisible, onSetLogoVisible_fn).call(this, visible);
        }
      });
    } catch (e) {
      console.error("[Needle Menu] License check failed.", e);
    }
    this.compactMenuButton.addEventListener("click", (evt) => {
      evt.preventDefault();
      this.root.classList.toggle("open");
    });
    let context = this._context;
    setTimeout(() => context = this._context);
    let changeEventCounter = 0;
    const forceVisible = (parent, visible) => {
      var _a3, _b2, _c2;
      if (debug28)
        console.log("Set menu visible", visible);
      if ((context == null ? void 0 : context.isInAR) && context.arOverlayElement) {
        if (parent != context.arOverlayElement) {
          context.arOverlayElement.appendChild(this);
        }
      } else if (this.parentNode != ((_a3 = this._domElement) == null ? void 0 : _a3.shadowRoot))
        (_c2 = (_b2 = this._domElement) == null ? void 0 : _b2.shadowRoot) == null ? void 0 : _c2.appendChild(this);
      this.style.display = visible ? "flex" : "none";
      this.style.visibility = "visible";
      this.style.opacity = "1";
    };
    let isHandlingMutation = false;
    const rootObserver = new MutationObserver((mutations) => {
      var _a3;
      if (isHandlingMutation) {
        return;
      }
      try {
        isHandlingMutation = true;
        this.onChangeDetected(mutations);
        const requiredParent = this == null ? void 0 : this.parentNode;
        if (this.style.display != "flex" || this.style.visibility != "visible" || this.style.opacity != "1" || requiredParent != ((_a3 = this._domElement) == null ? void 0 : _a3.shadowRoot)) {
          if (!hasCommercialLicense()) {
            const change = changeEventCounter++;
            if (isLocalNetwork() && this._userRequestedMenuVisible === false) {
              if (change === 0) {
                forceVisible(requiredParent, this._userRequestedMenuVisible);
              }
              if (change === 1) {
                console.warn(`Needle Menu Warning: You need a PRO license to hide the Needle Engine menu → The menu will be visible in your deployed website if you don't have a PRO license. See https://needle.tools/pricing for details.`);
              }
            } else {
              if (change === 0) {
                forceVisible(requiredParent, true);
              } else {
                setTimeout(() => forceVisible(requiredParent, true), 5);
              }
            }
          }
        }
      } finally {
        isHandlingMutation = false;
      }
    });
    rootObserver.observe(this.root, { childList: true, subtree: true, attributes: true });
    if (debug28) {
      this.___insertDebugOptions();
    }
  }
  static create() {
    return document.createElement(elementName2, { is: elementName2 });
  }
  static getOrCreate(domElement, context) {
    let element = domElement.querySelector(elementName2);
    if (!element && domElement.shadowRoot) {
      element = domElement.shadowRoot.querySelector(elementName2);
    }
    if (!element) {
      element = _NeedleMenuElement.create();
      if (domElement.shadowRoot)
        domElement.shadowRoot.appendChild(element);
      else
        domElement.appendChild(element);
    }
    element._domElement = domElement;
    element._context = context;
    return element;
  }
  connectedCallback() {
    window.addEventListener("resize", this.handleSizeChange);
    this.handleMenuVisible();
    this._sizeChangeInterval = setInterval(() => this.handleSizeChange(void 0, true), 5e3);
    setTimeout(() => {
      var _a2, _b;
      (_a2 = this._domElement) == null ? void 0 : _a2.addEventListener("resize", this.handleSizeChange);
      (_b = this._domElement) == null ? void 0 : _b.addEventListener("click", __privateGet(this, _onClick));
    }, 1);
  }
  disconnectedCallback() {
    var _a2, _b;
    window.removeEventListener("resize", this.handleSizeChange);
    clearInterval(this._sizeChangeInterval);
    (_a2 = this._domElement) == null ? void 0 : _a2.removeEventListener("resize", this.handleSizeChange);
    (_b = this._context) == null ? void 0 : _b.domElement.removeEventListener("click", __privateGet(this, _onClick));
  }
  showNeedleLogo(visible) {
    this._userRequestedLogoVisible = visible;
    if (!visible) {
      if (!hasCommercialLicense() || debugNonCommercial) {
        console.warn("Needle Menu: You need a PRO license to hide the Needle Engine logo.");
        const localNetwork = isLocalNetwork();
        if (!localNetwork)
          return;
      }
    }
    __privateMethod(this, _onSetLogoVisible, onSetLogoVisible_fn).call(this, visible);
  }
  setPosition(position) {
    if (position !== "top" && position !== "bottom") {
      return console.error("NeedleMenu.setPosition: invalid position", position);
    }
    this.root.classList.remove("top", "bottom");
    this.root.classList.add(position);
  }
  setVisible(visible) {
    this._userRequestedMenuVisible = visible;
    this.style.display = visible ? "flex" : "none";
  }
  /**
   * If the menu is in compact mode and the foldout is currently open (to show all menu options) then this will close the foldout
   */
  closeFoldout() {
    this.root.classList.remove("open");
  }
  append(...nodes) {
    for (const node of nodes) {
      if (typeof node === "string") {
        const element = document.createTextNode(node);
        this.options.appendChild(element);
      } else {
        this.options.appendChild(node);
      }
    }
  }
  appendChild(node) {
    var _a2;
    if (!(node instanceof Node)) {
      const button = document.createElement("button");
      button.textContent = node.label;
      button.onclick = node.onClick;
      button.setAttribute("priority", ((_a2 = node.priority) == null ? void 0 : _a2.toString()) ?? "0");
      if (node.title) {
        button.title = node.title;
      }
      if (node.icon) {
        const icon = getIconElement(node.icon);
        if (node.iconSide === "right") {
          button.appendChild(icon);
        } else {
          button.prepend(icon);
        }
      }
      if (node.class) {
        button.classList.add(node.class);
      }
      node = button;
    }
    const res = this.options.appendChild(node);
    return res;
  }
  prepend(...nodes) {
    for (const node of nodes) {
      if (typeof node === "string") {
        const element = document.createTextNode(node);
        this.options.prepend(element);
      } else {
        this.options.prepend(node);
      }
    }
  }
  /** Called when any change in the web component is detected (including in children and child attributes) */
  onChangeDetected(_mut) {
    if (this._isHandlingChange)
      return;
    this._isHandlingChange = true;
    try {
      this.handleMenuVisible();
      for (const mut of _mut) {
        if (mut.target == this.options) {
          this.onOptionsChildrenChanged(mut);
        }
      }
    } finally {
      this._isHandlingChange = false;
    }
  }
  onOptionsChildrenChanged(_mut) {
    this.root.classList.toggle("has-options", this.hasAnyVisibleOptions);
    this.root.classList.toggle("has-no-options", !this.hasAnyVisibleOptions);
    this.handleSizeChange(void 0, true);
    if (_mut.type === "childList") {
      if (_mut.addedNodes.length > 0) {
        const children = Array.from(this.options.children);
        children.sort((a, b) => {
          const p1 = parseInt(a.getAttribute("priority") || "0");
          const p2 = parseInt(b.getAttribute("priority") || "0");
          return p1 - p2;
        });
        let sortingChanged = false;
        for (let i = 0; i < children.length; i++) {
          const existing = this.options.children[i];
          const child = children[i];
          if (existing !== child) {
            sortingChanged = true;
            break;
          }
        }
        if (sortingChanged) {
          for (const child of children) {
            this.options.appendChild(child);
          }
        }
      }
    }
  }
  /** checks if the menu has any content and should be rendered at all
   * if we dont have any content and logo then we hide the menu
   */
  handleMenuVisible() {
    if (debug28)
      console.log("Update VisibleState: Any Content?", this.hasAnyContent);
    if (this.hasAnyContent) {
      this.root.style.display = "";
    } else {
      this.root.style.display = "none";
    }
    this.root.classList.toggle("has-options", this.hasAnyVisibleOptions);
    this.root.classList.toggle("has-no-options", !this.hasAnyVisibleOptions);
  }
  /** @returns true if we have any content OR a logo */
  get hasAnyContent() {
    if (this.logoContainer.style.display != "none")
      return true;
    if (this.hasAnyVisibleOptions)
      return true;
    return false;
  }
  get hasAnyVisibleOptions() {
    for (let i = 0; i < this.options.children.length; i++) {
      const child = this.options.children[i];
      if (child.tagName === "SLOT") {
        const slotElement = child;
        const nodes = slotElement.assignedNodes();
        for (const node of nodes) {
          if (node instanceof HTMLElement) {
            if (node.style.display != "none")
              return true;
          }
        }
      } else if (child.style.display != "none")
        return true;
    }
    return false;
  }
  ___insertDebugOptions() {
    window.addEventListener("keydown", (e) => {
      if (e.key === "p") {
        this.setPosition(this.root.classList.contains("top") ? "bottom" : "top");
      }
    });
    const removeOptionsButton = document.createElement("button");
    removeOptionsButton.textContent = "Hide Buttons";
    removeOptionsButton.onclick = () => {
      const optionsChildren = new Array(this.options.children.length);
      for (let i = 0; i < this.options.children.length; i++) {
        optionsChildren[i] = this.options.children[i];
      }
      for (const child of optionsChildren) {
        this.options.removeChild(child);
      }
      setTimeout(() => {
        for (const child of optionsChildren) {
          this.options.appendChild(child);
        }
      }, 1e3);
    };
    this.appendChild(removeOptionsButton);
    const anotherButton = document.createElement("button");
    anotherButton.textContent = "Toggle Logo";
    anotherButton.addEventListener("click", () => {
      this.logoContainer.style.display = this.logoContainer.style.display === "none" ? "" : "none";
    });
    this.appendChild(anotherButton);
  }
};
var NeedleMenuElement = _NeedleMenuElement;
_onClick = new WeakMap();
_onSetLogoVisible = new WeakSet();
onSetLogoVisible_fn = function(visible) {
  this.logoContainer.style.display = "";
  this.logoContainer.style.opacity = "1";
  this.logoContainer.style.visibility = "visible";
  if (visible) {
    this.root.classList.remove("logo-hidden");
    this.root.classList.add("logo-visible");
  } else {
    this.root.classList.remove("logo-visible");
    this.root.classList.add("logo-hidden");
  }
};
if (!customElements.get(elementName2))
  customElements.define(elementName2, NeedleMenuElement);

// node_modules/@needle-tools/engine/lib/engine/engine_context.js
var debug29 = getParam("debugcontext");
var stats = getParam("stats");
var debugActive = getParam("debugactive");
var debugframerate = getParam("debugframerate");
var debugCoroutine = getParam("debugcoroutine");
var build_scene_functions = {};
var ContextArgs = class {
  constructor() {
    __publicField(this, "name");
    /** for debugging only */
    __publicField(this, "alias");
    /** the hash is used as a seed when initially loading the scene files */
    __publicField(this, "hash");
    /** when true the context will not check if it's visible in the viewport and always update and render */
    __publicField(this, "runInBackground");
    /** the DOM element the context belongs to or is inside of (this does not have to be the canvas. use renderer.domElement if you want to access the dom canvas) */
    __publicField(this, "domElement");
    /** externally owned renderer */
    __publicField(this, "renderer");
    /** externally owned camera */
    __publicField(this, "camera");
    /** externally owned scene */
    __publicField(this, "scene");
  }
};
var FrameEvent;
(function(FrameEvent2) {
  FrameEvent2[FrameEvent2["Start"] = -1] = "Start";
  FrameEvent2[FrameEvent2["EarlyUpdate"] = 0] = "EarlyUpdate";
  FrameEvent2[FrameEvent2["Update"] = 1] = "Update";
  FrameEvent2[FrameEvent2["LateUpdate"] = 2] = "LateUpdate";
  FrameEvent2[FrameEvent2["OnBeforeRender"] = 3] = "OnBeforeRender";
  FrameEvent2[FrameEvent2["OnAfterRender"] = 4] = "OnAfterRender";
  FrameEvent2[FrameEvent2["PrePhysicsStep"] = 9] = "PrePhysicsStep";
  FrameEvent2[FrameEvent2["PostPhysicsStep"] = 10] = "PostPhysicsStep";
  FrameEvent2[FrameEvent2["Undefined"] = -1] = "Undefined";
})(FrameEvent || (FrameEvent = {}));
function registerComponent(script, context) {
  if (!script)
    return;
  if (!script.isComponent) {
    if (isDevEnvironment() || debug29)
      console.error('Registered script is not a Needle Engine component. \nThe script will be ignored. Please make sure your component extends "Behaviour" imported from "@needle-tools/engine"\n', script);
    return;
  }
  if (!context) {
    context = Context.Current;
    if (debug29)
      console.warn("> Registering component without context");
  }
  const new_scripts = context == null ? void 0 : context.new_scripts;
  if (!new_scripts.includes(script)) {
    new_scripts.push(script);
  }
}
var _Context = class {
  constructor(args) {
    /** The name of the context */
    __publicField(this, "name");
    /** An alias for the context */
    __publicField(this, "alias");
    /** When the renderer or camera are managed by an external process (e.g. when running in r3f context).
     * When this is false you are responsible to call update(timestamp, xframe.
     * It is also currently assumed that rendering is handled performed by an external process
     * */
    __publicField(this, "isManagedExternally", false);
    /** set to true to pause the update loop. You can receive an event for it in your components.
     * Note that script updates will not be called when paused */
    __publicField(this, "isPaused", false);
    /** When enabled the application will run while not visible on the page */
    __publicField(this, "runInBackground", false);
    /**
     * Set to the target framerate you want your application to run in (you can use ?stats to check the fps)
     * Set to undefined if you want to run at the maximum framerate
     */
    __publicField(this, "targetFrameRate");
    /** Use a higher number for more accurate physics simulation.
     * When undefined physics steps will be 1 for mobile devices and 5 for desktop devices
     * Set to 0 to disable physics updates
     * TODO: changing physics steps is currently not supported because then forces that we get from the character controller and rigidbody et al are not correct anymore - this needs to be properly tested before making this configureable
    */
    __publicField(this, "physicsSteps", 1);
    /** used to append to loaded assets */
    __publicField(this, "hash");
    /** The `<needle-engine>` web component */
    __publicField(this, "domElement");
    __publicField(this, "_resolutionScaleFactor", 1);
    // domElement.clientLeft etc doesnt return absolute position
    __publicField(this, "_boundingClientRectFrame", -1);
    __publicField(this, "_boundingClientRect", null);
    __publicField(this, "_domX");
    __publicField(this, "_domY");
    /** shorthand for `NeedleXRSession.active`
     * Automatically set by NeedleXRSession when a XR session is active
     * @returns the active XR session or null if no session is active
     * */
    __publicField(this, "xr", null);
    __publicField(this, "_xrFrame", null);
    __publicField(this, "_currentFrameEvent", FrameEvent.Undefined);
    __publicField(this, "scene");
    __publicField(this, "renderer");
    __publicField(this, "composer", null);
    // all scripts
    __publicField(this, "scripts", []);
    __publicField(this, "scripts_pausedChanged", []);
    // scripts with update event
    __publicField(this, "scripts_earlyUpdate", []);
    __publicField(this, "scripts_update", []);
    __publicField(this, "scripts_lateUpdate", []);
    __publicField(this, "scripts_onBeforeRender", []);
    __publicField(this, "scripts_onAfterRender", []);
    __publicField(this, "scripts_WithCorroutines", []);
    __publicField(this, "scripts_immersive_vr", []);
    __publicField(this, "scripts_immersive_ar", []);
    __publicField(this, "coroutines", {});
    /** callbacks called once after the context has been created */
    __publicField(this, "post_setup_callbacks", []);
    /** called every frame at the beginning of the frame (after component start events and before earlyUpdate) */
    __publicField(this, "pre_update_callbacks", []);
    /** called every frame before rendering (after all component events) */
    __publicField(this, "pre_render_callbacks", []);
    /** called every frame after rendering (after all component events) */
    __publicField(this, "post_render_callbacks", []);
    /** called every frame befroe update (this list is emptied every frame) */
    __publicField(this, "pre_update_oneshot_callbacks", []);
    __publicField(this, "new_scripts", []);
    __publicField(this, "new_script_start", []);
    __publicField(this, "new_scripts_pre_setup_callbacks", []);
    __publicField(this, "new_scripts_post_setup_callbacks", []);
    __publicField(this, "new_scripts_xr", []);
    /** The main camera component of the scene - this camera is used for rendering */
    __publicField(this, "mainCameraComponent");
    __publicField(this, "_mainCamera", null);
    __publicField(this, "_fallbackCamera", null);
    __publicField(this, "application");
    /** access animation mixer used by components in the scene */
    __publicField(this, "animations");
    /** access timings (current frame number, deltaTime, timeScale, ...) */
    __publicField(this, "time");
    __publicField(this, "input");
    /** access physics related methods (e.g. raycasting). To access the phyiscs engine use `context.physics.engine` */
    __publicField(this, "physics");
    /** access networking methods (use it to send or listen to messages or join a networking backend) */
    __publicField(this, "connection");
    /**
     * @deprecated AssetDataBase is deprecated
     */
    __publicField(this, "assets");
    __publicField(this, "mainLight", null);
    __publicField(this, "sceneLighting");
    __publicField(this, "addressables");
    __publicField(this, "lightmaps");
    __publicField(this, "players");
    __publicField(this, "lodsManager");
    __publicField(this, "menu");
    __publicField(this, "_sizeChanged", false);
    __publicField(this, "_isCreated", false);
    __publicField(this, "_isCreating", false);
    __publicField(this, "_isVisible", false);
    __publicField(this, "_stats", stats ? new stats_module_default() : null);
    __publicField(this, "_intersectionObserver", null);
    __publicField(this, "_disposeCallbacks", []);
    /** Clamps the renderer max resolution. If undefined the max resolution is not clamped. Default is undefined */
    __publicField(this, "maxRenderResolution");
    __publicField(this, "_originalCreationArgs");
    __publicField(this, "onUnhandledRejection", (event) => {
      this.onError(event.reason);
    });
    __publicField(this, "_cameraStack", []);
    __publicField(this, "_onBeforeRenderListeners", /* @__PURE__ */ new Map());
    __publicField(this, "_onAfterRenderListeners", /* @__PURE__ */ new Map());
    __publicField(this, "_requireDepthTexture", false);
    __publicField(this, "_requireColorTexture", false);
    __publicField(this, "_renderTarget");
    __publicField(this, "_isRendering", false);
    __publicField(this, "_createId", 0);
    __publicField(this, "_renderlooperrors", 0);
    __publicField(this, "_lastTimestamp", 0);
    __publicField(this, "_accumulatedTime", 0);
    __publicField(this, "_dispatchReadyAfterFrame", false);
    /** returns true if we should return out of the frame loop */
    __publicField(this, "_wasPaused", false);
    this.name = (args == null ? void 0 : args.name) || "";
    this.alias = args == null ? void 0 : args.alias;
    this.domElement = (args == null ? void 0 : args.domElement) || document.body;
    this.hash = args == null ? void 0 : args.hash;
    if (args == null ? void 0 : args.renderer) {
      this.renderer = args.renderer;
      this.isManagedExternally = true;
    }
    if ((args == null ? void 0 : args.runInBackground) !== void 0)
      this.runInBackground = args.runInBackground;
    if (args == null ? void 0 : args.scene)
      this.scene = args.scene;
    else
      this.scene = new Scene();
    if (args == null ? void 0 : args.camera)
      this._mainCamera = args.camera;
    this.application = new Application(this);
    this.time = new Time();
    this.input = new Input(this);
    this.physics = new Physics(this);
    this.connection = new NetworkConnection(this);
    this.assets = new AssetDatabase();
    this.sceneLighting = new RendererData(this);
    this.addressables = new Addressables(this);
    this.lightmaps = new LightDataRegistry(this);
    this.players = new PlayerViewManager(this);
    this.menu = new NeedleMenu(this);
    this.lodsManager = new LODsManager2(this);
    this.animations = new AnimationsRegistry(this);
    const resizeCallback = () => this._sizeChanged = true;
    window.addEventListener("resize", resizeCallback);
    this._disposeCallbacks.push(() => window.removeEventListener("resize", resizeCallback));
    const resizeObserver = new ResizeObserver((_) => this._sizeChanged = true);
    resizeObserver.observe(this.domElement);
    this._disposeCallbacks.push(() => resizeObserver.disconnect());
    this._intersectionObserver = new IntersectionObserver((entries) => {
      this._isVisible = entries[0].isIntersecting;
    });
    this._disposeCallbacks.push(() => {
      var _a2;
      return (_a2 = this._intersectionObserver) == null ? void 0 : _a2.disconnect();
    });
    ContextRegistry.register(this);
  }
  /** When a new context is created this is the framerate that will be used by default */
  static get DefaultTargetFrameRate() {
    return _Context._defaultTargetFramerate.value;
  }
  /** When a new context is created this is the framerate that will be used by default */
  static set DefaultTargetFrameRate(val) {
    _Context._defaultTargetFramerate.value = val;
  }
  /** The default parameters that will be used when creating a new WebGLRenderer.
   * Modify in global context to change the default parameters for all new contexts.
   * @example
   * ```typescript
   * import { Context } from "@needle-tools/engine";
   * Context.DefaultWebGLRendererParameters.antialias = false;
   * ```
   */
  static get DefaultWebGLRendererParameters() {
    return _Context._defaultWebglRendererParameters;
  }
  /** The needle engine version */
  get version() {
    return VERSION;
  }
  /** The currently active context. Only set during the update loops */
  static get Current() {
    return ContextRegistry.Current;
  }
  /** @internal this property should not be set by user code */
  static set Current(context) {
    ContextRegistry.Current = context;
  }
  appendHTMLElement(element) {
    if (this.domElement.shadowRoot)
      return this.domElement.shadowRoot.appendChild(element);
    else
      return this.domElement.appendChild(element);
  }
  get resolutionScaleFactor() {
    return this._resolutionScaleFactor;
  }
  /** use to scale the resolution up or down of the renderer. default is 1 */
  set resolutionScaleFactor(val) {
    if (val === this._resolutionScaleFactor)
      return;
    if (typeof val !== "number")
      return;
    if (val <= 0) {
      console.error("Invalid resolution scale factor", val);
      return;
    }
    this._resolutionScaleFactor = val;
    this.updateSize();
  }
  /** update bounding rects + domX, domY */
  calculateBoundingClientRect() {
    if (this.xr) {
      this._domX = 0;
      this._domY = 0;
      return;
    }
    if (this._boundingClientRectFrame === this.time.frame)
      return;
    this._boundingClientRectFrame = this.time.frame;
    this._boundingClientRect = this.domElement.getBoundingClientRect();
    this._domX = this._boundingClientRect.x;
    this._domY = this._boundingClientRect.y;
  }
  /** The width of the `<needle-engine>` element on the website */
  get domWidth() {
    if (this.isInAR)
      return window.innerWidth;
    return this.domElement.clientWidth;
  }
  /** The height of the `<needle-engine>` element on the website */
  get domHeight() {
    if (this.isInAR)
      return window.innerHeight;
    return this.domElement.clientHeight;
  }
  /** the X position of the Needle Engine element on the website */
  get domX() {
    this.calculateBoundingClientRect();
    return this._domX;
  }
  /** the Y position of the Needlee Engine element on the website */
  get domY() {
    this.calculateBoundingClientRect();
    return this._domY;
  }
  get isInXR() {
    var _a2, _b;
    return ((_b = (_a2 = this.renderer) == null ? void 0 : _a2.xr) == null ? void 0 : _b.isPresenting) || false;
  }
  get xrSessionMode() {
    var _a2;
    return (_a2 = this.xr) == null ? void 0 : _a2.mode;
  }
  get isInVR() {
    return this.xrSessionMode === "immersive-vr";
  }
  get isInAR() {
    return this.xrSessionMode === "immersive-ar";
  }
  /** If a XR session is active and in pass through mode (immersive-ar on e.g. Quest) */
  get isInPassThrough() {
    return this.xr ? this.xr.isPassThrough : false;
  }
  /** access the raw `XRSession` object (shorthand for `context.renderer.xr.getSession()`). For more control use `NeedleXRSession.active` */
  get xrSession() {
    var _a2, _b;
    return (_b = (_a2 = this.renderer) == null ? void 0 : _a2.xr) == null ? void 0 : _b.getSession();
  }
  /** @returns the latest XRFrame (if a XRSession is currently active)
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRFrame
   */
  get xrFrame() {
    return this._xrFrame;
  }
  /** @returns the current WebXR camera while the WebXRManager is active (shorthand for `context.renderer.xr.getCamera()`) */
  get xrCamera() {
    var _a2, _b;
    return this.renderer.xr.isPresenting ? (_b = (_a2 = this.renderer) == null ? void 0 : _a2.xr) == null ? void 0 : _b.getCamera() : void 0;
  }
  get arOverlayElement() {
    const el = this.domElement;
    if (typeof el.getAROverlayContainer === "function")
      return el.getAROverlayContainer();
    return this.domElement;
  }
  /** Current event of the update cycle */
  get currentFrameEvent() {
    return this._currentFrameEvent;
  }
  /** The main camera of the scene - this camera is used for rendering */
  get mainCamera() {
    if (this._mainCamera) {
      return this._mainCamera;
    }
    if (this.mainCameraComponent) {
      const cam = this.mainCameraComponent;
      if (!cam.threeCamera)
        cam.buildCamera();
      return cam.threeCamera;
    }
    if (!this._fallbackCamera) {
      this._fallbackCamera = new PerspectiveCamera(75, this.domWidth / this.domHeight, 0.1, 1e3);
    }
    return this._fallbackCamera;
  }
  /** Set the main camera of the scene. If set to null the camera of the {@link mainCameraComponent} will be used - this camera is used for rendering */
  set mainCamera(cam) {
    this._mainCamera = cam;
  }
  /** @deprecated Use sceneLighting */
  get rendererData() {
    return this.sceneLighting;
  }
  get isCreated() {
    return this._isCreated;
  }
  /** calling this function will dispose the current renderer and create a new one */
  createNewRenderer(params) {
    var _a2, _b, _c;
    (_a2 = this.renderer) == null ? void 0 : _a2.dispose();
    params = { ..._Context.DefaultWebGLRendererParameters, ...params };
    if (!params.canvas) {
      const canvas = (_c = (_b = this.domElement) == null ? void 0 : _b.shadowRoot) == null ? void 0 : _c.querySelector("canvas");
      if (canvas) {
        params.canvas = canvas;
        if (debug29) {
          console.log("Using canvas from shadow root", canvas);
        }
      }
    }
    if (debug29)
      console.log("Using Renderer Parameters:", params, this.domElement);
    this.renderer = new WebGLRenderer(params);
    this.renderer.debug.checkShaderErrors = isDevEnvironment() || getParam("checkshadererrors") === true;
    this.renderer.toneMappingExposure = 1;
    this.renderer.toneMapping = NoToneMapping;
    this.renderer.setClearColor(new Color("lightgrey"), 0);
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = PCFSoftShadowMap$1;
    this.renderer.setSize(this.domWidth, this.domHeight);
    this.renderer.outputColorSpace = SRGBColorSpace;
    this.renderer.nodes = {
      library: new BasicNodeLibrary(),
      modelViewMatrix: null,
      modelNormalViewMatrix: null
    };
    this.lodsManager.setRenderer(this.renderer);
    this.input.bindEvents();
  }
  internalOnUpdateVisible() {
    var _a2, _b;
    (_a2 = this._intersectionObserver) == null ? void 0 : _a2.disconnect();
    (_b = this._intersectionObserver) == null ? void 0 : _b.observe(this.domElement);
  }
  /** will request a renderer size update the next render call (will call updateSize the next update) */
  requestSizeUpdate() {
    this._sizeChanged = true;
  }
  /** update the renderer and canvas size */
  updateSize(force = false) {
    var _a2, _b, _c;
    if (force || !this.isManagedExternally && ((_a2 = this.renderer.xr) == null ? void 0 : _a2.isPresenting) === false) {
      this._sizeChanged = false;
      const scaleFactor = this.resolutionScaleFactor;
      let width = this.domWidth * scaleFactor;
      let height = this.domHeight * scaleFactor;
      if (this.maxRenderResolution) {
        this.maxRenderResolution.x = Math.max(1, this.maxRenderResolution.x);
        width = Math.min(this.maxRenderResolution.x, width);
        this.maxRenderResolution.y = Math.max(1, this.maxRenderResolution.y);
        height = Math.min(this.maxRenderResolution.y, height);
      }
      const camera = this.mainCamera;
      this.updateAspect(camera);
      this.renderer.setSize(width, height, true);
      this.renderer.setPixelRatio(window.devicePixelRatio);
      this.renderer.domElement.style.width = "100%";
      this.renderer.domElement.style.height = "100%";
      if (this.composer) {
        (_b = this.composer.setSize) == null ? void 0 : _b.call(this.composer, width, height);
        if ("setPixelRatio" in this.composer && typeof this.composer.setPixelRatio === "function")
          (_c = this.composer.setPixelRatio) == null ? void 0 : _c.call(this.composer, window.devicePixelRatio);
      }
    }
  }
  updateAspect(camera, width, height) {
    if (!camera)
      return;
    if (width === void 0)
      width = this.domWidth;
    if (height === void 0)
      height = this.domHeight;
    const pa = camera.aspect;
    camera.aspect = width / height;
    if (pa !== camera.aspect)
      camera.updateProjectionMatrix();
  }
  /** This will recreate the whole needle engine context and dispose the whole scene content
   * All content will be reloaded (loading times might be faster due to browser caches)
   * All scripts will be recreated */
  recreate() {
    this.clear();
    this.create(this._originalCreationArgs);
  }
  /** @deprecated use create. This method will be removed in a future version */
  async onCreate(opts) {
    return this.create(opts);
  }
  async create(opts) {
    try {
      this._isCreating = true;
      if (opts !== this._originalCreationArgs)
        this._originalCreationArgs = deepClone(opts);
      window.addEventListener("unhandledrejection", this.onUnhandledRejection);
      const res = await this.internalOnCreate(opts);
      this._isCreated = res;
      return res;
    } finally {
      window.removeEventListener("unhandledrejection", this.onUnhandledRejection);
      this._isCreating = false;
    }
  }
  /** Dispatches an error */
  onError(error) {
    this.domElement.dispatchEvent(new CustomEvent("error", { detail: error }));
  }
  /** Will destroy all scenes and objects in the scene
   */
  clear() {
    var _a2, _b, _c, _d;
    ContextRegistry.dispatchCallback(ContextEvent.ContextClearing, this);
    invokeLifecycleFunctions(this, ContextEvent.ContextClearing);
    destroy(this.scene, true, true);
    this.scene = new Scene();
    (_a2 = this.addressables) == null ? void 0 : _a2.dispose();
    (_b = this.lightmaps) == null ? void 0 : _b.clear();
    (_d = (_c = this.physics) == null ? void 0 : _c.engine) == null ? void 0 : _d.clearCaches();
    this.lodsManager.disable();
    if (!this.isManagedExternally) {
      if (this.renderer) {
        this.renderer.renderLists.dispose();
        this.renderer.state.reset();
        this.renderer.resetState();
      }
    }
    ContextRegistry.dispatchCallback(ContextEvent.ContextCleared, this);
  }
  dispose() {
    this.internalOnDestroy();
  }
  /**@deprecated use dispose()  */
  onDestroy() {
    this.internalOnDestroy();
  }
  internalOnDestroy() {
    var _a2, _b;
    _Context.Current = this;
    ContextRegistry.dispatchCallback(ContextEvent.ContextDestroying, this);
    invokeLifecycleFunctions(this, ContextEvent.ContextDestroying);
    this.clear();
    (_a2 = this.renderer) == null ? void 0 : _a2.setAnimationLoop(null);
    if (this.renderer) {
      this.renderer.setClearAlpha(0);
      this.renderer.clear();
      if (!this.isManagedExternally) {
        if (debug29)
          console.log("Disposing renderer");
        this.renderer.dispose();
      }
    }
    this.scene = null;
    this.renderer = null;
    this.input.dispose();
    this.menu.onDestroy();
    this.animations.onDestroy();
    for (const cb of this._disposeCallbacks) {
      try {
        cb();
      } catch (e) {
        console.error("Error in on dispose callback:", e, cb);
      }
    }
    if ((_b = this.domElement) == null ? void 0 : _b.parentElement) {
      this.domElement.parentElement.removeChild(this.domElement);
    }
    this._isCreated = false;
    ContextRegistry.dispatchCallback(ContextEvent.ContextDestroyed, this);
    invokeLifecycleFunctions(this, ContextEvent.ContextDestroyed);
    ContextRegistry.unregister(this);
    if (_Context.Current === this) {
      _Context.Current = null;
    }
  }
  registerCoroutineUpdate(script, coroutine, evt) {
    if (typeof (coroutine == null ? void 0 : coroutine.next) !== "function") {
      console.error("Registered invalid coroutine function from " + script.name + '\nCoroutine functions must be generators: "*myCoroutine() {...}"\nStart a coroutine from a component by calling "this.startCoroutine(myCoroutine())"');
      return coroutine;
    }
    if (!this.coroutines[evt])
      this.coroutines[evt] = [];
    this.coroutines[evt].push({ comp: script, main: coroutine });
    return coroutine;
  }
  unregisterCoroutineUpdate(coroutine, evt) {
    if (!this.coroutines[evt])
      return;
    const idx = this.coroutines[evt].findIndex((c2) => c2.main === coroutine);
    if (idx >= 0)
      this.coroutines[evt].splice(idx, 1);
  }
  stopAllCoroutinesFrom(script) {
    for (const evt in this.coroutines) {
      const rout = this.coroutines[evt];
      for (let i = rout.length - 1; i >= 0; i--) {
        const r = rout[i];
        if (r.comp === script) {
          rout.splice(i, 1);
        }
      }
    }
  }
  setCurrentCamera(cam) {
    var _a2;
    if (!cam)
      return;
    if (!cam.threeCamera)
      cam.buildCamera();
    if (!cam.threeCamera) {
      console.warn("Camera component is missing camera", cam);
      return;
    }
    const index = this._cameraStack.indexOf(cam);
    if (index >= 0)
      this._cameraStack.splice(index, 1);
    this._cameraStack.push(cam);
    this.mainCameraComponent = cam;
    const camera = cam.threeCamera;
    if (camera.isPerspectiveCamera)
      this.updateAspect(camera);
    (_a2 = this.mainCameraComponent) == null ? void 0 : _a2.applyClearFlagsIfIsActiveCamera();
  }
  removeCamera(cam) {
    if (!cam)
      return;
    const index = this._cameraStack.indexOf(cam);
    if (index >= 0)
      this._cameraStack.splice(index, 1);
    if (this.mainCameraComponent === cam) {
      this.mainCameraComponent = void 0;
      if (this._cameraStack.length > 0) {
        const last = this._cameraStack[this._cameraStack.length - 1];
        this.setCurrentCamera(last);
      }
    }
  }
  /** use this to subscribe to onBeforeRender events on threejs objects */
  addBeforeRenderListener(target, callback) {
    if (!this._onBeforeRenderListeners.has(target.uuid)) {
      this._onBeforeRenderListeners.set(target.uuid, []);
      target.onBeforeRender = this._createRenderCallbackWrapper(target, this._onBeforeRenderListeners);
    }
    this._onBeforeRenderListeners.get(target.uuid).push(callback);
  }
  removeBeforeRenderListener(target, callback) {
    if (this._onBeforeRenderListeners.has(target.uuid)) {
      const arr = this._onBeforeRenderListeners.get(target.uuid);
      const idx = arr.indexOf(callback);
      if (idx >= 0)
        arr.splice(idx, 1);
    }
  }
  /** use this to subscribe to onAfterRender events on threejs objects */
  addAfterRenderListener(target, callback) {
    var _a2;
    if (!this._onAfterRenderListeners.has(target.uuid)) {
      this._onAfterRenderListeners.set(target.uuid, []);
      target.onAfterRender = this._createRenderCallbackWrapper(target, this._onAfterRenderListeners);
    }
    (_a2 = this._onAfterRenderListeners.get(target.uuid)) == null ? void 0 : _a2.push(callback);
  }
  removeAfterRenderListener(target, callback) {
    if (this._onAfterRenderListeners.has(target.uuid)) {
      const arr = this._onAfterRenderListeners.get(target.uuid);
      const idx = arr.indexOf(callback);
      if (idx >= 0)
        arr.splice(idx, 1);
    }
  }
  _createRenderCallbackWrapper(target, array) {
    return (renderer, scene, camera, geometry, material, group) => {
      const arr = array.get(target.uuid);
      if (!arr)
        return;
      for (let i = 0; i < arr.length; i++) {
        const fn2 = arr[i];
        fn2(renderer, scene, camera, geometry, material, group);
      }
    };
  }
  get isRendering() {
    return this._isRendering;
  }
  setRequireDepth(val) {
    this._requireDepthTexture = val;
  }
  setRequireColor(val) {
    this._requireColorTexture = val;
  }
  get depthTexture() {
    var _a2;
    return ((_a2 = this._renderTarget) == null ? void 0 : _a2.depthTexture) || null;
  }
  get opaqueColorTexture() {
    var _a2;
    return ((_a2 = this._renderTarget) == null ? void 0 : _a2.texture) || null;
  }
  /** returns true if the dom element is visible on screen */
  get isVisibleToUser() {
    if (this.isInXR)
      return true;
    if (!this._isVisible)
      return false;
    const style = getComputedStyle(this.domElement);
    return style.visibility !== "hidden" && style.display !== "none" && style.opacity !== "0";
  }
  async internalOnCreate(opts) {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    const createId = ++this._createId;
    if (debug29)
      console.log("Creating context", this.name, opts);
    const dependenciesReady = globalThis["needle:dependencies:ready"];
    if (dependenciesReady instanceof Promise) {
      if (debug29)
        console.log("Waiting for dependencies to be ready");
      await dependenciesReady.catch((err) => {
        if (debug29 || isDevEnvironment()) {
          showBalloonError("Needle Engine dependencies failed to load. Please check the console for more details");
          const printedError = false;
          if (err instanceof ReferenceError) {
            let offendingComponentName = "YourComponentName";
            const offendingComponentStartIndex = err.message.indexOf("'");
            if (offendingComponentStartIndex > 0) {
              const offendingComponentEndIndex = err.message.indexOf("'", offendingComponentStartIndex + 1);
              if (offendingComponentEndIndex > 0) {
                const name = err.message.substring(offendingComponentStartIndex + 1, offendingComponentEndIndex);
                if (name.length > 3)
                  offendingComponentName = name;
              }
            }
            console.error(`Needle Engine dependencies failed to load:

# Make sure you don't have circular imports in your scripts!
→ Possible solution: Replace @serializable(${offendingComponentName}) in your script with @serializable(Behaviour)

---`, err);
            return;
          }
          if (!printedError) {
            console.error("Needle Engine dependencies failed to load", err);
          }
        }
      }).then(() => {
        if (debug29)
          console.log("Needle Engine dependencies are ready");
      });
    }
    this.clear();
    if (this.isManagedExternally === false) {
      this.createNewRenderer();
      (_a2 = this.renderer) == null ? void 0 : _a2.setAnimationLoop(null);
    }
    await delay(1);
    _Context.Current = this;
    await ContextRegistry.dispatchCallback(ContextEvent.ContextCreationStart, this);
    let prepare_succeeded = true;
    let loadedFiles;
    try {
      _Context.Current = this;
      if (opts) {
        loadedFiles = await this.internalLoadInitialContent(createId, opts);
      } else
        loadedFiles = [];
    } catch (err) {
      console.error(err);
      prepare_succeeded = false;
    }
    if (!prepare_succeeded) {
      this.onError("Failed to load initial content");
      return false;
    }
    if (createId !== this._createId || ((_b = opts == null ? void 0 : opts.abortSignal) == null ? void 0 : _b.aborted)) {
      return false;
    }
    this.internalOnUpdateVisible();
    if (!this.renderer) {
      if (debug29)
        console.warn("Context has no renderer (perhaps it was disconnected?", this.domElement.isConnected);
      return false;
    }
    if (!this.isManagedExternally && !this.domElement.shadowRoot) {
      this.domElement.prepend(this.renderer.domElement);
    }
    _Context.Current = this;
    _Context.Current = this;
    for (let i = 0; i < this.new_scripts.length; i++) {
      const script = this.new_scripts[i];
      if (script.gameObject !== void 0 && script.gameObject !== null) {
        if (script.gameObject.userData === void 0)
          script.gameObject.userData = {};
        if (script.gameObject.userData.components === void 0)
          script.gameObject.userData.components = [];
        const arr = script.gameObject.userData.components;
        if (!arr.includes(script))
          arr.push(script);
      }
    }
    if (this.post_setup_callbacks) {
      for (let i = 0; i < this.post_setup_callbacks.length; i++) {
        _Context.Current = this;
        await this.post_setup_callbacks[i](this);
      }
    }
    if (!this._mainCamera) {
      _Context.Current = this;
      let camera = null;
      foreachComponent(this.scene, (comp) => {
        const cam = comp;
        if (cam == null ? void 0 : cam.isCamera) {
          updateActiveInHierarchyWithoutEventCall(cam.gameObject);
          if (!cam.activeAndEnabled)
            return void 0;
          if (cam.tag === "MainCamera") {
            camera = cam;
            return true;
          } else
            camera = cam;
        }
        return void 0;
      });
      if (camera) {
        this.setCurrentCamera(camera);
      } else {
        const res2 = ContextRegistry.dispatchCallback(ContextEvent.MissingCamera, this, { files: loadedFiles });
        if (!res2 && !this.mainCamera && !this.isManagedExternally)
          console.warn("Missing camera in main scene", this);
      }
    }
    this.input.bindEvents();
    _Context.Current = this;
    processNewScripts(this);
    if (this.physics.engine) {
      (_c = this.physics.engine) == null ? void 0 : _c.step(0);
      (_d = this.physics.engine) == null ? void 0 : _d.postStep();
    }
    if (!this.isManagedExternally && this.composer && this.mainCamera) {
      const renderPass = new RenderPass(this.scene, this.mainCamera);
      this.renderer.setSize(this.domWidth, this.domHeight);
      this.composer.addPass(renderPass);
      this.composer.setSize(this.domWidth, this.domHeight);
    }
    this._sizeChanged = true;
    if (this._stats) {
      this._stats.showPanel(0);
      this._stats.dom.style.position = "absolute";
      (_e = this.domElement.shadowRoot) == null ? void 0 : _e.appendChild(this._stats.dom);
    }
    if (debug29)
      logHierarchy(this.scene, true);
    if (this.targetFrameRate === void 0) {
      if (debug29)
        console.warn("No target framerate set, using default", _Context.DefaultTargetFrameRate);
      this.targetFrameRate = _Context._defaultTargetFramerate;
    } else if (debug29)
      console.log("Target framerate set to", this.targetFrameRate);
    this._dispatchReadyAfterFrame = true;
    const res = ContextRegistry.dispatchCallback(ContextEvent.ContextCreated, this, { files: loadedFiles });
    if (res) {
      if ("internalSetLoadingMessage" in this.domElement && typeof this.domElement.internalSetLoadingMessage === "function")
        (_f = this.domElement) == null ? void 0 : _f.internalSetLoadingMessage("finish loading");
      await res;
    }
    if ((_g = opts == null ? void 0 : opts.abortSignal) == null ? void 0 : _g.aborted) {
      return false;
    }
    invokeLifecycleFunctions(this, ContextEvent.ContextCreated);
    if (debug29)
      console.log("Context Created...", this.renderer, this.renderer.domElement);
    this._isCreating = false;
    if (!this.isManagedExternally && !((_h = opts == null ? void 0 : opts.abortSignal) == null ? void 0 : _h.aborted))
      this.restartRenderLoop();
    return true;
  }
  async internalLoadInitialContent(createId, args) {
    var _a2, _b, _c, _d;
    const results = new Array();
    if (args.files.length === 0)
      return results;
    const files = [...args.files];
    const progressArg = {
      name: "",
      progress: null,
      index: 0,
      count: files.length
    };
    const loader2 = getLoader();
    const loadingHash = 0;
    for (let i = 0; i < files.length; i++) {
      if ((_a2 = args.abortSignal) == null ? void 0 : _a2.aborted) {
        if (debug29)
          console.log("Aborting loading because of abort signal");
        break;
      }
      if (createId !== this._createId) {
        if (debug29)
          console.log("Aborting loading because create id changed", createId, this._createId);
        break;
      }
      const file = files[i];
      (_b = args == null ? void 0 : args.onLoadingStart) == null ? void 0 : _b.call(this, i, file);
      if (debug29)
        console.log("Context Load " + file);
      const res = await loader2.loadSync(this, file, file, loadingHash, (prog) => {
        var _a3, _b2;
        if ((_a3 = args.abortSignal) == null ? void 0 : _a3.aborted)
          return;
        progressArg.name = file;
        progressArg.progress = prog;
        progressArg.index = i;
        progressArg.count = files.length;
        (_b2 = args.onLoadingProgress) == null ? void 0 : _b2.call(this, progressArg);
      });
      (_c = args == null ? void 0 : args.onLoadingFinished) == null ? void 0 : _c.call(this, i, file, res ?? null);
      if (res) {
        results.push({
          src: file,
          file: res
        });
      } else {
        console.warn("Could not load file: " + file);
      }
    }
    if (createId !== this._createId || ((_d = args.abortSignal) == null ? void 0 : _d.aborted)) {
      for (const res of results) {
        if (res && res.file) {
          for (const scene of res.file.scenes)
            destroy(scene, true, true);
        }
      }
    } else {
      let anyModelFound = false;
      for (const res of results) {
        if (res && res.file) {
          if (res.file.scene) {
            anyModelFound = true;
            this.scene.add(res.file.scene);
          } else {
            console.warn("No scene found in loaded file");
          }
        }
      }
      if (!anyModelFound) {
        for (const res of results) {
          if (res && res.file && "parser" in res.file) {
            let y = 0;
            if (!Array.isArray(res.file.parser.json.materials))
              continue;
            for (let i = 0; i < res.file.parser.json.materials.length; i++) {
              const mat = await res.file.parser.getDependency("material", i);
              const parent = new Object3D();
              parent.position.x = i * 1.1;
              parent.position.y = y;
              this.scene.add(parent);
              ObjectUtils.createPrimitive("ShaderBall", {
                parent,
                material: mat
              });
            }
            y += 1;
          }
        }
      }
    }
    return results;
  }
  /** Sets the animation loop.
   * Can not be done while creating the context or when disposed
   **/
  restartRenderLoop() {
    if (!this.renderer) {
      console.error("Can not start render loop without renderer");
      return false;
    }
    if (this._isCreating) {
      console.warn("Can not start render loop while creating context");
      return false;
    }
    this.renderer.setAnimationLoop((timestamp, frame) => {
      if (this.isManagedExternally)
        return;
      this.update(timestamp, frame);
    });
    return true;
  }
  /** Performs a full update step including script callbacks, rendering (unless isManagedExternally is set to false) and post render callbacks */
  update(timestamp, frame) {
    if (frame === void 0)
      frame = null;
    if (isDevEnvironment() || debug29 || hasNewScripts()) {
      try {
        performance.mark("update.start");
        this.internalStep(timestamp, frame);
        this._renderlooperrors = 0;
        performance.mark("update.end");
        performance.measure("NE Frame", "update.start", "update.end");
      } catch (err) {
        this._renderlooperrors += 1;
        if ((isDevEnvironment() || debug29) && (err instanceof Error || err instanceof TypeError))
          showBalloonMessage(`Caught unhandled exception during render-loop - see console for details.`, LogType.Error);
        console.error("Frame #" + this.time.frame + "\n", err);
        if (this._renderlooperrors >= 3) {
          console.warn("Stopping render loop due to error");
          this.renderer.setAnimationLoop(null);
        }
        this.domElement.dispatchEvent(new CustomEvent("error", { detail: err }));
      }
    } else {
      this.internalStep(timestamp, frame);
    }
  }
  /** Call to **manually** perform physics steps.
   * By default the context uses the `physicsSteps` property to perform steps during the update loop
   * If you just want to increase the accuracy of physics you can instead set the `physicsSteps` property to a higher value
   * */
  updatePhysics(steps) {
    this.internalUpdatePhysics(steps);
  }
  // TODO: we need to skip after render callbacks if the render loop is managed externally. When changing this we also need to to update the r3f sample
  internalStep(timestamp, frame) {
    if (this.internalOnBeforeRender(timestamp, frame) === false)
      return;
    this.internalOnRender();
    this.internalOnAfterRender();
  }
  internalOnBeforeRender(timestamp, frame) {
    var _a2;
    this.renderer.info.autoReset = true;
    const sessionStarted = frame !== null && this._xrFrame === null;
    this._xrFrame = frame;
    if (sessionStarted) {
      this.domElement.dispatchEvent(new CustomEvent("xr-session-started", { detail: { context: this, session: this.xrSession, frame } }));
    }
    this._currentFrameEvent = FrameEvent.Undefined;
    if (this.isManagedExternally === false && this.isInXR === false && this.targetFrameRate !== void 0) {
      if (this._lastTimestamp === 0)
        this._lastTimestamp = timestamp;
      this._accumulatedTime += (timestamp - this._lastTimestamp) / 1e3;
      this._lastTimestamp = timestamp;
      let targetFrameRate = this.targetFrameRate;
      if (typeof targetFrameRate === "object")
        targetFrameRate = targetFrameRate.value;
      if (this._accumulatedTime < 1 / (targetFrameRate + 1)) {
        return false;
      }
      this._accumulatedTime = 0;
    }
    (_a2 = this._stats) == null ? void 0 : _a2.begin();
    _Context.Current = this;
    if (this.onHandlePaused())
      return false;
    _Context.Current = this;
    this.time.update();
    if (debugframerate)
      console.log("FPS", this.time.smoothedFps.toFixed(0));
    processNewScripts(this);
    updateIsActive(this.scene);
    processStart(this);
    invokeLifecycleFunctions(this, FrameEvent.Start);
    while (this._cameraStack.length > 0 && (!this.mainCameraComponent || this.mainCameraComponent.destroyed)) {
      this._cameraStack.splice(this._cameraStack.length - 1, 1);
      const last = this._cameraStack[this._cameraStack.length - 1];
      this.setCurrentCamera(last);
    }
    if (this.pre_update_oneshot_callbacks) {
      for (const i in this.pre_update_oneshot_callbacks) {
        this.pre_update_oneshot_callbacks[i]();
      }
      this.pre_update_oneshot_callbacks.length = 0;
    }
    if (this.pre_update_callbacks) {
      for (const i in this.pre_update_callbacks) {
        this.pre_update_callbacks[i]();
      }
    }
    this._currentFrameEvent = FrameEvent.EarlyUpdate;
    for (let i = 0; i < this.scripts_earlyUpdate.length; i++) {
      const script = this.scripts_earlyUpdate[i];
      if (!script.activeAndEnabled)
        continue;
      if (script.earlyUpdate !== void 0) {
        _Context.Current = this;
        script.earlyUpdate();
      }
    }
    this.executeCoroutines(FrameEvent.EarlyUpdate);
    invokeLifecycleFunctions(this, FrameEvent.EarlyUpdate);
    if (this.onHandlePaused())
      return false;
    this._currentFrameEvent = FrameEvent.Update;
    for (let i = 0; i < this.scripts_update.length; i++) {
      const script = this.scripts_update[i];
      if (!script.activeAndEnabled)
        continue;
      if (script.update !== void 0) {
        _Context.Current = this;
        script.update();
      }
    }
    this.executeCoroutines(FrameEvent.Update);
    invokeLifecycleFunctions(this, FrameEvent.Update);
    if (this.onHandlePaused())
      return false;
    this._currentFrameEvent = FrameEvent.LateUpdate;
    for (let i = 0; i < this.scripts_lateUpdate.length; i++) {
      const script = this.scripts_lateUpdate[i];
      if (!script.activeAndEnabled)
        continue;
      if (script.lateUpdate !== void 0) {
        _Context.Current = this;
        script.lateUpdate();
      }
    }
    this.executeCoroutines(FrameEvent.LateUpdate);
    invokeLifecycleFunctions(this, FrameEvent.LateUpdate);
    if (this.onHandlePaused())
      return false;
    if (this.physicsSteps === void 0) {
      this.physicsSteps = 1;
    }
    if (this.physics.engine && this.physicsSteps > 0) {
      this.internalUpdatePhysics(this.physicsSteps);
    }
    if (this.onHandlePaused())
      return false;
    if (this.isVisibleToUser || this.runInBackground) {
      this._currentFrameEvent = FrameEvent.OnBeforeRender;
      for (let i = 0; i < this.scripts_onBeforeRender.length; i++) {
        const script = this.scripts_onBeforeRender[i];
        if (!script.activeAndEnabled)
          continue;
        if (script.onBeforeRender !== void 0) {
          _Context.Current = this;
          script.onBeforeRender(frame);
        }
      }
      this.executeCoroutines(FrameEvent.OnBeforeRender);
      invokeLifecycleFunctions(this, FrameEvent.OnBeforeRender);
      if (this._sizeChanged)
        this.updateSize();
      if (this.pre_render_callbacks) {
        for (const i in this.pre_render_callbacks) {
          this.pre_render_callbacks[i](frame);
        }
      }
    }
    return true;
  }
  internalUpdatePhysics(steps) {
    if (!this.physics.engine)
      return false;
    const physicsSteps = steps;
    const dt = this.time.deltaTime / physicsSteps;
    for (let i = 0; i < physicsSteps; i++) {
      this._currentFrameEvent = FrameEvent.PrePhysicsStep;
      this.executeCoroutines(FrameEvent.PrePhysicsStep);
      this.physics.engine.step(dt);
      this._currentFrameEvent = FrameEvent.PostPhysicsStep;
      this.executeCoroutines(FrameEvent.PostPhysicsStep);
    }
    this.physics.engine.postStep();
    return true;
  }
  internalOnRender() {
    if (!this.isManagedExternally) {
      runPrewarm(this);
      this._currentFrameEvent = FrameEvent.Undefined;
      nodeFrame.update();
      this.renderNow();
      this._currentFrameEvent = FrameEvent.OnAfterRender;
    }
  }
  internalOnAfterRender() {
    if (this.isVisibleToUser || this.runInBackground) {
      for (let i = 0; i < this.scripts_onAfterRender.length; i++) {
        const script = this.scripts_onAfterRender[i];
        if (!script.activeAndEnabled)
          continue;
        if (script.onAfterRender !== void 0) {
          _Context.Current = this;
          script.onAfterRender();
        }
      }
      this.executeCoroutines(FrameEvent.OnAfterRender);
      invokeLifecycleFunctions(this, FrameEvent.OnAfterRender);
      if (this.post_render_callbacks) {
        for (const i in this.post_render_callbacks) {
          this.post_render_callbacks[i]();
        }
      }
    }
    this._currentFrameEvent = -1;
    this.connection.sendBufferedMessagesNow();
    if (this._stats) {
      this._stats.end();
      if (this.time.frameCount % 150 === 0)
        console.log(this.renderer.info.render.calls + " DrawCalls", "\nRender:", { ...this.renderer.info.render }, "\nMemory:", { ...this.renderer.info.memory }, "\nTarget Framerate: " + this.targetFrameRate);
    }
    if (this._dispatchReadyAfterFrame) {
      this._dispatchReadyAfterFrame = false;
      this.domElement.dispatchEvent(new CustomEvent("ready"));
      ContextRegistry.dispatchCallback(ContextEvent.ContextFirstFrameRendered, this);
    }
  }
  renderNow(camera) {
    var _a2;
    if (!camera) {
      camera = this.mainCamera;
      if (!camera)
        return false;
    }
    this.handleRendererContextLost();
    this._isRendering = true;
    this.renderRequiredTextures();
    if (this.renderer.toneMapping !== NoToneMapping)
      patchTonemapping(this);
    if (this.composer && !this.isInXR) {
      if (camera) {
        const currentPassesCamera = (_a2 = this.composer.passes[0]) == null ? void 0 : _a2.mainCamera;
        if (currentPassesCamera != camera)
          this.composer.setMainCamera(camera);
      }
      this.composer.render(this.time.deltaTime);
    } else if (camera) {
      if (this.isInXR && DeviceUtilities.isMacOS())
        this.renderer.clearDepth();
      this.renderer.render(this.scene, camera);
    }
    this._isRendering = false;
    return true;
  }
  handleRendererContextLost() {
    if (this.renderer.getContext().isContextLost()) {
      console.warn("Attempting to recover WebGL context...");
      this.renderer.forceContextRestore();
    }
  }
  onHandlePaused() {
    const paused = this.evaluatePaused();
    if (this._wasPaused !== paused) {
      if (debugActive)
        console.log("Paused?", paused, "context:" + this.alias);
      for (let i = 0; i < this.scripts_pausedChanged.length; i++) {
        const script = this.scripts_pausedChanged[i];
        if (!script.activeAndEnabled)
          continue;
        if (script.onPausedChanged !== void 0) {
          _Context.Current = this;
          script.onPausedChanged(paused, this._wasPaused);
        }
      }
    }
    this._wasPaused = paused;
    return paused;
  }
  evaluatePaused() {
    if (this.isInXR)
      return false;
    if (this.isPaused)
      return true;
    if (this.runInBackground) {
      return false;
    }
    const paused = !this.isVisibleToUser;
    return paused;
  }
  renderRequiredTextures() {
    if (!this.mainCamera)
      return;
    if (!this._requireDepthTexture && !this._requireColorTexture)
      return;
    if (!this._renderTarget) {
      this._renderTarget = new WebGLRenderTarget(this.domWidth, this.domHeight);
      if (this._requireDepthTexture) {
        const dt = new DepthTexture(this.domWidth, this.domHeight);
        ;
        this._renderTarget.depthTexture = dt;
      }
      if (this._requireColorTexture) {
        this._renderTarget.texture = new Texture();
        this._renderTarget.texture.generateMipmaps = false;
        this._renderTarget.texture.minFilter = NearestFilter;
        this._renderTarget.texture.magFilter = NearestFilter;
        this._renderTarget.texture.format = RGBAFormat;
      }
    }
    const rt = this._renderTarget;
    if (rt.texture) {
      rt.texture.colorSpace = this.renderer.outputColorSpace;
    }
    const prevTarget = this.renderer.getRenderTarget();
    this.renderer.setRenderTarget(rt);
    this.renderer.render(this.scene, this.mainCamera);
    this.renderer.setRenderTarget(prevTarget);
  }
  executeCoroutines(evt) {
    var _a2;
    if (this.coroutines[evt]) {
      const evts = this.coroutines[evt];
      for (let i = 0; i < evts.length; i++) {
        try {
          const evt2 = evts[i];
          const remove = !evt2.comp || evt2.comp.destroyed || !evt2.main || evt2.comp["enabled"] === false;
          if (remove) {
            if (debugCoroutine)
              console.log("Removing coroutine", evt2.comp, evt2.comp["enabled"]);
            evts.splice(i, 1);
            --i;
            continue;
          }
          const iter = evt2.chained;
          if (iter && iter.length > 0) {
            const last = iter[iter.length - 1];
            const res2 = last.next();
            if (res2.done) {
              iter.pop();
            }
            if (isGenerator(res2)) {
              if (!evt2.chained)
                evt2.chained = [];
              evt2.chained.push(res2.value);
            }
            if (!res2.done)
              continue;
          }
          const res = evt2.main.next();
          if (res.done === true) {
            evts.splice(i, 1);
            --i;
            continue;
          }
          const val = res.value;
          if (isGenerator(val)) {
            const gen = val;
            const res2 = gen.next();
            if (res2.done)
              continue;
            if (!evt2.chained)
              evt2.chained = [];
            evt2.chained.push(val);
          } else if (val instanceof Promise) {
            const prom = val;
            if (!evt2.chained)
              evt2.chained = [];
            const nested = WaitForPromise(prom);
            (_a2 = evt2.chained) == null ? void 0 : _a2.push(nested);
            continue;
          }
        } catch (e) {
          console.error(e);
        }
      }
    }
    function isGenerator(val) {
      if (val) {
        if (val.next && val.return) {
          return true;
        }
      }
      return false;
    }
  }
};
var Context = _Context;
__publicField(Context, "_defaultTargetFramerate", { value: 90, toString() {
  return this.value;
} });
__publicField(Context, "_defaultWebglRendererParameters", {
  antialias: true,
  alpha: false,
  // Note: this is due to a bug on OSX devices. See NE-5370
  powerPreference: DeviceUtilities.isiOS() || DeviceUtilities.isMacOS() ? "default" : "high-performance",
  stencil: true
});

// node_modules/@needle-tools/engine/lib/engine/engine_license.js
var debug30 = getParam("debuglicense");
var NEEDLE_ENGINE_LICENSE_TYPE = "basic";
if (debug30)
  console.log("License Type: " + NEEDLE_ENGINE_LICENSE_TYPE);
function hasProLicense() {
  switch (NEEDLE_ENGINE_LICENSE_TYPE) {
    case "pro":
    case "enterprise":
      return true;
  }
  ;
  return false;
}
function hasIndieLicense() {
  switch (NEEDLE_ENGINE_LICENSE_TYPE) {
    case "indie":
      return true;
  }
  return false;
}
function hasCommercialLicense() {
  return hasProLicense() || hasIndieLicense();
}
var _licenseCheckResultChangedCallbacks = [];
function onLicenseCheckResultChanged(cb) {
  if (hasProLicense() || hasIndieLicense())
    return cb(true);
  _licenseCheckResultChangedCallbacks.push(cb);
}
function invokeLicenseCheckResultChanged(result) {
  for (const cb of _licenseCheckResultChangedCallbacks) {
    try {
      cb(result);
    } catch {
    }
  }
}
ContextRegistry.registerCallback(ContextEvent.ContextRegistered, (evt) => {
  showLicenseInfo(evt.context);
  sendUsageMessageToAnalyticsBackend();
  handleForbidden(evt.context);
});
var runtimeLicenseCheckPromise = void 0;
var applicationIsForbidden = false;
var applicationForbiddenText = "";
async function checkLicense() {
  if (runtimeLicenseCheckPromise)
    return runtimeLicenseCheckPromise;
  if (NEEDLE_ENGINE_LICENSE_TYPE === "basic") {
    try {
      const licenseUrl = "https://engine.needle.tools/licensing/check?location=" + encodeURIComponent(window.location.href) + "&version=" + VERSION + "&generator=" + encodeURIComponent(GENERATOR);
      const res = await fetch(licenseUrl, {
        method: "GET"
      }).catch((_err) => {
        if (debug30)
          console.error("License check failed", _err);
        return void 0;
      });
      if ((res == null ? void 0 : res.status) === 200) {
        applicationIsForbidden = false;
        if (debug30)
          console.log("License check succeeded");
        NEEDLE_ENGINE_LICENSE_TYPE = "pro";
        invokeLicenseCheckResultChanged(true);
      } else if ((res == null ? void 0 : res.status) === 403) {
        applicationIsForbidden = true;
        applicationForbiddenText = await res.text();
      } else {
        if (debug30)
          console.log("License check failed with status " + (res == null ? void 0 : res.status));
      }
    } catch (err) {
      if (debug30)
        console.error("License check failed", err);
    }
  } else if (debug30)
    console.log('Runtime license check is skipped because license is already applied as "' + NEEDLE_ENGINE_LICENSE_TYPE + '"');
}
runtimeLicenseCheckPromise = checkLicense();
async function handleForbidden(ctx) {
  function createForbiddenElement() {
    const div = document.createElement("div");
    div.className = "needle-forbidden";
    div.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: all;
        zIndex: 2147483647;
        line-height: 1.5;
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        `;
    const expectedStyle = div.style.cssText;
    const text = document.createElement("div");
    div.appendChild(text);
    text.style.cssText = `
        position: absolute;
        left: 0;
        right: 0;
        top:0;
        bottom: 0;
        padding: 10%;
        color: white;
        font-size: 20px;
        font-family: sans-serif;
        text-align: center;
        pointer-events: all;
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: rgba(0,0,0,.3);
        text-shadow: 0 0 2px black;
        `;
    const expectedTextStyle = text.style.cssText;
    const forbiddenText = (applicationForbiddenText == null ? void 0 : applicationForbiddenText.length) > 1 ? applicationForbiddenText : "This web application has been paused.<br/>You might be in violation of the Needle Engine terms of use.<br/>Please contact the Needle support if you think this is a mistake.";
    text.innerHTML = forbiddenText;
    setInterval(() => {
      if (text.innerHTML !== forbiddenText)
        text.innerHTML = forbiddenText;
      if (text.parentNode !== div)
        div.appendChild(text);
      if (div.style.cssText !== expectedStyle)
        div.style.cssText = expectedStyle;
      if (text.style.cssText !== expectedTextStyle)
        text.style.cssText = expectedTextStyle;
    }, 500);
    return div;
  }
  let forbiddenElement = createForbiddenElement();
  const expectedCSS = forbiddenElement.style.cssText;
  setInterval(() => {
    var _a2;
    if (applicationIsForbidden === true) {
      if (forbiddenElement.style.cssText !== expectedCSS)
        forbiddenElement = createForbiddenElement();
      if (ctx.domElement.shadowRoot) {
        if (forbiddenElement.parentNode !== ctx.domElement.shadowRoot)
          (_a2 = ctx.domElement.shadowRoot) == null ? void 0 : _a2.appendChild(forbiddenElement);
      } else if (forbiddenElement.parentNode != document.body) {
        document.body.appendChild(forbiddenElement);
      }
    }
  }, 500);
}
async function showLicenseInfo(ctx) {
  try {
    if (hasCommercialLicense() !== true)
      return onNonCommercialVersionDetected(ctx);
  } catch (err) {
    if (debug30)
      console.log("License check failed", err);
    return onNonCommercialVersionDetected(ctx);
  }
  if (debug30)
    onNonCommercialVersionDetected(ctx);
}
async function onNonCommercialVersionDetected(ctx) {
  let isReady = false;
  ctx.domElement.addEventListener("ready", () => isReady = true);
  await (runtimeLicenseCheckPromise == null ? void 0 : runtimeLicenseCheckPromise.catch(() => {
  }));
  if (hasCommercialLicense())
    return;
  logNonCommercialUse();
}
var lastLogTime = 0;
async function logNonCommercialUse(_logo) {
  var _a2;
  const now = Date.now();
  if (now - lastLogTime < 2e3)
    return;
  lastLogTime = now;
  const logo = "data:image/webp;base64,UklGRrABAABXRUJQVlA4WAoAAAAQAAAAHwAAHwAAQUxQSKEAAAARN6CmbSM4WR7vdARON11EBDq3fLiNbVtVzpMCPlKAEzsx0Y/x+Ovuv4dn0EFE/ydAvz6YggXzgh5sVgXM/zOC/4sii7qgGvB5N7hmuQYwkvazWAu1JPW41FXSHq6pnaQWvqYH18Fc0j1hO/BFTtIeSBlJi5w6qIIO7IOrwhFsB2Yxukif0FTRLpXswHR8MxbslKe9VZsn/Ub5C7YFOpqSTABWUDgg6AAAAFAGAJ0BKiAAIAA+7VyoTqmkpCI3+qgBMB2JbACdMt69DwMIQBLhkTO6XwY00UEDK6cNIDnuNibPf0EgAP7Y1myuiQHLDsF/0h5unrGh6WAbv7aegg2ZMd3uRKfT/3SJztcaujYfTvMXspfCTmYcoO6a+vhC3ss4M8uM58t4siiu59I4aOl59e9Sr6xoxYlHf2v+NnBNpJYeJf8jABQAId/PXuBkLEFkiCucgSGEcfhvajql/j3reCGl0M5/9gQWy7ayNPs+wlvIxFnNfSlfuND4CZOCyxOHhRqOmHN4ULHo3tCSrUNvgAA=";
  const style = `
        position: relative;
        display: block;
        font-size: 18px;
        background-size: 20px;
        background-position: 10px 5px;
        background-repeat:no-repeat;
        background-image:url('${logo}');
        background-max-size: 40px;
        margin-bottom: 5px;
        margin-top: .3em;
        margin-bottom: .5em;
        padding: .2em;
        padding-left: 25px;
        border-radius: .5em;
        border: 2px solid rgba(160,160,160,.3);
    `;
  const version2 = VERSION;
  const licenseText = `Needle Engine — No license active, commercial use is not allowed. Visit https://needle.tools/pricing for more information and licensing options! v${version2}`;
  if ((_a2 = Context.Current) == null ? void 0 : _a2.xr) {
    console.log(licenseText);
  } else {
    console.log("%c " + licenseText, style);
  }
}
async function sendUsageMessageToAnalyticsBackend() {
  var _a2;
  if (window.crossOriginIsolated)
    return;
  try {
    const analyticsUrl = "https://needle-engine-analytics-v2-r26roub2hq-lz.a.run.app";
    if (analyticsUrl) {
      if (debug30)
        console.log("Analytics backend url", analyticsUrl);
      const currentUrl = window.location.href.split("?")[0];
      let endpoint = "api/v2/new/request";
      if (!analyticsUrl.endsWith("/"))
        endpoint = "/" + endpoint;
      const license = NEEDLE_ENGINE_LICENSE_TYPE;
      const finalUrl = `${analyticsUrl}${endpoint}`;
      if (debug30)
        console.log("Sending non-commercial usage message to analytics backend", finalUrl);
      const beaconData = {
        license,
        url: currentUrl,
        hostname: window.location.hostname,
        pathname: window.location.pathname,
        // search: window.location.search,
        // hash: window.location.hash,
        version: VERSION,
        generator: GENERATOR,
        build_time: BUILD_TIME,
        public_key: PUBLIC_KEY
      };
      const res = (_a2 = navigator.sendBeacon) == null ? void 0 : _a2.call(navigator, finalUrl, JSON.stringify(beaconData));
      if (debug30)
        console.log("Send beacon result", res);
    }
  } catch (err) {
    if (debug30)
      console.log("Failed to send non-commercial usage message to analytics backend", err);
  }
}

// node_modules/@needle-tools/engine/lib/engine/engine_element_loading.js
var debug31 = getParam("debugloading");
var debugRendering = getParam("debugloadingrendering");
var debugLicense = getParam("debuglicense");
var LoadingElementOptions = class {
  constructor() {
    __publicField(this, "className");
    __publicField(this, "additionalClasses");
  }
};
var currentFileProgress = 0;
var currentFileName;
function calculateProgress01(progress) {
  if (debug31)
    console.log(progress.progress.loaded.toFixed(0) + "/" + progress.progress.total.toFixed(0), progress);
  const count = progress.count;
  const total = progress.progress.total;
  if (total === 0 || total === void 0) {
    if (currentFileName !== progress.name)
      currentFileProgress = 0;
    currentFileName = progress.name;
    currentFileProgress += (1 - currentFileProgress) * 1e-3;
    if (debug31)
      showBalloonWarning("Loading " + progress.name + " did not report total size");
  } else {
    currentFileProgress = progress.progress.loaded / total;
  }
  const prog = progress.index / count + currentFileProgress / count;
  return Mathf.clamp01(prog);
}
var _EngineLoadingView = class {
  /**
   * Creates a new loading view
   * @param owner the element that will contain the loading view (should be the NeedleEngineHTMLElement)
   */
  constructor(owner, opts) {
    // the raw progress
    __publicField(this, "loadingProgress", 0);
    /** Usually the NeedleEngineHTMLElement */
    __publicField(this, "_element");
    __publicField(this, "_progress", 0);
    __publicField(this, "_allowCustomLoadingElement", true);
    __publicField(this, "_loadingElement");
    __publicField(this, "_loadingTextContainer", null);
    __publicField(this, "_loadingBar", null);
    __publicField(this, "_messageContainer", null);
    __publicField(this, "_loadingElementOptions");
    __publicField(this, "_progressLoop");
    this._element = owner;
    this._loadingElementOptions = opts;
  }
  async onLoadingBegin(message) {
    const _element = this._element.shadowRoot || this._element;
    if (debug31)
      console.warn("Begin Loading");
    if (!this._loadingElement) {
      for (let i = 0; i < _element.children.length; i++) {
        const el = _element.children[i];
        if (el.classList.contains(_EngineLoadingView.LoadingContainerClassName)) {
          if (!this._allowCustomLoadingElement) {
            if (debug31)
              console.warn("Remove custom loading container");
            _element.removeChild(el);
            continue;
          }
          this._loadingElement = this.createLoadingElement(el);
        }
      }
      if (!this._loadingElement)
        this._loadingElement = this.createLoadingElement();
    }
    this._progress = 0;
    this.loadingProgress = 0;
    this._loadingElement.style.display = "flex";
    _element.appendChild(this._loadingElement);
    this.smoothProgressLoop();
    this.setMessage(message ?? "");
  }
  onLoadingUpdate(progress, message) {
    var _a2;
    if (!((_a2 = this._loadingElement) == null ? void 0 : _a2.parentNode)) {
      return;
    }
    let total01 = 0;
    if (typeof progress === "number") {
      total01 = progress;
    } else {
      if ("index" in progress)
        total01 = calculateProgress01(progress);
      if (!message && "name" in progress)
        this.setMessage("loading " + progress.name);
    }
    this.loadingProgress = total01;
    if (message)
      this.setMessage(message);
    this.updateDisplay();
  }
  onLoadingFinished() {
    if (debug31)
      console.warn("Finished Loading");
    if (!debugRendering) {
      this.loadingProgress = 1;
      this.onDoneLoading();
    }
  }
  setMessage(message) {
    if (this._messageContainer) {
      this._messageContainer.innerText = message;
    }
  }
  smoothProgressLoop() {
    if (this._progressLoop)
      return;
    let dt = 1 / 12;
    if (debugRendering) {
      dt = 1 / 500;
      if (typeof debugRendering === "number")
        dt *= debugRendering;
    }
    this._progressLoop = setInterval(() => {
      if (this.loadingProgress >= 0.95 && !debugRendering)
        dt = 0.9;
      this._progress = Mathf.lerp(this._progress, this.loadingProgress, dt * this.loadingProgress);
      this.updateDisplay();
    }, dt);
  }
  onDoneLoading() {
    if (this._loadingElement) {
      if (debug31)
        console.log("Hiding loading element");
      this._loadingElement.style.display = "none";
      this._loadingElement.remove();
    }
    if (this._progressLoop)
      clearInterval(this._progressLoop);
    this._progressLoop = null;
  }
  updateDisplay() {
    const t2 = this._progress;
    const percent = (t2 * 100).toFixed(0) + "%";
    if (this._loadingBar) {
      this._loadingBar.style.width = t2 * 100 + "%";
    }
    if (this._loadingTextContainer)
      this._loadingTextContainer.textContent = percent;
  }
  createLoadingElement(existing) {
    var _a2, _b;
    if (debug31 && !existing)
      console.log("Creating loading element");
    this._loadingElement = existing || document.createElement("div");
    let loadingStyle = this._element.getAttribute("loading-style");
    if (!loadingStyle || loadingStyle === "auto") {
      if (window.matchMedia("(prefers-color-scheme: dark)").matches)
        loadingStyle = "dark";
      else
        loadingStyle = "light";
    }
    const hasLicense = hasProLicense();
    if (!existing) {
      this._loadingElement.style.position = "absolute";
      this._loadingElement.style.width = "100%";
      this._loadingElement.style.height = "100%";
      this._loadingElement.style.left = "0";
      this._loadingElement.style.top = "0";
      if (loadingStyle === "light")
        this._loadingElement.style.backgroundColor = "#ddd";
      else
        this._loadingElement.style.backgroundColor = "#222";
      this._loadingElement.style.display = "flex";
      this._loadingElement.style.alignItems = "center";
      this._loadingElement.style.justifyContent = "center";
      this._loadingElement.style.zIndex = Number.MAX_SAFE_INTEGER.toString();
      this._loadingElement.style.flexDirection = "column";
      this._loadingElement.style.pointerEvents = "none";
      this._loadingElement.style.color = "white";
      this._loadingElement.style.fontFamily = 'system-ui, Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"';
      this._loadingElement.style.fontSize = "1rem";
      if (loadingStyle === "light")
        this._loadingElement.style.color = "rgba(0,0,0,.6)";
      else
        this._loadingElement.style.color = "rgba(255,255,255,.3)";
      if (hasLicense && this._element) {
        const loadingBackgroundColor = this._element.getAttribute("loading-background-color");
        if (loadingBackgroundColor) {
          this._loadingElement.style.backgroundColor = loadingBackgroundColor;
        }
        const textColor = this._element.getAttribute("loading-text-color");
        if (textColor) {
          this._loadingElement.style.color = textColor;
        }
      }
    }
    const className = ((_a2 = this._loadingElementOptions) == null ? void 0 : _a2.className) ?? _EngineLoadingView.LoadingContainerClassName;
    this._loadingElement.classList.add(className);
    if ((_b = this._loadingElementOptions) == null ? void 0 : _b.additionalClasses) {
      for (const c2 of this._loadingElementOptions.additionalClasses) {
        this._loadingElement.classList.add(c2);
      }
    }
    const content = document.createElement("div");
    this._loadingElement.appendChild(content);
    const logo = document.createElement("img");
    const logoSize = 120;
    logo.style.width = `${logoSize}px`;
    logo.style.height = `${logoSize}px`;
    logo.style.paddingTop = "20px";
    logo.style.paddingBottom = "10px";
    logo.style.margin = "0px";
    logo.style.userSelect = "none";
    logo.style.objectFit = "contain";
    logo.style.transition = "transform 1.5s ease-out, opacity .3s ease-in-out";
    logo.style.transform = "translateY(30px)";
    logo.style.opacity = "0.05";
    setTimeout(() => {
      logo.style.opacity = "1";
      logo.style.transform = "translateY(0px)";
    }, 1);
    logo.src = needleLogoOnlySVG;
    let isUsingCustomLogo = false;
    if (hasLicense && this._element) {
      const customLogo = this._element.getAttribute("loading-logo-src");
      if (customLogo) {
        isUsingCustomLogo = true;
        logo.src = customLogo;
      }
    }
    content.appendChild(logo);
    const details = document.createElement("div");
    details.style.cssText = `
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        width: 100%;
        opacity: 0;
        transition: opacity 1s ease-in-out 4s;
        `;
    setTimeout(() => {
      details.style.opacity = "1";
    }, 1);
    this._loadingElement.appendChild(details);
    const loadingBarContainer = document.createElement("div");
    const maxWidth = 100;
    loadingBarContainer.style.display = "flex";
    loadingBarContainer.style.width = maxWidth + "%";
    loadingBarContainer.style.height = "3px";
    loadingBarContainer.style.position = "absolute";
    loadingBarContainer.style.left = "0";
    loadingBarContainer.style.bottom = "0px";
    loadingBarContainer.style.opacity = "0";
    loadingBarContainer.style.transition = "opacity 1s ease-in-out 2s";
    setTimeout(() => {
      loadingBarContainer.style.opacity = "1";
    }, 1);
    if (loadingStyle === "light")
      loadingBarContainer.style.backgroundColor = "rgba(0,0,0,.2)";
    else
      loadingBarContainer.style.backgroundColor = "rgba(255,255,255,.2)";
    this._loadingElement.appendChild(loadingBarContainer);
    this._loadingBar = document.createElement("div");
    loadingBarContainer.appendChild(this._loadingBar);
    const getGradientPos = function(t2) {
      return Mathf.lerp(0, maxWidth, t2) + "%";
    };
    this._loadingBar.style.background = `linear-gradient(90deg, #204f49 ${getGradientPos(0)}, #0BA398 ${getGradientPos(0.3)}, #66A22F ${getGradientPos(0.6)}, #D7DB0A ${getGradientPos(1)})`;
    this._loadingBar.style.backgroundAttachment = "fixed";
    this._loadingBar.style.width = "0%";
    this._loadingBar.style.height = "100%";
    if (hasLicense && this._element) {
      const primaryColor = this._element.getAttribute("primary-color");
      const secondaryColor = this._element.getAttribute("secondary-color");
      if (primaryColor && secondaryColor) {
        this._loadingBar.style.background = `linear-gradient(90deg, ${primaryColor} ${getGradientPos(0)}, ${secondaryColor} ${getGradientPos(1)})`;
      } else if (primaryColor) {
        this._loadingBar.style.background = primaryColor;
      } else if (secondaryColor) {
        this._loadingBar.style.background = secondaryColor;
      }
    }
    this._loadingTextContainer = document.createElement("div");
    this._loadingTextContainer.style.display = "flex";
    this._loadingTextContainer.style.justifyContent = "center";
    this._loadingTextContainer.style.marginTop = ".2rem";
    details.appendChild(this._loadingTextContainer);
    const messageContainer = document.createElement("div");
    this._messageContainer = messageContainer;
    messageContainer.style.display = "flex";
    messageContainer.style.fontSize = ".8rem";
    messageContainer.style.paddingTop = ".1rem";
    messageContainer.style.justifyContent = "center";
    details.appendChild(messageContainer);
    if (hasLicense && this._element) {
      const loadingTextColor = this._element.getAttribute("loading-text-color");
      if (loadingTextColor) {
        messageContainer.style.color = loadingTextColor;
      }
    }
    this.handleRuntimeLicense(this._loadingElement);
    return this._loadingElement;
  }
  async handleRuntimeLicense(loadingElement) {
    let commercialLicense = hasCommercialLicense();
    if (commercialLicense)
      return;
    if (debugLicense)
      console.log("Loading UI has commercial license?", commercialLicense);
    const nonCommercialContainer = document.createElement("div");
    nonCommercialContainer.style.paddingTop = ".6em";
    nonCommercialContainer.style.fontSize = ".8em";
    nonCommercialContainer.style.textTransform = "uppercase";
    nonCommercialContainer.innerText = "NEEDLE ENGINE NON COMMERCIAL VERSION\nCLICK HERE TO GET A LICENSE";
    nonCommercialContainer.style.cursor = "pointer";
    nonCommercialContainer.style.userSelect = "none";
    nonCommercialContainer.style.textAlign = "center";
    nonCommercialContainer.style.pointerEvents = "all";
    nonCommercialContainer.addEventListener("click", () => window.open("https://needle.tools/pricing", "_self"));
    nonCommercialContainer.style.opacity = "0";
    loadingElement.appendChild(nonCommercialContainer);
    if (!isDevEnvironment() && runtimeLicenseCheckPromise) {
      if (debugLicense)
        console.log("Waiting for runtime license check");
      await runtimeLicenseCheckPromise;
      commercialLicense = hasCommercialLicense();
    }
    if (commercialLicense)
      return;
    nonCommercialContainer.style.transition = "opacity .5s ease-in-out";
    nonCommercialContainer.style.opacity = "1";
  }
};
var EngineLoadingView = _EngineLoadingView;
__publicField(EngineLoadingView, "LoadingContainerClassName", "loading");

// node_modules/@needle-tools/engine/lib/engine/engine_element_overlay.js
var debug32 = getParam("debugoverlay");
var arContainerClassName = "ar";
var quitARClassName = "quit-ar";
var AROverlayHandler = class {
  constructor() {
    __publicField(this, "arContainer", null);
    __publicField(this, "currentSession", null);
    __publicField(this, "_createdAROnlyElements", []);
    __publicField(this, "_reparentedObjects", []);
    __publicField(this, "contentElement", null);
    __publicField(this, "originalDomOverlayParent", null);
    __publicField(this, "requestEndAR", () => {
      this.onRequestedEndAR();
    });
  }
  get ARContainer() {
    return this.arContainer;
  }
  onBegin(context, overlayContainer, session) {
    var _a2;
    this.currentSession = session;
    this.arContainer = overlayContainer;
    if (DeviceUtilities.isMozillaXR()) {
      const arElements = context.domElement.children;
      for (let i = 0; i < (arElements == null ? void 0 : arElements.length); i++) {
        const el = arElements[i];
        if (!el)
          return;
        if (el === this.arContainer)
          return;
        this._reparentedObjects.push({ el, previousParent: el.parentElement });
        (_a2 = this.arContainer) == null ? void 0 : _a2.appendChild(el);
      }
      if (overlayContainer) {
        this.originalDomOverlayParent = overlayContainer.parentNode;
        if (this.originalDomOverlayParent) {
          console.log("Reparent DOM Overlay to body", overlayContainer, overlayContainer.style.display);
          overlayContainer.style.display = "";
          overlayContainer.style.visibility = "";
          document.body.appendChild(overlayContainer);
        }
      } else {
        console.warn("WebXRViewer: No DOM Overlay found");
      }
    }
    this.ensureQuitARButton(this.arContainer);
  }
  onEnd(_context) {
    var _a2;
    for (const created of this._createdAROnlyElements) {
      if (created.remove) {
        created.remove();
      }
    }
    for (const prev of this._reparentedObjects) {
      const el = prev.el;
      (_a2 = prev.previousParent) == null ? void 0 : _a2.appendChild(el);
    }
    this._reparentedObjects.length = 0;
    if (DeviceUtilities.isMozillaXR()) {
      setTimeout(() => {
        var _a3;
        const canvas = _context.renderer.domElement;
        if (canvas) {
          (_a3 = _context.domElement.shadowRoot) == null ? void 0 : _a3.prepend(canvas);
        }
        const elements = document.querySelectorAll("*");
        for (var i = 0; i < elements.length; i++) {
          const child = elements[i];
          if (child && child._displayChanged !== void 0 && child._displayWas !== void 0) {
            child.style.display = child._displayWas;
          }
        }
      }, 10);
    }
  }
  createOverlayContainer(needleEngineElement) {
    if (this.contentElement)
      return this.contentElement;
    if (debug32)
      console.log("Setup overlay container");
    const contentElement = needleEngineElement.shadowRoot.querySelector(".content");
    this.contentElement = contentElement;
    const overlaySlot = needleEngineElement.shadowRoot.querySelector(".overlay-content");
    if (overlaySlot)
      contentElement.appendChild(overlaySlot);
    if (debug32 && !DeviceUtilities.isMobileDevice())
      this.ensureQuitARButton(contentElement);
    return contentElement;
  }
  onRequestedEndAR() {
    if (!this.currentSession)
      return;
    this.currentSession.end();
    this.currentSession = null;
  }
  ensureQuitARButton(element) {
    const quitARSlot = document.createElement("slot");
    quitARSlot.setAttribute("name", "quit-ar");
    this.appendElement(quitARSlot, element);
    this._createdAROnlyElements.push(quitARSlot);
    quitARSlot.style.pointerEvents = "auto";
    const quitARElement = document.querySelector(`.${quitARClassName}`);
    if (quitARElement) {
      quitARElement.addEventListener("click", this.requestEndAR);
      if (debug32)
        quitARElement.addEventListener("click", () => console.log("Clicked quit-ar button"));
      return;
    }
    quitARSlot.addEventListener("click", this.requestEndAR);
    if (debug32)
      quitARSlot.addEventListener("click", () => console.log("Clicked fallback close button"));
    const fixedButtonContainer = document.createElement("div");
    fixedButtonContainer.style.cssText = `
            position: fixed;
            top: 0;
            right: 0;
            z-index: 600;
            pointer-events: all;
        `;
    this.appendElement(fixedButtonContainer, quitARSlot);
    var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.classList.add("quit-ar-button");
    svg.setAttribute("width", "40px");
    svg.setAttribute("height", "40px");
    svg.style.cssText = `
            background: rgba(255, 255, 255, .4);
            -webkit-backdrop-filter: blur(8px);
            backdrop-filter: blur(8px);
            border-radius: 50%;
            box-shadow: 0 0 5px rgba(0,0,0,.3);
            outline: 1px solid rgba(255, 255, 255, .6);
            display: flex;
            justify-content: center;
            align-items: center;
        `;
    fixedButtonContainer.appendChild(svg);
    var path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("d", "M 12,12 L 28,28 M 28,12 12,28");
    path.setAttribute("stroke", "#000000");
    path.setAttribute("stroke-width", "2px");
    path.style.cssText = `
            /**filter: drop-shadow(0 0px 1.2px rgba(0,0,0,.7));**/
        `;
    svg.appendChild(path);
    if (debug32)
      console.log("Created fallback close button", svg, element);
  }
  appendElement(element, parent) {
    if (parent.shadowRoot)
      return parent.shadowRoot.appendChild(element);
    return parent.appendChild(element);
  }
};

// node_modules/@needle-tools/engine/lib/engine/engine_loaders.js
var debug33 = getParam("debugdecoders");
var loaders = null;
function ensureLoaders() {
  if (!loaders) {
    const res = createLoaders(null);
    loaders = { dracoLoader: res.dracoLoader, ktx2Loader: res.ktx2Loader, meshoptDecoder: res.meshoptDecoder };
  }
  return loaders;
}
function setDracoDecoderPath(path) {
  if (path !== void 0 && typeof path === "string") {
    setDracoDecoderLocation(path);
    const loaders2 = ensureLoaders();
    if (debug33)
      console.log("Setting draco decoder path to", path);
    loaders2.dracoLoader.setDecoderPath(path);
  }
}
function setDracoDecoderType(type) {
  if (type !== void 0 && typeof type === "string") {
    const loaders2 = ensureLoaders();
    if (debug33)
      console.log("Setting draco decoder type to", type);
    loaders2.dracoLoader.setDecoderConfig({ type });
  }
}
function setKtx2TranscoderPath(path) {
  if (path !== void 0 && typeof path === "string") {
    setKTX2TranscoderLocation(path);
    const loaders2 = ensureLoaders();
    if (debug33)
      console.log("Setting ktx2 transcoder path to", path);
    loaders2.ktx2Loader.setTranscoderPath(path);
  }
}
function addDracoAndKTX2Loaders2(loader2, context) {
  const loaders2 = ensureLoaders();
  if (context.renderer) {
    loaders2.ktx2Loader.detectSupport(context.renderer);
  } else
    console.warn("No renderer provided to detect ktx2 support - loading KTX2 textures will probably fail");
  addDracoAndKTX2Loaders(loader2);
  if (!loader2.dracoLoader)
    loader2.setDRACOLoader(loaders2.dracoLoader);
  if (!loader2.ktx2Loader)
    loader2.setKTX2Loader(loaders2.ktx2Loader);
  if (!loader2.meshoptDecoder)
    loader2.setMeshoptDecoder(loaders2.meshoptDecoder);
  configureLoader(loader2, {
    progressive: true
  });
  return loader2;
}

// node_modules/three/examples/jsm/curves/NURBSUtils.js
function findSpan(p, u2, U) {
  const n2 = U.length - p - 1;
  if (u2 >= U[n2]) {
    return n2 - 1;
  }
  if (u2 <= U[p]) {
    return p;
  }
  let low = p;
  let high = n2;
  let mid = Math.floor((low + high) / 2);
  while (u2 < U[mid] || u2 >= U[mid + 1]) {
    if (u2 < U[mid]) {
      high = mid;
    } else {
      low = mid;
    }
    mid = Math.floor((low + high) / 2);
  }
  return mid;
}
function calcBasisFunctions(span, u2, p, U) {
  const N = [];
  const left = [];
  const right = [];
  N[0] = 1;
  for (let j = 1; j <= p; ++j) {
    left[j] = u2 - U[span + 1 - j];
    right[j] = U[span + j] - u2;
    let saved = 0;
    for (let r = 0; r < j; ++r) {
      const rv = right[r + 1];
      const lv = left[j - r];
      const temp = N[r] / (rv + lv);
      N[r] = saved + rv * temp;
      saved = lv * temp;
    }
    N[j] = saved;
  }
  return N;
}
function calcBSplinePoint(p, U, P2, u2) {
  const span = findSpan(p, u2, U);
  const N = calcBasisFunctions(span, u2, p, U);
  const C4 = new Vector4(0, 0, 0, 0);
  for (let j = 0; j <= p; ++j) {
    const point = P2[span - p + j];
    const Nj = N[j];
    const wNj = point.w * Nj;
    C4.x += point.x * wNj;
    C4.y += point.y * wNj;
    C4.z += point.z * wNj;
    C4.w += point.w * Nj;
  }
  return C4;
}
function calcBasisFunctionDerivatives(span, u2, p, n2, U) {
  const zeroArr = [];
  for (let i = 0; i <= p; ++i)
    zeroArr[i] = 0;
  const ders = [];
  for (let i = 0; i <= n2; ++i)
    ders[i] = zeroArr.slice(0);
  const ndu = [];
  for (let i = 0; i <= p; ++i)
    ndu[i] = zeroArr.slice(0);
  ndu[0][0] = 1;
  const left = zeroArr.slice(0);
  const right = zeroArr.slice(0);
  for (let j = 1; j <= p; ++j) {
    left[j] = u2 - U[span + 1 - j];
    right[j] = U[span + j] - u2;
    let saved = 0;
    for (let r2 = 0; r2 < j; ++r2) {
      const rv = right[r2 + 1];
      const lv = left[j - r2];
      ndu[j][r2] = rv + lv;
      const temp = ndu[r2][j - 1] / ndu[j][r2];
      ndu[r2][j] = saved + rv * temp;
      saved = lv * temp;
    }
    ndu[j][j] = saved;
  }
  for (let j = 0; j <= p; ++j) {
    ders[0][j] = ndu[j][p];
  }
  for (let r2 = 0; r2 <= p; ++r2) {
    let s1 = 0;
    let s2 = 1;
    const a = [];
    for (let i = 0; i <= p; ++i) {
      a[i] = zeroArr.slice(0);
    }
    a[0][0] = 1;
    for (let k = 1; k <= n2; ++k) {
      let d = 0;
      const rk = r2 - k;
      const pk = p - k;
      if (r2 >= k) {
        a[s2][0] = a[s1][0] / ndu[pk + 1][rk];
        d = a[s2][0] * ndu[rk][pk];
      }
      const j1 = rk >= -1 ? 1 : -rk;
      const j2 = r2 - 1 <= pk ? k - 1 : p - r2;
      for (let j3 = j1; j3 <= j2; ++j3) {
        a[s2][j3] = (a[s1][j3] - a[s1][j3 - 1]) / ndu[pk + 1][rk + j3];
        d += a[s2][j3] * ndu[rk + j3][pk];
      }
      if (r2 <= pk) {
        a[s2][k] = -a[s1][k - 1] / ndu[pk + 1][r2];
        d += a[s2][k] * ndu[r2][pk];
      }
      ders[k][r2] = d;
      const j = s1;
      s1 = s2;
      s2 = j;
    }
  }
  let r = p;
  for (let k = 1; k <= n2; ++k) {
    for (let j = 0; j <= p; ++j) {
      ders[k][j] *= r;
    }
    r *= p - k;
  }
  return ders;
}
function calcBSplineDerivatives(p, U, P2, u2, nd) {
  const du = nd < p ? nd : p;
  const CK = [];
  const span = findSpan(p, u2, U);
  const nders = calcBasisFunctionDerivatives(span, u2, p, du, U);
  const Pw = [];
  for (let i = 0; i < P2.length; ++i) {
    const point = P2[i].clone();
    const w = point.w;
    point.x *= w;
    point.y *= w;
    point.z *= w;
    Pw[i] = point;
  }
  for (let k = 0; k <= du; ++k) {
    const point = Pw[span - p].clone().multiplyScalar(nders[k][0]);
    for (let j = 1; j <= p; ++j) {
      point.add(Pw[span - p + j].clone().multiplyScalar(nders[k][j]));
    }
    CK[k] = point;
  }
  for (let k = du + 1; k <= nd + 1; ++k) {
    CK[k] = new Vector4(0, 0, 0);
  }
  return CK;
}
function calcKoverI(k, i) {
  let nom = 1;
  for (let j = 2; j <= k; ++j) {
    nom *= j;
  }
  let denom = 1;
  for (let j = 2; j <= i; ++j) {
    denom *= j;
  }
  for (let j = 2; j <= k - i; ++j) {
    denom *= j;
  }
  return nom / denom;
}
function calcRationalCurveDerivatives(Pders) {
  const nd = Pders.length;
  const Aders = [];
  const wders = [];
  for (let i = 0; i < nd; ++i) {
    const point = Pders[i];
    Aders[i] = new Vector32(point.x, point.y, point.z);
    wders[i] = point.w;
  }
  const CK = [];
  for (let k = 0; k < nd; ++k) {
    const v4 = Aders[k].clone();
    for (let i = 1; i <= k; ++i) {
      v4.sub(CK[k - i].clone().multiplyScalar(calcKoverI(k, i) * wders[i]));
    }
    CK[k] = v4.divideScalar(wders[0]);
  }
  return CK;
}
function calcNURBSDerivatives(p, U, P2, u2, nd) {
  const Pders = calcBSplineDerivatives(p, U, P2, u2, nd);
  return calcRationalCurveDerivatives(Pders);
}

// node_modules/three/examples/jsm/curves/NURBSCurve.js
var NURBSCurve = class extends Curve {
  constructor(degree, knots, controlPoints, startKnot, endKnot) {
    super();
    this.degree = degree;
    this.knots = knots;
    this.controlPoints = [];
    this.startKnot = startKnot || 0;
    this.endKnot = endKnot || this.knots.length - 1;
    for (let i = 0; i < controlPoints.length; ++i) {
      const point = controlPoints[i];
      this.controlPoints[i] = new Vector4(point.x, point.y, point.z, point.w);
    }
  }
  getPoint(t2, optionalTarget = new Vector32()) {
    const point = optionalTarget;
    const u2 = this.knots[this.startKnot] + t2 * (this.knots[this.endKnot] - this.knots[this.startKnot]);
    const hpoint = calcBSplinePoint(this.degree, this.knots, this.controlPoints, u2);
    if (hpoint.w !== 1) {
      hpoint.divideScalar(hpoint.w);
    }
    return point.set(hpoint.x, hpoint.y, hpoint.z);
  }
  getTangent(t2, optionalTarget = new Vector32()) {
    const tangent = optionalTarget;
    const u2 = this.knots[0] + t2 * (this.knots[this.knots.length - 1] - this.knots[0]);
    const ders = calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, u2, 1);
    tangent.copy(ders[1]).normalize();
    return tangent;
  }
};

// node_modules/three/examples/jsm/loaders/FBXLoader.js
var fbxTree;
var connections;
var sceneGraph;
var FBXLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad2, onProgress, onError2) {
    const scope = this;
    const path = scope.path === "" ? LoaderUtils.extractUrlBase(url) : scope.path;
    const loader2 = new FileLoader(this.manager);
    loader2.setPath(scope.path);
    loader2.setResponseType("arraybuffer");
    loader2.setRequestHeader(scope.requestHeader);
    loader2.setWithCredentials(scope.withCredentials);
    loader2.load(url, function(buffer2) {
      try {
        onLoad2(scope.parse(buffer2, path));
      } catch (e) {
        if (onError2) {
          onError2(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError2);
  }
  parse(FBXBuffer, path) {
    if (isFbxFormatBinary(FBXBuffer)) {
      fbxTree = new BinaryParser().parse(FBXBuffer);
    } else {
      const FBXText = convertArrayBufferToString(FBXBuffer);
      if (!isFbxFormatASCII(FBXText)) {
        throw new Error("THREE.FBXLoader: Unknown format.");
      }
      if (getFbxVersion(FBXText) < 7e3) {
        throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + getFbxVersion(FBXText));
      }
      fbxTree = new TextParser().parse(FBXText);
    }
    const textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);
    return new FBXTreeParser(textureLoader, this.manager).parse(fbxTree);
  }
};
var FBXTreeParser = class {
  constructor(textureLoader, manager) {
    this.textureLoader = textureLoader;
    this.manager = manager;
  }
  parse() {
    connections = this.parseConnections();
    const images = this.parseImages();
    const textures2 = this.parseTextures(images);
    const materials = this.parseMaterials(textures2);
    const deformers = this.parseDeformers();
    const geometryMap = new GeometryParser().parse(deformers);
    this.parseScene(deformers, geometryMap, materials);
    return sceneGraph;
  }
  // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
  // and details the connection type
  parseConnections() {
    const connectionMap = /* @__PURE__ */ new Map();
    if ("Connections" in fbxTree) {
      const rawConnections = fbxTree.Connections.connections;
      rawConnections.forEach(function(rawConnection) {
        const fromID = rawConnection[0];
        const toID = rawConnection[1];
        const relationship = rawConnection[2];
        if (!connectionMap.has(fromID)) {
          connectionMap.set(fromID, {
            parents: [],
            children: []
          });
        }
        const parentRelationship = { ID: toID, relationship };
        connectionMap.get(fromID).parents.push(parentRelationship);
        if (!connectionMap.has(toID)) {
          connectionMap.set(toID, {
            parents: [],
            children: []
          });
        }
        const childRelationship = { ID: fromID, relationship };
        connectionMap.get(toID).children.push(childRelationship);
      });
    }
    return connectionMap;
  }
  // Parse FBXTree.Objects.Video for embedded image data
  // These images are connected to textures in FBXTree.Objects.Textures
  // via FBXTree.Connections.
  parseImages() {
    const images = {};
    const blobs = {};
    if ("Video" in fbxTree.Objects) {
      const videoNodes = fbxTree.Objects.Video;
      for (const nodeID in videoNodes) {
        const videoNode = videoNodes[nodeID];
        const id = parseInt(nodeID);
        images[id] = videoNode.RelativeFilename || videoNode.Filename;
        if ("Content" in videoNode) {
          const arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0;
          const base64Content = typeof videoNode.Content === "string" && videoNode.Content !== "";
          if (arrayBufferContent || base64Content) {
            const image = this.parseImage(videoNodes[nodeID]);
            blobs[videoNode.RelativeFilename || videoNode.Filename] = image;
          }
        }
      }
    }
    for (const id in images) {
      const filename = images[id];
      if (blobs[filename] !== void 0)
        images[id] = blobs[filename];
      else
        images[id] = images[id].split("\\").pop();
    }
    return images;
  }
  // Parse embedded image data in FBXTree.Video.Content
  parseImage(videoNode) {
    const content = videoNode.Content;
    const fileName = videoNode.RelativeFilename || videoNode.Filename;
    const extension = fileName.slice(fileName.lastIndexOf(".") + 1).toLowerCase();
    let type;
    switch (extension) {
      case "bmp":
        type = "image/bmp";
        break;
      case "jpg":
      case "jpeg":
        type = "image/jpeg";
        break;
      case "png":
        type = "image/png";
        break;
      case "tif":
        type = "image/tiff";
        break;
      case "tga":
        if (this.manager.getHandler(".tga") === null) {
          console.warn("FBXLoader: TGA loader not found, skipping ", fileName);
        }
        type = "image/tga";
        break;
      default:
        console.warn('FBXLoader: Image type "' + extension + '" is not supported.');
        return;
    }
    if (typeof content === "string") {
      return "data:" + type + ";base64," + content;
    } else {
      const array = new Uint8Array(content);
      return window.URL.createObjectURL(new Blob([array], { type }));
    }
  }
  // Parse nodes in FBXTree.Objects.Texture
  // These contain details such as UV scaling, cropping, rotation etc and are connected
  // to images in FBXTree.Objects.Video
  parseTextures(images) {
    const textureMap = /* @__PURE__ */ new Map();
    if ("Texture" in fbxTree.Objects) {
      const textureNodes = fbxTree.Objects.Texture;
      for (const nodeID in textureNodes) {
        const texture = this.parseTexture(textureNodes[nodeID], images);
        textureMap.set(parseInt(nodeID), texture);
      }
    }
    return textureMap;
  }
  // Parse individual node in FBXTree.Objects.Texture
  parseTexture(textureNode, images) {
    const texture = this.loadTexture(textureNode, images);
    texture.ID = textureNode.id;
    texture.name = textureNode.attrName;
    const wrapModeU = textureNode.WrapModeU;
    const wrapModeV = textureNode.WrapModeV;
    const valueU = wrapModeU !== void 0 ? wrapModeU.value : 0;
    const valueV = wrapModeV !== void 0 ? wrapModeV.value : 0;
    texture.wrapS = valueU === 0 ? RepeatWrapping : ClampToEdgeWrapping;
    texture.wrapT = valueV === 0 ? RepeatWrapping : ClampToEdgeWrapping;
    if ("Scaling" in textureNode) {
      const values = textureNode.Scaling.value;
      texture.repeat.x = values[0];
      texture.repeat.y = values[1];
    }
    if ("Translation" in textureNode) {
      const values = textureNode.Translation.value;
      texture.offset.x = values[0];
      texture.offset.y = values[1];
    }
    return texture;
  }
  // load a texture specified as a blob or data URI, or via an external URL using TextureLoader
  loadTexture(textureNode, images) {
    const nonNativeExtensions = /* @__PURE__ */ new Set(["tga", "tif", "tiff", "exr", "dds", "hdr", "ktx2"]);
    const extension = textureNode.FileName.split(".").pop().toLowerCase();
    const loader2 = nonNativeExtensions.has(extension) ? this.manager.getHandler(`.${extension}`) : this.textureLoader;
    if (!loader2) {
      console.warn(
        `FBXLoader: ${extension.toUpperCase()} loader not found, creating placeholder texture for`,
        textureNode.RelativeFilename
      );
      return new Texture();
    }
    const loaderPath = loader2.path;
    if (!loaderPath) {
      loader2.setPath(this.textureLoader.path);
    }
    const children = connections.get(textureNode.id).children;
    let fileName;
    if (children !== void 0 && children.length > 0 && images[children[0].ID] !== void 0) {
      fileName = images[children[0].ID];
      if (fileName.indexOf("blob:") === 0 || fileName.indexOf("data:") === 0) {
        loader2.setPath(void 0);
      }
    }
    const texture = loader2.load(fileName);
    loader2.setPath(loaderPath);
    return texture;
  }
  // Parse nodes in FBXTree.Objects.Material
  parseMaterials(textureMap) {
    const materialMap = /* @__PURE__ */ new Map();
    if ("Material" in fbxTree.Objects) {
      const materialNodes = fbxTree.Objects.Material;
      for (const nodeID in materialNodes) {
        const material = this.parseMaterial(materialNodes[nodeID], textureMap);
        if (material !== null)
          materialMap.set(parseInt(nodeID), material);
      }
    }
    return materialMap;
  }
  // Parse single node in FBXTree.Objects.Material
  // Materials are connected to texture maps in FBXTree.Objects.Textures
  // FBX format currently only supports Lambert and Phong shading models
  parseMaterial(materialNode, textureMap) {
    const ID = materialNode.id;
    const name = materialNode.attrName;
    let type = materialNode.ShadingModel;
    if (typeof type === "object") {
      type = type.value;
    }
    if (!connections.has(ID))
      return null;
    const parameters = this.parseParameters(materialNode, textureMap, ID);
    let material;
    switch (type.toLowerCase()) {
      case "phong":
        material = new MeshPhongMaterial();
        break;
      case "lambert":
        material = new MeshLambertMaterial();
        break;
      default:
        console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', type);
        material = new MeshPhongMaterial();
        break;
    }
    material.setValues(parameters);
    material.name = name;
    return material;
  }
  // Parse FBX material and return parameters suitable for a three.js material
  // Also parse the texture map and return any textures associated with the material
  parseParameters(materialNode, textureMap, ID) {
    const parameters = {};
    if (materialNode.BumpFactor) {
      parameters.bumpScale = materialNode.BumpFactor.value;
    }
    if (materialNode.Diffuse) {
      parameters.color = ColorManagement.toWorkingColorSpace(new Color().fromArray(materialNode.Diffuse.value), SRGBColorSpace);
    } else if (materialNode.DiffuseColor && (materialNode.DiffuseColor.type === "Color" || materialNode.DiffuseColor.type === "ColorRGB")) {
      parameters.color = ColorManagement.toWorkingColorSpace(new Color().fromArray(materialNode.DiffuseColor.value), SRGBColorSpace);
    }
    if (materialNode.DisplacementFactor) {
      parameters.displacementScale = materialNode.DisplacementFactor.value;
    }
    if (materialNode.Emissive) {
      parameters.emissive = ColorManagement.toWorkingColorSpace(new Color().fromArray(materialNode.Emissive.value), SRGBColorSpace);
    } else if (materialNode.EmissiveColor && (materialNode.EmissiveColor.type === "Color" || materialNode.EmissiveColor.type === "ColorRGB")) {
      parameters.emissive = ColorManagement.toWorkingColorSpace(new Color().fromArray(materialNode.EmissiveColor.value), SRGBColorSpace);
    }
    if (materialNode.EmissiveFactor) {
      parameters.emissiveIntensity = parseFloat(materialNode.EmissiveFactor.value);
    }
    if (materialNode.Opacity) {
      parameters.opacity = parseFloat(materialNode.Opacity.value);
    }
    if (parameters.opacity < 1) {
      parameters.transparent = true;
    }
    if (materialNode.ReflectionFactor) {
      parameters.reflectivity = materialNode.ReflectionFactor.value;
    }
    if (materialNode.Shininess) {
      parameters.shininess = materialNode.Shininess.value;
    }
    if (materialNode.Specular) {
      parameters.specular = ColorManagement.toWorkingColorSpace(new Color().fromArray(materialNode.Specular.value), SRGBColorSpace);
    } else if (materialNode.SpecularColor && materialNode.SpecularColor.type === "Color") {
      parameters.specular = ColorManagement.toWorkingColorSpace(new Color().fromArray(materialNode.SpecularColor.value), SRGBColorSpace);
    }
    const scope = this;
    connections.get(ID).children.forEach(function(child) {
      const type = child.relationship;
      switch (type) {
        case "Bump":
          parameters.bumpMap = scope.getTexture(textureMap, child.ID);
          break;
        case "Maya|TEX_ao_map":
          parameters.aoMap = scope.getTexture(textureMap, child.ID);
          break;
        case "DiffuseColor":
        case "Maya|TEX_color_map":
          parameters.map = scope.getTexture(textureMap, child.ID);
          if (parameters.map !== void 0) {
            parameters.map.colorSpace = SRGBColorSpace;
          }
          break;
        case "DisplacementColor":
          parameters.displacementMap = scope.getTexture(textureMap, child.ID);
          break;
        case "EmissiveColor":
          parameters.emissiveMap = scope.getTexture(textureMap, child.ID);
          if (parameters.emissiveMap !== void 0) {
            parameters.emissiveMap.colorSpace = SRGBColorSpace;
          }
          break;
        case "NormalMap":
        case "Maya|TEX_normal_map":
          parameters.normalMap = scope.getTexture(textureMap, child.ID);
          break;
        case "ReflectionColor":
          parameters.envMap = scope.getTexture(textureMap, child.ID);
          if (parameters.envMap !== void 0) {
            parameters.envMap.mapping = EquirectangularReflectionMapping;
            parameters.envMap.colorSpace = SRGBColorSpace;
          }
          break;
        case "SpecularColor":
          parameters.specularMap = scope.getTexture(textureMap, child.ID);
          if (parameters.specularMap !== void 0) {
            parameters.specularMap.colorSpace = SRGBColorSpace;
          }
          break;
        case "TransparentColor":
        case "TransparencyFactor":
          parameters.alphaMap = scope.getTexture(textureMap, child.ID);
          parameters.transparent = true;
          break;
        case "AmbientColor":
        case "ShininessExponent":
        case "SpecularFactor":
        case "VectorDisplacementColor":
        default:
          console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", type);
          break;
      }
    });
    return parameters;
  }
  // get a texture from the textureMap for use by a material.
  getTexture(textureMap, id) {
    if ("LayeredTexture" in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture) {
      console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.");
      id = connections.get(id).children[0].ID;
    }
    return textureMap.get(id);
  }
  // Parse nodes in FBXTree.Objects.Deformer
  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.
  parseDeformers() {
    const skeletons = {};
    const morphTargets = {};
    if ("Deformer" in fbxTree.Objects) {
      const DeformerNodes = fbxTree.Objects.Deformer;
      for (const nodeID in DeformerNodes) {
        const deformerNode = DeformerNodes[nodeID];
        const relationships = connections.get(parseInt(nodeID));
        if (deformerNode.attrType === "Skin") {
          const skeleton = this.parseSkeleton(relationships, DeformerNodes);
          skeleton.ID = nodeID;
          if (relationships.parents.length > 1)
            console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported.");
          skeleton.geometryID = relationships.parents[0].ID;
          skeletons[nodeID] = skeleton;
        } else if (deformerNode.attrType === "BlendShape") {
          const morphTarget = {
            id: nodeID
          };
          morphTarget.rawTargets = this.parseMorphTargets(relationships, DeformerNodes);
          morphTarget.id = nodeID;
          if (relationships.parents.length > 1)
            console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported.");
          morphTargets[nodeID] = morphTarget;
        }
      }
    }
    return {
      skeletons,
      morphTargets
    };
  }
  // Parse single nodes in FBXTree.Objects.Deformer
  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
  // Each skin node represents a skeleton and each cluster node represents a bone
  parseSkeleton(relationships, deformerNodes) {
    const rawBones = [];
    relationships.children.forEach(function(child) {
      const boneNode = deformerNodes[child.ID];
      if (boneNode.attrType !== "Cluster")
        return;
      const rawBone = {
        ID: child.ID,
        indices: [],
        weights: [],
        transformLink: new Matrix4().fromArray(boneNode.TransformLink.a)
        // transform: new Matrix4().fromArray( boneNode.Transform.a ),
        // linkMode: boneNode.Mode,
      };
      if ("Indexes" in boneNode) {
        rawBone.indices = boneNode.Indexes.a;
        rawBone.weights = boneNode.Weights.a;
      }
      rawBones.push(rawBone);
    });
    return {
      rawBones,
      bones: []
    };
  }
  // The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
  parseMorphTargets(relationships, deformerNodes) {
    const rawMorphTargets = [];
    for (let i = 0; i < relationships.children.length; i++) {
      const child = relationships.children[i];
      const morphTargetNode = deformerNodes[child.ID];
      const rawMorphTarget = {
        name: morphTargetNode.attrName,
        initialWeight: morphTargetNode.DeformPercent,
        id: morphTargetNode.id,
        fullWeights: morphTargetNode.FullWeights.a
      };
      if (morphTargetNode.attrType !== "BlendShapeChannel")
        return;
      rawMorphTarget.geoID = connections.get(parseInt(child.ID)).children.filter(function(child2) {
        return child2.relationship === void 0;
      })[0].ID;
      rawMorphTargets.push(rawMorphTarget);
    }
    return rawMorphTargets;
  }
  // create the main Group() to be returned by the loader
  parseScene(deformers, geometryMap, materialMap) {
    sceneGraph = new Group();
    const modelMap = this.parseModels(deformers.skeletons, geometryMap, materialMap);
    const modelNodes = fbxTree.Objects.Model;
    const scope = this;
    modelMap.forEach(function(model) {
      var _a2;
      const modelNode = modelNodes[model.ID];
      scope.setLookAtProperties(model, modelNode);
      const parentConnections = (_a2 = connections.get(model.ID)) == null ? void 0 : _a2.parents;
      parentConnections == null ? void 0 : parentConnections.forEach(function(connection) {
        const parent = modelMap.get(connection.ID);
        if (parent !== void 0)
          parent.add(model);
      });
      if (model.parent === null) {
        sceneGraph.add(model);
      }
    });
    this.bindSkeleton(deformers.skeletons, geometryMap, modelMap);
    this.addGlobalSceneSettings();
    sceneGraph.traverse(function(node) {
      if (node.userData.transformData) {
        if (node.parent) {
          node.userData.transformData.parentMatrix = node.parent.matrix;
          node.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;
        }
        const transform = generateTransform(node.userData.transformData);
        node.applyMatrix4(transform);
        node.updateWorldMatrix();
      }
    });
    const animations = new AnimationParser().parse();
    if (sceneGraph.children.length === 1 && sceneGraph.children[0].isGroup) {
      sceneGraph.children[0].animations = animations;
      sceneGraph = sceneGraph.children[0];
    }
    sceneGraph.animations = animations;
  }
  // parse nodes in FBXTree.Objects.Model
  parseModels(skeletons, geometryMap, materialMap) {
    const modelMap = /* @__PURE__ */ new Map();
    const modelNodes = fbxTree.Objects.Model;
    for (const nodeID in modelNodes) {
      const id = parseInt(nodeID);
      const node = modelNodes[nodeID];
      const relationships = connections.get(id);
      let model = this.buildSkeleton(relationships, skeletons, id, node.attrName);
      if (!model) {
        switch (node.attrType) {
          case "Camera":
            model = this.createCamera(relationships);
            break;
          case "Light":
            model = this.createLight(relationships);
            break;
          case "Mesh":
            model = this.createMesh(relationships, geometryMap, materialMap);
            break;
          case "NurbsCurve":
            model = this.createCurve(relationships, geometryMap);
            break;
          case "LimbNode":
          case "Root":
            model = new Bone();
            break;
          case "Null":
          default:
            model = new Group();
            break;
        }
        model.name = node.attrName ? PropertyBinding.sanitizeNodeName(node.attrName) : "";
        model.userData.originalName = node.attrName;
        model.ID = id;
      }
      this.getTransformData(model, node);
      modelMap.set(id, model);
    }
    return modelMap;
  }
  buildSkeleton(relationships, skeletons, id, name) {
    let bone = null;
    relationships == null ? void 0 : relationships.parents.forEach(function(parent) {
      for (const ID in skeletons) {
        const skeleton = skeletons[ID];
        skeleton.rawBones.forEach(function(rawBone, i) {
          if (rawBone.ID === parent.ID) {
            const subBone = bone;
            bone = new Bone();
            bone.matrixWorld.copy(rawBone.transformLink);
            bone.name = name ? PropertyBinding.sanitizeNodeName(name) : "";
            bone.userData.originalName = name;
            bone.ID = id;
            skeleton.bones[i] = bone;
            if (subBone !== null) {
              bone.add(subBone);
            }
          }
        });
      }
    });
    return bone;
  }
  // create a PerspectiveCamera or OrthographicCamera
  createCamera(relationships) {
    let model;
    let cameraAttribute;
    relationships.children.forEach(function(child) {
      const attr = fbxTree.Objects.NodeAttribute[child.ID];
      if (attr !== void 0) {
        cameraAttribute = attr;
      }
    });
    if (cameraAttribute === void 0) {
      model = new Object3D();
    } else {
      let type = 0;
      if (cameraAttribute.CameraProjectionType !== void 0 && cameraAttribute.CameraProjectionType.value === 1) {
        type = 1;
      }
      let nearClippingPlane = 1;
      if (cameraAttribute.NearPlane !== void 0) {
        nearClippingPlane = cameraAttribute.NearPlane.value / 1e3;
      }
      let farClippingPlane = 1e3;
      if (cameraAttribute.FarPlane !== void 0) {
        farClippingPlane = cameraAttribute.FarPlane.value / 1e3;
      }
      let width = window.innerWidth;
      let height = window.innerHeight;
      if (cameraAttribute.AspectWidth !== void 0 && cameraAttribute.AspectHeight !== void 0) {
        width = cameraAttribute.AspectWidth.value;
        height = cameraAttribute.AspectHeight.value;
      }
      const aspect = width / height;
      let fov = 45;
      if (cameraAttribute.FieldOfView !== void 0) {
        fov = cameraAttribute.FieldOfView.value;
      }
      const focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;
      switch (type) {
        case 0:
          model = new PerspectiveCamera(fov, aspect, nearClippingPlane, farClippingPlane);
          if (focalLength !== null)
            model.setFocalLength(focalLength);
          break;
        case 1:
          console.warn("THREE.FBXLoader: Orthographic cameras not supported yet.");
          model = new Object3D();
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown camera type " + type + ".");
          model = new Object3D();
          break;
      }
    }
    return model;
  }
  // Create a DirectionalLight, PointLight or SpotLight
  createLight(relationships) {
    let model;
    let lightAttribute;
    relationships.children.forEach(function(child) {
      const attr = fbxTree.Objects.NodeAttribute[child.ID];
      if (attr !== void 0) {
        lightAttribute = attr;
      }
    });
    if (lightAttribute === void 0) {
      model = new Object3D();
    } else {
      let type;
      if (lightAttribute.LightType === void 0) {
        type = 0;
      } else {
        type = lightAttribute.LightType.value;
      }
      let color2 = 16777215;
      if (lightAttribute.Color !== void 0) {
        color2 = ColorManagement.toWorkingColorSpace(new Color().fromArray(lightAttribute.Color.value), SRGBColorSpace);
      }
      let intensity = lightAttribute.Intensity === void 0 ? 1 : lightAttribute.Intensity.value / 100;
      if (lightAttribute.CastLightOnObject !== void 0 && lightAttribute.CastLightOnObject.value === 0) {
        intensity = 0;
      }
      let distance = 0;
      if (lightAttribute.FarAttenuationEnd !== void 0) {
        if (lightAttribute.EnableFarAttenuation !== void 0 && lightAttribute.EnableFarAttenuation.value === 0) {
          distance = 0;
        } else {
          distance = lightAttribute.FarAttenuationEnd.value;
        }
      }
      const decay = 1;
      switch (type) {
        case 0:
          model = new PointLight(color2, intensity, distance, decay);
          break;
        case 1:
          model = new DirectionalLight(color2, intensity);
          break;
        case 2:
          let angle = Math.PI / 3;
          if (lightAttribute.InnerAngle !== void 0) {
            angle = MathUtils.degToRad(lightAttribute.InnerAngle.value);
          }
          let penumbra = 0;
          if (lightAttribute.OuterAngle !== void 0) {
            penumbra = MathUtils.degToRad(lightAttribute.OuterAngle.value);
            penumbra = Math.max(penumbra, 1);
          }
          model = new SpotLight(color2, intensity, distance, angle, penumbra, decay);
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown light type " + lightAttribute.LightType.value + ", defaulting to a PointLight.");
          model = new PointLight(color2, intensity);
          break;
      }
      if (lightAttribute.CastShadows !== void 0 && lightAttribute.CastShadows.value === 1) {
        model.castShadow = true;
      }
    }
    return model;
  }
  createMesh(relationships, geometryMap, materialMap) {
    let model;
    let geometry = null;
    let material = null;
    const materials = [];
    relationships.children.forEach(function(child) {
      if (geometryMap.has(child.ID)) {
        geometry = geometryMap.get(child.ID);
      }
      if (materialMap.has(child.ID)) {
        materials.push(materialMap.get(child.ID));
      }
    });
    if (materials.length > 1) {
      material = materials;
    } else if (materials.length > 0) {
      material = materials[0];
    } else {
      material = new MeshPhongMaterial({
        name: Loader.DEFAULT_MATERIAL_NAME,
        color: 13421772
      });
      materials.push(material);
    }
    if ("color" in geometry.attributes) {
      materials.forEach(function(material2) {
        material2.vertexColors = true;
      });
    }
    if (geometry.FBX_Deformer) {
      model = new SkinnedMesh(geometry, material);
      model.normalizeSkinWeights();
    } else {
      model = new Mesh(geometry, material);
    }
    return model;
  }
  createCurve(relationships, geometryMap) {
    const geometry = relationships.children.reduce(function(geo, child) {
      if (geometryMap.has(child.ID))
        geo = geometryMap.get(child.ID);
      return geo;
    }, null);
    const material = new LineBasicMaterial({
      name: Loader.DEFAULT_MATERIAL_NAME,
      color: 3342591,
      linewidth: 1
    });
    return new Line(geometry, material);
  }
  // parse the model node for transform data
  getTransformData(model, modelNode) {
    const transformData = {};
    if ("InheritType" in modelNode)
      transformData.inheritType = parseInt(modelNode.InheritType.value);
    if ("RotationOrder" in modelNode)
      transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);
    else
      transformData.eulerOrder = getEulerOrder(0);
    if ("Lcl_Translation" in modelNode)
      transformData.translation = modelNode.Lcl_Translation.value;
    if ("PreRotation" in modelNode)
      transformData.preRotation = modelNode.PreRotation.value;
    if ("Lcl_Rotation" in modelNode)
      transformData.rotation = modelNode.Lcl_Rotation.value;
    if ("PostRotation" in modelNode)
      transformData.postRotation = modelNode.PostRotation.value;
    if ("Lcl_Scaling" in modelNode)
      transformData.scale = modelNode.Lcl_Scaling.value;
    if ("ScalingOffset" in modelNode)
      transformData.scalingOffset = modelNode.ScalingOffset.value;
    if ("ScalingPivot" in modelNode)
      transformData.scalingPivot = modelNode.ScalingPivot.value;
    if ("RotationOffset" in modelNode)
      transformData.rotationOffset = modelNode.RotationOffset.value;
    if ("RotationPivot" in modelNode)
      transformData.rotationPivot = modelNode.RotationPivot.value;
    model.userData.transformData = transformData;
  }
  setLookAtProperties(model, modelNode) {
    if ("LookAtProperty" in modelNode) {
      const children = connections.get(model.ID).children;
      children.forEach(function(child) {
        if (child.relationship === "LookAtProperty") {
          const lookAtTarget = fbxTree.Objects.Model[child.ID];
          if ("Lcl_Translation" in lookAtTarget) {
            const pos = lookAtTarget.Lcl_Translation.value;
            if (model.target !== void 0) {
              model.target.position.fromArray(pos);
              sceneGraph.add(model.target);
            } else {
              model.lookAt(new Vector32().fromArray(pos));
            }
          }
        }
      });
    }
  }
  bindSkeleton(skeletons, geometryMap, modelMap) {
    const bindMatrices = this.parsePoseNodes();
    for (const ID in skeletons) {
      const skeleton = skeletons[ID];
      const parents = connections.get(parseInt(skeleton.ID)).parents;
      parents.forEach(function(parent) {
        if (geometryMap.has(parent.ID)) {
          const geoID = parent.ID;
          const geoRelationships = connections.get(geoID);
          geoRelationships.parents.forEach(function(geoConnParent) {
            if (modelMap.has(geoConnParent.ID)) {
              const model = modelMap.get(geoConnParent.ID);
              model.bind(new Skeleton(skeleton.bones), bindMatrices[geoConnParent.ID]);
            }
          });
        }
      });
    }
  }
  parsePoseNodes() {
    const bindMatrices = {};
    if ("Pose" in fbxTree.Objects) {
      const BindPoseNode = fbxTree.Objects.Pose;
      for (const nodeID in BindPoseNode) {
        if (BindPoseNode[nodeID].attrType === "BindPose" && BindPoseNode[nodeID].NbPoseNodes > 0) {
          const poseNodes = BindPoseNode[nodeID].PoseNode;
          if (Array.isArray(poseNodes)) {
            poseNodes.forEach(function(poseNode) {
              bindMatrices[poseNode.Node] = new Matrix4().fromArray(poseNode.Matrix.a);
            });
          } else {
            bindMatrices[poseNodes.Node] = new Matrix4().fromArray(poseNodes.Matrix.a);
          }
        }
      }
    }
    return bindMatrices;
  }
  addGlobalSceneSettings() {
    if ("GlobalSettings" in fbxTree) {
      if ("AmbientColor" in fbxTree.GlobalSettings) {
        const ambientColor = fbxTree.GlobalSettings.AmbientColor.value;
        const r = ambientColor[0];
        const g3 = ambientColor[1];
        const b = ambientColor[2];
        if (r !== 0 || g3 !== 0 || b !== 0) {
          const color2 = new Color().setRGB(r, g3, b, SRGBColorSpace);
          sceneGraph.add(new AmbientLight(color2, 1));
        }
      }
      if ("UnitScaleFactor" in fbxTree.GlobalSettings) {
        sceneGraph.userData.unitScaleFactor = fbxTree.GlobalSettings.UnitScaleFactor.value;
      }
    }
  }
};
var GeometryParser = class {
  constructor() {
    this.negativeMaterialIndices = false;
  }
  // Parse nodes in FBXTree.Objects.Geometry
  parse(deformers) {
    const geometryMap = /* @__PURE__ */ new Map();
    if ("Geometry" in fbxTree.Objects) {
      const geoNodes = fbxTree.Objects.Geometry;
      for (const nodeID in geoNodes) {
        const relationships = connections.get(parseInt(nodeID));
        const geo = this.parseGeometry(relationships, geoNodes[nodeID], deformers);
        geometryMap.set(parseInt(nodeID), geo);
      }
    }
    if (this.negativeMaterialIndices === true) {
      console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected.");
    }
    return geometryMap;
  }
  // Parse single node in FBXTree.Objects.Geometry
  parseGeometry(relationships, geoNode, deformers) {
    switch (geoNode.attrType) {
      case "Mesh":
        return this.parseMeshGeometry(relationships, geoNode, deformers);
        break;
      case "NurbsCurve":
        return this.parseNurbsGeometry(geoNode);
        break;
    }
  }
  // Parse single node mesh geometry in FBXTree.Objects.Geometry
  parseMeshGeometry(relationships, geoNode, deformers) {
    const skeletons = deformers.skeletons;
    const morphTargets = [];
    const modelNodes = relationships.parents.map(function(parent) {
      return fbxTree.Objects.Model[parent.ID];
    });
    if (modelNodes.length === 0)
      return;
    const skeleton = relationships.children.reduce(function(skeleton2, child) {
      if (skeletons[child.ID] !== void 0)
        skeleton2 = skeletons[child.ID];
      return skeleton2;
    }, null);
    relationships.children.forEach(function(child) {
      if (deformers.morphTargets[child.ID] !== void 0) {
        morphTargets.push(deformers.morphTargets[child.ID]);
      }
    });
    const modelNode = modelNodes[0];
    const transformData = {};
    if ("RotationOrder" in modelNode)
      transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);
    if ("InheritType" in modelNode)
      transformData.inheritType = parseInt(modelNode.InheritType.value);
    if ("GeometricTranslation" in modelNode)
      transformData.translation = modelNode.GeometricTranslation.value;
    if ("GeometricRotation" in modelNode)
      transformData.rotation = modelNode.GeometricRotation.value;
    if ("GeometricScaling" in modelNode)
      transformData.scale = modelNode.GeometricScaling.value;
    const transform = generateTransform(transformData);
    return this.genGeometry(geoNode, skeleton, morphTargets, transform);
  }
  // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
  genGeometry(geoNode, skeleton, morphTargets, preTransform) {
    const geo = new BufferGeometry();
    if (geoNode.attrName)
      geo.name = geoNode.attrName;
    const geoInfo = this.parseGeoNode(geoNode, skeleton);
    const buffers = this.genBuffers(geoInfo);
    const positionAttribute = new Float32BufferAttribute2(buffers.vertex, 3);
    positionAttribute.applyMatrix4(preTransform);
    geo.setAttribute("position", positionAttribute);
    if (buffers.colors.length > 0) {
      geo.setAttribute("color", new Float32BufferAttribute2(buffers.colors, 3));
    }
    if (skeleton) {
      geo.setAttribute("skinIndex", new Uint16BufferAttribute(buffers.weightsIndices, 4));
      geo.setAttribute("skinWeight", new Float32BufferAttribute2(buffers.vertexWeights, 4));
      geo.FBX_Deformer = skeleton;
    }
    if (buffers.normal.length > 0) {
      const normalMatrix = new Matrix3().getNormalMatrix(preTransform);
      const normalAttribute = new Float32BufferAttribute2(buffers.normal, 3);
      normalAttribute.applyNormalMatrix(normalMatrix);
      geo.setAttribute("normal", normalAttribute);
    }
    buffers.uvs.forEach(function(uvBuffer, i) {
      const name = i === 0 ? "uv" : `uv${i}`;
      geo.setAttribute(name, new Float32BufferAttribute2(buffers.uvs[i], 2));
    });
    if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
      let prevMaterialIndex = buffers.materialIndex[0];
      let startIndex = 0;
      buffers.materialIndex.forEach(function(currentIndex, i) {
        if (currentIndex !== prevMaterialIndex) {
          geo.addGroup(startIndex, i - startIndex, prevMaterialIndex);
          prevMaterialIndex = currentIndex;
          startIndex = i;
        }
      });
      if (geo.groups.length > 0) {
        const lastGroup = geo.groups[geo.groups.length - 1];
        const lastIndex = lastGroup.start + lastGroup.count;
        if (lastIndex !== buffers.materialIndex.length) {
          geo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex);
        }
      }
      if (geo.groups.length === 0) {
        geo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0]);
      }
    }
    this.addMorphTargets(geo, geoNode, morphTargets, preTransform);
    return geo;
  }
  parseGeoNode(geoNode, skeleton) {
    const geoInfo = {};
    geoInfo.vertexPositions = geoNode.Vertices !== void 0 ? geoNode.Vertices.a : [];
    geoInfo.vertexIndices = geoNode.PolygonVertexIndex !== void 0 ? geoNode.PolygonVertexIndex.a : [];
    if (geoNode.LayerElementColor) {
      geoInfo.color = this.parseVertexColors(geoNode.LayerElementColor[0]);
    }
    if (geoNode.LayerElementMaterial) {
      geoInfo.material = this.parseMaterialIndices(geoNode.LayerElementMaterial[0]);
    }
    if (geoNode.LayerElementNormal) {
      geoInfo.normal = this.parseNormals(geoNode.LayerElementNormal[0]);
    }
    if (geoNode.LayerElementUV) {
      geoInfo.uv = [];
      let i = 0;
      while (geoNode.LayerElementUV[i]) {
        if (geoNode.LayerElementUV[i].UV) {
          geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i]));
        }
        i++;
      }
    }
    geoInfo.weightTable = {};
    if (skeleton !== null) {
      geoInfo.skeleton = skeleton;
      skeleton.rawBones.forEach(function(rawBone, i) {
        rawBone.indices.forEach(function(index, j) {
          if (geoInfo.weightTable[index] === void 0)
            geoInfo.weightTable[index] = [];
          geoInfo.weightTable[index].push({
            id: i,
            weight: rawBone.weights[j]
          });
        });
      });
    }
    return geoInfo;
  }
  genBuffers(geoInfo) {
    const buffers = {
      vertex: [],
      normal: [],
      colors: [],
      uvs: [],
      materialIndex: [],
      vertexWeights: [],
      weightsIndices: []
    };
    let polygonIndex = 0;
    let faceLength = 0;
    let displayedWeightsWarning = false;
    let facePositionIndexes = [];
    let faceNormals = [];
    let faceColors = [];
    let faceUVs = [];
    let faceWeights = [];
    let faceWeightIndices = [];
    const scope = this;
    geoInfo.vertexIndices.forEach(function(vertexIndex, polygonVertexIndex) {
      let materialIndex;
      let endOfFace = false;
      if (vertexIndex < 0) {
        vertexIndex = vertexIndex ^ -1;
        endOfFace = true;
      }
      let weightIndices = [];
      let weights = [];
      facePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2);
      if (geoInfo.color) {
        const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color);
        faceColors.push(data[0], data[1], data[2]);
      }
      if (geoInfo.skeleton) {
        if (geoInfo.weightTable[vertexIndex] !== void 0) {
          geoInfo.weightTable[vertexIndex].forEach(function(wt2) {
            weights.push(wt2.weight);
            weightIndices.push(wt2.id);
          });
        }
        if (weights.length > 4) {
          if (!displayedWeightsWarning) {
            console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.");
            displayedWeightsWarning = true;
          }
          const wIndex = [0, 0, 0, 0];
          const Weight = [0, 0, 0, 0];
          weights.forEach(function(weight, weightIndex) {
            let currentWeight = weight;
            let currentIndex = weightIndices[weightIndex];
            Weight.forEach(function(comparedWeight, comparedWeightIndex, comparedWeightArray) {
              if (currentWeight > comparedWeight) {
                comparedWeightArray[comparedWeightIndex] = currentWeight;
                currentWeight = comparedWeight;
                const tmp = wIndex[comparedWeightIndex];
                wIndex[comparedWeightIndex] = currentIndex;
                currentIndex = tmp;
              }
            });
          });
          weightIndices = wIndex;
          weights = Weight;
        }
        while (weights.length < 4) {
          weights.push(0);
          weightIndices.push(0);
        }
        for (let i = 0; i < 4; ++i) {
          faceWeights.push(weights[i]);
          faceWeightIndices.push(weightIndices[i]);
        }
      }
      if (geoInfo.normal) {
        const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal);
        faceNormals.push(data[0], data[1], data[2]);
      }
      if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
        materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0];
        if (materialIndex < 0) {
          scope.negativeMaterialIndices = true;
          materialIndex = 0;
        }
      }
      if (geoInfo.uv) {
        geoInfo.uv.forEach(function(uv, i) {
          const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, uv);
          if (faceUVs[i] === void 0) {
            faceUVs[i] = [];
          }
          faceUVs[i].push(data[0]);
          faceUVs[i].push(data[1]);
        });
      }
      faceLength++;
      if (endOfFace) {
        scope.genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength);
        polygonIndex++;
        faceLength = 0;
        facePositionIndexes = [];
        faceNormals = [];
        faceColors = [];
        faceUVs = [];
        faceWeights = [];
        faceWeightIndices = [];
      }
    });
    return buffers;
  }
  // See https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal
  getNormalNewell(vertices) {
    const normal = new Vector32(0, 0, 0);
    for (let i = 0; i < vertices.length; i++) {
      const current = vertices[i];
      const next = vertices[(i + 1) % vertices.length];
      normal.x += (current.y - next.y) * (current.z + next.z);
      normal.y += (current.z - next.z) * (current.x + next.x);
      normal.z += (current.x - next.x) * (current.y + next.y);
    }
    normal.normalize();
    return normal;
  }
  getNormalTangentAndBitangent(vertices) {
    const normalVector = this.getNormalNewell(vertices);
    const up2 = Math.abs(normalVector.z) > 0.5 ? new Vector32(0, 1, 0) : new Vector32(0, 0, 1);
    const tangent = up2.cross(normalVector).normalize();
    const bitangent = normalVector.clone().cross(tangent).normalize();
    return {
      normal: normalVector,
      tangent,
      bitangent
    };
  }
  flattenVertex(vertex, normalTangent, normalBitangent) {
    return new Vector2(
      vertex.dot(normalTangent),
      vertex.dot(normalBitangent)
    );
  }
  // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
  genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength) {
    let triangles;
    if (faceLength > 3) {
      const vertices = [];
      const positions = geoInfo.baseVertexPositions || geoInfo.vertexPositions;
      for (let i = 0; i < facePositionIndexes.length; i += 3) {
        vertices.push(
          new Vector32(
            positions[facePositionIndexes[i]],
            positions[facePositionIndexes[i + 1]],
            positions[facePositionIndexes[i + 2]]
          )
        );
      }
      const { tangent, bitangent } = this.getNormalTangentAndBitangent(vertices);
      const triangulationInput = [];
      for (const vertex of vertices) {
        triangulationInput.push(this.flattenVertex(vertex, tangent, bitangent));
      }
      triangles = ShapeUtils.triangulateShape(triangulationInput, []);
    } else {
      triangles = [[0, 1, 2]];
    }
    for (const [i0, i1, i2] of triangles) {
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i0 * 3]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i0 * 3 + 1]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i0 * 3 + 2]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i1 * 3]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i1 * 3 + 1]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i1 * 3 + 2]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i2 * 3]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i2 * 3 + 1]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i2 * 3 + 2]]);
      if (geoInfo.skeleton) {
        buffers.vertexWeights.push(faceWeights[i0 * 4]);
        buffers.vertexWeights.push(faceWeights[i0 * 4 + 1]);
        buffers.vertexWeights.push(faceWeights[i0 * 4 + 2]);
        buffers.vertexWeights.push(faceWeights[i0 * 4 + 3]);
        buffers.vertexWeights.push(faceWeights[i1 * 4]);
        buffers.vertexWeights.push(faceWeights[i1 * 4 + 1]);
        buffers.vertexWeights.push(faceWeights[i1 * 4 + 2]);
        buffers.vertexWeights.push(faceWeights[i1 * 4 + 3]);
        buffers.vertexWeights.push(faceWeights[i2 * 4]);
        buffers.vertexWeights.push(faceWeights[i2 * 4 + 1]);
        buffers.vertexWeights.push(faceWeights[i2 * 4 + 2]);
        buffers.vertexWeights.push(faceWeights[i2 * 4 + 3]);
        buffers.weightsIndices.push(faceWeightIndices[i0 * 4]);
        buffers.weightsIndices.push(faceWeightIndices[i0 * 4 + 1]);
        buffers.weightsIndices.push(faceWeightIndices[i0 * 4 + 2]);
        buffers.weightsIndices.push(faceWeightIndices[i0 * 4 + 3]);
        buffers.weightsIndices.push(faceWeightIndices[i1 * 4]);
        buffers.weightsIndices.push(faceWeightIndices[i1 * 4 + 1]);
        buffers.weightsIndices.push(faceWeightIndices[i1 * 4 + 2]);
        buffers.weightsIndices.push(faceWeightIndices[i1 * 4 + 3]);
        buffers.weightsIndices.push(faceWeightIndices[i2 * 4]);
        buffers.weightsIndices.push(faceWeightIndices[i2 * 4 + 1]);
        buffers.weightsIndices.push(faceWeightIndices[i2 * 4 + 2]);
        buffers.weightsIndices.push(faceWeightIndices[i2 * 4 + 3]);
      }
      if (geoInfo.color) {
        buffers.colors.push(faceColors[i0 * 3]);
        buffers.colors.push(faceColors[i0 * 3 + 1]);
        buffers.colors.push(faceColors[i0 * 3 + 2]);
        buffers.colors.push(faceColors[i1 * 3]);
        buffers.colors.push(faceColors[i1 * 3 + 1]);
        buffers.colors.push(faceColors[i1 * 3 + 2]);
        buffers.colors.push(faceColors[i2 * 3]);
        buffers.colors.push(faceColors[i2 * 3 + 1]);
        buffers.colors.push(faceColors[i2 * 3 + 2]);
      }
      if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
        buffers.materialIndex.push(materialIndex);
        buffers.materialIndex.push(materialIndex);
        buffers.materialIndex.push(materialIndex);
      }
      if (geoInfo.normal) {
        buffers.normal.push(faceNormals[i0 * 3]);
        buffers.normal.push(faceNormals[i0 * 3 + 1]);
        buffers.normal.push(faceNormals[i0 * 3 + 2]);
        buffers.normal.push(faceNormals[i1 * 3]);
        buffers.normal.push(faceNormals[i1 * 3 + 1]);
        buffers.normal.push(faceNormals[i1 * 3 + 2]);
        buffers.normal.push(faceNormals[i2 * 3]);
        buffers.normal.push(faceNormals[i2 * 3 + 1]);
        buffers.normal.push(faceNormals[i2 * 3 + 2]);
      }
      if (geoInfo.uv) {
        geoInfo.uv.forEach(function(uv, j) {
          if (buffers.uvs[j] === void 0)
            buffers.uvs[j] = [];
          buffers.uvs[j].push(faceUVs[j][i0 * 2]);
          buffers.uvs[j].push(faceUVs[j][i0 * 2 + 1]);
          buffers.uvs[j].push(faceUVs[j][i1 * 2]);
          buffers.uvs[j].push(faceUVs[j][i1 * 2 + 1]);
          buffers.uvs[j].push(faceUVs[j][i2 * 2]);
          buffers.uvs[j].push(faceUVs[j][i2 * 2 + 1]);
        });
      }
    }
  }
  addMorphTargets(parentGeo, parentGeoNode, morphTargets, preTransform) {
    if (morphTargets.length === 0)
      return;
    parentGeo.morphTargetsRelative = true;
    parentGeo.morphAttributes.position = [];
    const scope = this;
    morphTargets.forEach(function(morphTarget) {
      morphTarget.rawTargets.forEach(function(rawTarget) {
        const morphGeoNode = fbxTree.Objects.Geometry[rawTarget.geoID];
        if (morphGeoNode !== void 0) {
          scope.genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name);
        }
      });
    });
  }
  // a morph geometry node is similar to a standard  node, and the node is also contained
  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
  // and a special attribute Index defining which vertices of the original geometry are affected
  // Normal and position attributes only have data for the vertices that are affected by the morph
  genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, name) {
    const basePositions = parentGeoNode.Vertices !== void 0 ? parentGeoNode.Vertices.a : [];
    const baseIndices = parentGeoNode.PolygonVertexIndex !== void 0 ? parentGeoNode.PolygonVertexIndex.a : [];
    const morphPositionsSparse = morphGeoNode.Vertices !== void 0 ? morphGeoNode.Vertices.a : [];
    const morphIndices = morphGeoNode.Indexes !== void 0 ? morphGeoNode.Indexes.a : [];
    const length = parentGeo.attributes.position.count * 3;
    const morphPositions = new Float32Array(length);
    for (let i = 0; i < morphIndices.length; i++) {
      const morphIndex = morphIndices[i] * 3;
      morphPositions[morphIndex] = morphPositionsSparse[i * 3];
      morphPositions[morphIndex + 1] = morphPositionsSparse[i * 3 + 1];
      morphPositions[morphIndex + 2] = morphPositionsSparse[i * 3 + 2];
    }
    const morphGeoInfo = {
      vertexIndices: baseIndices,
      vertexPositions: morphPositions,
      baseVertexPositions: basePositions
    };
    const morphBuffers = this.genBuffers(morphGeoInfo);
    const positionAttribute = new Float32BufferAttribute2(morphBuffers.vertex, 3);
    positionAttribute.name = name || morphGeoNode.attrName;
    positionAttribute.applyMatrix4(preTransform);
    parentGeo.morphAttributes.position.push(positionAttribute);
  }
  // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
  parseNormals(NormalNode) {
    const mappingType = NormalNode.MappingInformationType;
    const referenceType = NormalNode.ReferenceInformationType;
    const buffer2 = NormalNode.Normals.a;
    let indexBuffer = [];
    if (referenceType === "IndexToDirect") {
      if ("NormalIndex" in NormalNode) {
        indexBuffer = NormalNode.NormalIndex.a;
      } else if ("NormalsIndex" in NormalNode) {
        indexBuffer = NormalNode.NormalsIndex.a;
      }
    }
    return {
      dataSize: 3,
      buffer: buffer2,
      indices: indexBuffer,
      mappingType,
      referenceType
    };
  }
  // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
  parseUVs(UVNode) {
    const mappingType = UVNode.MappingInformationType;
    const referenceType = UVNode.ReferenceInformationType;
    const buffer2 = UVNode.UV.a;
    let indexBuffer = [];
    if (referenceType === "IndexToDirect") {
      indexBuffer = UVNode.UVIndex.a;
    }
    return {
      dataSize: 2,
      buffer: buffer2,
      indices: indexBuffer,
      mappingType,
      referenceType
    };
  }
  // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
  parseVertexColors(ColorNode) {
    if (!ColorNode.Colors)
      return void 0;
    const mappingType = ColorNode.MappingInformationType;
    const referenceType = ColorNode.ReferenceInformationType;
    const buffer2 = ColorNode.Colors.a;
    let indexBuffer = [];
    if (referenceType === "IndexToDirect") {
      indexBuffer = ColorNode.ColorIndex.a;
    }
    for (let i = 0, c2 = new Color(); i < buffer2.length; i += 4) {
      c2.fromArray(buffer2, i);
      ColorManagement.toWorkingColorSpace(c2, SRGBColorSpace);
      c2.toArray(buffer2, i);
    }
    return {
      dataSize: 4,
      buffer: buffer2,
      indices: indexBuffer,
      mappingType,
      referenceType
    };
  }
  // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
  parseMaterialIndices(MaterialNode) {
    const mappingType = MaterialNode.MappingInformationType;
    const referenceType = MaterialNode.ReferenceInformationType;
    if (mappingType === "NoMappingInformation") {
      return {
        dataSize: 1,
        buffer: [0],
        indices: [0],
        mappingType: "AllSame",
        referenceType
      };
    }
    const materialIndexBuffer = MaterialNode.Materials.a;
    const materialIndices = [];
    for (let i = 0; i < materialIndexBuffer.length; ++i) {
      materialIndices.push(i);
    }
    return {
      dataSize: 1,
      buffer: materialIndexBuffer,
      indices: materialIndices,
      mappingType,
      referenceType
    };
  }
  // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
  parseNurbsGeometry(geoNode) {
    const order = parseInt(geoNode.Order);
    if (isNaN(order)) {
      console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", geoNode.Order, geoNode.id);
      return new BufferGeometry();
    }
    const degree = order - 1;
    const knots = geoNode.KnotVector.a;
    const controlPoints = [];
    const pointsValues = geoNode.Points.a;
    for (let i = 0, l = pointsValues.length; i < l; i += 4) {
      controlPoints.push(new Vector4().fromArray(pointsValues, i));
    }
    let startKnot, endKnot;
    if (geoNode.Form === "Closed") {
      controlPoints.push(controlPoints[0]);
    } else if (geoNode.Form === "Periodic") {
      startKnot = degree;
      endKnot = knots.length - 1 - startKnot;
      for (let i = 0; i < degree; ++i) {
        controlPoints.push(controlPoints[i]);
      }
    }
    const curve = new NURBSCurve(degree, knots, controlPoints, startKnot, endKnot);
    const points = curve.getPoints(controlPoints.length * 12);
    return new BufferGeometry().setFromPoints(points);
  }
};
var AnimationParser = class {
  // take raw animation clips and turn them into three.js animation clips
  parse() {
    const animationClips = [];
    const rawClips = this.parseClips();
    if (rawClips !== void 0) {
      for (const key in rawClips) {
        const rawClip = rawClips[key];
        const clip = this.addClip(rawClip);
        animationClips.push(clip);
      }
    }
    return animationClips;
  }
  parseClips() {
    if (fbxTree.Objects.AnimationCurve === void 0)
      return void 0;
    const curveNodesMap = this.parseAnimationCurveNodes();
    this.parseAnimationCurves(curveNodesMap);
    const layersMap = this.parseAnimationLayers(curveNodesMap);
    const rawClips = this.parseAnimStacks(layersMap);
    return rawClips;
  }
  // parse nodes in FBXTree.Objects.AnimationCurveNode
  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
  // and is referenced by an AnimationLayer
  parseAnimationCurveNodes() {
    const rawCurveNodes = fbxTree.Objects.AnimationCurveNode;
    const curveNodesMap = /* @__PURE__ */ new Map();
    for (const nodeID in rawCurveNodes) {
      const rawCurveNode = rawCurveNodes[nodeID];
      if (rawCurveNode.attrName.match(/S|R|T|DeformPercent/) !== null) {
        const curveNode = {
          id: rawCurveNode.id,
          attr: rawCurveNode.attrName,
          curves: {}
        };
        curveNodesMap.set(curveNode.id, curveNode);
      }
    }
    return curveNodesMap;
  }
  // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
  // axis ( e.g. times and values of x rotation)
  parseAnimationCurves(curveNodesMap) {
    const rawCurves = fbxTree.Objects.AnimationCurve;
    for (const nodeID in rawCurves) {
      const animationCurve = {
        id: rawCurves[nodeID].id,
        times: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),
        values: rawCurves[nodeID].KeyValueFloat.a
      };
      const relationships = connections.get(animationCurve.id);
      if (relationships !== void 0) {
        const animationCurveID = relationships.parents[0].ID;
        const animationCurveRelationship = relationships.parents[0].relationship;
        if (animationCurveRelationship.match(/X/)) {
          curveNodesMap.get(animationCurveID).curves["x"] = animationCurve;
        } else if (animationCurveRelationship.match(/Y/)) {
          curveNodesMap.get(animationCurveID).curves["y"] = animationCurve;
        } else if (animationCurveRelationship.match(/Z/)) {
          curveNodesMap.get(animationCurveID).curves["z"] = animationCurve;
        } else if (animationCurveRelationship.match(/DeformPercent/) && curveNodesMap.has(animationCurveID)) {
          curveNodesMap.get(animationCurveID).curves["morph"] = animationCurve;
        }
      }
    }
  }
  // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
  // to various AnimationCurveNodes and is referenced by an AnimationStack node
  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
  parseAnimationLayers(curveNodesMap) {
    const rawLayers = fbxTree.Objects.AnimationLayer;
    const layersMap = /* @__PURE__ */ new Map();
    for (const nodeID in rawLayers) {
      const layerCurveNodes = [];
      const connection = connections.get(parseInt(nodeID));
      if (connection !== void 0) {
        const children = connection.children;
        children.forEach(function(child, i) {
          if (curveNodesMap.has(child.ID)) {
            const curveNode = curveNodesMap.get(child.ID);
            if (curveNode.curves.x !== void 0 || curveNode.curves.y !== void 0 || curveNode.curves.z !== void 0) {
              if (layerCurveNodes[i] === void 0) {
                const modelID = connections.get(child.ID).parents.filter(function(parent) {
                  return parent.relationship !== void 0;
                })[0].ID;
                if (modelID !== void 0) {
                  const rawModel = fbxTree.Objects.Model[modelID.toString()];
                  if (rawModel === void 0) {
                    console.warn("THREE.FBXLoader: Encountered a unused curve.", child);
                    return;
                  }
                  const node = {
                    modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : "",
                    ID: rawModel.id,
                    initialPosition: [0, 0, 0],
                    initialRotation: [0, 0, 0],
                    initialScale: [1, 1, 1]
                  };
                  sceneGraph.traverse(function(child2) {
                    if (child2.ID === rawModel.id) {
                      node.transform = child2.matrix;
                      if (child2.userData.transformData)
                        node.eulerOrder = child2.userData.transformData.eulerOrder;
                    }
                  });
                  if (!node.transform)
                    node.transform = new Matrix4();
                  if ("PreRotation" in rawModel)
                    node.preRotation = rawModel.PreRotation.value;
                  if ("PostRotation" in rawModel)
                    node.postRotation = rawModel.PostRotation.value;
                  layerCurveNodes[i] = node;
                }
              }
              if (layerCurveNodes[i])
                layerCurveNodes[i][curveNode.attr] = curveNode;
            } else if (curveNode.curves.morph !== void 0) {
              if (layerCurveNodes[i] === void 0) {
                const deformerID = connections.get(child.ID).parents.filter(function(parent) {
                  return parent.relationship !== void 0;
                })[0].ID;
                const morpherID = connections.get(deformerID).parents[0].ID;
                const geoID = connections.get(morpherID).parents[0].ID;
                const modelID = connections.get(geoID).parents[0].ID;
                const rawModel = fbxTree.Objects.Model[modelID];
                const node = {
                  modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : "",
                  morphName: fbxTree.Objects.Deformer[deformerID].attrName
                };
                layerCurveNodes[i] = node;
              }
              layerCurveNodes[i][curveNode.attr] = curveNode;
            }
          }
        });
        layersMap.set(parseInt(nodeID), layerCurveNodes);
      }
    }
    return layersMap;
  }
  // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
  // hierarchy. Each Stack node will be used to create a AnimationClip
  parseAnimStacks(layersMap) {
    const rawStacks = fbxTree.Objects.AnimationStack;
    const rawClips = {};
    for (const nodeID in rawStacks) {
      const children = connections.get(parseInt(nodeID)).children;
      if (children.length > 1) {
        console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
      }
      const layer = layersMap.get(children[0].ID);
      rawClips[nodeID] = {
        name: rawStacks[nodeID].attrName,
        layer
      };
    }
    return rawClips;
  }
  addClip(rawClip) {
    let tracks = [];
    const scope = this;
    rawClip.layer.forEach(function(rawTracks) {
      tracks = tracks.concat(scope.generateTracks(rawTracks));
    });
    return new AnimationClip(rawClip.name, -1, tracks);
  }
  generateTracks(rawTracks) {
    const tracks = [];
    let initialPosition = new Vector32();
    let initialScale = new Vector32();
    if (rawTracks.transform)
      rawTracks.transform.decompose(initialPosition, new Quaternion(), initialScale);
    initialPosition = initialPosition.toArray();
    initialScale = initialScale.toArray();
    if (rawTracks.T !== void 0 && Object.keys(rawTracks.T.curves).length > 0) {
      const positionTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.T.curves, initialPosition, "position");
      if (positionTrack !== void 0)
        tracks.push(positionTrack);
    }
    if (rawTracks.R !== void 0 && Object.keys(rawTracks.R.curves).length > 0) {
      const rotationTrack = this.generateRotationTrack(rawTracks.modelName, rawTracks.R.curves, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder);
      if (rotationTrack !== void 0)
        tracks.push(rotationTrack);
    }
    if (rawTracks.S !== void 0 && Object.keys(rawTracks.S.curves).length > 0) {
      const scaleTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, initialScale, "scale");
      if (scaleTrack !== void 0)
        tracks.push(scaleTrack);
    }
    if (rawTracks.DeformPercent !== void 0) {
      const morphTrack = this.generateMorphTrack(rawTracks);
      if (morphTrack !== void 0)
        tracks.push(morphTrack);
    }
    return tracks;
  }
  generateVectorTrack(modelName, curves, initialValue, type) {
    const times = this.getTimesForAllAxes(curves);
    const values = this.getKeyframeTrackValues(times, curves, initialValue);
    return new VectorKeyframeTrack(modelName + "." + type, times, values);
  }
  generateRotationTrack(modelName, curves, preRotation, postRotation, eulerOrder) {
    let times;
    let values;
    if (curves.x === void 0 || curves.y === void 0 || curves.z === void 0) {
      console.warn("THREE.FBXLoader: Missing rotation curves " + (curves.x === void 0 ? "x " : "") + (curves.y === void 0 ? "y " : "") + (curves.z === void 0 ? "z " : "") + " for animation of " + modelName + ". This is currently not supported.");
      return void 0;
    }
    if (curves.x !== void 0 && curves.y !== void 0 && curves.z !== void 0) {
      const result = this.interpolateRotations(curves.x, curves.y, curves.z, eulerOrder);
      times = result[0];
      values = result[1];
    }
    const defaultEulerOrder = getEulerOrder(0);
    if (preRotation !== void 0) {
      preRotation = preRotation.map(MathUtils.degToRad);
      preRotation.push(defaultEulerOrder);
      preRotation = new Euler().fromArray(preRotation);
      preRotation = new Quaternion().setFromEuler(preRotation);
    }
    if (postRotation !== void 0) {
      postRotation = postRotation.map(MathUtils.degToRad);
      postRotation.push(defaultEulerOrder);
      postRotation = new Euler().fromArray(postRotation);
      postRotation = new Quaternion().setFromEuler(postRotation).invert();
    }
    const quaternion = new Quaternion();
    const euler2 = new Euler();
    const quaternionValues = [];
    if (!values || !times)
      return void 0;
    for (let i = 0; i < values.length; i += 3) {
      euler2.set(values[i], values[i + 1], values[i + 2], eulerOrder);
      quaternion.setFromEuler(euler2);
      if (preRotation !== void 0)
        quaternion.premultiply(preRotation);
      if (postRotation !== void 0)
        quaternion.multiply(postRotation);
      if (i > 2) {
        const prevQuat = new Quaternion().fromArray(
          quaternionValues,
          (i - 3) / 3 * 4
        );
        if (prevQuat.dot(quaternion) < 0) {
          quaternion.set(-quaternion.x, -quaternion.y, -quaternion.z, -quaternion.w);
        }
      }
      quaternion.toArray(quaternionValues, i / 3 * 4);
    }
    return new QuaternionKeyframeTrack(modelName + ".quaternion", times, quaternionValues);
  }
  generateMorphTrack(rawTracks) {
    const curves = rawTracks.DeformPercent.curves.morph;
    const values = curves.values.map(function(val) {
      return val / 100;
    });
    const morphNum = sceneGraph.getObjectByName(rawTracks.modelName).morphTargetDictionary[rawTracks.morphName];
    return new NumberKeyframeTrack(rawTracks.modelName + ".morphTargetInfluences[" + morphNum + "]", curves.times, values);
  }
  // For all animated objects, times are defined separately for each axis
  // Here we'll combine the times into one sorted array without duplicates
  getTimesForAllAxes(curves) {
    let times = [];
    if (curves.x !== void 0)
      times = times.concat(curves.x.times);
    if (curves.y !== void 0)
      times = times.concat(curves.y.times);
    if (curves.z !== void 0)
      times = times.concat(curves.z.times);
    times = times.sort(function(a, b) {
      return a - b;
    });
    if (times.length > 1) {
      let targetIndex = 1;
      let lastValue = times[0];
      for (let i = 1; i < times.length; i++) {
        const currentValue = times[i];
        if (currentValue !== lastValue) {
          times[targetIndex] = currentValue;
          lastValue = currentValue;
          targetIndex++;
        }
      }
      times = times.slice(0, targetIndex);
    }
    return times;
  }
  getKeyframeTrackValues(times, curves, initialValue) {
    const prevValue = initialValue;
    const values = [];
    let xIndex = -1;
    let yIndex = -1;
    let zIndex = -1;
    times.forEach(function(time) {
      if (curves.x)
        xIndex = curves.x.times.indexOf(time);
      if (curves.y)
        yIndex = curves.y.times.indexOf(time);
      if (curves.z)
        zIndex = curves.z.times.indexOf(time);
      if (xIndex !== -1) {
        const xValue = curves.x.values[xIndex];
        values.push(xValue);
        prevValue[0] = xValue;
      } else {
        values.push(prevValue[0]);
      }
      if (yIndex !== -1) {
        const yValue = curves.y.values[yIndex];
        values.push(yValue);
        prevValue[1] = yValue;
      } else {
        values.push(prevValue[1]);
      }
      if (zIndex !== -1) {
        const zValue = curves.z.values[zIndex];
        values.push(zValue);
        prevValue[2] = zValue;
      } else {
        values.push(prevValue[2]);
      }
    });
    return values;
  }
  // Rotations are defined as Euler angles which can have values  of any size
  // These will be converted to quaternions which don't support values greater than
  // PI, so we'll interpolate large rotations
  interpolateRotations(curvex, curvey, curvez, eulerOrder) {
    const times = [];
    const values = [];
    times.push(curvex.times[0]);
    values.push(MathUtils.degToRad(curvex.values[0]));
    values.push(MathUtils.degToRad(curvey.values[0]));
    values.push(MathUtils.degToRad(curvez.values[0]));
    for (let i = 1; i < curvex.values.length; i++) {
      const initialValue = [
        curvex.values[i - 1],
        curvey.values[i - 1],
        curvez.values[i - 1]
      ];
      if (isNaN(initialValue[0]) || isNaN(initialValue[1]) || isNaN(initialValue[2])) {
        continue;
      }
      const initialValueRad = initialValue.map(MathUtils.degToRad);
      const currentValue = [
        curvex.values[i],
        curvey.values[i],
        curvez.values[i]
      ];
      if (isNaN(currentValue[0]) || isNaN(currentValue[1]) || isNaN(currentValue[2])) {
        continue;
      }
      const currentValueRad = currentValue.map(MathUtils.degToRad);
      const valuesSpan = [
        currentValue[0] - initialValue[0],
        currentValue[1] - initialValue[1],
        currentValue[2] - initialValue[2]
      ];
      const absoluteSpan = [
        Math.abs(valuesSpan[0]),
        Math.abs(valuesSpan[1]),
        Math.abs(valuesSpan[2])
      ];
      if (absoluteSpan[0] >= 180 || absoluteSpan[1] >= 180 || absoluteSpan[2] >= 180) {
        const maxAbsSpan = Math.max(...absoluteSpan);
        const numSubIntervals = maxAbsSpan / 180;
        const E1 = new Euler(...initialValueRad, eulerOrder);
        const E2 = new Euler(...currentValueRad, eulerOrder);
        const Q1 = new Quaternion().setFromEuler(E1);
        const Q2 = new Quaternion().setFromEuler(E2);
        if (Q1.dot(Q2)) {
          Q2.set(-Q2.x, -Q2.y, -Q2.z, -Q2.w);
        }
        const initialTime = curvex.times[i - 1];
        const timeSpan = curvex.times[i] - initialTime;
        const Q3 = new Quaternion();
        const E = new Euler();
        for (let t2 = 0; t2 < 1; t2 += 1 / numSubIntervals) {
          Q3.copy(Q1.clone().slerp(Q2.clone(), t2));
          times.push(initialTime + t2 * timeSpan);
          E.setFromQuaternion(Q3, eulerOrder);
          values.push(E.x);
          values.push(E.y);
          values.push(E.z);
        }
      } else {
        times.push(curvex.times[i]);
        values.push(MathUtils.degToRad(curvex.values[i]));
        values.push(MathUtils.degToRad(curvey.values[i]));
        values.push(MathUtils.degToRad(curvez.values[i]));
      }
    }
    return [times, values];
  }
};
var TextParser = class {
  getPrevNode() {
    return this.nodeStack[this.currentIndent - 2];
  }
  getCurrentNode() {
    return this.nodeStack[this.currentIndent - 1];
  }
  getCurrentProp() {
    return this.currentProp;
  }
  pushStack(node) {
    this.nodeStack.push(node);
    this.currentIndent += 1;
  }
  popStack() {
    this.nodeStack.pop();
    this.currentIndent -= 1;
  }
  setCurrentProp(val, name) {
    this.currentProp = val;
    this.currentPropName = name;
  }
  parse(text) {
    this.currentIndent = 0;
    this.allNodes = new FBXTree();
    this.nodeStack = [];
    this.currentProp = [];
    this.currentPropName = "";
    const scope = this;
    const split = text.split(/[\r\n]+/);
    split.forEach(function(line, i) {
      const matchComment = line.match(/^[\s\t]*;/);
      const matchEmpty = line.match(/^[\s\t]*$/);
      if (matchComment || matchEmpty)
        return;
      const matchBeginning = line.match("^\\t{" + scope.currentIndent + "}(\\w+):(.*){", "");
      const matchProperty = line.match("^\\t{" + scope.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)");
      const matchEnd = line.match("^\\t{" + (scope.currentIndent - 1) + "}}");
      if (matchBeginning) {
        scope.parseNodeBegin(line, matchBeginning);
      } else if (matchProperty) {
        scope.parseNodeProperty(line, matchProperty, split[++i]);
      } else if (matchEnd) {
        scope.popStack();
      } else if (line.match(/^[^\s\t}]/)) {
        scope.parseNodePropertyContinued(line);
      }
    });
    return this.allNodes;
  }
  parseNodeBegin(line, property) {
    const nodeName = property[1].trim().replace(/^"/, "").replace(/"$/, "");
    const nodeAttrs = property[2].split(",").map(function(attr) {
      return attr.trim().replace(/^"/, "").replace(/"$/, "");
    });
    const node = { name: nodeName };
    const attrs = this.parseNodeAttr(nodeAttrs);
    const currentNode = this.getCurrentNode();
    if (this.currentIndent === 0) {
      this.allNodes.add(nodeName, node);
    } else {
      if (nodeName in currentNode) {
        if (nodeName === "PoseNode") {
          currentNode.PoseNode.push(node);
        } else if (currentNode[nodeName].id !== void 0) {
          currentNode[nodeName] = {};
          currentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName];
        }
        if (attrs.id !== "")
          currentNode[nodeName][attrs.id] = node;
      } else if (typeof attrs.id === "number") {
        currentNode[nodeName] = {};
        currentNode[nodeName][attrs.id] = node;
      } else if (nodeName !== "Properties70") {
        if (nodeName === "PoseNode")
          currentNode[nodeName] = [node];
        else
          currentNode[nodeName] = node;
      }
    }
    if (typeof attrs.id === "number")
      node.id = attrs.id;
    if (attrs.name !== "")
      node.attrName = attrs.name;
    if (attrs.type !== "")
      node.attrType = attrs.type;
    this.pushStack(node);
  }
  parseNodeAttr(attrs) {
    let id = attrs[0];
    if (attrs[0] !== "") {
      id = parseInt(attrs[0]);
      if (isNaN(id)) {
        id = attrs[0];
      }
    }
    let name = "", type = "";
    if (attrs.length > 1) {
      name = attrs[1].replace(/^(\w+)::/, "");
      type = attrs[2];
    }
    return { id, name, type };
  }
  parseNodeProperty(line, property, contentLine) {
    let propName = property[1].replace(/^"/, "").replace(/"$/, "").trim();
    let propValue = property[2].replace(/^"/, "").replace(/"$/, "").trim();
    if (propName === "Content" && propValue === ",") {
      propValue = contentLine.replace(/"/g, "").replace(/,$/, "").trim();
    }
    const currentNode = this.getCurrentNode();
    const parentName = currentNode.name;
    if (parentName === "Properties70") {
      this.parseNodeSpecialProperty(line, propName, propValue);
      return;
    }
    if (propName === "C") {
      const connProps = propValue.split(",").slice(1);
      const from = parseInt(connProps[0]);
      const to = parseInt(connProps[1]);
      let rest = propValue.split(",").slice(3);
      rest = rest.map(function(elem) {
        return elem.trim().replace(/^"/, "");
      });
      propName = "connections";
      propValue = [from, to];
      append(propValue, rest);
      if (currentNode[propName] === void 0) {
        currentNode[propName] = [];
      }
    }
    if (propName === "Node")
      currentNode.id = propValue;
    if (propName in currentNode && Array.isArray(currentNode[propName])) {
      currentNode[propName].push(propValue);
    } else {
      if (propName !== "a")
        currentNode[propName] = propValue;
      else
        currentNode.a = propValue;
    }
    this.setCurrentProp(currentNode, propName);
    if (propName === "a" && propValue.slice(-1) !== ",") {
      currentNode.a = parseNumberArray(propValue);
    }
  }
  parseNodePropertyContinued(line) {
    const currentNode = this.getCurrentNode();
    currentNode.a += line;
    if (line.slice(-1) !== ",") {
      currentNode.a = parseNumberArray(currentNode.a);
    }
  }
  // parse "Property70"
  parseNodeSpecialProperty(line, propName, propValue) {
    const props = propValue.split('",').map(function(prop) {
      return prop.trim().replace(/^\"/, "").replace(/\s/, "_");
    });
    const innerPropName = props[0];
    const innerPropType1 = props[1];
    const innerPropType2 = props[2];
    const innerPropFlag = props[3];
    let innerPropValue = props[4];
    switch (innerPropType1) {
      case "int":
      case "enum":
      case "bool":
      case "ULongLong":
      case "double":
      case "Number":
      case "FieldOfView":
        innerPropValue = parseFloat(innerPropValue);
        break;
      case "Color":
      case "ColorRGB":
      case "Vector3D":
      case "Lcl_Translation":
      case "Lcl_Rotation":
      case "Lcl_Scaling":
        innerPropValue = parseNumberArray(innerPropValue);
        break;
    }
    this.getPrevNode()[innerPropName] = {
      "type": innerPropType1,
      "type2": innerPropType2,
      "flag": innerPropFlag,
      "value": innerPropValue
    };
    this.setCurrentProp(this.getPrevNode(), innerPropName);
  }
};
var BinaryParser = class {
  parse(buffer2) {
    const reader = new BinaryReader(buffer2);
    reader.skip(23);
    const version2 = reader.getUint32();
    if (version2 < 6400) {
      throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + version2);
    }
    const allNodes = new FBXTree();
    while (!this.endOfContent(reader)) {
      const node = this.parseNode(reader, version2);
      if (node !== null)
        allNodes.add(node.name, node);
    }
    return allNodes;
  }
  // Check if reader has reached the end of content.
  endOfContent(reader) {
    if (reader.size() % 16 === 0) {
      return (reader.getOffset() + 160 + 16 & ~15) >= reader.size();
    } else {
      return reader.getOffset() + 160 + 16 >= reader.size();
    }
  }
  // recursively parse nodes until the end of the file is reached
  parseNode(reader, version2) {
    const node = {};
    const endOffset = version2 >= 7500 ? reader.getUint64() : reader.getUint32();
    const numProperties = version2 >= 7500 ? reader.getUint64() : reader.getUint32();
    version2 >= 7500 ? reader.getUint64() : reader.getUint32();
    const nameLen = reader.getUint8();
    const name = reader.getString(nameLen);
    if (endOffset === 0)
      return null;
    const propertyList = [];
    for (let i = 0; i < numProperties; i++) {
      propertyList.push(this.parseProperty(reader));
    }
    const id = propertyList.length > 0 ? propertyList[0] : "";
    const attrName = propertyList.length > 1 ? propertyList[1] : "";
    const attrType = propertyList.length > 2 ? propertyList[2] : "";
    node.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false;
    while (endOffset > reader.getOffset()) {
      const subNode = this.parseNode(reader, version2);
      if (subNode !== null)
        this.parseSubNode(name, node, subNode);
    }
    node.propertyList = propertyList;
    if (typeof id === "number")
      node.id = id;
    if (attrName !== "")
      node.attrName = attrName;
    if (attrType !== "")
      node.attrType = attrType;
    if (name !== "")
      node.name = name;
    return node;
  }
  parseSubNode(name, node, subNode) {
    if (subNode.singleProperty === true) {
      const value = subNode.propertyList[0];
      if (Array.isArray(value)) {
        node[subNode.name] = subNode;
        subNode.a = value;
      } else {
        node[subNode.name] = value;
      }
    } else if (name === "Connections" && subNode.name === "C") {
      const array = [];
      subNode.propertyList.forEach(function(property, i) {
        if (i !== 0)
          array.push(property);
      });
      if (node.connections === void 0) {
        node.connections = [];
      }
      node.connections.push(array);
    } else if (subNode.name === "Properties70") {
      const keys = Object.keys(subNode);
      keys.forEach(function(key) {
        node[key] = subNode[key];
      });
    } else if (name === "Properties70" && subNode.name === "P") {
      let innerPropName = subNode.propertyList[0];
      let innerPropType1 = subNode.propertyList[1];
      const innerPropType2 = subNode.propertyList[2];
      const innerPropFlag = subNode.propertyList[3];
      let innerPropValue;
      if (innerPropName.indexOf("Lcl ") === 0)
        innerPropName = innerPropName.replace("Lcl ", "Lcl_");
      if (innerPropType1.indexOf("Lcl ") === 0)
        innerPropType1 = innerPropType1.replace("Lcl ", "Lcl_");
      if (innerPropType1 === "Color" || innerPropType1 === "ColorRGB" || innerPropType1 === "Vector" || innerPropType1 === "Vector3D" || innerPropType1.indexOf("Lcl_") === 0) {
        innerPropValue = [
          subNode.propertyList[4],
          subNode.propertyList[5],
          subNode.propertyList[6]
        ];
      } else {
        innerPropValue = subNode.propertyList[4];
      }
      node[innerPropName] = {
        "type": innerPropType1,
        "type2": innerPropType2,
        "flag": innerPropFlag,
        "value": innerPropValue
      };
    } else if (node[subNode.name] === void 0) {
      if (typeof subNode.id === "number") {
        node[subNode.name] = {};
        node[subNode.name][subNode.id] = subNode;
      } else {
        node[subNode.name] = subNode;
      }
    } else {
      if (subNode.name === "PoseNode") {
        if (!Array.isArray(node[subNode.name])) {
          node[subNode.name] = [node[subNode.name]];
        }
        node[subNode.name].push(subNode);
      } else if (node[subNode.name][subNode.id] === void 0) {
        node[subNode.name][subNode.id] = subNode;
      }
    }
  }
  parseProperty(reader) {
    const type = reader.getString(1);
    let length;
    switch (type) {
      case "C":
        return reader.getBoolean();
      case "D":
        return reader.getFloat64();
      case "F":
        return reader.getFloat32();
      case "I":
        return reader.getInt32();
      case "L":
        return reader.getInt64();
      case "R":
        length = reader.getUint32();
        return reader.getArrayBuffer(length);
      case "S":
        length = reader.getUint32();
        return reader.getString(length);
      case "Y":
        return reader.getInt16();
      case "b":
      case "c":
      case "d":
      case "f":
      case "i":
      case "l":
        const arrayLength = reader.getUint32();
        const encoding = reader.getUint32();
        const compressedLength = reader.getUint32();
        if (encoding === 0) {
          switch (type) {
            case "b":
            case "c":
              return reader.getBooleanArray(arrayLength);
            case "d":
              return reader.getFloat64Array(arrayLength);
            case "f":
              return reader.getFloat32Array(arrayLength);
            case "i":
              return reader.getInt32Array(arrayLength);
            case "l":
              return reader.getInt64Array(arrayLength);
          }
        }
        const data = unzlibSync(new Uint8Array(reader.getArrayBuffer(compressedLength)));
        const reader2 = new BinaryReader(data.buffer);
        switch (type) {
          case "b":
          case "c":
            return reader2.getBooleanArray(arrayLength);
          case "d":
            return reader2.getFloat64Array(arrayLength);
          case "f":
            return reader2.getFloat32Array(arrayLength);
          case "i":
            return reader2.getInt32Array(arrayLength);
          case "l":
            return reader2.getInt64Array(arrayLength);
        }
        break;
      default:
        throw new Error("THREE.FBXLoader: Unknown property type " + type);
    }
  }
};
var BinaryReader = class {
  constructor(buffer2, littleEndian) {
    this.dv = new DataView(buffer2);
    this.offset = 0;
    this.littleEndian = littleEndian !== void 0 ? littleEndian : true;
    this._textDecoder = new TextDecoder();
  }
  getOffset() {
    return this.offset;
  }
  size() {
    return this.dv.buffer.byteLength;
  }
  skip(length) {
    this.offset += length;
  }
  // seems like true/false representation depends on exporter.
  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
  // then sees LSB.
  getBoolean() {
    return (this.getUint8() & 1) === 1;
  }
  getBooleanArray(size) {
    const a = [];
    for (let i = 0; i < size; i++) {
      a.push(this.getBoolean());
    }
    return a;
  }
  getUint8() {
    const value = this.dv.getUint8(this.offset);
    this.offset += 1;
    return value;
  }
  getInt16() {
    const value = this.dv.getInt16(this.offset, this.littleEndian);
    this.offset += 2;
    return value;
  }
  getInt32() {
    const value = this.dv.getInt32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  }
  getInt32Array(size) {
    const a = [];
    for (let i = 0; i < size; i++) {
      a.push(this.getInt32());
    }
    return a;
  }
  getUint32() {
    const value = this.dv.getUint32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  }
  // JavaScript doesn't support 64-bit integer so calculate this here
  // 1 << 32 will return 1 so using multiply operation instead here.
  // There's a possibility that this method returns wrong value if the value
  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
  // TODO: safely handle 64-bit integer
  getInt64() {
    let low, high;
    if (this.littleEndian) {
      low = this.getUint32();
      high = this.getUint32();
    } else {
      high = this.getUint32();
      low = this.getUint32();
    }
    if (high & 2147483648) {
      high = ~high & 4294967295;
      low = ~low & 4294967295;
      if (low === 4294967295)
        high = high + 1 & 4294967295;
      low = low + 1 & 4294967295;
      return -(high * 4294967296 + low);
    }
    return high * 4294967296 + low;
  }
  getInt64Array(size) {
    const a = [];
    for (let i = 0; i < size; i++) {
      a.push(this.getInt64());
    }
    return a;
  }
  // Note: see getInt64() comment
  getUint64() {
    let low, high;
    if (this.littleEndian) {
      low = this.getUint32();
      high = this.getUint32();
    } else {
      high = this.getUint32();
      low = this.getUint32();
    }
    return high * 4294967296 + low;
  }
  getFloat32() {
    const value = this.dv.getFloat32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  }
  getFloat32Array(size) {
    const a = [];
    for (let i = 0; i < size; i++) {
      a.push(this.getFloat32());
    }
    return a;
  }
  getFloat64() {
    const value = this.dv.getFloat64(this.offset, this.littleEndian);
    this.offset += 8;
    return value;
  }
  getFloat64Array(size) {
    const a = [];
    for (let i = 0; i < size; i++) {
      a.push(this.getFloat64());
    }
    return a;
  }
  getArrayBuffer(size) {
    const value = this.dv.buffer.slice(this.offset, this.offset + size);
    this.offset += size;
    return value;
  }
  getString(size) {
    const start = this.offset;
    let a = new Uint8Array(this.dv.buffer, start, size);
    this.skip(size);
    const nullByte = a.indexOf(0);
    if (nullByte >= 0)
      a = new Uint8Array(this.dv.buffer, start, nullByte);
    return this._textDecoder.decode(a);
  }
};
var FBXTree = class {
  add(key, val) {
    this[key] = val;
  }
};
function isFbxFormatBinary(buffer2) {
  const CORRECT = "Kaydara FBX Binary  \0";
  return buffer2.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer2, 0, CORRECT.length);
}
function isFbxFormatASCII(text) {
  const CORRECT = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
  let cursor = 0;
  function read(offset) {
    const result = text[offset - 1];
    text = text.slice(cursor + offset);
    cursor++;
    return result;
  }
  for (let i = 0; i < CORRECT.length; ++i) {
    const num = read(1);
    if (num === CORRECT[i]) {
      return false;
    }
  }
  return true;
}
function getFbxVersion(text) {
  const versionRegExp = /FBXVersion: (\d+)/;
  const match = text.match(versionRegExp);
  if (match) {
    const version2 = parseInt(match[1]);
    return version2;
  }
  throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
}
function convertFBXTimeToSeconds(time) {
  return time / 46186158e3;
}
var dataArray = [];
function getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {
  let index;
  switch (infoObject.mappingType) {
    case "ByPolygonVertex":
      index = polygonVertexIndex;
      break;
    case "ByPolygon":
      index = polygonIndex;
      break;
    case "ByVertice":
      index = vertexIndex;
      break;
    case "AllSame":
      index = infoObject.indices[0];
      break;
    default:
      console.warn("THREE.FBXLoader: unknown attribute mapping type " + infoObject.mappingType);
  }
  if (infoObject.referenceType === "IndexToDirect")
    index = infoObject.indices[index];
  const from = index * infoObject.dataSize;
  const to = from + infoObject.dataSize;
  return slice(dataArray, infoObject.buffer, from, to);
}
var tempEuler = new Euler();
var tempVec = new Vector32();
function generateTransform(transformData) {
  const lTranslationM = new Matrix4();
  const lPreRotationM = new Matrix4();
  const lRotationM = new Matrix4();
  const lPostRotationM = new Matrix4();
  const lScalingM = new Matrix4();
  const lScalingPivotM = new Matrix4();
  const lScalingOffsetM = new Matrix4();
  const lRotationOffsetM = new Matrix4();
  const lRotationPivotM = new Matrix4();
  const lParentGX = new Matrix4();
  const lParentLX = new Matrix4();
  const lGlobalT = new Matrix4();
  const inheritType = transformData.inheritType ? transformData.inheritType : 0;
  if (transformData.translation)
    lTranslationM.setPosition(tempVec.fromArray(transformData.translation));
  const defaultEulerOrder = getEulerOrder(0);
  if (transformData.preRotation) {
    const array = transformData.preRotation.map(MathUtils.degToRad);
    array.push(defaultEulerOrder);
    lPreRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
  }
  if (transformData.rotation) {
    const array = transformData.rotation.map(MathUtils.degToRad);
    array.push(transformData.eulerOrder || defaultEulerOrder);
    lRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
  }
  if (transformData.postRotation) {
    const array = transformData.postRotation.map(MathUtils.degToRad);
    array.push(defaultEulerOrder);
    lPostRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
    lPostRotationM.invert();
  }
  if (transformData.scale)
    lScalingM.scale(tempVec.fromArray(transformData.scale));
  if (transformData.scalingOffset)
    lScalingOffsetM.setPosition(tempVec.fromArray(transformData.scalingOffset));
  if (transformData.scalingPivot)
    lScalingPivotM.setPosition(tempVec.fromArray(transformData.scalingPivot));
  if (transformData.rotationOffset)
    lRotationOffsetM.setPosition(tempVec.fromArray(transformData.rotationOffset));
  if (transformData.rotationPivot)
    lRotationPivotM.setPosition(tempVec.fromArray(transformData.rotationPivot));
  if (transformData.parentMatrixWorld) {
    lParentLX.copy(transformData.parentMatrix);
    lParentGX.copy(transformData.parentMatrixWorld);
  }
  const lLRM = lPreRotationM.clone().multiply(lRotationM).multiply(lPostRotationM);
  const lParentGRM = new Matrix4();
  lParentGRM.extractRotation(lParentGX);
  const lParentTM = new Matrix4();
  lParentTM.copyPosition(lParentGX);
  const lParentGRSM = lParentTM.clone().invert().multiply(lParentGX);
  const lParentGSM = lParentGRM.clone().invert().multiply(lParentGRSM);
  const lLSM = lScalingM;
  const lGlobalRS = new Matrix4();
  if (inheritType === 0) {
    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM).multiply(lLSM);
  } else if (inheritType === 1) {
    lGlobalRS.copy(lParentGRM).multiply(lParentGSM).multiply(lLRM).multiply(lLSM);
  } else {
    const lParentLSM = new Matrix4().scale(new Vector32().setFromMatrixScale(lParentLX));
    const lParentLSM_inv = lParentLSM.clone().invert();
    const lParentGSM_noLocal = lParentGSM.clone().multiply(lParentLSM_inv);
    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM_noLocal).multiply(lLSM);
  }
  const lRotationPivotM_inv = lRotationPivotM.clone().invert();
  const lScalingPivotM_inv = lScalingPivotM.clone().invert();
  let lTransform = lTranslationM.clone().multiply(lRotationOffsetM).multiply(lRotationPivotM).multiply(lPreRotationM).multiply(lRotationM).multiply(lPostRotationM).multiply(lRotationPivotM_inv).multiply(lScalingOffsetM).multiply(lScalingPivotM).multiply(lScalingM).multiply(lScalingPivotM_inv);
  const lLocalTWithAllPivotAndOffsetInfo = new Matrix4().copyPosition(lTransform);
  const lGlobalTranslation = lParentGX.clone().multiply(lLocalTWithAllPivotAndOffsetInfo);
  lGlobalT.copyPosition(lGlobalTranslation);
  lTransform = lGlobalT.clone().multiply(lGlobalRS);
  lTransform.premultiply(lParentGX.invert());
  return lTransform;
}
function getEulerOrder(order) {
  order = order || 0;
  const enums = [
    "ZYX",
    // -> XYZ extrinsic
    "YZX",
    // -> XZY extrinsic
    "XZY",
    // -> YZX extrinsic
    "ZXY",
    // -> YXZ extrinsic
    "YXZ",
    // -> ZXY extrinsic
    "XYZ"
    // -> ZYX extrinsic
    //'SphericXYZ', // not possible to support
  ];
  if (order === 6) {
    console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.");
    return enums[0];
  }
  return enums[order];
}
function parseNumberArray(value) {
  const array = value.split(",").map(function(val) {
    return parseFloat(val);
  });
  return array;
}
function convertArrayBufferToString(buffer2, from, to) {
  if (from === void 0)
    from = 0;
  if (to === void 0)
    to = buffer2.byteLength;
  return new TextDecoder().decode(new Uint8Array(buffer2, from, to));
}
function append(a, b) {
  for (let i = 0, j = a.length, l = b.length; i < l; i++, j++) {
    a[j] = b[i];
  }
}
function slice(a, b, from, to) {
  for (let i = from, j = 0; i < to; i++, j++) {
    a[j] = b[i];
  }
  return a;
}

// node_modules/three/examples/jsm/loaders/MTLLoader.js
var MTLLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  /**
   * Loads and parses a MTL asset from a URL.
   *
   * @param {String} url - URL to the MTL file.
   * @param {Function} [onLoad] - Callback invoked with the loaded object.
   * @param {Function} [onProgress] - Callback for download progress.
   * @param {Function} [onError] - Callback for download errors.
   *
   * @see setPath setResourcePath
   *
   * @note In order for relative texture references to resolve correctly
   * you must call setResourcePath() explicitly prior to load.
   */
  load(url, onLoad2, onProgress, onError2) {
    const scope = this;
    const path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
    const loader2 = new FileLoader(this.manager);
    loader2.setPath(this.path);
    loader2.setRequestHeader(this.requestHeader);
    loader2.setWithCredentials(this.withCredentials);
    loader2.load(url, function(text) {
      try {
        onLoad2(scope.parse(text, path));
      } catch (e) {
        if (onError2) {
          onError2(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError2);
  }
  setMaterialOptions(value) {
    this.materialOptions = value;
    return this;
  }
  /**
   * Parses a MTL file.
   *
   * @param {String} text - Content of MTL file
   * @return {MaterialCreator}
   *
   * @see setPath setResourcePath
   *
   * @note In order for relative texture references to resolve correctly
   * you must call setResourcePath() explicitly prior to parse.
   */
  parse(text, path) {
    const lines = text.split("\n");
    let info = {};
    const delimiter_pattern = /\s+/;
    const materialsInfo = {};
    for (let i = 0; i < lines.length; i++) {
      let line = lines[i];
      line = line.trim();
      if (line.length === 0 || line.charAt(0) === "#") {
        continue;
      }
      const pos = line.indexOf(" ");
      let key = pos >= 0 ? line.substring(0, pos) : line;
      key = key.toLowerCase();
      let value = pos >= 0 ? line.substring(pos + 1) : "";
      value = value.trim();
      if (key === "newmtl") {
        info = { name: value };
        materialsInfo[value] = info;
      } else {
        if (key === "ka" || key === "kd" || key === "ks" || key === "ke") {
          const ss = value.split(delimiter_pattern, 3);
          info[key] = [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];
        } else {
          info[key] = value;
        }
      }
    }
    const materialCreator = new MaterialCreator(this.resourcePath || path, this.materialOptions);
    materialCreator.setCrossOrigin(this.crossOrigin);
    materialCreator.setManager(this.manager);
    materialCreator.setMaterials(materialsInfo);
    return materialCreator;
  }
};
var MaterialCreator = class {
  constructor(baseUrl = "", options = {}) {
    this.baseUrl = baseUrl;
    this.options = options;
    this.materialsInfo = {};
    this.materials = {};
    this.materialsArray = [];
    this.nameLookup = {};
    this.crossOrigin = "anonymous";
    this.side = this.options.side !== void 0 ? this.options.side : FrontSide;
    this.wrap = this.options.wrap !== void 0 ? this.options.wrap : RepeatWrapping;
  }
  setCrossOrigin(value) {
    this.crossOrigin = value;
    return this;
  }
  setManager(value) {
    this.manager = value;
  }
  setMaterials(materialsInfo) {
    this.materialsInfo = this.convert(materialsInfo);
    this.materials = {};
    this.materialsArray = [];
    this.nameLookup = {};
  }
  convert(materialsInfo) {
    if (!this.options)
      return materialsInfo;
    const converted = {};
    for (const mn in materialsInfo) {
      const mat = materialsInfo[mn];
      const covmat = {};
      converted[mn] = covmat;
      for (const prop in mat) {
        let save = true;
        let value = mat[prop];
        const lprop = prop.toLowerCase();
        switch (lprop) {
          case "kd":
          case "ka":
          case "ks":
            if (this.options && this.options.normalizeRGB) {
              value = [value[0] / 255, value[1] / 255, value[2] / 255];
            }
            if (this.options && this.options.ignoreZeroRGBs) {
              if (value[0] === 0 && value[1] === 0 && value[2] === 0) {
                save = false;
              }
            }
            break;
          default:
            break;
        }
        if (save) {
          covmat[lprop] = value;
        }
      }
    }
    return converted;
  }
  preload() {
    for (const mn in this.materialsInfo) {
      this.create(mn);
    }
  }
  getIndex(materialName) {
    return this.nameLookup[materialName];
  }
  getAsArray() {
    let index = 0;
    for (const mn in this.materialsInfo) {
      this.materialsArray[index] = this.create(mn);
      this.nameLookup[mn] = index;
      index++;
    }
    return this.materialsArray;
  }
  create(materialName) {
    if (this.materials[materialName] === void 0) {
      this.createMaterial_(materialName);
    }
    return this.materials[materialName];
  }
  createMaterial_(materialName) {
    const scope = this;
    const mat = this.materialsInfo[materialName];
    const params = {
      name: materialName,
      side: this.side
    };
    function resolveURL(baseUrl, url) {
      if (typeof url !== "string" || url === "")
        return "";
      if (/^https?:\/\//i.test(url))
        return url;
      return baseUrl + url;
    }
    function setMapForType(mapType, value) {
      if (params[mapType])
        return;
      const texParams = scope.getTextureParams(value, params);
      const map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));
      map.repeat.copy(texParams.scale);
      map.offset.copy(texParams.offset);
      map.wrapS = scope.wrap;
      map.wrapT = scope.wrap;
      if (mapType === "map" || mapType === "emissiveMap") {
        map.colorSpace = SRGBColorSpace;
      }
      params[mapType] = map;
    }
    for (const prop in mat) {
      const value = mat[prop];
      let n2;
      if (value === "")
        continue;
      switch (prop.toLowerCase()) {
        case "kd":
          params.color = ColorManagement.toWorkingColorSpace(new Color().fromArray(value), SRGBColorSpace);
          break;
        case "ks":
          params.specular = ColorManagement.toWorkingColorSpace(new Color().fromArray(value), SRGBColorSpace);
          break;
        case "ke":
          params.emissive = ColorManagement.toWorkingColorSpace(new Color().fromArray(value), SRGBColorSpace);
          break;
        case "map_kd":
          setMapForType("map", value);
          break;
        case "map_ks":
          setMapForType("specularMap", value);
          break;
        case "map_ke":
          setMapForType("emissiveMap", value);
          break;
        case "norm":
          setMapForType("normalMap", value);
          break;
        case "map_bump":
        case "bump":
          setMapForType("bumpMap", value);
          break;
        case "map_d":
          setMapForType("alphaMap", value);
          params.transparent = true;
          break;
        case "ns":
          params.shininess = parseFloat(value);
          break;
        case "d":
          n2 = parseFloat(value);
          if (n2 < 1) {
            params.opacity = n2;
            params.transparent = true;
          }
          break;
        case "tr":
          n2 = parseFloat(value);
          if (this.options && this.options.invertTrProperty)
            n2 = 1 - n2;
          if (n2 > 0) {
            params.opacity = 1 - n2;
            params.transparent = true;
          }
          break;
        default:
          break;
      }
    }
    this.materials[materialName] = new MeshPhongMaterial(params);
    return this.materials[materialName];
  }
  getTextureParams(value, matParams) {
    const texParams = {
      scale: new Vector2(1, 1),
      offset: new Vector2(0, 0)
    };
    const items = value.split(/\s+/);
    let pos;
    pos = items.indexOf("-bm");
    if (pos >= 0) {
      matParams.bumpScale = parseFloat(items[pos + 1]);
      items.splice(pos, 2);
    }
    pos = items.indexOf("-s");
    if (pos >= 0) {
      texParams.scale.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));
      items.splice(pos, 4);
    }
    pos = items.indexOf("-o");
    if (pos >= 0) {
      texParams.offset.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));
      items.splice(pos, 4);
    }
    texParams.url = items.join(" ").trim();
    return texParams;
  }
  loadTexture(url, mapping, onLoad2, onProgress, onError2) {
    const manager = this.manager !== void 0 ? this.manager : DefaultLoadingManager;
    let loader2 = manager.getHandler(url);
    if (loader2 === null) {
      loader2 = new TextureLoader(manager);
    }
    if (loader2.setCrossOrigin)
      loader2.setCrossOrigin(this.crossOrigin);
    const texture = loader2.load(url, onLoad2, onProgress, onError2);
    if (mapping !== void 0)
      texture.mapping = mapping;
    return texture;
  }
};

// node_modules/three/examples/jsm/loaders/OBJLoader.js
var _object_pattern = /^[og]\s*(.+)?/;
var _material_library_pattern = /^mtllib /;
var _material_use_pattern = /^usemtl /;
var _map_use_pattern = /^usemap /;
var _face_vertex_data_separator_pattern = /\s+/;
var _vA = new Vector32();
var _vB = new Vector32();
var _vC = new Vector32();
var _ab = new Vector32();
var _cb = new Vector32();
var _color = new Color();
function ParserState() {
  const state = {
    objects: [],
    object: {},
    vertices: [],
    normals: [],
    colors: [],
    uvs: [],
    materials: {},
    materialLibraries: [],
    startObject: function(name, fromDeclaration) {
      if (this.object && this.object.fromDeclaration === false) {
        this.object.name = name;
        this.object.fromDeclaration = fromDeclaration !== false;
        return;
      }
      const previousMaterial = this.object && typeof this.object.currentMaterial === "function" ? this.object.currentMaterial() : void 0;
      if (this.object && typeof this.object._finalize === "function") {
        this.object._finalize(true);
      }
      this.object = {
        name: name || "",
        fromDeclaration: fromDeclaration !== false,
        geometry: {
          vertices: [],
          normals: [],
          colors: [],
          uvs: [],
          hasUVIndices: false
        },
        materials: [],
        smooth: true,
        startMaterial: function(name2, libraries) {
          const previous = this._finalize(false);
          if (previous && (previous.inherited || previous.groupCount <= 0)) {
            this.materials.splice(previous.index, 1);
          }
          const material = {
            index: this.materials.length,
            name: name2 || "",
            mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : "",
            smooth: previous !== void 0 ? previous.smooth : this.smooth,
            groupStart: previous !== void 0 ? previous.groupEnd : 0,
            groupEnd: -1,
            groupCount: -1,
            inherited: false,
            clone: function(index) {
              const cloned = {
                index: typeof index === "number" ? index : this.index,
                name: this.name,
                mtllib: this.mtllib,
                smooth: this.smooth,
                groupStart: 0,
                groupEnd: -1,
                groupCount: -1,
                inherited: false
              };
              cloned.clone = this.clone.bind(cloned);
              return cloned;
            }
          };
          this.materials.push(material);
          return material;
        },
        currentMaterial: function() {
          if (this.materials.length > 0) {
            return this.materials[this.materials.length - 1];
          }
          return void 0;
        },
        _finalize: function(end) {
          const lastMultiMaterial = this.currentMaterial();
          if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {
            lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
            lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
            lastMultiMaterial.inherited = false;
          }
          if (end && this.materials.length > 1) {
            for (let mi = this.materials.length - 1; mi >= 0; mi--) {
              if (this.materials[mi].groupCount <= 0) {
                this.materials.splice(mi, 1);
              }
            }
          }
          if (end && this.materials.length === 0) {
            this.materials.push({
              name: "",
              smooth: this.smooth
            });
          }
          return lastMultiMaterial;
        }
      };
      if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === "function") {
        const declared = previousMaterial.clone(0);
        declared.inherited = true;
        this.object.materials.push(declared);
      }
      this.objects.push(this.object);
    },
    finalize: function() {
      if (this.object && typeof this.object._finalize === "function") {
        this.object._finalize(true);
      }
    },
    parseVertexIndex: function(value, len) {
      const index = parseInt(value, 10);
      return (index >= 0 ? index - 1 : index + len / 3) * 3;
    },
    parseNormalIndex: function(value, len) {
      const index = parseInt(value, 10);
      return (index >= 0 ? index - 1 : index + len / 3) * 3;
    },
    parseUVIndex: function(value, len) {
      const index = parseInt(value, 10);
      return (index >= 0 ? index - 1 : index + len / 2) * 2;
    },
    addVertex: function(a, b, c2) {
      const src = this.vertices;
      const dst = this.object.geometry.vertices;
      dst.push(src[a + 0], src[a + 1], src[a + 2]);
      dst.push(src[b + 0], src[b + 1], src[b + 2]);
      dst.push(src[c2 + 0], src[c2 + 1], src[c2 + 2]);
    },
    addVertexPoint: function(a) {
      const src = this.vertices;
      const dst = this.object.geometry.vertices;
      dst.push(src[a + 0], src[a + 1], src[a + 2]);
    },
    addVertexLine: function(a) {
      const src = this.vertices;
      const dst = this.object.geometry.vertices;
      dst.push(src[a + 0], src[a + 1], src[a + 2]);
    },
    addNormal: function(a, b, c2) {
      const src = this.normals;
      const dst = this.object.geometry.normals;
      dst.push(src[a + 0], src[a + 1], src[a + 2]);
      dst.push(src[b + 0], src[b + 1], src[b + 2]);
      dst.push(src[c2 + 0], src[c2 + 1], src[c2 + 2]);
    },
    addFaceNormal: function(a, b, c2) {
      const src = this.vertices;
      const dst = this.object.geometry.normals;
      _vA.fromArray(src, a);
      _vB.fromArray(src, b);
      _vC.fromArray(src, c2);
      _cb.subVectors(_vC, _vB);
      _ab.subVectors(_vA, _vB);
      _cb.cross(_ab);
      _cb.normalize();
      dst.push(_cb.x, _cb.y, _cb.z);
      dst.push(_cb.x, _cb.y, _cb.z);
      dst.push(_cb.x, _cb.y, _cb.z);
    },
    addColor: function(a, b, c2) {
      const src = this.colors;
      const dst = this.object.geometry.colors;
      if (src[a] !== void 0)
        dst.push(src[a + 0], src[a + 1], src[a + 2]);
      if (src[b] !== void 0)
        dst.push(src[b + 0], src[b + 1], src[b + 2]);
      if (src[c2] !== void 0)
        dst.push(src[c2 + 0], src[c2 + 1], src[c2 + 2]);
    },
    addUV: function(a, b, c2) {
      const src = this.uvs;
      const dst = this.object.geometry.uvs;
      dst.push(src[a + 0], src[a + 1]);
      dst.push(src[b + 0], src[b + 1]);
      dst.push(src[c2 + 0], src[c2 + 1]);
    },
    addDefaultUV: function() {
      const dst = this.object.geometry.uvs;
      dst.push(0, 0);
      dst.push(0, 0);
      dst.push(0, 0);
    },
    addUVLine: function(a) {
      const src = this.uvs;
      const dst = this.object.geometry.uvs;
      dst.push(src[a + 0], src[a + 1]);
    },
    addFace: function(a, b, c2, ua, ub, uc, na, nb, nc) {
      const vLen = this.vertices.length;
      let ia = this.parseVertexIndex(a, vLen);
      let ib = this.parseVertexIndex(b, vLen);
      let ic = this.parseVertexIndex(c2, vLen);
      this.addVertex(ia, ib, ic);
      this.addColor(ia, ib, ic);
      if (na !== void 0 && na !== "") {
        const nLen = this.normals.length;
        ia = this.parseNormalIndex(na, nLen);
        ib = this.parseNormalIndex(nb, nLen);
        ic = this.parseNormalIndex(nc, nLen);
        this.addNormal(ia, ib, ic);
      } else {
        this.addFaceNormal(ia, ib, ic);
      }
      if (ua !== void 0 && ua !== "") {
        const uvLen = this.uvs.length;
        ia = this.parseUVIndex(ua, uvLen);
        ib = this.parseUVIndex(ub, uvLen);
        ic = this.parseUVIndex(uc, uvLen);
        this.addUV(ia, ib, ic);
        this.object.geometry.hasUVIndices = true;
      } else {
        this.addDefaultUV();
      }
    },
    addPointGeometry: function(vertices) {
      this.object.geometry.type = "Points";
      const vLen = this.vertices.length;
      for (let vi = 0, l = vertices.length; vi < l; vi++) {
        const index = this.parseVertexIndex(vertices[vi], vLen);
        this.addVertexPoint(index);
        this.addColor(index);
      }
    },
    addLineGeometry: function(vertices, uvs) {
      this.object.geometry.type = "Line";
      const vLen = this.vertices.length;
      const uvLen = this.uvs.length;
      for (let vi = 0, l = vertices.length; vi < l; vi++) {
        this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));
      }
      for (let uvi = 0, l = uvs.length; uvi < l; uvi++) {
        this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));
      }
    }
  };
  state.startObject("", false);
  return state;
}
var OBJLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.materials = null;
    this.materialsLoader = new MTLLoader(manager);
  }
  load(url, onLoad2, onProgress, onError2) {
    const scope = this;
    const loader2 = new FileLoader(this.manager);
    loader2.setPath(this.path);
    loader2.setRequestHeader(this.requestHeader);
    loader2.setWithCredentials(this.withCredentials);
    loader2.load(url, async function(text) {
      try {
        const state = scope.parse(text, true);
        for (let i = 0, l = state.materialLibraries.length; i < l; i++) {
          const mtlfile = state.materialLibraries[i];
          const newUrl = url.startsWith("blob:") ? url + "/" + mtlfile : new URL(mtlfile, url);
          console.debug("Loading MTL file: " + newUrl);
          await new Promise((resolve2, reject) => {
            scope.materialsLoader.load(newUrl.toString(), (creator) => {
              scope.setMaterials(creator);
              resolve2();
            }, null, reject);
          });
        }
        onLoad2(scope.createObjects(state));
      } catch (e) {
        if (onError2) {
          onError2(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError2);
  }
  setMTLLoader(loader2) {
    this.materialsLoader = loader2;
    return this;
  }
  setMaterials(materials) {
    this.materials = materials;
    return this;
  }
  parse(text, parseOnly = false) {
    const state = new ParserState();
    if (text.indexOf("\r\n") !== -1) {
      text = text.replace(/\r\n/g, "\n");
    }
    if (text.indexOf("\\\n") !== -1) {
      text = text.replace(/\\\n/g, "");
    }
    const lines = text.split("\n");
    let result = [];
    for (let i = 0, l = lines.length; i < l; i++) {
      const line = lines[i].trimStart();
      if (line.length === 0)
        continue;
      const lineFirstChar = line.charAt(0);
      if (lineFirstChar === "#")
        continue;
      if (lineFirstChar === "v") {
        const data = line.split(_face_vertex_data_separator_pattern);
        switch (data[0]) {
          case "v":
            state.vertices.push(
              parseFloat(data[1]),
              parseFloat(data[2]),
              parseFloat(data[3])
            );
            if (data.length >= 7) {
              _color.setRGB(
                parseFloat(data[4]),
                parseFloat(data[5]),
                parseFloat(data[6]),
                SRGBColorSpace
              );
              state.colors.push(_color.r, _color.g, _color.b);
            } else {
              state.colors.push(void 0, void 0, void 0);
            }
            break;
          case "vn":
            state.normals.push(
              parseFloat(data[1]),
              parseFloat(data[2]),
              parseFloat(data[3])
            );
            break;
          case "vt":
            state.uvs.push(
              parseFloat(data[1]),
              parseFloat(data[2])
            );
            break;
        }
      } else if (lineFirstChar === "f") {
        const lineData = line.slice(1).trim();
        const vertexData = lineData.split(_face_vertex_data_separator_pattern);
        const faceVertices = [];
        for (let j = 0, jl = vertexData.length; j < jl; j++) {
          const vertex = vertexData[j];
          if (vertex.length > 0) {
            const vertexParts = vertex.split("/");
            faceVertices.push(vertexParts);
          }
        }
        const v1 = faceVertices[0];
        for (let j = 1, jl = faceVertices.length - 1; j < jl; j++) {
          const v22 = faceVertices[j];
          const v32 = faceVertices[j + 1];
          state.addFace(
            v1[0],
            v22[0],
            v32[0],
            v1[1],
            v22[1],
            v32[1],
            v1[2],
            v22[2],
            v32[2]
          );
        }
      } else if (lineFirstChar === "l") {
        const lineParts = line.substring(1).trim().split(" ");
        let lineVertices = [];
        const lineUVs = [];
        if (line.indexOf("/") === -1) {
          lineVertices = lineParts;
        } else {
          for (let li = 0, llen = lineParts.length; li < llen; li++) {
            const parts = lineParts[li].split("/");
            if (parts[0] !== "")
              lineVertices.push(parts[0]);
            if (parts[1] !== "")
              lineUVs.push(parts[1]);
          }
        }
        state.addLineGeometry(lineVertices, lineUVs);
      } else if (lineFirstChar === "p") {
        const lineData = line.slice(1).trim();
        const pointData = lineData.split(" ");
        state.addPointGeometry(pointData);
      } else if ((result = _object_pattern.exec(line)) !== null) {
        const name = (" " + result[0].slice(1).trim()).slice(1);
        state.startObject(name);
      } else if (_material_use_pattern.test(line)) {
        state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);
      } else if (_material_library_pattern.test(line)) {
        state.materialLibraries.push(line.substring(7).trim());
      } else if (_map_use_pattern.test(line)) {
        console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
      } else if (lineFirstChar === "s") {
        result = line.split(" ");
        if (result.length > 1) {
          const value = result[1].trim().toLowerCase();
          state.object.smooth = value !== "0" && value !== "off";
        } else {
          state.object.smooth = true;
        }
        const material = state.object.currentMaterial();
        if (material)
          material.smooth = state.object.smooth;
      } else {
        if (line === "\0")
          continue;
        console.warn('THREE.OBJLoader: Unexpected line: "' + line + '"');
      }
    }
    state.finalize();
    if (parseOnly)
      return state;
    return this.createObjects(state);
  }
  createObjects(state) {
    const container = new Group();
    container.materialLibraries = [].concat(state.materialLibraries);
    const hasPrimitives = !(state.objects.length === 1 && state.objects[0].geometry.vertices.length === 0);
    if (hasPrimitives === true) {
      for (let i = 0, l = state.objects.length; i < l; i++) {
        const object = state.objects[i];
        const geometry = object.geometry;
        const materials = object.materials;
        const isLine = geometry.type === "Line";
        const isPoints = geometry.type === "Points";
        let hasVertexColors = false;
        if (geometry.vertices.length === 0)
          continue;
        const buffergeometry = new BufferGeometry();
        buffergeometry.setAttribute("position", new Float32BufferAttribute2(geometry.vertices, 3));
        if (geometry.normals.length > 0) {
          buffergeometry.setAttribute("normal", new Float32BufferAttribute2(geometry.normals, 3));
        }
        if (geometry.colors.length > 0) {
          hasVertexColors = true;
          buffergeometry.setAttribute("color", new Float32BufferAttribute2(geometry.colors, 3));
        }
        if (geometry.hasUVIndices === true) {
          buffergeometry.setAttribute("uv", new Float32BufferAttribute2(geometry.uvs, 2));
        }
        const createdMaterials = [];
        for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {
          const sourceMaterial = materials[mi];
          const materialHash = sourceMaterial.name + "_" + sourceMaterial.smooth + "_" + hasVertexColors;
          let material = state.materials[materialHash];
          if (this.materials !== null) {
            material = this.materials.create(sourceMaterial.name);
            if (isLine && material && !(material instanceof LineBasicMaterial)) {
              const materialLine = new LineBasicMaterial();
              Material.prototype.copy.call(materialLine, material);
              materialLine.color.copy(material.color);
              material = materialLine;
            } else if (isPoints && material && !(material instanceof PointsMaterial)) {
              const materialPoints = new PointsMaterial({ size: 10, sizeAttenuation: false });
              Material.prototype.copy.call(materialPoints, material);
              materialPoints.color.copy(material.color);
              materialPoints.map = material.map;
              material = materialPoints;
            }
          }
          if (material === void 0) {
            if (isLine) {
              material = new LineBasicMaterial();
            } else if (isPoints) {
              material = new PointsMaterial({ size: 1, sizeAttenuation: false });
            } else {
              material = new MeshPhongMaterial();
            }
            material.name = sourceMaterial.name;
            material.flatShading = sourceMaterial.smooth ? false : true;
            material.vertexColors = hasVertexColors;
            state.materials[materialHash] = material;
          }
          createdMaterials.push(material);
        }
        let mesh;
        if (createdMaterials.length > 1) {
          for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {
            const sourceMaterial = materials[mi];
            buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);
          }
          if (isLine) {
            mesh = new LineSegments(buffergeometry, createdMaterials);
          } else if (isPoints) {
            mesh = new Points(buffergeometry, createdMaterials);
          } else {
            mesh = new Mesh(buffergeometry, createdMaterials);
          }
        } else {
          if (isLine) {
            mesh = new LineSegments(buffergeometry, createdMaterials[0]);
          } else if (isPoints) {
            mesh = new Points(buffergeometry, createdMaterials[0]);
          } else {
            mesh = new Mesh(buffergeometry, createdMaterials[0]);
          }
        }
        mesh.name = object.name;
        container.add(mesh);
      }
    } else {
      if (state.vertices.length > 0) {
        const material = new PointsMaterial({ size: 1, sizeAttenuation: false });
        const buffergeometry = new BufferGeometry();
        buffergeometry.setAttribute("position", new Float32BufferAttribute2(state.vertices, 3));
        if (state.colors.length > 0 && state.colors[0] !== void 0) {
          buffergeometry.setAttribute("color", new Float32BufferAttribute2(state.colors, 3));
          material.vertexColors = true;
        }
        const points = new Points(buffergeometry, material);
        container.add(points);
      }
    }
    return container;
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/codegen/components.js
var components_exports = {};
__export(components_exports, {
  ActionBuilder: () => ActionBuilder,
  ActionCollection: () => ActionCollection,
  ActionModel: () => ActionModel,
  AlignmentConstraint: () => AlignmentConstraint,
  Animation: () => Animation,
  AnimationCurve: () => AnimationCurve,
  AnimationExtension: () => AnimationExtension,
  AnimationTrackHandler: () => AnimationTrackHandler,
  Animator: () => Animator,
  AnimatorController: () => AnimatorController,
  Antialiasing: () => Antialiasing,
  AudioExtension: () => AudioExtension,
  AudioListener: () => AudioListener2,
  AudioSource: () => AudioSource,
  AudioTrackHandler: () => AudioTrackHandler,
  Avatar: () => Avatar,
  AvatarBlink_Simple: () => AvatarBlink_Simple,
  AvatarEyeLook_Rotation: () => AvatarEyeLook_Rotation,
  AvatarLoader: () => AvatarLoader,
  AvatarMarker: () => AvatarMarker,
  AvatarModel: () => AvatarModel,
  Avatar_Brain_LookAt: () => Avatar_Brain_LookAt,
  Avatar_MouthShapes: () => Avatar_MouthShapes,
  Avatar_MustacheShake: () => Avatar_MustacheShake,
  Avatar_POI: () => Avatar_POI,
  AxesHelper: () => AxesHelper2,
  BaseUIComponent: () => BaseUIComponent,
  BasicIKConstraint: () => BasicIKConstraint,
  BehaviorExtension: () => BehaviorExtension,
  BehaviorModel: () => BehaviorModel,
  BloomEffect: () => BloomEffect2,
  BoxCollider: () => BoxCollider,
  BoxGizmo: () => BoxGizmo,
  BoxHelperComponent: () => BoxHelperComponent,
  Button: () => Button,
  CallInfo: () => CallInfo,
  Camera: () => Camera2,
  CameraTargetReachedEvent: () => CameraTargetReachedEvent,
  Canvas: () => Canvas,
  CanvasGroup: () => CanvasGroup,
  CapsuleCollider: () => CapsuleCollider,
  ChangeMaterialOnClick: () => ChangeMaterialOnClick,
  ChangeTransformOnClick: () => ChangeTransformOnClick,
  CharacterController: () => CharacterController,
  CharacterControllerInput: () => CharacterControllerInput,
  ChromaticAberration: () => ChromaticAberration,
  Collider: () => Collider,
  ColorAdjustments: () => ColorAdjustments,
  ColorBySpeedModule: () => ColorBySpeedModule,
  ColorOverLifetimeModule: () => ColorOverLifetimeModule,
  ContactShadows: () => ContactShadows,
  ControlTrackHandler: () => ControlTrackHandler,
  CustomBranding: () => CustomBranding,
  Deletable: () => Deletable,
  DeleteBox: () => DeleteBox,
  DepthOfField: () => DepthOfField,
  DeviceFlag: () => DeviceFlag,
  DocumentExtension: () => DocumentExtension,
  DragControls: () => DragControls,
  DropListener: () => DropListener,
  DropListenerAddedEvent: () => DropListenerAddedEvent,
  Duplicatable: () => Duplicatable,
  EffectWrapper: () => EffectWrapper,
  EmissionModule: () => EmissionModule,
  EmphasizeOnClick: () => EmphasizeOnClick,
  EventList: () => EventList,
  EventListEvent: () => EventListEvent,
  EventSystem: () => EventSystem,
  EventTrigger: () => EventTrigger,
  FieldWithDefault: () => FieldWithDefault,
  FixedJoint: () => FixedJoint,
  FlyControls: () => FlyControls2,
  Fog: () => Fog2,
  GltfExport: () => GltfExport,
  GltfExportBox: () => GltfExportBox,
  Gradient: () => Gradient,
  Graphic: () => Graphic,
  GraphicRaycaster: () => GraphicRaycaster,
  GridHelper: () => GridHelper2,
  GridLayoutGroup: () => GridLayoutGroup,
  GroundProjectedEnv: () => GroundProjectedEnv,
  GroupActionModel: () => GroupActionModel,
  HideOnStart: () => HideOnStart,
  HingeJoint: () => HingeJoint,
  HorizontalLayoutGroup: () => HorizontalLayoutGroup,
  Image: () => Image2,
  InheritVelocityModule: () => InheritVelocityModule,
  InputField: () => InputField,
  InstanceHandle: () => InstanceHandle,
  InstancingHandler: () => InstancingHandler,
  Interactable: () => Interactable,
  Keyframe: () => Keyframe,
  LODGroup: () => LODGroup,
  LODModel: () => LODModel,
  Light: () => Light,
  LimitVelocityOverLifetimeModule: () => LimitVelocityOverLifetimeModule,
  LogStats: () => LogStats,
  LookAt: () => LookAt,
  LookAtConstraint: () => LookAtConstraint,
  MainModule: () => MainModule,
  MaskableGraphic: () => MaskableGraphic,
  MeshCollider: () => MeshCollider,
  MeshRenderer: () => MeshRenderer,
  MinMaxCurve: () => MinMaxCurve,
  MinMaxGradient: () => MinMaxGradient,
  NeedleMenu: () => NeedleMenu2,
  NestedGltf: () => NestedGltf,
  Networking: () => Networking,
  NoiseModule: () => NoiseModule,
  ObjectRaycaster: () => ObjectRaycaster,
  OffsetConstraint: () => OffsetConstraint,
  OpenURL: () => OpenURL,
  OrbitControls: () => OrbitControls2,
  Outline: () => Outline,
  Padding: () => Padding,
  ParticleBurst: () => ParticleBurst,
  ParticleSubEmitter: () => ParticleSubEmitter,
  ParticleSystem: () => ParticleSystem2,
  ParticleSystemRenderer: () => ParticleSystemRenderer,
  PhysicsExtension: () => PhysicsExtension,
  PixelationEffect: () => PixelationEffect2,
  PlayAnimationOnClick: () => PlayAnimationOnClick,
  PlayAudioOnClick: () => PlayAudioOnClick,
  PlayableDirector: () => PlayableDirector,
  PlayerColor: () => PlayerColor,
  PointerEventData: () => PointerEventData,
  PostProcessingHandler: () => PostProcessingHandler,
  PreliminaryAction: () => PreliminaryAction,
  PreliminaryTrigger: () => PreliminaryTrigger,
  RawImage: () => RawImage,
  Rect: () => Rect,
  RectTransform: () => RectTransform,
  ReflectionProbe: () => ReflectionProbe,
  RegisteredAnimationInfo: () => RegisteredAnimationInfo,
  RemoteSkybox: () => RemoteSkybox,
  Renderer: () => Renderer,
  RendererLightmap: () => RendererLightmap,
  Rigidbody: () => Rigidbody,
  RotationBySpeedModule: () => RotationBySpeedModule,
  RotationOverLifetimeModule: () => RotationOverLifetimeModule,
  SceneSwitcher: () => SceneSwitcher,
  ScreenCapture: () => ScreenCapture,
  ScreenSpaceAmbientOcclusion: () => ScreenSpaceAmbientOcclusion,
  ScreenSpaceAmbientOcclusionN8: () => ScreenSpaceAmbientOcclusionN8,
  SetActiveOnClick: () => SetActiveOnClick,
  ShadowCatcher: () => ShadowCatcher,
  ShapeModule: () => ShapeModule,
  SharpeningEffect: () => SharpeningEffect,
  SignalAsset: () => SignalAsset,
  SignalReceiver: () => SignalReceiver,
  SignalReceiverEvent: () => SignalReceiverEvent,
  SignalTrackHandler: () => SignalTrackHandler,
  Size: () => Size,
  SizeBySpeedModule: () => SizeBySpeedModule,
  SizeOverLifetimeModule: () => SizeOverLifetimeModule,
  SkinnedMeshRenderer: () => SkinnedMeshRenderer,
  SmoothFollow: () => SmoothFollow,
  SpatialGrabRaycaster: () => SpatialGrabRaycaster,
  SpatialHtml: () => SpatialHtml,
  SpatialTrigger: () => SpatialTrigger,
  SpatialTriggerReceiver: () => SpatialTriggerReceiver,
  SpectatorCamera: () => SpectatorCamera,
  SphereCollider: () => SphereCollider,
  Sprite: () => Sprite3,
  SpriteData: () => SpriteData,
  SpriteRenderer: () => SpriteRenderer,
  SpriteSheet: () => SpriteSheet,
  SubEmitterSystem: () => SubEmitterSystem,
  SyncedCamera: () => SyncedCamera,
  SyncedRoom: () => SyncedRoom,
  SyncedTransform: () => SyncedTransform,
  TapGestureTrigger: () => TapGestureTrigger,
  TeleportTarget: () => TeleportTarget,
  TestRunner: () => TestRunner,
  TestSimulateUserData: () => TestSimulateUserData,
  Text: () => Text,
  TextBuilder: () => TextBuilder,
  TextExtension: () => TextExtension,
  TextureSheetAnimationModule: () => TextureSheetAnimationModule,
  TiltShiftEffect: () => TiltShiftEffect2,
  ToneMappingEffect: () => ToneMappingEffect2,
  TrailModule: () => TrailModule,
  TransformData: () => TransformData,
  TransformGizmo: () => TransformGizmo,
  TriggerBuilder: () => TriggerBuilder,
  TriggerModel: () => TriggerModel,
  UIRaycastUtils: () => UIRaycastUtils,
  UIRootComponent: () => UIRootComponent,
  USDZExporter: () => USDZExporter2,
  USDZText: () => USDZText,
  USDZUIExtension: () => USDZUIExtension,
  UsageMarker: () => UsageMarker,
  VariantAction: () => VariantAction,
  VelocityOverLifetimeModule: () => VelocityOverLifetimeModule,
  VerticalLayoutGroup: () => VerticalLayoutGroup,
  VideoPlayer: () => VideoPlayer,
  Vignette: () => Vignette,
  VisibilityAction: () => VisibilityAction,
  Voip: () => Voip,
  Volume: () => Volume,
  VolumeParameter: () => VolumeParameter,
  VolumeProfile: () => VolumeProfile,
  WebARCameraBackground: () => WebARCameraBackground,
  WebARSessionRoot: () => WebARSessionRoot,
  WebXR: () => WebXR,
  WebXRImageTracking: () => WebXRImageTracking,
  WebXRImageTrackingModel: () => WebXRImageTrackingModel,
  WebXRPlaneTracking: () => WebXRPlaneTracking,
  WebXRTrackedImage: () => WebXRTrackedImage,
  XRControllerFollow: () => XRControllerFollow,
  XRControllerModel: () => XRControllerModel2,
  XRControllerMovement: () => XRControllerMovement,
  XRFlag: () => XRFlag,
  XRRig: () => XRRig,
  XRState: () => XRState,
  __Ignore: () => __Ignore
});

// node_modules/@needle-tools/engine/lib/engine/engine_shims.js
if (typeof globalThis !== void 0 && !("OffscreenCanvas" in globalThis)) {
  globalThis["OffscreenCanvas"] = class OffscreenCanvas {
    constructor(width, height) {
      __publicField(this, "canvas");
      this.canvas = document.createElement("canvas");
      this.canvas.width = width;
      this.canvas.height = height;
      this.canvas.convertToBlob = (type, quality) => {
        return new Promise((resolve2) => {
          this.canvas.toBlob(resolve2, type, quality);
        });
      };
      return this.canvas;
    }
  };
}

// node_modules/@needle-tools/engine/lib/engine/engine_time_utils.js
var showProgressLogs = getParam("debugprogress");
function getFormattedDate(date) {
  date = date || /* @__PURE__ */ new Date();
  const month = date.getMonth() + 1;
  const day = date.getDate();
  const hour = date.getHours();
  const min = date.getMinutes();
  const sec = date.getSeconds();
  const s_month = (month < 10 ? "0" : "") + month;
  const s_day = (day < 10 ? "0" : "") + day;
  const s_hour = (hour < 10 ? "0" : "") + hour;
  const s_min = (min < 10 ? "0" : "") + min;
  const s_sec = (sec < 10 ? "0" : "") + sec;
  return date.getFullYear() + s_month + s_day + "-" + s_hour + s_min + s_sec;
}
var Progress = class {
  /** Start a new progress reporting scope. Make sure to close it with Progress.end.
   * @param scope The scope to start progress reporting for.
   * @param options Parent scope, onProgress callback and logging. If only a string is provided, it's used as parentScope.
   * @example
   * // Manual usage:
   * Progress.start("export-usdz", undefined, (progress) => console.log("Progress: " + progress));
   * Progress.report("export-usdz", { message: "Exporting object 1", currentStep: 1, totalSteps: 3 });
   * Progress.report("export-usdz", { message: "Exporting object 2", currentStep: 2, totalSteps: 3 });
   * Progress.report("export-usdz", { message: "Exporting object 3", currentStep: 3, totalSteps: 3 });
   *
   * // Auto step usage:
   * Progress.start("export-usdz", undefined, (progress) => console.log("Progress: " + progress));
   * Progress.report("export-usdz", { message: "Exporting objects", autoStep: true, totalSteps: 3 });
   * Progress.report("export-usdz", "Exporting object 1");
   * Progress.report("export-usdz", "Exporting object 2");
   * Progress.report("export-usdz", "Exporting object 3");
   * Progress.end("export-usdz");
   *
   * // Auto step with weights:
   * Progress.start("export-usdz", undefined, (progress) => console.log("Progress: " + progress));
   * Progress.report("export-usdz", { message: "Exporting objects", autoStep: true, totalSteps: 10 });
   * Progress.report("export-usdz", { message: "Exporting object 1", autoStep: 8 }); // will advance to 80% progress
   * Progress.report("export-usdz", "Exporting object 2"); // 90%
   * Progress.report("export-usdz", "Exporting object 3"); // 100%
   *
   * // Child scopes:
   * Progress.start("export-usdz", undefined, (progress) => console.log("Progress: " + progress));
   * Progress.report("export-usdz", { message: "Overall export", autoStep: true, totalSteps: 2 });
   * Progress.start("export-usdz-objects", "export-usdz");
   * Progress.report("export-usdz-objects", { message: "Exporting objects", autoStep: true, totalSteps: 3 });
   * Progress.report("export-usdz-objects", "Exporting object 1");
   * Progress.report("export-usdz-objects", "Exporting object 2");
   * Progress.report("export-usdz-objects", "Exporting object 3");
   * Progress.end("export-usdz-objects");
   * Progress.report("export-usdz", "Exporting materials");
   * Progress.end("export-usdz");
   *
   * // Enable console logging:
   * Progress.start("export-usdz", { logTimings: true });
   */
  static start(scope, options) {
    if (typeof options === "string")
      options = { parentScope: options };
    const p = new ProgressEntry(scope, options);
    progressCache.set(scope, p);
  }
  /** Report progress for a formerly started scope.
   * @param scope The scope to report progress for.
   * @param options Options for the progress report. If a string is passed, it will be used as the message.
   * @example
   * // auto step and show a message
   * Progress.report("export-usdz", "Exporting object 1");
   * // same as above
   * Progress.report("export-usdz", { message: "Exporting object 1", autoStep: true });
   * // show the current step and total steps and implicitly calculate progress as 10%
   * Progress.report("export-usdz", { currentStep: 1, totalSteps: 10 });
   * // enable auto step mode, following calls that have autoStep true will increase currentStep automatically.
   * Progress.report("export-usdz", { totalSteps: 20, autoStep: true });
   * // show the progress as 50%
   * Progress.report("export-usdz", { progress: 0.5 });
   * // give this step a weight of 20, which changes how progress is calculated. Useful for steps that take longer and/or have child scopes.
   * Progress.report("export-usdz", { message. "Long process", autoStep: 20 });
   * // show the current step and total steps and implicitly calculate progress as 10%
   * Progress.report("export-usdz", { currentStep: 1, totalSteps: 10 });
   */
  static report(scope, options) {
    const p = progressCache.get(scope);
    if (!p) {
      console.warn("Reporting progress for non-existing scope", scope);
      return;
    }
    if (typeof options === "string")
      options = { message: options, autoStep: true };
    p.report(options);
  }
  /** End a formerly started scope. This will also report the progress as 100%.
   * @remarks Will warn if any child scope is still running (progress < 1).
  */
  static end(scope) {
    const p = progressCache.get(scope);
    if (!p)
      return;
    p.end();
    progressCache.delete(scope);
  }
};
var progressCache = /* @__PURE__ */ new Map();
var ProgressEntry = class {
  constructor(scope, options) {
    __publicField(this, "scopeLabel");
    __publicField(this, "parentScope");
    __publicField(this, "childScopes", []);
    __publicField(this, "parentDepth", 0);
    __publicField(this, "lastStep", 0);
    __publicField(this, "lastAutoStepWeight", 1);
    __publicField(this, "lastTotalSteps", 0);
    __publicField(this, "onProgress");
    __publicField(this, "showLogs", false);
    __publicField(this, "selfProgress", 0);
    __publicField(this, "totalProgress", 0);
    __publicField(this, "selfReports", 0);
    __publicField(this, "totalReports", 0);
    this.parentScope = (options == null ? void 0 : options.parentScope) ? progressCache.get(options.parentScope) : void 0;
    if (this.parentScope) {
      this.parentScope.childScopes.push(this);
      this.parentDepth = this.parentScope.parentDepth + 1;
    }
    this.scopeLabel = " ".repeat(this.parentDepth * 2) + scope;
    this.showLogs = (options == null ? void 0 : options.logTimings) ?? !!showProgressLogs;
    if (this.showLogs)
      console.time(this.scopeLabel);
    this.onProgress = options == null ? void 0 : options.onProgress;
  }
  report(options, indirect = false) {
    if (options) {
      if (options.totalSteps !== void 0)
        this.lastTotalSteps = options.totalSteps;
      if (options.currentStep !== void 0)
        this.lastStep = options.currentStep;
      if (options.autoStep !== void 0) {
        if (options.currentStep === void 0) {
          if (this.lastStep === void 0)
            this.lastStep = 0;
          const stepIncrease = typeof options.autoStep === "number" ? options.autoStep : 1;
          this.lastStep += this.lastAutoStepWeight;
          this.lastAutoStepWeight = stepIncrease;
          options.currentStep = this.lastStep;
        }
        options.totalSteps = this.lastTotalSteps;
      }
      if (options.progress !== void 0)
        this.selfProgress = options.progress;
      else if (options.currentStep !== void 0 && options.totalSteps !== void 0) {
        this.selfProgress = options.currentStep / options.totalSteps;
      }
    }
    if (this.childScopes.length > 0) {
      let avgChildProgress = 0;
      let sumChildWeight = 0;
      for (const c2 of this.childScopes) {
        avgChildProgress += c2.selfProgress;
        sumChildWeight += 1;
      }
      if (sumChildWeight > 0)
        avgChildProgress /= sumChildWeight;
      const stepWeight = this.lastAutoStepWeight / (this.lastTotalSteps ?? 1);
      this.totalProgress = this.selfProgress + avgChildProgress * stepWeight;
    } else {
      this.totalProgress = this.selfProgress;
    }
    this.selfProgress = Math.min(1, this.selfProgress);
    this.totalProgress = Math.min(1, this.totalProgress);
    let msg = (this.totalProgress * 100).toFixed(3) + "%";
    if (this.childScopes.length > 0)
      msg += " (" + (this.selfProgress * 100).toFixed(3) + "% self)";
    if (options == null ? void 0 : options.message)
      msg = options.message + " – " + msg;
    if (this.lastStep !== void 0 && this.lastTotalSteps !== void 0)
      msg = "Step " + (this.lastStep + (this.lastAutoStepWeight != 1 ? "–" + (this.lastStep + this.lastAutoStepWeight) : "") + "/" + this.lastTotalSteps) + " " + msg;
    if (indirect)
      this.totalReports++;
    else {
      this.selfReports++;
      this.totalReports++;
    }
    if (this.showLogs)
      console.timeLog(this.scopeLabel, msg);
    if (this.onProgress)
      this.onProgress(this.totalProgress);
    if (this.parentScope)
      this.parentScope.report(void 0, true);
  }
  end() {
    this.report({ progress: 1, autoStep: true }, true);
    if (this.showLogs) {
      console.timeLog(this.scopeLabel, "Total reports: " + this.totalReports, "Self reports: " + this.selfReports);
      console.timeEnd(this.scopeLabel);
    }
    let anyRunningChildProgress = false;
    for (const c2 of this.childScopes) {
      if (c2.selfProgress >= 1)
        continue;
      anyRunningChildProgress = true;
      break;
    }
    if (anyRunningChildProgress)
      console.warn("Progress end with child scopes that are still running", this);
    this.onProgress = void 0;
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/export/usdz/ThreeUSDZExporter.js
function makeNameSafe(str) {
  str = str.replace(/[^a-zA-Z0-9_]/g, "");
  if (!str.match(/^[a-zA-Z_]/))
    str = "_" + str;
  return str;
}
function makeDisplayNameSafe(str) {
  str = str.replace('"', '\\"');
  return str;
}
function findCommonAncestor(objects) {
  if (objects.length === 0)
    return null;
  const ancestors = objects.map((obj) => {
    const objAncestors = new Array();
    while (obj.parent) {
      objAncestors.unshift(obj.parent);
      obj = obj.parent;
    }
    return objAncestors;
  });
  const commonAncestor = ancestors[0].findLast((ancestor) => {
    return ancestors.every((a) => a.includes(ancestor));
  });
  return commonAncestor || null;
}
function findStructuralNodesInBoneHierarchy(bones) {
  const commonAncestor = findCommonAncestor(bones);
  const structuralNodes = /* @__PURE__ */ new Set();
  for (const bone of bones) {
    let current = bone.parent;
    while (current && current !== commonAncestor) {
      if (!bones.includes(current)) {
        structuralNodes.add(current);
      }
      current = current.parent;
    }
  }
  return structuralNodes;
}
var PositionIdentity = new Vector32();
var QuaternionIdentity = new Quaternion();
var ScaleIdentity = new Vector32(1, 1, 1);
var _USDObject = class {
  constructor(id, name, transform = null, mesh = null, material = null, camera = null, skinnedMesh = null, animations = null) {
    __publicField(this, "uuid");
    __publicField(this, "name");
    /** If no type is provided, type is chosen automatically (Xform or Mesh) */
    __publicField(this, "type");
    /** MaterialBindingAPI and SkelBindingAPI are handled automatically, extra schemas can be added here */
    __publicField(this, "extraSchemas", []);
    __publicField(this, "displayName");
    __publicField(this, "visibility");
    __publicField(this, "transform", null);
    __publicField(this, "_isDynamic");
    __publicField(this, "geometry");
    __publicField(this, "material");
    __publicField(this, "camera");
    __publicField(this, "parent");
    __publicField(this, "skinnedMesh");
    __publicField(this, "children", []);
    __publicField(this, "animations");
    __publicField(this, "_eventListeners");
    // these are for tracking which xformops are needed
    __publicField(this, "needsTranslate", false);
    __publicField(this, "needsOrient", false);
    __publicField(this, "needsScale", false);
    var _a2, _b, _c;
    this.uuid = id;
    this.name = makeNameSafe(name);
    this.displayName = name;
    if (!transform)
      this.transform = null;
    else
      this.transform = {
        position: ((_a2 = transform.position) == null ? void 0 : _a2.clone()) || null,
        quaternion: ((_b = transform.quaternion) == null ? void 0 : _b.clone()) || null,
        scale: ((_c = transform.scale) == null ? void 0 : _c.clone()) || null
      };
    this.geometry = mesh;
    this.material = material;
    this.camera = camera;
    this.parent = null;
    this.children = [];
    this._eventListeners = {};
    this._isDynamic = false;
    this.skinnedMesh = skinnedMesh;
    this.animations = animations;
  }
  // defaults to "inherited" in USD
  getMatrix() {
    if (!this.transform)
      return new Matrix4();
    const { position, quaternion, scale } = this.transform;
    const matrix = new Matrix4();
    matrix.compose(position || PositionIdentity, quaternion || QuaternionIdentity, scale || ScaleIdentity);
    return matrix;
  }
  setMatrix(value) {
    if (!value || !(value instanceof Matrix4)) {
      this.transform = null;
      return;
    }
    const position = new Vector32();
    const quaternion = new Quaternion();
    const scale = new Vector32();
    value.decompose(position, quaternion, scale);
    this.transform = { position, quaternion, scale };
  }
  /** @deprecated Use `transform`, or `getMatrix()` if you really need the matrix */
  get matrix() {
    return this.getMatrix();
  }
  /** @deprecated Use `transform`, or `setMatrix()` if you really need the matrix */
  set matrix(value) {
    this.setMatrix(value);
  }
  get isDynamic() {
    return this._isDynamic;
  }
  set isDynamic(value) {
    this._isDynamic = value;
  }
  static createEmptyParent(object) {
    const emptyParent = new _USDObject(MathUtils.generateUUID(), object.name + "_empty_" + _USDObject.USDObject_export_id++, object.transform);
    const parent = object.parent;
    if (parent)
      parent.add(emptyParent);
    emptyParent.add(object);
    emptyParent.isDynamic = true;
    object.transform = null;
    return emptyParent;
  }
  static createEmpty() {
    const empty = new _USDObject(MathUtils.generateUUID(), "Empty_" + _USDObject.USDObject_export_id++);
    empty.isDynamic = true;
    return empty;
  }
  is(obj) {
    if (!obj)
      return false;
    return this.uuid === obj.uuid;
  }
  isEmpty() {
    return !this.geometry;
  }
  clone() {
    const clone = new _USDObject(MathUtils.generateUUID(), this.name, this.transform, this.geometry, this.material);
    clone.isDynamic = this.isDynamic;
    return clone;
  }
  deepClone() {
    const clone = this.clone();
    for (const child of this.children) {
      if (!child)
        continue;
      clone.add(child.deepClone());
    }
    return clone;
  }
  getPath() {
    let current = this.parent;
    let path = this.name;
    while (current) {
      const currentName = current.parent ? current.name : current.name + "/Scenes/Scene";
      path = currentName + "/" + path;
      current = current.parent;
    }
    return "</" + path + ">";
  }
  add(child) {
    if (child.parent) {
      child.parent.remove(child);
    }
    child.parent = this;
    this.children.push(child);
  }
  remove(child) {
    const index = this.children.indexOf(child);
    if (index >= 0) {
      if (child.parent === this)
        child.parent = null;
      this.children.splice(index, 1);
    }
  }
  addEventListener(evt, listener) {
    if (!this._eventListeners[evt])
      this._eventListeners[evt] = [];
    this._eventListeners[evt].push(listener);
  }
  removeEventListener(evt, listener) {
    if (!this._eventListeners[evt])
      return;
    const index = this._eventListeners[evt].indexOf(listener);
    if (index >= 0) {
      this._eventListeners[evt].splice(index, 1);
    }
  }
  onSerialize(writer, context) {
    const listeners = this._eventListeners["serialize"];
    if (listeners)
      listeners.forEach((listener) => listener(writer, context));
  }
};
var USDObject = _USDObject;
__publicField(USDObject, "USDObject_export_id", 0);
var USDDocument = class extends USDObject {
  constructor() {
    super(void 0, "StageRoot", null, null, null, null);
    __publicField(this, "stageLength");
    this.children = [];
    this.stageLength = 200;
  }
  get isDocumentRoot() {
    return true;
  }
  get isDynamic() {
    return false;
  }
  add(child) {
    child.parent = this;
    this.children.push(child);
  }
  remove(child) {
    const index = this.children.indexOf(child);
    if (index >= 0) {
      if (child.parent === this)
        child.parent = null;
      this.children.splice(index, 1);
    }
  }
  traverse(callback, current = null) {
    if (current !== null)
      callback(current);
    else
      current = this;
    if (current.children) {
      for (const child of current.children) {
        this.traverse(callback, child);
      }
    }
  }
  findById(uuid) {
    let found = false;
    function search(current) {
      if (found)
        return void 0;
      if (current.uuid === uuid) {
        found = true;
        return current;
      }
      if (current.children) {
        for (const child of current.children) {
          if (!child)
            continue;
          const res = search(child);
          if (res)
            return res;
        }
      }
      return void 0;
    }
    return search(this);
  }
  buildHeader(_context) {
    var _a2, _b, _c;
    const animationExtension = (_a2 = _context.extensions) == null ? void 0 : _a2.find((ext) => (ext == null ? void 0 : ext.extensionName) === "animation");
    const behaviorExtension = (_b = _context.extensions) == null ? void 0 : _b.find((ext) => (ext == null ? void 0 : ext.extensionName) === "Behaviour");
    const physicsExtension = (_c = _context.extensions) == null ? void 0 : _c.find((ext) => (ext == null ? void 0 : ext.extensionName) === "Physics");
    const startTimeCode = (animationExtension == null ? void 0 : animationExtension.getStartTimeCode()) ?? 0;
    const endTimeCode = (animationExtension == null ? void 0 : animationExtension.getEndTimeCode()) ?? 0;
    let comment = "";
    const registeredClips = animationExtension == null ? void 0 : animationExtension.registeredClips;
    if (registeredClips) {
      for (const clip of registeredClips) {
        comment += `	# Animation: ${clip.name}, start=${animationExtension.getStartTimeByClip(clip) * 60}, length=${clip.duration * 60}
`;
      }
    }
    const comments = comment;
    return `#usda 1.0
(
	customLayerData = {
		string creator = "Needle Engine ${VERSION}"
		dictionary Needle = {
			bool animations = ${animationExtension ? 1 : 0}
			bool interactive = ${behaviorExtension ? 1 : 0}
			bool physics = ${physicsExtension ? 1 : 0}
			bool quickLookCompatible = ${_context.quickLookCompatible ? 1 : 0}
		}
	}
	defaultPrim = "${makeNameSafe(this.name)}"
	metersPerUnit = 1
	upAxis = "Y"
	startTimeCode = ${startTimeCode}
	endTimeCode = ${endTimeCode}
	timeCodesPerSecond = 60
	framesPerSecond = 60
	doc = """Generated by Needle Engine USDZ Exporter ${VERSION}"""
${comments}
)
`;
  }
};
var newLine = "\n";
var materialRoot = "</StageRoot/Materials";
var USDWriter = class {
  constructor() {
    __publicField(this, "str");
    __publicField(this, "indent");
    this.str = "";
    this.indent = 0;
  }
  clear() {
    this.str = "";
    this.indent = 0;
  }
  beginBlock(str = void 0, char = "{", createNewLine = true) {
    if (str !== void 0) {
      str = this.applyIndent(str);
      this.str += str;
      if (createNewLine) {
        this.str += newLine;
        this.str += this.applyIndent(char);
      } else {
        this.str += " " + char;
      }
    } else {
      this.str += this.applyIndent(char);
    }
    this.str += newLine;
    this.indent += 1;
  }
  closeBlock(char = "}") {
    this.indent -= 1;
    this.str += this.applyIndent(char) + newLine;
  }
  beginArray(str) {
    str = this.applyIndent(str + " = [");
    this.str += str;
    this.str += newLine;
    this.indent += 1;
  }
  closeArray() {
    this.indent -= 1;
    this.str += this.applyIndent("]") + newLine;
  }
  appendLine(str = "") {
    str = this.applyIndent(str);
    this.str += str;
    this.str += newLine;
  }
  toString() {
    return this.str;
  }
  applyIndent(str) {
    let indents = "";
    for (let i = 0; i < this.indent; i++)
      indents += "	";
    return indents + str;
  }
};
var USDZExporterContext = class {
  constructor(root, exporter, options) {
    __publicField(this, "root");
    __publicField(this, "exporter");
    __publicField(this, "extensions", []);
    __publicField(this, "quickLookCompatible");
    __publicField(this, "exportInvisible");
    __publicField(this, "materials");
    __publicField(this, "textures");
    __publicField(this, "files");
    __publicField(this, "document");
    __publicField(this, "output");
    __publicField(this, "animations");
    this.root = root;
    this.exporter = exporter;
    this.quickLookCompatible = options.quickLookCompatible;
    this.exportInvisible = options.exportInvisible;
    if (options.extensions)
      this.extensions = options.extensions;
    this.materials = /* @__PURE__ */ new Map();
    this.textures = {};
    this.files = {};
    this.document = new USDDocument();
    this.output = "";
    this.animations = [];
  }
};
var USDZExporterOptions = class {
  constructor() {
    __publicField(this, "ar", {
      anchoring: { type: "plane" },
      planeAnchoring: { alignment: "horizontal" }
    });
    __publicField(this, "quickLookCompatible", false);
    __publicField(this, "extensions", []);
    __publicField(this, "maxTextureSize", 4096);
    __publicField(this, "exportInvisible", false);
  }
};
var USDZExporter = class {
  constructor() {
    __publicField(this, "debug");
    __publicField(this, "pruneUnusedNodes");
    __publicField(this, "sceneAnchoringOptions", new USDZExporterOptions());
    __publicField(this, "extensions", []);
    __publicField(this, "keepObject");
    __publicField(this, "beforeWritingDocument");
    this.debug = false;
    this.pruneUnusedNodes = true;
  }
  async parse(scene, options = new USDZExporterOptions()) {
    var _a2, _b;
    options = Object.assign(new USDZExporterOptions(), options);
    this.sceneAnchoringOptions = options;
    const context = new USDZExporterContext(scene, this, options);
    this.extensions = context.extensions;
    const files = context.files;
    const modelFileName = "model.usda";
    files[modelFileName] = null;
    const materials = context.materials;
    const textures2 = context.textures;
    Progress.report("export-usdz", "Invoking onBeforeBuildDocument");
    await invokeAll(context, "onBeforeBuildDocument");
    Progress.report("export-usdz", "Done onBeforeBuildDocument");
    Progress.report("export-usdz", "Reparent bones to common ancestor");
    const reparentings = [];
    const allReparentingObjects = /* @__PURE__ */ new Set();
    scene == null ? void 0 : scene.traverse((object) => {
      if (!options.exportInvisible && !object.visible)
        return;
      if (object instanceof SkinnedMesh) {
        const bones = object.skeleton.bones;
        const commonAncestor = findCommonAncestor(bones);
        if (commonAncestor) {
          const newReparenting = { object, originalParent: object.parent, newParent: commonAncestor };
          reparentings.push(newReparenting);
          allReparentingObjects.add(newReparenting.object.uuid);
          if (newReparenting.newParent)
            allReparentingObjects.add(newReparenting.newParent.uuid);
          if (newReparenting.originalParent)
            allReparentingObjects.add(newReparenting.originalParent.uuid);
        }
      }
    });
    for (const reparenting of reparentings) {
      const { object, originalParent, newParent } = reparenting;
      newParent.add(object);
    }
    Progress.report("export-usdz", "Traversing hierarchy");
    if (scene)
      traverse(scene, context.document, context, this.keepObject);
    Progress.report("export-usdz", "Invoking onAfterBuildDocument");
    await invokeAll(context, "onAfterBuildDocument");
    const behaviorExt = context.extensions.find((ext) => ext.extensionName === "Behaviour");
    const allBehaviorTargets = (behaviorExt == null ? void 0 : behaviorExt.getAllTargetUuids()) ?? /* @__PURE__ */ new Set();
    if (this.pruneUnusedNodes) {
      const options2 = {
        allBehaviorTargets,
        debug: false,
        boneReparentings: allReparentingObjects,
        quickLookCompatible: context.quickLookCompatible
      };
      if (this.debug)
        logUsdHierarchy(context.document, "Hierarchy BEFORE pruning", options2);
      prune(context.document, options2);
      if (this.debug)
        logUsdHierarchy(context.document, "Hierarchy AFTER pruning");
    } else if (this.debug) {
      console.log("Pruning of empty nodes is disabled. This may result in a larger USDZ file.");
    }
    Progress.report("export-usdz", { message: "Parsing document", autoStep: 10 });
    await parseDocument(context, () => {
      Progress.report("export-usdz", "Building materials");
      const result = buildMaterials(materials, textures2, options.quickLookCompatible);
      return result;
    });
    Progress.report("export-usdz", "Invoking onAfterSerialize");
    await invokeAll(context, "onAfterSerialize");
    for (const reparenting of reparentings) {
      const { object, originalParent, newParent } = reparenting;
      if (originalParent)
        originalParent.add(object);
    }
    (_b = (_a2 = context.exporter) == null ? void 0 : _a2.beforeWritingDocument) == null ? void 0 : _b.call(_a2);
    const header = context.document.buildHeader(context);
    const final = header + "\n" + context.output;
    if (this.debug)
      console.log(final);
    files[modelFileName] = strToU8(final);
    context.output = "";
    Progress.report("export-usdz", { message: "Exporting textures", autoStep: 10 });
    Progress.start("export-usdz-textures", { parentScope: "export-usdz", logTimings: false });
    const decompressionRenderer = new WebGLRenderer({
      antialias: false,
      alpha: true,
      premultipliedAlpha: false,
      preserveDrawingBuffer: true
    });
    const textureCount = Object.keys(textures2).length;
    Progress.report("export-usdz-textures", { totalSteps: textureCount * 3, currentStep: 0 });
    const convertTexture = async (id) => {
      const textureData = textures2[id];
      const texture = textureData.texture;
      const isRGBA = formatsWithAlphaChannel.includes(texture.format);
      let img = {
        imageData: texture.image
      };
      Progress.report("export-usdz-textures", { message: "read back texture", autoStep: true });
      const anyColorScale = textureData.scale !== void 0 && textureData.scale.x !== 1 && textureData.scale.y !== 1 && textureData.scale.z !== 1 && textureData.scale.w !== 1;
      if (texture.isCompressedTexture || texture.isRenderTargetTexture || anyColorScale) {
        img = await decompressGpuTexture(texture, options.maxTextureSize, decompressionRenderer, textureData.scale);
      }
      Progress.report("export-usdz-textures", { message: "convert texture to canvas", autoStep: true });
      const canvas = await imageToCanvasUnpremultiplied(img.imageBitmap || img.imageData, options.maxTextureSize).catch((err) => {
        console.error("Error converting texture to canvas", texture, err);
      });
      if (canvas) {
        Progress.report("export-usdz-textures", { message: "convert canvas to blob", autoStep: true });
        const blob = await canvas.convertToBlob({ type: isRGBA ? "image/png" : "image/jpeg", quality: 0.95 });
        files[`textures/${id}.${isRGBA ? "png" : "jpg"}`] = new Uint8Array(await blob.arrayBuffer());
      } else {
        console.warn("Can`t export texture: ", texture);
      }
    };
    for (const id in textures2) {
      await convertTexture(id);
    }
    decompressionRenderer.dispose();
    Progress.end("export-usdz-textures");
    let offset = 0;
    for (const filename in files) {
      const file = files[filename];
      const headerSize = 34 + filename.length;
      offset += headerSize;
      const offsetMod64 = offset & 63;
      if (offsetMod64 !== 4) {
        const padLength = 64 - offsetMod64;
        const padding = new Uint8Array(padLength);
        files[filename] = [file, { extra: { 12345: padding } }];
      }
      offset = file.length;
    }
    Progress.report("export-usdz", "zip archive");
    return zipSync(files, { level: 0 });
  }
};
function traverse(object, parentModel, context, keepObject) {
  var _a2;
  if (!context.exportInvisible && !object.visible)
    return;
  let model = void 0;
  let geometry = void 0;
  let material = void 0;
  const transform = { position: object.position, quaternion: object.quaternion, scale: object.scale };
  if (object.position.x === 0 && object.position.y === 0 && object.position.z === 0)
    transform.position = null;
  if (object.quaternion.x === 0 && object.quaternion.y === 0 && object.quaternion.z === 0 && object.quaternion.w === 1)
    transform.quaternion = null;
  if (object.scale.x === 1 && object.scale.y === 1 && object.scale.z === 1)
    transform.scale = null;
  if (object instanceof Mesh || object instanceof SkinnedMesh) {
    geometry = object.geometry;
    material = object.material;
  }
  if (keepObject && !keepObject(object)) {
    geometry = void 0;
    material = void 0;
  }
  if ((object instanceof Mesh || object instanceof SkinnedMesh) && material && (material instanceof MeshStandardMaterial || material instanceof MeshBasicMaterial || material instanceof Material && material.type === "MeshLineMaterial")) {
    const name = getObjectId(object);
    const skinnedMeshObject = object instanceof SkinnedMesh ? object : null;
    model = new USDObject(object.uuid, name, transform, geometry, material, void 0, skinnedMeshObject, object.animations);
  } else if (object instanceof PerspectiveCamera || object instanceof OrthographicCamera) {
    const name = getObjectId(object);
    model = new USDObject(object.uuid, name, transform, void 0, void 0, object);
  } else {
    const name = getObjectId(object);
    model = new USDObject(object.uuid, name, transform, void 0, void 0, void 0, void 0, object.animations);
  }
  if (model) {
    model.displayName = ((_a2 = object.userData) == null ? void 0 : _a2.name) || object.name;
    model.visibility = object.visible ? void 0 : "invisible";
    if (parentModel) {
      parentModel.add(model);
    }
    parentModel = model;
    if (context.extensions) {
      for (const ext of context.extensions) {
        if (ext.onExportObject)
          ext.onExportObject.call(ext, object, model, context);
      }
    }
  } else {
    const name = getObjectId(object);
    const empty = new USDObject(object.uuid, name, { position: object.position, quaternion: object.quaternion, scale: object.scale });
    if (parentModel) {
      parentModel.add(empty);
    }
    parentModel = empty;
  }
  for (const ch of object.children) {
    traverse(ch, parentModel, context, keepObject);
  }
}
function logUsdHierarchy(object, prefix2, ...extraLogObjects) {
  const item = {};
  let itemCount = 0;
  function collectItem(object2, current) {
    itemCount++;
    let name = object2.displayName || object2.name;
    name += " (" + object2.uuid + ")";
    const hasAny = object2.geometry || object2.material || object2.camera || object2.skinnedMesh;
    if (hasAny) {
      name += " (" + (object2.geometry ? "geo, " : "") + (object2.material ? "mat, " : "") + (object2.camera ? "cam, " : "") + (object2.skinnedMesh ? "skin, " : "") + ")";
    }
    current[name] = {};
    const props = { object: object2 };
    if (object2.material)
      props["mat"] = true;
    if (object2.geometry)
      props["geo"] = true;
    if (object2.camera)
      props["cam"] = true;
    if (object2.skinnedMesh)
      props["skin"] = true;
    current[name]._self = props;
    for (const child of object2.children) {
      if (child) {
        collectItem(child, current[name]);
      }
    }
  }
  collectItem(object, item);
  console.log(prefix2 + " (" + itemCount + " nodes)", item, ...extraLogObjects);
}
function prune(object, options) {
  var _a2;
  let allChildsWerePruned = true;
  const prunedChilds = new Array();
  const keptChilds = new Array();
  if (object.children.length === 0) {
    allChildsWerePruned = true;
  } else {
    const childs = [...object.children];
    for (const child of childs) {
      if (child) {
        const childWasPruned = prune(child, options);
        if (options.debug) {
          if (childWasPruned)
            prunedChilds.push(child);
          else
            keptChilds.push(child);
        }
        allChildsWerePruned = allChildsWerePruned && childWasPruned;
      }
    }
  }
  const isBehaviorSourceOrTarget = options.allBehaviorTargets.has(object.uuid);
  const isVisible2 = object.geometry || object.material || object.camera && !options.quickLookCompatible || object.skinnedMesh || false;
  const isBoneReparenting = options.boneReparentings.has(object.uuid);
  const canBePruned = allChildsWerePruned && !isBehaviorSourceOrTarget && !isVisible2 && !isBoneReparenting;
  if (canBePruned) {
    if (options.debug)
      console.log("Pruned object:", (object.displayName || object.name) + " (" + object.uuid + ")", {
        isVisible: isVisible2,
        isBehaviorSourceOrTarget,
        allChildsWerePruned,
        isBoneReparenting,
        object,
        prunedChilds,
        keptChilds
      });
    (_a2 = object.parent) == null ? void 0 : _a2.remove(object);
  } else {
    if (options.debug)
      console.log("Kept object:", (object.displayName || object.name) + " (" + object.uuid + ")", {
        isVisible: isVisible2,
        isBehaviorSourceOrTarget,
        allChildsWerePruned,
        isBoneReparenting,
        object,
        prunedChilds,
        keptChilds
      });
  }
  return canBePruned;
}
async function parseDocument(context, afterStageRoot) {
  Progress.start("export-usdz-resources", "export-usdz");
  const resources = [];
  for (const child of context.document.children) {
    addResources(child, context, resources);
  }
  const total = resources.length;
  for (let i = 0; i < total; i++) {
    Progress.report("export-usdz-resources", { totalSteps: total, currentStep: i });
    await new Promise((resolve2, _reject) => {
      resources[i]();
      resolve2();
    });
  }
  Progress.end("export-usdz-resources");
  const writer = new USDWriter();
  const arAnchoringOptions = context.exporter.sceneAnchoringOptions.ar;
  writer.beginBlock(`def Xform "${context.document.name}"`);
  writer.beginBlock(`def Scope "Scenes" (
		kind = "sceneLibrary"
	)`);
  writer.beginBlock(`def Xform "Scene"`, "(", false);
  writer.appendLine(`apiSchemas = ["Preliminary_AnchoringAPI"]`);
  writer.appendLine(`customData = {`);
  writer.appendLine(`	bool preliminary_collidesWithEnvironment = 0`);
  writer.appendLine(`	string sceneName = "Scene"`);
  writer.appendLine(`}`);
  writer.appendLine(`sceneName = "Scene"`);
  writer.closeBlock(")");
  writer.beginBlock();
  writer.appendLine(`token preliminary:anchoring:type = "${arAnchoringOptions.anchoring.type}"`);
  if (arAnchoringOptions.anchoring.type === "plane")
    writer.appendLine(`token preliminary:planeAnchoring:alignment = "${arAnchoringOptions.planeAnchoring.alignment}"`);
  if (arAnchoringOptions.anchoring.type === "image")
    writer.appendLine(`rel preliminary:imageAnchoring:referenceImage = </${context.document.name}/Scenes/Scene/AnchoringReferenceImage>`);
  writer.appendLine();
  const count = (object) => {
    if (!object)
      return 0;
    let total2 = 1;
    for (const child of object.children)
      total2 += count(child);
    return total2;
  };
  const totalXformCount = count(context.document);
  Progress.start("export-usdz-xforms", "export-usdz");
  Progress.report("export-usdz-xforms", { totalSteps: totalXformCount, currentStep: 1 });
  for (const child of context.document.children) {
    buildXform(child, writer, context);
  }
  Progress.end("export-usdz-xforms");
  Progress.report("export-usdz", "invoke onAfterHierarchy");
  invokeAll(context, "onAfterHierarchy", writer);
  writer.closeBlock();
  writer.closeBlock();
  writer.appendLine(afterStageRoot());
  writer.closeBlock();
  Progress.report("export-usdz", "write to string");
  context.output += writer.toString();
}
function addResources(object, context, resources) {
  if (!object)
    return;
  const geometry = object.geometry;
  const material = object.material;
  if (geometry) {
    if (material && ("isMeshStandardMaterial" in material && material.isMeshStandardMaterial || "isMeshBasicMaterial" in material && material.isMeshBasicMaterial || material.type === "MeshLineMaterial")) {
      const geometryFileName = "geometries/" + getGeometryName(geometry, object.name) + ".usda";
      if (!(geometryFileName in context.files)) {
        const action = () => {
          var _a2, _b;
          const meshObject = buildMeshObject(geometry, (_b = (_a2 = object.skinnedMesh) == null ? void 0 : _a2.skeleton) == null ? void 0 : _b.bones, context.quickLookCompatible);
          context.files[geometryFileName] = buildUSDFileAsString(meshObject, context);
        };
        resources.push(action);
      }
    } else {
      console.warn("NeedleUSDZExporter: Unsupported material type (USDZ only supports MeshStandardMaterial)", material == null ? void 0 : material.name);
    }
  }
  if (material) {
    if (!(material.uuid in context.materials)) {
      context.materials[material.uuid] = material;
    }
  }
  for (const ch of object.children) {
    addResources(ch, context, resources);
  }
}
async function invokeAll(context, name, writer = null) {
  if (context.extensions) {
    for (const ext of context.extensions) {
      if (!ext)
        continue;
      if (typeof ext[name] === "function") {
        const method = ext[name];
        const res = method.call(ext, context, writer);
        if (res instanceof Promise) {
          await res;
        }
      }
    }
  }
}
var _renderer = null;
var renderTarget = null;
var fullscreenQuadGeometry;
var fullscreenQuadMaterial;
var fullscreenQuad;
async function decompressGpuTexture(texture, maxTextureSize = Infinity, renderer = null, colorScale = void 0) {
  if (!fullscreenQuadGeometry)
    fullscreenQuadGeometry = new PlaneGeometry(2, 2, 1, 1);
  if (!fullscreenQuadMaterial)
    fullscreenQuadMaterial = new ShaderMaterial({
      uniforms: {
        blitTexture: new Uniform$1(texture),
        flipY: new Uniform$1(false),
        scale: new Uniform$1(new Vector4(1, 1, 1, 1))
      },
      vertexShader: `
            varying vec2 vUv;
			uniform bool flipY;
            void main(){
                vUv = uv;
				if (flipY)
					vUv.y = 1. - vUv.y;
                gl_Position = vec4(position.xy * 1.0,0.,.999999);
            }`,
      fragmentShader: `
            uniform sampler2D blitTexture;
			uniform vec4 scale; 
            varying vec2 vUv;

            void main(){ 
                gl_FragColor = vec4(vUv.xy, 0, 1);
                
                #ifdef IS_SRGB
                gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );
                #else
                gl_FragColor = texture2D( blitTexture, vUv);
                #endif
				
				gl_FragColor.rgba *= scale.rgba;
            }`
    });
  const uniforms = fullscreenQuadMaterial.uniforms;
  uniforms.blitTexture.value = texture;
  uniforms.flipY.value = false;
  uniforms.scale.value = new Vector4(1, 1, 1, 1);
  if (colorScale !== void 0)
    uniforms.scale.value.copy(colorScale);
  fullscreenQuadMaterial.defines.IS_SRGB = texture.colorSpace == SRGBColorSpace;
  fullscreenQuadMaterial.needsUpdate = true;
  if (!fullscreenQuad) {
    fullscreenQuad = new Mesh(fullscreenQuadGeometry, fullscreenQuadMaterial);
    fullscreenQuad.frustumCulled = false;
  }
  const _camera2 = new PerspectiveCamera();
  const _scene = new Scene();
  _scene.add(fullscreenQuad);
  if (!renderer) {
    renderer = _renderer = new WebGLRenderer({ antialias: false, alpha: true, premultipliedAlpha: false, preserveDrawingBuffer: true });
  }
  const width = Math.min(texture.image.width, maxTextureSize);
  const height = Math.min(texture.image.height, maxTextureSize);
  if (renderTarget && (renderTarget.width !== width || renderTarget.height !== height)) {
    renderTarget.dispose();
    renderTarget = null;
  }
  if (!renderTarget) {
    renderTarget = new WebGLRenderTarget(width, height, { format: RGBAFormat, type: UnsignedByteType, minFilter: LinearFilter, magFilter: LinearFilter });
  }
  renderer.setRenderTarget(renderTarget);
  renderer.setSize(width, height);
  renderer.clear();
  renderer.render(_scene, _camera2);
  if (_renderer) {
    _renderer.dispose();
    _renderer = null;
  }
  const buffer2 = new Uint8ClampedArray(renderTarget.width * renderTarget.height * 4);
  renderer.readRenderTargetPixels(renderTarget, 0, 0, renderTarget.width, renderTarget.height, buffer2);
  const imageData = new ImageData(buffer2, renderTarget.width, renderTarget.height, void 0);
  const bmp = await createImageBitmap(imageData, { premultiplyAlpha: "none" });
  return {
    imageData,
    imageBitmap: bmp
  };
}
function isImageBitmap2(image) {
  return typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== "undefined" && image instanceof OffscreenCanvas || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap;
}
async function imageToCanvasUnpremultiplied(image, maxTextureSize = 4096) {
  const scale = maxTextureSize / Math.max(image.width, image.height);
  const width = image.width * Math.min(1, scale);
  const height = image.height * Math.min(1, scale);
  const canvas = new OffscreenCanvas(width, height);
  const settings = { premultiplyAlpha: "none" };
  if (image.width !== width)
    settings.resizeWidth = width;
  if (image.height !== height)
    settings.resizeHeight = height;
  const imageBitmap = await createImageBitmap(image, settings);
  const ctx = canvas.getContext("bitmaprenderer");
  if (ctx) {
    ctx.transferFromImageBitmap(imageBitmap);
  }
  return canvas;
}
async function imageToCanvas(image, color2 = void 0, flipY = false, maxTextureSize = 4096) {
  if (isImageBitmap2(image)) {
    const scale = maxTextureSize / Math.max(image.width, image.height);
    const canvas = new OffscreenCanvas(image.width * Math.min(1, scale), image.height * Math.min(1, scale));
    const context = canvas.getContext("2d", { alpha: true, premultipliedAlpha: false });
    if (!context)
      throw new Error("Could not get canvas 2D context");
    if (flipY === true) {
      context.translate(0, canvas.height);
      context.scale(1, -1);
    }
    context.drawImage(image, 0, 0, canvas.width, canvas.height);
    if (color2 !== void 0) {
      const r = color2.x;
      const g3 = color2.y;
      const b = color2.z;
      const a = color2.w;
      const imagedata = context.getImageData(0, 0, canvas.width, canvas.height);
      const data = imagedata.data;
      for (let i = 0; i < data.length; i += 4) {
        data[i + 0] = data[i + 0] * r;
        data[i + 1] = data[i + 1] * g3;
        data[i + 2] = data[i + 2] * b;
        data[i + 3] = data[i + 3] * a;
      }
      context.putImageData(imagedata, 0, 0);
    }
    return canvas;
  } else {
    throw new Error("NeedleUSDZExporter: No valid image data found. Unable to process texture.");
  }
}
var PRECISION = 7;
function buildHeader() {
  return `#usda 1.0
(
    customLayerData = {
        string creator = "Needle Engine USDZExporter"
    }
    metersPerUnit = 1
    upAxis = "Y"
)
`;
}
function buildUSDFileAsString(dataToInsert, _context) {
  let output = buildHeader();
  output += dataToInsert;
  return strToU8(output);
}
function getObjectId(object) {
  return object.name.replace(/[-<>\(\)\[\]§$%&\/\\\=\?\,\;]/g, "") + "_" + object.id;
}
function getBoneName(bone) {
  return makeNameSafe(bone.name || "bone_" + bone.uuid);
}
function getGeometryName(geometry, _fallbackName) {
  return makeNameSafe(geometry.name || "Geometry") + "_" + geometry.id;
}
function getMaterialName(material) {
  return makeNameSafe(material.name || "Material") + "_" + material.id;
}
function getPathToSkeleton(bone, assumedRoot) {
  let path = getBoneName(bone);
  let current = bone.parent;
  while (current && current !== assumedRoot) {
    path = getBoneName(current) + "/" + path;
    current = current.parent;
  }
  return path;
}
function buildXform(model, writer, context) {
  var _a2;
  if (model == null)
    return;
  Progress.report("export-usdz-xforms", { message: "buildXform " + model.displayName || model.name, autoStep: true });
  const transform = model.transform;
  const geometry = model.geometry;
  const material = model.material;
  const camera = model.camera;
  const name = model.name;
  if (model.animations) {
    for (const animation of model.animations) {
      context.animations.push(animation);
    }
  }
  const isSkinnedMesh = geometry && geometry.isBufferGeometry && geometry.attributes.skinIndex !== void 0 && geometry.attributes.skinIndex.count > 0;
  const objType = isSkinnedMesh ? "SkelRoot" : "Xform";
  const _apiSchemas = new Array();
  const isUnlitDisplayColor = material && material instanceof MeshBasicMaterial && material.color && material.color.r === 1 && material.color.g === 1 && material.color.b === 1 && !material.map && material.opacity === 1 && (geometry == null ? void 0 : geometry.attributes.color);
  if ((geometry == null ? void 0 : geometry.attributes.color) && !isUnlitDisplayColor) {
    console.warn("NeedleUSDZExporter: Geometry has vertex colors. Vertex colors will only be shown in QuickLook for unlit materials with white color and no texture. Otherwise, they will be ignored.", model.displayName);
  }
  writer.appendLine();
  if (geometry) {
    writer.beginBlock(`def ${objType} "${name}"`, "(", false);
    if (context.quickLookCompatible && material && material.side === DoubleSide && !isSkinnedMesh)
      writer.appendLine(`prepend references = @./geometries/${getGeometryName(geometry, name)}.usda@</Geometry_doubleSided>`);
    else
      writer.appendLine(`prepend references = @./geometries/${getGeometryName(geometry, name)}.usda@</Geometry>`);
    if (!isUnlitDisplayColor)
      _apiSchemas.push("MaterialBindingAPI");
    if (isSkinnedMesh)
      _apiSchemas.push("SkelBindingAPI");
  } else if (camera && !context.quickLookCompatible)
    writer.beginBlock(`def Camera "${name}"`, "(", false);
  else if (model.type !== void 0)
    writer.beginBlock(`def ${model.type} "${name}"`);
  else
    writer.beginBlock(`def Xform "${name}"`, "(", false);
  if (model.type === void 0) {
    if ((_a2 = model.extraSchemas) == null ? void 0 : _a2.length)
      _apiSchemas.push(...model.extraSchemas);
    if (_apiSchemas.length)
      writer.appendLine(`prepend apiSchemas = [${_apiSchemas.map((s) => `"${s}"`).join(", ")}]`);
  }
  if (model.displayName)
    writer.appendLine(`displayName = "${makeDisplayNameSafe(model.displayName)}"`);
  if (camera || model.type === void 0) {
    writer.closeBlock(")");
    writer.beginBlock();
  }
  if (geometry && material) {
    if (!isUnlitDisplayColor) {
      const materialName = getMaterialName(material);
      writer.appendLine(`rel material:binding = </StageRoot/Materials/${materialName}>`);
    }
    if (!context.quickLookCompatible && material.side === DoubleSide) {
      writer.beginBlock(`over "Geometry" `);
      writer.appendLine(`uniform bool doubleSided = 1`);
      writer.closeBlock();
    }
  }
  let haveWrittenAnyXformOps = false;
  if (isSkinnedMesh) {
    writer.appendLine(`rel skel:skeleton = <Rig>`);
    writer.appendLine(`rel skel:animationSource = <Rig/_anim>`);
    haveWrittenAnyXformOps = false;
  } else if (model.type === void 0) {
    if (transform) {
      haveWrittenAnyXformOps = haveWrittenAnyXformOps || (transform.position !== null || transform.quaternion !== null || transform.scale !== null);
      if (transform.position) {
        model.needsTranslate = true;
        writer.appendLine(`double3 xformOp:translate = (${fn(transform.position.x)}, ${fn(transform.position.y)}, ${fn(transform.position.z)})`);
      }
      if (transform.quaternion) {
        model.needsOrient = true;
        writer.appendLine(`quatf xformOp:orient = (${fn(transform.quaternion.w)}, ${fn(transform.quaternion.x)}, ${fn(transform.quaternion.y)}, ${fn(transform.quaternion.z)})`);
      }
      if (transform.scale) {
        model.needsScale = true;
        writer.appendLine(`double3 xformOp:scale = (${fn(transform.scale.x)}, ${fn(transform.scale.y)}, ${fn(transform.scale.z)})`);
      }
    }
  }
  if (model.visibility !== void 0)
    writer.appendLine(`token visibility = "${model.visibility}"`);
  if (camera && !context.quickLookCompatible) {
    if ("isOrthographicCamera" in camera && camera.isOrthographicCamera) {
      writer.appendLine(`float2 clippingRange = (${camera.near}, ${camera.far})`);
      writer.appendLine(`float horizontalAperture = ${((Math.abs(camera.left) + Math.abs(camera.right)) * 10).toPrecision(PRECISION)}`);
      writer.appendLine(`float verticalAperture = ${((Math.abs(camera.top) + Math.abs(camera.bottom)) * 10).toPrecision(PRECISION)}`);
      writer.appendLine('token projection = "orthographic"');
    } else if ("isPerspectiveCamera" in camera && camera.isPerspectiveCamera) {
      writer.appendLine(`float2 clippingRange = (${camera.near.toPrecision(PRECISION)}, ${camera.far.toPrecision(PRECISION)})`);
      writer.appendLine(`float focalLength = ${camera.getFocalLength().toPrecision(PRECISION)}`);
      writer.appendLine(`float focusDistance = ${camera.focus.toPrecision(PRECISION)}`);
      writer.appendLine(`float horizontalAperture = ${camera.getFilmWidth().toPrecision(PRECISION)}`);
      writer.appendLine('token projection = "perspective"');
      writer.appendLine(`float verticalAperture = ${camera.getFilmHeight().toPrecision(PRECISION)}`);
    }
  }
  if (model.onSerialize) {
    model.onSerialize(writer, context);
  }
  if (model.type === void 0) {
    const ops = new Array();
    if (model.needsTranslate)
      ops.push('"xformOp:translate"');
    if (model.needsOrient)
      ops.push('"xformOp:orient"');
    if (model.needsScale)
      ops.push('"xformOp:scale"');
    if (ops.length)
      writer.appendLine(`uniform token[] xformOpOrder = [${ops.join(", ")}]`);
  }
  if (model.children) {
    writer.appendLine();
    for (const ch of model.children) {
      buildXform(ch, writer, context);
    }
  }
  writer.closeBlock();
}
function fn(num) {
  return Number.isInteger(num) ? num.toString() : num.toFixed(10);
}
function buildMatrix(matrix) {
  const array = matrix.elements;
  return `( ${buildMatrixRow(array, 0)}, ${buildMatrixRow(array, 4)}, ${buildMatrixRow(array, 8)}, ${buildMatrixRow(array, 12)} )`;
}
function buildMatrixRow(array, offset) {
  return `(${fn(array[offset + 0])}, ${fn(array[offset + 1])}, ${fn(array[offset + 2])}, ${fn(array[offset + 3])})`;
}
function buildMeshObject(geometry, bonesArray = [], quickLookCompatible = true) {
  const mesh = buildMesh(geometry, bonesArray, quickLookCompatible);
  return `
def "Geometry"
${mesh}
`;
}
function buildMesh(geometry, bones = [], quickLookCompatible = true) {
  const name = "Geometry";
  const attributes = geometry.attributes;
  const count = attributes.position.count;
  const hasBones = bones && bones.length > 0;
  const sortedBones = [];
  const indexMapping = [];
  let sortedSkinIndex = new Array();
  let sortedSkinIndexAttribute = attributes.skinIndex;
  let bonesArray = "";
  if (hasBones) {
    const uuidsFound = [];
    for (const bone of bones) {
      if (bone.parent.type !== "Bone") {
        sortedBones.push({ bone, index: bones.indexOf(bone) });
        uuidsFound.push(bone.uuid);
      }
    }
    while (uuidsFound.length < bones.length) {
      for (const sortedBone of sortedBones) {
        const children = sortedBone.bone.children;
        for (const childBone of children) {
          if (uuidsFound.indexOf(childBone.uuid) === -1 && bones.indexOf(childBone) !== -1) {
            sortedBones.push({ bone: childBone, index: bones.indexOf(childBone) });
            uuidsFound.push(childBone.uuid);
          }
        }
      }
    }
    for (const structuralNode of findStructuralNodesInBoneHierarchy(bones)) {
      sortedBones.push({ bone: structuralNode, index: sortedBones.length });
    }
    const assumedRoot = sortedBones[0].bone.parent;
    sortedBones.sort((a, b) => getPathToSkeleton(a.bone, assumedRoot) > getPathToSkeleton(b.bone, assumedRoot) ? 1 : -1);
    bonesArray = sortedBones.map((x2) => '"' + getPathToSkeleton(x2.bone, assumedRoot) + '"').join(", ");
    for (const i in sortedBones) {
      indexMapping[sortedBones[i].index] = parseInt(i);
    }
    const skinIndex = attributes.skinIndex;
    sortedSkinIndex = new Array();
    for (let i = 0; i < skinIndex.count; i++) {
      const x2 = skinIndex.getX(i);
      const y = skinIndex.getY(i);
      const z = skinIndex.getZ(i);
      const w = skinIndex.getW(i);
      sortedSkinIndex.push(indexMapping[x2], indexMapping[y], indexMapping[z], indexMapping[w]);
    }
    sortedSkinIndexAttribute = new BufferAttribute2(new Uint16Array(sortedSkinIndex), 4);
  }
  const isSkinnedMesh = attributes.skinWeight && attributes.skinIndex;
  return `
{	
    def Mesh "${name}" ${isSkinnedMesh ? `(
        prepend apiSchemas = ["SkelBindingAPI"]
    )` : ""}
    {
        int[] faceVertexCounts = [${buildMeshVertexCount(geometry)}]
        int[] faceVertexIndices = [${buildMeshVertexIndices(geometry)}]
		${attributes.normal || quickLookCompatible ? (
    // in QuickLook, normals are required, otherwise double-sided rendering doesn't work.
    `normal3f[] normals = [${buildVector3Array(attributes.normal, count)}] (
            interpolation = "vertex"
        )`
  ) : ""}
        point3f[] points = [${buildVector3Array(attributes.position, count)}]
        ${attributes.uv ? `texCoord2f[] primvars:st = [${buildVector2Array(attributes.uv, count, true)}] (
            interpolation = "vertex"
        )` : ""}
		${attributes.uv1 ? buildCustomAttributeAccessor("st1", attributes.uv1) : ""}
		${attributes.uv2 ? buildCustomAttributeAccessor("st2", attributes.uv2) : ""}
		${attributes.uv3 ? buildCustomAttributeAccessor("st3", attributes.uv3) : ""}
		${isSkinnedMesh ? `matrix4d primvars:skel:geomBindTransform = ( (1, 0, 0, 0), (0, 1, 0, 0), (0, 0, 1, 0), (0, 0, 0, 1) ) (
				elementSize = 1
				interpolation = "constant"
			)` : ""}
		${attributes.skinIndex ? `int[] primvars:skel:jointIndices = [${buildVector4Array(sortedSkinIndexAttribute, true)}] (
			elementSize = 4
			interpolation = "vertex"
		)` : ""}
		${attributes.skinWeight ? `float[] primvars:skel:jointWeights = [${buildVector4Array(attributes.skinWeight)}] (
			elementSize = 4
			interpolation = "vertex"
		)` : ""}
		${attributes.color ? `color3f[] primvars:displayColor = [${buildVector3Array(attributes.color, count)}] (
			interpolation = "vertex"
		)` : ""}
        uniform token subdivisionScheme = "none"
    }
}
${quickLookCompatible ? `
# This is a workaround for QuickLook/RealityKit not supporting the doubleSided attribute. We're adding a second
# geometry definition here, that uses the same mesh data but appends extra faces with reversed winding order.
def "${name}_doubleSided" (
	prepend references = </Geometry>
)
{
	over "Geometry"
	{
		int[] faceVertexCounts = [${buildMeshVertexCount(geometry) + ", " + buildMeshVertexCount(geometry)}]
		int[] faceVertexIndices = [${buildMeshVertexIndices(geometry) + ", " + buildMeshVertexIndices(geometry, true)}]
	}
}
` : ""}
`;
}
function buildMeshVertexCount(geometry) {
  const count = geometry.index !== null ? geometry.index.count : geometry.attributes.position.count;
  return Array(Math.floor(count / 3)).fill(3).join(", ");
}
function buildMeshVertexIndices(geometry, reverseWinding = false) {
  const index = geometry.index;
  const array = [];
  if (index !== null) {
    for (let i = 0; i < index.count; i++) {
      let val = i;
      if (reverseWinding)
        val = i % 3 === 0 ? i + 2 : i % 3 === 2 ? i - 2 : i;
      array.push(index.getX(val));
    }
  } else {
    const length = geometry.attributes.position.count;
    for (let i = 0; i < length; i++) {
      let val = i;
      if (reverseWinding)
        val = i % 3 === 0 ? i + 2 : i % 3 === 2 ? i - 2 : i;
      array.push(val);
    }
  }
  return array.join(", ");
}
function buildCustomAttributeAccessor(primvarName, attribute) {
  const count = attribute.itemSize;
  switch (count) {
    case 2:
      return `texCoord2f[] primvars:${primvarName} = [${buildVector2Array(attribute, count, true)}] (
				interpolation = "vertex"
			)`;
    case 3:
      return `texCoord3f[] primvars:${primvarName} = [${buildVector3Array(attribute, count)}] (
				interpolation = "vertex"
			)`;
    case 4:
      return `double4[] primvars:${primvarName} = [${buildVector4Array2(attribute, count)}] (
				interpolation = "vertex"
			)`;
    default:
      console.warn("USDZExporter: Attribute with " + count + " components are currently not supported. Results may be undefined for " + primvarName + ".");
      return "";
  }
}
function buildVector3Array(attribute, count) {
  if (attribute === void 0) {
    console.warn("USDZExporter: A mesh attribute is missing and will be set with placeholder data. The result may look incorrect.");
    return Array(count).fill("(0, 0, 1)").join(", ");
  }
  const array = [];
  for (let i = 0; i < attribute.count; i++) {
    const x2 = attribute.getX(i);
    const y = attribute.getY(i);
    const z = attribute.getZ(i);
    array.push(`(${x2.toPrecision(PRECISION)}, ${y.toPrecision(PRECISION)}, ${z.toPrecision(PRECISION)})`);
  }
  return array.join(", ");
}
function buildVector4Array2(attribute, count) {
  if (attribute === void 0) {
    console.warn("USDZExporter: Attribute is missing. Results may be undefined.");
    return Array(count).fill("(0, 0, 0, 0)").join(", ");
  }
  const array = [];
  for (let i = 0; i < attribute.count; i++) {
    const x2 = attribute.getX(i);
    const y = attribute.getY(i);
    const z = attribute.getZ(i) || 0;
    const w = attribute.getW(i) || 0;
    array.push(`(${x2.toPrecision(PRECISION)}, ${y.toPrecision(PRECISION)}, ${z.toPrecision(PRECISION)}, ${w.toPrecision(PRECISION)})`);
  }
  return array.join(", ");
}
function buildVector4Array(attribute, ints = false) {
  const array = [];
  for (let i = 0; i < attribute.count; i++) {
    const x2 = attribute.getX(i);
    const y = attribute.getY(i);
    const z = attribute.getZ(i);
    const w = attribute.getW(i);
    array.push(`${ints ? x2 : x2.toPrecision(PRECISION)}`);
    array.push(`${ints ? y : y.toPrecision(PRECISION)}`);
    array.push(`${ints ? z : z.toPrecision(PRECISION)}`);
    array.push(`${ints ? w : w.toPrecision(PRECISION)}`);
  }
  return array.join(", ");
}
function buildVector2Array(attribute, count, flipY = false) {
  if (attribute === void 0) {
    console.warn("USDZExporter: UVs missing.");
    return Array(count).fill("(0, 0)").join(", ");
  }
  const array = [];
  for (let i = 0; i < attribute.count; i++) {
    const x2 = attribute.getX(i);
    let y = attribute.getY(i);
    if (flipY)
      y = 1 - y;
    array.push(`(${x2.toPrecision(PRECISION)}, ${y.toPrecision(PRECISION)})`);
  }
  return array.join(", ");
}
function buildMaterials(materials, textures2, quickLookCompatible = false) {
  const array = [];
  for (const uuid in materials) {
    const material = materials[uuid];
    array.push(buildMaterial(material, textures2, quickLookCompatible));
  }
  return `
	def "Materials"
    {
${array.join("")}
    }`;
}
function buildMaterial(material, textures2, quickLookCompatible = false) {
  var _a2, _b, _c;
  const materialName = getMaterialName(material);
  console.log(material);
  const isShadowCatcherMaterial = material.colorWrite === false || (((_a2 = material.userData) == null ? void 0 : _a2.isShadowCatcherMaterial) || ((_b = material.userData) == null ? void 0 : _b.isLightBlendMaterial));
  if (isShadowCatcherMaterial) {
    const mode = material.userData.isLightBlendMaterial || material.userData.isShadowCatcherMaterial ? "ND_realitykit_shadowreceiver_surfaceshader" : "ND_realitykit_occlusion_surfaceshader";
    return `

		def Material "${materialName}" ${material.name ? `(
			displayName = "${material.name}"
		)` : ""}
		{
			token outputs:mtlx:surface.connect = ${materialRoot}/${materialName}/Occlusion.outputs:out>

			def Shader "Occlusion"
			{
				uniform token info:id = "${mode}"
				token outputs:out
			}
		}`;
  }
  const pad = "                ";
  const inputs = [];
  const samplers = [];
  const usedUVChannels = /* @__PURE__ */ new Set();
  function texName(tex) {
    var _a3;
    return makeNameSafe(tex.name) + "_" + (((_a3 = tex.source) == null ? void 0 : _a3.id) ?? tex.id);
  }
  function buildTexture(texture, mapType, color2 = void 0, opacity = void 0) {
    const name = texName(texture);
    const id = name + (opacity !== void 0 && opacity !== 1 ? "_" + opacity : "");
    const opacityIsAppliedToTextureAndNotAsScale = quickLookCompatible && opacity !== void 0 && opacity !== 1;
    const scaleToApply = opacityIsAppliedToTextureAndNotAsScale ? new Vector4(1, 1, 1, opacity) : void 0;
    if (opacity === void 0)
      opacity = 1;
    if (opacityIsAppliedToTextureAndNotAsScale)
      opacity = 1;
    if (scaleToApply && scaleToApply.w <= 0.05)
      scaleToApply.w = 0.05;
    textures2[id] = { texture, scale: scaleToApply };
    const uv = texture.channel > 0 ? "st" + texture.channel : "st";
    usedUVChannels.add(texture.channel);
    const isRGBA = formatsWithAlphaChannel.includes(texture.format);
    const WRAPPINGS = {
      1e3: "repeat",
      1001: "clamp",
      1002: "mirror"
      // MirroredRepeatWrapping
    };
    const repeat = texture.repeat.clone();
    const offset = texture.offset.clone();
    const rotation = texture.rotation;
    const xRotationOffset = Math.sin(rotation);
    const yRotationOffset = Math.cos(rotation);
    offset.y = 1 - offset.y - repeat.y;
    if (quickLookCompatible) {
      if (repeat.x === 0)
        repeat.x = 1e-4;
      if (repeat.y === 0)
        repeat.y = 1e-4;
      offset.x = offset.x / repeat.x;
      offset.y = offset.y / repeat.y;
      offset.x += xRotationOffset / repeat.x;
      offset.y += yRotationOffset - 1;
    } else {
      offset.x += xRotationOffset * repeat.x;
      offset.y += (1 - yRotationOffset) * repeat.y;
    }
    const needsTextureTransform = repeat.x != 1 || repeat.y != 1 || offset.x != 0 || offset.y != 0 || rotation != 0;
    const textureTransformInput = `${materialRoot}/${materialName}/${"uvReader_" + uv}.outputs:result>`;
    const textureTransformOutput = `${materialRoot}/${materialName}/Transform2d_${mapType}.outputs:result>`;
    const needsTextureScale = mapType !== "normal" && (color2 && (color2.r !== 1 || color2.g !== 1 || color2.b !== 1 || opacity !== 1)) || false;
    const needsNormalScaleAndBias = mapType === "normal";
    const normalScale = material instanceof MeshStandardMaterial ? material.normalScale ? material.normalScale.x * 2 : 2 : 2;
    const normalScaleValueString = normalScale.toFixed(PRECISION);
    const normalBiasString = (-1 * (normalScale / 2)).toFixed(PRECISION);
    const normalBiasZString = (1 - normalScale).toFixed(PRECISION);
    return `
			${needsTextureTransform ? `def Shader "Transform2d_${mapType}" (
				sdrMetadata = {
					string role = "math"
				}
			)
			{
				uniform token info:id = "UsdTransform2d"
				float2 inputs:in.connect = ${textureTransformInput}
				float2 inputs:scale = ${buildVector2(repeat)}
				float2 inputs:translation = ${buildVector2(offset)}
				float inputs:rotation = ${(rotation / Math.PI * 180).toFixed(PRECISION)}
				float2 outputs:result
			}
			` : ""}
			def Shader "${name}_${mapType}"
			{
				uniform token info:id = "UsdUVTexture"
				asset inputs:file = @textures/${id}.${isRGBA ? "png" : "jpg"}@
				token inputs:sourceColorSpace = "${texture.colorSpace === "srgb" ? "sRGB" : "raw"}"
				float2 inputs:st.connect = ${needsTextureTransform ? textureTransformOutput : textureTransformInput}
				${needsTextureScale ? `
				float4 inputs:scale = (${color2 ? color2.r + ", " + color2.g + ", " + color2.b : "1, 1, 1"}, ${opacity})
				` : ``}
				${needsNormalScaleAndBias ? `
				float4 inputs:scale = (${normalScaleValueString}, ${normalScaleValueString}, ${normalScaleValueString}, 1)
				float4 inputs:bias = (${normalBiasString}, ${normalBiasString}, ${normalBiasZString}, 0)
				` : ``}
				token inputs:wrapS = "${WRAPPINGS[texture.wrapS]}"
				token inputs:wrapT = "${WRAPPINGS[texture.wrapT]}"
				float outputs:r
				float outputs:g
				float outputs:b
				float3 outputs:rgb
				${material.transparent || material.alphaTest > 0 ? "float outputs:a" : ""}
			}`;
  }
  let effectiveOpacity = material.transparent || material.alphaTest ? material.opacity : 1;
  let haveConnectedOpacity = false;
  let haveConnectedOpacityThreshold = false;
  if (material instanceof MeshPhysicalMaterial && material.transmission !== void 0) {
    effectiveOpacity *= 1 - material.transmission * (1 - material.roughness * 0.5);
  }
  if (material.map) {
    inputs.push(`${pad}color3f inputs:diffuseColor.connect = ${materialRoot}/${materialName}/${texName(material.map)}_diffuse.outputs:rgb>`);
    if (material instanceof MeshBasicMaterial && material.transparent && material.alphaTest == 0 && quickLookCompatible) {
      inputs.push(`${pad}float inputs:opacity.connect = ${materialRoot}/${materialName}/${texName(material.map)}_diffuse.outputs:a>`);
      haveConnectedOpacity = true;
      inputs.push(`${pad}float inputs:opacityThreshold = ${1e-10}`);
      haveConnectedOpacityThreshold = true;
    } else if (material.transparent) {
      inputs.push(`${pad}float inputs:opacity.connect = ${materialRoot}/${materialName}/${texName(material.map)}_diffuse.outputs:a>`);
      haveConnectedOpacity = true;
    } else if (material.alphaTest > 0) {
      inputs.push(`${pad}float inputs:opacity.connect = ${materialRoot}/${materialName}/${texName(material.map)}_diffuse.outputs:a>`);
      haveConnectedOpacity = true;
      inputs.push(`${pad}float inputs:opacityThreshold = ${material.alphaTest}`);
      haveConnectedOpacityThreshold = true;
    }
    samplers.push(buildTexture(material.map, "diffuse", material.color, effectiveOpacity));
  } else {
    inputs.push(`${pad}color3f inputs:diffuseColor = ${buildColor(material.color)}`);
  }
  if (material.alphaHash && quickLookCompatible) {
    if (haveConnectedOpacityThreshold) {
      console.warn("Opacity threshold for " + material.name + " was already connected. Skipping alphaHash opacity threshold.");
    } else {
      inputs.push(`${pad}float inputs:opacityThreshold = 0.0000000001`);
      haveConnectedOpacityThreshold = true;
    }
  }
  if (material.aoMap) {
    inputs.push(`${pad}float inputs:occlusion.connect = ${materialRoot}/${materialName}/${texName(material.aoMap)}_occlusion.outputs:r>`);
    samplers.push(buildTexture(material.aoMap, "occlusion"));
  }
  if (material.alphaMap) {
    inputs.push(`${pad}float inputs:opacity.connect = ${materialRoot}/${materialName}/${texName(material.alphaMap)}_opacity.outputs:r>`);
    inputs.push(`${pad}float inputs:opacityThreshold = 0.0000000001`);
    haveConnectedOpacity = true;
    haveConnectedOpacityThreshold = true;
    samplers.push(buildTexture(material.alphaMap, "opacity", new Color(1, 1, 1), effectiveOpacity));
  } else {
    if (haveConnectedOpacity) {
      console.warn("Opacity for " + material.name + " was already connected. Skipping default opacity.");
    } else {
      inputs.push(`${pad}float inputs:opacity = ${effectiveOpacity}`);
      haveConnectedOpacity = true;
    }
    if (material.alphaTest > 0) {
      if (haveConnectedOpacityThreshold) {
        console.warn("Opacity threshold for " + material.name + " was already connected. Skipping default opacity threshold.");
      } else {
        inputs.push(`${pad}float inputs:opacityThreshold = ${material.alphaTest}`);
        haveConnectedOpacityThreshold = true;
      }
    }
  }
  if (material instanceof MeshStandardMaterial) {
    if (material.emissiveMap) {
      inputs.push(`${pad}color3f inputs:emissiveColor.connect = ${materialRoot}/${materialName}/${texName(material.emissiveMap)}_emissive.outputs:rgb>`);
      const color2 = material.emissive.clone();
      color2.multiplyScalar(material.emissiveIntensity);
      samplers.push(buildTexture(material.emissiveMap, "emissive", color2));
    } else if (((_c = material.emissive) == null ? void 0 : _c.getHex()) > 0) {
      const color2 = material.emissive.clone();
      color2.multiplyScalar(material.emissiveIntensity);
      inputs.push(`${pad}color3f inputs:emissiveColor = ${buildColor(color2)}`);
    } else {
    }
    if (material.normalMap) {
      inputs.push(`${pad}normal3f inputs:normal.connect = ${materialRoot}/${materialName}/${texName(material.normalMap)}_normal.outputs:rgb>`);
      samplers.push(buildTexture(material.normalMap, "normal"));
    }
    if (material.roughnessMap && material.roughness === 1) {
      inputs.push(`${pad}float inputs:roughness.connect = ${materialRoot}/${materialName}/${texName(material.roughnessMap)}_roughness.outputs:g>`);
      samplers.push(buildTexture(material.roughnessMap, "roughness"));
    } else {
      inputs.push(`${pad}float inputs:roughness = ${material.roughness !== void 0 ? material.roughness : 1}`);
    }
    if (material.metalnessMap && material.metalness === 1) {
      inputs.push(`${pad}float inputs:metallic.connect = ${materialRoot}/${materialName}/${texName(material.metalnessMap)}_metallic.outputs:b>`);
      samplers.push(buildTexture(material.metalnessMap, "metallic"));
    } else {
      inputs.push(`${pad}float inputs:metallic = ${material.metalness !== void 0 ? material.metalness : 0}`);
    }
  }
  if (material instanceof MeshPhysicalMaterial) {
    inputs.push(`${pad}float inputs:clearcoat = ${material.clearcoat}`);
    inputs.push(`${pad}float inputs:clearcoatRoughness = ${material.clearcoatRoughness}`);
    inputs.push(`${pad}float inputs:ior = ${material.ior}`);
    if (!material.transparent && !(material.alphaTest > 0) && material.transmissionMap) {
      inputs.push(`${pad}float inputs:opacity.connect = ${materialRoot}/${materialName}/${texName(material.transmissionMap)}_transmission.outputs:r>`);
      samplers.push(buildTexture(material.transmissionMap, "transmission"));
    }
  }
  if (usedUVChannels.size > 2) {
    console.warn("USDZExporter: Material " + material.name + " uses more than 2 UV channels. Currently, only UV0 and UV1 are supported.");
  } else if (usedUVChannels.size === 2) {
    if (!usedUVChannels.has(0) || !usedUVChannels.has(1)) {
      console.warn("USDZExporter: Material " + material.name + " uses UV channels other than 0 and 1. Currently, only UV0 and UV1 are supported.");
    }
  }
  return `

		def Material "${materialName}" ${material.name ? `(
			displayName = "${makeDisplayNameSafe(material.name)}"
		)` : ""}
		{
			token outputs:surface.connect = ${materialRoot}/${materialName}/PreviewSurface.outputs:surface>

			def Shader "PreviewSurface"
			{
				uniform token info:id = "UsdPreviewSurface"
${inputs.join("\n")}
				int inputs:useSpecularWorkflow = ${material instanceof MeshBasicMaterial ? "1" : "0"}
				token outputs:surface
			}
${samplers.length > 0 ? `
${usedUVChannels.has(0) ? `
			def Shader "uvReader_st"
			{
				uniform token info:id = "UsdPrimvarReader_float2"
				token inputs:varname = "st"
				float2 inputs:fallback = (0.0, 0.0)
				float2 outputs:result
			}
` : ""}
${usedUVChannels.has(1) ? `
			def Shader "uvReader_st1"
			{
				uniform token info:id = "UsdPrimvarReader_float2"
				token inputs:varname = "st1"
				float2 inputs:fallback = (0.0, 0.0)
				float2 outputs:result
			}
` : ""}
${samplers.join("\n")}` : ""}
		}`;
}
function buildColor(color2) {
  return `(${color2.r}, ${color2.g}, ${color2.b})`;
}
function buildVector2(vector) {
  return `(${vector.x}, ${vector.y})`;
}
var formatsWithAlphaChannel = [
  // uncompressed formats with alpha channel
  1023,
  // compressed formats with alpha channel
  33777,
  33778,
  33779,
  35842,
  35843,
  37496,
  37808,
  37809,
  37810,
  37811,
  37812,
  37813,
  37814,
  37815,
  37816,
  37817,
  37818,
  37819,
  37820,
  37821,
  36492
  // RGBA_BPTC_Format
];

// node_modules/@needle-tools/engine/lib/engine-components/export/usdz/extensions/behavior/BehavioursBuilder.js
var debug34 = getParam("debugusdz");
var _BehaviorModel = class {
  constructor(id, trigger, action) {
    __publicField(this, "id");
    __publicField(this, "trigger");
    __publicField(this, "action");
    __publicField(this, "exclusive", false);
    this.id = "Behavior_" + makeNameSafe(id) + "_" + _BehaviorModel.global_id++;
    this.trigger = trigger;
    this.action = action;
  }
  makeExclusive(exclusive) {
    this.exclusive = exclusive;
    return this;
  }
  writeTo(_ext, document2, writer) {
    if (!this.trigger || !this.action)
      return;
    writer.beginBlock(`def Preliminary_Behavior "${this.id}"`);
    let triggerString = "";
    if (Array.isArray(this.trigger)) {
      triggerString = "[";
      for (let i = 0; i < this.trigger.length; i++) {
        const tr = this.trigger[i];
        triggerString += "<" + tr.id + ">";
        if (i + 1 < this.trigger.length)
          triggerString += ", ";
      }
      triggerString += "]";
    } else
      triggerString = `<${this.trigger.id}>`;
    writer.appendLine(`rel triggers = ${triggerString}`);
    writer.appendLine(`rel actions = <${this.action.id}>`);
    writer.appendLine(`uniform bool exclusive = ${this.exclusive ? 1 : 0}`);
    writer.appendLine();
    if (Array.isArray(this.trigger)) {
      for (const trigger of this.trigger) {
        trigger.writeTo(document2, writer);
        writer.appendLine();
      }
    } else
      this.trigger.writeTo(document2, writer);
    writer.appendLine();
    this.action.writeTo(document2, writer);
    writer.closeBlock();
  }
};
var BehaviorModel = _BehaviorModel;
__publicField(BehaviorModel, "global_id", 0);
var addedStrings = /* @__PURE__ */ new Set();
function resolve(targetObject, document2) {
  var _a2, _b;
  let result = "";
  if (Array.isArray(targetObject)) {
    addedStrings.clear();
    let str = "[ ";
    for (let i = 0; i < targetObject.length; i++) {
      let obj = targetObject[i];
      if (!obj) {
        console.warn("Invalid target object in behavior", targetObject + ". Is the object exported?");
        continue;
      }
      if (typeof obj === "string") {
        if (addedStrings.has(obj))
          continue;
        str += obj;
        addedStrings.add(obj);
      } else if (typeof obj === "object") {
        if (obj.isObject3D) {
          obj = document2.findById(obj.uuid);
          if (!obj) {
            console.warn("Invalid target object in behavior", targetObject + ". Is the object exported?");
            continue;
          }
        }
        const res = (_a2 = obj.getPath) == null ? void 0 : _a2.call(obj);
        if (addedStrings.has(res))
          continue;
        str += res;
        addedStrings.add(res);
      }
      if (i + 1 < targetObject.length)
        str += ", ";
    }
    str += " ]";
    result = str;
    addedStrings.clear();
  } else if (typeof targetObject === "object") {
    const sourceObject = targetObject;
    if (sourceObject.isObject3D) {
      targetObject = document2.findById(sourceObject.uuid);
    }
    if (!targetObject) {
      console.error("Invalid target object in behavior, the target object is likely missing from USDZ export. Is the object exported?", sourceObject);
      throw new Error(`Invalid target object in behavior, the target object is likely missing from USDZ export. Please report a bug. uuid: ${sourceObject.uuid}.`);
    }
    result = (_b = targetObject.getPath) == null ? void 0 : _b.call(targetObject);
  }
  return result;
}
var _TriggerModel = class {
  constructor(targetId, id) {
    __publicField(this, "id");
    __publicField(this, "targetId");
    __publicField(this, "tokenId");
    __publicField(this, "type");
    __publicField(this, "distance");
    if (targetId)
      this.targetId = targetId;
    if (id)
      this.id = id;
    else
      this.id = "Trigger_" + _TriggerModel.global_id++;
  }
  writeTo(document2, writer) {
    writer.beginBlock(`def Preliminary_Trigger "${this.id}"`);
    if (this.targetId) {
      if (typeof this.targetId !== "string")
        this.targetId = resolve(this.targetId, document2);
      writer.appendLine(`rel affectedObjects = ` + this.targetId);
    }
    if (this.tokenId)
      writer.appendLine(`token info:id = "${this.tokenId}"`);
    if (this.type)
      writer.appendLine(`token type = "${this.type}"`);
    if (typeof this.distance === "number")
      writer.appendLine(`double distance = ${this.distance}`);
    writer.closeBlock();
  }
};
var TriggerModel = _TriggerModel;
__publicField(TriggerModel, "global_id", 0);
function addInputTargetComponent(model, options = { direct: true, indirect: true }) {
  const empty = USDObject.createEmpty();
  empty.name = "InputTarget_" + empty.name;
  empty.displayName = void 0;
  empty.type = "RealityKitComponent";
  empty.onSerialize = (writer) => {
    writer.appendLine("bool allowsDirectInput = " + (options.direct ? 1 : 0));
    writer.appendLine("bool allowsIndirectInput = " + (options.indirect ? 1 : 0));
    writer.appendLine('uniform token info:id = "RealityKit.InputTarget"');
  };
  model.add(empty);
}
var TriggerBuilder = class {
  static sceneStartTrigger() {
    const trigger = new TriggerModel();
    trigger.targetId = void 0;
    trigger.tokenId = "SceneTransition";
    trigger.type = "enter";
    return trigger;
  }
  /** Trigger that fires when an object has been tapped/clicked.
   * @param targetObject The object or list of objects that can be interacted with.
   * @param inputMode Input Mode (direct and/or indirect). Only available for USDObject targets. Only supported on Vision OS at the moment. */
  static tapTrigger(targetObject, inputMode = { direct: true, indirect: true }) {
    const trigger = new TriggerModel(targetObject);
    if (Array.isArray(targetObject) && targetObject.length > 1) {
      for (const obj of targetObject) {
        if (!(obj instanceof USDObject))
          continue;
        addInputTargetComponent(obj, inputMode);
      }
    } else {
      if (targetObject instanceof USDObject) {
        addInputTargetComponent(targetObject, inputMode);
      }
    }
    trigger.tokenId = "TapGesture";
    return trigger;
  }
  static isTapTrigger(trigger) {
    return (trigger == null ? void 0 : trigger.tokenId) === "TapGesture";
  }
  static proximityToCameraTrigger(targetObject, distance) {
    const trigger = new TriggerModel(targetObject);
    trigger.tokenId = "ProximityToCamera";
    trigger.distance = distance;
    return trigger;
  }
};
var GroupActionModel = class {
  constructor(id, actions) {
    __publicField(this, "id");
    __publicField(this, "actions");
    __publicField(this, "loops", 0);
    __publicField(this, "performCount", 1);
    __publicField(this, "type", "serial");
    __publicField(this, "multiplePerformOperation");
    this.id = id;
    this.actions = actions;
  }
  static getId() {
    return this.global_id++;
  }
  addAction(el) {
    this.actions.push(el);
    return this;
  }
  makeParallel() {
    this.type = "parallel";
    return this;
  }
  makeSequence() {
    this.type = "serial";
    return this;
  }
  makeLooping() {
    this.loops = 1;
    this.performCount = 0;
    return this;
  }
  makeRepeat(count) {
    this.performCount = count;
    return this;
  }
  writeTo(document2, writer) {
    writer.beginBlock(`def Preliminary_Action "${this.id}"`);
    writer.beginArray("rel actions");
    for (const act of this.actions) {
      if (!act)
        continue;
      const isLast = act === this.actions[this.actions.length - 1];
      writer.appendLine("<" + act.id + ">" + (isLast ? "" : ", "));
    }
    writer.closeArray();
    writer.appendLine();
    writer.appendLine(`token info:id = "Group"`);
    writer.appendLine(`bool loops = ${this.loops}`);
    writer.appendLine(`int performCount = ${this.loops > 0 ? 0 : Math.max(0, this.performCount)}`);
    writer.appendLine(`token type = "${this.type}"`);
    if (typeof this.multiplePerformOperation === "string") {
      writer.appendLine(`token multiplePerformOperation = "${this.multiplePerformOperation}"`);
    }
    writer.appendLine();
    for (const act of this.actions) {
      if (!act)
        continue;
      act.writeTo(document2, writer);
      writer.appendLine();
    }
    writer.closeBlock();
  }
};
__publicField(GroupActionModel, "global_id", 0);
var _ActionModel = class {
  constructor(affectedObjects, id) {
    __publicField(this, "id");
    __publicField(this, "tokenId");
    __publicField(this, "affectedObjects");
    __publicField(this, "easeType");
    __publicField(this, "motionType");
    __publicField(this, "duration");
    __publicField(this, "moveDistance");
    __publicField(this, "style");
    __publicField(this, "type");
    // combined types of different actions
    __publicField(this, "front");
    __publicField(this, "up");
    __publicField(this, "start");
    __publicField(this, "animationSpeed");
    __publicField(this, "reversed");
    __publicField(this, "pingPong");
    __publicField(this, "xFormTarget");
    __publicField(this, "audio");
    __publicField(this, "gain");
    __publicField(this, "auralMode");
    __publicField(this, "multiplePerformOperation");
    __publicField(this, "velocity");
    // extra info written as comment at the beginning of the action
    __publicField(this, "comment");
    __publicField(this, "animationName");
    if (affectedObjects)
      this.affectedObjects = affectedObjects;
    if (id)
      this.id = id;
    else
      this.id = "Action";
    this.id += "_" + _ActionModel.global_id++;
  }
  clone() {
    const copy = new _ActionModel();
    const id = copy.id;
    Object.assign(copy, this);
    copy.id = id;
    return copy;
  }
  writeTo(document2, writer) {
    writer.beginBlock(`def Preliminary_Action "${this.id}"`);
    if (this.comment)
      writer.appendLine(`# ${this.comment}`);
    if (this.affectedObjects) {
      if (typeof this.affectedObjects !== "string")
        this.affectedObjects = resolve(this.affectedObjects, document2);
      writer.appendLine("rel affectedObjects = " + this.affectedObjects);
    }
    if (typeof this.duration === "number") {
      if (typeof this.animationSpeed === "number" && this.animationSpeed !== 1) {
        writer.appendLine(`double duration = ${this.duration / this.animationSpeed} `);
      } else {
        writer.appendLine(`double duration = ${this.duration} `);
      }
    }
    if (this.easeType)
      writer.appendLine(`token easeType = "${this.easeType}"`);
    if (this.tokenId)
      writer.appendLine(`token info:id = "${this.tokenId}"`);
    if (this.tokenId === "ChangeScene")
      writer.appendLine(`rel scene = </StageRoot/Scenes/Scene>`);
    if (this.motionType !== void 0)
      writer.appendLine(`token motionType = "${this.motionType}"`);
    if (typeof this.moveDistance === "number")
      writer.appendLine(`double moveDistance = ${this.moveDistance} `);
    if (this.style)
      writer.appendLine(`token style = "${this.style}"`);
    if (this.type)
      writer.appendLine(`token type = "${this.type}"`);
    if (this.front)
      writer.appendLine(`vector3d front = (${this.front.x}, ${this.front.y}, ${this.front.z})`);
    if (this.up)
      writer.appendLine(`vector3d upVector = (${this.up.x}, ${this.up.y}, ${this.up.z})`);
    if (typeof this.start === "number") {
      writer.appendLine(`double start = ${this.start} `);
    }
    if (typeof this.animationSpeed === "number") {
      writer.appendLine(`double animationSpeed = ${this.animationSpeed.toFixed(2)} `);
    }
    if (typeof this.reversed === "boolean") {
      writer.appendLine(`bool reversed = ${this.reversed}`);
    }
    if (typeof this.pingPong === "boolean") {
      writer.appendLine(`bool reverses = ${this.pingPong}`);
    }
    if (this.xFormTarget) {
      if (typeof this.xFormTarget !== "string")
        this.xFormTarget = resolve(this.xFormTarget, document2);
      writer.appendLine(`rel xformTarget = ${this.xFormTarget}`);
    }
    if (typeof this.audio === "string") {
      writer.appendLine(`asset audio = @${this.audio}@`);
    }
    if (typeof this.gain === "number") {
      writer.appendLine(`double gain = ${this.gain}`);
    }
    if (typeof this.auralMode === "string") {
      writer.appendLine(`token auralMode = "${this.auralMode}"`);
    }
    if (typeof this.multiplePerformOperation === "string") {
      writer.appendLine(`token multiplePerformOperation = "${this.multiplePerformOperation}"`);
    }
    if (typeof this.velocity === "object") {
      writer.appendLine(`vector3d velocity = (${this.velocity.x}, ${this.velocity.y}, ${this.velocity.z})`);
    }
    writer.closeBlock();
  }
};
var ActionModel = _ActionModel;
__publicField(ActionModel, "global_id", 0);
var Vec3 = class {
  constructor(x2, y, z) {
    __publicField(this, "x", 0);
    __publicField(this, "y", 0);
    __publicField(this, "z", 0);
    this.x = x2;
    this.y = y;
    this.z = z;
  }
  static get up() {
    return new Vec3(0, 1, 0);
  }
  static get right() {
    return new Vec3(1, 0, 0);
  }
  static get forward() {
    return new Vec3(0, 0, 1);
  }
  static get back() {
    return new Vec3(0, 0, -1);
  }
  static get zero() {
    return new Vec3(0, 0, 0);
  }
};
var ActionBuilder = class {
  static sequence(...params) {
    const group = new GroupActionModel("Group_" + GroupActionModel.getId(), params);
    return group.makeSequence();
  }
  static parallel(...params) {
    const group = new GroupActionModel("Group_" + GroupActionModel.getId(), params);
    return group.makeParallel();
  }
  static fadeAction(targetObject, duration, show) {
    const act = new ActionModel(targetObject);
    act.tokenId = "Visibility";
    act.type = show ? "show" : "hide";
    act.duration = duration;
    act.style = "basic";
    act.motionType = "none";
    act.moveDistance = 0;
    act.easeType = "none";
    return act;
  }
  /**
   * creates an action that plays an animation
   * @param start offset in seconds!
   * @param duration in seconds! 0 means play to end
   */
  static startAnimationAction(targetObject, anim, reversed = false, pingPong = false) {
    const act = new ActionModel(targetObject);
    act.tokenId = "StartAnimation";
    const start = anim.start;
    const duration = anim.duration;
    const animationSpeed = anim.speed;
    const animationName = anim.clipName;
    act.comment = `Animation: ${animationName}, start=${start * 60}, length=${duration * 60}, end=${(start + duration) * 60}`;
    act.animationName = animationName;
    act.start = start;
    act.duration = duration;
    act.animationSpeed = animationSpeed;
    act.reversed = reversed;
    act.pingPong = pingPong;
    act.multiplePerformOperation = "allow";
    if (reversed) {
      act.start -= duration;
    }
    if (pingPong) {
      act.pingPong = false;
      const back = act.clone();
      back.reversed = !reversed;
      back.start = act.start;
      if (back.reversed) {
        back.start -= duration;
      }
      const group = ActionBuilder.sequence(act, back);
      return group;
    }
    return act;
  }
  static waitAction(duration) {
    const act = new ActionModel();
    act.tokenId = "Wait";
    act.duration = duration;
    act.motionType = void 0;
    return act;
  }
  static lookAtCameraAction(targets, duration, front, up2) {
    const act = new ActionModel(targets);
    act.tokenId = "LookAtCamera";
    act.duration = duration === void 0 ? 9999999999999 : duration;
    act.front = front ?? Vec3.forward;
    act.up = up2 ?? Vec3.up;
    return act;
  }
  static emphasize(targets, duration, motionType = "bounce", moveDistance = 1, style = "basic") {
    const act = new ActionModel(targets);
    act.tokenId = "Emphasize";
    act.duration = duration;
    act.style = style ?? "basic";
    act.motionType = motionType;
    act.moveDistance = moveDistance;
    return act;
  }
  static transformAction(targets, transformTarget, duration, transformType, easeType = "inout") {
    const act = new ActionModel(targets);
    act.tokenId = "Transform";
    act.duration = duration;
    act.duration = Math.max(1e-6, duration);
    act.type = transformType;
    act.easeType = duration > 0 ? easeType : "none";
    if (Array.isArray(transformTarget)) {
      console.error("Transform target must not be an array", transformTarget);
    }
    act.xFormTarget = transformTarget;
    return act;
  }
  static playAudioAction(targets, audio, type = "play", gain = 1, auralMode = "spatial") {
    const act = new ActionModel(targets);
    act.tokenId = "Audio";
    act.type = type;
    act.audio = audio;
    act.gain = gain;
    act.auralMode = auralMode;
    act.multiplePerformOperation = "allow";
    return act;
  }
  // Supported only on VisionOS, Preliminary Behaviours can affect RealityKit physics as well
  static impulseAction(targets, velocity) {
    const act = new ActionModel(targets);
    act.tokenId = "Impulse";
    act.velocity = velocity;
    return act;
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/export/usdz/extensions/behavior/Actions.js
var DocumentAction = class {
  constructor(obj) {
    __publicField(this, "object");
    __publicField(this, "model");
    this.object = obj;
  }
  get id() {
    return this.object.uuid;
  }
  apply(document2) {
    if (!this.model) {
      this.model = document2.findById(this.object.uuid);
      if (!this.model) {
        console.error("could not find model with id " + this.object.uuid);
        return;
      }
    }
    this.onApply(document2);
  }
};
var VariantAction = class extends DocumentAction {
  constructor(obj, matrix, material, geometry) {
    super(obj);
    __publicField(this, "matrix");
    __publicField(this, "material");
    __publicField(this, "geometry");
    __publicField(this, "_enableAction");
    __publicField(this, "_disableAction");
    this.matrix = matrix;
    this.material = material;
    this.geometry = geometry;
  }
  onApply(_) {
    var _a2, _b;
    const model = this.model;
    if (!model)
      return;
    if (!((_a2 = model.parent) == null ? void 0 : _a2.isDynamic)) {
      USDObject.createEmptyParent(model);
    }
    const clone = model.clone();
    if (this.matrix)
      clone.setMatrix(this.matrix);
    if (this.material)
      clone.material = this.material;
    if (this.geometry)
      clone.geometry = this.geometry;
    (_b = model.parent) == null ? void 0 : _b.add(clone);
  }
  enable() {
    if (this._enableAction)
      return this._enableAction;
    this._enableAction = ActionBuilder.fadeAction(this.object, 0, true);
    ;
    return this._enableAction;
  }
  disable() {
    if (this._disableAction)
      return this._disableAction;
    this._disableAction = ActionBuilder.fadeAction(this.object, 0, false);
    ;
    return this._disableAction;
  }
};
var ActionCollection = class {
  constructor(actions) {
    __publicField(this, "actions");
    __publicField(this, "sortedActions");
    this.actions = [...actions];
  }
  // organize is called once when getting an action for the first time
  // the sorted actions are baked then and adding new actions will not be added anymore
  organize() {
    this.sortedActions = {};
    for (const action of this.actions) {
      const id = action.id;
      if (!this.sortedActions[id]) {
        this.sortedActions[id] = [];
      }
      this.sortedActions[id].push(action);
    }
  }
  /** returns all document actions affecting the object passed in */
  getActions(obj) {
    if (!this.sortedActions)
      this.organize();
    return this.sortedActions[obj.uuid];
  }
};

// node_modules/@needle-tools/engine/lib/engine/engine_serialization_decorator.js
var serializeable = function(type) {
  return serializable(type);
};
var serializable = function(type) {
  if (type === void 0)
    type = null;
  if (!Array.isArray(type)) {
    type = setNullForPrimitiveTypes(type);
  } else {
    for (let i = 0; i < type.length; i++) {
      const entry = type[i];
      type[i] = setNullForPrimitiveTypes(entry);
    }
  }
  return function(_target, _propertyKey) {
    if (typeof _propertyKey !== "string") {
      _propertyKey = _propertyKey.name;
    }
    if (!Object.getOwnPropertyDescriptor(_target, "$serializedTypes"))
      _target["$serializedTypes"] = {};
    const types = _target["$serializedTypes"] = _target["$serializedTypes"] || {};
    types[_propertyKey] = type;
  };
};
function setNullForPrimitiveTypes(type) {
  var _a2, _b;
  switch ((_b = (_a2 = type == null ? void 0 : type.prototype) == null ? void 0 : _a2.constructor) == null ? void 0 : _b.name) {
    case "Number":
    case "String":
    case "Boolean":
      return null;
  }
  return type;
}

// node_modules/@needle-tools/engine/lib/engine-components/Component.js
var Component_exports = {};
__export(Component_exports, {
  Behaviour: () => Component2,
  Component: () => Component2,
  GameObject: () => GameObject
});
var GameObject = class extends Object3D {
  constructor() {
    super(...arguments);
    __publicField(this, "guid");
  }
  static isDestroyed(go) {
    return isDestroyed(go);
  }
  static setActive(go, active, processStart2 = true) {
    if (!go)
      return;
    setActive(go, active);
    updateIsActive(go);
    if (active && processStart2)
      processStart(Context.Current, go);
  }
  /** If the object is active (same as go.visible) */
  static isActiveSelf(go) {
    return isActiveSelf(go);
  }
  /** If the object is active in the hierarchy (e.g. if any parent is invisible or not in the scene it will be false)
   * @param go object to check
  */
  static isActiveInHierarchy(go) {
    return isActiveInHierarchy(go);
  }
  static markAsInstancedRendered(go, instanced) {
    markAsInstancedRendered(go, instanced);
  }
  static isUsingInstancing(instance) {
    return isUsingInstancing(instance);
  }
  /** Run a callback for all components of the provided type on the provided object and its children (if recursive is true)
   * @param instance object to run the method on
   * @param cb callback to run on each component, "return undefined;" to continue and "return <anything>;" to break the loop
   * @param recursive if true, the method will be run on all children as well
   * @returns the last return value of the callback
   */
  static foreachComponent(instance, cb, recursive = true) {
    return foreachComponent(instance, cb, recursive);
  }
  /** Creates a new instance of the provided object. The new instance will be created on all connected clients
   * @param instance object to instantiate
   * @param opts options for the instantiation
   */
  static instantiateSynced(instance, opts) {
    if (!instance)
      return null;
    return syncInstantiate(instance, opts);
  }
  /** Creates a new instance of the provided object (like cloning it including all components and children)
   * @param instance object to instantiate
   * @param opts options for the instantiation (e.g. with what parent, position, etc.)
  */
  static instantiate(instance, opts = null) {
    return instantiate(instance, opts);
  }
  /** Destroys a object on all connected clients (if you are in a networked session)
   * @param instance object to destroy
  */
  static destroySynced(instance, context, recursive = true) {
    if (!instance)
      return;
    const go = instance;
    context = context ?? Context.Current;
    syncDestroy(go, context.connection, recursive);
  }
  /** Destroys a object
   * @param instance object to destroy
   * @param recursive if true, all children will be destroyed as well. true by default
   */
  static destroy(instance, recursive = true) {
    return destroy(instance, recursive);
  }
  /**
   * Add an object to parent and also ensure all components are being registered
   */
  static add(instance, parent, context) {
    if (!instance || !parent)
      return;
    if (instance === parent) {
      console.warn("Can not add object to self", instance);
      return;
    }
    if (!context) {
      context = Context.Current;
    }
    parent.add(instance);
    setActive(instance, true);
    updateIsActive(instance);
    if (context) {
      GameObject.foreachComponent(instance, (comp) => {
        addScriptToArrays(comp, context);
        if (comp.__internalDidAwakeAndStart)
          return;
        if (context.new_script_start.includes(comp) === false) {
          context.new_script_start.push(comp);
        }
      }, true);
    } else {
      console.warn("Missing context");
    }
  }
  /**
   * Removes the object from its parent and deactivates all of its components
   */
  static remove(instance) {
    var _a2;
    if (!instance)
      return;
    (_a2 = instance.parent) == null ? void 0 : _a2.remove(instance);
    setActive(instance, false);
    updateIsActive(instance);
    GameObject.foreachComponent(instance, (comp) => {
      processRemoveFromScene(comp);
    }, true);
  }
  /** Invokes a method on all components including children (if a method with that name exists) */
  static invokeOnChildren(go, functionName, ...args) {
    this.invoke(go, functionName, true, args);
  }
  /** Invokes a method on all components that have a method matching the provided name
   * @param go object to invoke the method on all components
   * @param functionName name of the method to invoke
   */
  static invoke(go, functionName, children = false, ...args) {
    if (!go)
      return;
    this.foreachComponent(go, (c2) => {
      const fn2 = c2[functionName];
      if (fn2 && typeof fn2 === "function") {
        fn2 == null ? void 0 : fn2.call(c2, ...args);
      }
    }, children);
  }
  /** @deprecated use `addComponent` */
  // eslint-disable-next-line deprecation/deprecation
  static addNewComponent(go, type, init, callAwake = true) {
    return addComponent(go, type, init, { callAwake });
  }
  /**
   * Add a new component (or move an existing component) to the provided object
   * @param go object to add the component to
   * @param instanceOrType if an instance is provided it will be moved to the new object, if a type is provided a new instance will be created and moved to the new object
   * @param init optional init object to initialize the component with
   * @param callAwake if true, the component will be added and awake will be called immediately
   */
  static addComponent(go, instanceOrType, init, opts) {
    return addComponent(go, instanceOrType, init, opts);
  }
  /**
   * Moves a component to a new object
   * @param go component to move the component to
   * @param instance component to move to the GO
   */
  static moveComponent(go, instance) {
    return addComponent(go, instance);
  }
  /** Removes a component from its object
   * @param instance component to remove
   */
  static removeComponent(instance) {
    removeComponent(instance.gameObject, instance);
    return instance;
  }
  static getOrAddComponent(go, typeName) {
    return getOrAddComponent(go, typeName);
  }
  /** Gets a component on the provided object */
  static getComponent(go, typeName) {
    if (go === null)
      return null;
    return getComponent(go, typeName);
  }
  static getComponents(go, typeName, arr = null) {
    if (go === null)
      return arr ?? [];
    return getComponents(go, typeName, arr);
  }
  static findByGuid(guid, hierarchy) {
    const res = findByGuid(guid, hierarchy);
    return res;
  }
  static findObjectOfType(typeName, context, includeInactive = true) {
    return findObjectOfType(typeName, context ?? Context.Current, includeInactive);
  }
  static findObjectsOfType(typeName, context) {
    const arr = [];
    findObjectsOfType(typeName, arr, context);
    return arr;
  }
  static getComponentInChildren(go, typeName) {
    return getComponentInChildren(go, typeName);
  }
  static getComponentsInChildren(go, typeName, arr = null) {
    return getComponentsInChildren(go, typeName, arr ?? void 0);
  }
  static getComponentInParent(go, typeName) {
    return getComponentInParent(go, typeName);
  }
  static getComponentsInParent(go, typeName, arr = null) {
    return getComponentsInParent(go, typeName, arr);
  }
  static getAllComponents(go) {
    var _a2;
    const componentsList = (_a2 = go.userData) == null ? void 0 : _a2.components;
    if (!componentsList)
      return [];
    const newList = [...componentsList];
    return newList;
  }
  static *iterateComponents(go) {
    var _a2;
    const list = (_a2 = go == null ? void 0 : go.userData) == null ? void 0 : _a2.components;
    if (list && Array.isArray(list)) {
      for (let i = 0; i < list.length; i++) {
        yield list[i];
      }
    }
  }
};
var _Component = class {
  /** @internal */
  constructor(init) {
    __publicField(this, "__context");
    __publicField(this, "__name");
    /** the object this component is attached to. Note that this is a threejs Object3D with some additional features */
    __publicField(this, "gameObject");
    /** the unique identifier for this component */
    __publicField(this, "guid", "invalid");
    /** holds the source identifier this object was created with/from (e.g. if it was part of a glTF file the sourceId holds the url to the glTF) */
    __publicField(this, "sourceId");
    /** @internal */
    __publicField(this, "__didAwake", false);
    /** @internal */
    __publicField(this, "__didStart", false);
    /** @internal */
    __publicField(this, "__didEnable", false);
    /** @internal */
    __publicField(this, "__isEnabled");
    /** @internal */
    __publicField(this, "__destroyed", false);
    // EventTarget implementation:
    __publicField(this, "_eventListeners", /* @__PURE__ */ new Map());
    this.__didAwake = false;
    this.__didStart = false;
    this.__didEnable = false;
    this.__isEnabled = void 0;
    this.__destroyed = false;
    this._internalInit(init);
  }
  /** @internal */
  get isComponent() {
    return true;
  }
  /** Use the context to get access to many Needle Engine features and use physics, timing, access the camera or scene */
  get context() {
    return this.__context ?? Context.Current;
  }
  set context(context) {
    this.__context = context;
  }
  /** shorthand for `this.context.scene`
   * @returns the scene of the context  */
  get scene() {
    return this.context.scene;
  }
  /** @returns the layer of the gameObject this component is attached to */
  get layer() {
    var _a2, _b;
    return (_b = (_a2 = this.gameObject) == null ? void 0 : _a2.userData) == null ? void 0 : _b.layer;
  }
  /** @returns the name of the gameObject this component is attached to */
  get name() {
    var _a2, _b;
    if ((_a2 = this.gameObject) == null ? void 0 : _a2.name) {
      return this.gameObject.name;
    }
    return (_b = this.gameObject) == null ? void 0 : _b.userData.name;
  }
  set name(str) {
    if (this.gameObject) {
      if (!this.gameObject.userData)
        this.gameObject.userData = {};
      this.gameObject.userData.name = str;
      this.__name = str;
    } else {
      this.__name = str;
    }
  }
  /** @returns the tag of the gameObject this component is attached to */
  get tag() {
    var _a2;
    return (_a2 = this.gameObject) == null ? void 0 : _a2.userData.tag;
  }
  set tag(str) {
    if (this.gameObject) {
      if (!this.gameObject.userData)
        this.gameObject.userData = {};
      this.gameObject.userData.tag = str;
    }
  }
  /** Is the gameObject marked as static */
  get static() {
    var _a2;
    return (_a2 = this.gameObject) == null ? void 0 : _a2.userData.static;
  }
  set static(value) {
    if (this.gameObject) {
      if (!this.gameObject.userData)
        this.gameObject.userData = {};
      this.gameObject.userData.static = value;
    }
  }
  get hideFlags() {
    var _a2;
    return (_a2 = this.gameObject) == null ? void 0 : _a2.userData.hideFlags;
  }
  /** @returns true if the object is enabled and active in the hierarchy */
  get activeAndEnabled() {
    if (this.destroyed)
      return false;
    if (this.__isEnabled === false)
      return false;
    if (!this.__isActiveInHierarchy)
      return false;
    return true;
  }
  get __isActive() {
    return this.gameObject.visible;
  }
  get __isActiveInHierarchy() {
    if (!this.gameObject)
      return false;
    const res = this.gameObject[activeInHierarchyFieldName];
    if (res === void 0)
      return true;
    return res;
  }
  set __isActiveInHierarchy(val) {
    if (!this.gameObject)
      return;
    this.gameObject[activeInHierarchyFieldName] = val;
  }
  /** called once when the component becomes active for the first time (once per component)
   * This is the first callback to be called */
  awake() {
  }
  /** called every time when the component gets enabled (this is invoked after awake and before start)
   * or when it becomes active in the hierarchy (e.g. if a parent object or this.gameObject gets set to visible)
  */
  onEnable() {
  }
  /** called every time the component gets disabled or if a parent object (or this.gameObject) gets set to invisible */
  onDisable() {
  }
  /** Called when the component gets destroyed */
  onDestroy() {
    this.__destroyed = true;
  }
  /** starts a coroutine (javascript generator function)
   * `yield` will wait for the next frame:
   * - Use `yield WaitForSeconds(1)` to wait for 1 second.
   * - Use `yield WaitForFrames(10)` to wait for 10 frames.
   * - Use `yield new Promise(...)` to wait for a promise to resolve.
   * @param routine generator function to start
   * @param evt event to register the coroutine for (default: FrameEvent.Update). Note that all coroutine FrameEvent callbacks are invoked after the matching regular component callbacks. For example `FrameEvent.Update` will be called after regular component `update()` methods)
   * @returns the generator function (use it to stop the coroutine with `stopCoroutine`)
   * @example
   * ```ts
   * onEnable() { this.startCoroutine(this.myCoroutine()); }
   * private *myCoroutine() {
   *    while(this.activeAndEnabled) {
   *       console.log("Hello World", this.context.time.frame);
   *       // wait for 5 frames
   *       for(let i = 0; i < 5; i++) yield;
   *    }
   * }
   * ```
   */
  startCoroutine(routine, evt = FrameEvent.Update) {
    return this.context.registerCoroutineUpdate(this, routine, evt);
  }
  /**
   * Stop a coroutine that was previously started with `startCoroutine`
   * @param routine the routine to be stopped
   * @param evt the frame event to unregister the routine from (default: FrameEvent.Update)
   */
  stopCoroutine(routine, evt = FrameEvent.Update) {
    this.context.unregisterCoroutineUpdate(routine, evt);
  }
  /** @returns true if this component was destroyed (`this.destroy()`) or the whole object this component was part of */
  get destroyed() {
    return this.__destroyed;
  }
  /**
   * Destroys this component (and removes it from the object)
   */
  destroy() {
    if (this.__destroyed)
      return;
    this.__internalDestroy();
  }
  /** @internal */
  get __internalDidAwakeAndStart() {
    return this.__didAwake && this.__didStart;
  }
  /** @internal */
  __internalNewInstanceCreated(init) {
    this.__didAwake = false;
    this.__didStart = false;
    this.__didEnable = false;
    this.__isEnabled = void 0;
    this.__destroyed = false;
    this._internalInit(init);
    return this;
  }
  _internalInit(init) {
    if (typeof init === "object") {
      for (const key of Object.keys(init)) {
        const value = init[key];
        if (typeof value === "function")
          continue;
        this[key] = value;
      }
    }
  }
  /** @internal */
  __internalAwake() {
    if (this.__didAwake)
      return;
    this.__didAwake = true;
    this.awake();
  }
  /** @internal */
  __internalStart() {
    if (this.__didStart)
      return;
    this.__didStart = true;
    if (this.start)
      this.start();
  }
  /** @internal */
  __internalEnable(isAddingToScene) {
    if (this.__destroyed) {
      if (isDevEnvironment()) {
        console.warn("[Needle Engine Dev] Trying to enable destroyed component");
      }
      return false;
    }
    if (!this.__didAwake)
      return false;
    if (this.__didEnable) {
      if (isAddingToScene !== true)
        this.__isEnabled = true;
      return false;
    }
    this.__didEnable = true;
    this.__isEnabled = true;
    this.onEnable();
    return true;
  }
  /** @internal */
  __internalDisable(isRemovingFromScene) {
    if (!this.__didAwake)
      return;
    if (!this.__didEnable) {
      if (isRemovingFromScene !== true)
        this.__isEnabled = false;
      return;
    }
    this.__didEnable = false;
    this.__isEnabled = false;
    this.onDisable();
  }
  /** @internal */
  __internalDestroy() {
    var _a2;
    if (this.__destroyed)
      return;
    this.__destroyed = true;
    if (this.__didAwake) {
      (_a2 = this.onDestroy) == null ? void 0 : _a2.call(this);
      this.dispatchEvent(new CustomEvent("destroyed", { detail: this }));
    }
    destroyComponentInstance(this);
  }
  get enabled() {
    return typeof this.__isEnabled === "boolean" ? this.__isEnabled : true;
  }
  set enabled(val) {
    if (this.__destroyed) {
      if (isDevEnvironment()) {
        console.warn(`[Needle Engine Dev] Trying to ${val ? "enable" : "disable"} destroyed component`);
      }
      return;
    }
    if (typeof val === "number") {
      if (val >= 0.5)
        val = true;
      else
        val = false;
    }
    if (!this.__didAwake) {
      this.__isEnabled = val;
      return;
    }
    if (val) {
      this.__internalEnable();
    } else {
      this.__internalDisable();
    }
  }
  get worldPosition() {
    return getWorldPosition(this.gameObject);
  }
  set worldPosition(val) {
    setWorldPosition(this.gameObject, val);
  }
  setWorldPosition(x2, y, z) {
    setWorldPositionXYZ(this.gameObject, x2, y, z);
  }
  get worldQuaternion() {
    return getWorldQuaternion(this.gameObject);
  }
  set worldQuaternion(val) {
    setWorldQuaternion(this.gameObject, val);
  }
  setWorldQuaternion(x2, y, z, w) {
    setWorldQuaternionXYZW(this.gameObject, x2, y, z, w);
  }
  // world euler (in radians)
  get worldEuler() {
    return getWorldEuler(this.gameObject);
  }
  // world euler (in radians)
  set worldEuler(val) {
    setWorldEuler(this.gameObject, val);
  }
  // returns rotation in degrees
  get worldRotation() {
    return this.gameObject.worldRotation;
    ;
  }
  set worldRotation(val) {
    this.setWorldRotation(val.x, val.y, val.z, true);
  }
  setWorldRotation(x2, y, z, degrees = true) {
    setWorldRotationXYZ(this.gameObject, x2, y, z, degrees);
  }
  /** Forward (0,0,-1) vector in world space */
  get forward() {
    return _Component._forward.set(0, 0, -1).applyQuaternion(this.worldQuaternion);
  }
  /** Right (1,0,0) vector in world space */
  get right() {
    return _Component._right.set(1, 0, 0).applyQuaternion(this.worldQuaternion);
  }
  /** Up (0,1,0) vector in world space */
  get up() {
    return _Component._up.set(0, 1, 0).applyQuaternion(this.worldQuaternion);
  }
  addEventListener(type, listener) {
    this._eventListeners[type] = this._eventListeners[type] || [];
    this._eventListeners[type].push(listener);
  }
  removeEventListener(type, listener) {
    if (!this._eventListeners[type])
      return;
    const index = this._eventListeners[type].indexOf(listener);
    if (index >= 0)
      this._eventListeners[type].splice(index, 1);
  }
  dispatchEvent(evt) {
    if (!evt || !this._eventListeners[evt.type])
      return false;
    const listeners = this._eventListeners[evt.type];
    for (let i = 0; i < listeners.length; i++) {
      listeners[i](evt);
    }
    return false;
  }
};
var Component2 = _Component;
__publicField(Component2, "_forward", new Vector32());
__publicField(Component2, "_right", new Vector32());
__publicField(Component2, "_up", new Vector32());

// node_modules/@needle-tools/engine/lib/engine-components/AlignmentConstraint.js
var __decorate = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var AlignmentConstraint = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "from");
    __publicField(this, "to");
    __publicField(this, "width", 0);
    __publicField(this, "centered", true);
    __publicField(this, "_centerPos");
  }
  awake() {
    this._centerPos = new Vector32();
  }
  update() {
    if (!this.from || !this.to)
      return;
    const fromWorldPos = getWorldPosition(this.from).clone();
    const toWorldPos = getWorldPosition(this.to).clone();
    const dist = fromWorldPos.distanceTo(toWorldPos);
    this._centerPos.copy(fromWorldPos);
    this._centerPos.add(toWorldPos);
    this._centerPos.multiplyScalar(0.5);
    setWorldPosition(this.gameObject, this.centered ? this._centerPos : fromWorldPos);
    this.gameObject.lookAt(getWorldPosition(this.to).clone());
    this.gameObject.scale.set(this.width, this.width, dist);
  }
};
__decorate([
  serializable(GameObject)
], AlignmentConstraint.prototype, "from", void 0);
__decorate([
  serializable(GameObject)
], AlignmentConstraint.prototype, "to", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/Animation.js
var __decorate2 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug35 = getParam("debuganimation");
var Vec2 = class {
  constructor() {
    __publicField(this, "x");
    __publicField(this, "y");
  }
};
var Animation = class extends Component2 {
  constructor() {
    super(...arguments);
    /**
     * If true, the animation will start playing when the component is enabled
     */
    __publicField(this, "playAutomatically", true);
    /**
     * If true, the animation will start at a random time. This is used when the animation component is enabled
     * @default true
     */
    __publicField(this, "randomStartTime", true);
    /**
     * The animation min-max speed range
     * @default undefined
     */
    __publicField(this, "minMaxSpeed");
    /**
     * The normalized offset to start the animation at. This will override startTime
     * @default undefined
     */
    __publicField(this, "minMaxOffsetNormalized");
    /**
     * Set to true to loop the animation
     * @default true
     */
    __publicField(this, "loop", true);
    /**
     * If true, the animation will clamp when finished
     */
    __publicField(this, "clampWhenFinished", false);
    __publicField(this, "_tempAnimationClipBeforeGameObjectExisted", null);
    __publicField(this, "_tempAnimationsArray");
    __publicField(this, "mixer");
    __publicField(this, "_actions");
    __publicField(this, "_handles");
  }
  get isAnimationComponent() {
    return true;
  }
  addClip(clip) {
    if (!this.animations)
      this.animations = [];
    this.animations.push(clip);
  }
  /**
   * The time in seconds of the first running animation action
   * @default 0
   */
  get time() {
    if (this.actions) {
      for (const action of this.actions) {
        if (action.isRunning())
          return action.time;
      }
    }
    return 0;
  }
  set time(val) {
    if (this.actions) {
      for (const act of this.actions) {
        act.time = val;
      }
    }
  }
  /**
   * Get the first animation clip in the animations array
   */
  get clip() {
    var _a2;
    return ((_a2 = this.animations) == null ? void 0 : _a2.length) ? this.animations[0] : null;
  }
  /**
   * Set the first animation clip in the animations array
   */
  set clip(val) {
    if (!this.__didAwake) {
      if (debug35)
        console.warn("Assign clip during serialization", val);
      this._tempAnimationClipBeforeGameObjectExisted = val;
      return;
    }
    if (!val)
      return;
    if (!this.gameObject.animations)
      this.gameObject.animations = [];
    if (this.animations.includes(val))
      return;
    if (this.animations.length > 0) {
      this.animations.splice(0, 0, val);
    } else
      this.animations.push(val);
  }
  set clips(animations) {
    this.animations = animations;
  }
  set animations(animations) {
    if (animations === null || animations === void 0 || !Array.isArray(animations))
      return;
    if (this.gameObject)
      this.gameObject.animations = animations;
    else {
      this._tempAnimationsArray = animations;
    }
  }
  get animations() {
    return this.gameObject.animations || this._tempAnimationsArray || [];
  }
  /**
   * The animation actions
   */
  get actions() {
    return this._actions;
  }
  set actions(val) {
    this._actions = val;
  }
  /** @internal */
  awake() {
    this.mixer = void 0;
    if (debug35)
      console.log("Animation Awake", this.name, this);
    if (this._tempAnimationsArray) {
      this.animations = this._tempAnimationsArray;
      this._tempAnimationsArray = void 0;
    }
    if (this._tempAnimationClipBeforeGameObjectExisted) {
      this.clip = this._tempAnimationClipBeforeGameObjectExisted;
      this._tempAnimationClipBeforeGameObjectExisted = null;
    }
    this.actions = [];
    this._handles = [];
  }
  /** @internal */
  onEnable() {
    var _a2;
    if (this.playAutomatically && ((_a2 = this.animations) == null ? void 0 : _a2.length) > 0) {
      const index = Math.floor(Math.random() * this.animations.length);
      const animation = this.animations[index];
      this.play(index, {
        exclusive: true,
        fadeDuration: 0,
        startTime: this.randomStartTime ? Math.random() * animation.duration : 0,
        loop: this.loop,
        clampWhenFinished: this.clampWhenFinished
      });
    }
  }
  /** @internal */
  update() {
    if (!this.mixer)
      return;
    this.mixer.update(this.context.time.deltaTime);
    this._handles.forEach((h) => h.update());
  }
  /** @internal */
  onDisable() {
    if (this.mixer) {
      this.mixer.stopAllAction();
    }
  }
  /** @internal */
  onDestroy() {
    this.context.animations.unregisterAnimationMixer(this.mixer);
  }
  /** Get an animation action by the animation clip name */
  getAction(name) {
    var _a2;
    return ((_a2 = this.actions) == null ? void 0 : _a2.find((a) => a.getClip().name === name)) || null;
  }
  /** Is any animation playing? */
  get isPlaying() {
    if (this.actions) {
      for (let i = 0; i < this.actions.length; i++) {
        if (this.actions[i].isRunning())
          return true;
      }
    }
    return false;
  }
  /** Stops all currently playing animations */
  stopAll(opts) {
    if (this.actions) {
      for (const act of this.actions) {
        if (opts == null ? void 0 : opts.fadeDuration) {
          act.fadeOut(opts.fadeDuration);
        } else {
          act.stop();
        }
      }
    }
  }
  /**
   * Stops a specific animation clip or index. If clip is undefined then all animations will be stopped
   */
  stop(clip, opts) {
    if (clip === void 0) {
      this.stopAll();
      return;
    } else if (typeof clip === "number") {
      if (clip >= this.animations.length) {
        if (debug35)
          console.log("No animation at index", clip);
        return;
      }
      clip = this.animations[clip];
    } else if (typeof clip === "string") {
      clip = this.animations.find((a) => a.name === clip);
    }
    if (!clip) {
      console.error("Could not find clip", clip);
      return;
    }
    const act = this.actions.find((a) => a.getClip() === clip);
    if (!act) {
      console.error("Could not find action", clip);
      return;
    }
    if (opts == null ? void 0 : opts.fadeDuration) {
      act.fadeOut(opts.fadeDuration);
    } else {
      act.stop();
    }
  }
  /**
   * Pause all animations or a specific animation clip or index
   * @param clip optional animation clip, index or name, if undefined all animations will be paused
   * @param unpause if true, the animation will be resumed
   */
  pause(clip, unpause = false) {
    if (clip === void 0) {
      for (const act2 of this.actions) {
        act2.paused = !unpause;
      }
      return;
    } else if (typeof clip === "number") {
      if (clip >= this.animations.length) {
        if (debug35)
          console.log("No animation at index", clip);
        return;
      }
      clip = this.animations[clip];
    } else if (typeof clip === "string") {
      clip = this.animations.find((a) => a.name === clip);
    }
    if (!clip) {
      console.error("Could not find clip", clip);
      return;
    }
    const act = this.actions.find((a) => a.getClip() === clip);
    if (!act) {
      console.error("Could not find action", clip);
      return;
    }
    act.paused = !unpause;
  }
  /**
   * Resume all paused animations.
   * Note that this will not fade animations in or out and just unpause previous animations. If an animation was faded out which means it's not running anymore, it will not be resumed.
   */
  resume() {
    for (const act of this.actions) {
      act.paused = false;
    }
  }
  /**
   * Play an animation clip or an clip at the specified index.
   * @param clipOrNumber the animation clip, index or name to play. If undefined, the first animation in the animations array will be played
   * @param options the play options. Use to set the fade duration, loop, speed, start time, end time, clampWhenFinished
   * @returns a promise that resolves when the animation is finished (note that it will not resolve if the animation is looping)
   */
  play(clipOrNumber = 0, options) {
    if (debug35)
      console.log("PLAY", clipOrNumber);
    this.ensureMixer();
    if (!this.mixer) {
      if (debug35)
        console.warn("Missing mixer", this);
      return;
    }
    if (clipOrNumber === void 0)
      clipOrNumber = 0;
    let clip = clipOrNumber;
    if (typeof clipOrNumber === "number") {
      if (clipOrNumber >= this.animations.length) {
        if (debug35)
          console.log("No animation at index", clipOrNumber);
        return;
      }
      clip = this.animations[clipOrNumber];
    } else if (typeof clipOrNumber === "string") {
      clip = this.animations.find((a) => a.name === clipOrNumber);
    }
    if (!clip) {
      console.error("Could not find clip", clipOrNumber);
      return;
    }
    if (!options)
      options = {};
    for (const act2 of this.actions) {
      if (act2.getClip() === clip) {
        return this.internalOnPlay(act2, options);
      }
    }
    if (!clip.tracks) {
      console.warn("Clip is no AnimationClip", clip);
      return;
    }
    const act = this.mixer.clipAction(clip);
    this.actions.push(act);
    return this.internalOnPlay(act, options);
  }
  internalOnPlay(action, options) {
    var existing = this.actions.find((a) => a === action);
    if (existing === action && existing.isRunning() && existing.time < existing.getClip().duration) {
      const handle2 = this.tryFindHandle(action);
      if (existing.paused) {
        existing.paused = false;
      }
      if (handle2)
        return handle2.waitForFinish();
    }
    if (options.loop === void 0)
      options.loop = this.loop;
    if (options.clampWhenFinished === void 0)
      options.clampWhenFinished = this.clampWhenFinished;
    if (options.minMaxOffsetNormalized === void 0 && this.randomStartTime)
      options.minMaxOffsetNormalized = this.minMaxOffsetNormalized;
    if (options.minMaxSpeed === void 0)
      options.minMaxSpeed = this.minMaxSpeed;
    const stopOther = (options == null ? void 0 : options.exclusive) ?? true;
    if (stopOther) {
      for (const act of this.actions) {
        if (act != existing) {
          if (options.fadeDuration) {
            act.fadeOut(options.fadeDuration);
          } else {
            act.stop();
          }
        }
      }
    }
    if (options == null ? void 0 : options.fadeDuration) {
      action.fadeIn(options.fadeDuration);
    }
    action.enabled = true;
    if ((options == null ? void 0 : options.startTime) != void 0) {
      action.time = options.startTime;
    } else if ((options == null ? void 0 : options.minMaxOffsetNormalized) && options.minMaxOffsetNormalized.x != 0 && options.minMaxOffsetNormalized.y != 0) {
      const clip = action.getClip();
      action.time = Mathf.lerp(options.minMaxOffsetNormalized.x, options.minMaxOffsetNormalized.y, Math.random()) * clip.duration;
    } else if (action.time >= action.getClip().duration) {
      action.time = 0;
    }
    if (options == null ? void 0 : options.minMaxSpeed) {
      action.timeScale = Mathf.lerp(options.minMaxSpeed.x, options.minMaxSpeed.y, Math.random());
    } else {
      action.timeScale = (options == null ? void 0 : options.speed) ?? 1;
    }
    if ((options == null ? void 0 : options.loop) != void 0) {
      action.loop = options.loop ? LoopRepeat : LoopOnce;
    } else
      action.loop = LoopOnce;
    if (options == null ? void 0 : options.clampWhenFinished) {
      action.clampWhenFinished = true;
    }
    action.paused = false;
    action.play();
    if (debug35)
      console.log("PLAY", action.getClip().name, action);
    const handle = new AnimationHandle(action, this.mixer, options, (_) => {
      this._handles.splice(this._handles.indexOf(handle), 1);
    });
    this._handles.push(handle);
    return handle.waitForFinish();
  }
  tryFindHandle(action) {
    for (const handle of this._handles) {
      if (handle.action === action)
        return handle;
    }
    return void 0;
  }
  ensureMixer() {
    if (!this.mixer) {
      const key = "animationMixer";
      if (this.gameObject[key]) {
        this.mixer = this.gameObject[key];
      }
      if (!this.mixer || !this.mixer.clipAction) {
        this.mixer = new AnimationMixer(this.gameObject);
        this.gameObject[key] = this.mixer;
      }
    }
    this.context.animations.registerAnimationMixer(this.mixer);
  }
};
__decorate2([
  serializable()
], Animation.prototype, "playAutomatically", void 0);
__decorate2([
  serializable()
], Animation.prototype, "randomStartTime", void 0);
__decorate2([
  serializable(Vec2)
], Animation.prototype, "minMaxSpeed", void 0);
__decorate2([
  serializable(Vec2)
], Animation.prototype, "minMaxOffsetNormalized", void 0);
__decorate2([
  serializable()
], Animation.prototype, "loop", void 0);
__decorate2([
  serializable()
], Animation.prototype, "clampWhenFinished", void 0);
__decorate2([
  serializable(AnimationClip)
], Animation.prototype, "clips", null);
var AnimationHandle = class {
  constructor(action, mixer, opts, onDone) {
    __publicField(this, "mixer");
    __publicField(this, "action");
    __publicField(this, "promise", null);
    __publicField(this, "_options");
    __publicField(this, "_resolveCallback", null);
    __publicField(this, "_resolvedOrRejectedCallback");
    // private onLoop = (_evt: MixerEvent) => {
    // }
    __publicField(this, "onFinished", (evt) => {
      if (evt.action === this.action) {
        this.onResolve();
      }
    });
    this.action = action;
    this.mixer = mixer;
    this._resolvedOrRejectedCallback = onDone;
    this._options = opts;
  }
  waitForFinish() {
    if (this.promise)
      return this.promise;
    this.promise = new Promise((res) => {
      this._resolveCallback = res;
    });
    this.mixer.addEventListener("finished", this.onFinished);
    return this.promise;
  }
  update() {
    if (!this._options)
      return;
    if (this._options.endTime !== void 0 && this.action.time > this._options.endTime) {
      if (this._options.loop === true) {
        this.action.time = this._options.startTime ?? 0;
      } else {
        this.action.time = this._options.endTime;
        this.action.timeScale = 0;
        this.onResolve();
      }
    }
  }
  onResolve() {
    var _a2, _b;
    this.dispose();
    (_a2 = this._resolvedOrRejectedCallback) == null ? void 0 : _a2.call(this, this);
    (_b = this._resolveCallback) == null ? void 0 : _b.call(this, this.action);
  }
  dispose() {
    this.mixer.removeEventListener("finished", this.onFinished);
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/AnimationCurve.js
var __decorate3 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var Keyframe = class {
  constructor(time = 0, value = 0) {
    __publicField(this, "time", 0);
    __publicField(this, "value", 0);
    __publicField(this, "inTangent", Infinity);
    __publicField(this, "inWeight");
    __publicField(this, "outTangent", Infinity);
    __publicField(this, "outWeight");
    __publicField(this, "weightedMode");
    this.time = time;
    this.value = value;
  }
};
__decorate3([
  serializable()
], Keyframe.prototype, "time", void 0);
__decorate3([
  serializable()
], Keyframe.prototype, "value", void 0);
__decorate3([
  serializable()
], Keyframe.prototype, "inTangent", void 0);
__decorate3([
  serializable()
], Keyframe.prototype, "inWeight", void 0);
__decorate3([
  serializable()
], Keyframe.prototype, "outTangent", void 0);
__decorate3([
  serializable()
], Keyframe.prototype, "outWeight", void 0);
__decorate3([
  serializable()
], Keyframe.prototype, "weightedMode", void 0);
var AnimationCurve = class {
  constructor() {
    /**
     * The keyframes that define the curve.
    */
    __publicField(this, "keys", []);
  }
  /**
   * Creates an animation curve that goes from the `from` value to the `to` value over the given `duration`.
   */
  static linearFromTo(from, to, duration) {
    const curve = new AnimationCurve();
    const keyframe1 = new Keyframe();
    keyframe1.time = 0;
    keyframe1.value = from;
    const keyframe2 = new Keyframe();
    keyframe2.time = duration;
    keyframe2.value = to;
    curve.keys.push(keyframe1, keyframe2);
    return curve;
  }
  /** Creates an animation curve with just one keyframe */
  static constant(value) {
    const curve = new AnimationCurve();
    const keyframe = new Keyframe();
    keyframe.time = 0;
    keyframe.value = value;
    curve.keys.push(keyframe);
    return curve;
  }
  /**
   * Clones this AnimationCurve and returns a new instance with the same keyframes (the keyframes are also cloned).
  */
  clone() {
    var _a2;
    const curve = new AnimationCurve();
    curve.keys = ((_a2 = this.keys) == null ? void 0 : _a2.map((k) => {
      const key = new Keyframe();
      key.time = k.time;
      key.value = k.value;
      key.inTangent = k.inTangent;
      key.inWeight = k.inWeight;
      key.outTangent = k.outTangent;
      key.outWeight = k.outWeight;
      key.weightedMode = k.weightedMode;
      return key;
    })) || [];
    return curve;
  }
  /** The duration of the curve, which is the time of the last keyframe. */
  get duration() {
    if (!this.keys || this.keys.length == 0)
      return 0;
    return this.keys[this.keys.length - 1].time;
  }
  /** Evaluates the curve at the given time and returns the value of the curve at that time.
   * @param time The time at which to evaluate the curve.
   * @returns The value of the curve at the given time.
   */
  evaluate(time) {
    if (!this.keys || this.keys.length == 0)
      return 0;
    if (this.keys.length === 1) {
      return this.keys[0].value;
    }
    if (this.keys[0].time >= time) {
      return this.keys[0].value;
    }
    for (let i = 0; i < this.keys.length; i++) {
      const kf = this.keys[i];
      if (kf.time <= time) {
        const hasNextKeyframe = i + 1 < this.keys.length;
        if (hasNextKeyframe) {
          const nextKf = this.keys[i + 1];
          if (nextKf.time < time)
            continue;
          if (!isFinite(kf.outTangent) || !isFinite(nextKf.inTangent))
            return kf.value;
          return AnimationCurve.interpolateValue(time, kf, nextKf);
        } else {
          return kf.value;
        }
      }
    }
    return this.keys[this.keys.length - 1].value;
  }
  static interpolateValue(time, keyframe1, keyframe2) {
    const startTime1 = keyframe1.time;
    const startValue1 = keyframe1.value;
    const outTangent1 = keyframe1.outTangent;
    const startTime2 = keyframe2.time;
    const startValue2 = keyframe2.value;
    const inTangent2 = keyframe2.inTangent;
    const timeDifference = startTime2 - startTime1;
    const timeDifferenceSquared = timeDifference * timeDifference;
    const timeDifferenceCubed = timeDifferenceSquared * timeDifference;
    const a = ((outTangent1 + inTangent2) * timeDifference - 2 * (startValue2 - startValue1)) / timeDifferenceCubed;
    const b = (3 * (startValue2 - startValue1) - (inTangent2 + 2 * outTangent1) * timeDifference) / timeDifferenceSquared;
    const c2 = outTangent1;
    const d = startValue1;
    const timeDelta = time - startTime1;
    const timeDeltaSquared = timeDelta * timeDelta;
    const timeDeltaCubed = timeDeltaSquared * timeDelta;
    return a * timeDeltaCubed + b * timeDeltaSquared + c2 * timeDelta + d;
  }
};
__decorate3([
  serializable(Keyframe)
], AnimationCurve.prototype, "keys", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/AnimationUtils.js
var $objectAnimationKey = Symbol("objectIsAnimatedData");
function setObjectAnimated(obj, animatedBy, isAnimated) {
  if (!obj)
    return;
  if (obj[$objectAnimationKey] === void 0) {
    if (!isAnimated)
      return;
    obj[$objectAnimationKey] = /* @__PURE__ */ new Set();
  }
  const set2 = obj[$objectAnimationKey];
  if (isAnimated) {
    set2.add(animatedBy);
  } else if (set2.has(animatedBy))
    set2.delete(animatedBy);
}
function getObjectAnimated(obj) {
  if (!obj)
    return false;
  const set2 = obj[$objectAnimationKey];
  return set2 !== void 0 && set2.size > 0;
}

// node_modules/@needle-tools/engine/lib/engine/extensions/NEEDLE_animator_controller_model.js
var StateMachineBehaviour = class {
  constructor() {
    __publicField(this, "_context");
  }
  get context() {
    return this._context ?? Context.Current;
  }
  get isStateMachineBehaviour() {
    return true;
  }
};
var AnimatorStateInfo = class {
  constructor(state, normalizedTime, length, speed) {
    /** The name of the animation */
    __publicField(this, "name");
    /** The hash of the name */
    __publicField(this, "nameHash");
    /** The normalized time of the animation */
    __publicField(this, "normalizedTime");
    /** The length of the animation */
    __publicField(this, "length");
    /** The current speed of the animation */
    __publicField(this, "speed");
    /** The current action playing. It can be used to modify the action */
    __publicField(this, "action");
    /**
     * If the state has any transitions
     */
    __publicField(this, "hasTransitions");
    var _a2;
    this.name = state.name;
    this.nameHash = state.hash;
    this.normalizedTime = normalizedTime;
    this.length = length;
    this.speed = speed;
    this.action = state.motion.action || null;
    this.hasTransitions = ((_a2 = state.transitions) == null ? void 0 : _a2.length) > 0 || false;
  }
};
function createMotion(name, id) {
  return {
    name: "Empty",
    isLooping: false,
    guid: (id == null ? void 0 : id.generateUUID()) ?? MathUtils.generateUUID(),
    index: -1,
    clip: new AnimationClip(name, 0, [])
  };
}
var AnimatorConditionMode;
(function(AnimatorConditionMode2) {
  AnimatorConditionMode2[AnimatorConditionMode2["If"] = 1] = "If";
  AnimatorConditionMode2[AnimatorConditionMode2["IfNot"] = 2] = "IfNot";
  AnimatorConditionMode2[AnimatorConditionMode2["Greater"] = 3] = "Greater";
  AnimatorConditionMode2[AnimatorConditionMode2["Less"] = 4] = "Less";
  AnimatorConditionMode2[AnimatorConditionMode2["Equals"] = 6] = "Equals";
  AnimatorConditionMode2[AnimatorConditionMode2["NotEqual"] = 7] = "NotEqual";
})(AnimatorConditionMode || (AnimatorConditionMode = {}));
var AnimatorControllerParameterType;
(function(AnimatorControllerParameterType2) {
  AnimatorControllerParameterType2[AnimatorControllerParameterType2["Float"] = 1] = "Float";
  AnimatorControllerParameterType2[AnimatorControllerParameterType2["Int"] = 3] = "Int";
  AnimatorControllerParameterType2[AnimatorControllerParameterType2["Bool"] = 4] = "Bool";
  AnimatorControllerParameterType2[AnimatorControllerParameterType2["Trigger"] = 9] = "Trigger";
})(AnimatorControllerParameterType || (AnimatorControllerParameterType = {}));

// node_modules/@needle-tools/engine/lib/engine-components/AnimatorController.js
var debug36 = getParam("debuganimatorcontroller");
var debugRootMotion = getParam("debugrootmotion");
var AnimatorController = class {
  constructor(model) {
    __publicField(this, "_speed", 1);
    /** The normalized time of the start state. This is used to determine the start time of the first state. */
    __publicField(this, "normalizedStartOffset", 0);
    /** the animator that this controller is bound to */
    __publicField(this, "animator");
    /** the model that this controller is based on */
    __publicField(this, "model");
    __publicField(this, "_mixer");
    __publicField(this, "_activeState");
    __publicField(this, "_activeStates", []);
    /**
     * These actions have been active previously but not faded out because we entered a state that has no real animation - no duration. In which case we hold the previously active actions until they are faded out.
     */
    __publicField(this, "_heldActions", []);
    // https://docs.unity3d.com/Manual/RootMotion.html
    __publicField(this, "rootMotionHandler");
    this.model = model;
    if (debug36)
      console.log(this);
  }
  /** Create an animatorcontroller. States are created from the clips array.
   * @param clips the clips to assign to the controller
   * @param options options to control the creation of the controller.
   * @returns the created animator controller
  */
  static createFromClips(clips, options = { looping: false, autoTransition: true, transitionDuration: 0 }) {
    const states = [];
    for (let i = 0; i < clips.length; i++) {
      const clip = clips[i];
      const transitions = [];
      if (options.autoTransition !== false) {
        const dur = options.transitionDuration ?? 0;
        const normalizedDuration = dur / clip.duration;
        let nextState = i;
        if (options.autoTransition === void 0 || options.autoTransition === true) {
          nextState = (i + 1) % clips.length;
        }
        transitions.push({
          exitTime: 1 - normalizedDuration,
          offset: 0,
          duration: dur,
          hasExitTime: true,
          destinationState: nextState,
          conditions: []
        });
      }
      const state = {
        name: clip.name,
        hash: i,
        motion: {
          name: clip.name,
          clip,
          isLooping: (options == null ? void 0 : options.looping) ?? false
        },
        transitions,
        behaviours: []
      };
      states.push(state);
    }
    const model = {
      name: "AnimatorController",
      guid: new InstantiateIdProvider(Date.now()).generateUUID(),
      parameters: [],
      layers: [{
        name: "Base Layer",
        stateMachine: {
          defaultState: 0,
          states
        }
      }]
    };
    const controller = new AnimatorController(model);
    return controller;
  }
  play(name, layerIndex = -1, normalizedTime = Number.NEGATIVE_INFINITY, durationInSec = 0) {
    if (layerIndex < 0)
      layerIndex = 0;
    else if (layerIndex >= this.model.layers.length) {
      console.warn("invalid layer");
      return;
    }
    const layer = this.model.layers[layerIndex];
    const sm = layer.stateMachine;
    for (const state of sm.states) {
      if (state.name === name || state.hash === name) {
        if (debug36)
          console.log("transition to ", state);
        this.transitionTo(state, durationInSec, normalizedTime);
        return;
      }
    }
    console.warn("Could not find " + name + " to play");
  }
  reset() {
    this.setStartTransition();
  }
  setBool(name, value) {
    var _a2, _b;
    const key = typeof name === "string" ? "name" : "hash";
    return (_b = (_a2 = this.model) == null ? void 0 : _a2.parameters) == null ? void 0 : _b.filter((p) => p[key] === name).forEach((p) => p.value = value);
  }
  getBool(name) {
    var _a2, _b, _c;
    const key = typeof name === "string" ? "name" : "hash";
    return ((_c = (_b = (_a2 = this.model) == null ? void 0 : _a2.parameters) == null ? void 0 : _b.find((p) => p[key] === name)) == null ? void 0 : _c.value) ?? false;
  }
  setFloat(name, val) {
    var _a2, _b;
    const key = typeof name === "string" ? "name" : "hash";
    const filtered = (_b = (_a2 = this.model) == null ? void 0 : _a2.parameters) == null ? void 0 : _b.filter((p) => p[key] === name);
    filtered.forEach((p) => p.value = val);
    return (filtered == null ? void 0 : filtered.length) > 0;
  }
  getFloat(name) {
    var _a2, _b, _c;
    const key = typeof name === "string" ? "name" : "hash";
    return ((_c = (_b = (_a2 = this.model) == null ? void 0 : _a2.parameters) == null ? void 0 : _b.find((p) => p[key] === name)) == null ? void 0 : _c.value) ?? 0;
  }
  setInteger(name, val) {
    var _a2, _b;
    const key = typeof name === "string" ? "name" : "hash";
    return (_b = (_a2 = this.model) == null ? void 0 : _a2.parameters) == null ? void 0 : _b.filter((p) => p[key] === name).forEach((p) => p.value = val);
  }
  getInteger(name) {
    var _a2, _b, _c;
    const key = typeof name === "string" ? "name" : "hash";
    return ((_c = (_b = (_a2 = this.model) == null ? void 0 : _a2.parameters) == null ? void 0 : _b.find((p) => p[key] === name)) == null ? void 0 : _c.value) ?? 0;
  }
  setTrigger(name) {
    var _a2, _b;
    if (debug36)
      console.log("SET TRIGGER", name);
    const key = typeof name === "string" ? "name" : "hash";
    return (_b = (_a2 = this.model) == null ? void 0 : _a2.parameters) == null ? void 0 : _b.filter((p) => p[key] === name).forEach((p) => p.value = true);
  }
  resetTrigger(name) {
    var _a2, _b;
    const key = typeof name === "string" ? "name" : "hash";
    return (_b = (_a2 = this.model) == null ? void 0 : _a2.parameters) == null ? void 0 : _b.filter((p) => p[key] === name).forEach((p) => p.value = false);
  }
  getTrigger(name) {
    var _a2, _b, _c;
    const key = typeof name === "string" ? "name" : "hash";
    return ((_c = (_b = (_a2 = this.model) == null ? void 0 : _a2.parameters) == null ? void 0 : _b.find((p) => p[key] === name)) == null ? void 0 : _c.value) ?? false;
  }
  isInTransition() {
    return this._activeStates.length > 1;
  }
  /** Set the speed of the animator controller. Larger values will make the animation play faster. */
  setSpeed(speed) {
    this._speed = speed;
  }
  /**@deprecated use findState */
  FindState(name) {
    return this.findState(name);
  }
  findState(name) {
    if (!name)
      return null;
    if (Array.isArray(this.model.layers)) {
      for (const layer of this.model.layers) {
        for (const state of layer.stateMachine.states) {
          if (state.name === name || state.hash == name)
            return state;
        }
      }
    }
    return null;
  }
  /** Get the current state info
   * @returns the current state info or null if no state is active
  */
  getCurrentStateInfo() {
    if (!this._activeState)
      return null;
    const action = this._activeState.motion.action;
    if (!action)
      return null;
    const dur = this._activeState.motion.clip.duration;
    const normalizedTime = dur <= 0 ? 0 : Math.abs(action.time / dur);
    return new AnimatorStateInfo(this._activeState, normalizedTime, dur, this._speed);
  }
  /** Get the current action (shorthand for activeState.motion.action)
   * @returns the current action that is playing. This is the action that is currently transitioning to or playing.
   * If no action is playing null is returned.
   **/
  get currentAction() {
    if (!this._activeState)
      return null;
    const action = this._activeState.motion.action;
    if (!action)
      return null;
    return action;
  }
  /** Get the context of the animator */
  get context() {
    var _a2;
    return (_a2 = this.animator) == null ? void 0 : _a2.context;
  }
  /** Get the animation mixer that is used to play the animations */
  get mixer() {
    return this._mixer;
  }
  /**
   * Clears the animation mixer and unregisters it from the context.
   */
  dispose() {
    var _a2;
    this._mixer.stopAllAction();
    if (this.animator) {
      this._mixer.uncacheRoot(this.animator.gameObject);
      for (const action of this._activeStates) {
        if (action.motion.clip)
          this.mixer.uncacheAction(action.motion.clip, this.animator.gameObject);
      }
    }
    (_a2 = this.context) == null ? void 0 : _a2.animations.unregisterAnimationMixer(this._mixer);
  }
  // applyRootMotion(obj: Object3D) {
  //     // this.internalApplyRootMotion(obj);
  // }
  /** Bind the animator to the controller. Only one animator can be bound to a controller at a time. */
  bind(animator) {
    var _a2, _b;
    if (!animator)
      console.error("AnimatorController.bind: animator is null");
    else if (this.animator !== animator) {
      if (this._mixer) {
        this._mixer.stopAllAction();
        (_a2 = this.context) == null ? void 0 : _a2.animations.unregisterAnimationMixer(this._mixer);
      }
      this.animator = animator;
      this._mixer = new AnimationMixer(this.animator.gameObject);
      (_b = this.context) == null ? void 0 : _b.animations.registerAnimationMixer(this._mixer);
      this.createActions(this.animator);
    }
  }
  /** Create a clone of the controller. This will clone the model but not the runtime state. */
  clone() {
    if (typeof this.model === "string") {
      console.warn("AnimatorController has not been resolved, can not create model from string", this.model);
      return null;
    }
    if (debug36)
      console.warn("AnimatorController clone()", this.model);
    const clonedModel = deepClone(this.model, (_owner, _key, _value) => {
      if (_value === null || _value === void 0)
        return true;
      if (_value.type === "Object3D" || _value.isObject3D === true)
        return false;
      if (isAnimationAction(_value)) {
        return false;
      }
      if (_value["tracks"] !== void 0)
        return false;
      if (_value instanceof AnimatorController)
        return false;
      return true;
    });
    console.assert(clonedModel !== this.model);
    const controller = new AnimatorController(clonedModel);
    return controller;
  }
  /** Called by the animator. This will update the active states and transitions as well as the animation mixer. */
  update(weight) {
    var _a2, _b;
    if (!this.animator)
      return;
    this.evaluateTransitions();
    this.updateActiveStates(weight);
    const dt = this.animator.context.time.deltaTime;
    if (this.animator.applyRootMotion) {
      (_a2 = this.rootMotionHandler) == null ? void 0 : _a2.onBeforeUpdate(weight);
    }
    this._mixer.update(dt);
    if (this.animator.applyRootMotion) {
      (_b = this.rootMotionHandler) == null ? void 0 : _b.onAfterUpdate(weight);
    }
  }
  /** Get the currently active state playing
   * @returns the currently active state or undefined if no state is active
   **/
  get activeState() {
    return this._activeState;
  }
  updateActiveStates(weight) {
    for (let i = 0; i < this._activeStates.length; i++) {
      const state = this._activeStates[i];
      const motion = state.motion;
      if (!motion.action) {
        this._activeStates.splice(i, 1);
        i--;
      } else {
        const action = motion.action;
        action.weight = weight;
        if (action.getEffectiveWeight() <= 0 && !action.isRunning()) {
          if (debug36)
            console.debug("REMOVE", state.name, action.getEffectiveWeight(), action.isRunning(), action.isScheduled());
          this._activeStates.splice(i, 1);
          i--;
        }
      }
    }
  }
  setStartTransition() {
    var _a2;
    if (this.model.layers.length > 1 && (debug36 || isDevEnvironment())) {
      console.warn("Multiple layers are not supported yet " + ((_a2 = this.animator) == null ? void 0 : _a2.name));
    }
    for (const layer of this.model.layers) {
      const sm = layer.stateMachine;
      if (sm.defaultState === void 0) {
        if (debug36)
          console.warn("AnimatorController default state is undefined, will assign state 0 as default", layer);
        sm.defaultState = 0;
      }
      const start = sm.states[sm.defaultState];
      this.transitionTo(start, 0, this.normalizedStartOffset);
      break;
    }
  }
  evaluateTransitions() {
    var _a2;
    let didEnterStateThisFrame = false;
    if (!this._activeState) {
      this.setStartTransition();
      if (!this._activeState)
        return;
      didEnterStateThisFrame = true;
    }
    const state = this._activeState;
    const action = state.motion.action;
    let index = 0;
    for (const transition of state.transitions) {
      ++index;
      if (!transition.hasExitTime && transition.conditions.length <= 0) {
        continue;
      }
      let allConditionsAreMet = true;
      for (const cond of transition.conditions) {
        if (!this.evaluateCondition(cond)) {
          allConditionsAreMet = false;
          break;
        }
      }
      if (!allConditionsAreMet)
        continue;
      if (debug36 && allConditionsAreMet) {
      }
      if (action) {
        const dur = state.motion.clip.duration;
        const normalizedTime = dur <= 0 ? 1 : Math.abs(action.time / dur);
        let exitTime = transition.exitTime;
        if (action.timeScale < 0) {
          exitTime = 1 - exitTime;
        }
        let makeTransition = false;
        if (transition.hasExitTime) {
          if (action.timeScale > 0)
            makeTransition = normalizedTime >= transition.exitTime;
          else if (action.timeScale < 0)
            makeTransition = 1 - normalizedTime >= transition.exitTime;
        } else {
          makeTransition = true;
        }
        if (makeTransition) {
          for (const cond of transition.conditions) {
            const param = this.model.parameters.find((p) => p.name === cond.parameter);
            if ((param == null ? void 0 : param.type) === AnimatorControllerParameterType.Trigger && param.value) {
              param.value = false;
            }
          }
          action.clampWhenFinished = true;
          if (debug36) {
            const targetState = this.getState(transition.destinationState, 0);
            console.log(`Transition to ${transition.destinationState} / ${targetState == null ? void 0 : targetState.name}`, transition, "\nTimescale: " + action.timeScale, "\nNormalized time: " + normalizedTime.toFixed(3), "\nExit Time: " + exitTime, transition.hasExitTime);
          }
          this.transitionTo(transition.destinationState, transition.duration, transition.offset);
          return;
        }
      } else {
        this.transitionTo(transition.destinationState, transition.duration, transition.offset);
        return;
      }
    }
    if (action) {
      this.setTimescale(action, state);
    }
    let didTriggerLooping = false;
    if (state.motion.isLooping && action) {
      if (action.time >= action.getClip().duration) {
        didTriggerLooping = true;
        action.reset();
        action.time = 0;
        action.play();
      } else if (action.time <= 0 && action.timeScale < 0) {
        didTriggerLooping = true;
        action.reset();
        action.time = action.getClip().duration;
        action.play();
      }
    }
    if (!didTriggerLooping && state && !didEnterStateThisFrame && action && this.animator) {
      if (state.behaviours) {
        const duration = action == null ? void 0 : action.getClip().duration;
        const normalizedTime = action.time / duration;
        const info = new AnimatorStateInfo(this._activeState, normalizedTime, duration, this._speed);
        for (const beh of state.behaviours) {
          if (beh.instance) {
            (_a2 = beh.instance.onStateUpdate) == null ? void 0 : _a2.call(beh.instance, this.animator, info, 0);
          }
        }
      }
    }
  }
  setTimescale(action, state) {
    let speedFactor = state.speed ?? 1;
    if (state.speedParameter)
      speedFactor *= this.getFloat(state.speedParameter);
    if (speedFactor !== void 0) {
      action.timeScale = speedFactor * this._speed;
    }
  }
  getState(state, layerIndex) {
    if (typeof state === "number") {
      if (state == -1) {
        state = this.model.layers[layerIndex].stateMachine.defaultState;
        if (state === void 0) {
          if (debug36)
            console.warn("AnimatorController default state is undefined: ", this.model, "Layer: " + layerIndex);
          state = 0;
        }
      }
      state = this.model.layers[layerIndex].stateMachine.states[state];
    }
    return state;
  }
  releaseHeldActions(duration) {
    for (const prev of this._heldActions) {
      prev.fadeOut(duration);
    }
    this._heldActions.length = 0;
  }
  transitionTo(state, durationInSec, offsetNormalized) {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    if (!this.animator)
      return;
    const layerIndex = 0;
    state = this.getState(state, layerIndex);
    if (!(state == null ? void 0 : state.motion) || !state.motion.clip || !(state.motion.clip instanceof AnimationClip)) {
      return;
    }
    const isSelf = this._activeState === state;
    if (isSelf) {
      const motion = state.motion;
      if (!motion.action_loopback && motion.clip) {
        const previousMatrix = this.rootMotionHandler ? this.animator.gameObject.matrix.clone() : null;
        this._mixer.uncacheAction(motion.clip, this.animator.gameObject);
        if (previousMatrix)
          previousMatrix.decompose(this.animator.gameObject.position, this.animator.gameObject.quaternion, this.animator.gameObject.scale);
        motion.action_loopback = this.createAction(motion.clip);
      }
    }
    if (((_a2 = this._activeState) == null ? void 0 : _a2.behaviours) && this._activeState.motion.action) {
      const duration = (_b = this._activeState) == null ? void 0 : _b.motion.clip.duration;
      const normalizedTime = this._activeState.motion.action.time / duration;
      const info = new AnimatorStateInfo(this._activeState, normalizedTime, duration, this._speed);
      for (const beh of this._activeState.behaviours) {
        (_d = (_c = beh.instance) == null ? void 0 : _c.onStateExit) == null ? void 0 : _d.call(beh.instance, this.animator, info, layerIndex);
      }
    }
    const prevAction = (_e = this._activeState) == null ? void 0 : _e.motion.action;
    if (isSelf) {
      state.motion.action = state.motion.action_loopback;
      state.motion.action_loopback = prevAction;
    }
    const prev = this._activeState;
    this._activeState = state;
    const action = (_f = state.motion) == null ? void 0 : _f.action;
    const clip = state.motion.clip;
    if ((clip == null ? void 0 : clip.duration) <= 0 && clip.tracks.length <= 0) {
      if (prevAction) {
        this._heldActions.push(prevAction);
      }
    } else if (prevAction) {
      prevAction.fadeOut(durationInSec);
      this.releaseHeldActions(durationInSec);
    }
    if (action) {
      offsetNormalized = Math.max(0, Math.min(1, offsetNormalized));
      if (state.cycleOffsetParameter) {
        let val = this.getFloat(state.cycleOffsetParameter);
        if (typeof val === "number") {
          if (val < 0)
            val += 1;
          offsetNormalized += val;
          offsetNormalized %= 1;
        } else if (debug36)
          console.warn("AnimatorController cycle offset parameter is not a number", state.cycleOffsetParameter);
      } else if (typeof state.cycleOffset === "number") {
        offsetNormalized += state.cycleOffset;
        offsetNormalized %= 1;
      }
      if (action.isRunning())
        action.stop();
      action.reset();
      action.enabled = true;
      this.setTimescale(action, state);
      const duration = state.motion.clip.duration;
      action.time = isSelf ? 0 : offsetNormalized * duration;
      if (action.timeScale < 0)
        action.time = duration - action.time;
      action.clampWhenFinished = true;
      action.setLoop(LoopOnce, 0);
      if (durationInSec > 0)
        action.fadeIn(durationInSec);
      else
        action.weight = 1;
      action.play();
      if (this.rootMotionHandler) {
        this.rootMotionHandler.onStart(action);
      }
      if (!this._activeStates.includes(state))
        this._activeStates.push(state);
      if (this._activeState.behaviours) {
        const info = new AnimatorStateInfo(state, offsetNormalized, duration, this._speed);
        for (const beh of this._activeState.behaviours) {
          (_h = (_g = beh.instance) == null ? void 0 : _g.onStateEnter) == null ? void 0 : _h.call(beh.instance, this.animator, info, layerIndex);
        }
      }
    } else if (debug36) {
      if (!state["__warned_no_motion"]) {
        state["__warned_no_motion"] = true;
        console.warn("No action", state.motion, this);
      }
    }
    if (debug36)
      console.log("TRANSITION FROM " + (prev == null ? void 0 : prev.name) + " TO " + state.name, durationInSec, prevAction, action, action == null ? void 0 : action.getEffectiveTimeScale(), action == null ? void 0 : action.getEffectiveWeight(), action == null ? void 0 : action.isRunning(), action == null ? void 0 : action.isScheduled(), action == null ? void 0 : action.paused);
  }
  createAction(clip) {
    var _a2, _b;
    const existing = this._mixer.existingAction(clip);
    if (existing)
      this._mixer.uncacheAction(clip, (_a2 = this.animator) == null ? void 0 : _a2.gameObject);
    if ((_b = this.animator) == null ? void 0 : _b.applyRootMotion) {
      if (!this.rootMotionHandler) {
        this.rootMotionHandler = new RootMotionHandler(this);
      }
      const root = this.animator.gameObject;
      return this.rootMotionHandler.createClip(this._mixer, root, clip);
    } else {
      const action = this._mixer.clipAction(clip);
      return action;
    }
  }
  evaluateCondition(cond) {
    const param = this.model.parameters.find((p) => p.name === cond.parameter);
    if (!param)
      return false;
    switch (cond.mode) {
      case AnimatorConditionMode.If:
        return param.value === true;
      case AnimatorConditionMode.IfNot:
        return param.value === false;
      case AnimatorConditionMode.Greater:
        return param.value > cond.threshold;
      case AnimatorConditionMode.Less:
        return param.value < cond.threshold;
      case AnimatorConditionMode.Equals:
        return param.value === cond.threshold;
      case AnimatorConditionMode.NotEqual:
        return param.value !== cond.threshold;
    }
    return false;
  }
  createActions(_animator) {
    var _a2, _b, _c, _d;
    if (debug36)
      console.log("AnimatorController createActions", this.model);
    for (const layer of this.model.layers) {
      const sm = layer.stateMachine;
      for (let index = 0; index < sm.states.length; index++) {
        const state = sm.states[index];
        if (!state.transitions) {
          state.transitions = [];
        }
        for (const t2 of state.transitions) {
          if (!t2.conditions)
            t2.conditions = [];
        }
        if (!state.motion) {
          if (debug36)
            console.warn("No motion", state);
          state.motion = createMotion(state.name);
        }
        if (this.animator && state.motion.clips) {
          const mapping = (_a2 = state.motion.clips) == null ? void 0 : _a2.find((e) => {
            var _a3, _b2;
            return e.node.name === ((_b2 = (_a3 = this.animator) == null ? void 0 : _a3.gameObject) == null ? void 0 : _b2.name);
          });
          if (!mapping) {
            if (debug36 || isDevEnvironment()) {
              console.warn('Could not find clip for animator "' + ((_c = (_b = this.animator) == null ? void 0 : _b.gameObject) == null ? void 0 : _c.name) + '"', state.motion.clips.map((c2) => c2.node.name));
            }
          } else
            state.motion.clip = mapping.clip;
        }
        if (!state.motion.clip) {
          if (debug36)
            console.warn("No clip assigned to state", state);
          const clip = new AnimationClip(void 0, void 0, []);
          state.motion.clip = clip;
        }
        if ((_d = state.motion) == null ? void 0 : _d.clip) {
          const clip = state.motion.clip;
          if (clip instanceof AnimationClip) {
            const action = this.createAction(clip);
            state.motion.action = action;
          } else {
            if (debug36 || isDevEnvironment())
              console.warn("No valid animationclip assigned", state);
          }
        }
        if (state.behaviours && Array.isArray(state.behaviours)) {
          for (const behaviour of state.behaviours) {
            if (!(behaviour == null ? void 0 : behaviour.typeName))
              continue;
            const type = TypeStore.get(behaviour.typeName);
            if (type) {
              const instance = new type();
              if (instance.isStateMachineBehaviour) {
                instance._context = this.context ?? void 0;
                assign(instance, behaviour.properties);
                behaviour.instance = instance;
              }
              if (debug36)
                console.log("Created animator controller behaviour", state.name, behaviour.typeName, behaviour.properties, instance);
            } else {
              if (debug36 || isDevEnvironment())
                console.warn("Could not find AnimatorBehaviour type: " + behaviour.typeName);
            }
          }
        }
      }
    }
  }
  *enumerateActions() {
    if (!this.model.layers)
      return;
    for (const layer of this.model.layers) {
      const sm = layer.stateMachine;
      for (let index = 0; index < sm.states.length; index++) {
        const state = sm.states[index];
        if (state == null ? void 0 : state.motion) {
          if (state.motion.action)
            yield state.motion.action;
          if (state.motion.action_loopback)
            yield state.motion.action_loopback;
        }
      }
    }
  }
};
var TrackEvaluationWrapper = class {
  constructor(track, evaluate) {
    __publicField(this, "track");
    __publicField(this, "createdInterpolant");
    __publicField(this, "originalEvaluate");
    __publicField(this, "customEvaluate");
    this.track = track;
    const t2 = track;
    const createOriginalInterpolator = t2.createInterpolant.bind(track);
    t2.createInterpolant = () => {
      t2.createInterpolant = createOriginalInterpolator;
      this.createdInterpolant = createOriginalInterpolator();
      this.originalEvaluate = this.createdInterpolant.evaluate.bind(this.createdInterpolant);
      this.customEvaluate = (time) => {
        if (!this.originalEvaluate)
          return;
        const res = this.originalEvaluate(time);
        return evaluate(time, res);
      };
      this.createdInterpolant.evaluate = this.customEvaluate;
      return this.createdInterpolant;
    };
  }
  dispose() {
    if (this.createdInterpolant && this.originalEvaluate) {
      this.createdInterpolant.evaluate = this.originalEvaluate;
    }
    this.track = void 0;
    this.createdInterpolant = null;
    this.originalEvaluate = void 0;
    this.customEvaluate = void 0;
  }
};
var _RootMotionAction = class {
  constructor(context, root, clip, positionTrack, rotationTrack) {
    __publicField(this, "_action");
    __publicField(this, "root");
    __publicField(this, "clip");
    __publicField(this, "positionWrapper", null);
    __publicField(this, "rotationWrapper", null);
    __publicField(this, "context");
    __publicField(this, "positionChange", new Vector32());
    __publicField(this, "rotationChange", new Quaternion());
    __publicField(this, "_prevTime", 0);
    this.context = context;
    this.root = root;
    this.clip = clip;
    if (!_RootMotionAction.firstKeyframeRotation[this.cacheId])
      _RootMotionAction.firstKeyframeRotation[this.cacheId] = new Quaternion();
    if (rotationTrack) {
      const values = rotationTrack.values;
      _RootMotionAction.firstKeyframeRotation[this.cacheId].set(values[0], values[1], values[2], values[3]);
    }
    if (!_RootMotionAction.spaceRotation[this.cacheId])
      _RootMotionAction.spaceRotation[this.cacheId] = new Quaternion();
    if (!_RootMotionAction.effectiveSpaceRotation[this.cacheId])
      _RootMotionAction.effectiveSpaceRotation[this.cacheId] = new Quaternion();
    _RootMotionAction.clipOffsetRotation[this.cacheId] = new Quaternion();
    if (rotationTrack) {
      _RootMotionAction.clipOffsetRotation[this.cacheId].set(rotationTrack.values[0], rotationTrack.values[1], rotationTrack.values[2], rotationTrack.values[3]).invert();
    }
    this.handlePosition(clip, positionTrack);
    this.handleRotation(clip, rotationTrack);
  }
  set action(val) {
    this._action = val;
  }
  get action() {
    return this._action;
  }
  get cacheId() {
    return this.root.uuid;
  }
  onStart(action) {
    if (action.getClip() !== this.clip)
      return;
    if (!_RootMotionAction.lastObjRotation[this.cacheId]) {
      _RootMotionAction.lastObjRotation[this.cacheId] = this.root.quaternion.clone();
    }
    const lastRotation = _RootMotionAction.lastObjRotation[this.cacheId];
    _RootMotionAction.spaceRotation[this.cacheId].copy(lastRotation);
    if (debugRootMotion) {
      const euler2 = new Euler().setFromQuaternion(lastRotation);
      console.log("START", this.clip.name, Mathf.toDegrees(euler2.y), this.root.position.z);
    }
  }
  getClipRotationOffset() {
    return _RootMotionAction.clipOffsetRotation[this.cacheId];
  }
  handlePosition(_clip, track) {
    if (track) {
      const root = this.root;
      if (debugRootMotion)
        root.add(new AxesHelper());
      if (!_RootMotionAction.lastObjPosition[this.cacheId])
        _RootMotionAction.lastObjPosition[this.cacheId] = this.root.position.clone();
      const valuesDiff = new Vector32();
      const valuesPrev = new Vector32();
      this.positionWrapper = new TrackEvaluationWrapper(track, (time, value) => {
        const weight = this.action.getEffectiveWeight();
        if (debugRootMotion) {
          if (root.position.length() > 8)
            root.position.set(0, root.position.y, 0);
        }
        if (time > this._prevTime) {
          valuesDiff.set(value[0], value[1], value[2]);
          valuesDiff.sub(valuesPrev);
          valuesDiff.multiplyScalar(weight);
          valuesDiff.applyQuaternion(this.getClipRotationOffset());
          valuesDiff.applyQuaternion(root.quaternion);
          this.positionChange.copy(valuesDiff);
        }
        valuesPrev.fromArray(value);
        this._prevTime = time;
        value[0] = 0;
        value[1] = 0;
        value[2] = 0;
        return value;
      });
    }
  }
  handleRotation(clip, track) {
    if (track) {
      if (debugRootMotion) {
        const arr = track.values;
        const firstKeyframe = new Euler().setFromQuaternion(new Quaternion(arr[0], arr[1], arr[2], arr[3]));
        console.log(clip.name, track.name, "FIRST ROTATION IN TRACK", Mathf.toDegrees(firstKeyframe.y));
        const i = track.values.length - 4;
        const lastKeyframe = new Quaternion().set(arr[i], arr[i + 1], arr[i + 2], arr[i + 3]);
        const euler2 = new Euler().setFromQuaternion(lastKeyframe);
        console.log(clip.name, track.name, "LAST ROTATION IN TRACK", Mathf.toDegrees(euler2.y));
      }
      let prevTime = 0;
      const valuesPrev = new Quaternion();
      const valuesDiff = new Quaternion();
      this.rotationWrapper = new TrackEvaluationWrapper(track, (time, value) => {
        if (time > prevTime) {
          valuesDiff.set(value[0], value[1], value[2], value[3]);
          valuesPrev.invert();
          valuesDiff.multiply(valuesPrev);
          this.rotationChange.copy(valuesDiff);
        }
        valuesPrev.fromArray(value);
        prevTime = time;
        value[0] = 0;
        value[1] = 0;
        value[2] = 0;
        value[3] = 1;
        return value;
      });
    }
  }
  // private lastPos: Vector3 = new Vector3();
  onBeforeUpdate(_weight) {
    this.positionChange.set(0, 0, 0);
    this.rotationChange.set(0, 0, 0, 1);
  }
  onAfterUpdate(weight) {
    if (!this.action)
      return false;
    weight *= this.action.getEffectiveWeight();
    if (weight <= 0)
      return false;
    this.positionChange.multiplyScalar(weight);
    this.rotationChange.slerp(_RootMotionAction.identityQuaternion, 1 - weight);
    return true;
  }
};
var RootMotionAction = _RootMotionAction;
__publicField(RootMotionAction, "lastObjPosition", {});
__publicField(RootMotionAction, "lastObjRotation", {});
// we remove the first keyframe rotation from the space rotation when updating
__publicField(RootMotionAction, "firstKeyframeRotation", {});
// this is used to rotate the space on clip end / start (so the transform direction is correct)
__publicField(RootMotionAction, "spaceRotation", {});
__publicField(RootMotionAction, "effectiveSpaceRotation", {});
__publicField(RootMotionAction, "clipOffsetRotation", {});
__publicField(RootMotionAction, "identityQuaternion", new Quaternion());
var RootMotionHandler = class {
  constructor(controller) {
    __publicField(this, "controller");
    __publicField(this, "handler", []);
    __publicField(this, "root");
    __publicField(this, "basePosition", new Vector32());
    __publicField(this, "baseQuaternion", new Quaternion());
    __publicField(this, "baseRotation", new Euler());
    __publicField(this, "summedPosition", new Vector32());
    __publicField(this, "summedRotation", new Quaternion());
    this.controller = controller;
  }
  createClip(mixer, root, clip) {
    this.root = root;
    let rootName = "";
    if (root && "name" in root) {
      rootName = root.name;
    }
    const positionTrack = this.findRootTrack(clip, ".position");
    const rotationTrack = this.findRootTrack(clip, ".quaternion");
    const handler = new RootMotionAction(this.controller.context, root, clip, positionTrack, rotationTrack);
    this.handler.push(handler);
    const action = mixer.clipAction(clip);
    handler.action = action;
    return action;
  }
  onStart(action) {
    for (const handler of this.handler) {
      handler.onStart(action);
    }
  }
  onBeforeUpdate(weight) {
    this.basePosition.copy(this.root.position);
    this.baseQuaternion.copy(this.root.quaternion);
    for (const hand of this.handler)
      hand.onBeforeUpdate(weight);
  }
  onAfterUpdate(weight) {
    if (weight <= 0)
      return;
    this.root.position.copy(this.basePosition);
    this.root.quaternion.copy(this.baseQuaternion);
    this.summedPosition.set(0, 0, 0);
    this.summedRotation.set(0, 0, 0, 1);
    for (const entry of this.handler) {
      if (entry.onAfterUpdate(weight)) {
        this.summedPosition.add(entry.positionChange);
        this.summedRotation.multiply(entry.rotationChange);
      }
    }
    this.root.position.add(this.summedPosition);
    this.root.quaternion.multiply(this.summedRotation);
  }
  findRootTrack(clip, name) {
    const tracks = clip.tracks;
    if (!tracks)
      return null;
    for (const track of tracks) {
      if (track.name.endsWith(name)) {
        return track;
      }
    }
    return null;
  }
};
var AnimatorControllerSerializator = class extends TypeSerializer {
  onSerialize(_, _context) {
  }
  onDeserialize(data, context) {
    if (context.type === AnimatorController && (data == null ? void 0 : data.__type) === "AnimatorController")
      return new AnimatorController(data);
    return void 0;
  }
};
new AnimatorControllerSerializator(AnimatorController);

// node_modules/@needle-tools/engine/lib/engine-components/Animator.js
var __decorate4 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug37 = getParam("debuganimator");
var Animator = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "applyRootMotion", false);
    __publicField(this, "hasRootMotion", false);
    __publicField(this, "keepAnimatorControllerStateOnDisable", false);
    __publicField(this, "_parametersAreDirty", false);
    __publicField(this, "_isDirty", false);
    __publicField(this, "_speed", 1);
    __publicField(this, "_normalizedStartOffset", 0);
    __publicField(this, "_animatorController", null);
    // Why do we jump through hoops like this? It's because of the PlayableDirector and animation tracks
    // they NEED to use the same mixer when binding/creating the animation clips
    // so when the playable director runs it takes over updating the mixer for blending and then calls the runtimeAnimatorController.update
    // so they effectively share the same mixer. There might be cases still where not the same mixer is being used but then the animation track prints an error in dev
    __publicField(this, "_initializeWithRuntimeAnimatorController");
  }
  get isAnimationComponent() {
    return true;
  }
  // set from needle animator extension
  set runtimeAnimatorController(val) {
    var _a2;
    if (this._animatorController && this._animatorController.model === val) {
      return;
    }
    if (val) {
      if (!(val instanceof AnimatorController)) {
        if (debug37)
          console.log("Assign animator controller", val, this);
        this._animatorController = new AnimatorController(val);
        if (this.__didAwake)
          this._animatorController.bind(this);
      } else {
        if (val.animator && val.animator !== this) {
          console.warn("AnimatorController can not be bound to multiple animators", (_a2 = val.model) == null ? void 0 : _a2.name);
          if (!val.model) {
            console.error("AnimatorController has no model");
          }
          val = new AnimatorController(val.model);
        }
        this._animatorController = val;
        this._animatorController.bind(this);
      }
    } else
      this._animatorController = null;
  }
  get runtimeAnimatorController() {
    return this._animatorController;
  }
  /** The current state info of the animator.
   * If you just want to access the currently playing animation action you can use currentAction
   * @returns {AnimatorStateInfo} The current state info of the animator or null if no state is playing
  */
  getCurrentStateInfo() {
    var _a2;
    return (_a2 = this.runtimeAnimatorController) == null ? void 0 : _a2.getCurrentStateInfo();
  }
  /** The current action playing. It can be used to modify the action
   * @returns {AnimationAction | null} The current action playing or null if no state is playing
  */
  get currentAction() {
    var _a2;
    return ((_a2 = this.runtimeAnimatorController) == null ? void 0 : _a2.currentAction) || null;
  }
  /** @returns {boolean} True if parameters have been changed */
  get parametersAreDirty() {
    return this._parametersAreDirty;
  }
  /** @returns {boolean} True if the animator has been changed */
  get isDirty() {
    return this._isDirty;
  }
  /**@deprecated use play() */
  Play(name, layer = -1, normalizedTime = Number.NEGATIVE_INFINITY, transitionDurationInSec = 0) {
    this.play(name, layer, normalizedTime, transitionDurationInSec);
  }
  /** Plays an animation on the animator
   * @param {string | number} name The name of the animation to play. Can also be the hash of the animation
   * @param {number} layer The layer to play the animation on. Default is -1
   * @param {number} normalizedTime The normalized time to start the animation at. Default is Number.NEGATIVE_INFINITY
   * @param {number} transitionDurationInSec The duration of the transition to the new animation. Default is 0
   * @returns {void}
   * */
  play(name, layer = -1, normalizedTime = Number.NEGATIVE_INFINITY, transitionDurationInSec = 0) {
    var _a2;
    (_a2 = this.runtimeAnimatorController) == null ? void 0 : _a2.play(name, layer, normalizedTime, transitionDurationInSec);
    this._isDirty = true;
  }
  /**@deprecated use reset */
  Reset() {
    this.reset();
  }
  /** Resets the animatorcontroller */
  reset() {
    var _a2;
    (_a2 = this._animatorController) == null ? void 0 : _a2.reset();
    this._isDirty = true;
  }
  /**@deprecated use setBool */
  SetBool(name, val) {
    this.setBool(name, val);
  }
  setBool(name, value) {
    var _a2, _b;
    if (debug37)
      console.log("setBool", name, value);
    if (((_a2 = this.runtimeAnimatorController) == null ? void 0 : _a2.getBool(name)) !== value)
      this._parametersAreDirty = true;
    (_b = this.runtimeAnimatorController) == null ? void 0 : _b.setBool(name, value);
  }
  /**@deprecated use getBool */
  GetBool(name) {
    return this.getBool(name);
  }
  getBool(name) {
    var _a2;
    const res = ((_a2 = this.runtimeAnimatorController) == null ? void 0 : _a2.getBool(name)) ?? false;
    if (debug37)
      console.log("getBool", name, res);
    return res;
  }
  toggleBool(name) {
    this.setBool(name, !this.getBool(name));
  }
  /**@deprecated use setFloat */
  SetFloat(name, val) {
    this.setFloat(name, val);
  }
  setFloat(name, val) {
    var _a2, _b;
    if (((_a2 = this.runtimeAnimatorController) == null ? void 0 : _a2.getFloat(name)) !== val)
      this._parametersAreDirty = true;
    if (debug37)
      console.log("setFloat", name, val);
    (_b = this.runtimeAnimatorController) == null ? void 0 : _b.setFloat(name, val);
  }
  /**@deprecated use getFloat */
  GetFloat(name) {
    return this.getFloat(name);
  }
  getFloat(name) {
    var _a2;
    const res = ((_a2 = this.runtimeAnimatorController) == null ? void 0 : _a2.getFloat(name)) ?? -1;
    if (debug37)
      console.log("getFloat", name, res);
    return res;
  }
  /**@deprecated use setInteger */
  SetInteger(name, val) {
    this.setInteger(name, val);
  }
  setInteger(name, val) {
    var _a2, _b;
    if (((_a2 = this.runtimeAnimatorController) == null ? void 0 : _a2.getInteger(name)) !== val)
      this._parametersAreDirty = true;
    if (debug37)
      console.log("setInteger", name, val);
    (_b = this.runtimeAnimatorController) == null ? void 0 : _b.setInteger(name, val);
  }
  /**@deprecated use getInteger */
  GetInteger(name) {
    return this.getInteger(name);
  }
  getInteger(name) {
    var _a2;
    const res = ((_a2 = this.runtimeAnimatorController) == null ? void 0 : _a2.getInteger(name)) ?? -1;
    if (debug37)
      console.log("getInteger", name, res);
    return res;
  }
  /**@deprecated use setTrigger */
  SetTrigger(name) {
    this.setTrigger(name);
  }
  setTrigger(name) {
    var _a2;
    this._parametersAreDirty = true;
    if (debug37)
      console.log("setTrigger", name);
    (_a2 = this.runtimeAnimatorController) == null ? void 0 : _a2.setTrigger(name);
  }
  /**@deprecated use resetTrigger */
  ResetTrigger(name) {
    this.resetTrigger(name);
  }
  resetTrigger(name) {
    var _a2;
    this._parametersAreDirty = true;
    if (debug37)
      console.log("resetTrigger", name);
    (_a2 = this.runtimeAnimatorController) == null ? void 0 : _a2.resetTrigger(name);
  }
  /**@deprecated use getTrigger */
  GetTrigger(name) {
    this.getTrigger(name);
  }
  getTrigger(name) {
    var _a2;
    const res = (_a2 = this.runtimeAnimatorController) == null ? void 0 : _a2.getTrigger(name);
    if (debug37)
      console.log("getTrigger", name, res);
    return res;
  }
  /**@deprecated use isInTransition */
  IsInTransition() {
    return this.isInTransition();
  }
  /** @returns `true` if the animator is currently in a transition */
  isInTransition() {
    var _a2;
    return ((_a2 = this.runtimeAnimatorController) == null ? void 0 : _a2.isInTransition()) ?? false;
  }
  /**@deprecated use setSpeed */
  SetSpeed(speed) {
    return this.setSpeed(speed);
  }
  setSpeed(speed) {
    var _a2;
    if (speed === this._speed)
      return;
    if (debug37)
      console.log("setSpeed", speed);
    this._speed = speed;
    if (((_a2 = this._animatorController) == null ? void 0 : _a2.animator) == this)
      this._animatorController.setSpeed(speed);
  }
  /** Will generate a random speed between the min and max values and set it to the animatorcontroller */
  set minMaxSpeed(minMax) {
    var _a2;
    this._speed = Mathf.lerp(minMax.x, minMax.y, Math.random());
    if (((_a2 = this._animatorController) == null ? void 0 : _a2.animator) == this)
      this._animatorController.setSpeed(this._speed);
  }
  set minMaxOffsetNormalized(minMax) {
    var _a2;
    this._normalizedStartOffset = Mathf.lerp(minMax.x, minMax.y, Math.random());
    if (((_a2 = this.runtimeAnimatorController) == null ? void 0 : _a2.animator) == this)
      this.runtimeAnimatorController.normalizedStartOffset = this._normalizedStartOffset;
  }
  awake() {
    if (debug37)
      console.log("ANIMATOR", this.name, this);
    if (!this.gameObject)
      return;
    this.initializeRuntimeAnimatorController();
  }
  initializeRuntimeAnimatorController(force = false) {
    const shouldRun = force || this.runtimeAnimatorController !== this._initializeWithRuntimeAnimatorController;
    if (this.runtimeAnimatorController && shouldRun) {
      const clone = this.runtimeAnimatorController.clone();
      this._initializeWithRuntimeAnimatorController = clone;
      if (clone) {
        console.assert(this.runtimeAnimatorController !== clone);
        this.runtimeAnimatorController = clone;
        console.assert(this.runtimeAnimatorController === clone);
        this.runtimeAnimatorController.bind(this);
        this.runtimeAnimatorController.setSpeed(this._speed);
        this.runtimeAnimatorController.normalizedStartOffset = this._normalizedStartOffset;
      } else
        console.warn("Could not clone animator controller", this.runtimeAnimatorController);
    }
  }
  onDisable() {
    var _a2;
    if (!this.keepAnimatorControllerStateOnDisable)
      (_a2 = this._animatorController) == null ? void 0 : _a2.reset();
  }
  onBeforeRender() {
    this._isDirty = false;
    this._parametersAreDirty = false;
    const isAnimatedExternally = getObjectAnimated(this.gameObject);
    if (isAnimatedExternally)
      return;
    if (this._animatorController) {
      this._animatorController.update(1);
    }
  }
};
__decorate4([
  serializable()
], Animator.prototype, "applyRootMotion", void 0);
__decorate4([
  serializable()
], Animator.prototype, "hasRootMotion", void 0);
__decorate4([
  serializable()
], Animator.prototype, "keepAnimatorControllerStateOnDisable", void 0);
__decorate4([
  serializable()
], Animator.prototype, "runtimeAnimatorController", null);

// node_modules/@needle-tools/engine/lib/engine-components/export/usdz/extensions/Animation.js
var debug38 = getParam("debugusdzanimation");
var debugSerialization = getParam("debugusdzanimationserialization");
var RegisteredAnimationInfo = class {
  constructor(ext, root, clip) {
    __publicField(this, "_start");
    __publicField(this, "ext");
    __publicField(this, "root");
    __publicField(this, "_nearestAnimatedRoot");
    __publicField(this, "clip");
    // Playback speed. Does not affect how the animation is written, just how fast actions play it back.
    __publicField(this, "speed");
    this.ext = ext;
    this.root = root;
    this.clip = clip;
    this._nearestAnimatedRoot = this.getNearestAnimatedRoot();
  }
  get start() {
    if (this._start === void 0) {
      this._start = this.ext.getStartTimeByClip(this.clip);
    }
    return this._start;
  }
  get duration() {
    var _a2;
    return ((_a2 = this.clip) == null ? void 0 : _a2.duration) ?? TransformData.restPoseClipDuration;
  }
  get nearestAnimatedRoot() {
    return this._nearestAnimatedRoot;
  }
  get clipName() {
    var _a2;
    return ((_a2 = this.clip) == null ? void 0 : _a2.name) ?? "rest";
  }
  static isDescendantOf(parent, child) {
    let current = child;
    if (!current || !parent)
      return false;
    while (current) {
      if (!current)
        return false;
      if (current === parent)
        return true;
      current = current.parent;
    }
    return false;
  }
  /** Finds the nearest actually animated object under root based on the tracks in the AnimationClip. */
  getNearestAnimatedRoot() {
    var _a2;
    let highestRoot = void 0;
    try {
      for (const track of ((_a2 = this.clip) == null ? void 0 : _a2.tracks) ?? []) {
        const parsedPath = PropertyBinding.parseTrackName(track.name);
        let animationTarget = PropertyBinding.findNode(this.root, parsedPath.nodeName);
        if (animationTarget) {
          if (!highestRoot)
            highestRoot = animationTarget;
          else {
            if (animationTarget === highestRoot)
              continue;
            if (RegisteredAnimationInfo.isDescendantOf(highestRoot, animationTarget))
              continue;
            if (!RegisteredAnimationInfo.isDescendantOf(animationTarget, highestRoot)) {
              while (!RegisteredAnimationInfo.isDescendantOf(animationTarget, highestRoot) && animationTarget.parent) {
                animationTarget = animationTarget.parent;
              }
              if (!RegisteredAnimationInfo.isDescendantOf(animationTarget, highestRoot)) {
                console.error("USDZExporter: Animation clip targets multiple roots that are not parent/child. Please report a bug", this.root, this.clip, highestRoot, animationTarget);
              }
            }
            highestRoot = animationTarget;
          }
        }
      }
    } catch (e) {
      console.error("USDZExporter: Exception when trying to find nearest animated root. Please report a bug", e);
      highestRoot = void 0;
    }
    return highestRoot;
  }
};
var _TransformData = class {
  constructor(root, target, clip) {
    __publicField(this, "clip");
    __publicField(this, "pos");
    __publicField(this, "rot");
    __publicField(this, "scale");
    __publicField(this, "root");
    __publicField(this, "target");
    __publicField(this, "duration", 0);
    __publicField(this, "useRootMotion", false);
    this.root = root;
    this.target = target;
    this.clip = clip;
    if (!clip) {
      this.duration = _TransformData.restPoseClipDuration;
    } else {
      this.duration = clip.duration;
    }
    if (clip && clip.tracks) {
      const maxTime = Math.max(...clip.tracks.map((t2) => t2.times[t2.times.length - 1]));
      if (maxTime !== this.duration) {
        console.warn("USDZExporter: Animation clip duration does not match the maximum time value in the tracks.", clip, maxTime, this.duration);
        this.duration = maxTime;
      }
    }
    const animator = GameObject.getComponent(root, Animator);
    if (animator)
      this.useRootMotion = animator.applyRootMotion;
  }
  addTrack(track) {
    var _a2, _b;
    if (!this.clip) {
      console.error("This is a rest clip but you're trying to add tracks to it – this is likely a bug");
      return;
    }
    if (track.name.endsWith("position"))
      this.pos = track;
    else if (track.name.endsWith("quaternion"))
      this.rot = track;
    else if (track.name.endsWith("scale"))
      this.scale = track;
    else {
      if (track.name.endsWith("activeSelf")) {
        console.warn("[USDZ] Animation of enabled/disabled state is not supported for USDZ export and will NOT be exported: " + track.name + " on " + (((_a2 = this.root) == null ? void 0 : _a2.name) ?? this.target.name) + ". Animate scale 0/1 instead.");
      } else {
        console.warn("[USDZ] Animation track type not supported for USDZ export and will NOT be exported: " + track.name + " on " + (((_b = this.root) == null ? void 0 : _b.name) ?? this.target.name) + ". Only .position, .rotation, .scale are supported.");
      }
      if (isDevEnvironment())
        showBalloonWarning("[USDZ] Some animations can't be exported. See console for details.");
    }
  }
  getFrames() {
    var _a2, _b, _c, _d, _e, _f;
    if (!this.clip)
      return 2;
    return Math.max(((_b = (_a2 = this.pos) == null ? void 0 : _a2.times) == null ? void 0 : _b.length) ?? 0, ((_d = (_c = this.rot) == null ? void 0 : _c.times) == null ? void 0 : _d.length) ?? 0, ((_f = (_e = this.scale) == null ? void 0 : _e.times) == null ? void 0 : _f.length) ?? 0);
  }
  getDuration() {
    return this.duration;
  }
  getSortedTimesArray(generatePos = true, generateRot = true, generateScale = true) {
    var _a2, _b, _c;
    if (!this.clip)
      return [0, this.duration];
    const posTimesArray = (_a2 = this.pos) == null ? void 0 : _a2.times;
    const rotTimesArray = (_b = this.rot) == null ? void 0 : _b.times;
    const scaleTimesArray = (_c = this.scale) == null ? void 0 : _c.times;
    const timesArray = [];
    if (generatePos && posTimesArray)
      for (const t2 of posTimesArray)
        timesArray.push(t2);
    if (generateRot && rotTimesArray)
      for (const t2 of rotTimesArray)
        timesArray.push(t2);
    if (generateScale && scaleTimesArray)
      for (const t2 of scaleTimesArray)
        timesArray.push(t2);
    if (!timesArray.includes(0))
      timesArray.push(0);
    timesArray.sort((a, b) => a - b);
    return [...new Set(timesArray)];
  }
  /**
   * Returns an iterator that yields the values for each time sample.
   * Values are reused objects - if you want to append them to some array
   * instead of processing them right away, clone() them.
   * @param timesArray
   * @param generatePos
   * @param generateRot
   * @param generateScale
   */
  *getValues(timesArray, generatePos = true, generateRot = true, generateScale = true) {
    var _a2, _b, _c;
    const translation = new Vector32();
    const rotation = new Quaternion();
    const scale = new Vector32(1, 1, 1);
    const object = this.target;
    const positionInterpolant = generatePos ? (_a2 = this.pos) == null ? void 0 : _a2.createInterpolant() : void 0;
    const rotationInterpolant = generateRot ? (_b = this.rot) == null ? void 0 : _b.createInterpolant() : void 0;
    const scaleInterpolant = generateScale ? (_c = this.scale) == null ? void 0 : _c.createInterpolant() : void 0;
    if (!positionInterpolant)
      translation.set(object.position.x, object.position.y, object.position.z);
    if (!rotationInterpolant)
      rotation.set(object.quaternion.x, object.quaternion.y, object.quaternion.z, object.quaternion.w);
    if (!scaleInterpolant)
      scale.set(object.scale.x, object.scale.y, object.scale.z);
    if (positionInterpolant && positionInterpolant.valueSize !== 3)
      positionInterpolant.valueSize = 3;
    if (rotationInterpolant && rotationInterpolant.valueSize !== 4)
      rotationInterpolant.valueSize = 4;
    if (scaleInterpolant && scaleInterpolant.valueSize !== 3)
      scaleInterpolant.valueSize = 3;
    const extraFrame = 0;
    for (let index = 0 - extraFrame; index < timesArray.length + extraFrame; index++) {
      let time = 0;
      let returnTime = 0;
      if (index < 0) {
        time = timesArray[0];
        returnTime = time - _TransformData.animationDurationPadding / 2 + 1 / 60;
      } else if (index >= timesArray.length) {
        time = timesArray[timesArray.length - 1];
        returnTime = time + _TransformData.animationDurationPadding / 2 - 1 / 60;
      } else {
        time = timesArray[index];
        returnTime = time;
      }
      if (positionInterpolant) {
        const pos = positionInterpolant.evaluate(time);
        translation.set(pos[0], pos[1], pos[2]);
      }
      if (rotationInterpolant) {
        const quat = rotationInterpolant.evaluate(time);
        rotation.set(quat[0], quat[1], quat[2], quat[3]);
      }
      if (scaleInterpolant) {
        const scaleVal = scaleInterpolant.evaluate(time);
        scale.set(scaleVal[0], scaleVal[1], scaleVal[2]);
      }
      if (this.useRootMotion && object === this.root) {
        const rootMatrix = new Matrix4();
        rootMatrix.compose(translation, rotation, scale);
        rootMatrix.multiply(object.matrix);
        rootMatrix.decompose(translation, rotation, scale);
      }
      yield { time: returnTime, translation, rotation, scale, index };
    }
  }
};
var TransformData = _TransformData;
/** This value can theoretically be anything – a value of 1 is good to clearly see animation gaps.
 * For production, a value of 1/60 is enough, since the files can then still properly play back at 60fps.
 */
__publicField(TransformData, "frameRate", 60);
__publicField(TransformData, "animationDurationPadding", 6 / 60);
__publicField(TransformData, "restPoseClipDuration", 6 / 60);
var AnimationExtension = class {
  constructor(quickLookCompatible) {
    /** For each animated object, contains time/pos/rot/scale samples in the format that USD needs,
     *  ready to be written to the .usda file.
     */
    __publicField(this, "dict", /* @__PURE__ */ new Map());
    /** Map of all roots (Animation/Animator or scene) and all targets that they animate.
     *  We need that info so that we can ensure that each target has the same number of TransformData entries
     *  so that switching between animations doesn't result in data "leaking" to another clip.
     */
    __publicField(this, "rootTargetMap", /* @__PURE__ */ new Map());
    __publicField(this, "rootAndClipToRegisteredAnimationMap", /* @__PURE__ */ new Map());
    /** Clips registered for each root */
    __publicField(this, "rootToRegisteredClip", /* @__PURE__ */ new Map());
    __publicField(this, "lastClipEndTime", 0);
    __publicField(this, "clipToStartTime", /* @__PURE__ */ new Map());
    __publicField(this, "clipToHoldClip", /* @__PURE__ */ new Map());
    __publicField(this, "serializers", []);
    /** Determines if we inject a rest pose clip for each root - only makes sense for QuickLook */
    __publicField(this, "injectRestPoses", false);
    /** Determines if we inject a PlayAnimationOnClick component with "scenestart" trigger - only makes sense for QuickLook */
    __publicField(this, "injectImplicitBehaviours", false);
    this.injectRestPoses = quickLookCompatible;
    this.injectImplicitBehaviours = quickLookCompatible;
  }
  get extensionName() {
    return "animation";
  }
  get animationData() {
    return this.dict;
  }
  get registeredClips() {
    return this.clipToStartTime.keys();
  }
  get animatedRoots() {
    return this.rootTargetMap.keys();
  }
  get holdClipMap() {
    return this.clipToHoldClip;
  }
  getStartTimeCode() {
    if (!this.injectRestPoses)
      return 0;
    if (this.rootAndClipToRegisteredAnimationMap.size === 0)
      return 0;
    return (TransformData.restPoseClipDuration + TransformData.animationDurationPadding) * 60;
  }
  /** Returns the end time code, based on 60 frames per second, for all registered animations.
   * This matches the highest time value in the USDZ file. */
  getEndTimeCode() {
    let max = 0;
    for (const [_, info] of this.rootAndClipToRegisteredAnimationMap) {
      const end = info.start + info.duration;
      if (end > max)
        max = end;
    }
    return max * 60;
  }
  getClipCount(root) {
    var _a2;
    const currentCount = ((_a2 = this.rootToRegisteredClip.get(root)) == null ? void 0 : _a2.length) ?? 0;
    return currentCount ?? 0;
  }
  /*
      // TODO why do we have this here and on TransformData? Can RegisteredAnimationInfo not cache this value?
      // TODO we probably want to assert here that this is the same value on all nodes
      getStartTime01(root: Object3D, clip: AnimationClip | null) {
          // This is a rest pose clip, it always starts at 0
          if (!clip) return 0;
  
          const targets = this.rootTargetMap.get(root);
          if (!targets) return 0;
          const transformDatas = this.dict.get(targets[0]);
          if (!transformDatas) {
              console.error("Trying to get start time for root that has no animation data", root, clip, ...this.dict);
              return 0;
          }
  
          let currentStartTime = 0;
          for (let i = 0; i < transformDatas.length; i++) {
              if (transformDatas[i].clip === clip) break;
              currentStartTime += transformDatas[i].getDuration() + TransformData.animationDurationPadding;
          }
  
          return currentStartTime;
      }
      */
  getStartTimeByClip(clip) {
    if (!clip)
      return 0;
    if (!this.clipToStartTime.has(clip)) {
      console.error("USDZExporter: Missing start time for clip – please report a bug.", clip);
      return 0;
    }
    const time = this.clipToStartTime.get(clip);
    return time;
  }
  // The same clip could be registered for different roots. All of them need written animation data then.
  // The same root could have multiple clips registered to it. If it does, the clips need to write
  // independent time data, so that playing back an animation on that root doesn't result in data "leaking"/"overlapping".
  // The structure we need is:
  // - MyRoot
  //   Animator
  //     - Clip1: CubeScale (only animates MyCube), duration: 3s
  //     - Clip2: SphereRotation (only animates MySphere), duration: 2s
  //   - MyCube
  //   - MySphere
  // Results in:
  // - MyRoot
  //   - MyCube
  //     - # rest clip (0..0.1)
  //     - # CubeScale (0.2..3.2)
  //     - # rest clip for SphereRotation (3.3..5.3)
  //   - MySphere
  //     - # rest clip (0..0.1)
  //     - # rest clip for CubeScale (0.2..3.2)
  //     - # SphereRotation (3.3..5.3)
  /** Register an AnimationClip for a specific root object.
   * @param root The root object that the animation clip is targeting.
   * @param clip The animation clip to register. If null, a rest pose is registered.
   * @returns The registered animation info, which contains the start time and duration of the clip.
   */
  registerAnimation(root, clip) {
    var _a2;
    if (!root)
      return null;
    if (!this.rootTargetMap.has(root))
      this.rootTargetMap.set(root, []);
    const hash = root.uuid + ((clip == null ? void 0 : clip.uuid) ?? "-rest");
    if (this.rootAndClipToRegisteredAnimationMap.has(hash)) {
      return this.rootAndClipToRegisteredAnimationMap.get(hash);
    }
    if (debug38)
      console.log("registerAnimation", root, clip);
    const startIndex = this.injectRestPoses ? 1 : 0;
    const currentCount = (((_a2 = this.rootToRegisteredClip.get(root)) == null ? void 0 : _a2.length) ?? 0) + startIndex;
    const targets = this.rootTargetMap.get(root);
    const unregisteredNodesForThisClip = new Set(targets);
    if (clip && clip.tracks) {
      for (const track of clip.tracks) {
        const parsedPath = PropertyBinding.parseTrackName(track.name);
        const animationTarget = PropertyBinding.findNode(root, parsedPath.nodeName);
        if (!animationTarget) {
          console.warn("no object found for track", track.name, "using " + root.name + " instead");
          continue;
        }
        if (!this.dict.has(animationTarget)) {
          this.dict.set(animationTarget, []);
        }
        const transformDataForTarget = this.dict.get(animationTarget);
        if (!transformDataForTarget) {
          console.warn("no transform data found for target ", animationTarget, "at slot " + currentCount + ", this is likely a bug");
          continue;
        }
        unregisteredNodesForThisClip.delete(animationTarget);
        if (this.injectRestPoses && !transformDataForTarget[0]) {
          console.log("Injecting rest pose", animationTarget, clip, "at slot", currentCount);
          transformDataForTarget[0] = new TransformData(null, animationTarget, null);
        }
        let model = transformDataForTarget[currentCount];
        if (!model) {
          model = new TransformData(root, animationTarget, clip);
          transformDataForTarget[currentCount] = model;
        }
        model.addTrack(track);
        if (!(targets == null ? void 0 : targets.includes(animationTarget)))
          targets == null ? void 0 : targets.push(animationTarget);
      }
    }
    if (debug38)
      console.log("Unregistered nodes for this clip", unregisteredNodesForThisClip, "clip", clip, "at slot", currentCount, "for root", root, "targets", targets);
    for (const target of unregisteredNodesForThisClip) {
      const transformDataForTarget = this.dict.get(target);
      if (!transformDataForTarget)
        continue;
      if (this.injectRestPoses && !transformDataForTarget[0]) {
        console.warn("Adding rest pose for ", target, clip, "at slot", currentCount, "This is likely a bug, should have been added earlier.");
        const model2 = new TransformData(null, target, null);
        transformDataForTarget[0] = model2;
      }
      let model = transformDataForTarget[currentCount];
      if (!model) {
        if (debug38)
          console.log("Adding padding clip for ", target, clip, "at slot", currentCount);
        model = new TransformData(root, target, clip);
        transformDataForTarget[currentCount] = model;
      }
    }
    const info = new RegisteredAnimationInfo(this, root, clip);
    this.rootAndClipToRegisteredAnimationMap.set(hash, info);
    if (debug38)
      console.log({ root, clip, info });
    if (clip) {
      const registered = this.rootToRegisteredClip.get(root);
      if (!registered)
        this.rootToRegisteredClip.set(root, [clip]);
      else
        registered.push(clip);
      const lastClip = this.clipToStartTime.get(clip);
      if (!lastClip) {
        if (this.lastClipEndTime == null)
          this.lastClipEndTime = TransformData.restPoseClipDuration;
        let newStartTime = this.lastClipEndTime + TransformData.animationDurationPadding;
        let newEndTime = newStartTime + clip.duration;
        const roundedStartTime = Math.round(newStartTime * 60) / 60;
        const roundedEndTime = Math.round(newEndTime * 60) / 60;
        if (Math.abs(roundedStartTime - newStartTime) < 0.01)
          newStartTime = roundedStartTime;
        if (Math.abs(roundedEndTime - newEndTime) < 0.01)
          newEndTime = roundedEndTime;
        newStartTime = Math.ceil(newStartTime);
        newEndTime = newStartTime + clip.duration;
        this.clipToStartTime.set(clip, newStartTime);
        this.lastClipEndTime = newEndTime;
      }
    }
    return info;
  }
  onAfterHierarchy(_context) {
    if (debug38)
      console.log("Animation clips per animation target node", this.dict);
  }
  onAfterBuildDocument(_context) {
    var _a2, _b;
    if (debug38)
      console.log("Animation data", { dict: this.dict, rootTargetMap: this.rootTargetMap, rootToRegisteredClip: this.rootToRegisteredClip });
    for (const root of this.rootTargetMap.keys()) {
      const targets = this.rootTargetMap.get(root);
      if (!targets)
        continue;
      let arrayLength = void 0;
      const durations = [];
      for (const target of targets) {
        const datas = this.dict.get(target);
        if (!datas) {
          console.error("No data found for target on USDZ export – please report a bug!", target);
          continue;
        }
        if (arrayLength === void 0)
          arrayLength = datas == null ? void 0 : datas.length;
        if (arrayLength !== (datas == null ? void 0 : datas.length))
          console.error("Different array lengths for targets – please report a bug!", datas);
        for (let i = 0; i < datas.length; i++) {
          let data = datas[i];
          if (!data) {
            const index = i - (this.injectRestPoses ? 1 : 0);
            datas[i] = new TransformData(null, target, this.rootToRegisteredClip.get(root)[index]);
            data = datas[i];
          }
          const duration = data.getDuration();
          if (durations[i] === void 0)
            durations[i] = duration;
          else if (durations[i] !== duration) {
            console.error("Error during UDSZ export: Encountered different animation durations for animated targets. Please report a bug!", { datas, target });
            durations[i] = duration;
            continue;
          }
        }
      }
    }
    for (const ser of this.serializers) {
      const parent = (_a2 = ser.model) == null ? void 0 : _a2.parent;
      const isEmptyParent = (parent == null ? void 0 : parent.isDynamic) === true;
      if (debugSerialization)
        console.log(isEmptyParent, (_b = ser.model) == null ? void 0 : _b.parent);
      if (isEmptyParent) {
        ser.registerCallback(parent);
      }
    }
  }
  onExportObject(object, model, _context) {
    GameObject.foreachComponent(object, (comp) => {
      const c2 = comp;
      if (typeof c2.createAnimation === "function") {
        c2.createAnimation(this, model, _context);
      }
    }, false);
    const ser = new SerializeAnimation(object, this);
    this.serializers.push(ser);
    ser.registerCallback(model);
  }
};
var SerializeAnimation = class {
  constructor(object, ext) {
    __publicField(this, "model");
    __publicField(this, "object");
    __publicField(this, "animationData");
    __publicField(this, "ext");
    __publicField(this, "callback");
    this.object = object;
    this.animationData = ext.animationData;
    this.ext = ext;
  }
  registerCallback(model) {
    if (this.model && this.callback) {
      this.model.removeEventListener("serialize", this.callback);
    }
    if (!this.callback)
      this.callback = this.onSerialize.bind(this);
    if (debugSerialization)
      console.log("REPARENT", model);
    this.model = model;
    if (this.callback)
      this.model.addEventListener("serialize", this.callback);
  }
  skinnedMeshExport(writer, _context, ext) {
    var _a2;
    const model = this.model;
    const dict = this.animationData;
    if (!model)
      return;
    if (model.skinnedMesh) {
      let createVector3TimeSampleLines_ = function(values) {
        const lines = [];
        for (const [frame, frameValues] of values) {
          let line = `${frame} : [`;
          const boneRotations = [];
          for (const v4 of frameValues) {
            boneRotations.push(`(${fn(v4.x)}, ${fn(v4.y)}, ${fn(v4.z)})`);
          }
          line = line.concat(boneRotations.join(", "));
          line = line.concat("],");
          lines.push(line);
        }
        return lines;
      }, createVector4TimeSampleLines_ = function(rotations2) {
        const lines = [];
        for (const [frame, frameRotations] of rotations2) {
          let line = `${frame} : [`;
          const boneRotations = [];
          for (const v4 of frameRotations) {
            boneRotations.push(`(${fn(v4.w)}, ${fn(v4.x)}, ${fn(v4.y)}, ${fn(v4.z)})`);
          }
          line = line.concat(boneRotations.join(", "));
          line = line.concat("],");
          lines.push(line);
        }
        return lines;
      }, getSortedFrameTimes = function(boneToTransformData) {
        let numberOfEntries = void 0;
        let allBonesHaveSameNumberOfTransformDataEntries = true;
        const undefinedBoneEntries = /* @__PURE__ */ new Map();
        for (const [bone, transformDatas] of boneToTransformData) {
          if (numberOfEntries === void 0)
            numberOfEntries = transformDatas.length;
          if (numberOfEntries !== transformDatas.length) {
            allBonesHaveSameNumberOfTransformDataEntries = false;
          }
          let index = 0;
          for (const transformData of transformDatas) {
            index++;
            if (!transformData) {
              if (!undefinedBoneEntries.has(bone))
                undefinedBoneEntries.set(bone, []);
              undefinedBoneEntries.get(bone).push(index);
            }
          }
        }
        if (debug38) {
          console.log("Bone count: ", boneToTransformData.size, "TransformData entries per bone: ", numberOfEntries, "Undefined bone entries: ", undefinedBoneEntries);
        }
        console.assert(allBonesHaveSameNumberOfTransformDataEntries, "All bones should have the same number of TransformData entries", boneToTransformData);
        console.assert(undefinedBoneEntries.size === 0, "All TransformData entries should be set", undefinedBoneEntries);
        const times = [];
        for (const [bone, transformDatas] of boneToTransformData) {
          for (let i = 0; i < transformDatas.length; i++) {
            const transformData = transformDatas[i];
            const timeOffset = ext.getStartTimeByClip(transformData.clip);
            if (times.length <= i) {
              times.push({ pos: [], rot: [], scale: [], timeOffset });
            }
            const perTransfromDataTimes = times[i];
            perTransfromDataTimes.pos.push(...transformData.getSortedTimesArray(true, false, false));
            perTransfromDataTimes.rot.push(...transformData.getSortedTimesArray(false, true, false));
            perTransfromDataTimes.scale.push(...transformData.getSortedTimesArray(false, false, true));
          }
        }
        for (const perTransfromDataTimes of times) {
          perTransfromDataTimes.pos.sort((a, b) => a - b);
          perTransfromDataTimes.rot.sort((a, b) => a - b);
          perTransfromDataTimes.scale.sort((a, b) => a - b);
          perTransfromDataTimes.pos = [...new Set(perTransfromDataTimes.pos)];
          perTransfromDataTimes.rot = [...new Set(perTransfromDataTimes.rot)];
          perTransfromDataTimes.scale = [...new Set(perTransfromDataTimes.scale)];
        }
        return times;
      }, createTimeSamplesObject_ = function(data, sortedComponentFrameNumbers, bones) {
        const positionTimeSamples = /* @__PURE__ */ new Map();
        const quaternionTimeSamples = /* @__PURE__ */ new Map();
        const scaleTimeSamples = /* @__PURE__ */ new Map();
        const count = sortedComponentFrameNumbers.length;
        for (const bone of bones) {
          const boneEntryInData = data.get(bone);
          let emptyTransformData = void 0;
          if (boneEntryInData)
            console.assert(boneEntryInData.length === count, "We should have the same number of TransformData entries for each bone", boneEntryInData, sortedComponentFrameNumbers);
          else
            emptyTransformData = new TransformData(null, bone, null);
          for (let i = 0; i < count; i++) {
            const transformData = boneEntryInData ? boneEntryInData[i] : emptyTransformData;
            const timeData = sortedComponentFrameNumbers[i];
            for (const { time, translation } of transformData.getValues(timeData.pos, true, false, false)) {
              const shiftedTime = time + timeData.timeOffset;
              const t2 = shiftedTime * 60;
              if (!positionTimeSamples.has(t2))
                positionTimeSamples.set(t2, new Array());
              positionTimeSamples.get(t2).push(translation.clone());
            }
            for (const { time, rotation } of transformData.getValues(timeData.rot, false, true, false)) {
              const shiftedTime = time + timeData.timeOffset;
              const t2 = shiftedTime * 60;
              if (!quaternionTimeSamples.has(t2))
                quaternionTimeSamples.set(t2, new Array());
              quaternionTimeSamples.get(t2).push(rotation.clone());
            }
            for (const { time, scale } of transformData.getValues(timeData.scale, false, false, true)) {
              const shiftedTime = time + timeData.timeOffset;
              const t2 = shiftedTime * 60;
              if (!scaleTimeSamples.has(t2))
                scaleTimeSamples.set(t2, new Array());
              scaleTimeSamples.get(t2).push(scale.clone());
            }
          }
        }
        return {
          position: positionTimeSamples.size == 0 ? void 0 : positionTimeSamples,
          quaternion: quaternionTimeSamples.size == 0 ? void 0 : quaternionTimeSamples,
          scale: scaleTimeSamples.size == 0 ? void 0 : scaleTimeSamples
        };
      }, buildVector3Array_ = function(array) {
        const lines = [];
        for (const v4 of array) {
          lines.push(`(${fn(v4.x)}, ${fn(v4.y)}, ${fn(v4.z)})`);
        }
        return lines.join(", ");
      }, buildVector4Array_ = function(array) {
        const lines = [];
        for (const v4 of array) {
          lines.push(`(${fn(v4.w)}, ${fn(v4.x)}, ${fn(v4.y)}, ${fn(v4.z)})`);
        }
        return lines.join(", ");
      }, getPerBoneTransformData = function(bones) {
        const boneToTransformData = /* @__PURE__ */ new Map();
        if (debug38) {
          const logData = new Array();
          for (const [key, val] of dict) {
            logData.push(key.uuid + ": " + val.length + " " + val.map((x2) => {
              var _a3;
              return (_a3 = x2.clip) == null ? void 0 : _a3.uuid.substring(0, 6);
            }).join(" "));
          }
          console.log("getPerBoneTransformData\n" + logData.join("\n"));
        }
        for (const bone of bones) {
          const data = dict.get(bone);
          if (!data)
            continue;
          boneToTransformData.set(bone, data);
        }
        return boneToTransformData;
      }, createAllTimeSampleObjects = function(bones) {
        const perBoneTransformData = getPerBoneTransformData(bones);
        const sortedFrameNumbers = getSortedFrameTimes(perBoneTransformData);
        return createTimeSamplesObject_(perBoneTransformData, sortedFrameNumbers, bones);
      };
      const skeleton = model.skinnedMesh.skeleton;
      const boneAndInverse = new Array();
      const sortedBones = [];
      const uuidsFound = [];
      for (const bone of skeleton.bones) {
        if (bone.parent.type !== "Bone") {
          sortedBones.push(bone);
          const inverse = skeleton.boneInverses[skeleton.bones.indexOf(bone)];
          boneAndInverse.push({ bone, inverse });
          uuidsFound.push(bone.uuid);
        }
      }
      while (uuidsFound.length < skeleton.bones.length) {
        for (const sortedBone of sortedBones) {
          const children = sortedBone.children;
          for (const childBone of children) {
            if (uuidsFound.indexOf(childBone.uuid) === -1 && skeleton.bones.indexOf(childBone) !== -1) {
              sortedBones.push(childBone);
              const childInverse = skeleton.boneInverses[skeleton.bones.indexOf(childBone)];
              boneAndInverse.push({ bone: childBone, inverse: childInverse });
              uuidsFound.push(childBone.uuid);
            }
          }
        }
      }
      for (const bone of findStructuralNodesInBoneHierarchy(skeleton.bones)) {
        boneAndInverse.push({ bone, inverse: bone.matrixWorld.clone().invert() });
      }
      const assumedRoot = boneAndInverse[0].bone.parent;
      if (!assumedRoot)
        console.error("No bone parent found for skinned mesh during USDZ export", model.skinnedMesh);
      boneAndInverse.sort((a, b) => getPathToSkeleton(a.bone, assumedRoot) > getPathToSkeleton(b.bone, assumedRoot) ? 1 : -1);
      const sanitizeRestPose = _context.quickLookCompatible;
      const rest = [];
      const translations = [];
      const rotations = [];
      const scales = [];
      for (const { bone } of boneAndInverse) {
        if (sanitizeRestPose) {
          const scale = bone.scale;
          if (scale.x == 0)
            scale.x = 1e-5;
          if (scale.y == 0)
            scale.y = 1e-5;
          if (scale.z == 0)
            scale.z = 1e-5;
          rest.push(new Matrix4().compose(bone.position, bone.quaternion, bone.scale));
        } else {
          rest.push(bone.matrix.clone());
        }
        translations.push(bone.position);
        rotations.push(bone.quaternion);
        scales.push(bone.scale);
      }
      const bonesArray = boneAndInverse.map((x2) => '"' + getPathToSkeleton(x2.bone, assumedRoot) + '"').join(", ");
      const bindTransforms = boneAndInverse.map((x2) => buildMatrix(x2.inverse.clone().invert())).join(", ");
      writer.beginBlock(`def Skeleton "Rig"`);
      writer.appendLine(`uniform matrix4d[] bindTransforms = [${bindTransforms}]`);
      writer.appendLine(`uniform token[] joints = [${bonesArray}]`);
      writer.appendLine(`uniform token purpose = "guide"`);
      writer.appendLine(`uniform matrix4d[] restTransforms = [${rest.map((m2) => buildMatrix(m2)).join(", ")}]`);
      const timeSampleObjects = createAllTimeSampleObjects(boneAndInverse.map((x2) => x2.bone));
      if (debug38) {
        let min = 1e7;
        let max = 0;
        for (const key of ((_a2 = timeSampleObjects.position) == null ? void 0 : _a2.keys()) ?? []) {
          min = Math.min(min, key);
          max = Math.max(max, key);
        }
        console.log("Time samples", min, max, timeSampleObjects);
      }
      writer.beginBlock(`def SkelAnimation "_anim"`);
      writer.appendLine(`uniform token[] joints = [${bonesArray}]`);
      writer.appendLine(`quatf[] rotations = [${buildVector4Array_(rotations)}]`);
      if (timeSampleObjects && timeSampleObjects.quaternion) {
        writer.beginBlock(`quatf[] rotations.timeSamples = {`, "");
        const rotationTimeSampleLines = createVector4TimeSampleLines_(timeSampleObjects["quaternion"]);
        for (const line of rotationTimeSampleLines) {
          writer.appendLine(line);
        }
        writer.closeBlock();
      }
      writer.appendLine(`half3[] scales = [${buildVector3Array_(scales)}]`);
      if (timeSampleObjects && timeSampleObjects.scale) {
        writer.beginBlock(`half3[] scales.timeSamples = {`, "");
        const scaleTimeSampleLines = createVector3TimeSampleLines_(timeSampleObjects["scale"]);
        for (const line of scaleTimeSampleLines) {
          writer.appendLine(line);
        }
        writer.closeBlock();
      }
      writer.appendLine(`float3[] translations = [${buildVector3Array_(translations)}]`);
      if (timeSampleObjects && timeSampleObjects.position) {
        writer.beginBlock(`float3[] translations.timeSamples = {`, "");
        const positionTimeSampleLines = createVector3TimeSampleLines_(timeSampleObjects["position"]);
        for (const line of positionTimeSampleLines) {
          writer.appendLine(line);
        }
        writer.closeBlock();
      }
      writer.closeBlock();
      writer.closeBlock();
    }
  }
  onSerialize(writer, _context) {
    if (!this.model)
      return;
    const arr0 = this.animationData.get(this.object);
    if (arr0) {
      for (let i = 0; i < arr0.length; i++) {
        if (arr0[i] !== void 0)
          continue;
        arr0[i] = new TransformData(null, this.object, null);
      }
    }
    const ext = this.ext;
    this.skinnedMeshExport(writer, _context, ext);
    const object = this.object;
    const model = this.model;
    const animationData = this.animationData.get(object);
    if (!animationData)
      return;
    if (object.isSkinnedMesh)
      return;
    if (debugSerialization)
      console.log("SERIALIZE", this.model.name, this.object.type, animationData);
    const formatter = Intl.NumberFormat("en-US", {
      maximumFractionDigits: 3,
      minimumFractionDigits: 0,
      useGrouping: false
    });
    function writeAnimationTimesamples(arr, type) {
      var _a2;
      const hasAnimationData = arr.some((x2) => x2 && {
        position: x2.pos,
        rotation: x2.rot,
        scale: x2.scale
      }[type]);
      if (!hasAnimationData) {
        return;
      }
      switch (type) {
        case "position":
          model.needsTranslate = true;
          writer.beginBlock(`double3 xformOp:translate.timeSamples = {`, "");
          break;
        case "rotation":
          model.needsOrient = true;
          writer.beginBlock(`quatf xformOp:orient.timeSamples = {`, "");
          break;
        case "scale":
          model.needsScale = true;
          writer.beginBlock(`double3 xformOp:scale.timeSamples = {`, "");
          break;
      }
      for (let i = 0; i < arr.length; i++) {
        const transformData = arr[i];
        if (!transformData)
          continue;
        const startTime = ext.getStartTimeByClip(transformData.clip);
        const timesArray = transformData.getSortedTimesArray(type === "position", type === "rotation", type === "scale");
        if (!timesArray || timesArray.length === 0) {
          console.error("got an animated object but no time values?", object, transformData);
          continue;
        }
        const isRestPose = !transformData.clip;
        const hasPos = type === "position" && (transformData.pos || isRestPose);
        const hasRot = type === "rotation" && (transformData.rot || isRestPose);
        const hasScale = type === "scale" && (transformData.scale || isRestPose);
        if (hasPos || hasRot || hasScale) {
          const clipName = ((_a2 = transformData.clip) == null ? void 0 : _a2.name) ?? "rest";
          const duration = transformData.getDuration();
          if (debug38)
            console.log("Write .timeSamples:", clipName, startTime, duration, arr);
          writer.appendLine("# " + clipName + ": start=" + formatter.format(startTime * TransformData.frameRate) + ", length=" + formatter.format(duration * TransformData.frameRate) + ", frames=" + transformData.getFrames());
        }
        if (hasPos) {
          for (const { time, translation } of transformData.getValues(timesArray, true, false, false)) {
            const timeStr = formatter.format((startTime + time) * TransformData.frameRate);
            const line = `${timeStr}: (${fn(translation.x)}, ${fn(translation.y)}, ${fn(translation.z)}),`;
            writer.appendLine(line);
          }
        }
        if (hasRot) {
          for (const { time, rotation } of transformData.getValues(timesArray, false, true, false)) {
            const timeStr = formatter.format((startTime + time) * TransformData.frameRate);
            const line = `${timeStr}: (${fn(rotation.w)}, ${fn(rotation.x)}, ${fn(rotation.y)}, ${fn(rotation.z)}),`;
            writer.appendLine(line);
          }
        }
        if (hasScale) {
          for (const { time, scale } of transformData.getValues(timesArray, false, false, true)) {
            const timeStr = formatter.format((startTime + time) * TransformData.frameRate);
            const line = `${timeStr}: (${fn(scale.x)}, ${fn(scale.y)}, ${fn(scale.z)}),`;
            writer.appendLine(line);
          }
        }
      }
      writer.closeBlock();
    }
    writeAnimationTimesamples(animationData, "position");
    writeAnimationTimesamples(animationData, "rotation");
    writeAnimationTimesamples(animationData, "scale");
  }
};

// node_modules/three/examples/jsm/helpers/PositionalAudioHelper.js
var PositionalAudioHelper = class extends Line {
  constructor(audio, range = 1, divisionsInnerAngle = 16, divisionsOuterAngle = 2) {
    const geometry = new BufferGeometry();
    const divisions = divisionsInnerAngle + divisionsOuterAngle * 2;
    const positions = new Float32Array((divisions * 3 + 3) * 3);
    geometry.setAttribute("position", new BufferAttribute2(positions, 3));
    const materialInnerAngle = new LineBasicMaterial({ color: 65280 });
    const materialOuterAngle = new LineBasicMaterial({ color: 16776960 });
    super(geometry, [materialOuterAngle, materialInnerAngle]);
    this.audio = audio;
    this.range = range;
    this.divisionsInnerAngle = divisionsInnerAngle;
    this.divisionsOuterAngle = divisionsOuterAngle;
    this.type = "PositionalAudioHelper";
    this.update();
  }
  update() {
    const audio = this.audio;
    const range = this.range;
    const divisionsInnerAngle = this.divisionsInnerAngle;
    const divisionsOuterAngle = this.divisionsOuterAngle;
    const coneInnerAngle = MathUtils.degToRad(audio.panner.coneInnerAngle);
    const coneOuterAngle = MathUtils.degToRad(audio.panner.coneOuterAngle);
    const halfConeInnerAngle = coneInnerAngle / 2;
    const halfConeOuterAngle = coneOuterAngle / 2;
    let start = 0;
    let count = 0;
    let i;
    let stride;
    const geometry = this.geometry;
    const positionAttribute = geometry.attributes.position;
    geometry.clearGroups();
    function generateSegment(from, to, divisions, materialIndex) {
      const step = (to - from) / divisions;
      positionAttribute.setXYZ(start, 0, 0, 0);
      count++;
      for (i = from; i < to; i += step) {
        stride = start + count;
        positionAttribute.setXYZ(stride, Math.sin(i) * range, 0, Math.cos(i) * range);
        positionAttribute.setXYZ(stride + 1, Math.sin(Math.min(i + step, to)) * range, 0, Math.cos(Math.min(i + step, to)) * range);
        positionAttribute.setXYZ(stride + 2, 0, 0, 0);
        count += 3;
      }
      geometry.addGroup(start, count, materialIndex);
      start += count;
      count = 0;
    }
    generateSegment(-halfConeOuterAngle, -halfConeInnerAngle, divisionsOuterAngle, 0);
    generateSegment(-halfConeInnerAngle, halfConeInnerAngle, divisionsInnerAngle, 1);
    generateSegment(halfConeInnerAngle, halfConeOuterAngle, divisionsOuterAngle, 0);
    positionAttribute.needsUpdate = true;
    if (coneInnerAngle === coneOuterAngle)
      this.material[0].visible = false;
  }
  dispose() {
    this.geometry.dispose();
    this.material[0].dispose();
    this.material[1].dispose();
  }
};

// node_modules/@needle-tools/engine/lib/engine/engine_texture.js
var _prevVisible = Symbol("previous-visibility");
var _RenderTexture = class extends WebGLRenderTarget {
  /**
   * Render the scene to the texture
   * @param scene The scene to render
   * @param camera The camera to render from
   * @param renderer The renderer or effectcomposer to use
   */
  render(scene, camera, renderer) {
    if (renderer instanceof EffectComposer) {
      if (!this["_unsupported_effectcomposer_warning"]) {
        console.warn("RenderTexture.render() does not yet support EffectComposer");
        this["_unsupported_effectcomposer_warning"] = true;
      }
    } else {
      this.onBeforeRender();
      const prev = renderer.getRenderTarget();
      const xr = renderer.xr.enabled;
      renderer.xr.enabled = false;
      renderer.setRenderTarget(this);
      renderer.clear(true, true, true);
      renderer.render(scene, camera);
      renderer.setRenderTarget(prev);
      renderer.xr.enabled = xr;
      this.onAfterRender();
    }
  }
  onBeforeRender() {
    _RenderTexture._userSet.clear();
    const users = findResourceUsers(this.texture, true, null, _RenderTexture._userSet);
    for (const user of users) {
      if (user instanceof Mesh) {
        user[_prevVisible] = user.visible;
        user.visible = false;
      }
    }
  }
  onAfterRender() {
    for (const user of _RenderTexture._userSet) {
      if (user instanceof Mesh) {
        user.visible = user[_prevVisible];
      }
    }
    _RenderTexture._userSet.clear();
  }
};
var RenderTexture = _RenderTexture;
__publicField(RenderTexture, "_userSet", /* @__PURE__ */ new Set());

// node_modules/three/examples/jsm/controls/OrbitControls.js
var _changeEvent2 = { type: "change" };
var _startEvent = { type: "start" };
var _endEvent = { type: "end" };
var _ray = new Ray();
var _plane = new Plane();
var _TILT_LIMIT = Math.cos(70 * MathUtils.DEG2RAD);
var _v = new Vector32();
var _p = new Vector32();
var _twoPI = 2 * Math.PI;
var _STATE = {
  NONE: -1,
  ROTATE: 0,
  DOLLY: 1,
  PAN: 2,
  TOUCH_ROTATE: 3,
  TOUCH_PAN: 4,
  TOUCH_DOLLY_PAN: 5,
  TOUCH_DOLLY_ROTATE: 6
};
var _EPS = 1e-6;
var OrbitControls = class extends Controls {
  constructor(object, domElement = null) {
    super(object, domElement);
    this.state = _STATE.NONE;
    this.enabled = true;
    this.target = new Vector32();
    this.cursor = new Vector32();
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.minZoom = 0;
    this.maxZoom = Infinity;
    this.minTargetRadius = 0;
    this.maxTargetRadius = Infinity;
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = -Infinity;
    this.maxAzimuthAngle = Infinity;
    this.enableDamping = false;
    this.dampingFactor = 0.05;
    this.enableZoom = true;
    this.zoomSpeed = 1;
    this.enableRotate = true;
    this.rotateSpeed = 1;
    this.enablePan = true;
    this.panSpeed = 1;
    this.screenSpacePanning = true;
    this.keyPanSpeed = 7;
    this.zoomToCursor = false;
    this.autoRotate = false;
    this.autoRotateSpeed = 2;
    this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" };
    this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };
    this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };
    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.zoom0 = this.object.zoom;
    this._domElementKeyEvents = null;
    this._lastPosition = new Vector32();
    this._lastQuaternion = new Quaternion();
    this._lastTargetPosition = new Vector32();
    this._quat = new Quaternion().setFromUnitVectors(object.up, new Vector32(0, 1, 0));
    this._quatInverse = this._quat.clone().invert();
    this._spherical = new Spherical();
    this._sphericalDelta = new Spherical();
    this._scale = 1;
    this._currentScale = 1;
    this._panOffset = new Vector32();
    this._rotateStart = new Vector2();
    this._rotateEnd = new Vector2();
    this._rotateDelta = new Vector2();
    this._panStart = new Vector2();
    this._panEnd = new Vector2();
    this._panDelta = new Vector2();
    this._dollyStart = new Vector2();
    this._dollyEnd = new Vector2();
    this._dollyDelta = new Vector2();
    this._dollyDirection = new Vector32();
    this._mouse = new Vector2();
    this._performCursorZoom = false;
    this._pointers = [];
    this._pointerPositions = {};
    this._controlActive = false;
    this._onPointerMove = onPointerMove2.bind(this);
    this._onPointerDown = onPointerDown2.bind(this);
    this._onPointerUp = onPointerUp2.bind(this);
    this._onContextMenu = onContextMenu.bind(this);
    this._onMouseWheel = onMouseWheel.bind(this);
    this._onKeyDown = onKeyDown.bind(this);
    this._onTouchStart = onTouchStart.bind(this);
    this._onTouchMove = onTouchMove.bind(this);
    this._onMouseDown = onMouseDown.bind(this);
    this._onMouseMove = onMouseMove.bind(this);
    this._interceptControlDown = interceptControlDown.bind(this);
    this._interceptControlUp = interceptControlUp.bind(this);
    if (this.domElement !== null) {
      this.connect();
    }
    this.update();
  }
  connect() {
    this.domElement.addEventListener("pointerdown", this._onPointerDown);
    this.domElement.addEventListener("pointercancel", this._onPointerUp);
    this.domElement.addEventListener("contextmenu", this._onContextMenu);
    this.domElement.addEventListener("wheel", this._onMouseWheel, { passive: false });
    const document2 = this.domElement.getRootNode();
    document2.addEventListener("keydown", this._interceptControlDown, { passive: true, capture: true });
    this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown);
    this.domElement.removeEventListener("pointermove", this._onPointerMove);
    this.domElement.removeEventListener("pointerup", this._onPointerUp);
    this.domElement.removeEventListener("pointercancel", this._onPointerUp);
    this.domElement.removeEventListener("wheel", this._onMouseWheel);
    this.domElement.removeEventListener("contextmenu", this._onContextMenu);
    this.stopListenToKeyEvents();
    const document2 = this.domElement.getRootNode();
    document2.removeEventListener("keydown", this._interceptControlDown, { capture: true });
    this.domElement.style.touchAction = "auto";
  }
  dispose() {
    this.disconnect();
  }
  getPolarAngle() {
    return this._spherical.phi;
  }
  getAzimuthalAngle() {
    return this._spherical.theta;
  }
  getDistance() {
    return this.object.position.distanceTo(this.target);
  }
  listenToKeyEvents(domElement) {
    domElement.addEventListener("keydown", this._onKeyDown);
    this._domElementKeyEvents = domElement;
  }
  stopListenToKeyEvents() {
    if (this._domElementKeyEvents !== null) {
      this._domElementKeyEvents.removeEventListener("keydown", this._onKeyDown);
      this._domElementKeyEvents = null;
    }
  }
  saveState() {
    this.target0.copy(this.target);
    this.position0.copy(this.object.position);
    this.zoom0 = this.object.zoom;
  }
  reset() {
    this.target.copy(this.target0);
    this.object.position.copy(this.position0);
    this.object.zoom = this.zoom0;
    this.object.updateProjectionMatrix();
    this.dispatchEvent(_changeEvent2);
    this.update();
    this.state = _STATE.NONE;
  }
  update(deltaTime = null) {
    const position = this.object.getWorldPosition(this.object.position);
    _v.copy(position).sub(this.target);
    _v.applyQuaternion(this._quat);
    this._spherical.setFromVector3(_v);
    if (this.autoRotate && this.state === _STATE.NONE) {
      this._rotateLeft(this._getAutoRotationAngle(deltaTime));
    }
    if (this.enableDamping) {
      this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor;
      this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor;
    } else {
      this._spherical.theta += this._sphericalDelta.theta;
      this._spherical.phi += this._sphericalDelta.phi;
    }
    let min = this.minAzimuthAngle;
    let max = this.maxAzimuthAngle;
    if (isFinite(min) && isFinite(max)) {
      if (min < -Math.PI)
        min += _twoPI;
      else if (min > Math.PI)
        min -= _twoPI;
      if (max < -Math.PI)
        max += _twoPI;
      else if (max > Math.PI)
        max -= _twoPI;
      if (min <= max) {
        this._spherical.theta = Math.max(min, Math.min(max, this._spherical.theta));
      } else {
        this._spherical.theta = this._spherical.theta > (min + max) / 2 ? Math.max(min, this._spherical.theta) : Math.min(max, this._spherical.theta);
      }
    }
    this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi));
    this._spherical.makeSafe();
    if (this.enableDamping === true) {
      this.target.addScaledVector(this._panOffset, this.dampingFactor);
    } else {
      this.target.add(this._panOffset);
    }
    this.target.sub(this.cursor);
    this.target.clampLength(this.minTargetRadius, this.maxTargetRadius);
    this.target.add(this.cursor);
    let zoomChanged = false;
    if (this.enableDamping) {
      this._currentScale = MathUtils.lerp(this._currentScale, this._scale, this.dampingFactor);
    } else {
      this._currentScale = this._scale;
    }
    if (this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera) {
      this._spherical.radius = this._clampDistance(this._spherical.radius);
    } else {
      const prevRadius = this._spherical.radius;
      this._spherical.radius = this._clampDistance(this._spherical.radius * this._currentScale);
      zoomChanged = prevRadius != this._spherical.radius;
    }
    _v.setFromSpherical(this._spherical);
    _v.applyQuaternion(this._quatInverse);
    position.copy(this.target).add(_v);
    this.object.parent ? this.object.parent.worldToLocal(position) : this.object.position.copy(position);
    this.object.lookAt(this.target);
    if (this.enableDamping === true) {
      this._sphericalDelta.theta *= 1 - this.dampingFactor;
      this._sphericalDelta.phi *= 1 - this.dampingFactor;
      this._panOffset.multiplyScalar(1 - this.dampingFactor);
    } else {
      this._sphericalDelta.set(0, 0, 0);
      this._panOffset.set(0, 0, 0);
    }
    if (this.zoomToCursor && this._performCursorZoom) {
      let newRadius = null;
      if (this.object.isPerspectiveCamera) {
        const prevRadius = _v.length();
        newRadius = this._clampDistance(prevRadius * this._currentScale);
        const radiusDelta = prevRadius - newRadius;
        this.object.position.addScaledVector(this._dollyDirection, radiusDelta);
        this.object.updateMatrixWorld();
        zoomChanged = !!radiusDelta;
      } else if (this.object.isOrthographicCamera) {
        const mouseBefore = new Vector32(this._mouse.x, this._mouse.y, 0);
        mouseBefore.unproject(this.object);
        const prevZoom = this.object.zoom;
        this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._currentScale));
        this.object.updateProjectionMatrix();
        zoomChanged = prevZoom !== this.object.zoom;
        const mouseAfter = new Vector32(this._mouse.x, this._mouse.y, 0);
        mouseAfter.unproject(this.object);
        this.object.position.sub(mouseAfter).add(mouseBefore);
        this.object.updateMatrixWorld();
        newRadius = _v.length();
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.");
        this.zoomToCursor = false;
      }
      if (newRadius !== null) {
        if (this.screenSpacePanning) {
          this.target.set(0, 0, -1).transformDirection(this.object.matrix).multiplyScalar(newRadius).add(this.object.position);
        } else {
          _ray.origin.copy(this.object.position);
          _ray.direction.set(0, 0, -1).transformDirection(this.object.matrix);
          if (Math.abs(this.object.up.dot(_ray.direction)) < _TILT_LIMIT) {
            this.object.lookAt(this.target);
          } else {
            _plane.setFromNormalAndCoplanarPoint(this.object.up, this.target);
            _ray.intersectPlane(_plane, this.target);
          }
        }
      }
    } else if (this.object.isOrthographicCamera) {
      const prevZoom = this.object.zoom;
      this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale));
      if (prevZoom !== this.object.zoom) {
        this.object.updateProjectionMatrix();
        zoomChanged = true;
      }
    }
    this._scale = 1;
    if (zoomChanged || this._lastPosition.distanceToSquared(this.object.position) > _EPS || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > _EPS || this._lastTargetPosition.distanceToSquared(this.target) > _EPS) {
      this.dispatchEvent(_changeEvent2);
      this._lastPosition.copy(this.object.position);
      this._lastQuaternion.copy(this.object.quaternion);
      this._lastTargetPosition.copy(this.target);
      return true;
    }
    this._performCursorZoom = false;
    return false;
  }
  _getAutoRotationAngle(deltaTime) {
    if (deltaTime !== null) {
      return _twoPI / 60 * this.autoRotateSpeed * deltaTime;
    } else {
      return _twoPI / 60 / 60 * this.autoRotateSpeed;
    }
  }
  _getZoomScale(delta) {
    const normalizedDelta = Math.abs(delta * 0.01);
    return Math.pow(0.95, this.zoomSpeed * normalizedDelta);
  }
  _rotateLeft(angle) {
    this._sphericalDelta.theta -= angle;
  }
  _rotateUp(angle) {
    this._sphericalDelta.phi -= angle;
  }
  _panLeft(distance, objectMatrix) {
    _v.setFromMatrixColumn(objectMatrix, 0);
    _v.multiplyScalar(-distance);
    this._panOffset.add(_v);
  }
  _panUp(distance, objectMatrix) {
    if (this.screenSpacePanning === true) {
      _v.setFromMatrixColumn(objectMatrix, 1);
    } else {
      _v.setFromMatrixColumn(objectMatrix, 0);
      _v.crossVectors(this.object.up, _v);
    }
    _v.multiplyScalar(distance);
    this._panOffset.add(_v);
  }
  // deltaX and deltaY are in pixels; right and down are positive
  _pan(deltaX, deltaY) {
    const element = this.domElement;
    if (this.object.isPerspectiveCamera) {
      this.object.getWorldPosition(_v).sub(this.target);
      let targetDistance = _v.length();
      targetDistance *= Math.tan(this.object.fov / 2 * Math.PI / 180);
      this._panLeft(2 * deltaX * targetDistance / element.clientHeight, this.object.matrixWorld);
      this._panUp(2 * deltaY * targetDistance / element.clientHeight, this.object.matrixWorld);
    } else if (this.object.isOrthographicCamera) {
      this._panLeft(deltaX * (this.object.right - this.object.left) / this.object.zoom / element.clientWidth, this.object.matrixWorld);
      this._panUp(deltaY * (this.object.top - this.object.bottom) / this.object.zoom / element.clientHeight, this.object.matrixWorld);
    } else {
      console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
      this.enablePan = false;
    }
  }
  _dollyOut(dollyScale) {
    if (this.object.isPerspectiveCamera || this.object.isOrthographicCamera) {
      this._scale /= dollyScale;
    } else {
      console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
      this.enableZoom = false;
    }
  }
  _dollyIn(dollyScale) {
    if (this.object.isPerspectiveCamera || this.object.isOrthographicCamera) {
      this._scale *= dollyScale;
    } else {
      console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
      this.enableZoom = false;
    }
  }
  _updateZoomParameters(x2, y) {
    if (!this.zoomToCursor) {
      return;
    }
    this._performCursorZoom = true;
    const rect = this.domElement.getBoundingClientRect();
    const dx = x2 - rect.left;
    const dy = y - rect.top;
    const w = rect.width;
    const h = rect.height;
    this._mouse.x = dx / w * 2 - 1;
    this._mouse.y = -(dy / h) * 2 + 1;
    this._dollyDirection.set(this._mouse.x, this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize();
  }
  _clampDistance(dist) {
    return Math.max(this.minDistance, Math.min(this.maxDistance, dist));
  }
  //
  // event callbacks - update the object state
  //
  _handleMouseDownRotate(event) {
    this._rotateStart.set(event.clientX, event.clientY);
  }
  _handleMouseDownDolly(event) {
    this._updateZoomParameters(event.clientX, event.clientX);
    this._dollyStart.set(event.clientX, event.clientY);
  }
  _handleMouseDownPan(event) {
    this._panStart.set(event.clientX, event.clientY);
  }
  _handleMouseMoveRotate(event) {
    this._rotateEnd.set(event.clientX, event.clientY);
    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const element = this.domElement;
    this._rotateLeft(_twoPI * this._rotateDelta.x / element.clientHeight);
    this._rotateUp(_twoPI * this._rotateDelta.y / element.clientHeight);
    this._rotateStart.copy(this._rotateEnd);
    this.update();
  }
  _handleMouseMoveDolly(event) {
    this._dollyEnd.set(event.clientX, event.clientY);
    this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart);
    if (this._dollyDelta.y > 0) {
      this._dollyOut(this._getZoomScale(this._dollyDelta.y));
    } else if (this._dollyDelta.y < 0) {
      this._dollyIn(this._getZoomScale(this._dollyDelta.y));
    }
    this._dollyStart.copy(this._dollyEnd);
    this.update();
  }
  _handleMouseMovePan(event) {
    this._panEnd.set(event.clientX, event.clientY);
    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed);
    this._pan(this._panDelta.x, this._panDelta.y);
    this._panStart.copy(this._panEnd);
    this.update();
  }
  _handleMouseWheel(event) {
    this._updateZoomParameters(event.clientX, event.clientY);
    if (event.deltaY < 0) {
      this._dollyIn(this._getZoomScale(event.deltaY));
    } else if (event.deltaY > 0) {
      this._dollyOut(this._getZoomScale(event.deltaY));
    }
    this.update();
  }
  _handleKeyDown(event) {
    let needsUpdate = false;
    switch (event.code) {
      case this.keys.UP:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          this._rotateUp(_twoPI * this.rotateSpeed / this.domElement.clientHeight);
        } else {
          this._pan(0, this.keyPanSpeed);
        }
        needsUpdate = true;
        break;
      case this.keys.BOTTOM:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          this._rotateUp(-_twoPI * this.rotateSpeed / this.domElement.clientHeight);
        } else {
          this._pan(0, -this.keyPanSpeed);
        }
        needsUpdate = true;
        break;
      case this.keys.LEFT:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          this._rotateLeft(_twoPI * this.rotateSpeed / this.domElement.clientHeight);
        } else {
          this._pan(this.keyPanSpeed, 0);
        }
        needsUpdate = true;
        break;
      case this.keys.RIGHT:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          this._rotateLeft(-_twoPI * this.rotateSpeed / this.domElement.clientHeight);
        } else {
          this._pan(-this.keyPanSpeed, 0);
        }
        needsUpdate = true;
        break;
    }
    if (needsUpdate) {
      event.preventDefault();
      this.update();
    }
  }
  _handleTouchStartRotate(event) {
    if (this._pointers.length === 1) {
      this._rotateStart.set(event.pageX, event.pageY);
    } else {
      const position = this._getSecondPointerPosition(event);
      const x2 = 0.5 * (event.pageX + position.x);
      const y = 0.5 * (event.pageY + position.y);
      this._rotateStart.set(x2, y);
    }
  }
  _handleTouchStartPan(event) {
    if (this._pointers.length === 1) {
      this._panStart.set(event.pageX, event.pageY);
    } else {
      const position = this._getSecondPointerPosition(event);
      const x2 = 0.5 * (event.pageX + position.x);
      const y = 0.5 * (event.pageY + position.y);
      this._panStart.set(x2, y);
    }
  }
  _handleTouchStartDolly(event) {
    const position = this._getSecondPointerPosition(event);
    const dx = event.pageX - position.x;
    const dy = event.pageY - position.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    this._dollyStart.set(0, distance);
  }
  _handleTouchStartDollyPan(event) {
    if (this.enableZoom)
      this._handleTouchStartDolly(event);
    if (this.enablePan)
      this._handleTouchStartPan(event);
  }
  _handleTouchStartDollyRotate(event) {
    if (this.enableZoom)
      this._handleTouchStartDolly(event);
    if (this.enableRotate)
      this._handleTouchStartRotate(event);
  }
  _handleTouchMoveRotate(event) {
    if (this._pointers.length == 1) {
      this._rotateEnd.set(event.pageX, event.pageY);
    } else {
      const position = this._getSecondPointerPosition(event);
      const x2 = 0.5 * (event.pageX + position.x);
      const y = 0.5 * (event.pageY + position.y);
      this._rotateEnd.set(x2, y);
    }
    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const element = this.domElement;
    this._rotateLeft(_twoPI * this._rotateDelta.x / element.clientHeight);
    this._rotateUp(_twoPI * this._rotateDelta.y / element.clientHeight);
    this._rotateStart.copy(this._rotateEnd);
  }
  _handleTouchMovePan(event) {
    if (this._pointers.length === 1) {
      this._panEnd.set(event.pageX, event.pageY);
    } else {
      const position = this._getSecondPointerPosition(event);
      const x2 = 0.5 * (event.pageX + position.x);
      const y = 0.5 * (event.pageY + position.y);
      this._panEnd.set(x2, y);
    }
    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed);
    this._pan(this._panDelta.x, this._panDelta.y);
    this._panStart.copy(this._panEnd);
  }
  _handleTouchMoveDolly(event) {
    const position = this._getSecondPointerPosition(event);
    const dx = event.pageX - position.x;
    const dy = event.pageY - position.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    this._dollyEnd.set(0, distance);
    this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed));
    this._dollyOut(this._dollyDelta.y);
    this._dollyStart.copy(this._dollyEnd);
    const centerX = (event.pageX + position.x) * 0.5;
    const centerY = (event.pageY + position.y) * 0.5;
    this._updateZoomParameters(centerX, centerY);
  }
  _handleTouchMoveDollyPan(event) {
    if (this.enableZoom)
      this._handleTouchMoveDolly(event);
    if (this.enablePan)
      this._handleTouchMovePan(event);
  }
  _handleTouchMoveDollyRotate(event) {
    if (this.enableZoom)
      this._handleTouchMoveDolly(event);
    if (this.enableRotate)
      this._handleTouchMoveRotate(event);
  }
  // pointers
  _addPointer(event) {
    this._pointers.push(event.pointerId);
  }
  _removePointer(event) {
    delete this._pointerPositions[event.pointerId];
    for (let i = 0; i < this._pointers.length; i++) {
      if (this._pointers[i] == event.pointerId) {
        this._pointers.splice(i, 1);
        return;
      }
    }
  }
  _isTrackingPointer(event) {
    for (let i = 0; i < this._pointers.length; i++) {
      if (this._pointers[i] == event.pointerId)
        return true;
    }
    return false;
  }
  _trackPointer(event) {
    let position = this._pointerPositions[event.pointerId];
    if (position === void 0) {
      position = new Vector2();
      this._pointerPositions[event.pointerId] = position;
    }
    position.set(event.pageX, event.pageY);
  }
  _getSecondPointerPosition(event) {
    const pointerId = event.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
    return this._pointerPositions[pointerId];
  }
  //
  _customWheelEvent(event) {
    const mode = event.deltaMode;
    const newEvent = {
      clientX: event.clientX,
      clientY: event.clientY,
      deltaY: event.deltaY
    };
    switch (mode) {
      case 1:
        newEvent.deltaY *= 16;
        break;
      case 2:
        newEvent.deltaY *= 100;
        break;
    }
    if (event.ctrlKey && !this._controlActive) {
      newEvent.deltaY *= 10;
    }
    return newEvent;
  }
};
function onPointerDown2(event) {
  if (this.enabled === false)
    return;
  if (this._pointers.length === 0) {
    this.domElement.setPointerCapture(event.pointerId);
    this.domElement.addEventListener("pointermove", this._onPointerMove);
    window.addEventListener("pointerup", this._onPointerUp);
  }
  if (this._isTrackingPointer(event))
    return;
  this._addPointer(event);
  if (event.pointerType === "touch") {
    this._onTouchStart(event);
  } else {
    this._onMouseDown(event);
  }
}
function onPointerMove2(event) {
  if (this.enabled === false)
    return;
  if (event.pointerType === "touch") {
    this._onTouchMove(event);
  } else {
    this._onMouseMove(event);
  }
}
function onPointerUp2(event) {
  this._removePointer(event);
  switch (this._pointers.length) {
    case 0:
      this.domElement.releasePointerCapture(event.pointerId);
      this.domElement.removeEventListener("pointermove", this._onPointerMove);
      window.removeEventListener("pointerup", this._onPointerUp);
      this.dispatchEvent(_endEvent);
      this.state = _STATE.NONE;
      break;
    case 1:
      const pointerId = this._pointers[0];
      const position = this._pointerPositions[pointerId];
      this._onTouchStart({ pointerId, pageX: position.x, pageY: position.y });
      break;
  }
}
function onMouseDown(event) {
  let mouseAction;
  switch (event.button) {
    case 0:
      mouseAction = this.mouseButtons.LEFT;
      break;
    case 1:
      mouseAction = this.mouseButtons.MIDDLE;
      break;
    case 2:
      mouseAction = this.mouseButtons.RIGHT;
      break;
    default:
      mouseAction = -1;
  }
  switch (mouseAction) {
    case MOUSE.DOLLY:
      if (this.enableZoom === false)
        return;
      this._handleMouseDownDolly(event);
      this.state = _STATE.DOLLY;
      break;
    case MOUSE.ROTATE:
      if (event.ctrlKey || event.metaKey || event.shiftKey) {
        if (this.enablePan === false)
          return;
        this._handleMouseDownPan(event);
        this.state = _STATE.PAN;
      } else {
        if (this.enableRotate === false)
          return;
        this._handleMouseDownRotate(event);
        this.state = _STATE.ROTATE;
      }
      break;
    case MOUSE.PAN:
      if (event.ctrlKey || event.metaKey || event.shiftKey) {
        if (this.enableRotate === false)
          return;
        this._handleMouseDownRotate(event);
        this.state = _STATE.ROTATE;
      } else {
        if (this.enablePan === false)
          return;
        this._handleMouseDownPan(event);
        this.state = _STATE.PAN;
      }
      break;
    default:
      this.state = _STATE.NONE;
  }
  if (this.state !== _STATE.NONE) {
    this.dispatchEvent(_startEvent);
  }
}
function onMouseMove(event) {
  switch (this.state) {
    case _STATE.ROTATE:
      if (this.enableRotate === false)
        return;
      this._handleMouseMoveRotate(event);
      break;
    case _STATE.DOLLY:
      if (this.enableZoom === false)
        return;
      this._handleMouseMoveDolly(event);
      break;
    case _STATE.PAN:
      if (this.enablePan === false)
        return;
      this._handleMouseMovePan(event);
      break;
  }
}
function onMouseWheel(event) {
  if (this.enabled === false || this.enableZoom === false || this.state !== _STATE.NONE)
    return;
  event.preventDefault();
  this.dispatchEvent(_startEvent);
  this._handleMouseWheel(this._customWheelEvent(event));
  this.dispatchEvent(_endEvent);
}
function onKeyDown(event) {
  if (this.enabled === false || this.enablePan === false)
    return;
  this._handleKeyDown(event);
}
function onTouchStart(event) {
  this._trackPointer(event);
  switch (this._pointers.length) {
    case 1:
      switch (this.touches.ONE) {
        case TOUCH.ROTATE:
          if (this.enableRotate === false)
            return;
          this._handleTouchStartRotate(event);
          this.state = _STATE.TOUCH_ROTATE;
          break;
        case TOUCH.PAN:
          if (this.enablePan === false)
            return;
          this._handleTouchStartPan(event);
          this.state = _STATE.TOUCH_PAN;
          break;
        default:
          this.state = _STATE.NONE;
      }
      break;
    case 2:
      switch (this.touches.TWO) {
        case TOUCH.DOLLY_PAN:
          if (this.enableZoom === false && this.enablePan === false)
            return;
          this._handleTouchStartDollyPan(event);
          this.state = _STATE.TOUCH_DOLLY_PAN;
          break;
        case TOUCH.DOLLY_ROTATE:
          if (this.enableZoom === false && this.enableRotate === false)
            return;
          this._handleTouchStartDollyRotate(event);
          this.state = _STATE.TOUCH_DOLLY_ROTATE;
          break;
        default:
          this.state = _STATE.NONE;
      }
      break;
    default:
      this.state = _STATE.NONE;
  }
  if (this.state !== _STATE.NONE) {
    this.dispatchEvent(_startEvent);
  }
}
function onTouchMove(event) {
  this._trackPointer(event);
  switch (this.state) {
    case _STATE.TOUCH_ROTATE:
      if (this.enableRotate === false)
        return;
      this._handleTouchMoveRotate(event);
      this.update();
      break;
    case _STATE.TOUCH_PAN:
      if (this.enablePan === false)
        return;
      this._handleTouchMovePan(event);
      this.update();
      break;
    case _STATE.TOUCH_DOLLY_PAN:
      if (this.enableZoom === false && this.enablePan === false)
        return;
      this._handleTouchMoveDollyPan(event);
      this.update();
      break;
    case _STATE.TOUCH_DOLLY_ROTATE:
      if (this.enableZoom === false && this.enableRotate === false)
        return;
      this._handleTouchMoveDollyRotate(event);
      this.update();
      break;
    default:
      this.state = _STATE.NONE;
  }
}
function onContextMenu(event) {
  if (this.enabled === false)
    return;
  event.preventDefault();
}
function interceptControlDown(event) {
  if (event.key === "Control") {
    this._controlActive = true;
    const document2 = this.domElement.getRootNode();
    document2.addEventListener("keyup", this._interceptControlUp, { passive: true, capture: true });
  }
}
function interceptControlUp(event) {
  if (event.key === "Control") {
    this._controlActive = false;
    const document2 = this.domElement.getRootNode();
    document2.removeEventListener("keyup", this._interceptControlUp, { passive: true, capture: true });
  }
}

// node_modules/@needle-tools/engine/lib/engine-components/GroundProjection.js
var __decorate5 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug39 = getParam("debuggroundprojection");
var GroundProjectedEnv = class extends Component2 {
  constructor() {
    super(...arguments);
    /**
     * If true the projection will be created on awake and onEnable
     * @default false
     */
    __publicField(this, "applyOnAwake", false);
    /**
     * When enabled the position of the projected environment will be adjusted to be centered in the scene (and ground level).
     * @default true
     */
    __publicField(this, "autoFit", true);
    __publicField(this, "_radius", 50);
    __publicField(this, "_height", 3);
    __publicField(this, "_arblending", 0);
    __publicField(this, "_lastEnvironment");
    __publicField(this, "_lastRadius");
    __publicField(this, "_lastHeight");
    __publicField(this, "_projection");
    __publicField(this, "_watcher");
    __publicField(this, "_needsTextureUpdate", false);
    __publicField(this, "_blurrynessShader", null);
    __publicField(this, "_lastBlurriness", -1);
  }
  /**
   * Radius of the projection sphere. Set it large enough so the camera stays inside (make sure the far plane is also large enough)
   * @default 50
   */
  set radius(val) {
    this._radius = val;
    this.updateProjection();
  }
  get radius() {
    return this._radius;
  }
  /**
   * How far the camera that took the photo was above the ground. A larger value will magnify the downward part of the image.
   * @default 3
   */
  set height(val) {
    this._height = val;
    this.updateProjection();
  }
  get height() {
    return this._height;
  }
  /**
   * Blending factor for the AR projection being blended with the scene background.
   * 0 = not visible in AR - 1 = blended with real world background.
   * Values between 0 and 1 control the smoothness of the blend while lower values result in smoother blending.
   * @default 0
   */
  set arBlending(val) {
    this._arblending = val;
    this._needsTextureUpdate = true;
  }
  get arBlending() {
    return this._arblending;
  }
  /** @internal */
  awake() {
    if (this.applyOnAwake)
      this.updateAndCreate();
  }
  /** @internal */
  onEnable() {
    if (this.context.time.frameCount > 0) {
      if (this.applyOnAwake)
        this.updateAndCreate();
    }
    if (!this._watcher) {
      this._watcher = new Watch(this.context.scene, "environment");
      this._watcher.subscribeWrite((_) => {
        this.updateProjection();
      });
    }
  }
  /** @internal */
  onDisable() {
    var _a2, _b;
    (_a2 = this._watcher) == null ? void 0 : _a2.revoke();
    (_b = this._projection) == null ? void 0 : _b.removeFromParent();
  }
  /** @internal */
  onEnterXR() {
    if (!this.activeAndEnabled)
      return;
    this._needsTextureUpdate = true;
    this.updateProjection();
  }
  /** @internal */
  async onLeaveXR() {
    if (!this.activeAndEnabled)
      return;
    await delayForFrames(1);
    this.updateProjection();
  }
  /** @internal */
  onBeforeRender() {
    if (this._projection && this.scene.backgroundRotation) {
      this._projection.rotation.copy(this.scene.backgroundRotation);
    }
    const blurrinessChanged = this.context.scene.backgroundBlurriness !== void 0 && this._lastBlurriness != this.context.scene.backgroundBlurriness && this.context.scene.backgroundBlurriness > 1e-3;
    if (blurrinessChanged) {
      this.updateProjection();
    } else if (this._needsTextureUpdate) {
      this.updateBlurriness();
    }
  }
  updateAndCreate() {
    var _a2;
    this.updateProjection();
    (_a2 = this._watcher) == null ? void 0 : _a2.apply();
  }
  /**
   * Updates the ground projection. This is called automatically when the environment or settings change.
   */
  updateProjection() {
    var _a2, _b, _c, _d, _e;
    if (!this.context.scene.environment) {
      (_a2 = this._projection) == null ? void 0 : _a2.removeFromParent();
      return;
    }
    if (((_b = this.context.xr) == null ? void 0 : _b.isPassThrough) || ((_c = this.context.xr) == null ? void 0 : _c.isAR)) {
      if (this.arBlending === 0) {
        (_d = this._projection) == null ? void 0 : _d.removeFromParent();
        return;
      }
    }
    if (!this.gameObject || this.destroyed) {
      return;
    }
    let needsNewAutoFit = true;
    const offset = 0;
    if (!this._projection || this.context.scene.environment !== this._lastEnvironment || this._height !== this._lastHeight || this._radius !== this._lastRadius) {
      if (debug39)
        console.log("Create/Update Ground Projection", this.context.scene.environment.name);
      (_e = this._projection) == null ? void 0 : _e.removeFromParent();
      if (!this._projection || (this.context.scene.environment !== this._lastEnvironment || this._lastHeight !== this._height || this._lastRadius !== this._radius)) {
        try {
          this._projection = new GroundedSkybox(this.context.scene.environment, this._height, this.radius, 64);
        } catch (e) {
          console.error("Failed to enable GroundProjection for environment", e);
          return;
        }
      } else
        needsNewAutoFit = false;
      this._projection.position.y = this._height - offset;
      this._projection.name = "GroundProjection";
      setVisibleInCustomShadowRendering(this._projection, false);
    } else {
      needsNewAutoFit = false;
    }
    if (!this._projection.parent)
      this.gameObject.add(this._projection);
    if (this.autoFit && needsNewAutoFit) {
      this._projection.updateWorldMatrix(true, true);
      const box2 = getBoundingBox(this.context.scene.children, [this._projection]);
      const floor_y = box2.min.y;
      if (floor_y < Infinity) {
        const wp = getTempVector();
        wp.x = box2.min.x + (box2.max.x - box2.min.x) * 0.5;
        const scale = getWorldScale(this.gameObject).x;
        wp.y = floor_y + this._height * scale - offset;
        wp.z = box2.min.z + (box2.max.z - box2.min.z) * 0.5;
        setWorldPosition(this._projection, wp);
      }
      if (debug39)
        Gizmos.DrawWireBox3(box2, 65280, 5);
    }
    if (this.context.scene.backgroundBlurriness > 1e-3 && this._needsTextureUpdate) {
      this.updateBlurriness();
    }
    this._lastEnvironment = this.context.scene.environment;
    this._lastHeight = this._height;
    this._lastRadius = this._radius;
    this._needsTextureUpdate = false;
  }
  updateBlurriness() {
    var _a2;
    if (!this._projection) {
      return;
    } else if (!this.context.scene.environment) {
      return;
    }
    this._needsTextureUpdate = false;
    if (debug39)
      console.log("Update Blurriness", this.context.scene.backgroundBlurriness);
    this._blurrynessShader ?? (this._blurrynessShader = new ShaderMaterial({
      name: "GroundProjectionBlurriness",
      uniforms: {
        map: { value: this.context.scene.environment },
        blurriness: { value: this.context.scene.backgroundBlurriness },
        blending: { value: 0 },
        alphaFactor: { value: 1 }
      },
      vertexShader: blurVertexShader,
      fragmentShader: blurFragmentShader
    }));
    this._blurrynessShader.depthWrite = false;
    this._blurrynessShader.uniforms.blurriness.value = this.context.scene.backgroundBlurriness;
    this._lastBlurriness = this.context.scene.backgroundBlurriness;
    this.context.scene.environment.needsPMREMUpdate = true;
    const wasTransparent = this._projection.material.transparent;
    this._projection.material.transparent = (((_a2 = this.context.xr) == null ? void 0 : _a2.isAR) === true && this.arBlending > 1e-6) ?? false;
    if (this._projection.material.transparent) {
      this._blurrynessShader.uniforms.blending.value = this.arBlending;
    } else {
      this._blurrynessShader.uniforms.blending.value = 0;
    }
    if (this.context.isInPassThrough) {
      this._blurrynessShader.uniforms.alphaFactor.value = 0.95;
    } else {
      this._blurrynessShader.uniforms.alphaFactor.value = 1;
    }
    if (wasTransparent !== this._projection.material.transparent) {
      this._projection.material.needsUpdate = true;
    }
    this._projection.material.map = Graphics.copyTexture(this.context.scene.environment, this._blurrynessShader);
    this._projection.material.depthTest = true;
    this._projection.material.depthWrite = false;
  }
};
__decorate5([
  serializable()
], GroundProjectedEnv.prototype, "applyOnAwake", void 0);
__decorate5([
  serializable()
], GroundProjectedEnv.prototype, "autoFit", void 0);
__decorate5([
  serializable()
], GroundProjectedEnv.prototype, "radius", null);
__decorate5([
  serializable()
], GroundProjectedEnv.prototype, "height", null);
__decorate5([
  serializable()
], GroundProjectedEnv.prototype, "arBlending", null);
var blurVertexShader = `
  varying vec2 vUv;

  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;
var blurFragmentShader = `
  uniform sampler2D map;
  uniform float blurriness;
  uniform float alphaFactor;
  uniform float blending;
  varying vec2 vUv;

  const float PI = 3.14159265359;

  // Gaussian function
  float gaussian(float x, float sigma) {
    return exp(-(x * x) / (2.0 * sigma * sigma)) / (sqrt(2.0 * PI) * sigma);
  }

  // Custom smoothstep function for desired falloff
  float customSmoothstep(float edge0, float edge1, float x) {
    float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
    return t * t * (3.0 - 2.0 * t);
  }

  void main() {
    vec2 center = vec2(0.0, 0.0);
    vec2 pos = vUv;
    pos.x = 0.0; // Only consider vertical distance
    float distance = length(pos - center);
    
    // Calculate blur amount based on custom falloff
    float blurAmount = customSmoothstep(0.5, 1.0, distance * 2.0);
    blurAmount = clamp(blurAmount, 0.0, 1.0); // Ensure blur amount is within valid range

    // Gaussian blur
    vec2 pixelSize = 1.0 / vec2(textureSize(map, 0));
    vec4 color = vec4(0.0);
    float totalWeight = 0.0;
    int blurSize = int(60.0 * min(1.0, blurriness) * blurAmount); // Adjust blur size based on distance and blurriness
    float lodLevel = log2(float(blurSize)) * 0.5; // Compute LOD level

    for (int x = -blurSize; x <= blurSize; x++) {
        for (int y = -blurSize; y <= blurSize; y++) {
            vec2 offset = vec2(float(x), float(y)) * pixelSize * blurAmount;
            float weight = gaussian(length(vec2(float(x), float(y))), 1000.0 * blurAmount); // Use a fixed sigma value
            color += textureLod(map, vUv + offset, lodLevel) * weight;
            totalWeight += weight;
        }
    }

    color = totalWeight > 0.0 ? color / totalWeight : texture2D(map, vUv);

    gl_FragColor = color;

    float brightness = dot(gl_FragColor.rgb, vec3(0.299, 0.587, 0.114));
    float stepFactor = blending - brightness * .1;
    gl_FragColor.a = pow(1.0 - blending * customSmoothstep(0.35 * stepFactor, 0.45 * stepFactor, distance), 5.);
    gl_FragColor.a *= alphaFactor;
    // gl_FragColor.rgb = vec3(1.0);

    // #include <tonemapping_fragment>
    // #include <colorspace_fragment>
    
    // Uncomment to visualize blur amount
    // gl_FragColor = vec4(blurAmount, 0.0, 0.0, 1.0);
  }
`;

// node_modules/@needle-tools/engine/lib/engine-components/LookAtConstraint.js
var __decorate6 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var LookAtConstraint = class extends Component2 {
  constructor() {
    super(...arguments);
    /**
     * When true the constraint is active.
     */
    __publicField(this, "constraintActive", true);
    /**
     * When true the look at is locked to the position of the assigned sources.
     */
    __publicField(this, "locked", false);
    /**
     * The sources to look at.
     */
    __publicField(this, "sources", []);
  }
};
__decorate6([
  serializable()
], LookAtConstraint.prototype, "constraintActive", void 0);
__decorate6([
  serializable()
], LookAtConstraint.prototype, "locked", void 0);
__decorate6([
  serializable(Object3D)
], LookAtConstraint.prototype, "sources", void 0);

// node_modules/@needle-tools/engine/lib/engine/engine_lifecycle_api.js
function onInitialized(cb, opts) {
  registerFrameEventCallback(cb, ContextEvent.ContextCreated, opts);
  return () => unregisterFrameEventCallback(cb, ContextEvent.ContextCreated);
}
function onClear(cb, opts) {
  registerFrameEventCallback(cb, ContextEvent.ContextClearing, opts);
  return () => unregisterFrameEventCallback(cb, ContextEvent.ContextClearing);
}
function onDestroy(cb, opts) {
  registerFrameEventCallback(cb, ContextEvent.ContextDestroying, opts);
  return () => unregisterFrameEventCallback(cb, ContextEvent.ContextDestroying);
}
function onStart(cb, opts) {
  registerFrameEventCallback(cb, FrameEvent.Start, opts);
  return () => unregisterFrameEventCallback(cb, FrameEvent.Start);
}
function onUpdate(cb, opts) {
  registerFrameEventCallback(cb, FrameEvent.Update, opts);
  return () => unregisterFrameEventCallback(cb, FrameEvent.Update);
}
function onBeforeRender(cb, opts) {
  registerFrameEventCallback(cb, FrameEvent.OnBeforeRender, opts);
  return () => unregisterFrameEventCallback(cb, FrameEvent.OnBeforeRender);
}
function onAfterRender(cb, opts) {
  registerFrameEventCallback(cb, FrameEvent.OnAfterRender, opts);
  return () => unregisterFrameEventCallback(cb, FrameEvent.OnAfterRender);
}

// node_modules/@needle-tools/engine/lib/engine-schemes/vec3.js
var Vec32 = class {
  constructor() {
    __publicField(this, "bb", null);
    __publicField(this, "bb_pos", 0);
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  x() {
    return this.bb.readFloat32(this.bb_pos);
  }
  y() {
    return this.bb.readFloat32(this.bb_pos + 4);
  }
  z() {
    return this.bb.readFloat32(this.bb_pos + 8);
  }
  static sizeOf() {
    return 12;
  }
  static createVec3(builder3, x2, y, z) {
    builder3.prep(4, 12);
    builder3.writeFloat32(z);
    builder3.writeFloat32(y);
    builder3.writeFloat32(x2);
    return builder3.offset();
  }
};

// node_modules/@needle-tools/engine/lib/engine-schemes/transform.js
var Transform = class {
  constructor() {
    __publicField(this, "bb", null);
    __publicField(this, "bb_pos", 0);
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  position(obj) {
    return (obj || new Vec32()).__init(this.bb_pos, this.bb);
  }
  rotation(obj) {
    return (obj || new Vec32()).__init(this.bb_pos + 12, this.bb);
  }
  scale(obj) {
    return (obj || new Vec32()).__init(this.bb_pos + 24, this.bb);
  }
  static sizeOf() {
    return 36;
  }
  static createTransform(builder3, position_x, position_y, position_z, rotation_x, rotation_y, rotation_z, scale_x, scale_y, scale_z) {
    builder3.prep(4, 36);
    builder3.prep(4, 12);
    builder3.writeFloat32(scale_z);
    builder3.writeFloat32(scale_y);
    builder3.writeFloat32(scale_x);
    builder3.prep(4, 12);
    builder3.writeFloat32(rotation_z);
    builder3.writeFloat32(rotation_y);
    builder3.writeFloat32(rotation_x);
    builder3.prep(4, 12);
    builder3.writeFloat32(position_z);
    builder3.writeFloat32(position_y);
    builder3.writeFloat32(position_x);
    return builder3.offset();
  }
};

// node_modules/@needle-tools/engine/lib/engine-schemes/synced-transform-model.js
var SyncedTransformModel = class {
  constructor() {
    __publicField(this, "bb", null);
    __publicField(this, "bb_pos", 0);
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsSyncedTransformModel(bb, obj) {
    return (obj || new SyncedTransformModel()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsSyncedTransformModel(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new SyncedTransformModel()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  guid(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  /**
   * if the transform interpolation should be fast, this is true when the send interval is low and we want to have snappy transforms
   */
  fast() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
  }
  transform(obj) {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? (obj || new Transform()).__init(this.bb_pos + offset, this.bb) : null;
  }
  /**
   * if the server should not save this info
   */
  dontSave() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
  }
  static startSyncedTransformModel(builder3) {
    builder3.startObject(4);
  }
  static addGuid(builder3, guidOffset) {
    builder3.addFieldOffset(0, guidOffset, 0);
  }
  static addFast(builder3, fast) {
    builder3.addFieldInt8(1, +fast, 0);
  }
  static addTransform(builder3, transformOffset) {
    builder3.addFieldStruct(2, transformOffset, 0);
  }
  static addDontSave(builder3, dontSave) {
    builder3.addFieldInt8(3, +dontSave, 0);
  }
  static endSyncedTransformModel(builder3) {
    const offset = builder3.endObject();
    return offset;
  }
  static finishSyncedTransformModelBuffer(builder3, offset) {
    builder3.finish(offset);
  }
  static finishSizePrefixedSyncedTransformModelBuffer(builder3, offset) {
    builder3.finish(offset, void 0, true);
  }
};

// node_modules/@needle-tools/engine/lib/engine/engine_physics.types.js
var PhysicsMaterialCombine;
(function(PhysicsMaterialCombine2) {
  PhysicsMaterialCombine2[PhysicsMaterialCombine2["Average"] = 0] = "Average";
  PhysicsMaterialCombine2[PhysicsMaterialCombine2["Multiply"] = 1] = "Multiply";
  PhysicsMaterialCombine2[PhysicsMaterialCombine2["Minimum"] = 2] = "Minimum";
  PhysicsMaterialCombine2[PhysicsMaterialCombine2["Maximum"] = 3] = "Maximum";
})(PhysicsMaterialCombine || (PhysicsMaterialCombine = {}));
var CollisionDetectionMode;
(function(CollisionDetectionMode2) {
  CollisionDetectionMode2[CollisionDetectionMode2["Discrete"] = 0] = "Discrete";
  CollisionDetectionMode2[CollisionDetectionMode2["Continuous"] = 1] = "Continuous";
})(CollisionDetectionMode || (CollisionDetectionMode = {}));
var RigidbodyConstraints;
(function(RigidbodyConstraints2) {
  RigidbodyConstraints2[RigidbodyConstraints2["None"] = 0] = "None";
  RigidbodyConstraints2[RigidbodyConstraints2["FreezePositionX"] = 2] = "FreezePositionX";
  RigidbodyConstraints2[RigidbodyConstraints2["FreezePositionY"] = 4] = "FreezePositionY";
  RigidbodyConstraints2[RigidbodyConstraints2["FreezePositionZ"] = 8] = "FreezePositionZ";
  RigidbodyConstraints2[RigidbodyConstraints2["FreezePosition"] = 14] = "FreezePosition";
  RigidbodyConstraints2[RigidbodyConstraints2["FreezeRotationX"] = 16] = "FreezeRotationX";
  RigidbodyConstraints2[RigidbodyConstraints2["FreezeRotationY"] = 32] = "FreezeRotationY";
  RigidbodyConstraints2[RigidbodyConstraints2["FreezeRotationZ"] = 64] = "FreezeRotationZ";
  RigidbodyConstraints2[RigidbodyConstraints2["FreezeRotation"] = 112] = "FreezeRotation";
  RigidbodyConstraints2[RigidbodyConstraints2["FreezeAll"] = 126] = "FreezeAll";
})(RigidbodyConstraints || (RigidbodyConstraints = {}));
var Axes;
(function(Axes2) {
  Axes2[Axes2["None"] = 0] = "None";
  Axes2[Axes2["X"] = 2] = "X";
  Axes2[Axes2["Y"] = 4] = "Y";
  Axes2[Axes2["Z"] = 8] = "Z";
  Axes2[Axes2["All"] = -1] = "All";
})(Axes || (Axes = {}));

// node_modules/@needle-tools/engine/lib/engine/engine_util_decorator.js
var validate2 = function(set2, get2) {
  return function(target, propertyKey, descriptor) {
    createPropertyWrapper(target, propertyKey, descriptor, set2, get2);
  };
};
function createPropertyWrapper(target, _propertyKey, descriptor, set2, get2) {
  if (!get2 && !set2 && !target.onValidate)
    return;
  if (descriptor !== void 0) {
    console.error("Invalid usage of validate decorator. Only fields can be validated.", target, _propertyKey, descriptor);
    showBalloonMessage("Invalid usage of validate decorator. Only fields can be validated. Property: " + _propertyKey, LogType.Error);
    return;
  }
  let propertyKey = "";
  if (typeof _propertyKey === "string")
    propertyKey = _propertyKey;
  else
    propertyKey = _propertyKey.name;
  if (target.__internalAwake) {
    const $prop = Symbol(propertyKey);
    const awake = target.__internalAwake;
    target.__internalAwake = function() {
      var _a2;
      if (!this.onValidate) {
        if (isDevEnvironment())
          console.warn('Usage of @validate decorate detected but there is no onValidate method in your class: "' + ((_a2 = target.constructor) == null ? void 0 : _a2.name) + '"');
        return;
      }
      if (this[$prop] === void 0) {
        this[$prop] = this[propertyKey];
        const _val = this[propertyKey];
        if (_val instanceof Vector2 || _val instanceof Vector32 || _val instanceof Vector4 || _val instanceof Quaternion) {
          const vec2 = this[propertyKey];
          const cb = () => {
            this.onValidate(propertyKey);
          };
          watchWrite(vec2, cb);
        }
        Object.defineProperty(this, propertyKey, {
          set: function(v4) {
            var _a3;
            if (this[$isAssigningProperties] === true) {
              this[$prop] = v4;
            } else {
              set2 == null ? void 0 : set2.call(this, v4);
              const oldValue = this[$prop];
              this[$prop] = v4;
              (_a3 = this.onValidate) == null ? void 0 : _a3.call(this, propertyKey, oldValue);
            }
          },
          get: function() {
            get2 == null ? void 0 : get2.call(this);
            return this[$prop];
          }
        });
      }
      awake.call(this);
    };
  }
}
var prefix = function(type) {
  return function(target, _propertyKey, _PropertyDescriptor) {
    let propertyKey = "";
    if (typeof _propertyKey === "string")
      propertyKey = _propertyKey;
    else
      propertyKey = _propertyKey.name;
    const targetType = type.prototype;
    const originalProp = Object.getOwnPropertyDescriptor(targetType, propertyKey);
    if (!(originalProp == null ? void 0 : originalProp.value)) {
      console.warn("Can not apply prefix: type does not have method named", _propertyKey, type);
      return;
    }
    const originalValue = originalProp.value;
    const prefix2 = target[propertyKey];
    Object.defineProperty(targetType, propertyKey, {
      value: function(...args) {
        const res = prefix2 == null ? void 0 : prefix2.call(this, ...args);
        if (res instanceof Promise) {
          res.then((r) => {
            if (r === false)
              return;
            return originalValue.call(this, ...args);
          });
          return;
        }
        if (res === false)
          return;
        return originalValue.call(this, ...args);
      }
    });
  };
};

// node_modules/@needle-tools/engine/lib/engine-components/RigidBody.js
var __decorate7 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var TransformWatch = class {
  constructor(obj, context) {
    __publicField(this, "positionChanged", false);
    __publicField(this, "rotationChanged", false);
    __publicField(this, "position");
    __publicField(this, "quaternion");
    __publicField(this, "_positionKeys", ["x", "y", "z"]);
    __publicField(this, "_quaternionKeys", ["_x", "_y", "_z", "_w"]);
    __publicField(this, "mute", false);
    __publicField(this, "context");
    __publicField(this, "obj");
    __publicField(this, "_positionWatch");
    __publicField(this, "_rotationWatch");
    this.context = context;
    this.obj = obj;
  }
  get isDirty() {
    return this.positionChanged || this.rotationChanged;
  }
  reset(clearPreviousValues = false) {
    this.positionChanged = false;
    this.rotationChanged = false;
    this.mute = false;
    if (clearPreviousValues) {
      if (this.position)
        for (const key of this._positionKeys)
          delete this.position[key];
      if (this.quaternion)
        for (const key of this._quaternionKeys)
          delete this.quaternion[key];
    }
  }
  syncValues() {
    for (const key of this._positionKeys) {
      this.position[key] = this.obj.position[key];
    }
    for (const key of this._quaternionKeys) {
      this.quaternion[key] = this.obj.quaternion[key];
    }
  }
  applyValues() {
    if (this.positionChanged && this.position) {
      for (const key of this._positionKeys) {
        const val = this.position[key];
        if (val !== void 0)
          this.obj.position[key] = val;
      }
    }
    if (this.rotationChanged) {
      if (this.quaternion) {
        for (const key of this._quaternionKeys) {
          const val = this.quaternion[key];
          if (val !== void 0)
            this.obj.quaternion[key] = val;
        }
      }
    }
  }
  start(position, rotation) {
    this.reset();
    if (position) {
      if (!this._positionWatch)
        this._positionWatch = new Watch(this.obj.position, ["x", "y", "z"]);
      this._positionWatch.apply();
      this.position = {};
      this._positionWatch.subscribeWrite((val, prop) => {
        var _a2;
        if (((_a2 = this.context.physics.engine) == null ? void 0 : _a2.isUpdating) || this.mute)
          return;
        const prev = this.position[prop];
        if (Math.abs(prev - val) < 1e-5)
          return;
        this.position[prop] = val;
        this.positionChanged = true;
      });
    }
    if (rotation) {
      if (!this._rotationWatch)
        this._rotationWatch = new Watch(this.obj.quaternion, ["_x", "_y", "_z", "_w"]);
      this._rotationWatch.apply();
      this.quaternion = {};
      this._rotationWatch.subscribeWrite((val, prop) => {
        var _a2;
        if (((_a2 = this.context.physics.engine) == null ? void 0 : _a2.isUpdating) || this.mute)
          return;
        const prev = this.quaternion[prop];
        if (Math.abs(prev - val) < 1e-5)
          return;
        this.quaternion[prop] = val;
        this.rotationChanged = true;
      });
    }
    const original = this.obj.matrixWorld.multiplyMatrices.bind(this.obj.matrixWorld);
    const lastParentMatrix = new Matrix4();
    this.obj.matrixWorld["multiplyMatrices"] = (parent, matrix) => {
      var _a2;
      if (((_a2 = this.context.physics.engine) == null ? void 0 : _a2.isUpdating) || this.mute)
        return original(parent, matrix);
      if (!lastParentMatrix.equals(parent)) {
        this.positionChanged = true;
        this.rotationChanged = true;
        lastParentMatrix.copy(parent);
      }
      return original(parent, matrix);
      ;
    };
  }
  stop() {
    var _a2, _b;
    (_a2 = this._positionWatch) == null ? void 0 : _a2.revoke();
    (_b = this._rotationWatch) == null ? void 0 : _b.revoke();
  }
};
var _Rigidbody = class extends Component2 {
  constructor() {
    super(...arguments);
    /** When true the mass will be automatically calculated by the attached colliders */
    __publicField(this, "autoMass", true);
    __publicField(this, "_mass", 0);
    /**
     * Use gravity is a flag that can be set to false to disable gravity for a specific rigid-body.
     */
    __publicField(this, "useGravity", true);
    /**
     * The center of mass is the point around which the mass of the rigid-body is evenly distributed. It is used to compute the torque applied to the rigid-body when forces are applied to it.
     */
    __publicField(this, "centerOfMass", new Vector32(0, 0, 0));
    /**
     * Constraints are used to lock the position or rotation of an object in a specific axis.
     */
    __publicField(this, "constraints", RigidbodyConstraints.None);
    /**
     * IsKinematic is a flag that can be set to true to make a rigid-body kinematic. Kinematic rigid-bodies are not affected by forces and collisions. They are meant to be animated by the user.
     */
    __publicField(this, "isKinematic", false);
    /** Drag is a force that resists the motion of the rigid-body. It is applied to the center-of-mass of the rigid-body.
     * @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#damping */
    __publicField(this, "drag", 0);
    /** Angular drag is a force that resists the rotation of the rigid-body. It is applied to the center-of-mass of the rigid-body.
     * @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#damping */
    __publicField(this, "angularDrag", 1);
    /**
     * Detect collisions is a flag that can be set to false to disable collision detection for a specific rigid-body.
     */
    __publicField(this, "detectCollisions", true);
    /** The sleeping threshold is the minimum velocity below which a dynamic rigid-body will be put to sleep by the physics engine.
     * @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#sleeping */
    __publicField(this, "sleepThreshold", 0.01);
    /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#continuous-collision-detection */
    __publicField(this, "collisionDetectionMode", CollisionDetectionMode.Discrete);
    __publicField(this, "_gravityScale", 1);
    /** Rigidbodies with higher dominance will be immune to forces originating from contacts with rigidbodies of lower dominance.
     * @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#dominance
     */
    __publicField(this, "dominanceGroup", 0);
    __publicField(this, "_propertiesChanged", false);
    __publicField(this, "_currentVelocity", new Vector32());
    __publicField(this, "_smoothedVelocity", new Vector32());
    __publicField(this, "_smoothedVelocityGetter", new Vector32());
    __publicField(this, "_lastPosition", new Vector32());
    __publicField(this, "_watch");
  }
  /** By default the mass will be automatically calculated (see `autoMass`) by the physics engine using the collider sizes
   * To set the mass manually you can either set the `mass` value or set `autoMass` to `false`
   */
  set mass(value) {
    if (value === this._mass)
      return;
    this._mass = value;
    this._propertiesChanged = true;
    if (this.__didAwake) {
      this.autoMass = false;
    }
  }
  get mass() {
    var _a2, _b;
    if (this.autoMass)
      return ((_b = (_a2 = this.context.physics.engine) == null ? void 0 : _a2.getBody(this)) == null ? void 0 : _b.mass()) ?? -1;
    return this._mass;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  get lockPositionX() {
    return (this.constraints & RigidbodyConstraints.FreezePositionX) !== 0;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  get lockPositionY() {
    return (this.constraints & RigidbodyConstraints.FreezePositionY) !== 0;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  get lockPositionZ() {
    return (this.constraints & RigidbodyConstraints.FreezePositionZ) !== 0;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  get lockRotationX() {
    return (this.constraints & RigidbodyConstraints.FreezeRotationX) !== 0;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  get lockRotationY() {
    return (this.constraints & RigidbodyConstraints.FreezeRotationY) !== 0;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  get lockRotationZ() {
    return (this.constraints & RigidbodyConstraints.FreezeRotationZ) !== 0;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  set lockPositionX(v4) {
    if (v4)
      this.constraints |= RigidbodyConstraints.FreezePositionX;
    else
      this.constraints &= ~RigidbodyConstraints.FreezePositionX;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  set lockPositionY(v4) {
    if (v4)
      this.constraints |= RigidbodyConstraints.FreezePositionY;
    else
      this.constraints &= ~RigidbodyConstraints.FreezePositionY;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  set lockPositionZ(v4) {
    if (v4)
      this.constraints |= RigidbodyConstraints.FreezePositionZ;
    else
      this.constraints &= ~RigidbodyConstraints.FreezePositionZ;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  set lockRotationX(v4) {
    if (v4)
      this.constraints |= RigidbodyConstraints.FreezeRotationX;
    else
      this.constraints &= ~RigidbodyConstraints.FreezeRotationX;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  set lockRotationY(v4) {
    if (v4)
      this.constraints |= RigidbodyConstraints.FreezeRotationY;
    else
      this.constraints &= ~RigidbodyConstraints.FreezeRotationY;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  set lockRotationZ(v4) {
    if (v4)
      this.constraints |= RigidbodyConstraints.FreezeRotationZ;
    else
      this.constraints &= ~RigidbodyConstraints.FreezeRotationZ;
  }
  /** Gravity is such a common force that it is implemented as a special case (even if it could easily be implemented by the user using force application). Note however that a change of gravity won't automatically wake-up the sleeping bodies so keep in mind that you may want to wake them up manually before a gravity change.
   *
   * It is possible to change the way gravity affects a specific rigid-body by setting the rigid-body's gravity scale to a value other than 1.0. The magnitude of the gravity applied to this body will be multiplied by this scaling factor. Therefore, a gravity scale set to 0.0 will disable gravity for the rigid-body whereas a gravity scale set to 2.0 will make it twice as strong. A negative value will flip the direction of the gravity for this rigid-body.
   * @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#gravity
   */
  set gravityScale(val) {
    this._gravityScale = val;
  }
  get gravityScale() {
    return this._gravityScale;
  }
  awake() {
    this._watch = void 0;
    this._propertiesChanged = false;
  }
  onEnable() {
    var _a2;
    if (!this._watch) {
      this._watch = new TransformWatch(this.gameObject, this.context);
    }
    this._watch.start(true, true);
    this.startCoroutine(this.beforePhysics(), FrameEvent.LateUpdate);
    if (isDevEnvironment() && !((_a2 = this.context.physics.engine) == null ? void 0 : _a2.getBody(this))) {
      if (!globalThis["NEEDLE_USE_RAPIER"])
        console.warn(`Rigidbody could not be created: Rapier physics are explicitly disabled.`);
      else
        console.warn(`Rigidbody could not be created. Ensure "(${this.name}" has a Collider component.`);
    }
  }
  onDisable() {
    var _a2, _b;
    (_a2 = this._watch) == null ? void 0 : _a2.stop();
    (_b = this.context.physics.engine) == null ? void 0 : _b.removeBody(this);
  }
  onDestroy() {
    var _a2;
    (_a2 = this.context.physics.engine) == null ? void 0 : _a2.removeBody(this);
  }
  onValidate() {
    this._propertiesChanged = true;
  }
  // need to do this right before updating physics to prevent rendered object glitching through physical bodies
  *beforePhysics() {
    var _a2, _b, _c, _d;
    while (true) {
      if (this._propertiesChanged) {
        this._propertiesChanged = false;
        (_a2 = this.context.physics.engine) == null ? void 0 : _a2.updateProperties(this);
      }
      if ((_b = this._watch) == null ? void 0 : _b.isDirty) {
        this._watch.mute = true;
        this._watch.applyValues();
        (_c = this.context.physics.engine) == null ? void 0 : _c.updateBody(this, this._watch.positionChanged, this._watch.rotationChanged);
        this._watch.reset();
      } else
        (_d = this._watch) == null ? void 0 : _d.syncValues();
      this.captureVelocity();
      yield;
    }
  }
  /** Teleport the rigidbody to a new position in the world.
   * Will reset forces before setting the object world position
   * @param pt The new position to teleport the object to (world space)
   * @param localspace When true the object will be teleported in local space, otherwise in world space
   * */
  teleport(pt, localspace = true) {
    var _a2;
    (_a2 = this._watch) == null ? void 0 : _a2.reset(true);
    if (localspace)
      this.gameObject.position.set(pt.x, pt.y, pt.z);
    else
      this.setWorldPosition(pt.x, pt.y, pt.z);
    this.resetForcesAndTorques();
    this.resetVelocities();
  }
  resetForces(wakeup = true) {
    var _a2;
    (_a2 = this.context.physics.engine) == null ? void 0 : _a2.resetForces(this, wakeup);
  }
  resetTorques(wakeup = true) {
    var _a2;
    (_a2 = this.context.physics.engine) == null ? void 0 : _a2.resetTorques(this, wakeup);
  }
  resetVelocities() {
    this.setVelocity(0, 0, 0);
    this.setAngularVelocity(0, 0, 0);
  }
  resetForcesAndTorques() {
    this.resetForces();
    this.resetTorques();
  }
  /** When a dynamic rigid-body doesn't move (or moves very slowly) during a few seconds, it will be marked as sleeping by the physics pipeline. Rigid-bodies marked as sleeping are no longer simulated by the physics engine until they are woken up. That way the physics engine doesn't waste any computational resources simulating objects that don't actually move. They are woken up automatically whenever another non-sleeping rigid-body starts interacting with them (either with a joint, or with one of its attached colliders generating contacts).
   * @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#sleeping */
  wakeUp() {
    var _a2;
    (_a2 = this.context.physics.engine) == null ? void 0 : _a2.wakeup(this);
  }
  get isSleeping() {
    var _a2;
    return (_a2 = this.context.physics.engine) == null ? void 0 : _a2.isSleeping(this);
  }
  /** Call to force an update of the rigidbody properties in the physics engine */
  updateProperties() {
    var _a2;
    this._propertiesChanged = false;
    return (_a2 = this.context.physics.engine) == null ? void 0 : _a2.updateProperties(this);
  }
  /** Forces affect the rigid-body's acceleration whereas impulses affect the rigid-body's velocity
   * the acceleration change is equal to the force divided by the mass:
   * @link see https://rapier.rs/docs/user_guides/javascript/rigid_bodies#forces-and-impulses */
  applyForce(vec2, _rel, wakeup = true) {
    var _a2;
    if (this._propertiesChanged)
      this.updateProperties();
    (_a2 = this.context.physics.engine) == null ? void 0 : _a2.addForce(this, vec2, wakeup);
  }
  /** Forces affect the rigid-body's acceleration whereas impulses affect the rigid-body's velocity
   * the velocity change is equal to the impulse divided by the mass
   * @link see https://rapier.rs/docs/user_guides/javascript/rigid_bodies#forces-and-impulses */
  applyImpulse(vec2, wakeup = true) {
    var _a2;
    if (this._propertiesChanged)
      this.updateProperties();
    (_a2 = this.context.physics.engine) == null ? void 0 : _a2.applyImpulse(this, vec2, wakeup);
  }
  /** @link see https://rapier.rs/docs/user_guides/javascript/rigid_bodies#forces-and-impulses */
  setForce(x2, y, z, wakeup = true) {
    var _a2, _b, _c;
    (_a2 = this.context.physics.engine) == null ? void 0 : _a2.resetForces(this, wakeup);
    if (typeof x2 === "number") {
      y ?? (y = 0);
      z ?? (z = 0);
      (_b = this.context.physics.engine) == null ? void 0 : _b.addForce(this, { x: x2, y, z }, wakeup);
    } else {
      (_c = this.context.physics.engine) == null ? void 0 : _c.addForce(this, x2, wakeup);
    }
  }
  /** The velocity of a dynamic rigid-body controls how fast it is moving in time. The velocity is applied at the center-of-mass of the rigid-body. This method returns the current linear velocity of the rigid-body.
   * @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#velocity */
  getVelocity() {
    var _a2;
    const vel = (_a2 = this.context.physics.engine) == null ? void 0 : _a2.getLinearVelocity(this);
    if (!vel)
      return this._currentVelocity.set(0, 0, 0);
    this._currentVelocity.x = vel.x;
    this._currentVelocity.y = vel.y;
    this._currentVelocity.z = vel.z;
    return this._currentVelocity;
  }
  setVelocity(x2, y, z, wakeup = true) {
    var _a2, _b;
    if (x2 instanceof Vector32) {
      const vec2 = x2;
      (_a2 = this.context.physics.engine) == null ? void 0 : _a2.setLinearVelocity(this, vec2, wakeup);
      return;
    }
    if (y === void 0 || z === void 0)
      return;
    (_b = this.context.physics.engine) == null ? void 0 : _b.setLinearVelocity(this, { x: x2, y, z }, wakeup);
  }
  /** The velocity of a dynamic rigid-body controls how fast it is moving in time. The velocity is applied at the center-of-mass of the rigid-body. This method returns the current angular velocity of the rigid-body.
   * @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#velocity */
  getAngularVelocity() {
    var _a2;
    const vel = (_a2 = this.context.physics.engine) == null ? void 0 : _a2.getAngularVelocity(this);
    if (!vel)
      return this._currentVelocity.set(0, 0, 0);
    this._currentVelocity.x = vel.x;
    this._currentVelocity.y = vel.y;
    this._currentVelocity.z = vel.z;
    return this._currentVelocity;
  }
  setAngularVelocity(x2, y, z, wakeup = true) {
    var _a2, _b;
    if (typeof x2 === "object") {
      const vec2 = x2;
      (_a2 = this.context.physics.engine) == null ? void 0 : _a2.setAngularVelocity(this, vec2, wakeup);
      return;
    }
    if (y === void 0 || z === void 0 || typeof y === "boolean") {
      console.warn("setAngularVelocity expects either a Vec3 or 3 numbers");
      return;
    }
    (_b = this.context.physics.engine) == null ? void 0 : _b.setAngularVelocity(this, { x: x2, y, z }, wakeup);
  }
  setTorque(x2, y, z) {
    if (typeof x2 === "number") {
      this.setAngularVelocity(x2, y, z);
    } else
      this.setAngularVelocity(x2);
  }
  /** Returns the rigidbody velocity smoothed over ~ 10 frames */
  get smoothedVelocity() {
    this._smoothedVelocityGetter.copy(this._smoothedVelocity);
    return this._smoothedVelocityGetter.multiplyScalar(1 / this.context.time.deltaTime);
  }
  /**d
   * @deprecated not used anymore and will be removed in a future update
   */
  setBodyFromGameObject(_velocity = null) {
  }
  captureVelocity() {
    const wp = getWorldPosition(this.gameObject);
    this.gameObject.matrixWorld.decompose(_Rigidbody.tempPosition, tempQuaternion, tempScale);
    const vel = wp.sub(this._lastPosition);
    this._lastPosition.copy(_Rigidbody.tempPosition);
    this._smoothedVelocity.lerp(vel, this.context.time.deltaTime / 0.1);
  }
};
var Rigidbody = _Rigidbody;
__publicField(Rigidbody, "tempPosition", new Vector32());
__decorate7([
  validate2()
], Rigidbody.prototype, "autoMass", void 0);
__decorate7([
  serializable()
], Rigidbody.prototype, "mass", null);
__decorate7([
  validate2(),
  serializable()
], Rigidbody.prototype, "useGravity", void 0);
__decorate7([
  serializable(Vector32)
], Rigidbody.prototype, "centerOfMass", void 0);
__decorate7([
  validate2(),
  serializable()
], Rigidbody.prototype, "constraints", void 0);
__decorate7([
  validate2(),
  serializable()
], Rigidbody.prototype, "isKinematic", void 0);
__decorate7([
  validate2(),
  serializable()
], Rigidbody.prototype, "drag", void 0);
__decorate7([
  validate2(),
  serializable()
], Rigidbody.prototype, "angularDrag", void 0);
__decorate7([
  validate2(),
  serializable()
], Rigidbody.prototype, "detectCollisions", void 0);
__decorate7([
  validate2(),
  serializable()
], Rigidbody.prototype, "sleepThreshold", void 0);
__decorate7([
  validate2(),
  serializable()
], Rigidbody.prototype, "collisionDetectionMode", void 0);
__decorate7([
  validate2()
], Rigidbody.prototype, "_gravityScale", void 0);
__decorate7([
  validate2()
], Rigidbody.prototype, "dominanceGroup", void 0);
var tempPosition = new Vector32();
var tempQuaternion = new Quaternion();
var tempScale = new Vector32();

// node_modules/@needle-tools/engine/lib/engine-components/SyncedTransform.js
var debug40 = getParam("debugsync");
var SyncedTransformIdentifier = "STRS";
registerBinaryType(SyncedTransformIdentifier, SyncedTransformModel.getRootAsSyncedTransformModel);
var builder = new Builder();
function createTransformModel(guid, b, fast = true) {
  builder.clear();
  const guidObj = builder.createString(guid);
  SyncedTransformModel.startSyncedTransformModel(builder);
  SyncedTransformModel.addGuid(builder, guidObj);
  SyncedTransformModel.addFast(builder, fast);
  const p = b.worldPosition;
  const r = b.worldEuler;
  const s = b.gameObject.scale;
  SyncedTransformModel.addTransform(builder, Transform.createTransform(builder, p.x, p.y, p.z, r.x, r.y, r.z, s.x, s.y, s.z));
  const res = SyncedTransformModel.endSyncedTransformModel(builder);
  builder.finish(res, SyncedTransformIdentifier);
  return builder.asUint8Array();
}
var FAST_ACTIVE_SYNCTRANSFORMS = 0;
var FAST_INTERVAL = 0;
onUpdate((ctx) => {
  var _a2;
  const isRunningOnGlitch = (_a2 = ctx.connection.currentServerUrl) == null ? void 0 : _a2.includes("glitch");
  const threshold = isRunningOnGlitch ? 10 : 40;
  FAST_INTERVAL = Math.floor(FAST_ACTIVE_SYNCTRANSFORMS / threshold);
  FAST_ACTIVE_SYNCTRANSFORMS = 0;
  if (debug40 && FAST_INTERVAL > 0)
    console.log("Sync Transform Fast Interval", FAST_INTERVAL);
});
var SyncedTransform = class extends Component2 {
  constructor() {
    super(...arguments);
    // public autoOwnership: boolean = true;
    __publicField(this, "overridePhysics", true);
    __publicField(this, "interpolatePosition", true);
    __publicField(this, "interpolateRotation", true);
    __publicField(this, "fastMode", false);
    __publicField(this, "syncDestroy", false);
    // private _state!: SyncedTransformModel;
    __publicField(this, "_model", null);
    __publicField(this, "_needsUpdate", true);
    __publicField(this, "rb", null);
    __publicField(this, "_wasKinematic", false);
    __publicField(this, "_receivedDataBefore", false);
    __publicField(this, "_targetPosition");
    __publicField(this, "_targetRotation");
    __publicField(this, "_receivedFastUpdate", false);
    __publicField(this, "_shouldRequestOwnership", false);
    __publicField(this, "joinedRoomCallback", null);
    __publicField(this, "receivedDataCallback", null);
    __publicField(this, "tempEuler", new Euler());
    __publicField(this, "receivedUpdate", false);
    __publicField(this, "lastWorldPos");
    __publicField(this, "lastWorldRotation");
  }
  /** Request ownership of an object - you need to be connected to a room */
  requestOwnership() {
    if (debug40)
      console.log("Request ownership");
    if (!this._model) {
      this._shouldRequestOwnership = true;
      this._needsUpdate = true;
    } else
      this._model.requestOwnership();
  }
  hasOwnership() {
    var _a2;
    return ((_a2 = this._model) == null ? void 0 : _a2.hasOwnership) ?? void 0;
  }
  isOwned() {
    var _a2;
    return (_a2 = this._model) == null ? void 0 : _a2.isOwned;
  }
  /** @internal */
  awake() {
    if (debug40)
      console.log("new instance", this.guid, this);
    this._receivedDataBefore = false;
    this._targetPosition = new Vector32();
    this._targetRotation = new Quaternion();
    this.lastWorldPos = new Vector32();
    this.lastWorldRotation = new Quaternion();
    this.rb = GameObject.getComponentInChildren(this.gameObject, Rigidbody);
    if (this.rb) {
      this._wasKinematic = this.rb.isKinematic;
    }
    this.receivedUpdate = true;
    this._model = new OwnershipModel(this.context.connection, this.guid);
    if (this.context.connection.isConnected) {
      this.tryGetLastState();
    }
    this.joinedRoomCallback = this.tryGetLastState.bind(this);
    this.context.connection.beginListen(RoomEvents.JoinedRoom, this.joinedRoomCallback);
    this.receivedDataCallback = this.onReceivedData.bind(this);
    this.context.connection.beginListenBinary(SyncedTransformIdentifier, this.receivedDataCallback);
  }
  /** @internal */
  onDestroy() {
    if (this.syncDestroy)
      sendDestroyed(this.guid, this.context.connection);
    this._model = null;
    this.context.connection.stopListen(RoomEvents.JoinedRoom, this.joinedRoomCallback);
    this.context.connection.stopListenBinary(SyncedTransformIdentifier, this.receivedDataCallback);
  }
  tryGetLastState() {
    const model = this.context.connection.tryGetState(this.guid);
    if (model)
      this.onReceivedData(model);
  }
  onReceivedData(data) {
    var _a2;
    if (this.destroyed)
      return;
    if (typeof data.guid === "function" && data.guid() === this.guid) {
      if (debug40)
        console.log("new data", this.context.connection.connectionId, this.context.time.frameCount, this.guid, data);
      this.receivedUpdate = true;
      this._receivedFastUpdate = data.fast();
      const transform = data.transform();
      if (transform) {
        InstancingUtil.markDirty(this.gameObject, true);
        const position = transform.position();
        if (position) {
          if (this.interpolatePosition)
            (_a2 = this._targetPosition) == null ? void 0 : _a2.set(position.x(), position.y(), position.z());
          if (!this.interpolatePosition || !this._receivedDataBefore)
            this.setWorldPosition(position.x(), position.y(), position.z());
        }
        const rotation = transform.rotation();
        if (rotation) {
          this.tempEuler.set(rotation.x(), rotation.y(), rotation.z());
          if (this.interpolateRotation) {
            this._targetRotation.setFromEuler(this.tempEuler);
          }
          if (!this.interpolateRotation || !this._receivedDataBefore)
            setWorldEuler(this.gameObject, this.tempEuler);
        }
      }
      this._receivedDataBefore = true;
    }
  }
  /** @internal */
  onEnable() {
    this.lastWorldPos.copy(this.worldPosition);
    this.lastWorldRotation.copy(this.worldQuaternion);
    this._needsUpdate = true;
    if (this._model) {
      this._model.updateIsOwned();
    }
  }
  /** @internal */
  onDisable() {
    if (this._model)
      this._model.freeOwnership();
  }
  /** @internal */
  onBeforeRender() {
    if (!this.activeAndEnabled || !this.context.connection.isConnected)
      return;
    if (!this.context.connection.isInRoom || !this._model) {
      if (debug40)
        console.log("no model or room", this.name, this.guid, this.context.connection.isInRoom);
      return;
    }
    if (this._shouldRequestOwnership) {
      this._shouldRequestOwnership = false;
      this._model.requestOwnership();
    }
    const wp = this.worldPosition;
    const wr = this.worldQuaternion;
    if (this._model.isOwned && !this.receivedUpdate) {
      const worlddiff = wp.distanceTo(this.lastWorldPos);
      const worldRot = wr.angleTo(this.lastWorldRotation);
      const threshold = this._model.hasOwnership || this.fastMode ? 1e-4 : 1e-3;
      if (worlddiff > threshold || worldRot > threshold) {
        if (!this._model.hasOwnership) {
          if (debug40)
            console.log(this.guid, "reset because not owned but", this.gameObject.name, this.lastWorldPos);
          this.worldPosition = this.lastWorldPos;
          wp.copy(this.lastWorldPos);
          this.worldQuaternion = this.lastWorldRotation;
          wr.copy(this.lastWorldRotation);
          InstancingUtil.markDirty(this.gameObject, true);
          this._needsUpdate = false;
        } else {
          this._needsUpdate = true;
        }
      }
    }
    if (this._model && !this._model.hasOwnership && this._model.isOwned) {
      if (this._receivedDataBefore) {
        const factor = this._receivedFastUpdate || this.fastMode ? 0.5 : 0.3;
        const t2 = factor;
        let requireMarkDirty = false;
        if (this.interpolatePosition && this._targetPosition) {
          const pos = this.worldPosition;
          pos.lerp(this._targetPosition, t2);
          this.worldPosition = pos;
          requireMarkDirty = true;
        }
        if (this.interpolateRotation && this._targetRotation) {
          const rot = this.worldQuaternion;
          rot.slerp(this._targetRotation, t2);
          this.worldQuaternion = rot;
          requireMarkDirty = true;
        }
        if (requireMarkDirty)
          InstancingUtil.markDirty(this.gameObject, true);
      }
    }
    this.receivedUpdate = false;
    this.lastWorldPos.copy(wp);
    this.lastWorldRotation.copy(wr);
    if (!this._model)
      return;
    if (!this._model || this._model.hasOwnership === void 0 || !this._model.hasOwnership) {
      return;
    }
    if (this.rb && this.overridePhysics) {
      if (this._wasKinematic !== void 0) {
        if (debug40)
          console.log("reset kinematic", this.rb.name, this._wasKinematic);
        this.rb.isKinematic = this._wasKinematic;
      }
    }
    const updateInterval = 10;
    const fastUpdate = this.rb || this.fastMode;
    if (this._needsUpdate && (updateInterval <= 0 || updateInterval > 0 && this.context.time.frameCount % updateInterval === 0 || fastUpdate)) {
      FAST_ACTIVE_SYNCTRANSFORMS++;
      if (fastUpdate && FAST_INTERVAL > 0 && this.context.time.frameCount % FAST_INTERVAL !== 0)
        return;
      if (debug40)
        console.log("send update", this.context.connection.connectionId, this.guid, this.gameObject.name, this.gameObject.guid);
      this._needsUpdate = false;
      const st = createTransformModel(this.guid, this, fastUpdate ? true : false);
      this.context.connection.sendBinary(st);
    }
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/ui/BaseUIComponent.js
var debug41 = getParam("debugshadowcomponents");
__webpack_exports__Block.prototype["interactable"] = {
  get() {
    return this.interactive;
  },
  set(value) {
    this.interactable = value;
  }
};
var $shadowDomOwner = Symbol("shadowDomOwner");
var BaseUIComponent = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "_shadowComponent", null);
    __publicField(this, "_controlsChildLayout", true);
    __publicField(this, "_root");
    // private _intermediate?: Object3D;
    __publicField(this, "_parentComponent");
  }
  /** Is this object on the root of the UI hierarchy ? */
  isRoot() {
    var _a2;
    return ((_a2 = this.Root) == null ? void 0 : _a2.gameObject) === this.gameObject;
  }
  /** Access the parent canvas component */
  get canvas() {
    const cv = this.Root;
    if (cv == null ? void 0 : cv.isCanvas)
      return cv;
    return null;
  }
  /** @deprecated use `canvas` */
  get Canvas() {
    return this.canvas;
  }
  /** Mark the UI dirty which will trigger an THREE-Mesh-UI update */
  markDirty() {
    EventSystem.markUIDirty(this.context);
  }
  /** the underlying three-mesh-ui */
  get shadowComponent() {
    return this._shadowComponent;
  }
  set shadowComponent(val) {
    this._shadowComponent = val;
  }
  get controlsChildLayout() {
    return this._controlsChildLayout;
  }
  set controlsChildLayout(val) {
    this._controlsChildLayout = val;
    if (this.shadowComponent) {
      this.shadowComponent.autoLayout = val;
    }
  }
  get Root() {
    if (this._root === void 0) {
      this._root = GameObject.getComponentInParent(this.gameObject, UIRootComponent);
    }
    return this._root;
  }
  __internalNewInstanceCreated(args) {
    super.__internalNewInstanceCreated(args);
    this.shadowComponent = null;
    this._root = void 0;
    this._parentComponent = void 0;
    return this;
  }
  onEnable() {
    super.onEnable();
  }
  /** Add a three-mesh-ui object to the UI hierarchy
   * @param container the three-mesh-ui object to add
   * @param parent the parent component to add the object to
  */
  addShadowComponent(container, parent) {
    var _a2;
    if (!container)
      return;
    this.removeShadowComponent();
    const searchFrom = this.isRoot() ? this.gameObject : this.gameObject.parent;
    this._parentComponent = GameObject.getComponentInParent(searchFrom, BaseUIComponent);
    if (!this._parentComponent) {
      console.warn(`Component "${this.name}" doesn't have a UI parent anywhere. Do you have an UI element outside a Canvas? UI components must be a child of a Canvas component`, this);
      return;
    }
    container.name = this.name + " (" + (this.constructor.name ?? "UI") + ")";
    container.autoLayout = this._parentComponent.controlsChildLayout;
    container[$shadowDomOwner] = this;
    this.setShadowComponentOwner(container);
    let needsUpdate = false;
    if (((_a2 = this.Root) == null ? void 0 : _a2.gameObject) === this.gameObject) {
      this.gameObject.add(container);
    } else {
      const targetShadowComponent = this._parentComponent.shadowComponent;
      if (targetShadowComponent) {
        targetShadowComponent == null ? void 0 : targetShadowComponent.add(container);
        needsUpdate = true;
      }
    }
    this.shadowComponent = container;
    if (parent && parent.shadowComponent && this.shadowComponent) {
      parent.shadowComponent.add(this.shadowComponent);
    }
    if (showGizmos) {
      container.add(new AxesHelper(0.5));
    }
    this.onAfterAddedToScene();
    if (needsUpdate)
      __webpack_exports__update();
    if (debug41)
      console.warn("Added shadow component", this.shadowComponent);
  }
  setShadowComponentOwner(current) {
    if (!current)
      return;
    if (current[$shadowDomOwner] === void 0 || current[$shadowDomOwner] === this) {
      current[$shadowDomOwner] = this;
      if (current.children) {
        for (const ch of current.children) {
          this.setShadowComponentOwner(ch);
        }
      }
    }
  }
  traverseOwnedShadowComponents(current, owner, callback) {
    if (!current)
      return;
    if (current[$shadowDomOwner] === owner) {
      callback(current);
      for (const ch of current.children) {
        this.traverseOwnedShadowComponents(ch, owner, callback);
      }
    }
  }
  /** Remove the underlying UI object from the hierarchy */
  removeShadowComponent() {
    if (this.shadowComponent) {
      this.shadowComponent.removeFromParent();
    }
  }
  onAfterAddedToScene() {
  }
  setInteractable(value) {
    if (this.shadowComponent) {
      this.shadowComponent.interactable = value;
    }
  }
};
var UIRootComponent = class extends BaseUIComponent {
  awake() {
    super.awake();
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/ui/PointerEvents.js
var PointerEventData = class {
  constructor(input, event) {
    /** the original event */
    __publicField(this, "event");
    /**
     * mouse button 0 === LEFT, 1 === MIDDLE, 2 === RIGHT
     * */
    __publicField(this, "button");
    __publicField(this, "buttonName");
    __publicField(this, "_used", false);
    __publicField(this, "_propagationStopped", false);
    /**@ignore internal flag, pointer captured (we dont want to see it in intellisense) */
    __publicField(this, "z__pointer_ctured", false);
    /**@ignore internal flag, pointer capture released */
    __publicField(this, "z__pointer_cture_rleased", false);
    /** Who initiated this event */
    __publicField(this, "inputSource");
    /** The object this event hit or interacted with */
    __publicField(this, "object");
    /** The world position of this event */
    __publicField(this, "point");
    /** The object-space normal of this event */
    __publicField(this, "normal");
    /** */
    __publicField(this, "face");
    /** The distance of the hit point from the origin */
    __publicField(this, "distance");
    /** The instance ID of an object hit by a raycast (if a instanced object was hit) */
    __publicField(this, "instanceId");
    /** The three intersection */
    __publicField(this, "intersection");
    __publicField(this, "isDown");
    __publicField(this, "isUp");
    __publicField(this, "isPressed");
    __publicField(this, "isClick");
    __publicField(this, "isDoubleClick");
    __publicField(this, "input");
    this.event = event;
    this.input = input;
    this.button = event.button;
  }
  /** the index of the used device
   * mouse and touch are always 0, controller is the gamepad index or XRController index
  */
  get deviceIndex() {
    return this.event.deviceIndex;
  }
  /** a combination of the pointerId + button to uniquely identify the exact input (e.g. LeftController:Button0 = 0, RightController:Button1 = 101) */
  get pointerId() {
    return this.event.pointerId;
  }
  get pressure() {
    return this.event.pressure;
  }
  /** @returns `true` when `use()` has been called. Default: false */
  get used() {
    return this._used;
  }
  /** mark this event to be used */
  use() {
    if (this._used)
      return;
    this._used = true;
    this.event.use();
  }
  get propagationStopped() {
    return this._propagationStopped;
  }
  /** Call this method to stop immediate propagation on the `event` object.
   * WARNING: this is currently equivalent to stopImmediatePropagation
   */
  stopPropagation() {
    this._propagationStopped = true;
    this.event.stopImmediatePropagation();
  }
  /** Call this method to stop immediate propagation on the `event` object.
   */
  stopImmediatePropagation() {
    this._propagationStopped = true;
    this.event.stopImmediatePropagation();
  }
  /** Call this method in `onPointerDown` or `onPointerMove` to receive onPointerMove events for this pointerId even when the pointer has left the object until you call `releasePointerCapture` or when the pointerUp event happens
  */
  setPointerCapture() {
    this.z__pointer_ctured = true;
  }
  /** call this method in `onPointerDown` or `onPointerMove` to stop receiving onPointerMove events */
  releasePointerCapture() {
    this.z__pointer_cture_rleased = true;
  }
  /** Returns the input target ray mode e.g. "screen" for 2D mouse and touch events */
  get mode() {
    return this.event.mode;
  }
  clone() {
    const clone = new PointerEventData(this.input, this.event);
    Object.assign(clone, this);
    return clone;
  }
  /**@deprecated use use() */
  Use() {
    this.use();
  }
  /**@deprecated use stopPropagation() */
  StopPropagation() {
    this.event.stopImmediatePropagation();
  }
};
function hasPointerEventComponent(obj, event) {
  const res = GameObject.foreachComponent(obj, (comp) => {
    if (!comp.enabled)
      return void 0;
    const handler = comp;
    if (event) {
      switch (event) {
        case "pointerdown":
          if (handler.onPointerDown)
            return true;
          break;
        case "pointerup":
          if (handler.onPointerUp || handler.onPointerClick)
            return true;
          break;
        case "pointermove":
          if (handler.onPointerEnter || handler.onPointerExit || handler.onPointerMove)
            return true;
          break;
      }
    } else {
      if (handler.onPointerDown || handler.onPointerUp || handler.onPointerEnter || handler.onPointerExit || handler.onPointerClick)
        return true;
    }
    return void 0;
  }, false);
  if (res === true)
    return true;
  return false;
}

// node_modules/@needle-tools/engine/lib/engine-components/EventList.js
var argumentsBuffer = new Array();
var CallInfo = class {
  constructor(target, methodName, args, enabled) {
    /**
     * When the CallInfo is enabled it will be invoked when the EventList is invoked
     */
    __publicField(this, "enabled", true);
    /**
     * The target object to invoke the method on OR the function to invoke
     */
    __publicField(this, "target");
    __publicField(this, "methodName");
    /**
     * The arguments to invoke this method with
     */
    __publicField(this, "arguments");
    this.target = target;
    this.methodName = methodName || null;
    this.arguments = args;
    if (enabled != void 0)
      this.enabled = enabled;
  }
  get canClone() {
    return this.target instanceof Object;
  }
  invoke(...args) {
    if (this.enabled === false)
      return;
    if (typeof this.target === "function") {
      if (this.arguments) {
        argumentsBuffer.length = 0;
        if (args !== void 0 && args.length > 0)
          argumentsBuffer.push(...args);
        argumentsBuffer.push(...this.arguments);
        this.target(...this.arguments);
        argumentsBuffer.length = 0;
      } else {
        this.target(...args);
      }
    } else if (this.methodName != null) {
      const method = this.target[this.methodName];
      if (typeof method === "function") {
        if (this.arguments) {
          argumentsBuffer.length = 0;
          if (args !== void 0 && args.length > 0)
            argumentsBuffer.push(...args);
          argumentsBuffer.push(...this.arguments);
          method.call(this.target, ...argumentsBuffer);
          argumentsBuffer.length = 0;
        } else {
          method.call(this.target, ...args);
        }
      } else {
        if (this.arguments) {
          this.target[this.methodName] = this.arguments[0] || args[0];
        } else {
          this.target[this.methodName] = args[0];
        }
      }
    }
  }
};
var isUpperCase = (string) => /^[A-Z]*$/.test(string);
var EventListEvent = class extends Event {
  constructor() {
    super(...arguments);
    __publicField(this, "args");
  }
};
var EventList = class {
  constructor(evts) {
    /** checked during instantiate to create a new instance */
    __publicField(this, "isEventList", true);
    __publicField(this, "target");
    __publicField(this, "key");
    __publicField(this, "_isInvoking", false);
    // TODO: can we make functions serializable?
    __publicField(this, "methods", []);
    __publicField(this, "_methodsCopy", []);
    this.methods = [];
    if (Array.isArray(evts)) {
      for (const evt of evts) {
        if (evt instanceof CallInfo) {
          this.methods.push(evt);
        } else if (typeof evt === "function") {
          this.methods.push(new CallInfo(evt));
        }
      }
    } else {
      if (typeof evts === "function") {
        this.methods.push(new CallInfo(evts));
      }
    }
  }
  /**
   * @internal Used by the Needle Engine instantiate call to remap the event listeners to the new instance
   */
  __internalOnInstantiate(ctx) {
    var _a2;
    const newMethods2 = new Array();
    for (let i = 0; i < this.methods.length; i++) {
      const method = this.methods[i];
      if (method.target instanceof Function) {
      } else {
        const target = method.target;
        let key = target == null ? void 0 : target.uuid;
        if (target) {
          key = target.guid;
        }
        if (key) {
          const newTarget = ctx[key];
          if (newTarget) {
            const newArguments = (_a2 = method.arguments) == null ? void 0 : _a2.map((arg) => {
              if (arg instanceof Object && arg.uuid) {
                return ctx[arg.uuid];
              } else if (arg == null ? void 0 : arg.isComponent) {
                return ctx[arg.guid];
              }
              return arg;
            });
            newMethods2.push(new CallInfo(newTarget.clone, method.methodName, newArguments, method.enabled));
          } else if (isDevEnvironment()) {
            console.warn("Could not find target for event listener");
          }
        }
      }
    }
    const newInstance = new EventList(newMethods2);
    return newInstance;
  }
  // TODO: serialization should not take care of the args but instead give them to the eventlist directly
  // so we can handle passing them on here instead of in the serializer
  // this would also allow us to pass them on to the component EventTarget
  /** set an event target to try invoke the EventTarget dispatchEvent when this EventList is invoked */
  setEventTarget(key, target) {
    this.key = key;
    this.target = target;
    if (this.key !== void 0) {
      let temp = "";
      let foundFirstLetter = false;
      for (const c2 of this.key) {
        if (foundFirstLetter && isUpperCase(c2))
          temp += "-";
        foundFirstLetter = true;
        temp += c2.toLowerCase();
      }
      this.key = temp;
    }
  }
  /** How many callback methods are subscribed to this event */
  get listenerCount() {
    var _a2;
    return ((_a2 = this.methods) == null ? void 0 : _a2.length) ?? 0;
  }
  /** If the event is currently being invoked */
  get isInvoking() {
    return this._isInvoking;
  }
  static from(...evts) {
    return new EventList(evts);
  }
  /** Invoke all the methods that are subscribed to this event */
  invoke(...args) {
    var _a2;
    if (this._isInvoking) {
      console.warn("Circular event invocation detected. Please check your event listeners for circular references.", this);
      return false;
    }
    if (((_a2 = this.methods) == null ? void 0 : _a2.length) <= 0)
      return false;
    this._isInvoking = true;
    try {
      this._methodsCopy.length = 0;
      this._methodsCopy.push(...this.methods);
      for (const m2 of this._methodsCopy) {
        m2.invoke(...args);
      }
      if (typeof this.target === "object" && typeof this.key === "string") {
        const fn2 = this.target["dispatchEvent"];
        if (typeof fn2 === "function") {
          const evt = new EventListEvent(this.key);
          evt.args = args;
          fn2.call(this.target, evt);
        }
      }
    } finally {
      this._isInvoking = false;
      this._methodsCopy.length = 0;
    }
    return true;
  }
  /** Add a new event listener to this event */
  addEventListener(cb) {
    this.methods.push(new CallInfo(cb));
    return cb;
  }
  removeEventListener(cb) {
    if (!cb)
      return;
    for (let i = this.methods.length - 1; i >= 0; i--) {
      if (this.methods[i].target === cb) {
        this.methods[i].enabled = false;
        this.methods.splice(i, 1);
      }
    }
  }
  removeAllEventListeners() {
    this.methods.length = 0;
  }
};

// node_modules/@needle-tools/engine/lib/engine/engine_serialization_builtin_serializer.js
var ColorSerializer = class extends TypeSerializer {
  constructor() {
    super([Color, RGBAColor], "ColorSerializer");
  }
  onDeserialize(data) {
    if (data === void 0 || data === null)
      return;
    if (data.a !== void 0) {
      return new RGBAColor(data.r, data.g, data.b, data.a);
    } else if (data.alpha !== void 0) {
      return new RGBAColor(data.r, data.g, data.b, data.alpha);
    }
    return new Color(data.r, data.g, data.b);
  }
  onSerialize(data) {
    if (data === void 0 || data === null)
      return;
    if (data.a !== void 0)
      return { r: data.r, g: data.g, b: data.b, a: data.a };
    else
      return { r: data.r, g: data.g, b: data.b };
  }
};
var colorSerializer = new ColorSerializer();
var EulerSerializer = class extends TypeSerializer {
  constructor() {
    super([Euler], "EulerSerializer");
  }
  onDeserialize(data, _context) {
    if (data === void 0 || data === null)
      return void 0;
    if (data.order) {
      return new Euler(data.x, data.y, data.z, data.order);
    } else if (data.x != void 0) {
      return new Euler(data.x, data.y, data.z);
    }
    return void 0;
  }
  onSerialize(data, _context) {
    return { x: data.x, y: data.y, z: data.z, order: data.order };
  }
};
var euler = new EulerSerializer();
var ObjectSerializer = class extends TypeSerializer {
  constructor() {
    super(Object3D, "ObjectSerializer");
  }
  onSerialize(data, context) {
    if (context.objectToNode !== void 0 && data.uuid) {
      const node = context.objectToNode[data.uuid];
      if (debugExtension)
        console.log(node, data.name, data.uuid);
      return { node };
    }
    return void 0;
  }
  onDeserialize(data, context) {
    var _a2, _b, _c;
    if (typeof data === "string") {
      if (data.endsWith(".glb") || data.endsWith(".gltf")) {
        if (context.serializable instanceof Array) {
          if (context.serializable.includes(AssetReference))
            return void 0;
        }
        if (isDevEnvironment())
          showBalloonWarning("Detected wrong usage of @serializable with Object3D or GameObject. Instead you should use AssetReference here! Please see the console for details.");
        const scriptname = (_b = (_a2 = context.target) == null ? void 0 : _a2.constructor) == null ? void 0 : _b.name;
        console.warn(`Wrong usage of @serializable detected in your script "${scriptname}"

It looks like you used @serializable(Object3D) or @serializable(GameObject) for a prefab or scene reference which is exported to a separate glTF file.

To fix this please change your code to:

@serializable(AssetReference)
${context.path}! : AssetReference;
\0`);
      }
      return void 0;
    }
    if (data) {
      if (data.node !== void 0 && context.nodeToObject) {
        const res = context.nodeToObject[data.node];
        if (debugExtension)
          console.log("Deserialized object reference?", data, res, context == null ? void 0 : context.nodeToObject);
        if (!res)
          console.warn("Did not find node: " + data.node, context.nodeToObject, context.object);
        return res;
      } else if (data.guid) {
        if (!context.context) {
          console.error("Missing context");
          return void 0;
        }
        let res = void 0;
        const gltfScene = (_c = context.gltf) == null ? void 0 : _c.scene;
        if (gltfScene) {
          res = GameObject.findByGuid(data.guid, gltfScene);
        }
        if (!res) {
          res = GameObject.findByGuid(data.guid, context.context.scene);
        }
        if (!res) {
          if (isDevEnvironment() || debugExtension)
            console.warn("Could not resolve object reference", context.path, data, context.target, context.context.scene);
          data["could_not_resolve"] = true;
        } else {
          if (res && res.isComponent === true) {
            if (debugExtension)
              console.warn("Deserialized object reference is a component");
            res = res.gameObject;
          }
          if (debugExtension)
            console.log("Deserialized object reference?", data, res, context == null ? void 0 : context.nodeToObject);
        }
        return res;
      }
    }
    return void 0;
  }
};
var objectSerializer = new ObjectSerializer();
var ComponentSerializer = class extends TypeSerializer {
  constructor() {
    super([Component2, Component2], "ComponentSerializer");
  }
  onSerialize(data, _context) {
    if (data == null ? void 0 : data.guid) {
      return { guid: data.guid };
    }
    return void 0;
  }
  onDeserialize(data, context) {
    var _a2;
    if (data == null ? void 0 : data.guid) {
      if (data.___persistentAsset) {
        if (debugExtension)
          console.log("Skipping component deserialization because it's a persistent asset", data);
        return void 0;
      }
      const currentPath = context.path;
      if (debugExtension)
        console.log(data.guid, context.root, context.object, context.target);
      let res = this.findObjectForGuid(data.guid, context.root);
      if (res) {
        return res;
      }
      if (context.context) {
        res = this.findObjectForGuid(data.guid, (_a2 = context.context) == null ? void 0 : _a2.scene);
        if (res)
          return res;
      }
      if (isDevEnvironment() || debugExtension) {
        console.warn('Could not resolve component reference: "' + currentPath + '" using guid ' + data.guid, context.target);
      }
      data["could_not_resolve"] = true;
      return void 0;
    }
    return void 0;
  }
  findObjectForGuid(guid, root) {
    if (root["guid"] === guid)
      return root;
    const res = GameObject.foreachComponent(root, (c2) => {
      if (c2.guid === guid)
        return c2;
      return void 0;
    }, false);
    if (res !== void 0)
      return res;
    for (let i = 0; i < root.children.length; i++) {
      const child = root.children[i];
      const res2 = this.findObjectForGuid(guid, child);
      if (res2)
        return res2;
    }
  }
};
var componentSerializer = new ComponentSerializer();
var $eventListDebugInfo = Symbol("eventListDebugInfo");
var EventListSerializer = class extends TypeSerializer {
  constructor() {
    super([EventList]);
  }
  onSerialize(_data, _context) {
    console.log("TODO: SERIALIZE EVENT");
    return void 0;
  }
  onDeserialize(data, context) {
    var _a2, _b, _c;
    if (typeof data === "function") {
      const evtList = new EventList([new CallInfo(data, null, [], true)]);
      return evtList;
    } else if (data && data.type === "EventList") {
      if (debugExtension)
        console.log("DESERIALIZE EVENT", data);
      const fns = new Array();
      if (data.calls && Array.isArray(data.calls)) {
        for (const call of data.calls) {
          let deserializeArgument = function(arg) {
            if (typeof arg === "object") {
              let argRes = objectSerializer.onDeserialize(arg, context);
              if (!argRes)
                argRes = componentSerializer.onDeserialize(arg, context);
              if (argRes)
                return argRes;
            }
            return arg;
          };
          if (debugExtension)
            console.log(call);
          let target = componentSerializer.findObjectForGuid(call.target, context.root);
          if (!target && ((_a2 = context.context) == null ? void 0 : _a2.scene)) {
            target = componentSerializer.findObjectForGuid(call.target, (_b = context.context) == null ? void 0 : _b.scene);
          }
          const hasMethod = ((_c = call.method) == null ? void 0 : _c.length) > 0;
          if (target && hasMethod) {
            const printWarningMethodNotFound = () => {
              const uppercaseMethodName = call.method[0].toUpperCase() + call.method.slice(1);
              if (typeof target[uppercaseMethodName] === "function") {
                console.warn(`EventList method:
Could not find method ${call.method} on object ${target.name}. Please rename ${call.method} to ${uppercaseMethodName}?
`, target[uppercaseMethodName], "\n in script: ", target);
                showBalloonWarning("EventList methods must start with lowercase letter, see console for details");
                return;
              } else {
                console.warn(`EventList method:
Could not find method ${call.method} on object ${target.name}`, target, typeof target[call.method]);
              }
            };
            const method = target[call.method];
            if (typeof method !== "function") {
              let foundMethod = false;
              let currentPrototype = target;
              while (currentPrototype) {
                const desc = Object.getOwnPropertyDescriptor(currentPrototype, call.method);
                if (desc && (desc.writable === true || desc.set)) {
                  foundMethod = true;
                  break;
                }
                currentPrototype = Object.getPrototypeOf(currentPrototype);
              }
              if (!foundMethod && (isDevEnvironment() || debugExtension))
                printWarningMethodNotFound();
            }
          }
          if (target) {
            let args = call.argument;
            if (args !== void 0) {
              args = deserializeArgument(args);
            } else if (call.arguments !== void 0) {
              args = call.arguments.map(deserializeArgument);
            }
            const method = target[call.method];
            if (!method) {
              console.warn(`EventList method not found: "${call.method}" on ${target == null ? void 0 : target.name}`);
            } else {
              if (args !== void 0 && !Array.isArray(args)) {
                args = [args];
              }
              const fn2 = new CallInfo(target, call.method, args, call.enabled);
              fns.push(fn2);
            }
          } else if (isDevEnvironment()) {
            console.warn("[Debug] EventList: Could not find event listener in scene", call, context.object, data);
          }
        }
      }
      const evt = new EventList(fns);
      if (debugExtension)
        console.log(evt);
      const eventListOwner = context.target;
      if (eventListOwner !== void 0 && context.path !== void 0) {
        evt.setEventTarget(context.path, eventListOwner);
      }
      return evt;
    }
    return void 0;
  }
};
var eventListSerializer = new EventListSerializer();
var cloneOriginalMap = /* @__PURE__ */ new WeakMap();
var textureClone = Texture.prototype.clone;
Texture.prototype.clone = function() {
  const clone = textureClone.call(this);
  if (!cloneOriginalMap.has(clone)) {
    cloneOriginalMap.set(clone, this);
  }
  return clone;
};
var RenderTextureSerializer = class extends TypeSerializer {
  constructor() {
    super([RenderTexture, WebGLRenderTarget]);
  }
  onSerialize(_data, _context) {
  }
  onDeserialize(data, context) {
    if (data instanceof Texture && context.type === RenderTexture) {
      let tex = data;
      if (cloneOriginalMap.has(tex)) {
        const original = cloneOriginalMap.get(tex);
        tex = original;
      }
      tex.isRenderTargetTexture = true;
      tex.flipY = true;
      tex.offset.y = 1;
      tex.repeat.y = -1;
      tex.needsUpdate = true;
      tex.mipmaps = [];
      if (tex instanceof CompressedTexture) {
        tex["isCompressedTexture"] = false;
        tex.format = RGBAFormat;
      }
      const rt = new RenderTexture(tex.image.width, tex.image.height, {
        colorSpace: LinearSRGBColorSpace
      });
      rt.texture = tex;
      return rt;
    }
    return void 0;
  }
};
new RenderTextureSerializer();
var UriSerializer = class extends TypeSerializer {
  constructor() {
    super([URL]);
  }
  onSerialize(_data, _context) {
    return null;
  }
  onDeserialize(data, _context) {
    if (typeof data === "string" && data.length > 0) {
      return resolveUrl(_context.gltfId, data);
    }
    return void 0;
  }
};
new UriSerializer();

// node_modules/@needle-tools/engine/lib/engine-components/ui/Raycaster.js
var __decorate8 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var Raycaster2 = class extends Component2 {
  awake() {
    EventSystem.createIfNoneExists(this.context);
  }
  onEnable() {
    var _a2;
    (_a2 = EventSystem.get(this.context)) == null ? void 0 : _a2.register(this);
  }
  onDisable() {
    var _a2;
    (_a2 = EventSystem.get(this.context)) == null ? void 0 : _a2.unregister(this);
  }
};
var ObjectRaycaster = class extends Raycaster2 {
  constructor() {
    super(...arguments);
    __publicField(this, "targets", null);
    __publicField(this, "raycastHits", []);
    __publicField(this, "ignoreSkinnedMeshes", false);
  }
  start() {
    this.targets = [this.gameObject];
  }
  performRaycast(opts = null) {
    if (!this.targets)
      return null;
    opts ?? (opts = new RaycastOptions());
    opts.targets = this.targets;
    opts.results = this.raycastHits;
    opts.useAcceleratedRaycast = true;
    const orig = opts.testObject;
    if (this.ignoreSkinnedMeshes) {
      opts.testObject = (obj) => {
        if (obj instanceof SkinnedMesh) {
          return "continue in children";
        }
        if (orig)
          return orig(obj);
        return true;
      };
    }
    const hits = this.context.physics.raycast(opts);
    opts.testObject = orig;
    return hits;
  }
};
__decorate8([
  serializable()
], ObjectRaycaster.prototype, "ignoreSkinnedMeshes", void 0);
var GraphicRaycaster = class extends ObjectRaycaster {
  // eventCamera: Camera | null = null;
  // ignoreReversedGraphics: boolean = false;
  // rootRaycaster: GraphicRaycaster | null = null;
  constructor() {
    super();
    this.ignoreSkinnedMeshes = true;
  }
};
var _SpatialGrabRaycaster = class extends Raycaster2 {
  performRaycast(_opts) {
    if (!NeedleXRSession.active)
      return null;
    if (!_SpatialGrabRaycaster.allow)
      return null;
    if (!(_opts == null ? void 0 : _opts.ray))
      return null;
    const rayOrigin = _opts.ray.origin;
    const radius = 0.015;
    return this.context.physics.sphereOverlap(rayOrigin, radius, false, true);
  }
};
var SpatialGrabRaycaster = _SpatialGrabRaycaster;
/**
 * Use to disable SpatialGrabRaycaster globally
 */
__publicField(SpatialGrabRaycaster, "allow", true);

// node_modules/@needle-tools/engine/lib/engine-components/ui/RaycastUtils.js
var UIRaycastUtils = class {
  /** returns the real object when dealing with shadow UI */
  static getObject(obj) {
    const shadowOwner = obj[$shadowDomOwner];
    if (shadowOwner) {
      if (shadowOwner.isComponent === true)
        obj = shadowOwner.gameObject;
      else
        obj = shadowOwner;
    }
    return obj;
  }
  static isInteractable(obj, out) {
    if (out) {
      out.canvasGroup = void 0;
      out.graphic = void 0;
    }
    if (obj === null || obj === void 0 || !obj.visible)
      return false;
    obj = this.getObject(obj);
    if (!obj.visible)
      return false;
    const canvasGroup = this.tryFindCanvasGroup(obj);
    if ((canvasGroup == null ? void 0 : canvasGroup.isCanvasGroup) === true) {
      if (out)
        out.canvasGroup = canvasGroup;
      if (canvasGroup.blocksRaycasts === false)
        return false;
      if (canvasGroup.interactable === false)
        return false;
    }
    const graphic = foreachComponent(obj, (c2) => {
      if (c2.isGraphic === true)
        return c2;
      return void 0;
    }, false);
    if (out) {
      if ((graphic == null ? void 0 : graphic.isGraphic) === true)
        out.graphic = graphic;
    }
    if ((graphic == null ? void 0 : graphic.raycastTarget) === false)
      return false;
    if ((graphic == null ? void 0 : graphic.layer) === 2)
      return false;
    return true;
  }
  static tryFindCanvasGroup(obj) {
    if (!obj)
      return null;
    const res = foreachComponent(obj, (c2) => {
      const gr = c2;
      if (gr.blocksRaycasts !== void 0 && gr.interactable !== void 0)
        return gr;
      return void 0;
    }, false);
    if (res !== void 0)
      return res;
    return this.tryFindCanvasGroup(obj.parent);
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/ui/Utils.js
function tryGetUIComponent(obj) {
  const owner = obj[$shadowDomOwner];
  if (owner) {
    return owner;
  }
  if (obj.parent) {
    return tryGetUIComponent(obj.parent);
  }
  return null;
}
function isUIObject(obj) {
  return obj["isUI"] === true || typeof obj[$shadowDomOwner] === "object";
}
function updateRenderSettings(shadowComponent, settings) {
  if (!shadowComponent)
    return;
  const mat = shadowComponent["material"];
  if ((mat == null ? void 0 : mat.isMaterial) === true) {
    const parent = shadowComponent.parent;
    if (parent && parent["isText"] === true) {
    }
    mat.side = settings.doubleSided ?? true ? DoubleSide : FrontSide;
    mat.shadowSide = settings.doubleSided ? DoubleSide : FrontSide;
    shadowComponent.castShadow = settings.castShadows ? settings.castShadows : false;
    shadowComponent.receiveShadow = settings.receiveShadows ? settings.receiveShadows : false;
  }
  for (const ch of shadowComponent.children) {
    updateRenderSettings(ch, settings);
  }
}
function onChange(caller, field, callback) {
  if (caller[field] === void 0) {
    console.warn("Field", field, "is undefined on", caller);
  }
  const res = Proxy.revocable(caller[field], {
    // get(target, prop, receiver) {
    //     return Reflect.get(target, prop, receiver);
    // },
    set(target, prop, value, receiver) {
      const currentValue = target[prop];
      const res2 = Reflect.set(target, prop, value, receiver);
      callback(value, currentValue);
      return res2;
    }
  });
  const revoke = res.revoke;
  const original = caller[field];
  res.revoke = () => {
    caller[field] = original;
    revoke();
  };
  caller[field] = res.proxy;
  return res;
}
var $scheduledActionKey = Symbol("Scheduled action");
function scheduleAction(caller, action, timing = FrameEvent.OnBeforeRender) {
  let cache = caller[$scheduledActionKey];
  if (!cache)
    cache = caller[$scheduledActionKey] = {};
  const key = action.name;
  if (!cache[timing])
    cache[timing] = {};
  const actions = cache[timing];
  const existing = actions[key];
  if (existing)
    return;
  function* gen() {
    action == null ? void 0 : action.call(caller);
    actions[key] = null;
  }
  const coroutine = caller.startCoroutine(gen(), timing);
  actions[key] = coroutine;
}

// node_modules/@needle-tools/engine/lib/engine-components/ui/EventSystem.js
var debug42 = getParam("debugeventsystem");
var EventSystemEvents;
(function(EventSystemEvents2) {
  EventSystemEvents2["BeforeHandleInput"] = "BeforeHandleInput";
  EventSystemEvents2["AfterHandleInput"] = "AfterHandleInput";
})(EventSystemEvents || (EventSystemEvents = {}));
var _EventSystem = class extends Component2 {
  constructor() {
    super();
    __publicField(this, "raycaster", []);
    /**
     * all pointers that have pressed something
     *
     * key: pointerId
     * value: object that was pressed, data of the pointer event, handlers that are releavant to the event
    */
    __publicField(this, "pressedByID", /* @__PURE__ */ new Map());
    /**
     * all hovered objects
     *
     * key: pointerId
     * value: object that is hovered, data of the pointer event
     */
    __publicField(this, "hoveredByID", /* @__PURE__ */ new Map());
    /**
     * Handle an pointer event from the input system
     */
    __publicField(this, "onPointerEvent", (pointerEvent) => {
      if (pointerEvent === void 0)
        return;
      if (pointerEvent.propagationStopped)
        return;
      if (pointerEvent.defaultPrevented)
        return;
      if (pointerEvent.used)
        return;
      const data = new PointerEventData(this.context.input, pointerEvent);
      this._currentPointerEventName = pointerEvent.type;
      data.inputSource = this.context.input;
      data.isClick = pointerEvent.isClick;
      data.isDoubleClick = pointerEvent.isDoubleClick;
      data.isDown = pointerEvent.type == InputEvents.PointerDown;
      data.isUp = pointerEvent.type == InputEvents.PointerUp;
      data.isPressed = this.context.input.getPointerPressed(pointerEvent.pointerId);
      if (debug42) {
        if (data.isDown)
          console.log("DOWN", data.pointerId);
        else if (data.isUp)
          console.log("UP", data.pointerId);
        if (data.isClick)
          console.log("CLICK", data.pointerId);
      }
      const options = new RaycastOptions();
      if (pointerEvent.hasRay) {
        options.ray = pointerEvent.ray;
      } else {
        options.screenPoint = this.context.input.getPointerPositionRC(pointerEvent.pointerId);
      }
      const hits = this.performRaycast(options);
      if (hits) {
        for (const hit of hits) {
          hit.event = pointerEvent;
          pointerEvent.intersections.push(hit);
        }
        if (pointerEvent.origin.onPointerHits) {
          pointerEvent.origin.onPointerHits({
            sender: this,
            event: pointerEvent,
            hits
          });
        }
      }
      if (debug42 && data.isClick) {
        showBalloonMessage("EventSystem: " + data.pointerId + " - " + this.context.time.frame + " - Up:" + data.isUp + ", Down:" + data.isDown);
      }
      const evt = {
        sender: this,
        args: data,
        hasActiveUI: this.currentActiveMeshUIComponents.length > 0
      };
      this.dispatchEvent(new CustomEvent(EventSystemEvents.BeforeHandleInput, { detail: evt }));
      this.handleIntersections(hits, data);
      this.dispatchEvent(new CustomEvent(EventSystemEvents.AfterHandleInput, { detail: evt }));
    });
    __publicField(this, "_sortedHits", []);
    /**
     * cache for objects that we want to raycast against. It's cleared before each call to performRaycast invoking raycasters
     */
    __publicField(this, "_testObjectsCache", /* @__PURE__ */ new Map());
    /** that's the raycaster that is CURRENTLY being used for raycasting (the shouldRaycastObject method uses this) */
    __publicField(this, "_currentlyActiveRaycaster", null);
    __publicField(this, "_currentPointerEventName", null);
    /**
     * Checks if an object that we encounter has an event component and if it does, we add it to our objects cache
     * If it doesnt we tell our raycasting system to ignore it and continue in the child hierarchy
     * We do this to avoid raycasts against objects that are not going to be used by the event system
     * Because there's no component callback to be invoked anyways.
     * This is especially important to avoid expensive raycasts against SkinnedMeshes
     *
     * Further optimizations would be to check what type of event we're dealing with
     * For example if an event component has only an onPointerClick method we don't need to raycast during movement events
     * */
    __publicField(this, "shouldRaycastObject", (obj) => {
      var _a2;
      let uiOwner = null;
      const isUI = isUIObject(obj);
      if (isUI) {
        uiOwner = (_a2 = obj[$shadowDomOwner]) == null ? void 0 : _a2.gameObject;
      }
      if (this._testObjectsCache.has(obj) || uiOwner && this._testObjectsCache.has(uiOwner)) {
        const prev = this._testObjectsCache.get(obj);
        if (prev === false)
          return "continue in children";
        return true;
      } else {
        let hasEventComponent = hasPointerEventComponent(obj, this._currentPointerEventName);
        if (!hasEventComponent && uiOwner)
          hasEventComponent = hasPointerEventComponent(uiOwner, this._currentPointerEventName);
        if (hasEventComponent) {
          this._testObjectsCache.set(obj, true);
          for (const ch of obj.children)
            this.shouldRaycastObject_AddToYesCache(ch);
          return true;
        }
        this._testObjectsCache.set(obj, false);
        return "continue in children";
      }
    });
    __publicField(this, "_sortingBuffer", []);
    __publicField(this, "_noDepthTestingResults", []);
    __publicField(this, "out", {});
    /** the list of component handlers that requested pointerCapture for a specific pointerId */
    __publicField(this, "_capturedPointer", {});
    __publicField(this, "pointerEnterSymbol", Symbol("pointerEnter"));
    __publicField(this, "pointerExitSymbol", Symbol("pointerExit"));
    __publicField(this, "currentActiveMeshUIComponents", []);
    _EventSystem.systems.push(this);
  }
  static createIfNoneExists(context) {
    if (!this.didSearchEventSystem) {
      this.didSearchEventSystem = true;
      if (_EventSystem.systems.length <= 0) {
        _EventSystem.systems.push(...GameObject.findObjectsOfType(_EventSystem, context));
      }
    }
    for (const sys of _EventSystem.systems) {
      if (sys.context === context)
        return;
    }
    const go = new Object3D();
    GameObject.addComponent(go, _EventSystem);
    context.scene.add(go);
  }
  static get systems() {
    const context = Context.Current;
    if (!this._eventSystemMap.has(context)) {
      this._eventSystemMap.set(context, []);
    }
    return this._eventSystemMap.get(context);
  }
  static get(ctx) {
    const systems = this._eventSystemMap.get(ctx);
    if (systems && systems.length > 0)
      return systems[0];
    return null;
  }
  static get instance() {
    return this.systems[0];
  }
  //@ts-ignore
  static ensureUpdateMeshUI(instance, context, force = false) {
    MeshUIHelper.update(instance, context, force);
  }
  static markUIDirty(_context) {
    MeshUIHelper.markDirty();
  }
  get hasActiveUI() {
    return this.currentActiveMeshUIComponents.length > 0;
  }
  get isHoveringObjects() {
    return this.hoveredByID.size > 0;
  }
  onDestroy() {
    _EventSystem.systems.splice(_EventSystem.systems.indexOf(this), 1);
  }
  start() {
    if (this.raycaster.length <= 0) {
      const res = GameObject.findObjectOfType(Raycaster2, this.context);
      if (!res) {
        const rc = GameObject.addComponent(this.context.scene, ObjectRaycaster);
        this.raycaster.push(rc);
        if (isDevEnvironment() || debug42)
          console.warn("Added an ObjectRaycaster to the scene because no raycaster was found.");
      }
    }
  }
  register(rc) {
    var _a2;
    if (rc && this.raycaster && !this.raycaster.includes(rc))
      (_a2 = this.raycaster) == null ? void 0 : _a2.push(rc);
  }
  unregister(rc) {
    var _a2, _b;
    const i = (_a2 = this.raycaster) == null ? void 0 : _a2.indexOf(rc);
    if (i !== void 0 && i !== -1) {
      (_b = this.raycaster) == null ? void 0 : _b.splice(i, 1);
    }
  }
  onEnable() {
    this.context.input.addEventListener(InputEvents.PointerDown, this.onPointerEvent);
    this.context.input.addEventListener(InputEvents.PointerUp, this.onPointerEvent);
    this.context.input.addEventListener(InputEvents.PointerMove, this.onPointerEvent);
  }
  onDisable() {
    this.context.input.removeEventListener(InputEvents.PointerDown, this.onPointerEvent);
    this.context.input.removeEventListener(InputEvents.PointerUp, this.onPointerEvent);
    this.context.input.removeEventListener(InputEvents.PointerMove, this.onPointerEvent);
  }
  onBeforeRender() {
    this.resetMeshUIStates();
  }
  shouldRaycastObject_AddToYesCache(obj) {
    this._testObjectsCache.set(obj, true);
    for (const ch of obj.children) {
      this.shouldRaycastObject_AddToYesCache(ch);
    }
  }
  /** the raycast filter is always overriden */
  performRaycast(opts) {
    if (!this.raycaster)
      return null;
    this._testObjectsCache.clear();
    this._sortedHits.length = 0;
    if (!opts)
      opts = new RaycastOptions();
    opts.testObject = this.shouldRaycastObject;
    for (const rc of this.raycaster) {
      if (!rc.activeAndEnabled)
        continue;
      this._currentlyActiveRaycaster = rc;
      const res = rc.performRaycast(opts);
      this._currentlyActiveRaycaster = null;
      if (res && res.length > 0) {
        this._sortedHits.push(...res);
      }
    }
    this._sortedHits.sort((a, b) => {
      return a.distance - b.distance;
    });
    return this._sortedHits;
  }
  assignHitInformation(args, hit) {
    if (!hit) {
      args.intersection = void 0;
      args.point = void 0;
      args.normal = void 0;
      args.face = void 0;
      args.distance = void 0;
      args.instanceId = void 0;
    } else {
      args.intersection = hit;
      args.point = hit.point;
      args.normal = hit.normal;
      args.face = hit.face;
      args.distance = hit.distance;
      args.instanceId = hit.instanceId;
    }
  }
  handleIntersections(hits, args) {
    var _a2;
    if (hits == null ? void 0 : hits.length) {
      hits = this.sortCandidates(hits);
      for (const hit of hits) {
        if (args.event.immediatePropagationStopped) {
          return false;
        }
        this.assignHitInformation(args, hit);
        if (this.handleEventOnObject(hit.object, args)) {
          return true;
        }
      }
    }
    this.assignHitInformation(args, hits == null ? void 0 : hits[0]);
    this.invokePointerCapture(args);
    const hoveredData = this.hoveredByID.get(args.pointerId);
    if (hoveredData) {
      this.propagatePointerExit(hoveredData.obj, hoveredData.data, null);
    }
    this.hoveredByID.delete(args.pointerId);
    if (args.isUp) {
      (_a2 = this.pressedByID.get(args.pointerId)) == null ? void 0 : _a2.handlers.forEach((h) => this.invokeOnPointerUp(args, h));
      this.pressedByID.delete(args.pointerId);
    }
    return false;
  }
  sortCandidates(hits) {
    this._sortingBuffer.length = 0;
    this._noDepthTestingResults.length = 0;
    for (let i = 0; i < hits.length; i++) {
      const hit = hits[i];
      const object = hit.object;
      if (object.material) {
        if (object.material["depthTest"] === false) {
          this._noDepthTestingResults.push(hit);
          continue;
        }
      }
      this._sortingBuffer.push(hit);
    }
    for (const obj of this._sortingBuffer) {
      this._noDepthTestingResults.push(obj);
    }
    return this._noDepthTestingResults;
  }
  /**
   * Handle hit result by preparing all needed information before propagation.
   * Then calling propagate.
   */
  handleEventOnObject(object, args) {
    if (!this.testIsVisible(object)) {
      if (args.isClick && debug42)
        console.log("not allowed", object);
      return false;
    }
    if (args.pointerId === void 0) {
      if (debug42)
        console.error("Event without pointer can't be handled", args);
      return false;
    }
    args.object = object;
    const parent = object.parent;
    let isShadow = false;
    const clicked = args.isClick ?? false;
    let canvasGroup = null;
    if (parent && parent.isUI) {
      const pressedOrClicked = (args.isPressed || args.isClick) ?? false;
      if (parent[$shadowDomOwner]) {
        const actualGo = parent[$shadowDomOwner].gameObject;
        if (actualGo) {
          const res = UIRaycastUtils.isInteractable(actualGo, this.out);
          if (!res)
            return false;
          canvasGroup = this.out.canvasGroup ?? null;
          const handled = this.handleMeshUIIntersection(object, pressedOrClicked);
          if (!clicked && handled) {
          }
          object = actualGo;
          isShadow = true;
        }
      }
    }
    if (clicked && debug42)
      console.log(this.context.time.frame, object);
    const hovering = this.hoveredByID.get(args.pointerId);
    const prevHovering = hovering == null ? void 0 : hovering.obj;
    const isNewlyHovering = prevHovering !== object;
    if (isNewlyHovering && prevHovering) {
      this.propagatePointerExit(prevHovering, hovering.data, object);
    }
    const entry = this.hoveredByID.get(args.pointerId);
    if (!entry)
      this.hoveredByID.set(args.pointerId, { obj: object, data: args });
    else {
      entry.obj = object;
      entry.data = args;
    }
    if (args.isDown) {
      const data = this.pressedByID.get(args.pointerId);
      if (!data)
        this.pressedByID.set(args.pointerId, { obj: object, data: args, handlers: /* @__PURE__ */ new Set() });
      else {
        data.obj = object;
        data.data = args;
      }
    }
    if (canvasGroup === null || canvasGroup.interactable) {
      this.handleMainInteraction(object, args, prevHovering ?? null);
    }
    return true;
  }
  /**
   * Propagate up in hiearchy and call the callback for each component that is possibly a handler
   */
  propagate(object, onComponent) {
    while (true) {
      if (!object)
        break;
      GameObject.foreachComponent(object, (comp) => {
        onComponent(comp);
      }, false);
      object = object.parent;
    }
  }
  /**
   * Propagate up in hierarchy and call handlers based on the pointer event data
   */
  handleMainInteraction(object, args, prevHovering) {
    const pressedEvent = this.pressedByID.get(args.pointerId);
    const hoveredObjectChanged = prevHovering !== object;
    let isMoving = true;
    switch (args.event.pointerType) {
      case "mouse":
      case "touch":
        const posLastFrame = this.context.input.getPointerPositionLastFrame(args.pointerId);
        const posThisFrame = this.context.input.getPointerPosition(args.pointerId);
        isMoving = posLastFrame && !Mathf.approximately(posLastFrame, posThisFrame);
        break;
      case "controller":
      case "hand":
        break;
    }
    this.propagate(object, (behaviour) => {
      var _a2;
      const comp = behaviour;
      if (comp.interactable === false)
        return;
      if (!comp.activeAndEnabled || !comp.enabled)
        return;
      if (comp.onPointerEnter) {
        if (hoveredObjectChanged) {
          this.handlePointerEnter(comp, args);
        }
      }
      if (args.isDown) {
        if (comp.onPointerDown) {
          comp.onPointerDown(args);
          pressedEvent == null ? void 0 : pressedEvent.handlers.add(comp);
          this.handlePointerCapture(args, comp);
        }
      }
      if (comp.onPointerMove) {
        if (isMoving)
          comp.onPointerMove(args);
        this.handlePointerCapture(args, comp);
      }
      if (args.isUp) {
        if (comp.onPointerUp) {
          this.invokeOnPointerUp(args, comp);
          pressedEvent == null ? void 0 : pressedEvent.handlers.delete(comp);
        }
        if (comp.onPointerExit && ((_a2 = args.event) == null ? void 0 : _a2.pointerType) === PointerType.Touch) {
          this.handlePointerExit(comp, args);
          this.hoveredByID.delete(args.pointerId);
        }
      }
      if (args.isClick) {
        if (comp.onPointerClick) {
          comp.onPointerClick(args);
        }
      }
    });
    if (args.isUp) {
      pressedEvent == null ? void 0 : pressedEvent.handlers.forEach((handler) => {
        this.invokeOnPointerUp(args, handler);
      });
      this.pressedByID.delete(args.pointerId);
    }
  }
  /** Propagate up in hierarchy and call onPointerExit */
  propagatePointerExit(object, args, newObject) {
    this.propagate(object, (behaviour) => {
      if (!behaviour.gameObject || behaviour.destroyed)
        return;
      const inst = behaviour;
      if (inst.onPointerExit || inst.onPointerEnter) {
        if (newObject && this.isChild(newObject, behaviour.gameObject)) {
          return;
        }
        this.handlePointerExit(inst, args);
      }
    });
  }
  /** handles onPointerUp - this will also release the pointerCapture */
  invokeOnPointerUp(evt, handler) {
    var _a2;
    (_a2 = handler.onPointerUp) == null ? void 0 : _a2.call(handler, evt);
    this.releasePointerCapture(evt, handler);
  }
  /** Responsible for invoking onPointerEnter (and updating onPointerExit). We invoke onPointerEnter once per active pointerId */
  handlePointerEnter(comp, args) {
    if (comp.onPointerEnter) {
      if (this.updatePointerState(comp, args.pointerId, this.pointerEnterSymbol, true)) {
        comp.onPointerEnter(args);
      }
    }
    this.updatePointerState(comp, args.pointerId, this.pointerExitSymbol, false);
  }
  /** Responsible for invoking onPointerExit (and updating onPointerEnter). We invoke onPointerExit once per active pointerId */
  handlePointerExit(comp, evt) {
    if (comp.onPointerExit) {
      if (this.updatePointerState(comp, evt.pointerId, this.pointerExitSymbol, true)) {
        comp.onPointerExit(evt);
      }
    }
    this.updatePointerState(comp, evt.pointerId, this.pointerEnterSymbol, false);
  }
  /** updates the pointer state list for a component
   * @param comp the component to update
   * @param pointerId the pointerId to update
   * @param symbol the symbol to use for the state
   * @param add if true, the pointerId is added to the state list, if false the pointerId will be removed
   */
  updatePointerState(comp, pointerId, symbol, add) {
    let state = comp[symbol];
    if (add) {
      if (state && state.includes(pointerId))
        return false;
      state = state || [];
      state.push(pointerId);
      comp[symbol] = state;
      return true;
    } else {
      if (!state || !state.includes(pointerId))
        return false;
      const i = state.indexOf(pointerId);
      if (i !== -1) {
        state.splice(i, 1);
      }
      return true;
    }
  }
  /** check if the event was marked to be captured: if yes add the current component to the captured list */
  handlePointerCapture(evt, comp) {
    if (evt.z__pointer_ctured) {
      evt.z__pointer_ctured = false;
      const id = evt.pointerId;
      if (comp.onPointerMove) {
        const list = this._capturedPointer[id] || [];
        list.push(comp);
        this._capturedPointer[id] = list;
      } else {
        if (isDevEnvironment() && !comp["z__warned_no_pointermove"]) {
          comp["z__warned_no_pointermove"] = true;
          console.warn("PointerCapture was requested but the component doesn't implement onPointerMove. It will not receive any pointer events");
        }
      }
    } else if (evt.z__pointer_cture_rleased) {
      evt.z__pointer_cture_rleased = false;
      this.releasePointerCapture(evt, comp);
    }
  }
  /** removes the component from the pointer capture list */
  releasePointerCapture(evt, component) {
    const id = evt.pointerId;
    if (this._capturedPointer[id]) {
      const i = this._capturedPointer[id].indexOf(component);
      if (i !== -1) {
        this._capturedPointer[id].splice(i, 1);
        if (debug42)
          console.log("released pointer capture", id, component, this._capturedPointer);
      }
    }
  }
  /** invoke the pointerMove event on all captured handlers */
  invokePointerCapture(evt) {
    var _a2;
    if (evt.event.type === InputEvents.PointerMove) {
      const id = evt.pointerId;
      const captured = this._capturedPointer[id];
      if (captured) {
        if (debug42)
          console.log("Captured", id, captured);
        for (let i = 0; i < captured.length; i++) {
          const handler = captured[i];
          const comp = handler;
          if (comp.destroyed) {
            captured.splice(i, 1);
            i--;
            continue;
          }
          (_a2 = handler.onPointerMove) == null ? void 0 : _a2.call(handler, evt);
        }
      }
    }
  }
  isChild(obj, possibleChild) {
    if (!obj || !possibleChild)
      return false;
    if (obj === possibleChild)
      return true;
    if (!obj.parent)
      return false;
    return this.isChild(obj.parent, possibleChild);
  }
  handleMeshUiObjectWithoutShadowDom(obj, pressed) {
    if (!obj || !obj.isUI)
      return true;
    const hit = this.handleMeshUIIntersection(obj, pressed);
    return hit;
  }
  handleMeshUIIntersection(meshUiObject, pressed) {
    const res = MeshUIHelper.updateState(meshUiObject, pressed);
    if (res) {
      this.currentActiveMeshUIComponents.push(res);
    }
    return res !== null;
  }
  resetMeshUIStates() {
    if (this.context.input.getPointerPressedCount() > 0) {
      MeshUIHelper.resetLastSelected();
    }
    if (!this.currentActiveMeshUIComponents || this.currentActiveMeshUIComponents.length <= 0)
      return;
    for (let i = 0; i < this.currentActiveMeshUIComponents.length; i++) {
      const comp = this.currentActiveMeshUIComponents[i];
      MeshUIHelper.resetState(comp);
    }
    this.currentActiveMeshUIComponents.length = 0;
  }
  testIsVisible(obj) {
    if (!obj)
      return true;
    if (!GameObject.isActiveSelf(obj))
      return false;
    return this.testIsVisible(obj.parent);
  }
};
var EventSystem = _EventSystem;
__publicField(EventSystem, "_eventSystemMap", /* @__PURE__ */ new Map());
__publicField(EventSystem, "didSearchEventSystem", false);
var MeshUIHelper = class {
  static markDirty() {
    this.needsUpdate = true;
  }
  static update(threeMeshUI, context, force = false) {
    if (force) {
      threeMeshUI.update();
      return;
    }
    const currentFrame = context.time.frameCount;
    for (const lu of this.lastUpdateFrame) {
      if (lu.context === context) {
        if (currentFrame === lu.frame)
          return;
        lu.frame = currentFrame;
        let shouldUpdate = this.needsUpdate || currentFrame < 1;
        if (lu.nextUpdate <= currentFrame)
          shouldUpdate = true;
        if (shouldUpdate) {
          if (debug42)
            console.log("Update threemeshui");
          this.needsUpdate = false;
          lu.nextUpdate = currentFrame + 60;
          threeMeshUI.update();
        }
        return;
      }
    }
    this.lastUpdateFrame = [{ context, frame: currentFrame, nextUpdate: currentFrame + 60 }];
    threeMeshUI.update();
    this.needsUpdate = false;
  }
  static updateState(intersect, _selectState) {
    let foundBlock = null;
    if (intersect) {
      foundBlock = this.findBlockInParent(intersect);
      if (foundBlock && foundBlock !== this.lastSelected) {
        const interactable = foundBlock["interactable"];
        if (interactable === false)
          return null;
        this.needsUpdate = true;
      }
    }
    return foundBlock;
  }
  static resetLastSelected() {
    const last = this.lastSelected;
    if (!last)
      return;
    this.lastSelected = null;
    this.resetState(last);
  }
  static resetState(obj) {
    if (!obj)
      return;
    this.needsUpdate = true;
  }
  static findBlockInParent(elem) {
    if (!elem)
      return null;
    if (elem.isBlock) {
      return elem;
    }
    return this.findBlockInParent(elem.parent);
  }
};
__publicField(MeshUIHelper, "lastSelected", null);
__publicField(MeshUIHelper, "lastUpdateFrame", []);
__publicField(MeshUIHelper, "needsUpdate", false);

// node_modules/@needle-tools/engine/lib/engine-components/OrbitControls.js
var __decorate9 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug43 = getParam("debugorbit");
var freeCam = getParam("freecam");
var debugCameraFit = getParam("debugcamerafit");
var smoothcam = getParam("smoothcam");
var disabledKeys = { LEFT: "", UP: "", RIGHT: "", BOTTOM: "" };
var defaultKeys = void 0;
var OrbitControlsEventsType;
(function(OrbitControlsEventsType2) {
  OrbitControlsEventsType2["CameraTargetReached"] = "target-reached";
})(OrbitControlsEventsType || (OrbitControlsEventsType = {}));
var CameraTargetReachedEvent = class extends CustomEvent {
  constructor(ctrls, type) {
    super(OrbitControlsEventsType.CameraTargetReached, {
      detail: {
        controls: ctrls,
        type
      }
    });
  }
};
var OrbitControls2 = class extends Component2 {
  constructor() {
    super(...arguments);
    /** When enabled OrbitControls will automatically raycast find a look at target in start
     * @default true
    */
    __publicField(this, "autoTarget", true);
    /** When enabled the scene will be automatically fitted into the camera view in onEnable
     * @default false
    */
    __publicField(this, "autoFit", false);
    /** When enabled the camera can be rotated
     * @default true
    */
    __publicField(this, "enableRotate", true);
    /** When enabled the camera will rotate automatically
     * @default false
    */
    __publicField(this, "autoRotate", false);
    /** The speed at which the camera will rotate automatically. Will only be used when `autoRotate` is enabled
     * @default 1.0
    */
    __publicField(this, "autoRotateSpeed", 1);
    /** The minimum azimuth angle in radians */
    __publicField(this, "minAzimuthAngle", Infinity);
    /** The maximum azimuth angle in radians */
    __publicField(this, "maxAzimuthAngle", Infinity);
    /** The minimum polar angle in radians
     * @default 0
     */
    __publicField(this, "minPolarAngle", 0);
    /** The maximum polar angle in radians
     * @default Math.PI
     */
    __publicField(this, "maxPolarAngle", Math.PI);
    /** When enabled the camera can be moved using keyboard keys. The keys are defined in the `controls.keys` property
     * @default false
     */
    __publicField(this, "enableKeys", false);
    /** When enabled the camera movement will be damped
     * @default true
    */
    __publicField(this, "enableDamping", true);
    /** The damping factor for the camera movement. For more information see the [three.js documentation](https://threejs.org/docs/#examples/en/controls/OrbitControls.dampingFactor)
     * @default 0.1
     */
    __publicField(this, "dampingFactor", 0.1);
    /** When enabled the camera can be zoomed
     * @default true
    */
    __publicField(this, "enableZoom", true);
    /** The minimum zoom level
     * @default 0
     */
    __publicField(this, "minZoom", 0);
    /** The maximum zoom level
     * @default Infinity
     */
    __publicField(this, "maxZoom", Infinity);
    /**
     * Sets the zoom speed of the OrbitControls
     * @default 1
     */
    __publicField(this, "zoomSpeed", 1);
    /**
     * Set to true to enable zooming to the cursor position.
     * @default false
     */
    __publicField(this, "zoomToCursor", false);
    /** When enabled the camera can be panned
     * @default true
     */
    __publicField(this, "enablePan", true);
    /** Assigning a {@link LookAtConstraint} will make the camera look at the constraint source
     * @default null
    */
    __publicField(this, "lookAtConstraint", null);
    /** The weight of the first lookAtConstraint source
     * @default 1
    */
    __publicField(this, "lookAtConstraint01", 1);
    /** If true user input interrupts the camera from animating to a target
     * @default true
    */
    __publicField(this, "allowInterrupt", true);
    /** If true the camera will focus on the target when the middle mouse button is clicked */
    __publicField(this, "middleClickToFocus", true);
    /** If true the camera will focus on the target when the left mouse button is double clicked
     * @default true
     */
    __publicField(this, "doubleClickToFocus", true);
    /**
     * When enabled the camera will fit the scene to the camera view when the background is clicked the specified number of times within a short time
     * @default 2
     */
    __publicField(this, "clickBackgroundToFitScene", 2);
    /**
     * @internal If true debug information will be logged to the console
     * @default false
     */
    __publicField(this, "debugLog", false);
    /** The duration in seconds it takes for the camera look ad and position lerp to reach their destination (when set via `setCameraTargetPosition` and `setLookTargetPosition`)
     * @default 1
     */
    __publicField(this, "targetLerpDuration", 1);
    __publicField(this, "_controls", null);
    __publicField(this, "_cameraObject", null);
    __publicField(this, "_lookTargetLerpActive", false);
    __publicField(this, "_lookTargetStartPosition", new Vector32());
    __publicField(this, "_lookTargetEndPosition", new Vector32());
    __publicField(this, "_lookTargetLerp01", 0);
    __publicField(this, "_lookTargetLerpDuration", 0);
    __publicField(this, "_cameraLerpActive", false);
    __publicField(this, "_cameraStartPosition", new Vector32());
    __publicField(this, "_cameraEndPosition", new Vector32());
    __publicField(this, "_cameraLerp01", 0);
    __publicField(this, "_cameraLerpDuration", 0);
    __publicField(this, "_fovLerpActive", false);
    __publicField(this, "_fovLerpStartValue", 0);
    __publicField(this, "_fovLerpEndValue", 0);
    __publicField(this, "_fovLerp01", 0);
    __publicField(this, "_fovLerpDuration", 0);
    __publicField(this, "_inputs", 0);
    __publicField(this, "_enableTime", 0);
    // use to disable double click when double clicking on UI
    __publicField(this, "_startedListeningToKeyEvents", false);
    __publicField(this, "_eventSystem");
    __publicField(this, "_afterHandleInputFn");
    __publicField(this, "_camera", null);
    __publicField(this, "_syncedTransform");
    __publicField(this, "_didSetTarget", 0);
    __publicField(this, "targetElement", null);
    __publicField(this, "_activePointerEvents");
    __publicField(this, "_lastTimeClickOnBackground", -1);
    __publicField(this, "_clickOnBackgroundCount", 0);
    __publicField(this, "_onPointerDown", (_evt) => {
      this._activePointerEvents.push(_evt);
    });
    __publicField(this, "_onPointerUp", (evt) => {
      for (let i = this._activePointerEvents.length - 1; i >= 0; i--) {
        const registered = this._activePointerEvents[i];
        if (registered.pointerId === evt.pointerId && registered.button === evt.button) {
          this._activePointerEvents.splice(i, 1);
          break;
        }
      }
      if (this.clickBackgroundToFitScene > 0 && evt.isClick && evt.button === 0) {
        if (!evt.hasRay) {
          evt.intersections.push(...this.context.physics.raycast());
        }
        if (evt.intersections.length <= 0) {
          const dt = this.context.time.time - this._lastTimeClickOnBackground;
          this._lastTimeClickOnBackground = this.context.time.time;
          if (this.clickBackgroundToFitScene <= 1 || dt < this.clickBackgroundToFitScene * 0.15) {
            this._clickOnBackgroundCount += 1;
            if (this._clickOnBackgroundCount >= this.clickBackgroundToFitScene - 1)
              this.fitCamera(this.context.scene.children, {
                immediate: false
              });
          } else {
            this._clickOnBackgroundCount = 0;
          }
        }
        if (debug43)
          console.log(this.clickBackgroundToFitScene, evt.intersections.length, this._clickOnBackgroundCount);
      }
    });
    __publicField(this, "_onPointerUpLate", (evt) => {
      if (this.doubleClickToFocus && evt.isDoubleClick && !evt.used) {
        this.setTargetFromRaycast();
      }
    });
    __publicField(this, "onControlsChangeStarted", () => {
      if (this._syncedTransform) {
        this._syncedTransform.requestOwnership();
      }
    });
    __publicField(this, "_shouldDisable", false);
    __publicField(this, "__onPreRender", () => {
      const index = this.context.pre_render_callbacks.indexOf(this.__onPreRender);
      if (index >= 0) {
        this.context.pre_render_callbacks.splice(index, 1);
      }
      if (this.autoFit) {
        this.autoFit = false;
        this.fitCamera({
          centerCamera: "y",
          immediate: true,
          objects: this.scene.children
        });
      }
    });
    __publicField(this, "_haveAttachedKeyboardEvents", false);
  }
  /**
   * @inheritdoc
   */
  get isCameraController() {
    return true;
  }
  /** The underlying three.js OrbitControls.
   * See {@link https://threejs.org/docs/#examples/en/controls/OrbitControls}
   * @returns {@type ThreeOrbitControls | null}
  */
  get controls() {
    return this._controls;
  }
  /** The object being controlled by the OrbitControls (usually the camera)
   * See {@link https://threejs.org/docs/#examples/en/controls/OrbitControls.object}
   * @returns {@type Object3D | null}
  */
  get controllerObject() {
    return this._cameraObject;
  }
  /** Register callback when user starts interacting with the orbit controls */
  onStartInteraction(callback) {
    var _a2;
    (_a2 = this.controls) == null ? void 0 : _a2.addEventListener("start", callback);
  }
  /**
   * @deprecated use `targetLerpDuration` instead
   * ~~The speed at which the camera target and the camera will be lerping to their destinations (if set via script or user input)~~
   * */
  get targetLerpSpeed() {
    return 5;
  }
  set targetLerpSpeed(v4) {
    this.targetLerpDuration = 1 / v4;
  }
  /** @internal */
  awake() {
    if (debug43)
      console.debug("OrbitControls", this);
    this._didSetTarget = 0;
    this._startedListeningToKeyEvents = false;
  }
  /** @internal */
  start() {
    this._eventSystem = EventSystem.get(this.context) ?? void 0;
    if (this._eventSystem) {
      this._afterHandleInputFn = this.afterHandleInput.bind(this);
      this._eventSystem.addEventListener(EventSystemEvents.AfterHandleInput, this._afterHandleInputFn);
    }
  }
  /** @internal */
  onDestroy() {
    var _a2, _b;
    (_a2 = this._controls) == null ? void 0 : _a2.dispose();
    (_b = this._eventSystem) == null ? void 0 : _b.removeEventListener(EventSystemEvents.AfterHandleInput, this._afterHandleInputFn);
  }
  /** @internal */
  onEnable() {
    this._didSetTarget = 0;
    this._enableTime = this.context.time.time;
    const cameraComponent = GameObject.getComponent(this.gameObject, Camera2);
    this._camera = cameraComponent;
    let cam = cameraComponent == null ? void 0 : cameraComponent.threeCamera;
    if (!cam && this.gameObject instanceof PerspectiveCamera) {
      cam = this.gameObject;
    }
    if (cam)
      setCameraController(cam, this, true);
    if (!this._controls && cam instanceof PerspectiveCamera) {
      this._cameraObject = cam;
      const element = this.targetElement ?? this.context.renderer.domElement;
      const mat = cam == null ? void 0 : cam.quaternion.clone();
      this._controls = new OrbitControls(cam, element);
      cam == null ? void 0 : cam.quaternion.copy(mat);
      if (defaultKeys === void 0)
        defaultKeys = { ...this._controls.keys };
    }
    if (this._controls) {
      if (freeCam) {
        this.enablePan = true;
        this.enableZoom = true;
        this.middleClickToFocus = true;
        if (DeviceUtilities.isMobileDevice())
          this.doubleClickToFocus = true;
      }
      this._controls.addEventListener("start", this.onControlsChangeStarted);
      if (!this._startedListeningToKeyEvents && this.enableKeys) {
        this._startedListeningToKeyEvents = true;
        this._controls.listenToKeyEvents(this.context.domElement);
      } else {
        try {
          this._controls.stopListenToKeyEvents();
        } catch {
        }
      }
    }
    this._syncedTransform = GameObject.getComponent(this.gameObject, SyncedTransform) ?? void 0;
    this.context.pre_render_callbacks.push(this.__onPreRender);
    this._activePointerEvents = [];
    this.context.input.addEventListener("pointerdown", this._onPointerDown, { queue: InputEventQueue.Early });
    this.context.input.addEventListener("pointerup", this._onPointerUp, { queue: InputEventQueue.Early });
    this.context.input.addEventListener("pointerup", this._onPointerUpLate, { queue: InputEventQueue.Late });
  }
  /** @internal */
  onDisable() {
    var _a2;
    if ((_a2 = this._camera) == null ? void 0 : _a2.threeCamera) {
      setCameraController(this._camera.threeCamera, this, false);
    }
    if (this._controls) {
      this._controls.enabled = false;
      this._controls.autoRotate = false;
      this._controls.removeEventListener("start", this.onControlsChangeStarted);
      try {
        this._controls.stopListenToKeyEvents();
      } catch {
      }
      this._startedListeningToKeyEvents = false;
    }
    this._activePointerEvents.length = 0;
    this.context.input.removeEventListener("pointerdown", this._onPointerDown);
    this.context.input.removeEventListener("pointerup", this._onPointerUp);
    this.context.input.removeEventListener("pointerup", this._onPointerUpLate);
  }
  afterHandleInput(evt) {
    if (evt.detail.args.pointerId === 0) {
      if (evt.detail.args.isDown) {
        if (this._controls && this._eventSystem) {
          this._shouldDisable = this._eventSystem.hasActiveUI;
        }
      } else if (!evt.detail.args.isPressed || evt.detail.args.isUp) {
        this._shouldDisable = false;
      }
    }
  }
  /** @internal */
  onBeforeRender() {
    var _a2, _b, _c, _d;
    if (!this._controls)
      return;
    if (this._cameraObject !== this.context.mainCamera) {
      this._controls.enabled = false;
      return;
    }
    this._controls.enabled = true;
    if (this.context.input.getPointerDown(1) || this.context.input.getPointerDown(2) || this.context.input.mouseWheelChanged || (this.context.input.getPointerPressed(0) && ((_a2 = this.context.input.getPointerPositionDelta(0)) == null ? void 0 : _a2.length()) || 0 > 0.1)) {
      this._inputs += 1;
    }
    if (this._inputs > 0 && this.allowInterrupt) {
      if (this.enableRotate) {
        this.autoRotate = false;
      }
      this._cameraLerpActive = false;
      this._lookTargetLerpActive = false;
    }
    this._inputs = 0;
    if (this.autoTarget) {
      if (this._didSetTarget++ === 0) {
        const camGo = GameObject.getComponent(this.gameObject, Camera2);
        if (camGo && !this.setLookTargetFromConstraint()) {
          if (this.debugLog)
            console.log("NO TARGET");
          const worldPosition = getWorldPosition(camGo.threeCamera);
          const distanceToCenter = Math.max(0.01, worldPosition.length());
          const forward2 = new Vector32(0, 0, -distanceToCenter).applyMatrix4(camGo.threeCamera.matrixWorld);
          this.setLookTargetPosition(forward2, true);
        }
        if (!this.setLookTargetFromConstraint()) {
          const opts = new RaycastOptions();
          opts.screenPoint = new Vector2(0, 0);
          opts.lineThreshold = 0.1;
          const hits = this.context.physics.raycast(opts);
          if (hits.length > 0) {
            this.setLookTargetPosition(hits[0].point, true);
          }
          if (debugCameraFit)
            console.log("OrbitControls hits", ...hits);
        }
      }
    }
    const focusAtPointer = this.middleClickToFocus && this.context.input.getPointerClicked(1);
    if (focusAtPointer) {
      this.setTargetFromRaycast();
    }
    if (this._lookTargetLerpActive || this._cameraLerpActive || this._fovLerpActive) {
      if (this._cameraLerpActive && this._cameraObject) {
        this._cameraLerp01 += this.context.time.deltaTime / this._cameraLerpDuration;
        if (this._cameraLerp01 >= 1) {
          this._cameraObject.position.copy(this._cameraEndPosition);
          this._cameraLerpActive = false;
          this.dispatchEvent(new CameraTargetReachedEvent(this, "camera"));
        } else {
          const t2 = Mathf.easeInOutCubic(this._cameraLerp01);
          this._cameraObject.position.lerpVectors(this._cameraStartPosition, this._cameraEndPosition, t2);
        }
      }
      if (this._lookTargetLerpActive) {
        this._lookTargetLerp01 += this.context.time.deltaTime / this._lookTargetLerpDuration;
        if (this._lookTargetLerp01 >= 1) {
          this._controls.target.copy(this._lookTargetEndPosition);
          this._lookTargetLerpActive = false;
          this.dispatchEvent(new CameraTargetReachedEvent(this, "lookat"));
        } else {
          const t2 = Mathf.easeInOutCubic(this._lookTargetLerp01);
          this._controls.target.lerpVectors(this._lookTargetStartPosition, this._lookTargetEndPosition, t2);
        }
      }
      if (this._fovLerpActive && this._cameraObject) {
        const cam = this._cameraObject;
        this._fovLerp01 += this.context.time.deltaTime / this._fovLerpDuration;
        if (this._fovLerp01 >= 1) {
          cam.fov = this._fovLerpEndValue;
          this._fovLerpActive = false;
        } else {
          const t2 = Mathf.easeInOutCubic(this._fovLerp01);
          cam.fov = Mathf.lerp(this._fovLerpStartValue, this._fovLerpEndValue, t2);
        }
        cam.updateProjectionMatrix();
      }
    }
    if (this._controls) {
      if (this.debugLog)
        this._controls.domElement = this.context.renderer.domElement;
      this._controls.enabled = !this._shouldDisable && this._camera === this.context.mainCameraComponent && !this.context.isInXR && !this._activePointerEvents.some((e) => e.used);
      this._controls.keys = this.enableKeys ? defaultKeys : disabledKeys;
      this._controls.autoRotate = this.autoRotate;
      this._controls.autoRotateSpeed = this.autoRotateSpeed;
      this._controls.enableZoom = this.enableZoom;
      this._controls.zoomSpeed = this.zoomSpeed;
      this._controls.zoomToCursor = this.zoomToCursor;
      this._controls.enableDamping = this.enableDamping;
      this._controls.dampingFactor = this.dampingFactor;
      this._controls.enablePan = this.enablePan;
      this._controls.enableRotate = this.enableRotate;
      this._controls.minAzimuthAngle = this.minAzimuthAngle;
      this._controls.maxAzimuthAngle = this.maxAzimuthAngle;
      this._controls.minPolarAngle = this.minPolarAngle;
      this._controls.maxPolarAngle = this.maxPolarAngle;
      if (!freeCam) {
        if (((_c = (_b = this._camera) == null ? void 0 : _b.threeCamera) == null ? void 0 : _c.type) === "PerspectiveCamera") {
          this._controls.minDistance = this.minZoom;
          this._controls.maxDistance = this.maxZoom;
          this._controls.minZoom = 0;
          this._controls.maxZoom = Infinity;
        } else {
          this._controls.minDistance = 0;
          this._controls.maxDistance = Infinity;
          this._controls.minZoom = this.minZoom;
          this._controls.maxZoom = this.maxZoom;
        }
      }
      if (typeof smoothcam === "number" || smoothcam === true) {
        this._controls.enableDamping = true;
        const factor = typeof smoothcam === "number" ? smoothcam : 0.99;
        this._controls.dampingFactor = Math.max(1e-3, 1 - Math.min(1, factor));
      }
      if (!this.allowInterrupt) {
        if (this._lookTargetLerpActive) {
          this._controls.enablePan = false;
        }
        if (this._cameraLerpActive) {
          this._controls.enableRotate = false;
          this._controls.autoRotate = false;
        }
        if (this._lookTargetLerpActive || this._cameraLerpActive) {
          this._controls.enableZoom = false;
        }
      }
      if (!this.context.isInXR) {
        if (!freeCam && ((_d = this.lookAtConstraint) == null ? void 0 : _d.locked))
          this.setLookTargetFromConstraint(0, this.lookAtConstraint01);
        this._controls.update(this.context.time.deltaTime);
        if (debug43) {
          Gizmos.DrawWireSphere(this._controls.target, 0.1, 65280);
        }
      }
    }
  }
  /**
   * Sets camera target position and look direction. Does perform a raycast in the forward direction of the passed in object to find an orbit point
   */
  setCameraAndLookTarget(target) {
    if (!target || !(target instanceof Object3D))
      return;
    const worldPosition = getWorldPosition(target);
    const forward2 = getWorldDirection(target);
    this.setTargetFromRaycast(new Ray(worldPosition, forward2));
    this.setCameraTargetPosition(worldPosition);
  }
  /** Moves the camera to position smoothly.
   * @param position The position in local space of the controllerObject to move the camera to. If null the camera will stop lerping to the target.
   * @param immediateOrDuration If true the camera will move immediately to the new position, otherwise it will lerp. If a number is passed in it will be used as the duration of the lerp.
  */
  setCameraTargetPosition(position, immediateOrDuration = false) {
    var _a2;
    if (!position)
      return;
    if (position instanceof Object3D) {
      position = getWorldPosition(position);
    }
    if (!this._cameraEndPosition)
      this._cameraEndPosition = new Vector32();
    this._cameraEndPosition.copy(position);
    if (immediateOrDuration === true) {
      this._cameraLerpActive = false;
      if (this._cameraObject) {
        this._cameraObject.position.copy(this._cameraEndPosition);
      }
    } else if (this._cameraObject) {
      this._cameraLerpActive = true;
      this._cameraLerp01 = 0;
      this._cameraStartPosition.copy((_a2 = this._cameraObject) == null ? void 0 : _a2.position);
      if (typeof immediateOrDuration === "number") {
        this._cameraLerpDuration = immediateOrDuration;
      } else
        this._cameraLerpDuration = this.targetLerpDuration;
    }
  }
  /** True while the camera position is being lerped */
  get cameraLerpActive() {
    return this._cameraLerpActive;
  }
  /** Call to stop camera position lerping */
  stopCameraLerp() {
    this._cameraLerpActive = false;
  }
  setFieldOfView(fov, immediateOrDuration = false) {
    var _a2;
    if (!this._controls)
      return;
    if (typeof fov !== "number")
      return;
    const cam = (_a2 = this._camera) == null ? void 0 : _a2.threeCamera;
    if (!cam)
      return;
    if (immediateOrDuration === true) {
      cam.fov = fov;
    } else {
      this._fovLerpActive = true;
      this._fovLerp01 = 0;
      this._fovLerpStartValue = cam.fov;
      this._fovLerpEndValue = fov;
      if (typeof immediateOrDuration === "number") {
        this._fovLerpDuration = immediateOrDuration;
      } else
        this._fovLerpDuration = this.targetLerpDuration;
    }
  }
  /** Moves the camera look-at target to a position smoothly.
   * @param position The position in world space to move the camera target to. If null the camera will stop lerping to the target.
   * @param immediateOrDuration If true the camera target will move immediately to the new position, otherwise it will lerp. If a number is passed in it will be used as the duration of the lerp.
  */
  setLookTargetPosition(position = null, immediateOrDuration = false) {
    if (!this._controls)
      return;
    if (!position)
      return;
    if (position instanceof Object3D) {
      position = getWorldPosition(position);
    }
    this._lookTargetEndPosition.copy(position);
    this._didSetTarget++;
    if (debug43) {
      console.warn("OrbitControls: setLookTargetPosition", position, immediateOrDuration);
      Gizmos.DrawWireSphere(this._lookTargetEndPosition, 0.2, 16711680, 2);
    }
    if (immediateOrDuration === true) {
      this._controls.target.copy(this._lookTargetEndPosition);
    } else {
      this._lookTargetLerpActive = true;
      this._lookTargetLerp01 = 0;
      this._lookTargetStartPosition.copy(this._controls.target);
      if (typeof immediateOrDuration === "number") {
        this._lookTargetLerpDuration = immediateOrDuration;
      } else
        this._lookTargetLerpDuration = this.targetLerpDuration;
    }
  }
  /** True while the camera look target is being lerped */
  get lookTargetLerpActive() {
    return this._lookTargetLerpActive;
  }
  /** Call to stop camera look target lerping */
  stopLookTargetLerp() {
    this._lookTargetLerpActive = false;
  }
  /** Sets the look at target from an assigned lookAtConstraint source by index
   * @param index The index of the source to use
   * @param t The interpolation factor between the current look at target and the new target
  */
  setLookTargetFromConstraint(index = 0, t2 = 1) {
    var _a2;
    if (!this._controls)
      return false;
    const sources = (_a2 = this.lookAtConstraint) == null ? void 0 : _a2.sources;
    if (sources && sources.length > 0) {
      const target = sources[index];
      if (target) {
        target.getWorldPosition(this._lookTargetEndPosition);
        this.lerpLookTarget(this._lookTargetEndPosition, t2);
        return true;
      }
    }
    return false;
  }
  /** @deprecated use `controls.target.lerp(position, delta)` */
  lerpTarget(position, delta) {
    return this.lerpLookTarget(position, delta);
  }
  lerpLookTarget(position, delta) {
    if (!this._controls)
      return;
    if (delta >= 1)
      this._controls.target.copy(position);
    else
      this._controls.target.lerp(position, delta);
  }
  setTargetFromRaycast(ray) {
    if (!this.controls)
      return;
    const rc = ray ? this.context.physics.raycastFromRay(ray) : this.context.physics.raycast();
    for (const hit of rc) {
      if (hit.distance > 0 && GameObject.isActiveInHierarchy(hit.object)) {
        const uiComponent = tryGetUIComponent(hit.object);
        if (uiComponent) {
          const canvas = uiComponent.canvas;
          if (canvas == null ? void 0 : canvas.screenspace) {
            break;
          }
        }
        this.setLookTargetPosition(hit.point);
        break;
      }
    }
  }
  fitCamera(objectsOrOptions, options) {
    var _a2, _b;
    if (this.context.isInXR) {
      return;
    }
    let objects = void 0;
    if (Array.isArray(objectsOrOptions)) {
      objects = objectsOrOptions;
    } else if (objectsOrOptions && "type" in objectsOrOptions) {
      objects = objectsOrOptions.children;
    } else if (objectsOrOptions && "objects" in objectsOrOptions) {
      objects = objectsOrOptions == null ? void 0 : objectsOrOptions.objects;
      options = objectsOrOptions;
    }
    if (objects && !Array.isArray(objects)) {
      objects = objects.children;
    }
    if (!Array.isArray(objects) || objects && objects.length <= 0) {
      objects = this.context.scene.children;
    }
    if (!Array.isArray(objects) || objects.length <= 0) {
      console.warn("No objects to fit camera to...");
      return;
    }
    const camera = this._cameraObject;
    const controls = this._controls;
    if (!camera || !controls) {
      console.warn("No camera or controls found to fit camera to objects...");
      return;
    }
    if (!options)
      options = {};
    const { immediate = false, centerCamera = "y", cameraNearFar = "auto", fitOffset = 1.1, fov = camera == null ? void 0 : camera.fov } = options;
    const size = new Vector32();
    const center = new Vector32();
    const box2 = getBoundingBox(objects, void 0, (_b = (_a2 = this._camera) == null ? void 0 : _a2.threeCamera) == null ? void 0 : _b.layers);
    const boxCopy = box2.clone();
    camera.updateMatrixWorld();
    camera.updateProjectionMatrix();
    box2.getCenter(center);
    const box_size = new Vector32();
    box2.getSize(box_size);
    box2.applyMatrix4(camera.matrixWorldInverse);
    box2.getSize(size);
    box2.setFromCenterAndSize(center, size);
    if (Number.isNaN(size.x) || Number.isNaN(size.y) || Number.isNaN(size.z)) {
      console.warn("Camera fit size resultet in NaN", camera, box2, [...objects]);
      return;
    }
    if (size.length() <= 1e-10) {
      if (debugCameraFit)
        console.warn("Camera fit size is zero", box2, [...objects]);
      return;
    }
    const verticalFov = options.fov || camera.fov;
    const horizontalFov = 2 * Math.atan(Math.tan(verticalFov * Math.PI / 360 / 2) * camera.aspect) / Math.PI * 360;
    const fitHeightDistance = size.y / (2 * Math.atan(Math.PI * verticalFov / 360));
    const fitWidthDistance = size.x / (2 * Math.atan(Math.PI * horizontalFov / 360));
    const distance = fitOffset * Math.max(fitHeightDistance, fitWidthDistance) + size.z / 2;
    if (debugCameraFit) {
      console.log("Fit camera to objects", { fitHeightDistance, fitWidthDistance, distance, verticalFov, horizontalFov });
    }
    this.maxZoom = distance * 10;
    this.minZoom = distance * 0.01;
    const verticalOffset = 0.05;
    const lookAt = center.clone();
    lookAt.y -= size.y * verticalOffset;
    this.setLookTargetPosition(lookAt, immediate);
    this.setFieldOfView(options.fov, immediate);
    this.autoTarget = false;
    if (cameraNearFar == void 0 || cameraNearFar == "auto") {
      const groundprojection = GameObject.findObjectOfType(GroundProjectedEnv);
      const groundProjectionRadius = groundprojection ? groundprojection.radius : 0;
      const boundsMax = Math.max(box_size.x, box_size.y, box_size.z, groundProjectionRadius);
      camera.near = distance / 100;
      camera.far = boundsMax + distance * 10;
      if (groundprojection) {
        this.maxZoom = Math.max(Math.min(this.maxZoom, groundProjectionRadius * 0.5), distance);
      }
    }
    const currentZoom = controls.getDistance();
    if (currentZoom < this.minZoom)
      this.minZoom = currentZoom * 0.9;
    if (currentZoom > this.maxZoom)
      this.maxZoom = currentZoom * 1.1;
    camera.updateMatrixWorld();
    camera.updateProjectionMatrix();
    const cameraWp = getWorldPosition(camera);
    const direction = center.clone();
    direction.sub(cameraWp);
    if (centerCamera === "y")
      direction.y = 0;
    direction.normalize();
    direction.multiplyScalar(distance);
    if (centerCamera === "y")
      direction.y += -verticalOffset * 4 * distance;
    let cameraLocalPosition = center.clone().sub(direction);
    if (camera.parent) {
      cameraLocalPosition = camera.parent.worldToLocal(cameraLocalPosition);
    }
    this.setCameraTargetPosition(cameraLocalPosition, immediate);
    if (debugCameraFit) {
      const helper2 = new Box3Helper(box2);
      this.context.scene.add(helper2);
      setWorldRotation(helper2, getWorldRotation(camera));
      setTimeout(() => {
        this.context.scene.remove(helper2);
      }, 1e4);
      Gizmos.DrawWireBox3(boxCopy, 65280, 10);
      if (!this._haveAttachedKeyboardEvents) {
        this._haveAttachedKeyboardEvents = true;
        document.body.addEventListener("keydown", (e) => {
          if (e.code === "KeyF") {
            let fov2 = void 0;
            if (this._cameraObject instanceof PerspectiveCamera)
              fov2 = Math.random() * Math.random() * 170 + 10;
            this.fitCamera({ objects, fitOffset, immediate: false, fov: fov2 });
          }
          if (e.code === "KeyV") {
            if (this._cameraObject instanceof PerspectiveCamera)
              this._cameraObject.fov = 60;
          }
        });
      }
    }
    controls.update();
  }
};
__decorate9([
  serializable()
], OrbitControls2.prototype, "autoTarget", void 0);
__decorate9([
  serializable()
], OrbitControls2.prototype, "autoFit", void 0);
__decorate9([
  serializable()
], OrbitControls2.prototype, "enableRotate", void 0);
__decorate9([
  serializable()
], OrbitControls2.prototype, "autoRotate", void 0);
__decorate9([
  serializable()
], OrbitControls2.prototype, "autoRotateSpeed", void 0);
__decorate9([
  serializable()
], OrbitControls2.prototype, "minAzimuthAngle", void 0);
__decorate9([
  serializable()
], OrbitControls2.prototype, "maxAzimuthAngle", void 0);
__decorate9([
  serializable()
], OrbitControls2.prototype, "minPolarAngle", void 0);
__decorate9([
  serializable()
], OrbitControls2.prototype, "maxPolarAngle", void 0);
__decorate9([
  serializable()
], OrbitControls2.prototype, "enableKeys", void 0);
__decorate9([
  serializable()
], OrbitControls2.prototype, "enableDamping", void 0);
__decorate9([
  serializable()
], OrbitControls2.prototype, "dampingFactor", void 0);
__decorate9([
  serializable()
], OrbitControls2.prototype, "enableZoom", void 0);
__decorate9([
  serializable()
], OrbitControls2.prototype, "minZoom", void 0);
__decorate9([
  serializable()
], OrbitControls2.prototype, "maxZoom", void 0);
__decorate9([
  serializable()
], OrbitControls2.prototype, "zoomSpeed", void 0);
__decorate9([
  serializable()
], OrbitControls2.prototype, "enablePan", void 0);
__decorate9([
  serializable(LookAtConstraint)
], OrbitControls2.prototype, "lookAtConstraint", void 0);
__decorate9([
  serializable()
], OrbitControls2.prototype, "lookAtConstraint01", void 0);
__decorate9([
  serializable()
], OrbitControls2.prototype, "allowInterrupt", void 0);
__decorate9([
  serializable()
], OrbitControls2.prototype, "middleClickToFocus", void 0);
__decorate9([
  serializable()
], OrbitControls2.prototype, "doubleClickToFocus", void 0);
__decorate9([
  serializable()
], OrbitControls2.prototype, "clickBackgroundToFitScene", void 0);
__decorate9([
  serializable()
], OrbitControls2.prototype, "targetLerpDuration", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/Camera.js
var __decorate10 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var ClearFlags;
(function(ClearFlags2) {
  ClearFlags2[ClearFlags2["None"] = 0] = "None";
  ClearFlags2[ClearFlags2["Skybox"] = 1] = "Skybox";
  ClearFlags2[ClearFlags2["SolidColor"] = 2] = "SolidColor";
  ClearFlags2[ClearFlags2["Uninitialized"] = 4] = "Uninitialized";
})(ClearFlags || (ClearFlags = {}));
var debug44 = getParam("debugcam");
var debugscreenpointtoray = getParam("debugscreenpointtoray");
var _Camera = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "_nearClipPlane", 0.1);
    __publicField(this, "_farClipPlane", 1e3);
    __publicField(this, "orthographic", false);
    __publicField(this, "orthographicSize", 5);
    __publicField(this, "ARBackgroundAlpha", 0);
    __publicField(this, "_cullingMask", 4294967295);
    __publicField(this, "_backgroundBlurriness");
    __publicField(this, "_backgroundIntensity");
    __publicField(this, "_backgroundRotation");
    __publicField(this, "_environmentIntensity");
    __publicField(this, "_targetTexture", null);
    __publicField(this, "_backgroundColor");
    __publicField(this, "_fov");
    __publicField(this, "_cam", null);
    __publicField(this, "_clearFlags", ClearFlags.SolidColor);
    __publicField(this, "_skybox");
    __publicField(this, "_frustum");
    __publicField(this, "_projScreenMatrix", new Matrix4());
  }
  get isCamera() {
    return true;
  }
  /** The camera's aspect ratio (width divided by height) if it is a perspective camera */
  get aspect() {
    if (this._cam instanceof PerspectiveCamera)
      return this._cam.aspect;
    return this.context.domWidth / this.context.domHeight;
  }
  set aspect(value) {
    if (this._cam instanceof PerspectiveCamera) {
      if (this._cam.aspect !== value) {
        this._cam.aspect = value;
        this._cam.updateProjectionMatrix();
      }
    }
  }
  /** The camera's field of view in degrees if it is a perspective camera */
  get fieldOfView() {
    if (this._cam instanceof PerspectiveCamera) {
      return this._cam.fov;
    }
    return this._fov;
  }
  set fieldOfView(val) {
    const changed = this.fieldOfView != val;
    this._fov = val;
    if (changed && this._cam) {
      if (this._cam instanceof PerspectiveCamera) {
        if (this._fov === void 0) {
          console.warn("Can not set undefined fov on PerspectiveCamera");
          return;
        }
        this._cam.fov = this._fov;
        this._cam.updateProjectionMatrix();
      }
    }
  }
  /** The camera's near clipping plane */
  get nearClipPlane() {
    return this._nearClipPlane;
  }
  set nearClipPlane(val) {
    const changed = this._nearClipPlane != val;
    this._nearClipPlane = val;
    if (this._cam && (changed || this._cam.near != val)) {
      this._cam.near = val;
      this._cam.updateProjectionMatrix();
    }
  }
  applyClippingPlane() {
    if (this._cam) {
      this._cam.near = this._nearClipPlane;
      this._cam.far = this._farClipPlane;
      this._cam.updateProjectionMatrix();
    }
  }
  /** The camera's far clipping plane */
  get farClipPlane() {
    return this._farClipPlane;
  }
  set farClipPlane(val) {
    const changed = this._farClipPlane != val;
    this._farClipPlane = val;
    if (this._cam && (changed || this._cam.far != val)) {
      this._cam.far = val;
      this._cam.updateProjectionMatrix();
    }
  }
  /** The camera's clear flags - determines if the background is a skybox or a solid color or transparent */
  get clearFlags() {
    return this._clearFlags;
  }
  set clearFlags(val) {
    if (val === this._clearFlags)
      return;
    this._clearFlags = val;
    this.applyClearFlagsIfIsActiveCamera();
  }
  /**
   * The [`mask`](https://threejs.org/docs/#api/en/core/Layers.mask) value of the three camera object layers
   * If you want to just see objects on one layer (e.g. layer 2) then you can use `cullingLayer = 2` on this camera component instead
  */
  set cullingMask(val) {
    this._cullingMask = val;
    if (this._cam) {
      this._cam.layers.mask = val;
    }
  }
  get cullingMask() {
    if (this._cam)
      return this._cam.layers.mask;
    return this._cullingMask;
  }
  /** Set only a specific layer active to be rendered by the camera.
   * This is equivalent to calling `layers.set(val)`
   **/
  set cullingLayer(val) {
    this.cullingMask = (1 << val | 0) >>> 0;
  }
  /** The blurriness of the background texture (when using a skybox) */
  set backgroundBlurriness(val) {
    if (val === this._backgroundBlurriness)
      return;
    if (val === void 0)
      this._backgroundBlurriness = void 0;
    else
      this._backgroundBlurriness = Math.min(Math.max(val, 0), 1);
    this.applyClearFlagsIfIsActiveCamera();
  }
  get backgroundBlurriness() {
    return this._backgroundBlurriness;
  }
  /** The intensity of the background texture (when using a skybox) */
  set backgroundIntensity(val) {
    if (val === this._backgroundIntensity)
      return;
    if (val === void 0)
      this._backgroundIntensity = void 0;
    else
      this._backgroundIntensity = Math.min(Math.max(val, 0), 10);
    this.applyClearFlagsIfIsActiveCamera();
  }
  get backgroundIntensity() {
    return this._backgroundIntensity;
  }
  /** the rotation of the background texture (when using a skybox) */
  set backgroundRotation(val) {
    if (val === this._backgroundRotation)
      return;
    if (val === void 0)
      this._backgroundRotation = void 0;
    else
      this._backgroundRotation = val;
    this.applyClearFlagsIfIsActiveCamera();
  }
  get backgroundRotation() {
    return this._backgroundRotation;
  }
  /** The intensity of the environment map */
  set environmentIntensity(val) {
    this._environmentIntensity = val;
  }
  get environmentIntensity() {
    return this._environmentIntensity;
  }
  /** The background color of the camera when {@link ClearFlags} are set to `SolidColor` */
  get backgroundColor() {
    return this._backgroundColor ?? null;
  }
  set backgroundColor(val) {
    if (!val)
      return;
    if (!this._backgroundColor) {
      if (!val.clone)
        return;
      this._backgroundColor = val.clone();
    } else
      this._backgroundColor.copy(val);
    if (val.alpha === void 0)
      this._backgroundColor.alpha = 1;
    this.applyClearFlagsIfIsActiveCamera();
  }
  /** The texture that the camera should render to
   * It can be used to render to a {@link Texture} instead of the screen.
  */
  set targetTexture(rt) {
    this._targetTexture = rt;
  }
  get targetTexture() {
    return this._targetTexture;
  }
  /**
   * Get the three.js camera object. This will create a camera if it does not exist yet.
   * @returns {PerspectiveCamera | OrthographicCamera} the three camera
   * @deprecated use {@link threeCamera} instead
   */
  get cam() {
    return this.threeCamera;
  }
  /**
   * Get the three.js camera object. This will create a camera if it does not exist yet.
   * @returns {PerspectiveCamera | OrthographicCamera} the three camera
   */
  get threeCamera() {
    if (this.activeAndEnabled)
      this.buildCamera();
    return this._cam;
  }
  screenPointToRay(x2, y, ray) {
    const cam = this.threeCamera;
    const origin = _Camera._origin;
    origin.set(x2, y, -1);
    this.context.input.convertScreenspaceToRaycastSpace(origin);
    if (debugscreenpointtoray)
      console.log("screenPointToRay", x2.toFixed(2), y.toFixed(2), "now:", origin.x.toFixed(2), origin.y.toFixed(2), "isInXR:" + this.context.isInXR);
    origin.z = -1;
    origin.unproject(cam);
    const dir = _Camera._direction.set(origin.x, origin.y, origin.z);
    const camPosition = getWorldPosition(cam);
    dir.sub(camPosition);
    dir.normalize();
    if (ray) {
      ray.set(camPosition, dir);
      return ray;
    } else {
      return new Ray(camPosition.clone(), dir.clone());
    }
  }
  /**
   * Get a frustum - it will be created the first time this method is called and updated every frame in onBeforeRender when it exists.
   * You can also manually update it using the updateFrustum method.
   */
  getFrustum() {
    if (!this._frustum) {
      this._frustum = new Frustum();
      this.updateFrustum();
    }
    return this._frustum;
  }
  /** Force frustum update - note that this also happens automatically every frame in onBeforeRender */
  updateFrustum() {
    if (!this._frustum)
      this._frustum = new Frustum();
    this._frustum.setFromProjectionMatrix(this.getProjectionScreenMatrix(this._projScreenMatrix, true), this.context.renderer.coordinateSystem);
  }
  /**
   * @returns {Matrix4} this camera's projection screen matrix.
   */
  getProjectionScreenMatrix(target, forceUpdate) {
    if (forceUpdate) {
      this._projScreenMatrix.multiplyMatrices(this.threeCamera.projectionMatrix, this.threeCamera.matrixWorldInverse);
    }
    if (target === this._projScreenMatrix)
      return target;
    return target.copy(this._projScreenMatrix);
  }
  /** @internal */
  awake() {
    if (debugscreenpointtoray) {
      window.addEventListener("pointerdown", (evt) => {
        const px = evt.clientX;
        const py = evt.clientY;
        console.log("touch", px.toFixed(2), py.toFixed(2));
        const ray = this.screenPointToRay(px, py);
        const randomHex = "#" + Math.floor(Math.random() * 16777215).toString(16);
        Gizmos.DrawRay(ray.origin, ray.direction, randomHex, 10);
      });
    }
  }
  /** @internal */
  onEnable() {
    if (debug44)
      console.log(`Camera enabled: "${this.name}". ClearFlags=${ClearFlags[this._clearFlags]}`, this);
    this.buildCamera();
    if (this.tag == "MainCamera" || !this.context.mainCameraComponent) {
      this.context.setCurrentCamera(this);
      handleFreeCam(this);
    }
    this.applyClearFlagsIfIsActiveCamera({ applySkybox: true });
  }
  /** @internal */
  onDisable() {
    this.context.removeCamera(this);
  }
  /** @internal */
  onBeforeRender() {
    if (this._cam) {
      if (this._frustum) {
        this.updateFrustum();
      }
      if (this._clearFlags === ClearFlags.SolidColor)
        this.applyClearFlagsIfIsActiveCamera();
      if (this._targetTexture) {
        if (this.context.isManagedExternally) {
          if (!this["_warnedAboutExternalRenderer"]) {
            this["_warnedAboutExternalRenderer"] = true;
            console.warn("Rendering with external renderer is not supported yet. This may not work or throw errors. Please remove the the target texture from your camera: " + this.name, this.targetTexture);
          }
        }
        const composer = this.context.composer;
        const useNormalRenderer = true;
        const renderer = useNormalRenderer ? this.context.renderer : composer;
        if (renderer) {
          const mainCam = this.context.mainCameraComponent;
          this.applyClearFlags();
          this._targetTexture.render(this.context.scene, this._cam, renderer);
          mainCam == null ? void 0 : mainCam.applyClearFlags();
        }
      }
    }
  }
  /**
   * Creates a {@link PerspectiveCamera} if it does not exist yet and set the camera's properties. This is internally also called when accessing the {@link cam} property.
   **/
  buildCamera() {
    if (this._cam)
      return;
    const cameraAlreadyCreated = this.gameObject["isCamera"];
    let cam = null;
    if (cameraAlreadyCreated) {
      cam = this.gameObject;
      cam == null ? void 0 : cam.layers.enableAll();
      if (cam instanceof PerspectiveCamera)
        this._fov = cam.fov;
    } else
      cam = this.gameObject.children[0];
    if (cam && cam.isCamera) {
      if (cam instanceof PerspectiveCamera) {
        if (this._fov)
          cam.fov = this._fov;
        cam.near = this._nearClipPlane;
        cam.far = this._farClipPlane;
        cam.updateProjectionMatrix();
      }
    } else if (!this.orthographic) {
      cam = new PerspectiveCamera(this.fieldOfView, window.innerWidth / window.innerHeight, this._nearClipPlane, this._farClipPlane);
      if (this.fieldOfView)
        cam.fov = this.fieldOfView;
      this.gameObject.add(cam);
    } else {
      const factor = this.orthographicSize * 100;
      cam = new OrthographicCamera(window.innerWidth / -factor, window.innerWidth / factor, window.innerHeight / factor, window.innerHeight / -factor, this._nearClipPlane, this._farClipPlane);
      this.gameObject.add(cam);
    }
    this._cam = cam;
    this._cam.layers.mask = this._cullingMask;
    if (this.tag == "MainCamera") {
      this.context.setCurrentCamera(this);
    }
  }
  applyClearFlagsIfIsActiveCamera(opts) {
    if (this.context.mainCameraComponent === this) {
      this.applyClearFlags(opts);
    }
  }
  /** Apply this camera's clear flags and related settings to the renderer */
  applyClearFlags(opts) {
    var _a2;
    if (!this._cam) {
      if (debug44)
        console.log("Camera does not exist (apply clear flags)");
      return;
    }
    this.fieldOfView = this._fov;
    if (debug44) {
      const msg = `Camera "${this.name}" clear flags: ${ClearFlags[this._clearFlags]}`;
      console.debug(msg);
    }
    switch (this._clearFlags) {
      case ClearFlags.None:
        return;
      case ClearFlags.Skybox:
        if (_Camera.backgroundShouldBeTransparent(this.context)) {
          if (!this.ARBackgroundAlpha || this.ARBackgroundAlpha < 1e-3) {
            this.context.scene.background = null;
            this.context.renderer.setClearColor(0, 0);
            return;
          }
        }
        if (!this.scene.background || !this._skybox || (opts == null ? void 0 : opts.applySkybox) === true)
          this.applySceneSkybox();
        if (this._backgroundBlurriness !== void 0)
          this.context.scene.backgroundBlurriness = this._backgroundBlurriness;
        else if (debug44)
          console.warn(`Camera "${this.name}" has no background blurriness`);
        if (this._backgroundIntensity !== void 0)
          this.context.scene.backgroundIntensity = this._backgroundIntensity;
        if (this._backgroundRotation !== void 0)
          this.context.scene.backgroundRotation = this._backgroundRotation;
        else if (debug44)
          console.warn(`Camera "${this.name}" has no background intensity`);
        break;
      case ClearFlags.SolidColor:
        if (this._backgroundColor) {
          let alpha = this._backgroundColor.alpha;
          if (_Camera.backgroundShouldBeTransparent(this.context)) {
            alpha = this.ARBackgroundAlpha ?? 0;
          }
          this.context.scene.background = null;
          if ((_a2 = this.context.xr) == null ? void 0 : _a2.isVR) {
            this.context.renderer.setClearColor(getTempColor(this._backgroundColor).convertLinearToSRGB());
          } else {
            this.context.renderer.setClearColor(this._backgroundColor, alpha);
          }
        } else {
          if (debug44)
            console.warn(`Camera "${this.name}" has no background color`, this);
        }
        break;
      case ClearFlags.Uninitialized:
        this.context.scene.background = null;
        this.context.renderer.setClearColor(0, 0);
        break;
    }
  }
  /**
   * Apply the skybox to the scene
   */
  applySceneSkybox() {
    if (!this._skybox)
      this._skybox = new CameraSkybox(this);
    this._skybox.apply();
  }
  /** Used to determine if the background should be transparent when in pass through AR
   * @returns true when in XR on a pass through device where the background shouldbe invisible
   **/
  static backgroundShouldBeTransparent(context) {
    var _a2, _b, _c, _d;
    const session = (_a2 = context.renderer.xr) == null ? void 0 : _a2.getSession();
    if (!session)
      return false;
    if (typeof session["_transparent"] === "boolean") {
      return session["_transparent"];
    }
    const environmentBlendMode = session.environmentBlendMode;
    if (debug44)
      showBalloonMessage("Environment blend mode: " + environmentBlendMode + " on " + navigator.userAgent);
    let transparent = environmentBlendMode === "additive" || environmentBlendMode === "alpha-blend";
    if (context.isInAR) {
      if (environmentBlendMode === "opaque") {
        if ((_b = navigator.userAgent) == null ? void 0 : _b.includes("OculusBrowser")) {
          transparent = true;
        } else if (((_c = navigator.userAgent) == null ? void 0 : _c.includes("Mozilla")) && ((_d = navigator.userAgent) == null ? void 0 : _d.includes("Mobile WebXRViewer/v2"))) {
          transparent = true;
        }
      }
    }
    session["_transparent"] = transparent;
    return transparent;
  }
};
var Camera2 = _Camera;
__publicField(Camera2, "_origin", new Vector32());
__publicField(Camera2, "_direction", new Vector32());
__decorate10([
  serializable()
], Camera2.prototype, "aspect", null);
__decorate10([
  serializable()
], Camera2.prototype, "fieldOfView", null);
__decorate10([
  serializable()
], Camera2.prototype, "nearClipPlane", null);
__decorate10([
  serializable()
], Camera2.prototype, "farClipPlane", null);
__decorate10([
  serializable()
], Camera2.prototype, "clearFlags", null);
__decorate10([
  serializable()
], Camera2.prototype, "orthographic", void 0);
__decorate10([
  serializable()
], Camera2.prototype, "orthographicSize", void 0);
__decorate10([
  serializable()
], Camera2.prototype, "ARBackgroundAlpha", void 0);
__decorate10([
  serializable()
], Camera2.prototype, "cullingMask", null);
__decorate10([
  serializable()
], Camera2.prototype, "backgroundBlurriness", null);
__decorate10([
  serializable()
], Camera2.prototype, "backgroundIntensity", null);
__decorate10([
  serializable(Euler)
], Camera2.prototype, "backgroundRotation", null);
__decorate10([
  serializable()
], Camera2.prototype, "environmentIntensity", null);
__decorate10([
  serializable(RGBAColor)
], Camera2.prototype, "backgroundColor", null);
__decorate10([
  serializable(RenderTexture)
], Camera2.prototype, "targetTexture", null);
var CameraSkybox = class {
  constructor(camera) {
    __publicField(this, "_camera");
    __publicField(this, "_skybox");
    this._camera = camera;
  }
  get context() {
    var _a2;
    return (_a2 = this._camera) == null ? void 0 : _a2.context;
  }
  apply() {
    this._skybox = this.context.lightmaps.tryGetSkybox(this._camera.sourceId);
    if (!this._skybox) {
      if (!this["_did_log_failed_to_find_skybox"]) {
        this["_did_log_failed_to_find_skybox"] = true;
        console.warn(`Camera "${this._camera.name}" has no skybox texture. ${this._camera.sourceId}`);
      }
    } else if (this.context.scene.background !== this._skybox) {
      if (debug44)
        console.log(`Camera "${this._camera.name}" set skybox`, this._camera, this._skybox);
      this._skybox.mapping = EquirectangularReflectionMapping;
      this.context.scene.background = this._skybox;
    }
  }
};
function handleFreeCam(cam) {
  const isFreecam = getParam("freecam");
  if (isFreecam) {
    if (cam.context.mainCameraComponent === cam) {
      GameObject.getOrAddComponent(cam.gameObject, OrbitControls2);
    }
  }
}

// node_modules/@needle-tools/engine/lib/engine-components/AudioListener.js
var AudioListener2 = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "_listener", null);
    __publicField(this, "onInteraction", () => {
      if (this.destroyed)
        return;
      const listener = this.listener;
      if (listener == null)
        return;
      this.addListenerIfItExists();
    });
  }
  /**
   * Gets the existing or creates a new {@link ThreeAudioListener} instance
   * @returns The {@link ThreeAudioListener} instance
   */
  get listener() {
    if (this._listener == null)
      this._listener = new AudioListener();
    return this._listener;
  }
  /** @internal */
  onEnable() {
    Application.registerWaitForInteraction(this.onInteraction);
    this.addListenerIfItExists();
  }
  /** @internal */
  onDisable() {
    Application.unregisterWaitForInteraction(this.onInteraction);
    this.removeListenerIfItExists();
  }
  addListenerIfItExists() {
    const listener = this._listener;
    if (!listener)
      return;
    if (listener == null ? void 0 : listener.parent)
      return;
    const cam = this.context.mainCameraComponent || GameObject.getComponentInParent(this.gameObject, Camera2);
    if (cam == null ? void 0 : cam.threeCamera) {
      cam.threeCamera.add(listener);
    } else {
      this.gameObject.add(listener);
    }
    if (!listener.filter) {
      listener.gain.connect(listener.context.destination);
    } else {
      listener.gain.connect(listener.filter);
      listener.filter.connect(listener.context.destination);
    }
  }
  removeListenerIfItExists() {
    const listener = this._listener;
    if (!listener)
      return;
    listener.removeFromParent();
    if (listener.filter) {
      listener.filter.disconnect();
    }
    if (listener.gain) {
      listener.gain.disconnect();
    }
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/AudioSource.js
var __decorate11 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug45 = getParam("debugaudio");
var AudioRolloffMode;
(function(AudioRolloffMode2) {
  AudioRolloffMode2[AudioRolloffMode2["Logarithmic"] = 0] = "Logarithmic";
  AudioRolloffMode2[AudioRolloffMode2["Linear"] = 1] = "Linear";
  AudioRolloffMode2[AudioRolloffMode2["Custom"] = 2] = "Custom";
})(AudioRolloffMode || (AudioRolloffMode = {}));
var AudioSource = class extends Component2 {
  constructor() {
    super(...arguments);
    /**
     * The audio clip to play. Can be a string (URL) or a MediaStream.
     */
    __publicField(this, "clip", "");
    /**
     * If true, the audio source will start playing as soon as the scene starts.
     * If false, you can call play() to start the audio.
     * @default false
    */
    __publicField(this, "playOnAwake", false);
    /**
     * If true, the audio source will start loading the audio clip as soon as the scene starts.
     * If false, the audio clip will be loaded when play() is called.
     * @default false
     */
    __publicField(this, "preload", false);
    /**
     * When true, the audio will play in the background. This means it will continue playing if the browser tab is not focused/active or minimized
     * @default true
     */
    __publicField(this, "playInBackground", true);
    __publicField(this, "_spatialBlend", 0);
    __publicField(this, "_minDistance", 1);
    __publicField(this, "_maxDistance", 100);
    __publicField(this, "_volume", 1);
    __publicField(this, "rollOffMode", 0);
    __publicField(this, "_loop", false);
    __publicField(this, "sound", null);
    __publicField(this, "helper", null);
    __publicField(this, "wasPlaying", false);
    __publicField(this, "audioLoader", null);
    __publicField(this, "shouldPlay", false);
    // set this from audio context time, used to set clip offset when setting "time" property
    // there is maybe a better way to set a audio clip current time?!
    __publicField(this, "_lastClipStartedLoading", null);
    __publicField(this, "_audioElement", null);
    __publicField(this, "onVisibilityChanged", () => {
      switch (document.visibilityState) {
        case "hidden":
          if (this.playInBackground === false || DeviceUtilities.isMobileDevice()) {
            this.wasPlaying = this.isPlaying;
            if (this.isPlaying) {
              this.pause();
            }
          }
          break;
        case "visible":
          if (debug45)
            console.log("visible", this.enabled, this.playOnAwake, !this.isPlaying, AudioSource.userInteractionRegistered, this.wasPlaying);
          if (this.enabled && this.playOnAwake && !this.isPlaying && AudioSource.userInteractionRegistered && this.wasPlaying) {
            this.play();
          }
          break;
      }
    });
    __publicField(this, "onApplicationMuteChanged", () => {
      var _a2, _b;
      if (this.context.application.muted)
        (_a2 = this.sound) == null ? void 0 : _a2.setVolume(0);
      else
        (_b = this.sound) == null ? void 0 : _b.setVolume(this.volume);
    });
    __publicField(this, "createAudio", (buffer2) => {
      if (debug45)
        console.log("AudioBuffer finished loading", buffer2);
      const sound = this.Sound;
      if (!sound) {
        if (debug45)
          console.warn("Failed getting sound?", this.name);
        return;
      }
      if (sound.isPlaying)
        sound.stop();
      if (buffer2)
        sound.setBuffer(buffer2);
      sound.loop = this._loop;
      if (this.context.application.muted)
        sound.setVolume(0);
      else
        sound.setVolume(this.volume);
      sound.autoplay = this.shouldPlay && AudioSource.userInteractionRegistered;
      this.applySpatialDistanceSettings();
      if (sound.isPlaying)
        sound.stop();
      AudioSource.registerWaitForAllowAudio(this.__onAllowAudioCallback);
    });
    __publicField(this, "__onAllowAudioCallback", () => {
      if (this.shouldPlay)
        this.play();
    });
    __publicField(this, "_lastContextTime", 0);
    __publicField(this, "_hasEnded", true);
    __publicField(this, "_needUpdateSpatialDistanceSettings", false);
  }
  /** Check if the user has interacted with the page to allow audio playback.
   * Internally calling {@link Application.userInteractionRegistered}
   */
  static get userInteractionRegistered() {
    return Application.userInteractionRegistered;
  }
  /** Register a callback that is called when the user has interacted with the page to allow audio playback.
   * Internally calling {@link Application.registerWaitForInteraction}
   */
  static registerWaitForAllowAudio(cb) {
    Application.registerWaitForInteraction(cb);
  }
  /**
   * If true, the audio is currently playing.
   */
  get isPlaying() {
    var _a2;
    return ((_a2 = this.sound) == null ? void 0 : _a2.isPlaying) ?? false;
  }
  /** The duration of the audio clip in seconds. */
  get duration() {
    var _a2, _b;
    return (_b = (_a2 = this.sound) == null ? void 0 : _a2.buffer) == null ? void 0 : _b.duration;
  }
  /** The current time of the audio clip in 0-1 range. */
  get time01() {
    var _a2;
    const duration = this.duration;
    if (duration && this.sound) {
      return ((_a2 = this.sound) == null ? void 0 : _a2.context.currentTime) / duration;
    }
    return 0;
  }
  set time01(val) {
    const duration = this.duration;
    if (duration && this.sound) {
      this.time = val * duration;
    }
  }
  /**
   * The current time of the audio clip in seconds.
   */
  get time() {
    var _a2, _b;
    return ((_a2 = this.sound) == null ? void 0 : _a2.source) ? ((_b = this.sound.source) == null ? void 0 : _b.context.currentTime) - this._lastContextTime + this.sound.offset : 0;
  }
  set time(val) {
    if (this.sound) {
      if (val === this.sound.offset)
        return;
      const wasPlaying = this.isPlaying;
      this.stop();
      this.sound.offset = val;
      if (wasPlaying)
        this.play();
    }
  }
  /**
   * If true, the audio source will loop the audio clip.
   * If false, the audio clip will play once.
   * @default false
   */
  get loop() {
    if (this.sound)
      this._loop = this.sound.getLoop();
    return this._loop;
  }
  set loop(val) {
    this._loop = val;
    if (this.sound)
      this.sound.setLoop(val);
  }
  /** Can be used to play the audio clip in 2D or 3D space.
   * 2D Playback is currently not fully supported.
   * 0 = 2D, 1 = 3D
   * */
  get spatialBlend() {
    return this._spatialBlend;
  }
  set spatialBlend(val) {
    if (val === this._spatialBlend)
      return;
    this._spatialBlend = val;
    this._needUpdateSpatialDistanceSettings = true;
  }
  get minDistance() {
    return this._minDistance;
  }
  set minDistance(val) {
    if (this._minDistance === val)
      return;
    this._minDistance = val;
    this._needUpdateSpatialDistanceSettings = true;
  }
  get maxDistance() {
    return this._maxDistance;
  }
  set maxDistance(val) {
    if (this._maxDistance === val)
      return;
    this._maxDistance = val;
    this._needUpdateSpatialDistanceSettings = true;
  }
  get volume() {
    return this._volume;
  }
  set volume(val) {
    this._volume = val;
    if (this.sound && !this.context.application.muted) {
      if (debug45)
        console.log(this.name, "audio set volume", val);
      this.sound.setVolume(val);
    }
  }
  set pitch(val) {
    if (this.sound)
      this.sound.setPlaybackRate(val);
  }
  get pitch() {
    return this.sound ? this.sound.getPlaybackRate() : 1;
  }
  get Sound() {
    var _a2;
    if (!this.sound && AudioSource.userInteractionRegistered) {
      let listener = GameObject.getComponent(this.context.mainCamera, AudioListener2) ?? GameObject.findObjectOfType(AudioListener2, this.context);
      if (!listener && this.context.mainCamera)
        listener = GameObject.addComponent(this.context.mainCamera, AudioListener2);
      if (listener == null ? void 0 : listener.listener) {
        this.sound = new PositionalAudio(listener.listener);
        (_a2 = this.gameObject) == null ? void 0 : _a2.add(this.sound);
      } else if (debug45)
        console.warn("No audio listener found in scene - can not play audio");
    }
    return this.sound;
  }
  // This is a hacky workaround to get the PositionalAudio behave like a 2D audio source
  // private _listener: AudioListener | null = null;
  // private _originalSoundMatrixWorldFunction: Function | null = null;
  // private _onSoundMatrixWorld = (force: boolean) => {
  //     if (this._spatialBlend > .05) {
  //         if (this._originalSoundMatrixWorldFunction) {
  //             this._originalSoundMatrixWorldFunction.call(this.sound, force);
  //         }
  //     }
  //     else {
  //         // we use another object's matrix world function (but bound to the positional audio)
  //         // this is just a little trick to prevent calling the PositionalAudio's updateMatrixWorld function
  //         this.gameObject.updateMatrixWorld?.call(this.sound, force);
  //         if (this.sound && this._listener) {
  //             this.sound.gain.connect(this._listener.listener.getInput());
  //             // const pos = getTempVector().setFromMatrixPosition(this._listener.gameObject.matrixWorld);
  //             // const ctx = this.sound.context;
  //             // const delay = this._listener.listener.timeDelta;
  //             // const time = ctx.currentTime ;
  //             // this.sound.panner.positionX.setValueAtTime(pos.x, time);
  //             // this.sound.panner.positionY.setValueAtTime(pos.y, time);
  //             // this.sound.panner.positionZ.setValueAtTime(pos.z, time);
  //             // this.sound.panner.orientationX.setValueAtTime(0, time);
  //             // this.sound.panner.orientationY.setValueAtTime(0, time);
  //             // this.sound.panner.orientationZ.setValueAtTime(-1, time);
  //         }
  //     }
  // }
  get ShouldPlay() {
    return this.shouldPlay;
  }
  /** Get the audio context from the Sound */
  get audioContext() {
    var _a2;
    return (_a2 = this.sound) == null ? void 0 : _a2.context;
  }
  /** @internal */
  awake() {
    if (debug45)
      console.log(this);
    this.audioLoader = new AudioLoader();
    if (this.playOnAwake)
      this.shouldPlay = true;
    if (this.preload) {
      if (typeof this.clip === "string") {
        this.audioLoader.load(this.clip, this.createAudio, () => {
        }, console.error);
      }
    }
  }
  /** @internal */
  onEnable() {
    if (this.sound)
      this.gameObject.add(this.sound);
    if (!AudioSource.userInteractionRegistered) {
      AudioSource.registerWaitForAllowAudio(() => {
        if (this.enabled && !this.destroyed && this.shouldPlay)
          this.onNewClip(this.clip);
      });
    } else if (this.playOnAwake && this.context.application.isVisible) {
      this.play();
    }
    globalThis.addEventListener("visibilitychange", this.onVisibilityChanged);
    this.context.application.addEventListener(ApplicationEvents.MuteChanged, this.onApplicationMuteChanged);
  }
  /** @internal */
  onDisable() {
    globalThis.removeEventListener("visibilitychange", this.onVisibilityChanged);
    this.context.application.removeEventListener(ApplicationEvents.MuteChanged, this.onApplicationMuteChanged);
    this.pause();
  }
  applySpatialDistanceSettings() {
    const sound = this.sound;
    if (!sound)
      return;
    this._needUpdateSpatialDistanceSettings = false;
    const dist = Mathf.lerp(10 * this._maxDistance / Math.max(1e-4, this.spatialBlend), this._minDistance, this.spatialBlend);
    if (debug45)
      console.log(this.name, this._minDistance, this._maxDistance, this.spatialBlend, "Ref distance=" + dist);
    sound.setRefDistance(dist);
    sound.setMaxDistance(Math.max(0.01, this._maxDistance));
    switch (this.rollOffMode) {
      case AudioRolloffMode.Logarithmic:
        sound.setDistanceModel("exponential");
        break;
      case AudioRolloffMode.Linear:
        sound.setDistanceModel("linear");
        break;
      case AudioRolloffMode.Custom:
        console.warn("Custom rolloff for AudioSource is not supported: " + this.name);
        break;
    }
    if (this.spatialBlend > 0) {
      if (debug45 && !this.helper) {
        this.helper = new PositionalAudioHelper(sound, sound.getRefDistance());
        sound.add(this.helper);
      }
    } else if (this.helper && this.helper.parent) {
      this.helper.removeFromParent();
    }
  }
  async onNewClip(clip) {
    if (clip)
      this.clip = clip;
    if (typeof clip === "string") {
      if (debug45)
        console.log(clip);
      if (clip.endsWith(".mp3") || clip.endsWith(".wav")) {
        if (!this.audioLoader)
          this.audioLoader = new AudioLoader();
        this.shouldPlay = true;
        if (this._lastClipStartedLoading === clip) {
          if (debug45)
            console.log("Is currently loading:", this._lastClipStartedLoading, this);
          return;
        }
        this._lastClipStartedLoading = clip;
        if (debug45)
          console.log("load audio", clip);
        const buffer2 = await this.audioLoader.loadAsync(clip).catch(console.error);
        this._lastClipStartedLoading = null;
        if (buffer2)
          this.createAudio(buffer2);
      } else
        console.warn("Unsupported audio clip type", clip);
    } else {
      this.shouldPlay = true;
      this.createAudio();
    }
  }
  /** Play a audioclip or mediastream */
  play(clip = void 0) {
    var _a2, _b, _c;
    if (!clip && this.clip)
      clip = this.clip;
    if (clip !== void 0 && typeof clip !== "string" && !(clip instanceof MediaStream)) {
      if (isDevEnvironment())
        console.warn("Called play on AudioSource with unknown argument type:", clip + "\nUsing the assigned clip instead:", this.clip);
      clip = this.clip;
    }
    let needsLoading = !this.sound || clip && clip !== this.clip;
    if (typeof clip === "string" && !this.audioLoader)
      needsLoading = true;
    if (clip instanceof MediaStream || typeof clip === "string")
      this.clip = clip;
    if (needsLoading) {
      this.shouldPlay = true;
      this.onNewClip(clip);
      return;
    }
    this.shouldPlay = true;
    this._hasEnded = false;
    if (debug45)
      console.log("play", (_a2 = this.sound) == null ? void 0 : _a2.getVolume(), this.sound);
    if (this.sound && !this.sound.isPlaying) {
      const muted = this.context.application.muted;
      if (muted)
        this.sound.setVolume(0);
      (_b = this.gameObject) == null ? void 0 : _b.add(this.sound);
      if (this.clip instanceof MediaStream) {
        this.sound.setMediaStreamSource(this.clip);
        if (!this._audioElement) {
          this._audioElement = document.createElement("audio");
          this._audioElement.style.display = "none";
        }
        if (!this._audioElement.parentNode)
          (_c = this.context.domElement.shadowRoot) == null ? void 0 : _c.append(this._audioElement);
        this._audioElement.srcObject = this.clip;
        this._audioElement.autoplay = false;
      } else {
        if (this._audioElement)
          this._audioElement.remove();
        this.sound.play(muted ? 0.1 : 0);
      }
    }
  }
  /**
   * Pause the audio
   */
  pause() {
    var _a2, _b;
    if (debug45)
      console.log("Pause", this);
    this._hasEnded = true;
    this.shouldPlay = false;
    if (this.sound && this.sound.isPlaying && this.sound.source) {
      this._lastContextTime = (_a2 = this.sound) == null ? void 0 : _a2.context.currentTime;
      this.sound.pause();
    }
    (_b = this._audioElement) == null ? void 0 : _b.remove();
  }
  /**
   * Stop the audio and reset the time to 0
   */
  stop() {
    var _a2, _b;
    if (debug45)
      console.log("Pause", this);
    this._hasEnded = true;
    this.shouldPlay = false;
    if (this.sound && this.sound.source) {
      this._lastContextTime = (_a2 = this.sound) == null ? void 0 : _a2.context.currentTime;
      if (debug45)
        console.log(this._lastContextTime);
      this.sound.stop();
    }
    (_b = this._audioElement) == null ? void 0 : _b.remove();
  }
  /** @internal */
  update() {
    if (this.helper) {
      if (this.isPlaying)
        this.helper.update();
      this.helper.visible = this.isPlaying;
    }
    if (this._needUpdateSpatialDistanceSettings) {
      this.applySpatialDistanceSettings();
    }
    if (this.sound && !this.sound.isPlaying && this.shouldPlay && !this._hasEnded) {
      this._hasEnded = true;
      if (debug45)
        console.log("Audio clip ended", this.clip);
      this.dispatchEvent(new CustomEvent("ended", { detail: this }));
    }
  }
};
__decorate11([
  serializable(URL)
], AudioSource.prototype, "clip", void 0);
__decorate11([
  serializable()
], AudioSource.prototype, "playOnAwake", void 0);
__decorate11([
  serializable()
], AudioSource.prototype, "preload", void 0);
__decorate11([
  serializable()
], AudioSource.prototype, "playInBackground", void 0);
__decorate11([
  serializable()
], AudioSource.prototype, "loop", null);
__decorate11([
  serializable()
], AudioSource.prototype, "spatialBlend", null);
__decorate11([
  serializable()
], AudioSource.prototype, "minDistance", null);
__decorate11([
  serializable()
], AudioSource.prototype, "maxDistance", null);
__decorate11([
  serializable()
], AudioSource.prototype, "volume", null);
__decorate11([
  serializable()
], AudioSource.prototype, "pitch", null);
__decorate11([
  serializable()
], AudioSource.prototype, "rollOffMode", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/timeline/SignalAsset.js
var __decorate12 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug46 = getParam("debugsignals");
var SignalAsset = class {
  constructor() {
    __publicField(this, "guid");
  }
};
__decorate12([
  serializable()
], SignalAsset.prototype, "guid", void 0);
var SignalReceiverEvent = class {
  constructor() {
    __publicField(this, "signal");
    __publicField(this, "reaction");
  }
};
__decorate12([
  serializable(SignalAsset)
], SignalReceiverEvent.prototype, "signal", void 0);
__decorate12([
  serializable(EventList)
], SignalReceiverEvent.prototype, "reaction", void 0);
var _SignalReceiver = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "events");
  }
  static invoke(guid) {
    if (_SignalReceiver.receivers[guid]) {
      const receivers = _SignalReceiver.receivers[guid];
      if (!receivers)
        return;
      for (const rec of receivers)
        rec.invoke(guid);
    }
  }
  /** @internal */
  awake() {
    if (debug46)
      console.log("SignalReceiver awake", this);
  }
  /** @internal */
  onEnable() {
    if (this.events) {
      for (const evt of this.events) {
        if (!_SignalReceiver.receivers[evt.signal.guid])
          _SignalReceiver.receivers[evt.signal.guid] = [];
        _SignalReceiver.receivers[evt.signal.guid].push(this);
      }
    }
  }
  /** @internal */
  onDisable() {
    if (this.events) {
      for (const evt of this.events) {
        if (_SignalReceiver.receivers[evt.signal.guid]) {
          const idx = _SignalReceiver.receivers[evt.signal.guid].indexOf(this);
          if (idx >= 0)
            _SignalReceiver.receivers[evt.signal.guid].splice(idx, 1);
        }
      }
    }
  }
  invoke(sig) {
    if (!this.events || !Array.isArray(this.events))
      return;
    const id = typeof sig === "object" ? sig.guid : sig;
    for (const evt of this.events) {
      if (evt.signal.guid === id) {
        try {
          if (!evt.reaction) {
            console.warn("Missing reaction for signal", evt, this);
            continue;
          } else if (!evt.reaction.invoke) {
            console.warn("Missing invoke - possibly a serialization error", evt, this);
            continue;
          }
          evt.reaction.invoke();
        } catch (err) {
          console.error(err);
        }
      }
    }
  }
};
var SignalReceiver = _SignalReceiver;
__publicField(SignalReceiver, "receivers", {});
__decorate12([
  serializable(SignalReceiverEvent)
], SignalReceiver.prototype, "events", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/timeline/TimelineModels.js
var TrackType;
(function(TrackType2) {
  TrackType2["Activation"] = "ActivationTrack";
  TrackType2["Animation"] = "AnimationTrack";
  TrackType2["Audio"] = "AudioTrack";
  TrackType2["Control"] = "ControlTrack";
  TrackType2["Marker"] = "MarkerTrack";
  TrackType2["Signal"] = "SignalTrack";
})(TrackType || (TrackType = {}));
var ClipExtrapolation;
(function(ClipExtrapolation3) {
  ClipExtrapolation3[ClipExtrapolation3["None"] = 0] = "None";
  ClipExtrapolation3[ClipExtrapolation3["Hold"] = 1] = "Hold";
  ClipExtrapolation3[ClipExtrapolation3["Loop"] = 2] = "Loop";
  ClipExtrapolation3[ClipExtrapolation3["PingPong"] = 3] = "PingPong";
  ClipExtrapolation3[ClipExtrapolation3["Continue"] = 4] = "Continue";
})(ClipExtrapolation || (ClipExtrapolation = {}));
var MarkerType;
(function(MarkerType2) {
  MarkerType2["Signal"] = "SignalEmitter";
})(MarkerType || (MarkerType = {}));

// node_modules/@needle-tools/engine/lib/engine-components/timeline/PlayableDirector.js
var __decorate13 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug47 = getParam("debugtimeline");
var DirectorWrapMode;
(function(DirectorWrapMode2) {
  DirectorWrapMode2[DirectorWrapMode2["Hold"] = 0] = "Hold";
  DirectorWrapMode2[DirectorWrapMode2["Loop"] = 1] = "Loop";
  DirectorWrapMode2[DirectorWrapMode2["None"] = 2] = "None";
})(DirectorWrapMode || (DirectorWrapMode = {}));
var ClipExtrapolation2;
(function(ClipExtrapolation3) {
  ClipExtrapolation3[ClipExtrapolation3["None"] = 0] = "None";
  ClipExtrapolation3[ClipExtrapolation3["Hold"] = 1] = "Hold";
  ClipExtrapolation3[ClipExtrapolation3["Loop"] = 2] = "Loop";
  ClipExtrapolation3[ClipExtrapolation3["PingPong"] = 3] = "PingPong";
  ClipExtrapolation3[ClipExtrapolation3["Continue"] = 4] = "Continue";
})(ClipExtrapolation2 || (ClipExtrapolation2 = {}));
var _PlayableDirector = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "playableAsset");
    /** Set to true to start playing the timeline when the scene starts */
    __publicField(this, "playOnAwake");
    __publicField(this, "extrapolationMode", DirectorWrapMode.Loop);
    /** When enabled the timeline will wait for audio tracks to load at the current time before starting to play */
    __publicField(this, "waitForAudio", true);
    __publicField(this, "_visibilityChangeEvt");
    __publicField(this, "_clonedPlayableAsset", false);
    __publicField(this, "_speed", 1);
    __publicField(this, "_guidsMap");
    // INTERNALS
    __publicField(this, "_isPlaying", false);
    __publicField(this, "_internalUpdateRoutine");
    __publicField(this, "_isPaused", false);
    /** internal, true during the time stop() is being processed */
    __publicField(this, "_isStopping", false);
    __publicField(this, "_time", 0);
    __publicField(this, "_duration", 0);
    __publicField(this, "_weight", 1);
    __publicField(this, "_animationTracks", []);
    __publicField(this, "_audioTracks", []);
    __publicField(this, "_signalTracks", []);
    __publicField(this, "_controlTracks", []);
    __publicField(this, "_customTracks", []);
    __publicField(this, "_allTracks", [
      this._animationTracks,
      this._audioTracks,
      this._signalTracks,
      this._controlTracks,
      this._customTracks
    ]);
    /** Experimental support for overriding timeline animation data (position or rotation) */
    __publicField(this, "animationCallbackReceivers", []);
  }
  static registerCreateTrack(type, fn2) {
    this.createTrackFunctions[type] = fn2;
  }
  /** @returns true if the timeline is currently playing */
  get isPlaying() {
    return this._isPlaying;
  }
  /** @returns true if the timeline is currently paused */
  get isPaused() {
    return this._isPaused;
  }
  /** the current time of the timeline */
  get time() {
    return this._time;
  }
  set time(value) {
    if (typeof value === "number" && !Number.isNaN(value))
      this._time = value;
    else if (debug47 || isLocalNetwork()) {
      console.error("INVALID TIMELINE.TIME VALUE", value, this.name);
    }
    ;
  }
  /** the duration of the timeline */
  get duration() {
    return this._duration;
  }
  set duration(value) {
    this._duration = value;
  }
  /** the weight of the timeline. Set to a value below 1 to blend with other timelines */
  get weight() {
    return this._weight;
  }
  set weight(value) {
    this._weight = value;
  }
  /** the playback speed of the timeline */
  get speed() {
    return this._speed;
  }
  set speed(value) {
    this._speed = value;
  }
  /** @internal */
  awake() {
    var _a2, _b, _c, _d, _e;
    if (debug47)
      console.log(this, (_a2 = this.playableAsset) == null ? void 0 : _a2.tracks);
    this.rebuildGraph();
    if (!this.isValid() && (debug47 || isDevEnvironment())) {
      if (debug47) {
        console.warn("PlayableDirector is not valid", "Asset?", this.playableAsset, "Tracks:", (_b = this.playableAsset) == null ? void 0 : _b.tracks, "IsArray?", Array.isArray((_c = this.playableAsset) == null ? void 0 : _c.tracks), this);
      } else if (!((_e = (_d = this.playableAsset) == null ? void 0 : _d.tracks) == null ? void 0 : _e.length)) {
        console.warn("PlayableDirector has no tracks");
      } else {
        console.warn("PlayableDirector is not valid");
      }
    }
  }
  /** @internal */
  onEnable() {
    var _a2, _b, _c;
    for (const track of this._audioTracks) {
      (_a2 = track.onEnable) == null ? void 0 : _a2.call(track);
    }
    for (const track of this._customTracks) {
      (_b = track.onEnable) == null ? void 0 : _b.call(track);
    }
    for (const track of this._animationTracks) {
      (_c = track.onEnable) == null ? void 0 : _c.call(track);
    }
    if (this.playOnAwake) {
      this.play();
    }
    if (!this._visibilityChangeEvt)
      this._visibilityChangeEvt = () => {
        switch (document.visibilityState) {
          case "hidden":
            this.setAudioTracksAllowPlaying(false);
            break;
          case "visible":
            this.setAudioTracksAllowPlaying(true);
            break;
        }
      };
    window.addEventListener("visibilitychange", this._visibilityChangeEvt);
  }
  /** @internal */
  onDisable() {
    var _a2, _b, _c;
    this.stop();
    for (const track of this._audioTracks) {
      (_a2 = track.onDisable) == null ? void 0 : _a2.call(track);
    }
    for (const track of this._customTracks) {
      (_b = track.onDisable) == null ? void 0 : _b.call(track);
    }
    for (const track of this._animationTracks) {
      (_c = track.onDisable) == null ? void 0 : _c.call(track);
    }
    if (this._visibilityChangeEvt)
      window.removeEventListener("visibilitychange", this._visibilityChangeEvt);
  }
  /** @internal */
  onDestroy() {
    var _a2;
    for (const tracks of this._allTracks) {
      for (const track of tracks)
        (_a2 = track.onDestroy) == null ? void 0 : _a2.call(track);
    }
  }
  /** @internal */
  rebuildGraph() {
    if (!this.isValid())
      return;
    this.resolveBindings();
    this.updateTimelineDuration();
    this.setupAndCreateTrackHandlers();
  }
  /**
   * Play the timeline from the current time.
   * If the timeline is already playing this method does nothing.
   */
  async play() {
    if (!this.isValid())
      return;
    const pauseChanged = this._isPaused == true;
    this._isPaused = false;
    if (this._isPlaying)
      return;
    this._isPlaying = true;
    if (pauseChanged)
      this.invokePauseChangedMethodsOnTracks();
    if (this.waitForAudio) {
      const promises = [];
      for (const track of this._audioTracks) {
        const promise = track.loadAudio(this._time, 1, 0);
        if (promise)
          promises.push(promise);
      }
      if (promises.length > 0) {
        await Promise.all(promises);
        if (!this._isPlaying)
          return;
      }
      while (this._audioTracks.length > 0 && this._isPlaying && !AudioSource.userInteractionRegistered && this.waitForAudio)
        await delay(200);
    }
    this.invokeStateChangedMethodsOnTracks();
    this._internalUpdateRoutine = this.startCoroutine(this.internalUpdate(), FrameEvent.LateUpdate);
  }
  /**
   * Pause the timeline.
   */
  pause() {
    if (!this.isValid())
      return;
    this._isPlaying = false;
    if (this._isPaused)
      return;
    this._isPaused = true;
    this.internalEvaluate();
    this.invokePauseChangedMethodsOnTracks();
    this.invokeStateChangedMethodsOnTracks();
  }
  /**
   * Stop the timeline.
   */
  stop() {
    this._isStopping = true;
    for (const track of this._audioTracks)
      track.stop();
    const pauseChanged = this._isPaused == true;
    const wasPlaying = this._isPlaying;
    if (this._isPlaying) {
      this._time = 0;
      this._isPlaying = false;
      this._isPaused = false;
      this.internalEvaluate();
      if (pauseChanged)
        this.invokePauseChangedMethodsOnTracks();
    }
    this._isPlaying = false;
    this._isPaused = false;
    if (pauseChanged && !wasPlaying)
      this.invokePauseChangedMethodsOnTracks();
    if (wasPlaying)
      this.invokeStateChangedMethodsOnTracks();
    if (this._internalUpdateRoutine)
      this.stopCoroutine(this._internalUpdateRoutine);
    this._internalUpdateRoutine = null;
    this._isStopping = false;
  }
  /**
   * Evaluate the timeline at the current time. This is useful when you want to manually update the timeline e.g. when the timeline is paused and you set `time` to a new value.
   */
  evaluate() {
    this.internalEvaluate(true);
  }
  /**
   * @returns true if the timeline is valid and has tracks
   */
  isValid() {
    return this.playableAsset && this.playableAsset.tracks && Array.isArray(this.playableAsset.tracks);
  }
  /** Iterates over all tracks of the timeline
   * @returns all tracks of the timeline
   */
  *forEachTrack() {
    for (const tracks of this._allTracks) {
      for (const track of tracks)
        yield track;
    }
  }
  /**
   * @returns all animation tracks of the timeline
   */
  get animationTracks() {
    return this._animationTracks;
  }
  /**
   * @returns all audio tracks of the timeline
   */
  get audioTracks() {
    return this._audioTracks;
  }
  /** @internal */
  resolveGuids(map) {
    this._guidsMap = map;
  }
  /** should be called after evaluate if the director was playing */
  invokePauseChangedMethodsOnTracks() {
    var _a2;
    for (const track of this.forEachTrack()) {
      (_a2 = track.onPauseChanged) == null ? void 0 : _a2.call(track);
    }
  }
  invokeStateChangedMethodsOnTracks() {
    var _a2;
    for (const track of this.forEachTrack()) {
      (_a2 = track.onStateChanged) == null ? void 0 : _a2.call(track, this._isPlaying);
    }
  }
  *internalUpdate() {
    while (this._isPlaying && this.activeAndEnabled) {
      if (!this._isPaused && this._isPlaying) {
        this._time += this.context.time.deltaTime * this.speed;
        this.internalEvaluate();
      }
      yield;
    }
  }
  /**
   * PlayableDirector lifecycle should always call this instead of "evaluate"
   * @param called_by_user If true the evaluation is called by the user (e.g. via evaluate())
   */
  internalEvaluate(called_by_user = false) {
    if (!this.isValid())
      return;
    let t2 = this._time;
    switch (this.extrapolationMode) {
      case DirectorWrapMode.Hold:
        if (this._speed > 0)
          t2 = Math.min(t2, this._duration);
        else if (this._speed < 0)
          t2 = Math.max(t2, 0);
        this._time = t2;
        break;
      case DirectorWrapMode.Loop:
        t2 %= this._duration;
        this._time = t2;
        break;
      case DirectorWrapMode.None:
        if (t2 > this._duration) {
          this.stop();
          return;
        }
        break;
    }
    const time = this._time;
    for (const track of this.playableAsset.tracks) {
      if (track.muted)
        continue;
      switch (track.type) {
        case TrackType.Activation:
          if (!called_by_user && !this._isPlaying)
            continue;
          for (let i = 0; i < track.outputs.length; i++) {
            const binding = track.outputs[i];
            if (typeof binding === "object") {
              let isActive = false;
              if (track.clips) {
                for (const clip of track.clips) {
                  if (clip.start <= time && time <= clip.end) {
                    isActive = true;
                  }
                }
              }
              const obj = binding;
              if (obj.visible !== void 0) {
                if (obj.visible !== isActive) {
                  obj.visible = isActive;
                  if (debug47)
                    console.warn(this.name, "set ActivationTrack-" + i, obj.name, isActive, time);
                }
              }
            }
          }
          break;
      }
    }
    if (!this._isStopping) {
      for (const handler of this._animationTracks) {
        handler.evaluate(time);
      }
    }
    for (const handler of this._audioTracks) {
      handler.evaluate(time);
    }
    for (const sig of this._signalTracks) {
      sig.evaluate(time);
    }
    for (const ctrl of this._controlTracks) {
      ctrl.evaluate(time);
    }
    for (const cust of this._customTracks) {
      cust.evaluate(time);
    }
  }
  resolveBindings() {
    if (!this._clonedPlayableAsset) {
      this._clonedPlayableAsset = true;
      this.playableAsset = deepClone(this.playableAsset);
    }
    if (!this.playableAsset || !this.playableAsset.tracks)
      return;
    const root = this.findRoot(this.gameObject);
    for (const track of this.playableAsset.tracks) {
      for (let i = track.outputs.length - 1; i >= 0; i--) {
        let binding = track.outputs[i];
        if (typeof binding === "string") {
          if (this._guidsMap && this._guidsMap[binding])
            binding = this._guidsMap[binding];
          const obj = GameObject.findByGuid(binding, root);
          if (obj === null || typeof obj !== "object") {
            track.outputs.splice(i, 1);
            console.warn("Failed to resolve binding", binding, track.name, track.type);
          } else {
            if (debug47)
              console.log("Resolved binding", binding, "to", obj);
            track.outputs[i] = obj;
          }
        } else if (binding === null) {
          track.outputs.splice(i, 1);
          if (_PlayableDirector.createTrackFunctions[track.type]) {
            continue;
          }
          if (track.type !== TrackType.Audio && track.type !== TrackType.Control && track.type !== TrackType.Marker && track.type !== TrackType.Signal)
            console.warn("Missing binding", binding, track.name, track.type, this.name, this.playableAsset.name);
        }
      }
      if (track.type === TrackType.Control) {
        if (track.clips) {
          for (let i = 0; i < track.clips.length; i++) {
            const clip = track.clips[i];
            let binding = clip.asset.sourceObject;
            if (typeof binding === "string") {
              if (this._guidsMap && this._guidsMap[binding])
                binding = this._guidsMap[binding];
              const obj = GameObject.findByGuid(binding, root);
              if (obj === null || typeof obj !== "object") {
                console.warn("Failed to resolve sourceObject binding", binding, track.name, clip);
              } else {
                if (debug47)
                  console.log("Resolved binding", binding, "to", obj);
                clip.asset.sourceObject = obj;
              }
            }
          }
        }
      }
    }
  }
  findRoot(current) {
    if (current.parent)
      return this.findRoot(current.parent);
    return current;
  }
  updateTimelineDuration() {
    this._duration = 0;
    if (!this.playableAsset || !this.playableAsset.tracks)
      return;
    for (const track of this.playableAsset.tracks) {
      if (track.muted === true)
        continue;
      if (track.clips) {
        for (const clip of track.clips) {
          if (clip.end > this._duration)
            this._duration = clip.end;
        }
      }
      if (track.markers) {
        for (const marker of track.markers) {
          if (marker.time > this._duration)
            this._duration = marker.time + 1e-3;
        }
      }
    }
  }
  setupAndCreateTrackHandlers() {
    var _a2, _b, _c;
    this._animationTracks.length = 0;
    this._audioTracks.length = 0;
    this._signalTracks.length = 0;
    if (!this.playableAsset)
      return;
    let audioListener = GameObject.findObjectOfType(AudioListener2, this.context);
    for (const track of this.playableAsset.tracks) {
      const type = track.type;
      const registered = _PlayableDirector.createTrackFunctions[type];
      if (registered !== null && registered !== void 0) {
        const res = registered(this, track);
        if (typeof res.evaluate === "function") {
          res.director = this;
          res.track = track;
          this._customTracks.push(res);
          continue;
        }
      }
      if (track.type === TrackType.Animation) {
        if (!track.clips || track.clips.length <= 0) {
          if (debug47)
            console.warn("Animation track has no clips", track);
          continue;
        }
        for (let i = track.outputs.length - 1; i >= 0; i--) {
          let binding = track.outputs[i];
          if (binding instanceof Object3D) {
            const anim = GameObject.getOrAddComponent(binding, Animator);
            if (anim)
              binding = anim;
          }
          const animationClips = (_a2 = binding == null ? void 0 : binding.gameObject) == null ? void 0 : _a2.animations;
          if (animationClips) {
            const handler = new AnimationTrackHandler();
            handler.trackOffset = track.trackOffset;
            handler.director = this;
            handler.track = track;
            for (let i2 = 0; i2 < track.clips.length; i2++) {
              const clipModel = track.clips[i2];
              const animModel = clipModel.asset;
              if (!animModel) {
                console.error(`Timeline ${this.name}: clip #${i2} on track "${track.name}" has no animation data`);
                continue;
              }
              const targetObjectId = animModel.clip;
              let clip = targetObjectId;
              if (typeof clip === "string" || typeof clip === "number") {
                clip = animationClips.find((c2) => c2.name === targetObjectId);
              }
              if (debug47)
                console.log(animModel, targetObjectId, "→", clip);
              if (!clip) {
                console.warn("Could not find animationClip for model", clipModel, track.name, this.name, (_b = this.playableAsset) == null ? void 0 : _b.name, animationClips, binding);
                continue;
              }
              if (binding instanceof Animator && binding.runtimeAnimatorController) {
                if (!binding.__internalDidAwakeAndStart)
                  binding.initializeRuntimeAnimatorController();
                if (!binding.runtimeAnimatorController.mixer)
                  binding.runtimeAnimatorController.bind(binding);
                handler.mixer = binding.runtimeAnimatorController.mixer;
              }
              if (!handler.mixer) {
                handler.mixer = new AnimationMixer(binding.gameObject);
                this.context.animations.registerAnimationMixer(handler.mixer);
              }
              handler.clips.push(clip);
              handler.mixer.uncacheAction(clip);
              handler.createHooks(clipModel.asset, clip);
              const clipAction = handler.mixer.clipAction(clip);
              handler.actions.push(clipAction);
              handler.models.push(clipModel);
            }
            this._animationTracks.push(handler);
          }
        }
      } else if (track.type === TrackType.Audio) {
        if (!track.clips || track.clips.length <= 0)
          continue;
        const audio = new AudioTrackHandler();
        audio.director = this;
        audio.track = track;
        audio.audioSource = track.outputs.find((o) => o instanceof AudioSource);
        this._audioTracks.push(audio);
        if (!audioListener) {
          audioListener = (_c = this.context.mainCameraComponent) == null ? void 0 : _c.gameObject.addComponent(AudioListener2);
        }
        audio.listener = audioListener.listener;
        for (let i = 0; i < track.clips.length; i++) {
          const clipModel = track.clips[i];
          audio.addModel(clipModel);
        }
      } else if (track.type === TrackType.Marker) {
        const signalHandler = new SignalTrackHandler();
        signalHandler.director = this;
        signalHandler.track = track;
        if (track.markers) {
          for (const marker of track.markers) {
            switch (marker.type) {
              case MarkerType.Signal:
                signalHandler.models.push(marker);
                signalHandler.didTrigger.push(false);
                break;
            }
          }
        }
        if (signalHandler !== null && signalHandler.models.length > 0) {
          const rec = GameObject.getComponent(this.gameObject, SignalReceiver);
          if (rec) {
            signalHandler.receivers.push(rec);
            this._signalTracks.push(signalHandler);
          }
        }
      } else if (track.type === TrackType.Signal) {
        const handler = new SignalTrackHandler();
        handler.director = this;
        handler.track = track;
        if (track.markers) {
          for (const marker of track.markers) {
            handler.models.push(marker);
            handler.didTrigger.push(false);
          }
        }
        for (const bound of track.outputs) {
          handler.receivers.push(bound);
        }
        this._signalTracks.push(handler);
      } else if (track.type === TrackType.Control) {
        const handler = new ControlTrackHandler();
        handler.director = this;
        handler.track = track;
        if (track.clips) {
          for (const clip of track.clips) {
            handler.models.push(clip);
          }
        }
        handler.resolveSourceObjects(this.context);
        this._controlTracks.push(handler);
      }
    }
  }
  setAudioTracksAllowPlaying(allow) {
    for (const track of this._audioTracks) {
      track.onAllowAudioChanged(allow);
    }
  }
  /** Experimental: Receive callbacks for timeline animation. Allows modification of final value */
  registerAnimationCallback(receiver) {
    this.animationCallbackReceivers.push(receiver);
  }
  /** Experimental: Unregister callbacks for timeline animation. Allows modification of final value */
  unregisterAnimationCallback(receiver) {
    const index = this.animationCallbackReceivers.indexOf(receiver);
    if (index === -1)
      return;
    this.animationCallbackReceivers.splice(index, 1);
  }
};
var PlayableDirector = _PlayableDirector;
__publicField(PlayableDirector, "createTrackFunctions", {});
__decorate13([
  serializable()
], PlayableDirector.prototype, "playOnAwake", void 0);
__decorate13([
  serializable()
], PlayableDirector.prototype, "extrapolationMode", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/timeline/TimelineTracks.js
var debug48 = getParam("debugtimeline");
var TrackHandler = class {
  constructor() {
    __publicField(this, "director");
    __publicField(this, "track");
  }
  get muted() {
    return this.track.muted;
  }
  set muted(val) {
    var _a2;
    if (val !== this.track.muted) {
      this.track.muted = val;
      (_a2 = this.onMuteChanged) == null ? void 0 : _a2.call(this);
    }
  }
  *forEachClip(backwards = false) {
    var _a2;
    if (!((_a2 = this.track) == null ? void 0 : _a2.clips))
      return;
    if (backwards) {
      for (let i = this.track.clips.length - 1; i >= 0; i--) {
        yield this.track.clips[i];
      }
    } else {
      for (const clip of this.track.clips) {
        yield clip;
      }
    }
  }
  getClipTime(time, model) {
    return model.clipIn + (time - model.start) * model.timeScale;
  }
  getClipTimeNormalized(time, model) {
    return (time - model.start) / model.duration;
  }
  evaluateWeight(time, index, models, isActive = true) {
    if (index < 0 || index >= models.length)
      return 0;
    const model = models[index];
    if (isActive || time >= model.start && time <= model.end) {
      let weight = 1;
      const isBlendingWithNext = false;
      if (model.easeInDuration > 0) {
        const easeIn = Math.min((time - model.start) / model.easeInDuration, 1);
        weight *= easeIn;
      }
      if (model.easeOutDuration > 0 && !isBlendingWithNext) {
        const easeOut = Math.min((model.end - time) / model.easeOutDuration, 1);
        weight *= easeOut;
      }
      return weight;
    }
    return 0;
  }
};
var AnimationClipOffsetData = class {
  constructor(action) {
    __publicField(this, "clip");
    __publicField(this, "rootPositionOffset");
    __publicField(this, "rootQuaternionOffset");
    // not necessary
    __publicField(this, "rootStartPosition");
    __publicField(this, "rootEndPosition");
    __publicField(this, "rootStartQuaternion");
    __publicField(this, "rootEndQuaternion");
    const clip = action.getClip();
    this.clip = clip;
    const root = action.getRoot();
    const rootPositionTrackName = root.name + ".position";
    const rootRotationTrackName = root.name + ".quaternion";
    if (debug48)
      console.log(clip.name, clip.tracks, rootPositionTrackName);
    for (const track of clip.tracks) {
      if (track.times.length <= 0)
        continue;
      if (track.name.endsWith(rootPositionTrackName)) {
        this.rootStartPosition = new Vector32().fromArray(track.values, 0);
        this.rootEndPosition = new Vector32().fromArray(track.values, track.values.length - 3);
        this.rootPositionOffset = this.rootEndPosition.clone().sub(this.rootStartPosition);
        if (debug48)
          console.log(this.rootPositionOffset);
      } else if (track.name.endsWith(rootRotationTrackName)) {
        this.rootStartQuaternion = new Quaternion().fromArray(track.values, 0);
        this.rootEndQuaternion = new Quaternion().fromArray(track.values, track.values.length - 4);
        this.rootQuaternionOffset = this.rootEndQuaternion.clone().multiply(this.rootStartQuaternion);
        if (debug48) {
          const euler2 = new Euler().setFromQuaternion(this.rootQuaternionOffset);
          console.log("ROT", euler2);
        }
      }
    }
  }
  get hasOffsets() {
    return this.rootPositionOffset !== void 0 || this.rootQuaternionOffset !== void 0;
  }
};
var AnimationTrackHandler = class extends TrackHandler {
  constructor() {
    super(...arguments);
    /** @internal */
    __publicField(this, "models", []);
    /** @internal */
    __publicField(this, "trackOffset");
    /** The object that is being animated. */
    __publicField(this, "target");
    /** The AnimationMixer, should be shared with the animator if an animator is bound */
    __publicField(this, "mixer");
    __publicField(this, "clips", []);
    __publicField(this, "actions", []);
    /**
     * You can use the weight to blend the timeline animation tracks with multiple animation tracks on the same object.
     * @default 1
     */
    __publicField(this, "weight", 1);
    /** holds data/info about clips differences */
    __publicField(this, "_actionOffsets", []);
    __publicField(this, "_didBind", false);
    __publicField(this, "_animator", null);
    __publicField(this, "_useclipOffsets", true);
    __publicField(this, "_totalOffsetPosition", new Vector32());
    __publicField(this, "_totalOffsetRotation", new Quaternion());
    __publicField(this, "_totalOffsetPosition2", new Vector32());
    __publicField(this, "_totalOffsetRotation2", new Quaternion());
    __publicField(this, "_summedPos", new Vector32());
    __publicField(this, "_tempPos", new Vector32());
    __publicField(this, "_summedRot", new Quaternion());
    __publicField(this, "_tempRot", new Quaternion());
    __publicField(this, "_clipRotQuat", new Quaternion());
  }
  onDisable() {
    var _a2;
    (_a2 = this.mixer) == null ? void 0 : _a2.stopAllAction();
  }
  onDestroy() {
    this.director.context.animations.unregisterAnimationMixer(this.mixer);
  }
  // Using this callback instead of onEnable etc 
  // because we want to re-enable the animator when the director is at the end and wrap mode is set to none
  // in which case the director is stopped (but not disabled)
  // which means we want to notify the object that it's not animated anymore
  // and the animator can then take over
  onStateChanged() {
    if (this._animator)
      setObjectAnimated(this._animator.gameObject, this, this.director.isPlaying);
  }
  createHooks(clipModel, clip) {
    var _a2, _b;
    if (((_a2 = clip.tracks) == null ? void 0 : _a2.length) <= 0) {
      console.warn("No tracks in AnimationClip", clip);
      return;
    }
    const parts = clip.tracks[0].name.split(".");
    const rootName = parts[parts.length - 2];
    const positionTrackName = rootName + ".position";
    const rotationTrackName = rootName + ".quaternion";
    let foundPositionTrack = false;
    let foundRotationTrack = false;
    for (const t2 of clip.tracks) {
      if (t2.name.endsWith(positionTrackName)) {
        foundPositionTrack = true;
        this.createPositionInterpolant(clip, clipModel, t2);
      } else if (t2.name.endsWith(rotationTrackName)) {
        foundRotationTrack = true;
        this.createRotationInterpolant(clip, clipModel, t2);
      }
    }
    if (!foundPositionTrack || !foundRotationTrack) {
      const root = (_b = this.mixer) == null ? void 0 : _b.getRoot();
      const track = clip.tracks[0];
      const indexOfProperty = track.name.lastIndexOf(".");
      const baseName = track.name.substring(0, indexOfProperty);
      const objName = baseName.substring(baseName.lastIndexOf(".") + 1);
      const targetObj = root.getObjectByName(objName);
      if (targetObj) {
        if (!foundPositionTrack) {
          const trackName = baseName + ".position";
          if (debug48)
            console.warn("Create position track", objName, targetObj);
          const pos = targetObj.position;
          const track2 = new VectorKeyframeTrack(trackName, [0, clip.duration], [pos.x, pos.y, pos.z, pos.x, pos.y, pos.z]);
          clip.tracks.push(track2);
          this.createPositionInterpolant(clip, clipModel, track2);
        } else if (!foundRotationTrack) {
          const trackName = clip.tracks[0].name.substring(0, indexOfProperty) + ".quaternion";
          if (debug48)
            console.warn("Create quaternion track", objName, targetObj);
          const rot = targetObj.quaternion;
          const track2 = new QuaternionKeyframeTrack(trackName, [0, clip.duration], [rot.x, rot.y, rot.z, rot.w, rot.x, rot.y, rot.z, rot.w]);
          clip.tracks.push(track2);
          this.createRotationInterpolant(clip, clipModel, track2);
        }
      }
    }
  }
  bind() {
    if (this._didBind)
      return;
    this._didBind = true;
    if (debug48)
      console.log(this.models);
    if (this.mixer)
      this.target = this.mixer.getRoot();
    else
      console.warn("No mixer was assigned to animation track");
    for (const action of this.actions) {
      const off = new AnimationClipOffsetData(action);
      this._actionOffsets.push(off);
    }
    if (this.target) {
      this._animator = GameObject.getComponent(this.target, Animator) ?? null;
      if (this._animator) {
        setObjectAnimated(this._animator.gameObject, this, true);
      }
    }
    for (const model of this.models) {
      const clipData = model.asset;
      const pos = clipData.position;
      const rot = clipData.rotation;
      if (pos && pos.x !== void 0) {
        if (!pos.isVector3) {
          clipData.position = new Vector32(pos.x, pos.y, pos.z);
        }
        if (!rot.isQuaternion) {
          clipData.rotation = new Quaternion(rot.x, rot.y, rot.z, rot.w);
        }
      }
    }
    this.ensureTrackOffsets();
  }
  ensureTrackOffsets() {
    if (this.trackOffset) {
      const pos = this.trackOffset.position;
      if (pos) {
        if (!pos.isVector3) {
          this.trackOffset.position = new Vector32(pos.x, pos.y, pos.z);
        }
      }
      const rot = this.trackOffset.rotation;
      if (rot) {
        if (!rot.isQuaternion) {
          this.trackOffset.rotation = new Quaternion(rot.x, rot.y, rot.z, rot.w);
        }
      }
    }
  }
  evaluate(time) {
    var _a2, _b, _c, _d, _e, _f, _g;
    if (this.track.muted)
      return;
    if (!this.mixer)
      return;
    this.bind();
    this._totalOffsetPosition.set(0, 0, 0);
    this._totalOffsetRotation.set(0, 0, 0, 1);
    this._totalOffsetPosition2.set(0, 0, 0);
    this._totalOffsetRotation2.set(0, 0, 0, 1);
    let activeClips = 0;
    let blend = 0;
    let didPostExtrapolate = false;
    let didPreExtrapolate = false;
    let totalWeight = 0;
    for (let i = 0; i < this.clips.length; i++) {
      const model = this.models[i];
      const action = this.actions[i];
      const clipModel = model.asset;
      action.weight = 0;
      const isInTimeRange = time >= model.start && time <= model.end;
      const preExtrapolation = model.preExtrapolationMode;
      const postExtrapolation = model.postExtrapolationMode;
      const nextClip = i < this.clips.length - 1 ? this.models[i + 1] : null;
      let isActive = isInTimeRange;
      let doPreExtrapolate = false;
      if (!isActive && !didPostExtrapolate && model.end < time && postExtrapolation !== ClipExtrapolation.None) {
        if (!nextClip || nextClip.start > time) {
          isActive = true;
          didPostExtrapolate = true;
        }
      } else if (i == 0 && !isActive && !didPreExtrapolate && model.start > time && preExtrapolation !== ClipExtrapolation.None) {
        if (!nextClip || nextClip.start < time) {
          isActive = true;
          doPreExtrapolate = true;
          didPreExtrapolate = true;
        }
      }
      if (isActive) {
        let weight = this.weight;
        weight *= this.evaluateWeight(time, i, this.models, isActive);
        weight *= this.director.weight;
        let handleLoop = isInTimeRange;
        if (doPreExtrapolate) {
          switch (preExtrapolation) {
            case ClipExtrapolation.Hold:
              break;
            case ClipExtrapolation.Loop:
              time += model.start;
              handleLoop = true;
              break;
            default:
              time += model.start;
              handleLoop = true;
              break;
          }
        }
        let t2 = this.getClipTime(time, model);
        let loops = 0;
        const duration = clipModel.duration;
        if (doPreExtrapolate) {
          if (preExtrapolation === ClipExtrapolation.Hold) {
            t2 = 0;
          }
        }
        if (handleLoop) {
          if (clipModel.loop) {
            loops += Math.floor(t2 / (duration + 1e-6));
            while (t2 > duration) {
              t2 -= duration;
            }
          }
        } else if (!isInTimeRange) {
          if (didPostExtrapolate) {
            switch (postExtrapolation) {
              case ClipExtrapolation.Hold:
                t2 = this.getClipTime(model.end, model);
                break;
              case ClipExtrapolation.Loop:
                t2 %= duration;
                break;
              case ClipExtrapolation.PingPong:
                const loops2 = Math.floor(t2 / duration);
                const invert = loops2 % 2 !== 0;
                t2 %= duration;
                if (invert)
                  t2 = duration - t2;
                break;
            }
          }
        }
        if (model.reversed === true)
          action.time = action.getClip().duration - t2;
        else
          action.time = t2;
        action.timeScale = 0;
        const effectiveWeight = Math.max(0, weight);
        action.weight = effectiveWeight;
        totalWeight += effectiveWeight;
        action.clampWhenFinished = false;
        if (!action.isRunning())
          action.play();
        if (this._useclipOffsets) {
          const totalPosition = activeClips == 0 ? this._totalOffsetPosition : this._totalOffsetPosition2;
          const totalRotation = activeClips == 0 ? this._totalOffsetRotation : this._totalOffsetRotation2;
          if (activeClips < 1)
            blend = 1 - weight;
          activeClips += 1;
          const summedPos = this._summedPos.set(0, 0, 0);
          const tempPos = this._tempPos.set(0, 0, 0);
          const summedRot = this._summedRot.identity();
          const tempRot = this._tempRot.identity();
          const clipOffsetRot = clipModel.rotation;
          if (clipOffsetRot) {
            this._clipRotQuat.identity();
            this._clipRotQuat.slerp(clipOffsetRot, weight);
          }
          const offsets = this._actionOffsets[i];
          if (offsets.hasOffsets) {
            for (let i2 = 0; i2 < loops; i2++) {
              if (offsets.rootPositionOffset)
                tempPos.copy(offsets.rootPositionOffset);
              else
                tempPos.set(0, 0, 0);
              tempPos.applyQuaternion(summedRot);
              if (this._clipRotQuat)
                tempPos.applyQuaternion(this._clipRotQuat);
              if (offsets.rootQuaternionOffset) {
                tempRot.copy(offsets.rootQuaternionOffset);
                summedRot.multiply(tempRot);
              }
              summedPos.add(tempPos);
            }
          }
          if (this._clipRotQuat)
            totalRotation.multiply(this._clipRotQuat);
          totalRotation.multiply(summedRot);
          if (clipModel.position)
            summedPos.add(clipModel.position);
          totalPosition.add(summedPos);
        }
      }
    }
    if (this._useclipOffsets) {
      this._totalOffsetPosition.lerp(this._totalOffsetPosition2, blend);
      this._totalOffsetRotation.slerp(this._totalOffsetRotation2, blend);
    }
    if (this["__mixerError"] === void 0 && (debug48 || isDevEnvironment()) && ((_b = (_a2 = this._animator) == null ? void 0 : _a2.runtimeAnimatorController) == null ? void 0 : _b.mixer) && this.mixer !== ((_d = (_c = this._animator) == null ? void 0 : _c.runtimeAnimatorController) == null ? void 0 : _d.mixer)) {
      this["__mixerError"] = true;
      console.error("AnimationTrack mixer is not shared with the animator controller - this might result in the timeline to not animate properly. Please report a bug to the Needle Engine team!", this);
    }
    if ((_e = this._animator) == null ? void 0 : _e.runtimeAnimatorController) {
      const weightLeft = Math.max(0, 1 - totalWeight);
      (_g = (_f = this._animator) == null ? void 0 : _f.runtimeAnimatorController) == null ? void 0 : _g.update(weightLeft);
    } else {
      this.mixer.update(time);
    }
  }
  createRotationInterpolant(_clip, _clipModel, track) {
    var _a2;
    const createInterpolantOriginal = track.createInterpolant.bind(track);
    const quat = new Quaternion();
    this.ensureTrackOffsets();
    const trackOffsetRot = (_a2 = this.trackOffset) == null ? void 0 : _a2.rotation;
    track.createInterpolant = () => {
      const createdInterpolant = createInterpolantOriginal();
      const interpolate = createdInterpolant.evaluate.bind(createdInterpolant);
      createdInterpolant.evaluate = (time) => {
        var _a3;
        const res = interpolate(time);
        quat.set(res[0], res[1], res[2], res[3]);
        quat.premultiply(this._totalOffsetRotation);
        if (trackOffsetRot)
          quat.premultiply(trackOffsetRot);
        if (this.director.animationCallbackReceivers) {
          for (const rec of this.director.animationCallbackReceivers) {
            (_a3 = rec == null ? void 0 : rec.onTimelineRotation) == null ? void 0 : _a3.call(rec, this.director, this.target, time, quat);
          }
        }
        res[0] = quat.x;
        res[1] = quat.y;
        res[2] = quat.z;
        res[3] = quat.w;
        return res;
      };
      return createdInterpolant;
    };
  }
  createPositionInterpolant(clip, clipModel, track) {
    var _a2, _b;
    const createInterpolantOriginal = track.createInterpolant.bind(track);
    const currentPosition = new Vector32();
    this.ensureTrackOffsets();
    const trackOffsetRot = (_a2 = this.trackOffset) == null ? void 0 : _a2.rotation;
    const trackOffsetPos = (_b = this.trackOffset) == null ? void 0 : _b.position;
    let startOffset = void 0;
    track.createInterpolant = () => {
      const createdInterpolant = createInterpolantOriginal();
      const evaluate = createdInterpolant.evaluate.bind(createdInterpolant);
      createdInterpolant.evaluate = (time) => {
        var _a3, _b2, _c;
        const res = evaluate(time);
        currentPosition.set(res[0], res[1], res[2]);
        if (clipModel.removeStartOffset) {
          if (startOffset === void 0) {
            startOffset = null;
            startOffset = (_b2 = (_a3 = this._actionOffsets.find((a) => a.clip === clip)) == null ? void 0 : _a3.rootStartPosition) == null ? void 0 : _b2.clone();
          } else if (startOffset == null ? void 0 : startOffset.isVector3) {
            currentPosition.sub(startOffset);
          }
        }
        currentPosition.applyQuaternion(this._totalOffsetRotation);
        currentPosition.add(this._totalOffsetPosition);
        if (trackOffsetRot)
          currentPosition.applyQuaternion(trackOffsetRot);
        if (trackOffsetPos) {
          currentPosition.x -= trackOffsetPos.x;
          currentPosition.y += trackOffsetPos.y;
          currentPosition.z += trackOffsetPos.z;
        }
        if (this.director.animationCallbackReceivers) {
          for (const rec of this.director.animationCallbackReceivers) {
            (_c = rec == null ? void 0 : rec.onTimelinePosition) == null ? void 0 : _c.call(rec, this.director, this.target, time, currentPosition);
          }
        }
        res[0] = currentPosition.x;
        res[1] = currentPosition.y;
        res[2] = currentPosition.z;
        return res;
      };
      return createdInterpolant;
    };
  }
};
var muteAudioTracks = getParam("mutetimeline");
var _AudioTrackHandler = class extends TrackHandler {
  constructor() {
    super(...arguments);
    __publicField(this, "models", []);
    __publicField(this, "listener");
    __publicField(this, "audio", []);
    __publicField(this, "audioContextTimeOffset", []);
    __publicField(this, "lastTime", 0);
    __publicField(this, "audioSource");
    __publicField(this, "_audioLoader", null);
    __publicField(this, "_playableDirectorResumed", false);
  }
  getAudioFilePath(path) {
    const glbLocation = this.director.sourceId;
    return resolveUrl(glbLocation, path);
  }
  onAllowAudioChanged(allow) {
    for (let i = 0; i < this.models.length; i++) {
      const model = this.models[i];
      const audio = this.audio[i];
      audio.setVolume(allow ? model.asset.volume : 0);
    }
  }
  addModel(model) {
    const audio = new Audio2(this.listener);
    this.audio.push(audio);
    const audioClipModel = model;
    audioClipModel._didTriggerPlay = false;
    this.models.push(audioClipModel);
  }
  onDisable() {
    for (const audio of this.audio) {
      if (audio.isPlaying)
        audio.stop();
    }
    for (const model of this.models) {
      model._didTriggerPlay = false;
    }
  }
  onDestroy() {
    for (const audio of this.audio) {
      if (audio.source)
        audio == null ? void 0 : audio.disconnect();
    }
    this.audio.length = 0;
  }
  onMuteChanged() {
    if (this.muted) {
      for (let i = 0; i < this.audio.length; i++) {
        const audio = this.audio[i];
        if (audio == null ? void 0 : audio.isPlaying)
          audio.stop();
      }
    }
  }
  stop() {
    for (let i = 0; i < this.audio.length; i++) {
      const audio = this.audio[i];
      if (audio == null ? void 0 : audio.isPlaying)
        audio.stop();
    }
    for (const model of this.models) {
      model._didTriggerPlay = false;
    }
  }
  onPauseChanged() {
    for (let i = 0; i < this.audio.length; i++) {
      const audio = this.audio[i];
      if (audio == null ? void 0 : audio.isPlaying)
        audio.stop();
    }
    this._playableDirectorResumed = this.director.isPlaying;
  }
  evaluate(time) {
    if (muteAudioTracks)
      return;
    if (this.track.muted)
      return;
    if (this.director.speed < 0) {
      return;
    }
    const isMuted = this.director.context.application.muted;
    const resumePlay = this._playableDirectorResumed;
    this._playableDirectorResumed = false;
    const playTimeOffset = isMuted ? 0.1 : 0;
    for (let i = 0; i < this.models.length; i++) {
      const model = this.models[i];
      const audio = this.audio[i];
      const asset = model.asset;
      if ((!audio || !audio.buffer) && this.isInTimeRange(model, time - 1, time + 1)) {
        this.handleAudioLoading(model, audio);
      }
      if (AudioSource.userInteractionRegistered === false)
        continue;
      if (audio === null || !audio.buffer)
        continue;
      audio.playbackRate = this.director.context.time.timeScale * this.director.speed;
      audio.loop = asset.loop;
      if (time >= model.start && time <= model.end && time < this.director.duration) {
        if (!audio.isPlaying || !this.director.isPlaying) {
          if (resumePlay || !model._didTriggerPlay && this.lastTime < time) {
            const clipDuration = model.duration * model.timeScale;
            if (clipDuration > 0.3)
              audio.offset = model.clipIn + (time - model.start) * model.timeScale;
            else
              audio.offset = 0;
            if (debug48)
              console.log("Timeline Audio (" + this.track.name + ") play with offset " + audio.offset + " - " + model.asset.clip);
            audio.play(playTimeOffset);
            model._didTriggerPlay = true;
          } else {
          }
        } else {
          const targetOffset = model.clipIn + (time - model.start) * model.timeScale;
          const currentTime = audio.context.currentTime - audio["_startedAt"] + audio.offset;
          const diff = Math.abs(targetOffset - currentTime);
          if (diff > 0.3) {
            audio.offset = targetOffset;
            audio.stop();
            audio.play(playTimeOffset);
          }
        }
        let vol = asset.volume;
        if (this.track.volume !== void 0)
          vol *= this.track.volume;
        if (isMuted)
          vol = 0;
        if (model.easeInDuration > 0) {
          const easeIn = Math.min((time - model.start) / model.easeInDuration, 1);
          vol *= easeIn;
        }
        if (model.easeOutDuration > 0) {
          const easeOut = Math.min((model.end - time) / model.easeOutDuration, 1);
          vol *= easeOut;
        }
        audio.setVolume(vol * this.director.weight);
      } else {
        model._didTriggerPlay = false;
        if (this.director.isPlaying) {
          if (audio.isPlaying) {
            audio.stop();
          }
        }
      }
    }
    this.lastTime = time;
  }
  /** Call to load audio buffer for a specific time in the track. Can be used to preload the timeline audio */
  loadAudio(time, lookAhead = 0, lookBehind = 0) {
    let promises = null;
    const rangeStart = time - lookBehind;
    const rangeEnd = time + lookAhead;
    for (const model of this.models) {
      if (this.isInTimeRange(model, rangeStart, rangeEnd)) {
        const audio = this.audio[this.models.indexOf(model)];
        const promise = this.handleAudioLoading(model, audio);
        if (promise !== null) {
          if (promises === null)
            promises = [];
          promises.push(promise);
        }
      }
    }
    if (promises !== null) {
      return Promise.all(promises);
    }
    return null;
  }
  isInTimeRange(model, start, end) {
    if (start <= model.start && end >= model.end)
      return true;
    if (start >= model.start && start <= model.end)
      return true;
    if (end >= model.start && end <= model.end)
      return true;
    return false;
  }
  static dispose() {
    _AudioTrackHandler._audioBuffers.clear();
  }
  handleAudioLoading(model, audio) {
    if (!this._audioLoader) {
      this._audioLoader = new AudioLoader();
    }
    const path = this.getAudioFilePath(model.asset.clip);
    if (_AudioTrackHandler._audioBuffers.get(path)) {
      const promise = _AudioTrackHandler._audioBuffers.get(path);
      promise.then((buffer2) => {
        if (buffer2)
          audio.setBuffer(buffer2);
      });
      return promise;
    }
    if (debug48)
      console.warn("LOAD audio track", path, this.director.sourceId);
    const loadingPromise = new Promise((resolve2, _reject) => {
      this._audioLoader.load(path, (buffer2) => {
        audio.setBuffer(buffer2);
        resolve2(buffer2);
      }, void 0, (err) => {
        console.error("Error loading audio", err);
        resolve2(null);
      });
    });
    _AudioTrackHandler._audioBuffers.set(path, loadingPromise);
    return loadingPromise;
  }
};
var AudioTrackHandler = _AudioTrackHandler;
__publicField(AudioTrackHandler, "_audioBuffers", /* @__PURE__ */ new Map());
var SignalTrackHandler = class extends TrackHandler {
  constructor() {
    super(...arguments);
    __publicField(this, "models", []);
    __publicField(this, "didTrigger", []);
    __publicField(this, "receivers", []);
  }
  // TODO: test when timeline signals are being reset in Unity
  // onEnable() {
  //     for (let i = 0; i < this.didTrigger?.length; i++) {
  //         this.didTrigger[i] = false;
  //     }
  // }
  // private _lastTime: number = -1;
  evaluate(time) {
    var _a2;
    if (this.track.muted)
      return;
    const estimatedFrameLengthWithPadding = this.director.context.time.deltaTime * 1.5;
    for (let i = 0; i < this.models.length; i++) {
      const model = this.models[i];
      const wasTriggered = this.didTrigger[i];
      const td = model.time - time;
      let isActive = false;
      if (model.retroActive) {
        isActive = td <= 1e-6;
      } else {
        const abs = Math.abs(td);
        if (abs === 0) {
          isActive = true;
        } else if (abs >= 1e-5 && abs < estimatedFrameLengthWithPadding) {
          isActive = true;
        }
      }
      if (isActive) {
        if (!wasTriggered) {
          if (debug48)
            console.log("Trigger signal", time, model.time, model);
          this.didTrigger[i] = true;
          if (((_a2 = this.receivers) == null ? void 0 : _a2.length) <= 0) {
            SignalReceiver.invoke(model.asset);
          } else {
            for (const rec of this.receivers) {
              if (!rec)
                continue;
              rec.invoke(model.asset);
            }
          }
        }
      } else {
        if (!model.emitOnce)
          this.didTrigger[i] = false;
      }
    }
  }
};
var ControlTrackHandler = class extends TrackHandler {
  constructor() {
    super(...arguments);
    __publicField(this, "models", []);
    __publicField(this, "timelines", []);
    __publicField(this, "_previousActiveModel", null);
  }
  resolveSourceObjects(_context) {
    for (let i = this.models.length - 1; i >= 0; i--) {
      const model = this.models[i];
      const asset = model.asset;
      if (!asset.sourceObject || typeof asset.sourceObject !== "object") {
        console.log("no source object, removing model", i, asset);
        this.models.splice(i, 1);
        continue;
      } else {
        const timeline = GameObject.getComponent(asset.sourceObject, PlayableDirector);
        this.timelines.push(timeline);
        if (timeline) {
          if (asset.updateDirector) {
            timeline.playOnAwake = false;
          }
        }
      }
    }
  }
  evaluate(time) {
    var _a2;
    this._previousActiveModel = null;
    for (let i = 0; i < this.models.length; i++) {
      const model = this.models[i];
      const asset = model.asset;
      if (time >= model.start && time <= model.end) {
        this._previousActiveModel = model;
        const clipTime = this.getClipTime(time, model);
        if (asset.controlActivation) {
          const obj = asset.sourceObject;
          obj.visible = true;
        }
        if (asset.updateDirector) {
          const timeline = this.timelines[i];
          if (timeline) {
            if (timeline.isPlaying) {
              timeline.pause();
            }
            timeline.time = clipTime;
            timeline.evaluate();
          }
        }
      } else {
        const previousActiveAsset = (_a2 = this._previousActiveModel) == null ? void 0 : _a2.asset;
        if (asset.controlActivation) {
          const obj = asset.sourceObject;
          if ((previousActiveAsset == null ? void 0 : previousActiveAsset.sourceObject) !== obj)
            obj.visible = false;
        }
      }
    }
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/postprocessing/utils.js
var debug49 = getParam("debugpost");
var PostprocessingManagerType = null;
function setPostprocessingManagerType(type) {
  PostprocessingManagerType = type;
}
function findPostProcessingManager(effect) {
  let obj = effect.gameObject;
  while (obj) {
    for (const comp of foreachComponentEnumerator(obj)) {
      if (comp.isPostProcessingManager === true) {
        return comp;
      }
    }
    obj = obj.parent;
  }
  return null;
}
function getPostProcessingManager(effect) {
  let manager = findPostProcessingManager(effect);
  if (!manager) {
    if (PostprocessingManagerType) {
      if (debug49)
        console.warn("Adding postprocessing manager to the scene.");
      const scene = effect.scene;
      manager = addComponent(scene, PostprocessingManagerType);
    } else {
      if (isDevEnvironment())
        console.warn("No post processing manager found");
    }
  }
  return manager;
}

// node_modules/@needle-tools/engine/lib/engine-components/postprocessing/VolumeParameter.js
var __decorate14 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug50 = getParam("debugpost");
var VolumeParameter = class {
  constructor(value) {
    __publicField(this, "isVolumeParameter", true);
    __publicField(this, "_isInitialized", false);
    __publicField(this, "_active", true);
    __publicField(this, "_value");
    __publicField(this, "_valueRaw");
    __publicField(this, "_defaultValue");
    /** called to modify a changing value before it is saved */
    __publicField(this, "valueProcessor");
    /** called when a value has changed (with the final value) */
    __publicField(this, "onValueChanged");
    if (value !== void 0)
      this.initialize(value);
  }
  get isInitialized() {
    return this._isInitialized;
  }
  initialize(value) {
    if (value !== void 0) {
      this._value = value;
      this._defaultValue = value;
      this._valueRaw = value;
      this._isInitialized = true;
    }
  }
  get overrideState() {
    return this._active;
  }
  set overrideState(val) {
    if (this._active === val)
      return;
    this._active = val;
    const value = val ? this._valueRaw : this._defaultValue;
    this.processValue(value, true);
  }
  get value() {
    return this._valueRaw;
  }
  set value(val) {
    if (!this.isInitialized)
      this.initialize(val);
    this.processValue(val, false);
  }
  set defaultValue(val) {
    this._defaultValue = val;
  }
  /** enforce the value to be set and onValueChanged to be called if assigned */
  __init() {
    this.processValue(this._valueRaw, true);
  }
  processValue(val, forceUpdate) {
    if (val === null || val === void 0)
      return;
    if (!forceUpdate && this.testIfValueChanged(val) === false)
      return;
    const oldValue = this._value;
    if (debug50) {
      let hasChanged = true;
      if (typeof oldValue == "number" && typeof val == "number") {
        const oldFixed = oldValue == null ? void 0 : oldValue.toFixed(4);
        const newFixed = val == null ? void 0 : val.toFixed(4);
        if (oldFixed != newFixed) {
          hasChanged = true;
        } else
          hasChanged = false;
      }
    }
    if (!this._active && this._defaultValue !== void 0) {
      this._value = this._defaultValue;
      val = this._defaultValue;
      this._valueRaw = val;
    } else {
      this._valueRaw = val;
      if (this._active && this.valueProcessor)
        val = this.valueProcessor(val);
      this._value = val;
    }
    if (this.onValueChanged) {
      this.onValueChanged(val, oldValue, this);
    }
  }
  testIfValueChanged(newValue) {
    if (this._valueRaw === newValue)
      return false;
    return true;
  }
};
__decorate14([
  serializable()
], VolumeParameter.prototype, "overrideState", null);
__decorate14([
  serializable()
], VolumeParameter.prototype, "value", null);
var VolumeParameterSerializer = class extends TypeSerializer {
  constructor() {
    super([VolumeParameter]);
  }
  onSerialize(_data, _context) {
  }
  onDeserialize(data, context) {
    const target = context.target;
    const name = context.path;
    let parameter;
    if (target && name) {
      parameter = target[name];
    }
    if (!(typeof parameter === "object") || typeof parameter === "object" && parameter.isVolumeParameter !== true) {
      parameter = new VolumeParameter();
    }
    if (typeof data === "object" && "value" in data) {
      const value = data.value;
      parameter.initialize(value);
      parameter.overrideState = data.overrideState;
    } else {
      parameter.value = data;
    }
    return parameter;
  }
};
new VolumeParameterSerializer();

// node_modules/@needle-tools/engine/lib/engine-components/postprocessing/PostProcessingEffect.js
var __decorate15 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug51 = getParam("debugpost");
var PostProcessingEffect = class extends Component2 {
  constructor(params = void 0) {
    super();
    __publicField(this, "active", true);
    __publicField(this, "_manager", null);
    /** previously created effect (if any) */
    __publicField(this, "_result");
    __publicField(this, "_postprocessingContext", null);
    if (params) {
      for (const key of Object.keys(params)) {
        const value = params[key];
        const param = this[key];
        if (param instanceof VolumeParameter) {
          param.initialize(value);
        } else if (param !== void 0) {
          this[key] = value;
        }
      }
    }
  }
  get isPostProcessingEffect() {
    return true;
  }
  onEnable() {
    super.onEnable();
    this.onEffectEnabled();
    if (this.__internalDidAwakeAndStart)
      this.active = true;
  }
  onDisable() {
    var _a2;
    super.onDisable();
    (_a2 = this._manager) == null ? void 0 : _a2.removeEffect(this);
    this.active = false;
  }
  onEffectEnabled(manager) {
    var _a2;
    if (manager && manager.isPostProcessingManager === true)
      this._manager = manager;
    else if (!this._manager)
      this._manager = getPostProcessingManager(this);
    (_a2 = this._manager) == null ? void 0 : _a2.addEffect(this);
  }
  /** override to initialize bindings on parameters */
  init() {
  }
  get postprocessingContext() {
    return this._postprocessingContext;
  }
  /** Apply post settings. Make sure to call super.apply() if you also create an effect */
  apply(ctx) {
    var _a2;
    this._postprocessingContext = ctx;
    if (!this._result) {
      this.initParameters();
      this._result = (_a2 = this.onCreateEffect) == null ? void 0 : _a2.call(this);
    }
    if (this._result) {
      this.initParameters();
    }
    return this._result;
  }
  /** Reset previously set values (e.g. when adjusting settings on the renderer like Tonemapping) */
  unapply() {
  }
  dispose() {
    if (debug51)
      console.warn("DISPOSE", this);
    if (this._result) {
      if (Array.isArray(this._result)) {
        this._result.forEach((r) => r.dispose());
      } else {
        this._result.dispose();
      }
    }
    this._result = void 0;
  }
  initParameters() {
    const keys = Object.keys(this);
    for (const key of keys) {
      const value = this[key];
      if (value instanceof VolumeParameter) {
        value.__init();
      }
    }
  }
  // TODO this is currently not used for post processing effects that are part of Volume stacks,
  // since these handle that already.
  onEditorModification(modification) {
    const key = modification.propertyName;
    if (this[key] instanceof VolumeParameter) {
      const value = modification.value;
      this[key].value = value;
      return true;
    }
  }
};
__decorate15([
  serializable()
], PostProcessingEffect.prototype, "active", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/postprocessing/VolumeProfile.js
var __decorate16 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug52 = getParam("debugpost");
var customEffects = {};
function registerCustomEffectType(name, effect) {
  customEffects[name] = effect;
}
function resolveComponentType(data) {
  if (data.__type in customEffects)
    return customEffects[data.__type];
  if (debug52 && data.__type)
    console.warn("Unknown postprocessing type", data.__type, data);
  return PostProcessingEffect;
}
var VolumeProfile = class {
  constructor() {
    /** effects added to the volume */
    __publicField(this, "components", []);
  }
  /**
   * call init on all components
   * @hidden
   **/
  init() {
    var _a2;
    (_a2 = this.components) == null ? void 0 : _a2.forEach((c2) => c2.init());
  }
  addEffect(effect) {
    this.components.push(effect);
  }
  removeEffect(effect) {
    const idx = this.components.indexOf(effect);
    if (idx >= 0)
      this.components.splice(idx, 1);
  }
};
__decorate16([
  serializeable([(d) => resolveComponentType(d), PostProcessingEffect])
], VolumeProfile.prototype, "components", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/postprocessing/Effects/Antialiasing.js
var __decorate17 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var QualityLevel;
(function(QualityLevel2) {
  QualityLevel2[QualityLevel2["LOW"] = 0] = "LOW";
  QualityLevel2[QualityLevel2["MEDIUM"] = 1] = "MEDIUM";
  QualityLevel2[QualityLevel2["HIGH"] = 2] = "HIGH";
  QualityLevel2[QualityLevel2["ULTRA"] = 3] = "ULTRA";
})(QualityLevel || (QualityLevel = {}));
var Antialiasing = class extends PostProcessingEffect {
  constructor() {
    super(...arguments);
    // @serializable(VolumeParameter)
    // edgeDetectionThreshold!: VolumeParameter;
    __publicField(this, "preset", new VolumeParameter(SMAAPreset.HIGH));
  }
  get typeName() {
    return "Antialiasing";
  }
  onCreateEffect() {
    const effect = new SMAAEffect({
      preset: SMAAPreset.HIGH,
      edgeDetectionMode: EdgeDetectionMode.DEPTH
    });
    this.preset.onValueChanged = (newValue) => {
      effect.applyPreset(newValue);
    };
    return effect;
  }
};
__decorate17([
  serializable(VolumeParameter)
], Antialiasing.prototype, "preset", void 0);
registerCustomEffectType("Antialiasing", Antialiasing);

// node_modules/@needle-tools/engine/lib/engine-components/export/usdz/extensions/behavior/AudioExtension.js
var debug53 = getParam("debugusdz");
var AudioExtension = class {
  constructor() {
    __publicField(this, "files", new Array());
  }
  static getName(clip) {
    var _a2;
    const clipExt = clip.split(".").pop();
    const fileWithoutExt = clip.split(".").slice(0, -1).join(".");
    let clipName = (_a2 = fileWithoutExt.split("/").pop()) == null ? void 0 : _a2.replace(".", "_");
    if (!clipName) {
      clipName = "Audio_" + Math.random().toString(36).substring(2, 15);
    }
    return makeNameSafe(clipName) + "." + clipExt;
  }
  get extensionName() {
    return "Audio";
  }
  onExportObject(object, model, _context) {
    const audioSources = GameObject.getComponents(object, AudioSource);
    if (audioSources.length) {
      for (const audioSource of audioSources) {
        if (!audioSource.clip)
          continue;
        if (typeof audioSource.clip !== "string")
          continue;
        if (!audioSource.playOnAwake)
          continue;
        const clipName = audioSource.clip.split("/").pop() || "Audio";
        const safeClipNameWithExt = AudioExtension.getName(audioSource.clip);
        const safeClipName = makeNameSafe(safeClipNameWithExt);
        if (!this.files.some((f2) => f2.path === audioSource.clip)) {
          this.files.push({ path: audioSource.clip, name: safeClipNameWithExt });
          const lowerCase = safeClipNameWithExt.toLowerCase();
          if (_context.quickLookCompatible && !lowerCase.endsWith(".mp3") && !lowerCase.endsWith(".wav") && !lowerCase.endsWith(".m4a")) {
            console.error("Audio file " + audioSource.clip + " from " + audioSource.name + " is not an MP3 or WAV file. QuickLook may not support playing it.");
          }
        }
        if (!_context.quickLookCompatible) {
          model.addEventListener("serialize", (writer, _context2) => {
            writer.appendLine();
            writer.beginBlock(`def SpatialAudio "${safeClipName}"`, "(", false);
            writer.appendLine(`displayName = "${clipName}"`);
            writer.closeBlock(")");
            writer.beginBlock();
            writer.appendLine(`uniform asset filePath = @audio/${safeClipNameWithExt}@`);
            writer.appendLine(`uniform token auralMode = "${audioSource.spatialBlend > 0 ? "spatial" : "nonSpatial"}"`);
            writer.appendLine(`uniform token playbackMode = "${audioSource.loop ? "loopFromStage" : "onceFromStart"}"`);
            writer.appendLine(`uniform float gain = ${audioSource.volume}`);
            writer.closeBlock();
          });
        }
      }
    }
  }
  async onAfterSerialize(context) {
    for (const file of this.files) {
      const key = "audio/" + file.name;
      if (context.files[key]) {
        if (debug53)
          console.warn("Audio file with name " + key + " already exists in the context. Skipping.");
        continue;
      }
      const audio = await fetch(file.path);
      const audioBlob = await audio.blob();
      const arrayBuffer = await audioBlob.arrayBuffer();
      const audioData = new Uint8Array(arrayBuffer);
      context.files[key] = audioData;
    }
  }
};

// node_modules/@needle-tools/engine/lib/engine/engine_networking_auto.js
var debug54 = getParam("debugautosync");
var $syncerId = Symbol("syncerId");
var ComponentsSyncerManager = class {
  constructor() {
    __publicField(this, "_syncers", {});
  }
  getOrCreateSyncer(comp) {
    if (!comp.guid)
      return null;
    if (this._syncers[comp.guid])
      return this._syncers[comp.guid];
    const syncer = new ComponentPropertiesSyncer(comp);
    syncer[$syncerId] = comp.guid;
    this._syncers[syncer[$syncerId]] = syncer;
    return syncer;
  }
  removeSyncer(syncer) {
    delete this._syncers[syncer[$syncerId]];
  }
};
var syncerHandler = new ComponentsSyncerManager();
var ComponentPropertiesSyncer = class {
  constructor(comp) {
    __publicField(this, "comp");
    // private getters: { [key: string]: Function } = {};
    __publicField(this, "hasChanges", false);
    __publicField(this, "changedProperties", {});
    /** is set to true in on receive call to avoid circular sending */
    __publicField(this, "_isReceiving", false);
    __publicField(this, "_isInit", false);
    __publicField(this, "onHandleSending", () => {
      if (!this.hasChanges)
        return;
      this.hasChanges = false;
      const net = this.comp.context.connection;
      if (!net || !net.isConnected || !net.isInRoom) {
        for (const key in this.changedProperties)
          delete this.changedProperties[key];
        return;
      }
      for (const name in this.changedProperties) {
        const guid = this.comp.guid + "/" + name;
        const value = this.changedProperties[name];
        if (debug54)
          console.log("SEND", this.comp.name, this.networkingKey);
        net.send(this.networkingKey, { guid, data: value }, SendQueue.Queued);
      }
    });
    __publicField(this, "onHandleReceiving", (val) => {
      if (debug54)
        console.log("RECEIVE", this.comp.name, this.comp.guid, val);
      if (!this._isInit)
        return;
      if (!this.comp)
        return;
      if (val.guid.startsWith(this.comp.guid) === false) {
        return;
      }
      const [_guid, key] = val.guid.split("/");
      if (debug54)
        console.log("RECEIVED", this.comp.name, this.comp.guid, val);
      try {
        this._isReceiving = true;
        this.comp[key] = val.data;
      } catch (err) {
        console.error(err);
      } finally {
        this._isReceiving = false;
      }
    });
    this.comp = comp;
  }
  // private data = {};
  get networkingKey() {
    return this.comp.guid;
  }
  init(comp) {
    if (this._isInit)
      return;
    this._isInit = true;
    this.comp = comp;
    this.comp.context.post_render_callbacks.push(this.onHandleSending);
    this.comp.context.connection.beginListen(this.networkingKey, this.onHandleReceiving);
    const state = this.comp.context.connection.tryGetState(this.comp.guid);
    if (state)
      this.onHandleReceiving(state);
  }
  destroy() {
    if (!this._isInit)
      return;
    this.comp.context.post_render_callbacks.splice(this.comp.context.post_render_callbacks.indexOf(this.onHandleSending), 1);
    this.comp.context.connection.stopListen(this.networkingKey, this.onHandleReceiving);
    this.comp = null;
    this._isInit = false;
  }
  notifyChanged(propertyName, value) {
    if (this._isReceiving)
      return;
    if (debug54)
      console.log("Property changed: " + propertyName, value);
    this.hasChanges = true;
    this.changedProperties[propertyName] = value;
  }
};
function testValueChanged(newValue, previousValue) {
  let valueChanged = previousValue !== newValue;
  if (!valueChanged && newValue && previousValue) {
    if (Array.isArray(newValue) && Array.isArray(previousValue)) {
      valueChanged = true;
    } else if (typeof newValue === "object" && typeof previousValue === "object") {
      valueChanged = true;
    }
  }
  return valueChanged;
}
var $syncer = Symbol("AutoSyncHandler");
function getSyncer(instance) {
  if (instance[$syncer]) {
    return instance[$syncer];
  }
  const syncer = syncerHandler.getOrCreateSyncer(instance);
  syncer == null ? void 0 : syncer.init(instance);
  instance[$syncer] = syncer;
  return syncer;
}
function destroySyncer(instance) {
  const syncer = instance[$syncer];
  if (syncer) {
    syncerHandler.removeSyncer(syncer);
    syncer.destroy();
    delete instance[$syncer];
  }
}
var syncField = function(onFieldChanged = null) {
  return function(target, _propertyKey) {
    var _a2;
    let propertyKey = "";
    if (typeof _propertyKey === "string")
      propertyKey = _propertyKey;
    else
      propertyKey = _propertyKey.name;
    let syncer = null;
    let fn2 = void 0;
    if (typeof onFieldChanged === "string")
      fn2 = target[onFieldChanged];
    else if (typeof onFieldChanged === "function") {
      fn2 = onFieldChanged;
    }
    if (fn2 == void 0) {
      if (isDevEnvironment() || debug54) {
        if (onFieldChanged != void 0)
          console.warn('syncField: no callback function found for property "' + propertyKey + '"', '"' + onFieldChanged + '"');
      }
    }
    const t2 = target;
    const internalAwake = t2.__internalAwake;
    if (typeof internalAwake !== "function") {
      if (debug54 || isDevEnvironment())
        console.error('@syncField can currently only used on Needle Engine Components, custom object of type "' + ((_a2 = target == null ? void 0 : target.constructor) == null ? void 0 : _a2.name) + '" is not supported', target);
      return;
    }
    if (debug54)
      console.log(propertyKey);
    const backingFieldName = Symbol(propertyKey);
    t2.__internalAwake = function() {
      if (this[backingFieldName] !== void 0) {
        return;
      }
      this[backingFieldName] = this[propertyKey];
      syncer = syncerHandler.getOrCreateSyncer(this);
      const desc = Object.getOwnPropertyDescriptor(this, propertyKey);
      if ((desc == null ? void 0 : desc.set) === void 0) {
        let invokingCallback = false;
        Object.defineProperty(this, propertyKey, {
          set: function(value) {
            var _a3;
            const oldValue = this[backingFieldName];
            this[backingFieldName] = value;
            if (invokingCallback) {
              if (isDevEnvironment() || debug54)
                console.warn("Recursive call detected", propertyKey);
              return;
            }
            invokingCallback = true;
            try {
              const valueChanged = testValueChanged(value, oldValue);
              if (debug54)
                console.log("SyncField assignment", propertyKey, "changed?", valueChanged, value, fn2);
              if (valueChanged) {
                const res = fn2 == null ? void 0 : fn2.call(this, value, oldValue);
                if (res !== false) {
                  (_a3 = getSyncer(this)) == null ? void 0 : _a3.notifyChanged(propertyKey, value);
                }
              }
            } finally {
              invokingCallback = false;
            }
          },
          get: function() {
            return this[backingFieldName];
          },
          configurable: true,
          enumerable: true
        });
      }
      syncer == null ? void 0 : syncer.init(this);
      internalAwake.call(this);
    };
    const internalDestroy2 = t2.__internalDestroy;
    t2.__internalDestroy = function() {
      destroySyncer(this);
      internalDestroy2.call(this);
    };
  };
};

// node_modules/@needle-tools/engine/lib/engine-components-experimental/networking/PlayerSync.js
var __decorate18 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug55 = getParam("debugplayersync");
var PlayerSync = class extends Component2 {
  constructor() {
    super(...arguments);
    /** when enabled PlayerSync will automatically load and instantiate the assigned asset when joining a networked room */
    __publicField(this, "autoSync", true);
    /** This asset will be loaded and instantiated when PlayerSync becomes active and joins a networked room */
    __publicField(this, "asset");
    /** Event called when an instance is spawned */
    __publicField(this, "onPlayerSpawned");
    __publicField(this, "_localInstance");
    __publicField(this, "onJoinedRoom", () => {
      if (debug55)
        console.log("PlayerSync.joinedRoom. autoSync is set to " + this.autoSync);
      if (this.autoSync)
        this.getInstance();
    });
    __publicField(this, "destroyInstance", () => {
      var _a2;
      (_a2 = this._localInstance) == null ? void 0 : _a2.then((go) => {
        if (debug55)
          console.log("PlayerSync.destroyInstance", go);
        syncDestroy(go, this.context.connection, true, { saveInRoom: false });
      });
      this._localInstance = void 0;
    });
  }
  /**
   * This API is experimental and may change or be removed in the future.
   * Create a PlayerSync instance at runtime from a given URL
   * @example
   * ```typescript
   * const res = await PlayerSync.setupFrom("/assets/demo.glb");
   * addComponent(res.asset?.asset, DragControls);
   * addComponent(res.asset?.asset, SyncedTransform);
   * scene.add(res.gameObject);
   * ```
   */
  static async setupFrom(url, init) {
    const assetReference = AssetReference.getOrCreateFromUrl(url);
    if (!assetReference.asset) {
      const i = await assetReference.loadAssetAsync();
      GameObject.getOrAddComponent(i, PlayerState);
    }
    const ps = new PlayerSync();
    ps._internalInit(init);
    ps.asset = assetReference;
    const obj = new Object3D();
    obj["guid"] = url;
    GameObject.addComponent(obj, ps);
    return ps;
  }
  awake() {
    this.watchTabVisible();
    if (!this.onPlayerSpawned)
      this.onPlayerSpawned = new EventList();
  }
  onEnable() {
    this.context.connection.beginListen(RoomEvents.RoomStateSent, this.onJoinedRoom);
    this.context.connection.beginListen(RoomEvents.JoinedRoom, this.onJoinedRoom);
    this.context.connection.beginListen(RoomEvents.LeftRoom, this.destroyInstance);
    if (this.context.connection.isInRoom) {
      this.onJoinedRoom();
    }
  }
  onDisable() {
    this.context.connection.stopListen(RoomEvents.RoomStateSent, this.onJoinedRoom);
    this.context.connection.stopListen(RoomEvents.JoinedRoom, this.onJoinedRoom);
    this.context.connection.stopListen(RoomEvents.LeftRoom, this.destroyInstance);
  }
  async getInstance() {
    var _a2, _b, _c, _d, _e, _f;
    if (this._localInstance)
      return this._localInstance;
    if (debug55)
      console.log("PlayerSync.createInstance", (_a2 = this.asset) == null ? void 0 : _a2.url);
    if (!((_b = this.asset) == null ? void 0 : _b.asset) && !((_c = this.asset) == null ? void 0 : _c.url)) {
      console.error('PlayerSync: can not create an instance because "asset" is not set and or has no URL!');
      return null;
    }
    if (!this.gameObject.guid) {
      console.warn("PlayerSync: gameObject has no guid! This might cause issues with syncing the player state.");
    }
    this._localInstance = (_d = this.asset) == null ? void 0 : _d.instantiateSynced({ parent: this.gameObject, deleteOnDisconnect: true }, true);
    const instance = await this._localInstance;
    if (instance) {
      const pl = GameObject.getComponentsInChildren(instance, PlayerState);
      if (pl == null ? void 0 : pl.length) {
        for (const state of pl)
          state.owner = this.context.connection.connectionId;
        (_e = this.onPlayerSpawned) == null ? void 0 : _e.invoke(instance);
      } else {
        this._localInstance = void 0;
        console.error("<strong>Failed finding PlayerState on " + ((_f = this.asset) == null ? void 0 : _f.url) + "</strong>: please make sure the asset has a PlayerState component!");
        GameObject.destroySynced(instance);
      }
    } else {
      this._localInstance = void 0;
      console.warn("PlayerSync: failed instantiating asset!");
    }
    return this._localInstance;
  }
  watchTabVisible() {
    window.addEventListener("visibilitychange", (_) => {
      if (document.visibilityState === "visible") {
        for (let i = PlayerState.all.length - 1; i >= 0; i--) {
          const pl = PlayerState.all[i];
          if (!pl.owner || !this.context.connection.userIsInRoom(pl.owner)) {
            pl.doDestroy();
          }
        }
      }
    });
  }
};
__decorate18([
  serializable()
], PlayerSync.prototype, "autoSync", void 0);
__decorate18([
  serializable(AssetReference)
], PlayerSync.prototype, "asset", void 0);
__decorate18([
  serializable(EventList)
], PlayerSync.prototype, "onPlayerSpawned", void 0);
var PlayerStateEvent;
(function(PlayerStateEvent2) {
  PlayerStateEvent2["OwnerChanged"] = "ownerChanged";
})(PlayerStateEvent || (PlayerStateEvent = {}));
var _PlayerState = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "onOwnerChangeEvent", new EventList());
    __publicField(this, "onFirstOwnerChangeEvent", new EventList());
    __publicField(this, "hasOwner", false);
    __publicField(this, "owner");
    /** when enabled PlayerSync will not destroy itself when not connected anymore */
    __publicField(this, "dontDestroy", false);
    __publicField(this, "onUserLeftRoom", (model) => {
      if (model.userId === this.owner) {
        if (debug55)
          console.log("PLAYERSYNC LEFT", this.owner);
        this.doDestroy();
        return;
      }
    });
  }
  /** all instances for all players */
  static get all() {
    return _PlayerState._all;
  }
  /** all instances for the local player */
  static get local() {
    return _PlayerState._local;
  }
  static getFor(obj) {
    if (obj instanceof Object3D) {
      return GameObject.getComponentInParent(obj, _PlayerState);
    } else if (obj instanceof Component2) {
      return GameObject.getComponentInParent(obj.gameObject, _PlayerState);
    }
    return void 0;
  }
  //** use to check if a component or gameobject is part of a instance owned by the local player */
  static isLocalPlayer(obj) {
    const state = _PlayerState.getFor(obj);
    return (state == null ? void 0 : state.isLocalPlayer) ?? false;
  }
  /**
   * Add a callback for a PlayerStateEvent
   */
  static addEventListener(event, cb) {
    if (!this._callbacks[event])
      this._callbacks[event] = [];
    this._callbacks[event].push(cb);
    return cb;
  }
  static removeEventListener(event, cb) {
    if (!this._callbacks[event])
      return;
    const index = this._callbacks[event].indexOf(cb);
    if (index >= 0)
      this._callbacks[event].splice(index, 1);
  }
  static dispatchEvent(event, args) {
    if (!this._callbacks[event])
      return;
    for (const cb of this._callbacks[event]) {
      cb(args);
    }
  }
  get isLocalPlayer() {
    return this.owner === this.context.connection.connectionId;
  }
  onOwnerChange(newOwner, oldOwner) {
    var _a2, _b;
    if (debug55)
      console.log("PlayerSync.onOwnerChange", this, "newOwner", newOwner, "oldOwner", oldOwner);
    const index = _PlayerState._local.indexOf(this);
    if (index >= 0)
      _PlayerState._local.splice(index, 1);
    const detail = {
      playerState: this,
      oldValue: oldOwner,
      newValue: newOwner
    };
    if (!this.hasOwner) {
      this.hasOwner = true;
      (_a2 = this.onFirstOwnerChangeEvent) == null ? void 0 : _a2.invoke(detail);
    }
    (_b = this.onOwnerChangeEvent) == null ? void 0 : _b.invoke(detail);
    if (this.owner === this.context.connection.connectionId) {
      _PlayerState._local.push(this);
      const evt2 = new CustomEvent("local-owner-changed", { detail });
      this.dispatchEvent(evt2);
    }
    const evt = new CustomEvent("owner-changed", { detail });
    this.dispatchEvent(evt);
    _PlayerState.dispatchEvent(PlayerStateEvent.OwnerChanged, evt);
  }
  awake() {
    _PlayerState.all.push(this);
    if (debug55)
      console.log("Registered new PlayerState", this.guid, _PlayerState.all.length - 1, _PlayerState.all);
    this.context.connection.beginListen(RoomEvents.UserLeftRoom, this.onUserLeftRoom);
  }
  async start() {
    if (debug55)
      console.log("PLAYERSTATE.START, owner: " + this.owner, this.context.connection.usersInRoom([]));
    if (this.owner) {
      if (!this.context.connection.isInRoom)
        await delay(300);
      if (this.context.connection.userIsInRoom(this.owner) == false) {
        if (debug55)
          console.log(`PlayerSync.start → doDestroy "${this.name}" because user "${this.owner}" is not in room anymore...`, "Currently in room:", ...this.context.connection.usersInRoom());
        this.doDestroy();
      }
    } else if (!this.owner) {
      if (debug55)
        console.warn("PlayerState.start → owner is undefined!", this.name);
      setTimeout(() => {
        if (!this.destroyed && !this.owner) {
          if (!this.dontDestroy) {
            if (debug55)
              console.warn(`PlayerState.start → owner is still undefined: destroying "${this.name}" instance now`);
            this.doDestroy();
          } else if (debug55)
            console.warn("PlayerState.start → owner is still undefined but dontDestroy is set to true", this.name);
        } else if (debug55)
          console.log("PlayerState.start → owner is assigned", this.owner);
      }, 2e3);
    }
  }
  // onEnable() {
  //     if (debug) this.startCoroutine(this.debugRoutine());
  // }
  // *debugRoutine() {
  //     while (!this.destroyed && this.activeAndEnabled) {
  //         Gizmos.DrawLabel(this.gameObject.worldPosition, this.owner ?? "no owner");
  //         yield;
  //     }
  // }
  /** this tells the server that this client has been destroyed and the networking message for the instantiate will be removed */
  doDestroy() {
    if (debug55)
      console.log("PlayerSync.doDestroy → syncDestroy", this.name);
    syncDestroy(this.gameObject, this.context.connection, true, { saveInRoom: false });
  }
  onDestroy() {
    this.context.connection.stopListen(RoomEvents.UserLeftRoom, this.onUserLeftRoom);
    _PlayerState.all.splice(_PlayerState.all.indexOf(this), 1);
    if (this.isLocalPlayer) {
      const index = _PlayerState._local.indexOf(this);
      if (index >= 0)
        _PlayerState._local.splice(index, 1);
    }
  }
};
var PlayerState = _PlayerState;
__publicField(PlayerState, "_all", []);
__publicField(PlayerState, "_local", []);
// static Callback
__publicField(PlayerState, "_callbacks", {});
__decorate18([
  syncField(PlayerState.prototype.onOwnerChange)
], PlayerState.prototype, "owner", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/webxr/WebXRAvatar.js
var debug56 = getParam("debugavatar");
var _AvatarMarker = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "connectionId");
    __publicField(this, "avatar");
  }
  static getAvatar(index) {
    if (index >= 0 && index < _AvatarMarker.instances.length)
      return _AvatarMarker.instances[index];
    return null;
  }
  static onAvatarMarkerCreated(cb) {
    _AvatarMarker._onNewAvatarMarkerAdded.push(cb);
    return cb;
  }
  static onAvatarMarkerDestroyed(cb) {
    _AvatarMarker._onAvatarMarkerDestroyed.push(cb);
    return cb;
  }
  awake() {
    _AvatarMarker.instances.push(this);
    if (debug56)
      console.log(this);
    for (const cb of _AvatarMarker._onNewAvatarMarkerAdded)
      cb({ avatarMarker: this, gameObject: this.gameObject });
  }
  onDestroy() {
    _AvatarMarker.instances.splice(_AvatarMarker.instances.indexOf(this), 1);
    for (const cb of _AvatarMarker._onAvatarMarkerDestroyed)
      cb({ avatarMarker: this, gameObject: this.gameObject });
  }
  isLocalAvatar() {
    return this.connectionId === this.context.connection.connectionId;
  }
};
var AvatarMarker = _AvatarMarker;
__publicField(AvatarMarker, "instances", []);
__publicField(AvatarMarker, "_onNewAvatarMarkerAdded", []);
__publicField(AvatarMarker, "_onAvatarMarkerDestroyed", []);

// node_modules/@needle-tools/engine/lib/engine-components/webxr/XRFlag.js
var __decorate19 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug57 = getParam("debugxrflags");
var disable = getParam("disablexrflags");
if (disable) {
  console.warn("XRFlags are disabled");
}
var XRStateFlag;
(function(XRStateFlag2) {
  XRStateFlag2[XRStateFlag2["Never"] = 0] = "Never";
  XRStateFlag2[XRStateFlag2["Browser"] = 1] = "Browser";
  XRStateFlag2[XRStateFlag2["AR"] = 2] = "AR";
  XRStateFlag2[XRStateFlag2["VR"] = 4] = "VR";
  XRStateFlag2[XRStateFlag2["FirstPerson"] = 8] = "FirstPerson";
  XRStateFlag2[XRStateFlag2["ThirdPerson"] = 16] = "ThirdPerson";
  XRStateFlag2[XRStateFlag2["All"] = 4294967295] = "All";
})(XRStateFlag || (XRStateFlag = {}));
var _XRState = class {
  constructor() {
    __publicField(this, "Mask", XRStateFlag.Browser | XRStateFlag.ThirdPerson);
  }
  Has(state) {
    const res = this.Mask & state;
    return res !== 0;
  }
  Set(state) {
    if (debug57)
      console.warn("Set XR flag state to", state);
    this.Mask = state;
    XRFlag.Apply();
  }
  Enable(state) {
    this.Mask |= state;
    XRFlag.Apply();
  }
  Disable(state) {
    this.Mask &= ~state;
    XRFlag.Apply();
  }
  Toggle(state) {
    this.Mask ^= state;
    XRFlag.Apply();
  }
  EnableAll() {
    this.Mask = 4294967295 | 0;
    XRFlag.Apply();
  }
  DisableAll() {
    this.Mask = 0;
    XRFlag.Apply();
  }
};
var XRState = _XRState;
__publicField(XRState, "Global", new _XRState());
var _XRFlag = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "visibleIn");
  }
  static Apply() {
    for (const r of this.registry)
      r.UpdateVisible(XRState.Global);
  }
  awake() {
    _XRFlag.registry.push(this);
  }
  onEnable() {
    if (!_XRFlag.firstApply) {
      _XRFlag.firstApply = true;
      _XRFlag.Apply();
    } else {
      this.UpdateVisible(XRState.Global);
    }
  }
  onDestroy() {
    const i = _XRFlag.registry.indexOf(this);
    if (i >= 0)
      _XRFlag.registry.splice(i, 1);
  }
  get isOn() {
    return this.gameObject.visible;
  }
  UpdateVisible(state = null) {
    if (disable) {
      return;
    }
    let res = void 0;
    const flag = state;
    if (flag && typeof flag === "number") {
      console.assert(typeof flag === "number", "XRFlag.UpdateVisible: state must be a number", flag);
      if (debug57)
        console.log(flag);
      _XRFlag.buffer.Mask = flag;
      state = _XRFlag.buffer;
    }
    if (state instanceof XRState) {
      if (debug57)
        console.warn(this.name, "use passed in mask", state.Mask, this.visibleIn);
      res = state.Has(this.visibleIn);
    } else {
      if (debug57)
        console.log(this.name, "use global mask");
      XRState.Global.Has(this.visibleIn);
    }
    if (res === void 0)
      return;
    if (res) {
      if (debug57)
        console.log(this.name, "is visible", this.gameObject.uuid);
      GameObject.setActive(this.gameObject, true);
    } else {
      if (debug57)
        console.log(this.name, "is not visible", this.gameObject.uuid);
      const isVisible2 = this.gameObject.visible;
      if (!isVisible2)
        return;
      this.gameObject.visible = false;
    }
  }
};
var XRFlag = _XRFlag;
__publicField(XRFlag, "registry", []);
__publicField(XRFlag, "firstApply");
__publicField(XRFlag, "buffer", new XRState());
__decorate19([
  serializable()
], XRFlag.prototype, "visibleIn", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/webxr/Avatar.js
var __decorate20 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug58 = getParam("debugwebxr");
var flipForwardQuaternion2 = new Quaternion().setFromAxisAngle(new Vector32(0, 1, 0), Math.PI);
var Avatar = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "head");
    __publicField(this, "leftHand");
    __publicField(this, "rightHand");
    __publicField(this, "_leftHandMeshes");
    __publicField(this, "_rightHandMeshes");
    __publicField(this, "_syncTransforms");
  }
  async onEnterXR(_args) {
    if (!this.activeAndEnabled)
      return;
    if (debug58)
      console.warn("AVATAR ENTER XR", this.guid, this.sourceId, this, this.activeAndEnabled);
    if (this._syncTransforms)
      this._syncTransforms.length = 0;
    await this.prepareAvatar();
    const playerstate = PlayerState.getFor(this);
    if (playerstate == null ? void 0 : playerstate.owner) {
      const marker = this.gameObject.addComponent(AvatarMarker);
      marker.avatar = this.gameObject;
      marker.connectionId = playerstate.owner;
    } else if (this.context.connection.isConnected)
      console.error("No player state found for avatar", this);
    else if (playerstate && !this.context.connection.isConnected)
      playerstate.dontDestroy = true;
  }
  onLeaveXR(_args) {
    const marker = this.gameObject.getComponent(AvatarMarker);
    if (marker) {
      marker.destroy();
    }
  }
  onUpdateXR(args) {
    var _a2, _b;
    if (!this.activeAndEnabled)
      return;
    const isLocalPlayer = PlayerState.isLocalPlayer(this);
    if (!isLocalPlayer)
      return;
    const xr = args.xr;
    if (xr.rig && xr.rig.gameObject !== this.gameObject.parent) {
      this.gameObject.position.set(0, 0, 0);
      this.gameObject.rotation.set(0, 0, 0);
      this.gameObject.scale.set(1, 1, 1);
      xr.rig.gameObject.add(this.gameObject);
    }
    if (this._syncTransforms && isLocalPlayer) {
      for (const sync of this._syncTransforms) {
        sync.fastMode = true;
        if (!sync.isOwned())
          sync.requestOwnership();
      }
    }
    if (this.head && this.context.mainCamera) {
      const headObj = this.head.asset;
      headObj.position.copy(this.context.mainCamera.position);
      headObj.position.x *= -1;
      headObj.position.z *= -1;
      headObj.quaternion.copy(this.context.mainCamera.quaternion);
      headObj.quaternion.x *= -1;
      if (this.context.time.frameCount % 10 === 0) {
        const xrflags = GameObject.getComponentsInChildren(this.head.asset, XRFlag);
        for (const flag of xrflags) {
          flag.enabled = false;
          flag.gameObject.visible = false;
        }
      }
    }
    const leftCtrl = args.xr.leftController;
    const leftObj = (_a2 = this.leftHand) == null ? void 0 : _a2.asset;
    if (leftCtrl && leftObj) {
      leftObj.position.copy(leftCtrl.gripPosition);
      leftObj.quaternion.copy(leftCtrl.gripQuaternion);
      leftObj.quaternion.multiply(flipForwardQuaternion2);
      leftObj.visible = leftCtrl.isTracking;
      this.updateHandVisibility(leftCtrl, leftObj, this._leftHandMeshes);
    } else if (leftObj && leftObj.visible) {
      leftObj.visible = false;
    }
    const right = args.xr.rightController;
    const rightObj = (_b = this.rightHand) == null ? void 0 : _b.asset;
    if (right && rightObj) {
      rightObj.position.copy(right.gripPosition);
      rightObj.quaternion.copy(right.gripQuaternion);
      rightObj.quaternion.multiply(flipForwardQuaternion2);
      rightObj.visible = right.isTracking;
      this.updateHandVisibility(right, rightObj, this._rightHandMeshes);
    } else if (rightObj && rightObj.visible) {
      rightObj.visible = false;
    }
  }
  onBeforeRender() {
    if (this.context.xr) {
      if (this.context.time.frame % 10 === 0)
        this.updateRemoteAvatarVisibility();
    }
  }
  updateHandVisibility(controller, avatarHand, meshes) {
    if (meshes) {
      const hasOtherRenderingModel = controller.model && controller.model.visible && controller.model !== avatarHand;
      meshes.forEach((mesh) => {
        setCustomVisibility(mesh, !hasOtherRenderingModel);
      });
    }
  }
  updateRemoteAvatarVisibility() {
    var _a2, _b, _c;
    if (this.context.connection.isConnected) {
      const state = PlayerState.getFor(this);
      if (state && state.isLocalPlayer == false) {
        const sync = NeedleXRSession.getXRSync(this.context);
        if (sync) {
          if (sync.hasState(state.owner)) {
            this.tryFindAvatarObjectsIfMissing();
            const leftObj = (_a2 = this.leftHand) == null ? void 0 : _a2.asset;
            if (leftObj) {
              leftObj.visible = (sync == null ? void 0 : sync.isTracking(state.owner, "left")) ?? false;
            }
            const rightObj = (_b = this.rightHand) == null ? void 0 : _b.asset;
            if (rightObj) {
              rightObj.visible = (sync == null ? void 0 : sync.isTracking(state.owner, "right")) ?? false;
            }
          }
        }
        if ((_c = this.head) == null ? void 0 : _c.asset) {
          const xrflags = GameObject.getComponentsInChildren(this.head.asset, XRFlag);
          for (const flag of xrflags) {
            flag.enabled = false;
            flag.gameObject.visible = true;
          }
        }
      }
    }
  }
  tryFindAvatarObjectsIfMissing() {
    if (!this.head || !this.leftHand || !this.rightHand) {
      const res = { head: this.head, leftHand: this.leftHand, rightHand: this.rightHand };
      NeedleXRUtils.tryFindAvatarObjects(this.gameObject, this.sourceId || "", res);
      if (res.head)
        this.head = res.head;
      if (res.leftHand)
        this.leftHand = res.leftHand;
      if (res.rightHand)
        this.rightHand = res.rightHand;
    }
  }
  async prepareAvatar() {
    this.tryFindAvatarObjectsIfMissing();
    if (!this.head) {
      const head = new Object3D();
      head.name = "Head";
      const cube = ObjectUtils.createPrimitive(PrimitiveType.Cube);
      head.add(cube);
      this.gameObject.add(head);
      this.head = new AssetReference("", this.sourceId, head);
      if (debug58)
        console.log("Create head", head);
    } else if (this.head instanceof Object3D) {
      this.head = new AssetReference("", this.sourceId, this.head);
    }
    if (!this.rightHand) {
      const rightHand = new Object3D();
      rightHand.name = "Right Hand";
      this.gameObject.add(rightHand);
      this.rightHand = new AssetReference("", this.sourceId, rightHand);
      if (debug58)
        console.log("Create right hand", rightHand);
    } else if (this.rightHand instanceof Object3D) {
      this.rightHand = new AssetReference("", this.sourceId, this.rightHand);
    }
    if (!this.leftHand) {
      const leftHand = new Object3D();
      leftHand.name = "Left Hand";
      this.gameObject.add(leftHand);
      this.leftHand = new AssetReference("", this.sourceId, leftHand);
      if (debug58)
        console.log("Create left hand", leftHand);
    } else if (this.leftHand instanceof Object3D) {
      this.leftHand = new AssetReference("", this.sourceId, this.leftHand);
    }
    await this.loadAvatarObjects(this.head, this.leftHand, this.rightHand);
    this._leftHandMeshes = [];
    this.leftHand.asset.traverse((obj) => {
      if (obj == null ? void 0 : obj.isMesh)
        this._leftHandMeshes.push(obj);
    });
    this._rightHandMeshes = [];
    this.rightHand.asset.traverse((obj) => {
      if (obj == null ? void 0 : obj.isMesh)
        this._rightHandMeshes.push(obj);
    });
    if (PlayerState.isLocalPlayer(this.gameObject)) {
      this._syncTransforms = GameObject.getComponentsInChildren(this.gameObject, SyncedTransform);
    }
  }
  async loadAvatarObjects(head, left, right) {
    const pHead = head.loadAssetAsync();
    const pHandLeft = left.loadAssetAsync();
    const pHandRight = right.loadAssetAsync();
    const promises = new Array();
    if (pHead)
      promises.push(pHead);
    if (pHandLeft)
      promises.push(pHandLeft);
    if (pHandRight)
      promises.push(pHandRight);
    const res = await PromiseAllWithErrors(promises);
    if (debug58)
      console.log("Avatar loaded results:", res);
  }
};
__decorate20([
  serializable(AssetReference)
], Avatar.prototype, "head", void 0);
__decorate20([
  serializable(AssetReference)
], Avatar.prototype, "leftHand", void 0);
__decorate20([
  serializable(AssetReference)
], Avatar.prototype, "rightHand", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/avatar/Avatar_Brain_LookAt.js
var Avatar_POI = class {
  static Add(context, obj, ignoredBy = null) {
    if (!obj)
      return;
    for (const e of this.Pois) {
      if (e.obj === obj)
        return;
    }
    this.Pois.push({ obj, avatar: ignoredBy });
    this.LastChangeTime = context.time.time;
  }
  static Remove(context, obj) {
    var _a2;
    if (!obj)
      return;
    for (const e of this.Pois) {
      if (e.obj === obj) {
        this.Pois.splice(this.Pois.indexOf(e), 1);
        this.LastChangeTime = (context == null ? void 0 : context.time.time) ?? ((_a2 = Context.Current) == null ? void 0 : _a2.time.time);
        return;
      }
    }
  }
};
__publicField(Avatar_POI, "Pois", []);
__publicField(Avatar_POI, "LastChangeTime", 0);
var NetworkEvents;
(function(NetworkEvents2) {
  NetworkEvents2["TargetChanged"] = "avatar-look-target-changed";
})(NetworkEvents || (NetworkEvents = {}));
var TargetModel = class {
  constructor() {
    __publicField(this, "guid");
    __publicField(this, "position", new Vector32());
  }
};
var Avatar_Brain_LookAt = class extends Component2 {
  constructor() {
    super(...arguments);
    // that target to copy positions into
    __publicField(this, "target", null);
    __publicField(this, "avatar", null);
    __publicField(this, "_model", null);
    __publicField(this, "_targetModel", new TargetModel());
    __publicField(this, "_currentTargetObject", null);
    __publicField(this, "_lastUpdateTime", 0);
    __publicField(this, "_lookDuration", 0);
    __publicField(this, "_lastPoiChangedTime", 0);
  }
  set controlledTarget(target) {
    this.target = target;
    const r = TypeStore.get("MoveRandom");
    if (r && this.target) {
      const rm = GameObject.getComponent(this.target, r);
      if (rm) {
        rm.destroy();
      }
    }
  }
  awake() {
    this.avatar = GameObject.getComponentInParent(this.gameObject, AvatarMarker);
    if (this.avatar) {
      const marker = GameObject.getComponentInParent(this.gameObject, AvatarMarker);
      this._model = new OwnershipModel(this.context.connection, this.guid);
      if (marker == null ? void 0 : marker.isLocalAvatar) {
        this._model.requestOwnership();
      }
    }
    this.context.connection.beginListen(NetworkEvents.TargetChanged, (cb) => {
      var _a2;
      if (this.target && cb && cb.guid === ((_a2 = this.avatar) == null ? void 0 : _a2.guid)) {
        setWorldPosition(this.target, cb.position);
      }
    });
  }
  update() {
    var _a2;
    const connected = this.context.connection.isConnected;
    if (!connected || ((_a2 = this._model) == null ? void 0 : _a2.hasOwnership)) {
      if (Avatar_POI.LastChangeTime !== this._lastPoiChangedTime) {
        this._lastPoiChangedTime = Avatar_POI.LastChangeTime;
        this._lookDuration = 0;
      }
      this.selectTarget();
      if (this._currentTargetObject && this.context.time.frameCount % 10 === 0 && this.target) {
        const wp = getWorldPosition(this._currentTargetObject);
        setWorldPosition(this.target, wp);
        if (this.context.connection.isConnected && this.avatar) {
          this.context.connection.send(NetworkEvents.TargetChanged, this._targetModel);
          this._targetModel.guid = this.avatar.guid;
          this._targetModel.position.copy(wp);
        }
      }
    }
  }
  selectTarget() {
    const td = this.context.time.time - this._lastUpdateTime;
    if (td > this._lookDuration) {
      this._lastUpdateTime = this.context.time.time;
      this._lookDuration = Math.random() * 0.5 + 0.2;
      const pois = Avatar_POI.Pois;
      if (pois.length > 0) {
        const poi = pois[Math.floor(Math.random() * pois.length)];
        if (poi && poi.obj) {
          if (poi.avatar && poi.avatar === this.avatar)
            return;
          this._currentTargetObject = poi.obj;
        }
      }
    }
  }
};

// node_modules/@needle-tools/engine/lib/engine/engine_types.js
function isComponent(obj) {
  return obj && obj.isComponent;
}
var $physicsKey = Symbol("object");
var contactsVectorBuffer = new CircularBuffer(() => new Vector32(), 20);
var ContactPoint = class {
  /** @internal */
  constructor(point, dist, normal, impulse, friction, tangentVelocity) {
    __publicField(this, "_point");
    __publicField(this, "_normal");
    __publicField(this, "_tangentVelocity");
    /** the distance of the collision point */
    __publicField(this, "distance");
    /** the impulse velocity */
    __publicField(this, "impulse");
    __publicField(this, "friction");
    this._point = point;
    this.distance = dist;
    this._normal = normal;
    this.impulse = impulse;
    this.friction = friction;
    this._tangentVelocity = tangentVelocity;
  }
  /** worldspace point */
  get point() {
    const target = contactsVectorBuffer.get();
    return target.set(this._point.x, this._point.y, this._point.z);
  }
  /** worldspace normal */
  get normal() {
    const target = contactsVectorBuffer.get();
    return target.set(this._normal.x, this._normal.y, this._normal.z);
  }
  /** worldspace tangent */
  get tangentVelocity() {
    const target = contactsVectorBuffer.get();
    return target.set(this._tangentVelocity.x, this._tangentVelocity.y, this._tangentVelocity.z);
  }
};
var Collision = class {
  /** @internal */
  constructor(obj, otherCollider, contacts) {
    /** The contact points of this collision. Contains information about positions, normals, distance, friction, impulse... */
    __publicField(this, "contacts");
    /** the gameobject this collision event belongs to (e.g. if onCollisionEnter is called then `me` is the same as `this.gameObject`) */
    __publicField(this, "me");
    __publicField(this, "_collider");
    __publicField(this, "_gameObject");
    this.me = obj;
    this._collider = otherCollider;
    this._gameObject = otherCollider.gameObject;
    this.contacts = contacts;
  }
  /** the other collider the collision happened with */
  get collider() {
    return this._collider;
  }
  /** the other object the collision happened with */
  get gameObject() {
    return this._gameObject;
  }
  /** the other rigidbody we hit, null if none attached */
  get rigidBody() {
    var _a2;
    return (_a2 = this.collider) == null ? void 0 : _a2.attachedRigidbody;
  }
};
var SphereOverlapResult = class {
  constructor(object, collider) {
    __publicField(this, "object");
    __publicField(this, "collider");
    this.object = object;
    this.collider = collider;
  }
};

// node_modules/@needle-tools/engine/lib/engine/engine_networking_streams.js
var debug59 = getParam("debugnetworkingstreams");
var NetworkedStreamEvents;
(function(NetworkedStreamEvents2) {
  NetworkedStreamEvents2["Connected"] = "peer-user-connected";
  NetworkedStreamEvents2["StreamReceived"] = "receive-stream";
  NetworkedStreamEvents2["StreamEnded"] = "call-ended";
  NetworkedStreamEvents2["Disconnected"] = "peer-user-disconnected";
  NetworkedStreamEvents2["UserJoined"] = "user-joined";
})(NetworkedStreamEvents || (NetworkedStreamEvents = {}));
var StreamEndedEvent = class {
  constructor(userId, direction) {
    __publicField(this, "type", NetworkedStreamEvents.StreamEnded);
    __publicField(this, "userId");
    __publicField(this, "direction");
    this.userId = userId;
    this.direction = direction;
  }
};
var StreamReceivedEvent = class {
  constructor(userId, stream, target) {
    __publicField(this, "type", NetworkedStreamEvents.StreamReceived);
    __publicField(this, "userId");
    __publicField(this, "stream");
    __publicField(this, "target");
    this.userId = userId;
    this.stream = stream;
    this.target = target;
  }
};
var PeerUserConnectedModel = class {
  constructor(handle, peerId) {
    /** the peer handle id */
    __publicField(this, "guid");
    __publicField(this, "peerId");
    // internal so server doesnt save it to persistent storage
    __publicField(this, "dontSave", true);
    this.guid = handle.id;
    this.peerId = peerId;
  }
};
var CallDirection;
(function(CallDirection2) {
  CallDirection2["Incoming"] = "incoming";
  CallDirection2["Outgoing"] = "outgoing";
})(CallDirection || (CallDirection = {}));
var CallHandle = class extends EventDispatcher {
  constructor(userId, call, direction, stream = null) {
    super();
    __publicField(this, "peerId");
    __publicField(this, "userId");
    __publicField(this, "direction");
    __publicField(this, "call");
    __publicField(this, "_stream", null);
    __publicField(this, "_isDisposed", false);
    this.peerId = call.peer;
    this.userId = userId;
    this.call = call;
    this.direction = direction;
    this._stream = stream;
    call.on("stream", (stream2) => {
      if (debug59)
        console.log("Receive stream", "\nAudio:", stream2.getAudioTracks(), "\nVideo:", stream2.getVideoTracks());
      this._stream = stream2;
      if (direction === CallDirection.Incoming) {
        const args = new StreamReceivedEvent(userId, stream2, this);
        this.dispatchEvent(args);
      }
    });
    call.on("close", () => {
      this.dispatchEvent(new StreamEndedEvent(userId, direction));
    });
  }
  get stream() {
    return this._stream;
  }
  close() {
    if (this._isDisposed)
      return;
    this._isDisposed = true;
    this.call.close();
    disposeStream(this._stream);
  }
  get isOpen() {
    var _a2;
    return ((_a2 = this.call.peerConnection) == null ? void 0 : _a2.connectionState) === "connected";
  }
  get isOpening() {
    var _a2;
    return ((_a2 = this.call.peerConnection) == null ? void 0 : _a2.connectionState) === "connecting";
  }
  get isClosed() {
    return !this.isOpen || this._isDisposed;
  }
};
function applySdpTransform(sdp) {
  sdp = sdp.replace("a=fmtp:111 minptime=10;useinbandfec=1", "a=fmtp:111 ptime=5;useinbandfec=1;stereo=1;maxplaybackrate=48000;maxaveragebitrat=128000;sprop-stereo=1");
  return sdp;
}
var _PeerHandle = class extends EventDispatcher {
  constructor(context, id) {
    super();
    __publicField(this, "updateCalls", () => {
      var _a2;
      for (let i = this._incomingCalls.length - 1; i >= 0; i--) {
        const call = this._incomingCalls[i];
        if (call.isClosed && !call.isOpening) {
          this._incomingCalls.splice(i, 1);
        }
      }
      for (let i = this._outgoingCalls.length - 1; i >= 0; i--) {
        const call = this._outgoingCalls[i];
        let shouldRemove = false;
        if (call.isClosed && !call.isOpening) {
          if ((_a2 = call.stream) == null ? void 0 : _a2.active) {
            if (debug59)
              console.warn("!!! Stream is still active, don't remove call", call.userId, "Your id: " + this.context.connection.connectionId);
          } else {
            if (debug59)
              console.warn("!!! Remove closed call", call.userId);
            shouldRemove = true;
          }
        }
        if (this.context.connection.userIsInRoom(call.userId) === false) {
          if (debug59)
            console.warn("!!! User is not in room anymore, remove call", call.userId);
          shouldRemove = true;
        }
        if (shouldRemove) {
          call.close();
          this._outgoingCalls.splice(i, 1);
        }
      }
    });
    __publicField(this, "id");
    __publicField(this, "context");
    __publicField(this, "_incomingCalls", []);
    __publicField(this, "_outgoingCalls", []);
    __publicField(this, "_peer");
    __publicField(this, "_enabled", false);
    __publicField(this, "_enabledPeer", false);
    __publicField(this, "onConnectRoomFn", this.onConnectRoom.bind(this));
    /**
     * Emitted when a connection to the PeerServer is established. You may use the peer before this is emitted, but messages to the server will be queued. id is the brokering ID of the peer (which was either provided in the constructor or assigned by the server).
     * @param id ID of the peer
    */
    __publicField(this, "onPeerConnect", (id) => {
      if (debug59)
        console.log("PEER opened as", id);
      if (id === null) {
        console.error("Peer connection failed", id);
        return;
      }
      this.context.connection.send(NetworkedStreamEvents.Connected, new PeerUserConnectedModel(this, id));
    });
    /** Emitted when the peer is destroyed and can no longer accept or create any new connections. At this time, the peer's connections will all be closed. */
    __publicField(this, "onPeerClose", () => {
      if (debug59)
        console.log("PEER closed");
      this.updateCalls();
    });
    /** Emitted when the peer is disconnected from the signalling server, either manually or because the connection to the signalling server was lost. */
    __publicField(this, "onPeerDisconnected", () => {
      if (debug59)
        console.log("PEER disconnected");
      this.updateCalls();
    });
    /**
     * Errors on the peer are almost always fatal and will destroy the peer. Errors from the underlying socket and PeerConnections are forwarded here.
     */
    __publicField(this, "onPeerError", (err) => {
      if (debug59)
        console.error("PEER error", err);
    });
    __publicField(this, "onPeerReceivingCall", (call) => {
      call.answer(void 0, {
        sdpTransform: (sdp) => {
          return applySdpTransform(sdp);
        }
      });
      this.registerCall(call, CallDirection.Incoming, null);
    });
    this.context = context;
    this.id = id;
    this.setupPeer();
    navigator["getUserMedia"] = navigator["getUserMedia"] || navigator["webkitGetUserMedia"] || navigator["mozGetUserMedia"] || navigator["msGetUserMedia"];
  }
  static getOrCreate(context, guid) {
    if (_PeerHandle.instances.has(guid))
      return _PeerHandle.instances.get(guid);
    const peer = new _PeerHandle(context, guid);
    _PeerHandle.instances.set(guid, peer);
    return peer;
  }
  getMyPeerId() {
    if (this.context.connection.connectionId)
      return this.getPeerIdFromUserId(this.context.connection.connectionId);
    return void 0;
  }
  getPeerIdFromUserId(userConnectionId) {
    return this.id + "-" + userConnectionId;
  }
  getUserIdFromPeerId(peerId) {
    return peerId.substring(this.id.length + 1);
  }
  makeCall(peerId, stream) {
    var _a2;
    if (!(stream == null ? void 0 : stream.id)) {
      if (debug59)
        console.warn("Can not make a call: mediastream has no id or is undefined");
      else
        console.debug("Can not make a call: mediastream has no id or is undefined");
      return void 0;
    }
    const opts = {
      metadata: {
        userId: this.context.connection.connectionId,
        streamId: stream.id
      },
      sdpTransform: (sdp) => {
        return applySdpTransform(sdp);
      }
    };
    const call = (_a2 = this._peer) == null ? void 0 : _a2.call(peerId, stream, opts);
    if (call) {
      const res = this.registerCall(call, CallDirection.Outgoing, stream);
      if (debug59)
        console.warn(`📞 CALL ${peerId}`, "\nOutgoing:", this._outgoingCalls, "\nIncoming:", this._incomingCalls);
      return res;
    } else if (debug59) {
      console.error("Failed to make call", peerId, stream, this._peer);
    }
    return void 0;
  }
  closeAll() {
    for (const call of this._incomingCalls) {
      call.close();
    }
    for (const call of this._outgoingCalls) {
      call.close();
    }
    this.updateCalls();
  }
  get peer() {
    return this._peer;
  }
  get incomingCalls() {
    return this._incomingCalls;
  }
  // private onUserJoinedOrLeftRoomFn: Function = this.onUserJoinedOrLeftRoom.bind(this);
  // private onPeerConnectFn: (id) => void = this.onPeerConnect.bind(this);
  // private onPeerReceiveCallFn: (call) => void = this.onPeerReceivingCall.bind(this);
  // private _connectionPeerIdMap : Map<string, string> = new Map();
  enable() {
    if (this._enabled)
      return;
    this._enabled = true;
    this.context.connection.beginListen(RoomEvents.JoinedRoom, this.onConnectRoomFn);
    this.subscribePeerEvents();
  }
  disable() {
    if (!this._enabled)
      return;
    this._enabled = false;
    this.context.connection.stopListen(RoomEvents.JoinedRoom, this.onConnectRoomFn);
    this.unsubscribePeerEvents();
  }
  onConnectRoom() {
    this.setupPeer();
  }
  // private onUserJoinedOrLeftRoom(_: UserJoinedOrLeftRoomModel): void {
  // };
  setupPeer() {
    if (!this.context.connection.connectionId)
      return;
    if (this._enabledPeer)
      return;
    this._enabledPeer = true;
    if (!this._peer) {
      const peerId = this.getMyPeerId();
      if (peerId)
        this._peer = getPeerjsInstance(peerId);
      else
        console.error("Failed to setup peerjs because we dont have a connection id", this.context.connection.connectionId);
    }
    if (this._enabled)
      this.subscribePeerEvents();
  }
  subscribePeerEvents() {
    if (!this._peer)
      return;
    this._peer.on("open", this.onPeerConnect);
    this._peer.on("close", this.onPeerClose);
    this._peer.on("call", this.onPeerReceivingCall);
    this._peer.on("disconnected", this.onPeerDisconnected);
    this._peer.on("error", this.onPeerError);
  }
  unsubscribePeerEvents() {
    if (!this._peer)
      return;
    this._peer.off("open", this.onPeerConnect);
    this._peer.off("close", this.onPeerClose);
    this._peer.off("call", this.onPeerReceivingCall);
    this._peer.off("disconnected", this.onPeerDisconnected);
    this._peer.off("error", this.onPeerError);
  }
  registerCall(call, direction, stream) {
    const meta = call.metadata;
    if (!meta || !meta.userId) {
      console.error("Missing call metadata", call);
    }
    const userId = meta.userId;
    if (direction === CallDirection.Incoming && debug59)
      console.warn("← Receive call from", call.metadata, call.connectionId);
    else if (debug59) {
      console.warn("→ Make call to", call.metadata);
    }
    const calls = direction === CallDirection.Incoming ? this._incomingCalls : this._outgoingCalls;
    const handle = new CallHandle(userId, call, direction, stream);
    calls.push(handle);
    call.on("error", (err) => {
      console.error("Call error", err);
    });
    call.on("close", () => {
      if (debug59)
        console.log("Call ended", call.metadata);
      const index = calls.indexOf(handle);
      if (index !== -1)
        calls.splice(index, 1);
      handle.close();
      this.dispatchEvent(new StreamEndedEvent(userId, direction));
    });
    handle.addEventListener(NetworkedStreamEvents.StreamEnded, (e) => {
      this.dispatchEvent(e);
    });
    if (direction === CallDirection.Incoming) {
      handle.addEventListener(NetworkedStreamEvents.StreamReceived, (e) => {
        this.dispatchEvent(e);
      });
      call.on("stream", () => {
        if (debug59)
          console.log("Received stream for call", call.metadata);
        let intervalCounter = 0;
        const closeInterval = setInterval(() => {
          const isFirstInterval = intervalCounter === 0;
          if (!handle.isOpen && isFirstInterval) {
            if (debug59)
              console.warn("Close call because stream is not active", call.metadata);
            intervalCounter += 1;
            clearInterval(closeInterval);
            handle.close();
          }
        }, 2e3);
      });
    }
    return handle;
  }
};
var PeerHandle = _PeerHandle;
__publicField(PeerHandle, "instances", /* @__PURE__ */ new Map());
var NetworkedStreams = class extends EventDispatcher {
  constructor(context, peer) {
    super();
    __publicField(this, "context");
    __publicField(this, "peer");
    // private _receiveVideoStreamListeners: Array<(info: IncomingStreamArgs) => void> = [];
    __publicField(this, "_sendingStreams", /* @__PURE__ */ new Map());
    /**
     * If true, will log debug information
     */
    __publicField(this, "debug", false);
    // private onConnectRoomFn: Function = this.onConnectRoom.bind(this);
    // private onUserConnectedFn: Function = this.onUserConnected.bind(this);
    // private onUserLeftFn: Function = this.onUserLeft.bind(this);
    __publicField(this, "_enabled", false);
    __publicField(this, "_tickIntervalId");
    /* for webpack */
    __publicField(this, "tick", () => {
      this.updateSendingCalls();
    });
    // private onUserJoinedPeer = (evt) => {
    //     if (!this.context.connection.isConnected && evt.userId) {
    //         this.startCallWithUserIfNotAlready(evt.userId);
    //     }
    // }
    // When either we ourselves OR someone else is joining the room we want to make sure to re-establish all calls
    // and if the user that joined is not yet receiving our video stream we want to start a stream with them
    // https://github.com/needle-tools/needle-tiny/issues/697#issuecomment-1510425539
    __publicField(this, "onJoinedRoom", (evt) => {
      if (this._sendingStreams.size > 0) {
        if (this.debug)
          console.warn(`${(evt == null ? void 0 : evt.userId) ? `User ${evt.userId}` : "You"} joined room`, evt, this._sendingStreams.size);
        this.updateSendingCalls();
      }
    });
    /** This is when the local user leaves the room */
    __publicField(this, "onLeftRoom", (evt) => {
      if (this.debug)
        console.warn(`${(evt == null ? void 0 : evt.userId) || "You"} left room`, evt);
      this.stopCallsToUsersThatAreNotInTheRoomAnymore();
      this.peer.closeAll();
    });
    __publicField(this, "onCallStreamReceived", (evt) => {
      if (this.debug)
        console.log("Call with " + evt.userId + " started");
      this.dispatchEvent({ type: NetworkedStreamEvents.StreamReceived, target: this, stream: evt.stream, userId: evt.userId });
      if (this.debug) {
        this.debugLogCurrentState();
      }
    });
    __publicField(this, "onCallEnded", (evt) => {
      if (this.debug)
        console.log("Call with " + evt.userId + " ended");
      this.dispatchEvent(evt);
      if (this.debug) {
        this.debugLogCurrentState();
      }
    });
    __publicField(this, "onUserConnected", (user) => {
      if (this.peer.id === user.guid) {
        if (this.debug)
          console.log("PEER USER CONNECTED", user.guid, user, this._sendingStreams.size);
        const stream = this._sendingStreams.keys().next().value;
        this.peer.makeCall(user.peerId, stream);
      } else {
        if (debug59)
          console.log("Unknown user connected", user.guid, user.peerId);
      }
    });
    __publicField(this, "onUserLeft", (_) => {
      if (this.debug)
        console.log("User left room: " + _.userId);
      this.stopCallsToUsersThatAreNotInTheRoomAnymore();
    });
    if (isComponent(context)) {
      const comp = context;
      context = comp.context;
      peer = PeerHandle.getOrCreate(comp.context, comp.guid);
    } else if (typeof peer === "string") {
      peer = PeerHandle.getOrCreate(context, peer);
    }
    if (!context)
      throw new Error("Failed to create NetworkedStreams because context is undefined");
    else if (!(context instanceof Context))
      throw new Error("Failed to create NetworkedStreams because context is not an instance of Context");
    if (!peer)
      throw new Error("Failed to create NetworkedStreams because peer is undefined");
    this.context = context;
    this.peer = peer;
    if (debug59)
      this.debug = true;
  }
  /**
   * Create a new NetworkedStreams instance
   */
  static create(comp, guid) {
    const peer = PeerHandle.getOrCreate(comp.context, guid || comp.context.connection.connectionId || comp.guid);
    return new NetworkedStreams(comp.context, peer);
  }
  startSendingStream(stream) {
    if (!this._sendingStreams.has(stream)) {
      this._sendingStreams.set(stream, []);
      this.updateSendingCalls();
    } else {
      console.warn("Received start sending stream with stream that is already being sent");
    }
  }
  stopSendingStream(_steam) {
    if (_steam) {
      const calls = this._sendingStreams.get(_steam);
      if (calls) {
        for (const call of calls) {
          call.close();
        }
        calls.length = 0;
      }
      this._sendingStreams.delete(_steam);
      if (calls && this.debug)
        this.debugLogCurrentState();
    }
    this.updateSendingCalls();
  }
  get enabled() {
    return this._enabled;
  }
  enable() {
    if (this._enabled)
      return;
    this._enabled = true;
    this.peer.enable();
    this.peer.addEventListener(NetworkedStreamEvents.StreamReceived, this.onCallStreamReceived);
    this.peer.addEventListener(NetworkedStreamEvents.StreamEnded, this.onCallEnded);
    this.context.connection.beginListen(NetworkedStreamEvents.Connected, this.onUserConnected);
    this.context.connection.beginListen(RoomEvents.JoinedRoom, this.onJoinedRoom);
    this.context.connection.beginListen(RoomEvents.UserJoinedRoom, this.onJoinedRoom);
    this.context.connection.beginListen(RoomEvents.UserLeftRoom, this.onUserLeft);
    this.context.connection.beginListen(RoomEvents.LeftRoom, this.onLeftRoom);
    this._tickIntervalId = setInterval(this.tick, 5e3);
  }
  disable() {
    if (!this._enabled)
      return;
    this._enabled = false;
    this.peer.disable();
    this.peer.removeEventListener(NetworkedStreamEvents.StreamReceived, this.onCallStreamReceived);
    this.peer.removeEventListener(NetworkedStreamEvents.StreamEnded, this.onCallEnded);
    this.context.connection.stopListen(NetworkedStreamEvents.Connected, this.onUserConnected);
    this.context.connection.stopListen(RoomEvents.JoinedRoom, this.onJoinedRoom);
    this.context.connection.stopListen(RoomEvents.UserJoinedRoom, this.onJoinedRoom);
    this.context.connection.stopListen(RoomEvents.UserLeftRoom, this.onUserLeft);
    this.context.connection.stopListen(RoomEvents.LeftRoom, this.onLeftRoom);
    if (this._tickIntervalId != void 0) {
      clearInterval(this._tickIntervalId);
      this._tickIntervalId = void 0;
    }
  }
  updateSendingCalls() {
    let startedNewCall = false;
    const localUserId = this.context.connection.connectionId;
    for (const stream of this._sendingStreams.keys()) {
      const calls = this._sendingStreams.get(stream) || [];
      for (const userId of this.context.connection.usersInRoom()) {
        if (userId === localUserId)
          continue;
        const peerId = this.peer.getPeerIdFromUserId(userId);
        const existing = calls.find((c2) => {
          var _a2;
          return c2.peerId === peerId && c2.direction === CallDirection.Outgoing && !c2.isClosed && ((_a2 = c2.stream) == null ? void 0 : _a2.active);
        });
        if (!existing) {
          const handle = this.peer.makeCall(peerId, stream);
          if (handle) {
            startedNewCall = true;
            calls.push(handle);
          }
        } else if (debug59) {
          console.debug("Already have a call with user " + userId + " / peer " + peerId);
        }
      }
      this._sendingStreams.set(stream, calls);
    }
    this.stopCallsToUsersThatAreNotInTheRoomAnymore();
  }
  // private startCallWithUserIfNotAlready(userId: string) {
  //     for (const stream of this._sendingVideoStreams.keys()) {
  //         const calls = this._sendingVideoStreams.get(stream) || [];
  //         const existing = calls.find(c => c.userId === userId);
  //         if (!existing || existing.stream?.active === false) {
  //             if (this.debug) console.log("Starting call to", userId)
  //             const handle = this.peer.makeCall(this.peer.getPeerIdFromUserId(userId), stream);
  //             if (handle) {
  //                 calls.push(handle);
  //                 return true;
  //             }
  //         }
  //     }
  //     return false;
  // }
  stopCallsToUsersThatAreNotInTheRoomAnymore() {
    for (const stream of this._sendingStreams.keys()) {
      const calls = this._sendingStreams.get(stream);
      if (!calls)
        continue;
      for (let i = calls.length - 1; i >= 0; i--) {
        const call = calls[i];
        if (!this.context.connection.userIsInRoom(call.userId)) {
          if (debug59)
            console.log(`Remove call ${[i]} to user that is not in room anymore ${call.userId}`);
          call.close();
          calls.splice(i, 1);
        } else if (debug59) {
          if (this.context.connection.connectionId === call.userId)
            console.warn(`You are still in the room [${i}] ${call.userId}`);
          else {
            console.log(`User is still in room [${i}] ${call.userId}`);
          }
        }
      }
    }
    this.peer.updateCalls();
    if (this.debug) {
      this.debugLogCurrentState();
    }
  }
  debugLogCurrentState() {
    console.warn(`You (${this.context.connection.connectionId}) are currently sending ${this._sendingStreams.size} and receiving ${this.peer.incomingCalls.length} calls (${this.peer.incomingCalls.map((c2) => c2.userId).join(", ")})`, this.peer.incomingCalls);
  }
};
function disposeStream(str) {
  if (!str)
    return;
  if (str instanceof MediaStream) {
    for (const cap of str.getTracks())
      cap.stop();
  }
}

// node_modules/@needle-tools/engine/lib/engine-components/Voip.js
var __decorate21 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var noVoip = "noVoip";
var debugParam = getParam("debugvoip");
var Voip = class extends Component2 {
  constructor() {
    super(...arguments);
    /** When enabled, VoIP will start when a room is joined or when this component is enabled while already in a room.
     * @default true
    */
    __publicField(this, "autoConnect", true);
    /**
     * When enabled, VoIP will stay connected even when the browser tab is not focused/active anymore.
     * @default true
     */
    __publicField(this, "runInBackground", true);
    /**
     * When enabled, a menu button will be created to allow the user to toggle VoIP on and off.
     */
    __publicField(this, "createMenuButton", true);
    /**
     * When enabled debug messages will be printed to the console. This is useful for debugging audio issues. You can also append ?debugvoip to the URL to enable this.
     */
    __publicField(this, "debug", false);
    __publicField(this, "_net");
    __publicField(this, "_menubutton");
    /** Set via the mic button (e.g. when the websocket connection closes and rejoins but the user was muted before we don't want to enable VOIP again automatically) */
    __publicField(this, "_allowSending", true);
    __publicField(this, "_outputStream", null);
    // we have to wait for the user to connect to a room when "auto connect" is enabled
    __publicField(this, "onJoinedRoom", async () => {
      if (this.debug)
        console.log("VOIP: Joined room");
      await delay(300);
      if (this.autoConnect && !this.isSending && this._allowSending) {
        this.connect();
      }
    });
    __publicField(this, "onLeftRoom", () => {
      if (this.debug)
        console.log("VOIP: Left room");
      this.disconnect();
      for (const incoming of this._incomingStreams.values()) {
        disposeStream(incoming.srcObject);
      }
      this._incomingStreams.clear();
    });
    __publicField(this, "_incomingStreams", /* @__PURE__ */ new Map());
    __publicField(this, "onReceiveStream", (evt) => {
      const userId = evt.target.userId;
      const stream = evt.stream;
      let audioElement = this._incomingStreams.get(userId);
      if (!audioElement) {
        audioElement = new Audio();
        this._incomingStreams.set(userId, audioElement);
      }
      audioElement.srcObject = stream;
      audioElement.setAttribute("autoplay", "true");
      Application.registerWaitForInteraction(() => {
        audioElement == null ? void 0 : audioElement.play().catch((err) => {
          console.error("VOIP: Failed to play audio", err);
        });
      });
    });
    __publicField(this, "onStreamEnded", (evt) => {
      const existing = this._incomingStreams.get(evt.userId);
      disposeStream(existing == null ? void 0 : existing.srcObject);
      this._incomingStreams.delete(evt.userId);
    });
    __publicField(this, "onEnabledChanged", () => {
      for (const key of this._incomingStreams) {
        const element = key[1];
        element.muted = !this.enabled;
      }
    });
    __publicField(this, "onVisibilityChanged", () => {
      if (this.runInBackground)
        return;
      const visible = document.visibilityState === "visible";
      const muted = !visible;
      this.setMuted(muted);
      for (const element of this._incomingStreams) {
        const str = element[1];
        str.muted = muted;
      }
    });
  }
  /** @internal */
  awake() {
    if (debugParam)
      this.debug = true;
    if (this.debug) {
      console.log("VOIP debugging: press 'v' to toggle mute or 'c' to toggle connect/disconnect");
      window.addEventListener("keydown", async (evt) => {
        const key = evt.key.toLowerCase();
        switch (key) {
          case "v":
            console.log("MUTE?", !this.isMuted);
            this.setMuted(!this.isMuted);
            break;
          case "c":
            if (this.isSending)
              this.disconnect();
            else
              this.connect();
            break;
        }
      });
      window.addEventListener("blur", () => {
        console.log("VOIP: MUTE ON BLUR");
        this.setMuted(true);
      });
      window.addEventListener("focus", () => {
        console.log("VOIP: UNMUTE ON FOCUS");
        this.setMuted(false);
      });
    }
  }
  /** @internal */
  onEnable() {
    if (!this._net)
      this._net = NetworkedStreams.create(this);
    if (this.debug)
      this._net.debug = true;
    this._net.addEventListener(NetworkedStreamEvents.StreamReceived, this.onReceiveStream);
    this._net.addEventListener(NetworkedStreamEvents.StreamEnded, this.onStreamEnded);
    this._net.enable();
    if (this.autoConnect) {
      if (this.context.connection.isConnected)
        this.connect();
    }
    this.context.connection.beginListen(RoomEvents.JoinedRoom, this.onJoinedRoom);
    this.context.connection.beginListen(RoomEvents.LeftRoom, this.onLeftRoom);
    this.onEnabledChanged();
    this.updateButton();
    window.addEventListener("visibilitychange", this.onVisibilityChanged);
  }
  /** @internal */
  onDisable() {
    var _a2;
    if (this._net) {
      this._net.stopSendingStream(this._outputStream);
      this._net.removeEventListener(NetworkedStreamEvents.StreamReceived, this.onReceiveStream);
      this._net.removeEventListener(NetworkedStreamEvents.StreamEnded, this.onStreamEnded);
      (_a2 = this._net) == null ? void 0 : _a2.disable();
    }
    this.context.connection.stopListen(RoomEvents.JoinedRoom, this.onJoinedRoom);
    this.context.connection.stopListen(RoomEvents.LeftRoom, this.onLeftRoom);
    this.onEnabledChanged();
    this.updateButton();
    window.removeEventListener("visibilitychange", this.onVisibilityChanged);
  }
  /** @internal */
  onDestroy() {
    var _a2;
    (_a2 = this._menubutton) == null ? void 0 : _a2.remove();
    this._menubutton = void 0;
  }
  /**
   * @returns true if the component is currently sending audio
   */
  get isSending() {
    return this._outputStream != null && this._outputStream.active;
  }
  /** Start sending audio. */
  async connect(audioSource) {
    var _a2, _b;
    if (!this._net) {
      console.error("Cannot connect to voice chat - NetworkedStreams not initialized. Make sure the component is enabled before calling this method.");
      return false;
    }
    if (!this.context.connection.isConnected) {
      console.error("Cannot connect to voice chat - not connected to server");
      this.updateButton();
      return false;
    } else if (!await DeviceUtilities.microphonePermissionsGranted()) {
      console.error("Cannot connect to voice chat - microphone permissions not granted");
      this.updateButton();
      return false;
    }
    this._allowSending = true;
    (_a2 = this._net) == null ? void 0 : _a2.stopSendingStream(this._outputStream);
    disposeStream(this._outputStream);
    this._outputStream = await this.getAudioStream(audioSource);
    if (this._outputStream) {
      if (this.debug)
        console.log("VOIP: Got audio stream");
      (_b = this._net) == null ? void 0 : _b.startSendingStream(this._outputStream);
      this.updateButton();
      return true;
    } else {
      this.updateButton();
      if (!await DeviceUtilities.microphonePermissionsGranted()) {
        showBalloonError("Microphone permissions not granted: Please grant microphone permissions to use voice chat");
      } else
        console.error("VOIP: Could not get audio stream - please make sure to connect an audio device and grant microphone permissions");
    }
    if (this.debug || isDevEnvironment())
      console.log("VOIP: Failed to get audio stream");
    return false;
  }
  /** Stop sending audio (muting your own microphone) */
  disconnect(opts) {
    var _a2;
    if (opts == null ? void 0 : opts.remember) {
      this._allowSending = false;
    }
    (_a2 = this._net) == null ? void 0 : _a2.stopSendingStream(this._outputStream);
    disposeStream(this._outputStream);
    this._outputStream = null;
    this.updateButton();
  }
  /**
   * Mute or unmute the audio stream (this will only mute incoming streams and not mute your own microphone. Use disconnect() to mute your own microphone)
   */
  setMuted(mute) {
    var _a2;
    const audio = (_a2 = this._outputStream) == null ? void 0 : _a2.getAudioTracks();
    if (audio) {
      for (const track of audio) {
        track.enabled = !mute;
      }
    }
  }
  /** Returns true if the audio stream is currently muted */
  get isMuted() {
    var _a2;
    if (this._outputStream === null)
      return false;
    const audio = (_a2 = this._outputStream) == null ? void 0 : _a2.getAudioTracks();
    if (audio) {
      for (const track of audio) {
        if (!track.enabled)
          return true;
      }
    }
    return false;
  }
  async updateButton() {
    var _a2;
    if (this.createMenuButton) {
      if (!this._menubutton) {
        this._menubutton = document.createElement("button");
        this._menubutton.addEventListener("click", () => {
          if (this.isSending) {
            this.disconnect({ remember: true });
          } else
            this.connect();
          DeviceUtilities.microphonePermissionsGranted().then((res) => {
            if (!res)
              showBalloonWarning("<strong>Microphone permissions not granted</strong>. Please allow your browser to use the microphone to be able to talk. Click on the button on the left side of your browser's address bar to allow microphone permissions.");
          });
        });
      }
      if (this._menubutton) {
        this.context.menu.appendChild(this._menubutton);
        if (this.activeAndEnabled) {
          this._menubutton.style.display = "";
        } else {
          this._menubutton.style.display = "none";
        }
        this._menubutton.title = this.isSending ? "Click to disable your microphone" : "Click to enable your microphone";
        let label = this.isSending ? "" : "";
        let icon = this.isSending ? "mic" : "mic_off";
        const hasPermission = await DeviceUtilities.microphonePermissionsGranted();
        if (!hasPermission) {
          label = "No Permission";
          icon = "mic_off";
          this._menubutton.title = "Microphone permissions not granted. Please allow your browser to use the microphone to be able to talk. This can usually be done in the addressbar of the webpage.";
        }
        this._menubutton.innerText = label;
        this._menubutton.prepend(getIconElement(icon));
        if (this.context.connection.isConnected == false)
          this._menubutton.setAttribute("disabled", "");
        else
          this._menubutton.removeAttribute("disabled");
      }
    } else if (!this.activeAndEnabled) {
      (_a2 = this._menubutton) == null ? void 0 : _a2.remove();
    }
  }
  // private _analyzer?: AudioAnalyser;
  /** @deprecated */
  getFrequency(_userId) {
    if (!this["unsupported_getfrequency"]) {
      this["unsupported_getfrequency"] = true;
      if (isDevEnvironment())
        showBalloonWarning("VOIP: getFrequency is currently not supported");
      console.warn("VOIP: getFrequency is currently not supported");
    }
    return null;
  }
  async getAudioStream(audio) {
    if (!navigator.mediaDevices.getUserMedia) {
      console.error("No getDisplayMedia support");
      return null;
    }
    const getUserMedia = async (constraints) => {
      return await navigator.mediaDevices.getUserMedia({ audio: constraints ?? true, video: false }).catch((err) => {
        console.warn("VOIP failed getting audio stream", err);
        return null;
      });
      ;
    };
    const stream = await getUserMedia(audio);
    if (!stream)
      return null;
    if (DeviceUtilities.isiOS() && (audio == null ? void 0 : audio.deviceId) === void 0) {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const nonBuiltInAudioSource = devices.find((device) => (device.kind === "audioinput" || device.kind === "audiooutput") && !device.label.includes("iPhone"));
      if (nonBuiltInAudioSource) {
        const constraints = Object.assign({}, audio);
        constraints.deviceId = nonBuiltInAudioSource.deviceId;
        return await getUserMedia(constraints);
      }
    }
    return stream;
  }
};
__decorate21([
  serializable()
], Voip.prototype, "autoConnect", void 0);
__decorate21([
  serializable()
], Voip.prototype, "runInBackground", void 0);
__decorate21([
  serializable()
], Voip.prototype, "createMenuButton", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/avatar/Avatar_MouthShapes.js
var __decorate22 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug60 = getParam("debugmouth");
var Avatar_MouthShapes = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "idle", []);
    __publicField(this, "talking", []);
    __publicField(this, "marker", null);
    __publicField(this, "voip", null);
    __publicField(this, "lastMouthChangeTime", 0);
    __publicField(this, "mouthChangeLength", 0);
  }
  awake() {
    setTimeout(() => {
      this.voip = GameObject.findObjectOfType(Voip, this.context);
      if (!this.marker)
        this.marker = GameObject.getComponentInParent(this.gameObject, AvatarMarker);
    }, 3e3);
  }
  update() {
    var _a2;
    if (!this.voip)
      return;
    if (this.context.time.frameCount % 10 !== 0)
      return;
    let id = ((_a2 = this.marker) == null ? void 0 : _a2.connectionId) ?? null;
    if (!id) {
      if (debug60)
        id = null;
      return;
    }
    const freq = this.voip.getFrequency(id) ?? 0;
    this.updateLips(freq);
  }
  updateLips(frequency) {
    if (this.context.time.time - this.lastMouthChangeTime > this.mouthChangeLength) {
      this.mouthChangeLength = 0.05 + Math.random() * 0.1;
      if (this.talking && this.talking.length > 0 && frequency > 30) {
        this.lastMouthChangeTime = this.context.time.time;
        const index = Math.floor(Math.random() * this.talking.length);
        this.setMouthShapeActive(this.talking, index);
      } else if (this.idle.length > 0 && this.context.time.time - this.lastMouthChangeTime > 0.5) {
        this.lastMouthChangeTime = this.context.time.time;
        const index = Math.floor(Math.random() * this.idle.length);
        this.setMouthShapeActive(this.idle, index);
      }
    }
  }
  setMouthShapeActive(arr, index) {
    if (!arr)
      return;
    if (arr != this.idle)
      this.idle.map((i) => i.visible = false);
    else
      this.talking.map((i) => i.visible = false);
    for (let i = 0; i < arr.length; i++) {
      const shape = arr[i];
      if (shape) {
        shape.visible = i === index;
      }
    }
  }
};
__decorate22([
  serializable(Object3D)
], Avatar_MouthShapes.prototype, "idle", void 0);
__decorate22([
  serializable(Object3D)
], Avatar_MouthShapes.prototype, "talking", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/avatar/Avatar_MustacheShake.js
var Avatar_MustacheShake = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "voip", null);
    __publicField(this, "marker", null);
    __publicField(this, "_startPosition", null);
  }
  awake() {
    this.voip = GameObject.findObjectOfType(Voip, this.context);
    this.marker = GameObject.getComponentInParent(this.gameObject, AvatarMarker);
  }
  update() {
    if (!this.voip || !this.marker)
      return;
    if (this.context.time.frameCount % 10 !== 0)
      return;
    const id = this.marker.connectionId;
    const freq = this.voip.getFrequency(id);
    if (freq == null)
      return;
    if (!this._startPosition) {
      this._startPosition = this.gameObject.position.clone();
    }
    const t2 = freq / 100;
    this.gameObject.position.y = this._startPosition.y + t2 * 0.07;
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/avatar/AvatarBlink_Simple.js
var __decorate23 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var AvatarBlink_Simple = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "eyes", []);
    __publicField(this, "lastBlinkTime", 0);
    __publicField(this, "blinkLength", 0);
    __publicField(this, "eyesOpen", true);
    __publicField(this, "state", null);
  }
  awake() {
    this.state = GameObject.getComponentInParent(this.gameObject, XRFlag);
  }
  update() {
    if (!this.gameObject || !this.gameObject.visible)
      return;
    if (!this.eyes || !Array.isArray(this.eyes) || this.eyes.length === 0)
      return;
    const needsUpdate = this.context.time.time - this.lastBlinkTime > this.blinkLength;
    if (needsUpdate) {
      this.lastBlinkTime = this.context.time.time;
      if (this.state && !this.state.isOn)
        return;
      if (!this.activeAndEnabled)
        return;
      this.eyesOpen = !this.eyesOpen;
      this.blinkLength = Math.random();
      if (!this.eyesOpen) {
        this.blinkLength *= Math.random() * 0.2;
        this.blinkLength += 0.1;
      } else {
        this.blinkLength *= 3;
        this.blinkLength += 0.5;
        if (Math.random() < 0.1)
          this.blinkLength = 0.1 + Math.random() * 0.2;
      }
      if (Math.random() < 0.1)
        this.blinkLength *= 3;
      this.blinkLength = Math.max(0.2, this.blinkLength);
      this.blinkLength = Math.min(3, this.blinkLength);
      if (this.eyes) {
        for (const eye of this.eyes) {
          if (eye)
            eye.visible = this.eyesOpen;
        }
      }
    }
  }
};
__decorate23([
  serializable(Object3D)
], AvatarBlink_Simple.prototype, "eyes", void 0);
__decorate23([
  serializable()
], AvatarBlink_Simple.prototype, "lastBlinkTime", void 0);
__decorate23([
  serializable()
], AvatarBlink_Simple.prototype, "blinkLength", void 0);
__decorate23([
  serializable()
], AvatarBlink_Simple.prototype, "eyesOpen", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/avatar/AvatarEyeLook_Rotation.js
var __decorate24 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var _AvatarEyeLook_Rotation = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "head", null);
    __publicField(this, "eyes", null);
    __publicField(this, "target", null);
    __publicField(this, "brain", null);
    __publicField(this, "vec", new Vector32());
    __publicField(this, "currentTargetPoint", new Vector32());
  }
  awake() {
    if (!this.brain) {
      this.brain = GameObject.getComponentInParent(this.gameObject, Avatar_Brain_LookAt);
    }
    if (!this.brain) {
      this.brain = GameObject.addComponent(this.gameObject, Avatar_Brain_LookAt);
    }
    if (this.brain && this.target) {
      this.brain.controlledTarget = this.target;
    }
  }
  update() {
    const target = this.target;
    if (target && this.head) {
      const eyes = this.eyes;
      if (eyes) {
        const worldTarget = getWorldPosition(target);
        this.currentTargetPoint.lerp(worldTarget, this.context.time.deltaTime / 0.1);
        const headPosition = getWorldPosition(this.head);
        const direction = this.vec.copy(this.currentTargetPoint).sub(headPosition).normalize();
        if (direction.length() < 0.1)
          return;
        const forward2 = _AvatarEyeLook_Rotation.forward;
        forward2.set(0, 0, 1);
        forward2.applyQuaternion(getWorldQuaternion(this.head));
        const dot = forward2.dot(direction);
        if (dot > 0.45) {
          for (let i = 0; i < eyes.length; i++) {
            const eye = eyes[i];
            eye.lookAt(this.currentTargetPoint);
          }
        }
      }
    }
  }
};
var AvatarEyeLook_Rotation = _AvatarEyeLook_Rotation;
__publicField(AvatarEyeLook_Rotation, "forward", new Vector32(0, 0, 1));
__decorate24([
  serializable(Object3D)
], AvatarEyeLook_Rotation.prototype, "head", void 0);
__decorate24([
  serializable(Object3D)
], AvatarEyeLook_Rotation.prototype, "eyes", void 0);
__decorate24([
  serializable(Object3D)
], AvatarEyeLook_Rotation.prototype, "target", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/AvatarLoader.js
var debug61 = getParam("debugavatar");
var AvatarModel = class {
  constructor(root, head, leftHand, rigthHand) {
    __publicField(this, "root");
    __publicField(this, "head");
    __publicField(this, "leftHand");
    __publicField(this, "rigthHand");
    var _a2;
    this.root = root;
    this.head = head;
    this.leftHand = leftHand;
    this.rigthHand = rigthHand;
    (_a2 = this.root) == null ? void 0 : _a2.traverse((h) => h.layers.set(2));
  }
  get isValid() {
    return this.head !== null && this.head !== void 0;
  }
};
var AvatarLoader = class {
  constructor() {
    __publicField(this, "avatarRegistryUrl", null);
  }
  // private loader: GLTFLoader | null;
  // private avatarModelCache: Map<string, AvatarModel | null> = new Map<string, AvatarModel | null>();
  async getOrCreateNewAvatarInstance(context, avatarId) {
    if (!avatarId) {
      console.error("Can not create avatar: failed to provide id or root object");
      return null;
    }
    let root = null;
    if (typeof avatarId === "string") {
      root = await this.loadAvatar(context, avatarId);
      if (!root) {
        const opts = new InstantiateOptions();
        root = GameObject.instantiate(tryFindObject(avatarId, context.scene), opts);
      }
    } else
      root = avatarId;
    if (!root) {
      return null;
    }
    const model = this.findAvatar(root);
    if (model.isValid) {
      if (debug61)
        console.log("[Custom Avatar] valid config", avatarId, debug61 ? model : "");
      return model;
    } else {
      console.warn("[Custom Avatar] config isn't valid", avatarId, debug61 ? model : "");
      return null;
    }
  }
  async loadAvatar(context, avatarId) {
    console.assert(avatarId !== void 0 && avatarId !== null && typeof avatarId === "string", "Avatar id must not be null");
    if (avatarId.length <= 0)
      return null;
    if (!avatarId)
      return null;
    if (debug61)
      console.log("[Custom Avatar] " + avatarId + ", loading...");
    if (!avatarId.endsWith(".glb"))
      avatarId += ".glb";
    if (this.avatarRegistryUrl === null) {
      const download_res = await fetch("./" + avatarId);
      let bin = null;
      if (download_res.ok) {
        const blob = await download_res.blob();
        if (blob)
          bin = await blob.arrayBuffer();
      }
      if (!bin) {
        return null;
      }
      const gltf = await getLoader().parseSync(context, bin, null, 0);
      return (gltf == null ? void 0 : gltf.scene) ?? null;
    }
    const loader2 = new GLTFLoader();
    addDracoAndKTX2Loaders2(loader2, context);
    return new Promise((resolve2, _reject) => {
      const url = this.avatarRegistryUrl + "/" + avatarId;
      loader2.load(url, async (gltf) => {
        await getLoader().createBuiltinComponents(context, url, gltf, null, void 0);
        resolve2(gltf.scene);
      }, (progress) => {
        if (debug61)
          console.log("[Custom Avatar] " + progress.loaded / progress.total * 100 + "% loaded of " + progress.total / 1024 + "kB");
      }, (error) => {
        console.error("[Custom Avatar] Error when loading: " + error);
        resolve2(null);
      });
    });
  }
  cacheModel(_id, _model) {
  }
  // TODO this should be burned to the ground once 🤞 we have proper extras that define object relations.
  findAvatar(obj) {
    const root = obj;
    let searchIn = root;
    if (searchIn.children.length == 1)
      searchIn = obj.children[0];
    let head = this.findAvatarPart(searchIn, ["head"]);
    const leftHand = this.findAvatarPart(searchIn, ["left", "hand"]);
    const rightHand = this.findAvatarPart(searchIn, ["right", "hand"]);
    if (!head) {
      head = root;
      const boundsSize = new Vector32();
      new Box3().setFromObject(head).getSize(boundsSize);
      const maxAxis = Math.max(boundsSize.x, boundsSize.y, boundsSize.z);
      console.warn("[Custom Avatar] Normalizing head scale, it's too big: " + maxAxis + " meters! Should be < 0.3m");
      if (maxAxis > 0.3) {
        head.scale.multiplyScalar(1 / maxAxis * 0.3);
      }
    }
    const model = new AvatarModel(root, head, leftHand, rightHand);
    return model;
  }
  findAvatarPart(obj, searchString) {
    const name = obj.name.toLowerCase();
    let matchesAll = true;
    for (const str of searchString) {
      if (!matchesAll)
        break;
      if (name.indexOf(str) === -1)
        matchesAll = false;
    }
    if (matchesAll)
      return obj;
    if (obj.children) {
      for (const child of obj.children) {
        const found = this.findAvatarPart(child, searchString);
        if (found)
          return found;
      }
    }
    return null;
  }
  handleCustomAvatarErrors(response) {
    if (!response.ok) {
      throw Error(response.statusText);
    }
    return response;
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/AxesHelper.js
var __decorate25 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var AxesHelper2 = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "length", 1);
    __publicField(this, "depthTest", true);
    __publicField(this, "isGizmo", false);
    __publicField(this, "_axes", null);
  }
  onEnable() {
    if (this.isGizmo && !showGizmos)
      return;
    if (!this._axes)
      this._axes = new AxesHelper(this.length);
    this._axes.layers.disableAll();
    this._axes.layers.set(this.layer);
    this.gameObject.add(this._axes);
    const mat = this._axes.material;
    if (mat) {
      if (mat.depthTest !== void 0)
        mat.depthTest = this.depthTest;
    }
  }
  onDisable() {
    if (!this._axes)
      return;
    this.gameObject.remove(this._axes);
  }
};
__decorate25([
  serializable()
], AxesHelper2.prototype, "length", void 0);
__decorate25([
  serializable()
], AxesHelper2.prototype, "depthTest", void 0);
__decorate25([
  serializable()
], AxesHelper2.prototype, "isGizmo", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/BasicIKConstraint.js
var BasicIKConstraint = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "from");
    __publicField(this, "to");
    __publicField(this, "hint");
    __publicField(this, "desiredDistance", 1);
  }
  onEnable() {
  }
  update() {
    if (!this.from || !this.to || !this.hint)
      return;
    const toPos = getWorldPosition(this.to).clone();
    const fromPos = getWorldPosition(this.from).clone();
    const dist = toPos.distanceTo(fromPos);
    const dir0 = toPos.clone();
    dir0.sub(fromPos);
    const center = fromPos.clone();
    center.add(toPos);
    center.multiplyScalar(0.5);
    const hintDir = getWorldPosition(this.hint).clone();
    hintDir.sub(center);
    const offsetDir = new Vector32();
    offsetDir.crossVectors(hintDir, dir0);
    offsetDir.crossVectors(dir0, offsetDir);
    offsetDir.normalize();
    const halfDist = dist * 0.5;
    const stretchDistance = Math.max(this.desiredDistance, halfDist);
    const offsetLength = Math.sqrt(stretchDistance * stretchDistance - halfDist * halfDist);
    const resultPos = offsetDir.clone();
    resultPos.multiplyScalar(offsetLength);
    resultPos.add(center);
    setWorldPosition(this.gameObject, resultPos);
    const lookPos = center.clone();
    lookPos.sub(offsetDir);
    this.gameObject.lookAt(lookPos);
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/export/usdz/extensions/behavior/Behaviour.js
var debug62 = getParam("debugusdzbehaviours");
var BehaviorExtension = class {
  constructor() {
    __publicField(this, "behaviours", []);
    __publicField(this, "behaviourComponents", []);
    __publicField(this, "behaviourComponentsCopy", []);
    __publicField(this, "audioClips", []);
    __publicField(this, "audioClipsCopy", []);
    __publicField(this, "targetUuids", /* @__PURE__ */ new Set());
  }
  get extensionName() {
    return "Behaviour";
  }
  addBehavior(beh) {
    this.behaviours.push(beh);
  }
  /** Register audio clip for USDZ export. The clip will be embedded in the resulting file. */
  addAudioClip(clipUrl) {
    if (!clipUrl)
      return "";
    if (typeof clipUrl !== "string")
      return "";
    const clipName = AudioExtension.getName(clipUrl);
    const filesKey = "audio/" + clipName;
    this.audioClips.push({ clipUrl, filesKey });
    return filesKey;
  }
  getAllTargetUuids() {
    return this.targetUuids;
  }
  onBeforeBuildDocument(context) {
    if (!context.root)
      return Promise.resolve();
    const beforeCreateDocumentPromises = [];
    context.root.traverse((e) => {
      GameObject.foreachComponent(e, (comp) => {
        var _a2;
        const c2 = comp;
        if (typeof c2.createBehaviours === "function" || typeof c2.beforeCreateDocument === "function" || typeof c2.afterCreateDocument === "function" || typeof c2.afterSerialize === "function") {
          this.behaviourComponents.push(c2);
          const res = (_a2 = c2.beforeCreateDocument) == null ? void 0 : _a2.call(c2, this, context);
          if (res instanceof Promise) {
            beforeCreateDocumentPromises.push(res);
          }
        }
      }, false);
    });
    if (debug62)
      console.log("onBeforeBuildDocument: all components", this.behaviourComponents);
    return Promise.all(beforeCreateDocumentPromises);
  }
  onExportObject(_object, model, context) {
    var _a2;
    for (const beh of this.behaviourComponents) {
      (_a2 = beh.createBehaviours) == null ? void 0 : _a2.call(beh, this, model, context);
    }
  }
  onAfterBuildDocument(context) {
    for (const beh of this.behaviourComponents) {
      if (typeof beh.afterCreateDocument === "function")
        beh.afterCreateDocument(this, context);
    }
    this.behaviourComponentsCopy = this.behaviourComponents.slice();
    this.behaviourComponents.length = 0;
    this.audioClipsCopy = this.audioClips.slice();
    this.audioClips.length = 0;
    const triggerSources = /* @__PURE__ */ new Set();
    const actionTargets = /* @__PURE__ */ new Set();
    const targetUuids = /* @__PURE__ */ new Set();
    const playAnimationActions = /* @__PURE__ */ new Set();
    const createMermaidGraphForDebugging = debug62;
    let mermaidGraph = "graph LR\n";
    let mermaidGraphTopLevel = "";
    function collectAction(actionModel) {
      if (actionModel instanceof GroupActionModel) {
        if (createMermaidGraphForDebugging)
          mermaidGraph += `subgraph Group_${actionModel.id}
`;
        for (const action of actionModel.actions) {
          if (createMermaidGraphForDebugging)
            mermaidGraph += `${actionModel.id}[${actionModel.id}] -- ${actionModel.type} --> ${action.id}[${action.id}]
`;
          collectAction(action);
        }
        if (createMermaidGraphForDebugging)
          mermaidGraph += `end
`;
      } else if (actionModel instanceof ActionModel) {
        if (actionModel.tokenId === "StartAnimation") {
          playAnimationActions.add(actionModel);
        }
        const affected = actionModel.affectedObjects;
        if (affected) {
          if (Array.isArray(affected)) {
            for (const a of affected) {
              actionTargets.add(a);
              if (createMermaidGraphForDebugging)
                mermaidGraphTopLevel += `${actionModel.id}[${actionModel.id}] -- ${actionModel.tokenId} --> ${a.uuid}(("${a.displayName || a.name || a.uuid}"))
`;
            }
          } else if (typeof affected === "object") {
            actionTargets.add(affected);
            if (createMermaidGraphForDebugging)
              mermaidGraphTopLevel += `${actionModel.id}[${actionModel.id}] -- ${actionModel.tokenId} --> ${affected.uuid}(("${affected.displayName || affected.name || affected.uuid}"))
`;
          } else if (typeof affected === "string") {
            actionTargets.add({ uuid: affected });
          }
        }
        const xform = actionModel.xFormTarget;
        if (xform) {
          if (typeof xform === "object") {
            actionTargets.add(xform);
            if (createMermaidGraphForDebugging)
              mermaidGraphTopLevel += `${actionModel.id}[${actionModel.id}] -- ${actionModel.tokenId} --> ${xform.uuid}(("${xform.displayName || xform.name || xform.uuid}"))
`;
          } else if (typeof xform === "string") {
            actionTargets.add({ uuid: xform });
          }
        }
      }
    }
    function collectTrigger(trigger, action) {
      if (Array.isArray(trigger)) {
        for (const t2 of trigger)
          collectTrigger(t2, action);
      } else if (trigger instanceof TriggerModel) {
        if (typeof trigger.targetId === "object") {
          triggerSources.add(trigger.targetId);
          if (createMermaidGraphForDebugging)
            mermaidGraphTopLevel += `${trigger.targetId.uuid}(("${trigger.targetId.displayName}")) --> ${trigger.id}[${trigger.id}]
`;
        }
        if (createMermaidGraphForDebugging)
          mermaidGraph += `${trigger.id}((${trigger.id})) -- ${trigger.tokenId}${trigger.type ? ":" + trigger.type : ""} --> ${action.id}[${action.tokenId || action.id}]
`;
      }
    }
    for (const beh of this.behaviours) {
      if (createMermaidGraphForDebugging)
        mermaidGraph += `subgraph Behavior_${beh.id}
`;
      collectAction(beh.action);
      collectTrigger(beh.trigger, beh.action);
      if (createMermaidGraphForDebugging)
        mermaidGraph += `end
`;
    }
    if (createMermaidGraphForDebugging)
      mermaidGraph += "\n" + mermaidGraphTopLevel;
    if (createMermaidGraphForDebugging) {
      console.log("All USDZ behaviours", this.behaviours);
      console.warn("The Mermaid graph can be pasted into https://massive-mermaid.glitch.me/ or https://mermaid.live/edit. It should be in your clipboard already!");
      console.log(mermaidGraph);
      navigator.clipboard.writeText(mermaidGraph);
    }
    {
      let animationsGraph = "gantt\ntitle Animations\ndateFormat X\naxisFormat %s\n";
      const arr = Array.from(playAnimationActions);
      const animationTargetObjects = /* @__PURE__ */ new Set();
      for (const a of arr) {
        if (!a.affectedObjects)
          continue;
        if (typeof a.affectedObjects === "string")
          continue;
        if (Array.isArray(a.affectedObjects)) {
          for (const o of a.affectedObjects) {
            animationTargetObjects.add(o);
          }
        } else {
          animationTargetObjects.add(a.affectedObjects);
        }
        if (createMermaidGraphForDebugging) {
          animationsGraph += `section ${a.animationName} (${a.id})
`;
          animationsGraph += `${a.id} : ${a.start}, ${a.duration}s
`;
        }
      }
      if (createMermaidGraphForDebugging) {
        console.log(animationsGraph);
      }
      const animationTargetPaths = /* @__PURE__ */ new Set();
      for (const o of animationTargetObjects) {
        if (!o.getPath) {
          console.error("USDZExporter: Animation target object has no getPath method. This is likely a bug", o);
        }
        let path = o.getPath();
        if (path.startsWith("<"))
          path = path.substring(1);
        if (path.endsWith(">"))
          path = path.substring(0, path.length - 1);
        animationTargetPaths.add({ path, obj: o });
      }
      const sortedPaths = Array.from(animationTargetPaths).sort((a, b) => a.path.length - b.path.length);
      const overlappingTargets = new Array();
      for (let i = 0; i < sortedPaths.length; i++) {
        for (let j = i + 1; j < sortedPaths.length; j++) {
          if (sortedPaths[j].path.startsWith(sortedPaths[i].path)) {
            const c2 = sortedPaths[j];
            const p = sortedPaths[i];
            overlappingTargets.push({ child: c2.obj.displayName + " (" + c2.path + ")", parent: p.obj.displayName + " (" + p.path + ")" });
          }
        }
      }
      if (overlappingTargets.length) {
        console.warn("USDZExporter: There are overlapping PlayAnimation actions. This can lead to undefined runtime behaviour when playing multiple animations. Please restructure the hierarchy so that animations don't overlap.", {
          overlappingTargets,
          playAnimationActions
        });
      }
    }
    for (const source of /* @__PURE__ */ new Set([...triggerSources, ...actionTargets])) {
      if (Array.isArray(source)) {
        for (const s of source)
          targetUuids.add(s.uuid);
      } else
        targetUuids.add(source.uuid);
    }
    if (debug62)
      console.log("All Behavior trigger sources and action targets", triggerSources, actionTargets, targetUuids);
    this.targetUuids = new Set(targetUuids);
  }
  onAfterHierarchy(context, writer) {
    var _a2;
    if ((_a2 = this.behaviours) == null ? void 0 : _a2.length) {
      writer.beginBlock('def Scope "Behaviors"');
      for (const beh of this.behaviours)
        beh.writeTo(this, context.document, writer);
      writer.closeBlock();
    }
  }
  async onAfterSerialize(context) {
    if (debug62)
      console.log("onAfterSerialize behaviours", this.behaviourComponentsCopy);
    for (const beh of this.behaviourComponentsCopy) {
      if (typeof beh.afterSerialize === "function") {
        const isAsync = beh.afterSerialize.constructor.name === "AsyncFunction";
        if (isAsync) {
          await beh.afterSerialize(this, context);
        } else {
          beh.afterSerialize(this, context);
        }
      }
    }
    for (const { clipUrl, filesKey } of this.audioClipsCopy) {
      if (context.files[filesKey])
        return;
      const audio = await fetch(clipUrl);
      const audioBlob = await audio.blob();
      const arrayBuffer = await audioBlob.arrayBuffer();
      const audioData = new Uint8Array(arrayBuffer);
      context.files[filesKey] = audioData;
    }
    this.behaviourComponentsCopy.length = 0;
    this.audioClipsCopy.length = 0;
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/postprocessing/Effects/BloomEffect.js
var __decorate26 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var _BloomEffect = class extends PostProcessingEffect {
  constructor() {
    super(...arguments);
    /**
     * The bloom threshold controls at what brightness level the bloom effect will be applied.
     * A higher value means the bloom will be applied to brighter areas or lights only
     * @default 0.9
     */
    __publicField(this, "threshold", new VolumeParameter(0.9));
    /**
     * Intensity of the bloom effect. A higher value will increase the intensity of the bloom effect.
     * @default 1
     */
    __publicField(this, "intensity", new VolumeParameter(1));
    /**
     * Scatter value. The higher the value, the more the bloom will scatter.
     * @default 0.3
     */
    __publicField(this, "scatter", new VolumeParameter(0.3));
    /**
     * Set to true to use selective bloom when the effect gets created.
     * @default false
     */
    __publicField(this, "selectiveBloom");
  }
  get typeName() {
    return "Bloom";
  }
  init() {
    this.threshold.valueProcessor = (v4) => v4;
    this.intensity.valueProcessor = (v4) => v4;
    this.scatter.valueProcessor = (v4) => v4;
  }
  onCreateEffect() {
    let bloom;
    if (this.selectiveBloom == void 0) {
      this.selectiveBloom = _BloomEffect.useSelectiveBloom;
    }
    if (this.selectiveBloom) {
      const selectiveBloom = bloom = new SelectiveBloomEffect(this.context.scene, this.context.mainCamera, {
        blendFunction: BlendFunction.ADD,
        mipmapBlur: true,
        luminanceThreshold: this.threshold.value,
        luminanceSmoothing: this.scatter.value,
        radius: 0.85,
        intensity: this.intensity.value
      });
      selectiveBloom.inverted = true;
    } else {
      bloom = new BloomEffect({
        blendFunction: BlendFunction.ADD,
        mipmapBlur: true,
        luminanceThreshold: this.threshold.value,
        luminanceSmoothing: this.scatter.value,
        radius: 0.85,
        intensity: this.intensity.value
      });
    }
    this.intensity.onValueChanged = (newValue) => {
      bloom.intensity = newValue;
    };
    this.threshold.onValueChanged = (newValue) => {
      bloom.luminanceMaterial.threshold = Math.pow(newValue, 2.2);
    };
    this.scatter.onValueChanged = (newValue) => {
      bloom.luminancePass.enabled = true;
      bloom.luminanceMaterial.smoothing = newValue;
      if (bloom["mipmapBlurPass"])
        bloom["mipmapBlurPass"].radius = MathUtils.lerp(0.1, 0.9, newValue);
    };
    return bloom;
  }
};
var BloomEffect2 = _BloomEffect;
/** Whether to use selective bloom by default */
__publicField(BloomEffect2, "useSelectiveBloom", false);
__decorate26([
  serializable(VolumeParameter)
], BloomEffect2.prototype, "threshold", void 0);
__decorate26([
  serializable(VolumeParameter)
], BloomEffect2.prototype, "intensity", void 0);
__decorate26([
  serializable(VolumeParameter)
], BloomEffect2.prototype, "scatter", void 0);
registerCustomEffectType("Bloom", BloomEffect2);

// node_modules/@needle-tools/engine/lib/engine-components/Collider.js
var __decorate27 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var Collider = class extends Component2 {
  constructor() {
    super(...arguments);
    /**
     * The Rigidbody that this collider is attached to.
     */
    __publicField(this, "attachedRigidbody", null);
    /**
     * When `true` the collider will not be used for collision detection but will still trigger events.
     */
    __publicField(this, "isTrigger", false);
    /**
     * The physics material that is used for the collider. This material defines physical properties of the collider such as friction and bounciness.
     */
    __publicField(this, "sharedMaterial");
    /**
     * The layers that the collider is assigned to.
     */
    __publicField(this, "membership", [0]);
    /**
     * The layers that the collider will interact with.
     * @inheritdoc
     */
    __publicField(this, "filter");
    /**
     * Apply the collider properties to the physics engine.
     */
    __publicField(this, "updateProperties", () => {
      var _a2;
      (_a2 = this.context.physics.engine) == null ? void 0 : _a2.updateProperties(this);
    });
  }
  /** @internal */
  get isCollider() {
    return true;
  }
  /** @internal */
  awake() {
    super.awake();
    if (!this.attachedRigidbody)
      this.attachedRigidbody = this.gameObject.getComponentInParent(Rigidbody);
  }
  /** @internal */
  start() {
    if (!this.attachedRigidbody)
      this.attachedRigidbody = this.gameObject.getComponentInParent(Rigidbody);
  }
  /** @internal */
  onEnable() {
    if (!this.attachedRigidbody)
      this.attachedRigidbody = this.gameObject.getComponentInParent(Rigidbody);
  }
  /** @internal */
  onDisable() {
    var _a2;
    (_a2 = this.context.physics.engine) == null ? void 0 : _a2.removeBody(this);
  }
  /** Returns the underlying physics body from the physics engine (if any) - the component must be enabled and active in the scene */
  get body() {
    var _a2;
    return (_a2 = this.context.physics.engine) == null ? void 0 : _a2.getBody(this);
  }
  /** Requests an update of the physics material in the physics engine */
  updatePhysicsMaterial() {
    var _a2;
    (_a2 = this.context.physics.engine) == null ? void 0 : _a2.updatePhysicsMaterial(this);
  }
};
__decorate27([
  serializable(Rigidbody)
], Collider.prototype, "attachedRigidbody", void 0);
__decorate27([
  serializable()
], Collider.prototype, "isTrigger", void 0);
__decorate27([
  serializable()
], Collider.prototype, "sharedMaterial", void 0);
__decorate27([
  serializable()
], Collider.prototype, "membership", void 0);
__decorate27([
  serializable()
], Collider.prototype, "filter", void 0);
var SphereCollider = class extends Collider {
  constructor() {
    super(...arguments);
    __publicField(this, "radius", 0.5);
    __publicField(this, "center", new Vector32(0, 0, 0));
  }
  onEnable() {
    var _a2;
    super.onEnable();
    (_a2 = this.context.physics.engine) == null ? void 0 : _a2.addSphereCollider(this);
    watchWrite(this.gameObject.scale, this.updateProperties);
  }
  onDisable() {
    super.onDisable();
    unwatchWrite(this.gameObject.scale, this.updateProperties);
  }
  onValidate() {
    this.updateProperties();
  }
};
__decorate27([
  validate2(),
  serializable()
], SphereCollider.prototype, "radius", void 0);
__decorate27([
  serializable(Vector32)
], SphereCollider.prototype, "center", void 0);
var BoxCollider = class extends Collider {
  constructor() {
    super(...arguments);
    __publicField(this, "size", new Vector32(1, 1, 1));
    __publicField(this, "center", new Vector32(0, 0, 0));
  }
  static add(obj, opts) {
    const collider = new BoxCollider();
    if (!obj.geometry.boundingBox)
      obj.geometry.computeBoundingBox();
    const bb = obj.geometry.boundingBox;
    collider.size = bb.getSize(new Vector32()) || new Vector32(1, 1, 1);
    collider.center = bb.getCenter(new Vector32()) || new Vector32(0, 0, 0);
    addComponent(obj, collider);
    if ((opts == null ? void 0 : opts.rigidbody) === true) {
      addComponent(obj, Rigidbody, { isKinematic: false });
    }
    return collider;
  }
  onEnable() {
    var _a2;
    super.onEnable();
    (_a2 = this.context.physics.engine) == null ? void 0 : _a2.addBoxCollider(this, this.size);
    watchWrite(this.gameObject.scale, this.updateProperties);
  }
  onDisable() {
    super.onDisable();
    unwatchWrite(this.gameObject.scale, this.updateProperties);
  }
  onValidate() {
    this.updateProperties();
  }
};
__decorate27([
  validate2(),
  serializable(Vector32)
], BoxCollider.prototype, "size", void 0);
__decorate27([
  serializable(Vector32)
], BoxCollider.prototype, "center", void 0);
var MeshCollider = class extends Collider {
  constructor() {
    super(...arguments);
    /**
     * The mesh that is used for the collider.
     */
    __publicField(this, "sharedMesh");
    /** When `true` the collider won't have holes or entrances.
     * If you wan't this mesh collider to be able to *contain* other objects this should be set to `false` */
    __publicField(this, "convex", false);
  }
  onEnable() {
    var _a2, _b, _c;
    super.onEnable();
    if (!this.context.physics.engine)
      return;
    if (!((_a2 = this.sharedMesh) == null ? void 0 : _a2.isMesh)) {
      if (this.gameObject instanceof Mesh || this.gameObject instanceof Group) {
        this.sharedMesh = this.gameObject;
      }
    }
    const LOD3 = 0;
    if ((_b = this.sharedMesh) == null ? void 0 : _b.isMesh) {
      this.context.physics.engine.addMeshCollider(this, this.sharedMesh, this.convex, getWorldScale(this.gameObject));
      NEEDLE_progressive.assignMeshLOD(this.sharedMesh, LOD3).then((res) => {
        if (res && this.activeAndEnabled && this.context.physics.engine && this.sharedMesh) {
          this.context.physics.engine.removeBody(this);
          this.sharedMesh.geometry = res;
          this.context.physics.engine.addMeshCollider(this, this.sharedMesh, this.convex, getWorldScale(this.gameObject));
        }
      });
    } else {
      const group = this.sharedMesh;
      if (group == null ? void 0 : group.isGroup) {
        console.warn(`MeshCollider mesh is a group "${((_c = this.sharedMesh) == null ? void 0 : _c.name) || this.gameObject.name}", adding all children as colliders. This is currently not fully supported (colliders can not be removed from world again)`, this);
        const promises = new Array();
        for (const ch in group.children) {
          const child = group.children[ch];
          if (child.isMesh) {
            this.context.physics.engine.addMeshCollider(this, child, this.convex, getWorldScale(this.gameObject));
            promises.push(NEEDLE_progressive.assignMeshLOD(child, LOD3));
          }
        }
        Promise.all(promises).then((res) => {
          var _a3, _b2;
          if (res.some((r) => r) == false)
            return;
          (_a3 = this.context.physics.engine) == null ? void 0 : _a3.removeBody(this);
          const mesh = new Mesh();
          for (const r of res) {
            if (r && this.activeAndEnabled) {
              mesh.geometry = r;
              (_b2 = this.context.physics.engine) == null ? void 0 : _b2.addMeshCollider(this, mesh, this.convex, getWorldScale(this.gameObject));
            }
          }
        });
      } else {
        console.warn("A MeshCollider mesh is assigned, but it's neither a Mesh nor a Group. Please report a bug!", this, this.sharedMesh);
      }
    }
  }
};
__decorate27([
  serializable(Mesh)
], MeshCollider.prototype, "sharedMesh", void 0);
__decorate27([
  serializable()
], MeshCollider.prototype, "convex", void 0);
var CapsuleCollider = class extends Collider {
  constructor() {
    super(...arguments);
    __publicField(this, "center", new Vector32(0, 0, 0));
    __publicField(this, "radius", 0.5);
    __publicField(this, "height", 2);
  }
  onEnable() {
    var _a2;
    super.onEnable();
    (_a2 = this.context.physics.engine) == null ? void 0 : _a2.addCapsuleCollider(this, this.height, this.radius);
  }
};
__decorate27([
  serializable(Vector32)
], CapsuleCollider.prototype, "center", void 0);
__decorate27([
  serializable()
], CapsuleCollider.prototype, "radius", void 0);
__decorate27([
  serializable()
], CapsuleCollider.prototype, "height", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/Gizmos.js
var __decorate28 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var BoxGizmo = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "objectBounds", false);
    __publicField(this, "color");
    __publicField(this, "isGizmo", true);
    __publicField(this, "_gizmoObject", null);
    __publicField(this, "_boxHelper", null);
  }
  onEnable() {
    if (this.isGizmo && !showGizmos)
      return;
    if (!this._gizmoObject) {
      if (this.objectBounds) {
        this._gizmoObject = new BoxHelper(this.gameObject, this.color ?? 16776960);
      } else {
        this.objectBounds = false;
        this._gizmoObject = CreateWireCube(this.color ?? 16776960);
      }
    }
    if (this.objectBounds) {
      this.scene.add(this._gizmoObject);
      this._boxHelper = this._gizmoObject;
      this.startCoroutine(this.syncObjectBounds(), FrameEvent.OnBeforeRender);
    } else
      this.gameObject.add(this._gizmoObject);
  }
  onDisable() {
    if (this._gizmoObject) {
      this.gameObject.remove(this._gizmoObject);
    }
  }
  *syncObjectBounds() {
    var _a2;
    while (this._boxHelper) {
      (_a2 = this._boxHelper) == null ? void 0 : _a2.update();
      yield;
    }
  }
};
__decorate28([
  serializable()
], BoxGizmo.prototype, "objectBounds", void 0);
__decorate28([
  serializable(Color)
], BoxGizmo.prototype, "color", void 0);
__decorate28([
  serializable()
], BoxGizmo.prototype, "isGizmo", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/BoxHelperComponent.js
var gizmos = getParam("gizmos");
var debug63 = getParam("debugboxhelper");
var _BoxHelperComponent = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "box", null);
    __publicField(this, "_lastMatrixUpdateFrame", -1);
    __publicField(this, "_helper", null);
    __publicField(this, "_color", null);
  }
  isInBox(obj) {
    var _a2;
    if (!obj)
      return void 0;
    if (!this.box) {
      this.box = new Box3();
    }
    getBoundingBox([obj], void 0, void 0, _BoxHelperComponent.testBox);
    if (_BoxHelperComponent.testBox.isEmpty()) {
      const wp = getWorldPosition(obj, _BoxHelperComponent._position);
      _BoxHelperComponent.testBox.setFromCenterAndSize(wp, _BoxHelperComponent._emptyObjectSize);
    }
    this.updateBox();
    const intersects = (_a2 = this.box) == null ? void 0 : _a2.intersectsBox(_BoxHelperComponent.testBox);
    if (intersects) {
      if (debug63)
        Gizmos.DrawWireBox3(_BoxHelperComponent.testBox, 16711680, 5);
    }
    return intersects;
  }
  intersects(box2) {
    if (!box2)
      return false;
    return this.updateBox(false).intersectsBox(box2);
  }
  updateBox(force = false) {
    if (!this.box) {
      this.box = new Box3();
    }
    if (force || this.context.time.frameCount != this._lastMatrixUpdateFrame) {
      const firstUpdate = this._lastMatrixUpdateFrame < 0;
      this._lastMatrixUpdateFrame = this.context.time.frameCount;
      const updateParents = firstUpdate;
      const wp = getWorldPosition(this.gameObject, _BoxHelperComponent._position, updateParents);
      const size = getWorldScale(this.gameObject, _BoxHelperComponent._size);
      this.box.setFromCenterAndSize(wp, size);
    }
    return this.box;
  }
  awake() {
    this._helper = null;
    this._color = null;
    this.box = null;
  }
  showHelper(col2 = null, force = false) {
    var _a2;
    if (!gizmos && !force)
      return;
    if (this._helper) {
      if (col2)
        (_a2 = this._color) == null ? void 0 : _a2.set(col2);
      this.gameObject.add(this._helper);
      return;
    }
    this._helper = CreateWireCube(col2);
    this.gameObject.add(this._helper);
  }
};
var BoxHelperComponent = _BoxHelperComponent;
__publicField(BoxHelperComponent, "testBox", new Box3());
__publicField(BoxHelperComponent, "_position", new Vector32());
__publicField(BoxHelperComponent, "_size", new Vector32(0.01, 0.01, 0.01));
__publicField(BoxHelperComponent, "_emptyObjectSize", new Vector32(0.01, 0.01, 0.01));

// node_modules/three-mesh-ui/examples/behaviors/states/SimpleStateBehavior.js
var SimpleStateBehavior = class extends __webpack_exports__Behavior {
  constructor(subject, states = {}) {
    super(subject);
    subject._simpleState__activeStates = [];
    subject._simpleState__normalStyles = {};
    subject._simpleState__states = states;
    subject._simpleState__statesProperties = {};
    for (const statesKey in states) {
      for (const styleProperty in states[statesKey]) {
        if (!subject._simpleState__statesProperties[styleProperty]) {
          subject._simpleState__statesProperties[styleProperty] = [];
        }
        subject._simpleState__statesProperties[styleProperty].push(statesKey);
      }
    }
    for (const component of subject._components) {
      if (subject._simpleState__statesProperties[component.id]) {
        subject._simpleState__normalStyles[component.id] = component.inline ? component.inline : component._value;
      }
    }
    subject.__overridedSet = subject.set;
    subject.set = this.storeSet.bind(subject);
    subject.renderStates = this.renderStates.bind(subject);
    subject.setupState = this.setupState.bind(subject);
    subject.setState = this.setState.bind(subject);
    subject.activatePseudoState = this.activatePseudoState.bind(subject);
    subject.deactivatePseudoState = this.deactivatePseudoState.bind(subject);
    subject.togglePseudoState = this.togglePseudoState.bind(subject);
  }
  act() {
  }
  attach() {
  }
  detach() {
  }
  setupState(state, options) {
    this._simpleState__states[state] = options;
    const newOptions = [];
    for (const styleProperty in options) {
      if (!this._simpleState__statesProperties[styleProperty]) {
        this._simpleState__statesProperties[styleProperty] = [];
        newOptions.push(styleProperty);
      }
      this._simpleState__statesProperties[styleProperty].push(state);
    }
    for (const component of this._components) {
      if (newOptions.indexOf(component.id) > -1) {
        this._simpleState__normalStyles[component.id] = component.inline ? component.inline : component._value;
      }
    }
  }
  renderStates() {
    let stateValues = { ...this._simpleState__normalStyles };
    for (const state in this._simpleState__states) {
      if (this._simpleState__activeStates.indexOf(state) > -1) {
        stateValues = { ...stateValues, ...this._simpleState__states[state] };
      }
    }
    this.set(stateValues, false);
  }
  /**
   * @internal will replace default set method
   * @param options
   * @param store
   */
  storeSet(options, store = true) {
    if (store) {
      for (const optionsKey in options) {
        if (this._simpleState__statesProperties[optionsKey]) {
          this._simpleState__normalStyles[optionsKey] = options[optionsKey];
        }
      }
    }
    this.__overridedSet(options);
  }
  activatePseudoState(state) {
    if (this._simpleState__activeStates.indexOf(state) === -1) {
      this._simpleState__activeStates.push(state);
      this.renderStates();
    }
  }
  deactivatePseudoState(state) {
    const index = this._simpleState__activeStates.indexOf(state);
    if (index > -1) {
      this._simpleState__activeStates.splice(index, 1);
      this.renderStates();
    }
  }
  togglePseudoState(state) {
    const index = this._simpleState__activeStates.indexOf(state);
    if (index > -1) {
      this._simpleState__activeStates.splice(index, 1);
    } else {
      this._simpleState__activeStates.push(state);
    }
    this.renderStates();
  }
  setState(states) {
    if (Array.isArray(states)) {
      this._simpleState__activeStates = states;
    } else {
      this._simpleState__activeStates = [states];
    }
    this.renderStates();
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/ui/Outline.js
var __decorate29 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var Outline = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "effectColor");
    __publicField(this, "effectDistance");
  }
};
__decorate29([
  serializable(RGBAColor)
], Outline.prototype, "effectColor", void 0);
__decorate29([
  serializable(Vector2)
], Outline.prototype, "effectDistance", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/ui/RectTransform.js
var __decorate30 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug64 = getParam("debugui");
var debugLayout = getParam("debuguilayout");
var Size = class {
  constructor() {
    __publicField(this, "width");
    __publicField(this, "height");
  }
};
var Rect = class {
  constructor() {
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "width");
    __publicField(this, "height");
  }
};
var tempVec2 = new Vector32();
var tempMatrix = new Matrix4();
var tempQuaternion2 = new Quaternion();
var RectTransform = class extends BaseUIComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "_anchoredPosition");
    __publicField(this, "sizeDelta", new Vector2(100, 100));
    __publicField(this, "pivot", new Vector2(0.5, 0.5));
    __publicField(this, "anchorMin", new Vector2(0, 0));
    __publicField(this, "anchorMax", new Vector2(1, 1));
    // @serializable(Vector2)
    // offsetMin: Vector2 = new Vector2(0, 0);
    // @serializable(Vector2)
    // offsetMax: Vector2 = new Vector2(0, 0);
    /** Optional min width in pixel, set to undefined to disable it */
    __publicField(this, "minWidth");
    /** Optional min height in pixel, set to undefined to disable it */
    __publicField(this, "minHeight");
    // private lastMatrixWorld!: Matrix4;
    __publicField(this, "lastMatrix");
    __publicField(this, "rectBlock");
    __publicField(this, "_transformNeedsUpdate", false);
    __publicField(this, "_initialPosition");
    __publicField(this, "_parentRectTransform");
    __publicField(this, "_lastUpdateFrame", -1);
    // onAfterRender() {
    //     if (this._copyMatrixAfterRender) {
    //         // can we only have this event when the transform changed in this frame? Otherwise all RectTransforms will be iterated. Not sure what is better
    //         this.lastMatrixWorld.copy(this.gameObject.matrixWorld);
    //     }
    // }
    __publicField(this, "_lastAnchoring");
    __publicField(this, "_createdBlocks", []);
    __publicField(this, "_createdTextBlocks", []);
  }
  get parent() {
    return this._parentRectTransform;
  }
  // @serializable(Object3D)
  // root? : Object3D;
  get translation() {
    return this.gameObject.position;
  }
  get rotation() {
    return this.gameObject.quaternion;
  }
  get scale() {
    return this.gameObject.scale;
  }
  get anchoredPosition() {
    if (!this._anchoredPosition)
      this._anchoredPosition = new Vector2();
    return this._anchoredPosition;
  }
  set anchoredPosition(value) {
    this._anchoredPosition = value;
  }
  get width() {
    let width = this.sizeDelta.x;
    if (this.anchorMin.x !== this.anchorMax.x) {
      if (this._parentRectTransform) {
        const parentWidth = this._parentRectTransform.width;
        const anchorWidth = this.anchorMax.x - this.anchorMin.x;
        width = parentWidth * anchorWidth;
        width += this.sizeDelta.x;
      }
    }
    if (this.minWidth !== void 0 && width < this.minWidth)
      return this.minWidth;
    return width;
  }
  get height() {
    let height = this.sizeDelta.y;
    if (this.anchorMin.y !== this.anchorMax.y) {
      if (this._parentRectTransform) {
        const parentHeight = this._parentRectTransform.height;
        const anchorHeight = this.anchorMax.y - this.anchorMin.y;
        height = parentHeight * anchorHeight;
        height += this.sizeDelta.y;
      }
    }
    if (this.minHeight !== void 0 && height < this.minHeight)
      return this.minHeight;
    return height;
  }
  awake() {
    super.awake();
    if (!this._anchoredPosition)
      this._anchoredPosition = new Vector2();
    this.lastMatrix = new Matrix4();
    this.rectBlock = new Object3D();
    this.rectBlock.name = this.name;
    this._initialPosition = this.gameObject.position.clone();
    this._initialPosition.z = 0;
    onChange(this, "_anchoredPosition", () => {
      this.markDirty();
    });
    onChange(this, "sizeDelta", () => {
      this.markDirty();
    });
    onChange(this, "pivot", () => {
      this.markDirty();
    });
    onChange(this, "anchorMin", () => {
      this.markDirty();
    });
    onChange(this, "anchorMax", () => {
      this.markDirty();
    });
  }
  onEnable() {
    var _a2;
    super.onEnable();
    if (!this.rectBlock)
      this.rectBlock = new Object3D();
    if (!this.lastMatrix)
      this.lastMatrix = new Matrix4();
    if (!this._lastAnchoring)
      this._lastAnchoring = new Vector2();
    if (!this._initialPosition)
      this._initialPosition = new Vector32();
    if (!this._anchoredPosition)
      this._anchoredPosition = new Vector2();
    this.addShadowComponent(this.rectBlock);
    this._transformNeedsUpdate = true;
    (_a2 = this.canvas) == null ? void 0 : _a2.registerTransform(this);
  }
  onDisable() {
    var _a2;
    super.onDisable();
    this.removeShadowComponent();
    (_a2 = this.canvas) == null ? void 0 : _a2.unregisterTransform(this);
  }
  onParentRectTransformChanged(comp) {
    if (this._transformNeedsUpdate)
      return;
    this.onApplyTransform(debugLayout ? `${comp.name} changed` : void 0);
  }
  get isDirty() {
    if (!this._transformNeedsUpdate)
      this._transformNeedsUpdate = !this.lastMatrix.equals(this.gameObject.matrix);
    return this._transformNeedsUpdate;
  }
  // private _copyMatrixAfterRender: boolean = false;
  markDirty() {
    if (this._transformNeedsUpdate)
      return;
    if (debugLayout)
      console.warn("RectTransform markDirty()", this.name);
    this._transformNeedsUpdate = true;
    this._lastUpdateFrame = -1;
  }
  /** Will update the transforms if it changed or is dirty */
  updateTransform() {
    const transformChanged = this._transformNeedsUpdate || !this.lastMatrix.equals(this.gameObject.matrix);
    if (transformChanged && this.canUpdate()) {
      this.onApplyTransform(this._transformNeedsUpdate ? "Marked dirty" : "Matrix changed");
    }
  }
  canUpdate() {
    return this._transformNeedsUpdate && this.activeAndEnabled && this._lastUpdateFrame !== this.context.time.frame;
  }
  onApplyTransform(reason) {
    var _a2;
    if (this.context.time.frameCount === this._lastUpdateFrame)
      return;
    this._lastUpdateFrame = this.context.time.frameCount;
    const uiobject = this.shadowComponent;
    if (!uiobject)
      return;
    if (this.gameObject.parent)
      this._parentRectTransform = GameObject.getComponentInParent(this.gameObject.parent, RectTransform);
    else
      this._parentRectTransform = void 0;
    this._transformNeedsUpdate = false;
    if (debugLayout)
      console.warn("RectTransform → ApplyTransform", this.name + " because " + reason);
    if (!this.isRoot()) {
      uiobject.matrix.identity();
      uiobject.matrixAutoUpdate = false;
      tempVec2.set(0, 0, 0);
      this.applyPivot(tempVec2);
      uiobject.matrix.setPosition(tempVec2.x, tempVec2.y, 0);
      if (this.gameObject.quaternion.x || this.gameObject.quaternion.y || this.gameObject.quaternion.z) {
        tempQuaternion2.copy(this.gameObject.quaternion);
        tempQuaternion2.x *= -1;
        tempQuaternion2.z *= -1;
        tempMatrix.makeRotationFromQuaternion(tempQuaternion2);
        uiobject.matrix.premultiply(tempMatrix);
      }
      tempVec2.set(0, 0, 0);
      this.applyAnchoring(tempVec2);
      if ((_a2 = this.canvas) == null ? void 0 : _a2.screenspace)
        tempVec2.z += 0.1;
      else
        tempVec2.z += 0.01;
      tempMatrix.identity();
      tempMatrix.setPosition(tempVec2.x, tempVec2.y, tempVec2.z);
      uiobject.matrix.premultiply(tempMatrix);
      uiobject.matrix.scale(this.gameObject.scale);
    } else {
      const canvas = this.Root;
      if (!canvas.screenspace)
        uiobject.rotation.y = Math.PI;
    }
    this.lastMatrix.copy(this.gameObject.matrix);
    const includeChildren = true;
    for (const comp of foreachComponentEnumerator(this.gameObject, BaseUIComponent, includeChildren, 1)) {
      if (comp === this)
        continue;
      if (!comp.activeAndEnabled)
        continue;
      const callback = comp;
      if (callback.onParentRectTransformChanged) {
        callback.onParentRectTransformChanged(this);
      }
    }
  }
  /** applies the position offset to the passed in vector */
  applyAnchoring(pos) {
    if (!this._lastAnchoring)
      this._lastAnchoring = new Vector2();
    const diff = this._lastAnchoring.sub(this._anchoredPosition);
    this.gameObject.position.x += diff.x;
    this.gameObject.position.y += diff.y;
    this._lastAnchoring.copy(this._anchoredPosition);
    pos.x += this._initialPosition.x - this.gameObject.position.x;
    pos.y += this._initialPosition.y - this.gameObject.position.y;
    pos.z += this._initialPosition.z - this.gameObject.position.z;
    const parent = this._parentRectTransform;
    if (parent) {
      let oy = 0;
      const vert2 = 1 - this.anchorMax.y - this.anchorMin.y;
      oy -= parent.height * 0.5 * vert2;
      pos.y += oy;
      let ox = 0;
      const horz = 1 - this.anchorMax.x - this.anchorMin.x;
      ox -= parent.width * 0.5 * horz;
      pos.x += ox;
    }
  }
  /** applies the pivot offset to the passed in vector */
  applyPivot(vec2) {
    if (this.pivot && !this.isRoot()) {
      const pv = this.pivot.x - 0.5;
      vec2.x -= pv * this.sizeDelta.x * this.gameObject.scale.x;
      const ph = this.pivot.y - 0.5;
      vec2.y -= ph * this.sizeDelta.y * this.gameObject.scale.y;
    }
  }
  getBasicOptions() {
    const opts = {
      width: this.sizeDelta.x,
      height: this.sizeDelta.y,
      offset: 0,
      backgroundOpacity: 0,
      borderWidth: 0,
      borderRadius: 0,
      borderOpacity: 0,
      letterSpacing: -0.03
      // justifyContent: 'center',
      // alignItems: 'center',
      // alignContent: 'center',
      // backgroundColor: new Color(1, 1, 1),
    };
    this.ensureValidSize(opts);
    return opts;
  }
  // e.g. when a transform has the size 0,0 we still want to render the text
  ensureValidSize(opts, fallbackWidth = 1e-4) {
    if (opts.width <= 0) {
      opts.width = fallbackWidth;
    }
    if (opts.height <= 0)
      opts.height = 1e-4;
    return opts;
  }
  createNewBlock(opts) {
    opts = {
      ...this.getBasicOptions(),
      ...opts
    };
    if (debug64)
      console.log(this.name, opts);
    const block = new __webpack_exports__Block(opts);
    this._createdBlocks.push(block);
    return block;
  }
  createNewText(opts) {
    if (debug64)
      console.log(opts);
    opts = {
      ...this.getBasicOptions(),
      ...opts
    };
    if (debug64)
      console.log(this.name, opts);
    const block = new __webpack_exports__Text(opts);
    this._createdTextBlocks.push(block);
    return block;
  }
};
__decorate30([
  serializable(Vector2)
], RectTransform.prototype, "anchoredPosition", null);
__decorate30([
  serializable(Vector2)
], RectTransform.prototype, "sizeDelta", void 0);
__decorate30([
  serializable(Vector2)
], RectTransform.prototype, "pivot", void 0);
__decorate30([
  serializable(Vector2)
], RectTransform.prototype, "anchorMin", void 0);
__decorate30([
  serializable(Vector2)
], RectTransform.prototype, "anchorMax", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/ui/Graphic.js
var __decorate31 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var _colorStateObject = {
  backgroundColor: new Color(1, 1, 1),
  backgroundOpacity: 1,
  borderColor: new Color(1, 1, 1),
  borderOpacity: 1
};
var _Graphic = class extends BaseUIComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "_alphaFactor", 1);
    __publicField(this, "sRGBColor", new Color(1, 0, 1));
    __publicField(this, "raycastTarget", true);
    __publicField(this, "uiObject", null);
    __publicField(this, "_color", null);
    __publicField(this, "_rect", null);
    __publicField(this, "_stateManager", null);
    __publicField(this, "_currentlyCreatingPanel", false);
  }
  get isGraphic() {
    return true;
  }
  get color() {
    if (!this._color)
      this._color = new RGBAColor(1, 1, 1, 1);
    return this._color;
  }
  set color(col2) {
    const changed = !this._color || this._color.r !== col2.r || this._color.g !== col2.g || this._color.b !== col2.b || this._color.alpha !== col2.alpha;
    if (!changed)
      return;
    if (!this._color) {
      this._color = new RGBAColor(1, 1, 1, 1);
    }
    this._color.copy(col2);
    this.onColorChanged();
  }
  setAlphaFactor(factor) {
    this._alphaFactor = factor;
    this.onColorChanged();
  }
  get alphaFactor() {
    return this._alphaFactor;
  }
  onColorChanged() {
    if (this.uiObject) {
      this.sRGBColor.copy(this._color);
      this.sRGBColor.convertLinearToSRGB();
      _colorStateObject.backgroundColor = this.sRGBColor;
      _colorStateObject.backgroundOpacity = this._color.alpha * this._alphaFactor;
      this.applyEffects(_colorStateObject, this._alphaFactor);
      this.uiObject.set(_colorStateObject);
      this.markDirty();
    }
  }
  // used via animations
  get m_Color() {
    return this._color;
  }
  get rectTransform() {
    if (!this._rect) {
      this._rect = GameObject.getComponent(this.gameObject, RectTransform);
    }
    if (!this._rect)
      throw new Error("Not Supported: Make sure to add a RectTransform component before adding a UI Graphic component.");
    return this._rect;
  }
  onParentRectTransformChanged() {
    var _a2;
    (_a2 = this.uiObject) == null ? void 0 : _a2.set({ width: this.rectTransform.width, height: this.rectTransform.height });
    this.markDirty();
  }
  __internalNewInstanceCreated(init) {
    super.__internalNewInstanceCreated(init);
    this._rect = null;
    this.uiObject = null;
    if (this._color)
      this._color = this._color.clone();
    return this;
  }
  setState(state) {
    this.makePanel();
    if (this.uiObject) {
      this.uiObject.setState(state);
      this == null ? void 0 : this.markDirty();
    }
  }
  setupState(state) {
    this.makePanel();
    if (this.uiObject) {
      if (!this._stateManager)
        this._stateManager = new SimpleStateBehavior(this.uiObject);
      this.uiObject.setupState(state.state, state.attributes);
    }
  }
  setOptions(opts) {
    this.makePanel();
    if (this.uiObject) {
      this.uiObject.set(opts);
    }
  }
  awake() {
    super.awake();
    this.makePanel();
    onChange(this, "_color", () => scheduleAction(this, this.onColorChanged));
  }
  onEnable() {
    var _a2;
    super.onEnable();
    if (this.uiObject) {
      (_a2 = this.rectTransform.shadowComponent) == null ? void 0 : _a2.add(this.uiObject);
      this.addShadowComponent(this.uiObject, this.rectTransform);
    }
  }
  onDisable() {
    super.onDisable();
    if (this.uiObject)
      this.removeShadowComponent();
  }
  makePanel() {
    if (this.uiObject)
      return;
    if (this._currentlyCreatingPanel)
      return;
    this._currentlyCreatingPanel = true;
    const offset = 0.015;
    const opts = {
      backgroundColor: this.color,
      backgroundOpacity: this.color.alpha,
      offset
      // without a tiny offset we get z fighting
    };
    this.onBeforeCreate(opts);
    this.applyEffects(opts);
    this.onCreate(opts);
    this.controlsChildLayout = false;
    this._currentlyCreatingPanel = false;
    this.onAfterCreated();
    this.onColorChanged();
  }
  onBeforeCreate(_opts) {
  }
  onCreate(opts) {
    this.uiObject = this.rectTransform.createNewBlock(opts);
    this.uiObject.name = this.name;
  }
  onAfterCreated() {
  }
  applyEffects(opts, alpha = 1) {
    var _a2;
    const outline = (_a2 = this.gameObject) == null ? void 0 : _a2.getComponent(Outline);
    if (outline) {
      if (outline.effectDistance)
        opts.borderWidth = Math.max(Math.abs(outline.effectDistance.x), Math.abs(outline.effectDistance.y));
      if (outline.effectColor) {
        opts.borderColor = outline.effectColor;
        opts.borderOpacity = outline.effectColor.alpha * alpha;
      }
    }
  }
  async setTexture(tex) {
    this.setOptions({ backgroundOpacity: 0 });
    if (tex) {
      if (_Graphic.textureCache.has(tex)) {
        tex = _Graphic.textureCache.get(tex);
      } else {
        if (tex.isRenderTargetTexture) {
        } else {
          const clone = tex.clone();
          clone.colorSpace = LinearSRGBColorSpace;
          _Graphic.textureCache.set(tex, clone);
          tex = clone;
        }
      }
      this.setOptions({ backgroundImage: tex, borderRadius: 0, backgroundOpacity: this.color.alpha, backgroundSize: "stretch" });
      NEEDLE_progressive.assignTextureLOD(tex, 0).then((res) => {
        if (res instanceof Texture) {
          if (tex)
            _Graphic.textureCache.set(tex, res);
          this.setOptions({ backgroundImage: res });
          this.markDirty();
        }
      });
    } else {
      this.setOptions({ backgroundImage: void 0, borderRadius: 0, backgroundOpacity: this.color.alpha });
    }
    this.markDirty();
  }
  onAfterAddedToScene() {
    super.onAfterAddedToScene();
    if (this.shadowComponent) {
      this.shadowComponent.offset = this.shadowComponent.position.z;
    }
  }
};
var Graphic = _Graphic;
/** used internally to ensure textures assigned to UI use linear encoding */
__publicField(Graphic, "textureCache", /* @__PURE__ */ new Map());
__decorate31([
  serializable(RGBAColor)
], Graphic.prototype, "color", null);
__decorate31([
  serializable()
], Graphic.prototype, "raycastTarget", void 0);
var MaskableGraphic = class extends Graphic {
  constructor() {
    super(...arguments);
    __publicField(this, "_flippedObject", false);
  }
  onAfterCreated() {
    if (this.uiObject && !this._flippedObject) {
      this._flippedObject = true;
      this.uiObject.scale.y *= -1;
    }
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/ui/Image.js
var __decorate32 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var Sprite2 = class {
  constructor() {
    __publicField(this, "texture", null);
    __publicField(this, "rect");
  }
};
__decorate32([
  serializable(Texture)
], Sprite2.prototype, "texture", void 0);
var Image2 = class extends MaskableGraphic {
  constructor() {
    super(...arguments);
    __publicField(this, "_sprite");
    __publicField(this, "pixelsPerUnitMultiplier", 1);
  }
  set image(img) {
    if (!this.sprite)
      this.sprite = new Sprite2();
    this.sprite.texture = img;
    this.onAfterCreated();
  }
  get image() {
    if (this.sprite)
      return this.sprite.texture;
    return null;
  }
  get sprite() {
    return this._sprite;
  }
  set sprite(sprite) {
    if (this._sprite === sprite)
      return;
    this._sprite = sprite;
    this.onAfterCreated();
  }
  isBuiltinSprite() {
    var _a2, _b, _c, _d, _e, _f, _g;
    const sprite = this.sprite;
    switch ((_a2 = sprite == null ? void 0 : sprite.texture) == null ? void 0 : _a2.name) {
      case "InputFieldBackground":
      case "UISprite":
      case "Background":
      case "Knob":
        return true;
    }
    if (!((_c = (_b = sprite == null ? void 0 : sprite.texture) == null ? void 0 : _b.name) == null ? void 0 : _c.length) && ((_e = (_d = sprite == null ? void 0 : sprite.texture) == null ? void 0 : _d.image) == null ? void 0 : _e.width) === 32 && ((_g = (_f = sprite == null ? void 0 : sprite.texture) == null ? void 0 : _f.image) == null ? void 0 : _g.height) === 32)
      return true;
    return false;
  }
  onBeforeCreate(opts) {
    var _a2, _b;
    super.onBeforeCreate(opts);
    if (this.isBuiltinSprite()) {
      opts.borderRadius = 5 / this.pixelsPerUnitMultiplier;
      if (((_b = (_a2 = this.sprite) == null ? void 0 : _a2.texture) == null ? void 0 : _b.name) === "Knob") {
        opts.borderRadius = 999;
      }
    }
  }
  onAfterCreated() {
    var _a2;
    if (!this.__didAwake)
      return;
    super.onAfterCreated();
    if (this.isBuiltinSprite())
      return;
    this.setTexture((_a2 = this.sprite) == null ? void 0 : _a2.texture);
  }
};
__decorate32([
  serializable(Sprite2)
], Image2.prototype, "sprite", null);
__decorate32([
  serializable()
], Image2.prototype, "pixelsPerUnitMultiplier", void 0);
var RawImage = class extends MaskableGraphic {
  constructor() {
    super(...arguments);
    __publicField(this, "_mainTexture");
  }
  get mainTexture() {
    return this._mainTexture;
  }
  set mainTexture(texture) {
    if (this._mainTexture === texture)
      return;
    this._mainTexture = texture;
    this.onAfterCreated();
  }
  onAfterCreated() {
    if (!this.__didAwake)
      return;
    super.onAfterCreated();
    this.setTexture(this.mainTexture);
  }
};
__decorate32([
  serializable(Texture)
], RawImage.prototype, "mainTexture", null);

// node_modules/@needle-tools/engine/lib/engine-components/ui/Button.js
var __decorate33 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug65 = getParam("debugbutton");
var Transition;
(function(Transition2) {
  Transition2[Transition2["None"] = 0] = "None";
  Transition2[Transition2["ColorTint"] = 1] = "ColorTint";
  Transition2[Transition2["SpriteSwap"] = 2] = "SpriteSwap";
  Transition2[Transition2["Animation"] = 3] = "Animation";
})(Transition || (Transition = {}));
var ButtonColors = class {
  constructor() {
    __publicField(this, "colorMultiplier");
    __publicField(this, "disabledColor");
    __publicField(this, "fadeDuration");
    __publicField(this, "highlightedColor");
    __publicField(this, "normalColor");
    __publicField(this, "pressedColor");
    __publicField(this, "selectedColor");
  }
};
__decorate33([
  serializable()
], ButtonColors.prototype, "colorMultiplier", void 0);
__decorate33([
  serializable(RGBAColor)
], ButtonColors.prototype, "disabledColor", void 0);
__decorate33([
  serializable()
], ButtonColors.prototype, "fadeDuration", void 0);
__decorate33([
  serializable(RGBAColor)
], ButtonColors.prototype, "highlightedColor", void 0);
__decorate33([
  serializable(RGBAColor)
], ButtonColors.prototype, "normalColor", void 0);
__decorate33([
  serializable(RGBAColor)
], ButtonColors.prototype, "pressedColor", void 0);
__decorate33([
  serializable(RGBAColor)
], ButtonColors.prototype, "selectedColor", void 0);
var AnimationTriggers = class {
  constructor() {
    __publicField(this, "disabledTrigger");
    __publicField(this, "highlightedTrigger");
    __publicField(this, "normalTrigger");
    __publicField(this, "pressedTrigger");
    __publicField(this, "selectedTrigger");
  }
};
var Button = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "onClick", new EventList());
    __publicField(this, "_isHovered", 0);
    __publicField(this, "colors");
    __publicField(this, "transition");
    __publicField(this, "animationTriggers");
    __publicField(this, "animator");
    __publicField(this, "_interactable", true);
    __publicField(this, "_requestedAnimatorTrigger");
    __publicField(this, "_isInit", false);
    __publicField(this, "_image");
  }
  /**
   * Invokes the onClick event
   */
  click() {
    var _a2;
    (_a2 = this.onClick) == null ? void 0 : _a2.invoke();
  }
  onPointerEnter(evt) {
    var _a2, _b;
    const canSetCursor = evt.event.pointerType === "mouse" && evt.button === 0;
    if (canSetCursor)
      this._isHovered += 1;
    if (debug65)
      console.warn("Button Enter", canSetCursor, this._isHovered, (_a2 = this.animationTriggers) == null ? void 0 : _a2.highlightedTrigger, this.animator);
    if (!this.interactable)
      return;
    if (this.transition == Transition.Animation && this.animationTriggers && this.animator) {
      this.animator.setTrigger(this.animationTriggers.highlightedTrigger);
    } else if (this.transition === Transition.ColorTint && this.colors) {
      (_b = this._image) == null ? void 0 : _b.setState("hovered");
    }
    if (canSetCursor)
      this.context.input.setCursorPointer();
  }
  onPointerExit() {
    var _a2, _b;
    this._isHovered -= 1;
    if (this._isHovered < 0)
      this._isHovered = 0;
    if (debug65)
      console.log("Button Exit", this._isHovered, (_a2 = this.animationTriggers) == null ? void 0 : _a2.highlightedTrigger, this.animator);
    if (!this.interactable)
      return;
    if (this._isHovered > 0)
      return;
    this._isHovered = 0;
    if (this.transition == Transition.Animation && this.animationTriggers && this.animator) {
      this.animator.setTrigger(this.animationTriggers.normalTrigger);
    } else if (this.transition === Transition.ColorTint && this.colors) {
      (_b = this._image) == null ? void 0 : _b.setState("normal");
    }
    this.context.input.setCursorNormal();
  }
  onPointerDown(_) {
    var _a2, _b;
    if (debug65)
      console.log("Button Down", (_a2 = this.animationTriggers) == null ? void 0 : _a2.highlightedTrigger, this.animator);
    if (!this.interactable)
      return;
    if (this.transition == Transition.Animation && this.animationTriggers && this.animator) {
      this.animator.setTrigger(this.animationTriggers.pressedTrigger);
    } else if (this.transition === Transition.ColorTint && this.colors) {
      (_b = this._image) == null ? void 0 : _b.setState("pressed");
    }
  }
  onPointerUp(_) {
    var _a2, _b;
    if (debug65)
      console.warn("Button Up", (_a2 = this.animationTriggers) == null ? void 0 : _a2.highlightedTrigger, this.animator, this._isHovered);
    if (!this.interactable)
      return;
    if (this.transition == Transition.Animation && this.animationTriggers && this.animator) {
      this.animator.setTrigger(this._isHovered ? this.animationTriggers.highlightedTrigger : this.animationTriggers.normalTrigger);
    } else if (this.transition === Transition.ColorTint && this.colors) {
      (_b = this._image) == null ? void 0 : _b.setState(this._isHovered ? "hovered" : "normal");
    }
  }
  onPointerClick(args) {
    if (!this.interactable)
      return;
    if (args.button !== 0 && args.event.pointerType === PointerType.Mouse)
      return;
    if (debug65) {
      console.warn("Button Click", this.onClick);
      showBalloonMessage("CLICKED button " + this.name + " at " + this.context.time.frameCount);
    }
    if (this.onClick && this.onClick.listenerCount > 0) {
      this.onClick.invoke();
      args.use();
      if (debug65) {
        const pos = this.gameObject.worldPosition;
        pos.add(this.gameObject.worldUp.multiplyScalar(1 + Math.random() * 0.5));
        Gizmos.DrawLabel(pos, "CLICK:" + Date.now(), 0.1, 1 + Math.random() * 0.5);
      }
    }
  }
  // @serializable(Image)
  // image? : Image;
  set interactable(value) {
    this._interactable = value;
    if (this._image) {
      this._image.setInteractable(value);
      if (value)
        this._image.setState("normal");
      else
        this._image.setState("disabled");
    }
  }
  get interactable() {
    return this._interactable;
  }
  set_interactable(value) {
    this.interactable = value;
  }
  awake() {
    super.awake();
    if (debug65)
      console.log(this);
    this._isInit = false;
    this.init();
  }
  start() {
    var _a2;
    (_a2 = this._image) == null ? void 0 : _a2.setInteractable(this.interactable);
    if (!this.gameObject.getComponentInParent(Raycaster2)) {
      this.gameObject.addComponent(GraphicRaycaster);
    }
  }
  onEnable() {
    super.onEnable();
  }
  onDestroy() {
    if (this._isHovered)
      this.context.input.setCursorNormal();
  }
  *setAnimatorTriggerAtEndOfFrame(requestedTriggerId) {
    var _a2;
    this._requestedAnimatorTrigger = requestedTriggerId;
    yield;
    yield;
    if (this._requestedAnimatorTrigger == requestedTriggerId) {
      (_a2 = this.animator) == null ? void 0 : _a2.setTrigger(requestedTriggerId);
    }
  }
  init() {
    if (this._isInit)
      return;
    this._isInit = true;
    this._image = GameObject.getComponent(this.gameObject, Image2);
    if (this._image) {
      this.stateSetup(this._image);
      if (this.interactable)
        this._image.setState("normal");
      else
        this._image.setState("disabled");
    }
  }
  stateSetup(image) {
    var _a2, _b, _c, _d, _e;
    image.setInteractable(this.interactable);
    const normal = this.getFinalColor(image.color, (_a2 = this.colors) == null ? void 0 : _a2.normalColor);
    const normalState = {
      state: "normal",
      attributes: {
        backgroundColor: normal,
        backgroundOpacity: normal.alpha
      }
    };
    image.setupState(normalState);
    const hover = this.getFinalColor(image.color, (_b = this.colors) == null ? void 0 : _b.highlightedColor);
    const hoverState = {
      state: "hovered",
      attributes: {
        backgroundColor: hover,
        backgroundOpacity: hover.alpha
      }
    };
    image.setupState(hoverState);
    const pressed = this.getFinalColor(image.color, (_c = this.colors) == null ? void 0 : _c.pressedColor);
    const pressedState = {
      state: "pressed",
      attributes: {
        backgroundColor: pressed,
        backgroundOpacity: pressed.alpha
      }
    };
    image.setupState(pressedState);
    const selected = this.getFinalColor(image.color, (_d = this.colors) == null ? void 0 : _d.selectedColor);
    const selectedState = {
      state: "selected",
      attributes: {
        backgroundColor: selected,
        backgroundOpacity: selected.alpha
      }
    };
    image.setupState(selectedState);
    const disabled = this.getFinalColor(image.color, (_e = this.colors) == null ? void 0 : _e.disabledColor);
    const disabledState = {
      state: "disabled",
      attributes: {
        backgroundColor: disabled,
        // @marwie, this disabled alpha property doesn't seem to have the opacity requested in unity
        backgroundOpacity: disabled.alpha
      }
    };
    image.setupState(disabledState);
  }
  getFinalColor(col2, col22) {
    if (col22) {
      return col2.clone().multiply(col22).convertLinearToSRGB();
    }
    return col2.clone().convertLinearToSRGB();
  }
};
__decorate33([
  serializable(EventList)
], Button.prototype, "onClick", void 0);
__decorate33([
  serializable(ButtonColors)
], Button.prototype, "colors", void 0);
__decorate33([
  serializable()
], Button.prototype, "transition", void 0);
__decorate33([
  serializable(AnimationTriggers)
], Button.prototype, "animationTriggers", void 0);
__decorate33([
  serializable(Animator)
], Button.prototype, "animator", void 0);
__decorate33([
  serializable()
], Button.prototype, "interactable", null);

// node_modules/@needle-tools/engine/lib/engine-components/ui/Layout.js
var __decorate34 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug66 = getParam("debuguilayout");
var Padding = class {
  constructor() {
    __publicField(this, "left", 0);
    __publicField(this, "right", 0);
    __publicField(this, "top", 0);
    __publicField(this, "bottom", 0);
  }
  get vertical() {
    return this.top + this.bottom;
  }
  get horizontal() {
    return this.left + this.right;
  }
};
__decorate34([
  serializable()
], Padding.prototype, "left", void 0);
__decorate34([
  serializable()
], Padding.prototype, "right", void 0);
__decorate34([
  serializable()
], Padding.prototype, "top", void 0);
__decorate34([
  serializable()
], Padding.prototype, "bottom", void 0);
var TextAnchor;
(function(TextAnchor3) {
  TextAnchor3[TextAnchor3["UpperLeft"] = 0] = "UpperLeft";
  TextAnchor3[TextAnchor3["UpperCenter"] = 1] = "UpperCenter";
  TextAnchor3[TextAnchor3["UpperRight"] = 2] = "UpperRight";
  TextAnchor3[TextAnchor3["MiddleLeft"] = 3] = "MiddleLeft";
  TextAnchor3[TextAnchor3["MiddleCenter"] = 4] = "MiddleCenter";
  TextAnchor3[TextAnchor3["MiddleRight"] = 5] = "MiddleRight";
  TextAnchor3[TextAnchor3["LowerLeft"] = 6] = "LowerLeft";
  TextAnchor3[TextAnchor3["LowerCenter"] = 7] = "LowerCenter";
  TextAnchor3[TextAnchor3["LowerRight"] = 8] = "LowerRight";
  TextAnchor3[TextAnchor3["Custom"] = 9] = "Custom";
})(TextAnchor || (TextAnchor = {}));
var Axis;
(function(Axis2) {
  Axis2["Horizontal"] = "x";
  Axis2["Vertical"] = "y";
})(Axis || (Axis = {}));
var LayoutGroup = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "_rectTransform", null);
    __publicField(this, "_needsUpdate", false);
    // onBeforeRender(): void {
    //     this.updateLayout();
    // }
    __publicField(this, "childAlignment", TextAnchor.UpperLeft);
    __publicField(this, "reverseArrangement", false);
    __publicField(this, "spacing", 0);
    __publicField(this, "padding");
    __publicField(this, "minWidth", 0);
    __publicField(this, "minHeight", 0);
    __publicField(this, "flexibleHeight", 0);
    __publicField(this, "flexibleWidth", 0);
    __publicField(this, "preferredHeight", 0);
    __publicField(this, "preferredWidth", 0);
  }
  get rectTransform() {
    return this._rectTransform;
  }
  onParentRectTransformChanged(_comp) {
    this._needsUpdate = true;
  }
  get isDirty() {
    return this._needsUpdate;
  }
  get isLayoutGroup() {
    return true;
  }
  updateLayout() {
    if (!this._rectTransform)
      return;
    if (debug66)
      console.warn("Layout Update", this.context.time.frame, this.name);
    this._needsUpdate = false;
    this.onCalculateLayout(this._rectTransform);
  }
  start() {
    this._needsUpdate = true;
  }
  onEnable() {
    if (debug66)
      console.log(this.name, this);
    this._rectTransform = this.gameObject.getComponent(RectTransform);
    const canvas = this.gameObject.getComponentInParent(Canvas);
    if (canvas) {
      canvas.registerLayoutGroup(this);
    }
    this._needsUpdate = true;
  }
  onDisable() {
    const canvas = this.gameObject.getComponentInParent(Canvas);
    if (canvas) {
      canvas.unregisterLayoutGroup(this);
    }
  }
  // for animation:
  set m_Spacing(val) {
    if (val === this.spacing)
      return;
    this._needsUpdate = true;
    this.spacing = val;
  }
  get m_Spacing() {
    return this.spacing;
  }
};
__decorate34([
  serializable()
], LayoutGroup.prototype, "childAlignment", void 0);
__decorate34([
  serializable()
], LayoutGroup.prototype, "reverseArrangement", void 0);
__decorate34([
  serializable()
], LayoutGroup.prototype, "spacing", void 0);
__decorate34([
  serializable(Padding)
], LayoutGroup.prototype, "padding", void 0);
__decorate34([
  serializable()
], LayoutGroup.prototype, "minWidth", void 0);
__decorate34([
  serializable()
], LayoutGroup.prototype, "minHeight", void 0);
__decorate34([
  serializable()
], LayoutGroup.prototype, "flexibleHeight", void 0);
__decorate34([
  serializable()
], LayoutGroup.prototype, "flexibleWidth", void 0);
__decorate34([
  serializable()
], LayoutGroup.prototype, "preferredHeight", void 0);
__decorate34([
  serializable()
], LayoutGroup.prototype, "preferredWidth", void 0);
var HorizontalOrVerticalLayoutGroup = class extends LayoutGroup {
  constructor() {
    super(...arguments);
    __publicField(this, "childControlHeight", true);
    __publicField(this, "childControlWidth", true);
    __publicField(this, "childForceExpandHeight", false);
    __publicField(this, "childForceExpandWidth", false);
    __publicField(this, "childScaleHeight", false);
    __publicField(this, "childScaleWidth", false);
  }
  onCalculateLayout(rect) {
    var _a2;
    const axis = this.primaryAxis;
    const totalWidth = rect.width;
    let actualWidth = totalWidth;
    const totalHeight = rect.height;
    let actualHeight = totalHeight;
    actualWidth -= this.padding.horizontal;
    actualHeight -= this.padding.vertical;
    const paddingAxis = axis === Axis.Horizontal ? this.padding.horizontal : this.padding.vertical;
    const isHorizontal = axis === Axis.Horizontal;
    const isVertical = !isHorizontal;
    const otherAxis = isHorizontal ? "y" : "x";
    const controlSize = isHorizontal ? this.childControlWidth : this.childControlHeight;
    const controlSizeOtherAxis = isHorizontal ? this.childControlHeight : this.childControlWidth;
    const forceExpandSize = isHorizontal ? this.childForceExpandWidth : this.childForceExpandHeight;
    const forceExpandSizeOtherAxis = isHorizontal ? this.childForceExpandHeight : this.childForceExpandWidth;
    const actualExpandSize = isHorizontal ? actualHeight : actualWidth;
    const totalSpace = isHorizontal ? totalWidth : totalHeight;
    const alignmentOnAxis = 0.5 * (isHorizontal ? this.childAlignment % 3 : Math.floor(this.childAlignment / 3));
    let start = 0;
    if (isHorizontal) {
      start += this.padding.left;
    } else
      start += this.padding.top;
    let totalChildSize = 0;
    let actualRectTransformChildCount = 0;
    for (let i = 0; i < this.gameObject.children.length; i++) {
      const ch = this.gameObject.children[i];
      const rt = GameObject.getComponent(ch, RectTransform);
      if (rt == null ? void 0 : rt.activeAndEnabled) {
        actualRectTransformChildCount += 1;
        if (isHorizontal) {
          totalChildSize += rt.width;
        } else {
          totalChildSize += rt.height;
        }
      }
    }
    let sizePerChild = 0;
    const totalSpacing = this.spacing * (actualRectTransformChildCount - 1);
    if (forceExpandSize || controlSize) {
      let size = 0;
      if (isHorizontal) {
        size = actualWidth -= totalSpacing;
      } else {
        size = actualHeight -= totalSpacing;
      }
      if (actualRectTransformChildCount > 0)
        sizePerChild = size / actualRectTransformChildCount;
    }
    let leftOffset = 0;
    leftOffset += this.padding.left;
    leftOffset -= this.padding.right;
    if (alignmentOnAxis !== 0) {
      start = totalSpace - totalChildSize;
      start *= alignmentOnAxis;
      start -= totalSpacing * alignmentOnAxis;
      if (isHorizontal) {
        start -= this.padding.right * alignmentOnAxis;
        start += this.padding.left * (1 - alignmentOnAxis);
        if (start < this.padding.left) {
          start = this.padding.left;
        }
      } else {
        start -= this.padding.bottom * alignmentOnAxis;
        start += this.padding.top * (1 - alignmentOnAxis);
        if (start < this.padding.top) {
          start = this.padding.top;
        }
      }
    }
    let k = 1;
    for (let i = 0; i < this.gameObject.children.length; i++) {
      const ch = this.gameObject.children[i];
      const rt = GameObject.getComponent(ch, RectTransform);
      if (rt == null ? void 0 : rt.activeAndEnabled) {
        (_a2 = rt.pivot) == null ? void 0 : _a2.set(0.5, 0.5);
        rt.anchorMin.set(0, 1);
        rt.anchorMax.set(0, 1);
        const x2 = totalWidth * 0.5 + leftOffset * 0.5;
        if (rt.anchoredPosition.x !== x2)
          rt.anchoredPosition.x = x2;
        const y = totalHeight * -0.5;
        if (rt.anchoredPosition.y !== y)
          rt.anchoredPosition.y = y;
        if (forceExpandSizeOtherAxis && controlSizeOtherAxis && rt.sizeDelta[otherAxis] !== actualExpandSize) {
          rt.sizeDelta[otherAxis] = actualExpandSize;
        }
        if (forceExpandSize && controlSize && rt.sizeDelta[axis] !== sizePerChild) {
          rt.sizeDelta[axis] = sizePerChild;
        }
        const size = isHorizontal ? rt.width : rt.height;
        const halfSize = size * 0.5;
        start += halfSize;
        if (forceExpandSize) {
          const preferredStart = sizePerChild * k - sizePerChild * 0.5;
          if (preferredStart > start) {
            start = preferredStart - sizePerChild * 0.5 + size + this.padding.left;
            start -= halfSize;
          }
        }
        let value = start;
        if (axis === Axis.Vertical)
          value = -value;
        if (rt.anchoredPosition[axis] !== value) {
          rt.anchoredPosition[axis] = value;
        }
        start += halfSize;
        start += this.spacing;
        k += 1;
      }
    }
  }
};
__decorate34([
  serializable()
], HorizontalOrVerticalLayoutGroup.prototype, "childControlHeight", void 0);
__decorate34([
  serializable()
], HorizontalOrVerticalLayoutGroup.prototype, "childControlWidth", void 0);
__decorate34([
  serializable()
], HorizontalOrVerticalLayoutGroup.prototype, "childForceExpandHeight", void 0);
__decorate34([
  serializable()
], HorizontalOrVerticalLayoutGroup.prototype, "childForceExpandWidth", void 0);
__decorate34([
  serializable()
], HorizontalOrVerticalLayoutGroup.prototype, "childScaleHeight", void 0);
__decorate34([
  serializable()
], HorizontalOrVerticalLayoutGroup.prototype, "childScaleWidth", void 0);
var VerticalLayoutGroup = class extends HorizontalOrVerticalLayoutGroup {
  get primaryAxis() {
    return Axis.Vertical;
  }
};
var HorizontalLayoutGroup = class extends HorizontalOrVerticalLayoutGroup {
  get primaryAxis() {
    return Axis.Horizontal;
  }
};
var GridLayoutGroup = class extends LayoutGroup {
  onCalculateLayout() {
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/ui/Canvas.js
var __decorate35 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var RenderMode;
(function(RenderMode3) {
  RenderMode3[RenderMode3["ScreenSpaceOverlay"] = 0] = "ScreenSpaceOverlay";
  RenderMode3[RenderMode3["ScreenSpaceCamera"] = 1] = "ScreenSpaceCamera";
  RenderMode3[RenderMode3["WorldSpace"] = 2] = "WorldSpace";
  RenderMode3[RenderMode3["Undefined"] = -1] = "Undefined";
})(RenderMode || (RenderMode = {}));
var debugLayout2 = getParam("debuguilayout");
var Canvas = class extends UIRootComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "_renderOnTop");
    __publicField(this, "_depthWrite", false);
    __publicField(this, "_doubleSided", true);
    __publicField(this, "_castShadows", false);
    __publicField(this, "_receiveShadows", false);
    __publicField(this, "_renderMode", RenderMode.Undefined);
    __publicField(this, "_rootCanvas");
    __publicField(this, "_scaleFactor", 1);
    __publicField(this, "worldCamera");
    __publicField(this, "planeDistance", -1);
    __publicField(this, "_boundRenderSettingsChanged", this.onRenderSettingsChanged.bind(this));
    __publicField(this, "previousParent", null);
    __publicField(this, "_lastMatrixWorld", null);
    __publicField(this, "_rectTransforms", []);
    __publicField(this, "_layoutGroups", /* @__PURE__ */ new Map());
    __publicField(this, "_receivers", []);
    __publicField(this, "onBeforeRenderRoutine", () => {
      var _a2, _b, _c, _d;
      this.previousParent = this.gameObject.parent;
      if ((((_a2 = this.context.xr) == null ? void 0 : _a2.isVR) || ((_b = this.context.xr) == null ? void 0 : _b.isPassThrough)) && this.screenspace) {
        this.gameObject.visible = false;
        this.gameObject.removeFromParent();
        return;
      }
      if (this.renderOnTop || this.screenspace) {
        this.gameObject.removeFromParent();
      } else {
        this.onUpdateRenderMode();
        this.handleLayoutUpdates();
        (_c = this.shadowComponent) == null ? void 0 : _c.updateMatrixWorld(true);
        (_d = this.shadowComponent) == null ? void 0 : _d.updateWorldMatrix(true, true);
        this.invokeBeforeRenderEvents();
        EventSystem.ensureUpdateMeshUI(three_mesh_ui_module_exports, this.context);
      }
    });
    __publicField(this, "onAfterRenderRoutine", () => {
      var _a2, _b, _c, _d, _e;
      if ((((_a2 = this.context.xr) == null ? void 0 : _a2.isVR) || ((_b = this.context.xr) == null ? void 0 : _b.isPassThrough)) && this.screenspace) {
        (_c = this.previousParent) == null ? void 0 : _c.add(this.gameObject);
        return;
      }
      if ((this.screenspace || this.renderOnTop) && this.previousParent && this.context.mainCamera) {
        if (this.screenspace) {
          const camObj = this.context.mainCamera;
          camObj == null ? void 0 : camObj.add(this.gameObject);
        } else {
          this.previousParent.add(this.gameObject);
        }
        const prevAutoClearDepth = this.context.renderer.autoClear;
        const prevAutoClearColor = this.context.renderer.autoClearColor;
        this.context.renderer.autoClear = false;
        this.context.renderer.autoClearColor = false;
        this.context.renderer.clearDepth();
        this.onUpdateRenderMode(true);
        this.handleLayoutUpdates();
        (_d = this.shadowComponent) == null ? void 0 : _d.updateMatrixWorld(true);
        this.invokeBeforeRenderEvents();
        EventSystem.ensureUpdateMeshUI(three_mesh_ui_module_exports, this.context, true);
        this.context.renderer.render(this.gameObject, this.context.mainCamera);
        this.context.renderer.autoClear = prevAutoClearDepth;
        this.context.renderer.autoClearColor = prevAutoClearColor;
        this.previousParent.add(this.gameObject);
      }
      (_e = this._lastMatrixWorld) == null ? void 0 : _e.copy(this.gameObject.matrixWorld);
    });
    __publicField(this, "_updateRenderSettingsRoutine");
    __publicField(this, "_activeRenderMode", -1);
    __publicField(this, "_lastWidth", -1);
    __publicField(this, "_lastHeight", -1);
  }
  get isCanvas() {
    return true;
  }
  get screenspace() {
    return this.renderMode !== RenderMode.WorldSpace;
  }
  set renderOnTop(val) {
    if (val === this._renderOnTop) {
      return;
    }
    this._renderOnTop = val;
    this.onRenderSettingsChanged();
  }
  get renderOnTop() {
    if (this._renderOnTop !== void 0)
      return this._renderOnTop;
    if (this.screenspace) {
      if (this._renderMode === RenderMode.ScreenSpaceOverlay)
        return true;
    }
    return false;
  }
  set depthWrite(val) {
    if (this._depthWrite === val)
      return;
    this._depthWrite = val;
    this.onRenderSettingsChanged();
  }
  get depthWrite() {
    return this._depthWrite;
  }
  set doubleSided(val) {
    if (this._doubleSided === val)
      return;
    this._doubleSided = val;
    this.onRenderSettingsChanged();
  }
  get doubleSided() {
    return this._doubleSided;
  }
  set castShadows(val) {
    if (this._castShadows === val)
      return;
    this._castShadows = val;
    this.onRenderSettingsChanged();
  }
  get castShadows() {
    return this._castShadows;
  }
  set receiveShadows(val) {
    if (this._receiveShadows === val)
      return;
    this._receiveShadows = val;
    this.onRenderSettingsChanged();
  }
  get receiveShadows() {
    return this._receiveShadows;
  }
  get renderMode() {
    return this._renderMode;
  }
  set renderMode(val) {
    if (this._renderMode === val)
      return;
    this._renderMode = val;
    this.onRenderSettingsChanged();
  }
  set rootCanvas(val) {
    if (this._rootCanvas instanceof Canvas)
      return;
    this._rootCanvas = val;
  }
  get rootCanvas() {
    return this._rootCanvas;
  }
  get scaleFactor() {
    return this._scaleFactor;
  }
  set scaleFactor(val) {
    this._scaleFactor = val;
  }
  awake() {
    var _a2;
    this.shadowComponent = this.gameObject;
    this.previousParent = this.gameObject.parent;
    if (debugLayout2)
      console.log("Canvas.Awake()", ((_a2 = this.previousParent) == null ? void 0 : _a2.name) + "/" + this.gameObject.name);
    super.awake();
  }
  start() {
    this.onUpdateRenderMode();
  }
  onEnable() {
    super.onEnable();
    this._updateRenderSettingsRoutine = void 0;
    this._lastMatrixWorld = new Matrix4();
    this.onUpdateRenderMode();
    document.addEventListener("resize", this._boundRenderSettingsChanged);
    this.context.pre_render_callbacks.push(this.onBeforeRenderRoutine);
    this.context.post_render_callbacks.push(this.onAfterRenderRoutine);
  }
  onDisable() {
    super.onDisable();
    document.removeEventListener("resize", this._boundRenderSettingsChanged);
    const preRenderIndex = this.context.pre_render_callbacks.indexOf(this.onBeforeRenderRoutine);
    if (preRenderIndex !== -1) {
      this.context.pre_render_callbacks.splice(preRenderIndex, 1);
    }
    const postRenderIndex = this.context.post_render_callbacks.indexOf(this.onAfterRenderRoutine);
    if (postRenderIndex !== -1) {
      this.context.post_render_callbacks.splice(postRenderIndex, 1);
    }
  }
  registerTransform(rt) {
    this._rectTransforms.push(rt);
  }
  unregisterTransform(rt) {
    const index = this._rectTransforms.indexOf(rt);
    if (index !== -1) {
      this._rectTransforms.splice(index, 1);
    }
  }
  registerLayoutGroup(group) {
    const obj = group.gameObject;
    this._layoutGroups.set(obj, group);
  }
  unregisterLayoutGroup(group) {
    const obj = group.gameObject;
    this._layoutGroups.delete(obj);
  }
  registerEventReceiver(receiver) {
    this._receivers.push(receiver);
  }
  unregisterEventReceiver(receiver) {
    const index = this._receivers.indexOf(receiver);
    if (index !== -1) {
      this._receivers.splice(index, 1);
    }
  }
  async onEnterXR(args) {
    if (this.screenspace) {
      if (args.xr.isVR || args.xr.isPassThrough) {
        this.gameObject.visible = false;
      }
    } else {
      this.gameObject.visible = false;
      await delayForFrames(1).then(() => {
        this.gameObject.visible = true;
      });
    }
  }
  onLeaveXR(args) {
    if (this.screenspace) {
      if (args.xr.isVR || args.xr.isPassThrough) {
        this.gameObject.visible = true;
      }
    }
  }
  invokeBeforeRenderEvents() {
    var _a2;
    for (const receiver of this._receivers) {
      (_a2 = receiver.onBeforeCanvasRender) == null ? void 0 : _a2.call(receiver, this);
    }
  }
  handleLayoutUpdates() {
    if (this._lastMatrixWorld === null) {
      this._lastMatrixWorld = new Matrix4();
    }
    const matrixWorldChanged = !this._lastMatrixWorld.equals(this.gameObject.matrixWorld);
    if (debugLayout2 && matrixWorldChanged)
      console.log("Canvas Layout changed", this.context.time.frameCount, this.name);
    const didLog = false;
    for (const ch of this._rectTransforms) {
      if (matrixWorldChanged)
        ch.markDirty();
      let layout = this._layoutGroups.get(ch.gameObject);
      if (ch.isDirty && !layout) {
        layout = ch.gameObject.getComponentInParent(LayoutGroup);
      }
      if (ch.isDirty || (layout == null ? void 0 : layout.isDirty)) {
        if (debugLayout2 && !didLog) {
          console.log("CANVAS UPDATE ### " + ch.name + " ##################################### " + this.context.time.frame);
        }
        layout == null ? void 0 : layout.updateLayout();
        ch.updateTransform();
      }
    }
  }
  applyRenderSettings() {
    this.onRenderSettingsChanged();
  }
  onRenderSettingsChanged() {
    if (this._updateRenderSettingsRoutine)
      return;
    this._updateRenderSettingsRoutine = this.startCoroutine(this._updateRenderSettingsDelayed(), FrameEvent.OnBeforeRender);
  }
  *_updateRenderSettingsDelayed() {
    yield;
    this._updateRenderSettingsRoutine = void 0;
    if (this.shadowComponent) {
      this.onUpdateRenderMode();
      updateRenderSettings(this.shadowComponent, this);
      for (const ch of GameObject.getComponentsInChildren(this.gameObject, BaseUIComponent)) {
        updateRenderSettings(ch.shadowComponent, this);
      }
    }
  }
  onUpdateRenderMode(force = false) {
    if (!force) {
      if (this._renderMode === this._activeRenderMode && this._lastWidth === this.context.domWidth && this._lastHeight === this.context.domHeight) {
        return;
      }
    }
    this._activeRenderMode = this._renderMode;
    let camera = this.context.mainCameraComponent;
    let planeDistance = 10;
    if (camera && camera.nearClipPlane > 0 && camera.farClipPlane > 0) {
      planeDistance = Mathf.lerp(camera.nearClipPlane, camera.farClipPlane, 0.01);
    }
    if (this._renderMode === RenderMode.ScreenSpaceCamera) {
      if (this.worldCamera)
        camera = this.worldCamera;
      if (this.planeDistance > 0)
        planeDistance = this.planeDistance;
    }
    switch (this._renderMode) {
      case RenderMode.ScreenSpaceOverlay:
      case RenderMode.ScreenSpaceCamera:
        this._lastWidth = this.context.domWidth;
        this._lastHeight = this.context.domHeight;
        if (!camera)
          return;
        const plane = planeDistance + 0.01;
        this.gameObject.position.x = 0;
        this.gameObject.position.y = 0;
        this.gameObject.position.z = -plane;
        this.gameObject.quaternion.identity();
        const rect = this.gameObject.getComponent(RectTransform);
        let hasChanged = false;
        if (rect.sizeDelta.x !== this.context.domWidth) {
          hasChanged = true;
        }
        if (rect.sizeDelta.y !== this.context.domHeight) {
          hasChanged = true;
        }
        const vFOV = camera.fieldOfView * Math.PI / 180;
        const h = 2 * Math.tan(vFOV / 2) * Math.abs(plane);
        this.gameObject.scale.x = h / this.context.domHeight;
        this.gameObject.scale.y = h / this.context.domHeight;
        this.gameObject.scale.z = 0.01;
        if (hasChanged) {
          rect.sizeDelta.x = this.context.domWidth;
          rect.sizeDelta.y = this.context.domHeight;
          rect == null ? void 0 : rect.markDirty();
        }
        break;
      case RenderMode.WorldSpace:
        this._lastWidth = -1;
        this._lastHeight = -1;
        break;
    }
  }
};
__decorate35([
  serializable()
], Canvas.prototype, "renderOnTop", null);
__decorate35([
  serializable()
], Canvas.prototype, "depthWrite", null);
__decorate35([
  serializable()
], Canvas.prototype, "doubleSided", null);
__decorate35([
  serializable()
], Canvas.prototype, "castShadows", null);
__decorate35([
  serializable()
], Canvas.prototype, "receiveShadows", null);
__decorate35([
  serializable()
], Canvas.prototype, "renderMode", null);
__decorate35([
  serializable(Canvas)
], Canvas.prototype, "rootCanvas", null);
__decorate35([
  serializable()
], Canvas.prototype, "scaleFactor", null);
__decorate35([
  serializable(Camera2)
], Canvas.prototype, "worldCamera", void 0);
__decorate35([
  serializable()
], Canvas.prototype, "planeDistance", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/ui/CanvasGroup.js
var __decorate36 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var CanvasGroup = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "_alpha", 1);
    __publicField(this, "interactable", true);
    __publicField(this, "blocksRaycasts", true);
    __publicField(this, "_isDirty", false);
    __publicField(this, "_buffer", []);
  }
  get alpha() {
    return this._alpha;
  }
  set alpha(val) {
    if (val === this._alpha)
      return;
    this._alpha = val;
    this.markDirty();
  }
  get isCanvasGroup() {
    return true;
  }
  markDirty() {
    if (this._isDirty)
      return;
    this._isDirty = true;
    this.startCoroutine(this.applyChangesDelayed(), FrameEvent.OnBeforeRender);
  }
  *applyChangesDelayed() {
    this._isDirty = false;
    this.applyChangesNow();
  }
  applyChangesNow() {
    this._buffer.length = 0;
    for (const ch of GameObject.getComponentsInChildren(this.gameObject, BaseUIComponent, this._buffer)) {
      const hasAlphaFactor = ch;
      if (hasAlphaFactor.setAlphaFactor)
        hasAlphaFactor.setAlphaFactor(this._alpha);
    }
  }
};
__decorate36([
  serializable()
], CanvasGroup.prototype, "alpha", null);
__decorate36([
  serializable()
], CanvasGroup.prototype, "interactable", void 0);
__decorate36([
  serializable()
], CanvasGroup.prototype, "blocksRaycasts", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/export/usdz/extensions/behavior/BehaviourComponents.js
var __decorate37 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug67 = getParam("debugusdzbehaviours");
function ensureRaycaster(obj) {
  if (!obj)
    return;
  if (!obj.getComponentInParent(Raycaster2)) {
    if (isDevEnvironment())
      console.debug('Raycaster on "' + obj.name + '" was automatically added, because no raycaster was found in the parent hierarchy.');
    obj.addComponent(ObjectRaycaster);
  }
}
var ChangeTransformOnClick = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "object");
    __publicField(this, "target");
    __publicField(this, "duration", 1);
    __publicField(this, "relativeMotion", false);
    __publicField(this, "coroutine", null);
    __publicField(this, "targetPos", new Vector32());
    __publicField(this, "targetRot", new Quaternion());
    __publicField(this, "targetScale", new Vector32());
  }
  start() {
    ensureRaycaster(this.gameObject);
  }
  onPointerClick(args) {
    args.use();
    if (this.coroutine)
      this.stopCoroutine(this.coroutine);
    if (!this.relativeMotion)
      this.coroutine = this.startCoroutine(this.moveToTarget());
    else
      this.coroutine = this.startCoroutine(this.moveRelative());
  }
  *moveToTarget() {
    if (!this.target || !this.object)
      return;
    const thisPos = getWorldPosition(this.object).clone();
    const targetPos = getWorldPosition(this.target).clone();
    const thisRot = getWorldQuaternion(this.object).clone();
    const targetRot = getWorldQuaternion(this.target).clone();
    const thisScale = getWorldScale(this.object).clone();
    const targetScale = getWorldScale(this.target).clone();
    const dist = thisPos.distanceTo(targetPos);
    const rotDist = thisRot.angleTo(targetRot);
    const scaleDist = thisScale.distanceTo(targetScale);
    if (dist < 0.01 && rotDist < 0.01 && scaleDist < 0.01) {
      setWorldPosition(this.object, targetPos);
      setWorldQuaternion(this.object, targetRot);
      setWorldScale(this.object, targetScale);
      this.coroutine = null;
      return;
    }
    let t01 = 0;
    let eased = 0;
    while (t01 < 1) {
      t01 += this.context.time.deltaTime / this.duration;
      if (t01 > 1)
        t01 = 1;
      eased = t01 < 0.5 ? 4 * t01 * t01 * t01 : 1 - Math.pow(-2 * t01 + 2, 3) / 2;
      this.targetPos.lerpVectors(thisPos, targetPos, eased);
      this.targetRot.slerpQuaternions(thisRot, targetRot, eased);
      this.targetScale.lerpVectors(thisScale, targetScale, eased);
      setWorldPosition(this.object, this.targetPos);
      setWorldQuaternion(this.object, this.targetRot);
      setWorldScale(this.object, this.targetScale);
      yield;
    }
    this.coroutine = null;
  }
  *moveRelative() {
    if (!this.target || !this.object)
      return;
    const thisPos = this.object.position.clone();
    const thisRot = this.object.quaternion.clone();
    const thisScale = this.object.scale.clone();
    const posOffset = this.target.position.clone();
    const rotOffset = this.target.quaternion.clone();
    const scaleOffset = this.target.scale.clone();
    posOffset.applyQuaternion(this.object.quaternion);
    this.targetPos.copy(this.object.position).add(posOffset);
    this.targetRot.copy(this.object.quaternion).multiply(rotOffset);
    this.targetScale.copy(this.object.scale).multiply(scaleOffset);
    let t01 = 0;
    let eased = 0;
    while (t01 < 1) {
      t01 += this.context.time.deltaTime / this.duration;
      if (t01 > 1)
        t01 = 1;
      eased = t01 < 0.5 ? 4 * t01 * t01 * t01 : 1 - Math.pow(-2 * t01 + 2, 3) / 2;
      this.object.position.lerpVectors(thisPos, this.targetPos, eased);
      this.object.quaternion.slerpQuaternions(thisRot, this.targetRot, eased);
      this.object.scale.lerpVectors(thisScale, this.targetScale, eased);
      yield;
    }
    this.coroutine = null;
  }
  beforeCreateDocument(ext) {
    var _a2;
    if (this.target && this.object && this.gameObject) {
      const moveForward = new BehaviorModel("Move to " + ((_a2 = this.target) == null ? void 0 : _a2.name), TriggerBuilder.tapTrigger(this.gameObject), ActionBuilder.transformAction(this.object, this.target, this.duration, this.relativeMotion ? "relative" : "absolute"));
      ext.addBehavior(moveForward);
    }
  }
};
__decorate37([
  serializable(Object3D)
], ChangeTransformOnClick.prototype, "object", void 0);
__decorate37([
  serializable(Object3D)
], ChangeTransformOnClick.prototype, "target", void 0);
__decorate37([
  serializable()
], ChangeTransformOnClick.prototype, "duration", void 0);
__decorate37([
  serializable()
], ChangeTransformOnClick.prototype, "relativeMotion", void 0);
var _ChangeMaterialOnClick = class extends Component2 {
  constructor() {
    super(...arguments);
    /**
     * The material that will be switched to the variant material
     */
    __publicField(this, "materialToSwitch");
    /**
     * The material that will be switched to
     */
    __publicField(this, "variantMaterial");
    /**
     * The duration of the fade effect in seconds (USDZ/Quicklook only)
     * @default 0
     */
    __publicField(this, "fadeDuration", 0);
    __publicField(this, "_objectsWithThisMaterial", null);
    __publicField(this, "selfModel");
    __publicField(this, "targetModels");
  }
  start() {
    var _a2;
    this._objectsWithThisMaterial = this.objectsWithThisMaterial;
    ensureRaycaster(this.gameObject);
    if (isDevEnvironment() && this._objectsWithThisMaterial.length <= 0) {
      console.warn('ChangeMaterialOnClick: No objects found with material "' + ((_a2 = this.materialToSwitch) == null ? void 0 : _a2.name) + '"');
    }
  }
  onPointerEnter(_args) {
    this.context.input.setCursorPointer();
  }
  onPointerExit(_) {
    this.context.input.setCursorNormal();
  }
  onPointerClick(args) {
    args.use();
    if (!this.variantMaterial)
      return;
    for (let i = 0; i < this.objectsWithThisMaterial.length; i++) {
      const obj = this.objectsWithThisMaterial[i];
      obj.material = this.variantMaterial;
    }
  }
  /** Get all objects in the scene that have the assigned materialToSwitch */
  get objectsWithThisMaterial() {
    if (this._objectsWithThisMaterial != null)
      return this._objectsWithThisMaterial;
    this._objectsWithThisMaterial = [];
    if (this.variantMaterial && this.materialToSwitch) {
      this.context.scene.traverse((obj) => {
        if (obj instanceof Mesh) {
          if (Array.isArray(obj.material)) {
            for (const mat of obj.material) {
              if (mat === this.materialToSwitch) {
                this.objectsWithThisMaterial.push(obj);
                break;
              }
            }
          } else {
            if (obj.material === this.materialToSwitch) {
              this.objectsWithThisMaterial.push(obj);
            } else if (compareAssociation(obj.material, this.materialToSwitch)) {
              this.objectsWithThisMaterial.push(obj);
            }
          }
        }
      });
    }
    return this._objectsWithThisMaterial;
  }
  async beforeCreateDocument(_ext, _context) {
    this.targetModels = [];
    _ChangeMaterialOnClick._materialTriggersPerId = {};
    _ChangeMaterialOnClick.variantSwitchIndex = 0;
    if (this.materialToSwitch) {
      await NEEDLE_progressive.assignTextureLOD(this.materialToSwitch, 0);
    }
    if (this.variantMaterial) {
      await NEEDLE_progressive.assignTextureLOD(this.variantMaterial, 0);
    }
  }
  createBehaviours(_ext, model, _context) {
    const shouldExport = this.objectsWithThisMaterial.find((o) => o.uuid === model.uuid);
    if (shouldExport) {
      this.targetModels.push(model);
    }
    if (this.gameObject.uuid === model.uuid) {
      this.selfModel = model;
      if (this.materialToSwitch) {
        if (!_ChangeMaterialOnClick._materialTriggersPerId[this.materialToSwitch.uuid])
          _ChangeMaterialOnClick._materialTriggersPerId[this.materialToSwitch.uuid] = [];
        _ChangeMaterialOnClick._materialTriggersPerId[this.materialToSwitch.uuid].push(this);
      }
    }
  }
  afterCreateDocument(ext, _context) {
    if (!this.materialToSwitch)
      return;
    const handlers2 = _ChangeMaterialOnClick._materialTriggersPerId[this.materialToSwitch.uuid];
    if (handlers2) {
      const variants = {};
      for (const handler of handlers2) {
        const createdVariants = handler.createVariants();
        if (createdVariants && createdVariants.length > 0)
          variants[handler.selfModel.uuid] = createdVariants;
      }
      for (const handler of handlers2) {
        const otherVariants = [];
        for (const key in variants) {
          if (key !== handler.selfModel.uuid) {
            otherVariants.push(...variants[key]);
          }
        }
        handler.createAndAttachBehaviors(ext, variants[handler.selfModel.uuid], otherVariants);
      }
    }
    delete _ChangeMaterialOnClick._materialTriggersPerId[this.materialToSwitch.uuid];
  }
  createAndAttachBehaviors(ext, myVariants, otherVariants) {
    const start = [];
    const select = [];
    const fadeDuration = Math.max(0, this.fadeDuration);
    select.push(ActionBuilder.fadeAction([...this.targetModels, ...otherVariants], fadeDuration, false));
    start.push(ActionBuilder.fadeAction(myVariants, fadeDuration, false));
    select.push(ActionBuilder.fadeAction(myVariants, fadeDuration, true));
    ext.addBehavior(new BehaviorModel("Select_" + this.selfModel.name, TriggerBuilder.tapTrigger(this.selfModel), ActionBuilder.parallel(...select)));
    ext.addBehavior(new BehaviorModel("StartHidden_" + this.selfModel.name, TriggerBuilder.sceneStartTrigger(), ActionBuilder.parallel(...start)));
  }
  static getMaterialName(material) {
    return makeNameSafe(material.name || "Material") + "_" + material.id;
  }
  createVariants() {
    if (!this.variantMaterial)
      return null;
    const variantModels = [];
    for (const target of this.targetModels) {
      const variant = target.clone();
      variant.name += "_Variant_" + _ChangeMaterialOnClick.variantSwitchIndex++ + "_" + _ChangeMaterialOnClick.getMaterialName(this.variantMaterial);
      variant.displayName = variant.displayName + ": Variant with material " + this.variantMaterial.name;
      variant.material = this.variantMaterial;
      variant.geometry = target.geometry;
      variant.transform = target.transform;
      if (!target.parent || !target.parent.isEmpty()) {
        USDObject.createEmptyParent(target);
      }
      if (target.parent)
        target.parent.add(variant);
      variantModels.push(variant);
    }
    return variantModels;
  }
};
var ChangeMaterialOnClick = _ChangeMaterialOnClick;
__publicField(ChangeMaterialOnClick, "_materialTriggersPerId", {});
__publicField(ChangeMaterialOnClick, "variantSwitchIndex", 0);
__decorate37([
  serializable(Material)
], ChangeMaterialOnClick.prototype, "materialToSwitch", void 0);
__decorate37([
  serializable(Material)
], ChangeMaterialOnClick.prototype, "variantMaterial", void 0);
__decorate37([
  serializable()
], ChangeMaterialOnClick.prototype, "fadeDuration", void 0);
var _SetActiveOnClick = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "target");
    __publicField(this, "toggleOnClick", false);
    __publicField(this, "targetState", true);
    __publicField(this, "hideSelf", true);
    __publicField(this, "selfModel");
    __publicField(this, "selfModelClone");
    __publicField(this, "targetModel");
    __publicField(this, "toggleModel");
    __publicField(this, "stateBeforeCreatingDocument", false);
    __publicField(this, "targetStateBeforeCreatingDocument", false);
  }
  start() {
    ensureRaycaster(this.gameObject);
  }
  onPointerClick(args) {
    args.use();
    if (!this.toggleOnClick && this.hideSelf)
      this.gameObject.visible = false;
    if (this.target)
      this.target.visible = this.toggleOnClick ? !this.target.visible : this.targetState;
  }
  createBehaviours(_, model, _context) {
    if (model.uuid === this.gameObject.uuid) {
      this.selfModel = model;
      this.selfModelClone = model.clone();
    }
  }
  beforeCreateDocument() {
    if (!this.target)
      return;
    if (this.gameObject[_SetActiveOnClick.wasVisible] === void 0)
      this.gameObject[_SetActiveOnClick.wasVisible] = this.gameObject.activeSelf;
    if (this.target[_SetActiveOnClick.wasVisible] === void 0)
      this.target[_SetActiveOnClick.wasVisible] = this.target.activeSelf;
    this.stateBeforeCreatingDocument = this.gameObject[_SetActiveOnClick.wasVisible];
    this.targetStateBeforeCreatingDocument = this.target[_SetActiveOnClick.wasVisible];
    this.gameObject.visible = true;
    this.target.visible = true;
  }
  afterCreateDocument(ext, context) {
    if (!this.target)
      return;
    this.targetModel = context.document.findById(this.target.uuid);
    const originalModel = this.selfModel;
    if (this.selfModel && this.targetModel) {
      let selfModel = this.selfModel;
      let targetState = this.targetState;
      if (this.toggleOnClick) {
        targetState = !this.targetStateBeforeCreatingDocument;
        if (!this.selfModelClone.geometry) {
          if (!this.selfModel.parent || this.selfModel.parent.isEmpty())
            USDDocument.createEmptyParent(this.selfModel);
          this.toggleModel = this.selfModel.deepClone();
          this.toggleModel.name += "_toggle";
          this.selfModel.parent.add(this.toggleModel);
        } else {
          if (!this.gameObject[_SetActiveOnClick.toggleClone]) {
            const clone = this.selfModelClone.clone();
            clone.setMatrix(new Matrix4());
            clone.name += "_toggle" + _SetActiveOnClick.clonedToggleIndex++;
            originalModel.add(clone);
            this.gameObject[_SetActiveOnClick.toggleClone] = clone;
            console.warn("USDZExport: Toggle " + this.gameObject.name + " doesn't have geometry. It will be deep cloned and nested behaviours will likely not work.");
          }
          const clonedSelfModel = this.gameObject[_SetActiveOnClick.toggleClone];
          if (!this.gameObject[_SetActiveOnClick.reverseToggleClone]) {
            const clone = this.selfModelClone.clone();
            clone.setMatrix(new Matrix4());
            clone.name += "_toggleReverse" + _SetActiveOnClick.clonedToggleIndex++;
            originalModel.add(clone);
            this.gameObject[_SetActiveOnClick.reverseToggleClone] = clone;
          }
          this.toggleModel = this.gameObject[_SetActiveOnClick.reverseToggleClone];
          if (!this.toggleModel.geometry || !clonedSelfModel.geometry) {
            console.error("triggers without childs and without geometry won't work!", this, originalModel.geometry);
          }
          selfModel = clonedSelfModel;
          originalModel.geometry = null;
          originalModel.material = null;
        }
      }
      if (!this.toggleModel) {
        const sequence = [];
        if (this.hideSelf)
          sequence.push(ActionBuilder.fadeAction(selfModel, 0, false));
        sequence.push(ActionBuilder.fadeAction(this.targetModel, 0, targetState));
        ext.addBehavior(new BehaviorModel("Toggle_" + selfModel.name + "_toggleTo" + (targetState ? "On" : "Off"), TriggerBuilder.tapTrigger(selfModel), ActionBuilder.parallel(...sequence)));
      } else if (this.toggleOnClick) {
        const toggleSequence = [];
        toggleSequence.push(ActionBuilder.fadeAction(selfModel, 0, false));
        toggleSequence.push(ActionBuilder.fadeAction(this.toggleModel, 0, true));
        toggleSequence.push(ActionBuilder.fadeAction(this.targetModel, 0, targetState));
        ext.addBehavior(new BehaviorModel("Toggle_" + selfModel.name + "_toggleTo" + (targetState ? "On" : "Off"), TriggerBuilder.tapTrigger(selfModel), ActionBuilder.parallel(...toggleSequence)));
        const reverseSequence = [];
        reverseSequence.push(ActionBuilder.fadeAction(this.toggleModel, 0, false));
        reverseSequence.push(ActionBuilder.fadeAction(selfModel, 0, true));
        reverseSequence.push(ActionBuilder.fadeAction(this.targetModel, 0, !targetState));
        ext.addBehavior(new BehaviorModel("Toggle_" + selfModel.name + "_toggleTo" + (!targetState ? "On" : "Off"), TriggerBuilder.tapTrigger(this.toggleModel), ActionBuilder.parallel(...reverseSequence)));
      }
      const objectsToHide = new Array();
      if (!this.targetStateBeforeCreatingDocument)
        objectsToHide.push(this.targetModel);
      if (!this.stateBeforeCreatingDocument)
        objectsToHide.push(originalModel);
      if (this.toggleModel)
        objectsToHide.push(this.toggleModel);
      ext.addBehavior(new BehaviorModel("HideOnStart_" + this.gameObject.name, TriggerBuilder.sceneStartTrigger(), ActionBuilder.fadeAction(objectsToHide, 0, false)));
    }
  }
  afterSerialize(_ext, _context) {
    if (this.gameObject[_SetActiveOnClick.wasVisible] !== void 0) {
      this.gameObject.visible = this.gameObject[_SetActiveOnClick.wasVisible];
      delete this.gameObject[_SetActiveOnClick.wasVisible];
    }
    if (this.target && this.target[_SetActiveOnClick.wasVisible] !== void 0) {
      this.target.visible = this.target[_SetActiveOnClick.wasVisible];
      delete this.target[_SetActiveOnClick.wasVisible];
    }
    delete this.gameObject[_SetActiveOnClick.toggleClone];
    delete this.gameObject[_SetActiveOnClick.reverseToggleClone];
  }
};
var SetActiveOnClick = _SetActiveOnClick;
__publicField(SetActiveOnClick, "clonedToggleIndex", 0);
__publicField(SetActiveOnClick, "wasVisible", Symbol("usdz_SetActiveOnClick_wasVisible"));
__publicField(SetActiveOnClick, "toggleClone", Symbol("clone for toggling"));
__publicField(SetActiveOnClick, "reverseToggleClone", Symbol("clone for reverse toggling"));
__decorate37([
  serializable(Object3D)
], SetActiveOnClick.prototype, "target", void 0);
__decorate37([
  serializable()
], SetActiveOnClick.prototype, "toggleOnClick", void 0);
__decorate37([
  serializable()
], SetActiveOnClick.prototype, "targetState", void 0);
__decorate37([
  serializable()
], SetActiveOnClick.prototype, "hideSelf", void 0);
var HideOnStart = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "wasVisible", false);
  }
  start() {
    GameObject.setActive(this.gameObject, false);
  }
  createBehaviours(ext, model, _context) {
    if (model.uuid === this.gameObject.uuid) {
      if (!this.wasVisible) {
        ext.addBehavior(new BehaviorModel("HideOnStart_" + this.gameObject.name, TriggerBuilder.sceneStartTrigger(), ActionBuilder.fadeAction(model, 0, false)));
      }
    }
  }
  beforeCreateDocument() {
    this.wasVisible = GameObject.isActiveSelf(this.gameObject);
  }
};
var EmphasizeOnClick = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "target");
    __publicField(this, "duration", 0.5);
    __publicField(this, "motionType", "bounce");
  }
  beforeCreateDocument() {
  }
  createBehaviours(ext, model, _context) {
    if (!this.target)
      return;
    if (model.uuid === this.gameObject.uuid) {
      const emphasize = new BehaviorModel("emphasize " + this.name, TriggerBuilder.tapTrigger(this.gameObject), ActionBuilder.emphasize(this.target, this.duration, this.motionType, void 0, "basic"));
      ext.addBehavior(emphasize);
    }
  }
  afterCreateDocument(_ext, _context) {
  }
};
__decorate37([
  serializable()
], EmphasizeOnClick.prototype, "target", void 0);
__decorate37([
  serializable()
], EmphasizeOnClick.prototype, "duration", void 0);
__decorate37([
  serializable()
], EmphasizeOnClick.prototype, "motionType", void 0);
var PlayAudioOnClick = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "target");
    __publicField(this, "clip", "");
    __publicField(this, "toggleOnClick", false);
    // Not exposed, but used for implicit playback of PlayOnAwake audio sources
    __publicField(this, "trigger", "tap");
  }
  start() {
    ensureRaycaster(this.gameObject);
  }
  ensureAudioSource() {
    if (!this.target) {
      const newAudioSource = this.gameObject.addComponent(AudioSource);
      if (newAudioSource) {
        this.target = newAudioSource;
        newAudioSource.spatialBlend = 1;
        newAudioSource.volume = 1;
        newAudioSource.loop = false;
        newAudioSource.preload = true;
      }
    }
  }
  onPointerClick(args) {
    var _a2;
    args.use();
    if (!((_a2 = this.target) == null ? void 0 : _a2.clip) && !this.clip)
      return;
    this.ensureAudioSource();
    if (this.target) {
      if (this.target.isPlaying && this.toggleOnClick) {
        this.target.stop();
      } else {
        if (!this.toggleOnClick && this.target.isPlaying) {
          this.target.stop();
        }
        if (this.clip)
          this.target.play(this.clip);
        else
          this.target.play();
      }
    }
  }
  createBehaviours(ext, model, _context) {
    if (!this.target && !this.clip)
      return;
    if (model.uuid === this.gameObject.uuid) {
      const clipUrl = this.clip ? this.clip : this.target ? this.target.clip : void 0;
      if (!clipUrl)
        return;
      if (typeof clipUrl !== "string")
        return;
      const playbackTarget = this.target ? this.target.gameObject : this.gameObject;
      const clipName = AudioExtension.getName(clipUrl);
      const volume = this.target ? this.target.volume : 1;
      const auralMode = this.target && this.target.spatialBlend == 0 ? "nonSpatial" : "spatial";
      let anyChildHasGeometry = false;
      this.gameObject.traverse((c2) => {
        if (c2 instanceof Mesh && c2.visible)
          anyChildHasGeometry = true;
      });
      anyChildHasGeometry = true;
      const audioClip = ext.addAudioClip(clipUrl);
      let playAction = ActionBuilder.playAudioAction(playbackTarget, audioClip, "play", volume, auralMode);
      if (this.target && this.target.loop)
        playAction = ActionBuilder.sequence(playAction).makeLooping();
      const behaviorName = this.name ? "_" + this.name : "";
      if (anyChildHasGeometry && this.trigger === "tap") {
        if (this.toggleOnClick)
          playAction.multiplePerformOperation = "stop";
        const playClipOnTap = new BehaviorModel("playAudio" + behaviorName, TriggerBuilder.tapTrigger(model), playAction);
        ext.addBehavior(playClipOnTap);
      }
      if (this.target && this.target.playOnAwake && this.target.enabled) {
        if (anyChildHasGeometry && this.trigger === "tap") {
          console.warn("USDZExport: Audio sources that are played on tap can't also auto-play at scene start due to a QuickLook bug.");
        } else {
          const playClipOnStart = new BehaviorModel("playAudioOnStart" + behaviorName, TriggerBuilder.sceneStartTrigger(), playAction);
          ext.addBehavior(playClipOnStart);
        }
      }
    }
  }
};
__decorate37([
  serializable(AudioSource)
], PlayAudioOnClick.prototype, "target", void 0);
__decorate37([
  serializable(URL)
], PlayAudioOnClick.prototype, "clip", void 0);
__decorate37([
  serializable()
], PlayAudioOnClick.prototype, "toggleOnClick", void 0);
var _PlayAnimationOnClick = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "animator");
    __publicField(this, "stateName");
    // Not editable from the outside yet, but from code
    // we want to expose this once we have a nice drawer for "Triggers" (e.g. shows proximity distance)
    // and once we rename the component to "PlayAnimation" or "PlayAnimationOnTrigger"
    __publicField(this, "trigger", "tap");
    // "proximity"
    __publicField(this, "animation");
    __publicField(this, "selfModel");
    __publicField(this, "stateAnimationModel");
    __publicField(this, "animationSequence", new Array());
    __publicField(this, "animationLoopAfterSequence", new Array());
    __publicField(this, "randomOffsetNormalized", 0);
  }
  get target() {
    var _a2, _b;
    return ((_a2 = this.animator) == null ? void 0 : _a2.gameObject) || ((_b = this.animation) == null ? void 0 : _b.gameObject);
  }
  start() {
    ensureRaycaster(this.gameObject);
  }
  onPointerClick(args) {
    var _a2;
    args.use();
    if (!this.target)
      return;
    if (this.stateName) {
      (_a2 = this.animator) == null ? void 0 : _a2.play(this.stateName, 0, 0, 0.1);
    }
  }
  createBehaviours(_ext, model, _context) {
    if (model.uuid === this.gameObject.uuid)
      this.selfModel = model;
  }
  // Cleanup. TODO This is not the best way as it's called multiple times (once for each component).
  afterSerialize() {
    if (_PlayAnimationOnClick.rootsWithExclusivePlayback.size > 1) {
      const message = 'Multiple root objects targeted by more than one animation. To work around QuickLook bug FB13410767, animations will be set as "exclusive" and activating them will stop other animations being marked as exclusive.';
      if (isDevEnvironment())
        showBalloonWarning(message);
      console.warn(message, ..._PlayAnimationOnClick.rootsWithExclusivePlayback);
    }
    _PlayAnimationOnClick.animationActions = [];
    _PlayAnimationOnClick.rootsWithExclusivePlayback = /* @__PURE__ */ new Set();
  }
  afterCreateDocument(ext, context) {
    if (this.animationSequence === void 0 && this.animationLoopAfterSequence === void 0 || !this.stateAnimationModel)
      return;
    if (!this.target)
      return;
    const document2 = context.document;
    const animationExt = context.extensions.find((ext2) => ext2 instanceof AnimationExtension);
    if (!animationExt)
      return;
    const requiresExclusivePlayback = animationExt.getClipCount(this.target) > 1;
    if (requiresExclusivePlayback) {
      if (isDevEnvironment())
        console.warn("Setting exclusive playback for " + this.target.name + "@" + this.stateName + " because it has " + animationExt.getClipCount(this.target) + " animations. This works around QuickLook bug FB13410767.");
      _PlayAnimationOnClick.rootsWithExclusivePlayback.add(this.target);
    }
    const behaviorName = this.name ? this.name : "";
    document2.traverse((model) => {
      var _a2, _b;
      if (model.uuid === ((_a2 = this.target) == null ? void 0 : _a2.uuid)) {
        const sequence = _PlayAnimationOnClick.getActionForSequences(document2, model, this.animationSequence, this.animationLoopAfterSequence, this.randomOffsetNormalized);
        const playAnimationOnTap = new BehaviorModel(this.trigger + "_" + behaviorName + "_toPlayAnimation_" + this.stateName + "_on_" + ((_b = this.target) == null ? void 0 : _b.name), this.trigger == "tap" ? TriggerBuilder.tapTrigger(this.selfModel) : TriggerBuilder.sceneStartTrigger(), sequence);
        if (requiresExclusivePlayback)
          playAnimationOnTap.makeExclusive(true);
        ext.addBehavior(playAnimationOnTap);
      }
    });
  }
  static getActionForSequences(_document, model, animationSequence, animationLoopAfterSequence, randomOffsetNormalized) {
    const getOrCacheAction = (model2, anim) => {
      let action = _PlayAnimationOnClick.animationActions.find((a) => a.affectedObjects == model2 && a.start == anim.start && a.duration == anim.duration && a.animationSpeed == anim.speed);
      if (!action) {
        action = ActionBuilder.startAnimationAction(model2, anim);
        _PlayAnimationOnClick.animationActions.push(action);
      }
      return action;
    };
    const sequence = ActionBuilder.sequence();
    if (animationSequence && animationSequence.length > 0) {
      for (const anim of animationSequence) {
        sequence.addAction(getOrCacheAction(model, anim));
      }
    }
    if (animationLoopAfterSequence && animationLoopAfterSequence.length > 0) {
      const loopSequence = sequence.actions.length == 0 ? sequence : ActionBuilder.sequence();
      for (const anim of animationLoopAfterSequence) {
        loopSequence.addAction(getOrCacheAction(model, anim));
      }
      loopSequence.makeLooping();
      if (sequence !== loopSequence)
        sequence.addAction(loopSequence);
    }
    if (randomOffsetNormalized && randomOffsetNormalized > 0) {
      sequence.actions.unshift(ActionBuilder.waitAction(randomOffsetNormalized));
    }
    return sequence;
  }
  static getAndRegisterAnimationSequences(ext, target, stateName) {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    if (!target)
      return void 0;
    const animator = target.getComponent(Animator);
    const animation = target.getComponent(Animation);
    if (!animator && !animation)
      return void 0;
    if (animator && !stateName) {
      throw new Error("PlayAnimationOnClick: No stateName specified for animator " + animator.name + " on " + target.name);
    }
    let animationSequence = [];
    let animationLoopAfterSequence = [];
    if (animation) {
      const anim = ext.registerAnimation(target, animation.clip);
      if (anim) {
        if (animation.loop)
          animationLoopAfterSequence.push(anim);
        else
          animationSequence.push(anim);
      }
      let randomTimeOffset2 = 0;
      if (animation.minMaxOffsetNormalized) {
        const from = animation.minMaxOffsetNormalized.x;
        const to = animation.minMaxOffsetNormalized.y;
        randomTimeOffset2 = (((_a2 = animation.clip) == null ? void 0 : _a2.duration) || 1) * (from + Math.random() * (to - from));
      }
      return {
        animationSequence,
        animationLoopAfterSequence,
        randomTimeOffset: randomTimeOffset2
      };
    }
    const runtimeController = animator == null ? void 0 : animator.runtimeAnimatorController;
    let currentState = runtimeController == null ? void 0 : runtimeController.findState(stateName);
    let statesUntilLoop = [];
    let statesLooping = [];
    if (runtimeController && currentState) {
      const visitedStates = new Array();
      visitedStates.push(currentState);
      let foundLoop = false;
      while (visitedStates.length < 100) {
        if (!currentState || currentState === null || !currentState.transitions || currentState.transitions.length === 0) {
          if ((_b = currentState.motion) == null ? void 0 : _b.isLooping)
            foundLoop = true;
          break;
        }
        const transition = currentState.transitions.find((t2) => t2.conditions.length === 0);
        const nextState = transition ? runtimeController["getState"](transition.destinationState, 0) : null;
        if (nextState && visitedStates.includes(nextState)) {
          currentState = nextState;
          foundLoop = true;
          break;
        } else if (transition) {
          currentState = nextState;
          if (!currentState)
            break;
          visitedStates.push(currentState);
        } else {
          foundLoop = ((_c = currentState.motion) == null ? void 0 : _c.isLooping) ?? false;
          break;
        }
      }
      if (foundLoop && currentState) {
        const firstStateInLoop = visitedStates.indexOf(currentState);
        statesUntilLoop = visitedStates.slice(0, firstStateInLoop);
        statesLooping = visitedStates.slice(firstStateInLoop);
        if (debug67)
          console.log("found loop from " + stateName, "states until loop", statesUntilLoop, "states looping", statesLooping);
      } else {
        statesUntilLoop = visitedStates;
        statesLooping = [];
        if (debug67)
          console.log("found no loop from " + stateName, "states", statesUntilLoop);
      }
      if (!statesLooping.length) {
        const lastState = statesUntilLoop[statesUntilLoop.length - 1];
        const lastClip = (_d = lastState.motion) == null ? void 0 : _d.clip;
        if (lastClip) {
          let clipCopy;
          if (ext.holdClipMap.has(lastClip)) {
            clipCopy = ext.holdClipMap.get(lastClip);
          } else {
            const holdStateName = lastState.name + "_hold";
            clipCopy = lastClip.clone();
            clipCopy.duration = 1;
            clipCopy.name = holdStateName;
            const lastFrame = lastClip.duration;
            clipCopy.tracks = lastClip.tracks.map((t2) => {
              const trackCopy = t2.clone();
              trackCopy.times = new Float32Array([0, lastFrame]);
              const len = t2.values.length;
              const size = t2.getValueSize();
              ;
              const lastValue = t2.values.slice(len - size, len);
              trackCopy.values = new Float32Array(2 * size);
              trackCopy.values.set(lastValue, 0);
              trackCopy.values.set(lastValue, size);
              return trackCopy;
            });
            clipCopy.name = holdStateName;
            ext.holdClipMap.set(lastClip, clipCopy);
          }
          if (clipCopy) {
            const holdState = {
              name: clipCopy.name,
              motion: { clip: clipCopy, isLooping: false, name: clipCopy.name },
              speed: 1,
              transitions: [],
              behaviours: [],
              hash: lastState.hash + 1
            };
            statesLooping.push(holdState);
          }
        }
      }
    }
    if (statesUntilLoop.length === 1 && (!((_e = statesUntilLoop[0].motion) == null ? void 0 : _e.clip) || ((_g = (_f = statesUntilLoop[0].motion) == null ? void 0 : _f.clip.tracks) == null ? void 0 : _g.length) === 0)) {
      animationSequence = new Array();
      const anim = ext.registerAnimation(target, null);
      if (anim)
        animationSequence.push(anim);
      return void 0;
    }
    statesUntilLoop = statesUntilLoop.filter((s) => {
      var _a3, _b2, _c2;
      return ((_a3 = s.motion) == null ? void 0 : _a3.clip) && ((_c2 = (_b2 = s.motion) == null ? void 0 : _b2.clip.tracks) == null ? void 0 : _c2.length) > 0;
    });
    statesLooping = statesLooping.filter((s) => {
      var _a3, _b2, _c2;
      return ((_a3 = s.motion) == null ? void 0 : _a3.clip) && ((_c2 = (_b2 = s.motion) == null ? void 0 : _b2.clip.tracks) == null ? void 0 : _c2.length) > 0;
    });
    if (statesUntilLoop.length === 0 && statesLooping.length === 0) {
      console.warn("No clips found for state " + stateName + " on " + (animator == null ? void 0 : animator.name) + ", can't export animation data");
      return void 0;
    }
    const addStateToSequence = (state, sequence) => {
      if (!target)
        return;
      const anim = ext.registerAnimation(target, state.motion.clip ?? null);
      if (anim) {
        anim.speed = state.speed;
        sequence.push(anim);
      } else
        console.warn("Couldn't register animation for state " + state.name + " on " + (animator == null ? void 0 : animator.name));
    };
    if (statesUntilLoop.length > 0) {
      animationSequence = new Array();
      for (const state of statesUntilLoop) {
        addStateToSequence(state, animationSequence);
      }
    }
    if (statesLooping.length > 0) {
      animationLoopAfterSequence = new Array();
      for (const state of statesLooping) {
        addStateToSequence(state, animationLoopAfterSequence);
      }
    }
    let randomTimeOffset = 0;
    if (animator && runtimeController && animator.minMaxOffsetNormalized) {
      const from = animator.minMaxOffsetNormalized.x;
      const to = animator.minMaxOffsetNormalized.y;
      const firstState = statesUntilLoop.length ? statesUntilLoop[0] : statesLooping.length ? statesLooping[0] : null;
      randomTimeOffset = (((_h = firstState == null ? void 0 : firstState.motion.clip) == null ? void 0 : _h.duration) || 1) * (from + Math.random() * (to - from));
    }
    return {
      animationSequence,
      animationLoopAfterSequence,
      randomTimeOffset
    };
  }
  createAnimation(ext, model, _context) {
    if (!this.target || !this.animator && !this.animation)
      return;
    const result = _PlayAnimationOnClick.getAndRegisterAnimationSequences(ext, this.target, this.stateName);
    if (!result)
      return;
    this.animationSequence = result.animationSequence;
    this.animationLoopAfterSequence = result.animationLoopAfterSequence;
    this.randomOffsetNormalized = result.randomTimeOffset;
    this.stateAnimationModel = model;
  }
};
var PlayAnimationOnClick = _PlayAnimationOnClick;
__publicField(PlayAnimationOnClick, "animationActions", []);
__publicField(PlayAnimationOnClick, "rootsWithExclusivePlayback", /* @__PURE__ */ new Set());
__decorate37([
  serializable(Animator)
], PlayAnimationOnClick.prototype, "animator", void 0);
__decorate37([
  serializable()
], PlayAnimationOnClick.prototype, "stateName", void 0);
var PreliminaryAction = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "target");
  }
  getType() {
  }
  getDuration() {
  }
};
__decorate37([
  serializable(Object3D)
], PreliminaryAction.prototype, "target", void 0);
var PreliminaryTrigger = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "target");
  }
};
__decorate37([
  serializable(PreliminaryAction)
], PreliminaryTrigger.prototype, "target", void 0);
var VisibilityAction = class extends PreliminaryAction {
  constructor() {
    super(...arguments);
    //@type int
    __publicField(this, "type", VisibilityActionType.Hide);
    __publicField(this, "duration", 1);
  }
  getType() {
    switch (this.type) {
      case VisibilityActionType.Hide:
        return "hide";
      case VisibilityActionType.Show:
        return "show";
    }
  }
  getDuration() {
    return this.duration;
  }
};
__decorate37([
  serializable()
], VisibilityAction.prototype, "type", void 0);
__decorate37([
  serializable()
], VisibilityAction.prototype, "duration", void 0);
var TapGestureTrigger = class extends PreliminaryTrigger {
};
var VisibilityActionType;
(function(VisibilityActionType2) {
  VisibilityActionType2[VisibilityActionType2["Show"] = 0] = "Show";
  VisibilityActionType2[VisibilityActionType2["Hide"] = 1] = "Hide";
})(VisibilityActionType || (VisibilityActionType = {}));

// node_modules/@needle-tools/engine/lib/engine-components/CharacterController.js
var __decorate38 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug68 = getParam("debugcharactercontroller");
var CharacterController = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "center", new Vector32(0, 0, 0));
    __publicField(this, "radius", 0.5);
    __publicField(this, "height", 2);
    __publicField(this, "_rigidbody", null);
    __publicField(this, "_activeGroundCollisions");
    __publicField(this, "_contactVelocity", new Vector32());
  }
  get rigidbody() {
    if (this._rigidbody)
      return this._rigidbody;
    this._rigidbody = this.gameObject.getComponent(Rigidbody);
    if (!this._rigidbody)
      this._rigidbody = this.gameObject.addComponent(Rigidbody);
    return this.rigidbody;
  }
  awake() {
    this._activeGroundCollisions = /* @__PURE__ */ new Set();
  }
  onEnable() {
    const rb = this.rigidbody;
    let collider = this.gameObject.getComponent(CapsuleCollider);
    if (!collider)
      collider = this.gameObject.addComponent(CapsuleCollider);
    collider.center.copy(this.center);
    collider.radius = this.radius;
    collider.height = this.height;
    const wForward = new Vector32(0, 0, 1);
    const wRight = new Vector32(1, 0, 0);
    const wUp = new Vector32(0, 1, 0);
    const fwd = this.gameObject.getWorldDirection(new Vector32());
    fwd.y = 0;
    const sign = wRight.dot(fwd) < 0 ? -1 : 1;
    const angleY = wForward.angleTo(fwd) * sign;
    this.gameObject.setRotationFromAxisAngle(wUp, angleY);
    rb.lockRotationX = true;
    rb.lockRotationY = true;
    rb.lockRotationZ = true;
  }
  move(vec2) {
    this.gameObject.position.add(vec2);
  }
  onCollisionEnter(col2) {
    if (col2.contacts.length == 0 || col2.contacts.some((contact) => contact.normal.y > 0.2)) {
      this._activeGroundCollisions.add(col2);
      if (debug68) {
        console.log(`Collision(${this._activeGroundCollisions.size}): ${col2.contacts.map((c2) => c2.normal.y.toFixed(2)).join(", ")} - ${this.isGrounded}`);
      }
    }
  }
  onCollisionExit(col2) {
    this._activeGroundCollisions.delete(col2);
    if (debug68) {
      console.log(`Collision(${this._activeGroundCollisions.size}) - ${this.isGrounded}`);
    }
  }
  get isGrounded() {
    return this._activeGroundCollisions.size > 0;
  }
  get contactVelocity() {
    var _a2;
    this._contactVelocity.set(0, 0, 0);
    for (const col2 of this._activeGroundCollisions) {
      const vel = (_a2 = this.context.physics.engine) == null ? void 0 : _a2.getLinearVelocity(col2.collider);
      if (!vel)
        continue;
      this._contactVelocity.x += vel.x;
      this._contactVelocity.y += vel.y;
      this._contactVelocity.z += vel.z;
    }
    return this._contactVelocity;
  }
};
__decorate38([
  serializable(Vector32)
], CharacterController.prototype, "center", void 0);
__decorate38([
  serializable()
], CharacterController.prototype, "radius", void 0);
__decorate38([
  serializable()
], CharacterController.prototype, "height", void 0);
var CharacterControllerInput = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "controller");
    __publicField(this, "movementSpeed", 2);
    __publicField(this, "rotationSpeed", 2);
    __publicField(this, "jumpForce", 1);
    __publicField(this, "doubleJumpForce", 2);
    __publicField(this, "animator");
    __publicField(this, "lookForward", true);
    __publicField(this, "lookInput", new Vector2(0, 0));
    __publicField(this, "moveInput", new Vector2(0, 0));
    __publicField(this, "jumpInput", false);
    __publicField(this, "_currentSpeed", new Vector32(0, 0, 0));
    __publicField(this, "_currentAngularSpeed", new Vector32(0, 0, 0));
    __publicField(this, "_temp", new Vector32(0, 0, 0));
    __publicField(this, "_jumpCount", 0);
    __publicField(this, "_currentRotation");
    __publicField(this, "_raycastOptions", new RaycastOptions());
  }
  awake() {
    this._currentRotation = new Quaternion();
  }
  update() {
    const input = this.context.input;
    if (input.isKeyPressed("KeyW"))
      this.moveInput.y += 1;
    else if (input.isKeyPressed("KeyS"))
      this.moveInput.y -= 1;
    if (input.isKeyPressed("KeyD"))
      this.lookInput.x += 1;
    else if (input.isKeyPressed("KeyA"))
      this.lookInput.x -= 1;
    this.jumpInput || (this.jumpInput = input.isKeyDown("Space"));
  }
  move(move) {
    this.moveInput.add(move);
  }
  look(look) {
    this.lookInput.add(look);
  }
  jump() {
    this.jumpInput = true;
  }
  onBeforeRender() {
    this.handleInput(this.moveInput, this.lookInput, this.jumpInput);
    this.lookInput.set(0, 0);
    this.moveInput.set(0, 0);
    this.jumpInput = false;
  }
  handleInput(move, look, jump) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
    if ((_a2 = this.controller) == null ? void 0 : _a2.isGrounded) {
      this._jumpCount = 0;
      if (this.doubleJumpForce > 0)
        (_b = this.animator) == null ? void 0 : _b.setBool("doubleJump", false);
    }
    this._currentSpeed.z += move.y * this.movementSpeed * this.context.time.deltaTime;
    (_c = this.animator) == null ? void 0 : _c.setBool("running", move.length() > 0.01);
    (_e = this.animator) == null ? void 0 : _e.setBool("jumping", ((_d = this.controller) == null ? void 0 : _d.isGrounded) === true && jump);
    this._temp.copy(this._currentSpeed);
    this._temp.applyQuaternion(this.gameObject.quaternion);
    if (this.controller)
      this.controller.move(this._temp);
    else
      this.gameObject.position.add(this._temp);
    this._currentAngularSpeed.y += Mathf.toRadians(-look.x * this.rotationSpeed) * this.context.time.deltaTime;
    if (this.lookForward && Math.abs(this._currentAngularSpeed.y) < 0.01) {
      const forwardVector = this.context.mainCameraComponent.forward;
      forwardVector.y = 0;
      forwardVector.normalize();
      this._currentRotation.setFromUnitVectors(new Vector32(0, 0, 1), forwardVector);
      this.gameObject.quaternion.slerp(this._currentRotation, this.context.time.deltaTime * 10);
    }
    this.gameObject.rotateY(this._currentAngularSpeed.y);
    this._currentSpeed.multiplyScalar(1 - this.context.time.deltaTime * 10);
    this._currentAngularSpeed.y *= 1 - this.context.time.deltaTime * 10;
    if (this.controller && jump && this.jumpForce > 0) {
      let canJump = (_f = this.controller) == null ? void 0 : _f.isGrounded;
      if (this.doubleJumpForce > 0 && !((_g = this.controller) == null ? void 0 : _g.isGrounded) && this._jumpCount === 1) {
        canJump = true;
        (_h = this.animator) == null ? void 0 : _h.setBool("doubleJump", true);
      }
      if (canJump) {
        this._jumpCount += 1;
        const rb = this.controller.rigidbody;
        const factor = this._jumpCount === 2 ? this.doubleJumpForce : this.jumpForce;
        rb.applyImpulse(new Vector32(0, 1, 0).multiplyScalar(factor));
      }
    }
    if (this.controller) {
      const verticalSpeed = (_i = this.controller) == null ? void 0 : _i.rigidbody.getVelocity().y;
      if (verticalSpeed < -1) {
        if (!this._raycastOptions.ray)
          this._raycastOptions.ray = new Ray();
        this._raycastOptions.ray.origin.copy(getWorldPosition(this.gameObject));
        this._raycastOptions.ray.direction.set(0, -1, 0);
        const currentLayer = this.layer;
        this.gameObject.layers.disableAll();
        this.gameObject.layers.set(2);
        const hits = this.context.physics.raycast(this._raycastOptions);
        this.gameObject.layers.set(currentLayer);
        if (hits.length && hits[0].distance > 2 || verticalSpeed < -10) {
          (_j = this.animator) == null ? void 0 : _j.setBool("falling", true);
        }
      } else
        (_k = this.animator) == null ? void 0 : _k.setBool("falling", false);
    }
  }
};
__decorate38([
  serializable(CharacterController)
], CharacterControllerInput.prototype, "controller", void 0);
__decorate38([
  serializable()
], CharacterControllerInput.prototype, "movementSpeed", void 0);
__decorate38([
  serializable()
], CharacterControllerInput.prototype, "rotationSpeed", void 0);
__decorate38([
  serializable()
], CharacterControllerInput.prototype, "jumpForce", void 0);
__decorate38([
  serializable()
], CharacterControllerInput.prototype, "doubleJumpForce", void 0);
__decorate38([
  serializable(Animator)
], CharacterControllerInput.prototype, "animator", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/postprocessing/Effects/ChromaticAberration.js
var __decorate39 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var ChromaticAberration = class extends PostProcessingEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "intensity", new VolumeParameter(0));
  }
  get typeName() {
    return "ChromaticAberration";
  }
  onCreateEffect() {
    const chromatic = new ChromaticAberrationEffect();
    chromatic.offset = new Vector2(0, 0);
    chromatic.radialModulation = true;
    chromatic.modulationOffset = 0.15;
    this.intensity.valueProcessor = (v4) => v4 * 0.02;
    this.intensity.onValueChanged = (v4) => {
      chromatic.offset.x = -v4;
      chromatic.offset.y = v4;
    };
    return chromatic;
  }
};
__decorate39([
  serializable(VolumeParameter)
], ChromaticAberration.prototype, "intensity", void 0);
registerCustomEffectType("ChromaticAberration", ChromaticAberration);

// node_modules/@needle-tools/engine/lib/engine-components/postprocessing/Effects/Tonemapping.js
var __decorate40 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug69 = getParam("debugpost");
var NEToneMappingMode;
(function(NEToneMappingMode2) {
  NEToneMappingMode2[NEToneMappingMode2["None"] = 0] = "None";
  NEToneMappingMode2[NEToneMappingMode2["Neutral"] = 1] = "Neutral";
  NEToneMappingMode2[NEToneMappingMode2["ACES"] = 2] = "ACES";
  NEToneMappingMode2[NEToneMappingMode2["AgX"] = 3] = "AgX";
  NEToneMappingMode2[NEToneMappingMode2["KhronosNeutral"] = 4] = "KhronosNeutral";
})(NEToneMappingMode || (NEToneMappingMode = {}));
function toThreeToneMapping(mode) {
  switch (mode) {
    case NEToneMappingMode.None:
      return LinearToneMapping;
    case NEToneMappingMode.Neutral:
      return ReinhardToneMapping;
    case NEToneMappingMode.ACES:
      return ACESFilmicToneMapping;
    case NEToneMappingMode.AgX:
      return AgXToneMapping;
    case NEToneMappingMode.KhronosNeutral:
      return NeutralToneMapping;
    default:
      return NeutralToneMapping;
  }
}
function threeToNeToneMapping(mode) {
  switch (mode) {
    case LinearToneMapping:
      return NEToneMappingMode.None;
    case ACESFilmicToneMapping:
      return NEToneMappingMode.ACES;
    case AgXToneMapping:
      return NEToneMappingMode.AgX;
    case NeutralToneMapping:
      return NEToneMappingMode.Neutral;
    case ReinhardToneMapping:
      return NEToneMappingMode.Neutral;
    default:
      return NEToneMappingMode.None;
  }
}
function threeToneMappingToEffectMode(mode) {
  switch (mode) {
    case LinearToneMapping:
      return ToneMappingMode.LINEAR;
    case ACESFilmicToneMapping:
      return ToneMappingMode.ACES_FILMIC;
    case AgXToneMapping:
      return ToneMappingMode.AGX;
    case NeutralToneMapping:
      return ToneMappingMode.NEUTRAL;
    case ReinhardToneMapping:
      return ToneMappingMode.REINHARD;
    default:
      return ToneMappingMode.LINEAR;
  }
}
var ToneMappingEffect2 = class extends PostProcessingEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "mode", new VolumeParameter(void 0));
    __publicField(this, "exposure", new VolumeParameter(1));
  }
  get typeName() {
    return "ToneMapping";
  }
  /** Set the tonemapping mode to e.g. "agx" */
  setMode(mode) {
    const enumValue = NEToneMappingMode[mode];
    if (enumValue === void 0) {
      console.error("Invalid ToneMapping mode", mode);
      return this;
    }
    this.mode.value = enumValue;
    return this;
  }
  get isToneMapping() {
    return true;
  }
  onEffectEnabled() {
    const ppmanager = findPostProcessingManager(this);
    if (!ppmanager)
      return;
    super.onEffectEnabled(ppmanager);
  }
  onCreateEffect() {
    if (this.postprocessingContext) {
      for (const other of this.postprocessingContext.components) {
        if (other === this)
          break;
        if (other != this && other instanceof ToneMappingEffect2) {
          console.warn("Multiple tonemapping effects found in the same postprocessing stack: Please check your scene setup.", { activeEffect: other, ignoredEffect: this });
          return void 0;
        }
      }
    }
    if (this.mode.isInitialized == false) {
      const init = threeToNeToneMapping(this.context.renderer.toneMapping);
      this.mode.initialize(init);
    }
    const threeMode = toThreeToneMapping(this.mode.value);
    const tonemapping = new ToneMappingEffect({
      mode: threeToneMappingToEffectMode(threeMode)
    });
    this.mode.onValueChanged = (newValue) => {
      const threeMode2 = toThreeToneMapping(newValue);
      tonemapping.mode = threeToneMappingToEffectMode(threeMode2);
      if (debug69)
        console.log("ToneMapping mode changed to", NEToneMappingMode[newValue], threeMode2, tonemapping.mode);
    };
    if (debug69)
      console.log("Use ToneMapping", NEToneMappingMode[this.mode.value], threeMode, tonemapping.mode, "renderer.tonemapping: " + this.context.renderer.toneMapping);
    this.exposure.onValueChanged = (newValue) => {
      this.context.renderer.toneMappingExposure = newValue;
    };
    return tonemapping;
  }
  onBeforeRender() {
    if (this.mode.overrideState)
      this.context.renderer.toneMapping = toThreeToneMapping(this.mode.value);
    if (this.exposure.overrideState)
      this.context.renderer.toneMappingExposure = this.exposure.value;
  }
};
__decorate40([
  serializable(VolumeParameter)
], ToneMappingEffect2.prototype, "mode", void 0);
__decorate40([
  serializable(VolumeParameter)
], ToneMappingEffect2.prototype, "exposure", void 0);
registerCustomEffectType("Tonemapping", ToneMappingEffect2);

// node_modules/@needle-tools/engine/lib/engine-components/postprocessing/Effects/ColorAdjustments.js
var __decorate41 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var ColorAdjustments = class extends PostProcessingEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "postExposure", new VolumeParameter(0));
    __publicField(this, "contrast", new VolumeParameter(0));
    __publicField(this, "hueShift", new VolumeParameter(0));
    __publicField(this, "saturation", new VolumeParameter(0));
  }
  get typeName() {
    return "ColorAdjustments";
  }
  init() {
    this.postExposure.valueProcessor = (v4) => {
      v4 = Math.pow(2, v4);
      return v4;
    };
    this.contrast.valueProcessor = (v4) => {
      let divisor = 1;
      if (v4 > 0)
        divisor = 200;
      else if (v4 < 0)
        divisor = 100;
      const val = v4 / divisor;
      return val;
    };
    this.contrast.defaultValue = 0;
    this.hueShift.valueProcessor = (v4) => Math.PI * v4 / 180;
    this.hueShift.defaultValue = 0;
    this.saturation.valueProcessor = (v4) => {
      if (v4 < 0)
        return v4 / 100;
      const sat = v4 / (100 * Math.PI);
      return sat;
    };
    this.saturation.defaultValue = 0;
  }
  onCreateEffect() {
    var _a2, _b;
    const effects = [];
    if (this.context.renderer.toneMapping !== NoToneMapping && this.postExposure.overrideState)
      this.context.renderer.toneMapping = NoToneMapping;
    let tonemappingEffect = (_a2 = this.postprocessingContext) == null ? void 0 : _a2.components.find((c2) => c2 instanceof ToneMappingEffect2);
    if (!tonemappingEffect) {
      tonemappingEffect = new ToneMappingEffect2();
      (_b = this.postprocessingContext) == null ? void 0 : _b.components.push(tonemappingEffect);
    }
    this.postExposure.onValueChanged = (v4) => {
      if (this.postExposure.overrideState) {
        tonemappingEffect.exposure.value = v4;
      }
    };
    const brightnesscontrast = new BrightnessContrastEffect();
    this.contrast.onValueChanged = (v4) => brightnesscontrast.contrast = v4;
    const hueSaturationEffect = new HueSaturationEffect();
    effects.push(brightnesscontrast);
    effects.push(hueSaturationEffect);
    this.hueShift.onValueChanged = (v4) => hueSaturationEffect.hue = v4;
    this.saturation.onValueChanged = (v4) => hueSaturationEffect.saturation = v4;
    return effects;
  }
};
__decorate41([
  serializable(VolumeParameter)
], ColorAdjustments.prototype, "postExposure", void 0);
__decorate41([
  serializable(VolumeParameter)
], ColorAdjustments.prototype, "contrast", void 0);
__decorate41([
  serializable(VolumeParameter)
], ColorAdjustments.prototype, "hueShift", void 0);
__decorate41([
  serializable(VolumeParameter)
], ColorAdjustments.prototype, "saturation", void 0);
registerCustomEffectType("ColorAdjustments", ColorAdjustments);

// node_modules/simplex-noise/dist/esm/simplex-noise.js
var SQRT3 = Math.sqrt(3);
var SQRT5 = Math.sqrt(5);
var F2 = 0.5 * (SQRT3 - 1);
var G2 = (3 - SQRT3) / 6;
var F3 = 1 / 3;
var G3 = 1 / 6;
var F4 = (SQRT5 - 1) / 4;
var G4 = (5 - SQRT5) / 20;
var fastFloor = (x2) => Math.floor(x2) | 0;
var grad2 = new Float64Array([
  1,
  1,
  -1,
  1,
  1,
  -1,
  -1,
  -1,
  1,
  0,
  -1,
  0,
  1,
  0,
  -1,
  0,
  0,
  1,
  0,
  -1,
  0,
  1,
  0,
  -1
]);
var grad3 = new Float64Array([
  1,
  1,
  0,
  -1,
  1,
  0,
  1,
  -1,
  0,
  -1,
  -1,
  0,
  1,
  0,
  1,
  -1,
  0,
  1,
  1,
  0,
  -1,
  -1,
  0,
  -1,
  0,
  1,
  1,
  0,
  -1,
  1,
  0,
  1,
  -1,
  0,
  -1,
  -1
]);
var grad4 = new Float64Array([
  0,
  1,
  1,
  1,
  0,
  1,
  1,
  -1,
  0,
  1,
  -1,
  1,
  0,
  1,
  -1,
  -1,
  0,
  -1,
  1,
  1,
  0,
  -1,
  1,
  -1,
  0,
  -1,
  -1,
  1,
  0,
  -1,
  -1,
  -1,
  1,
  0,
  1,
  1,
  1,
  0,
  1,
  -1,
  1,
  0,
  -1,
  1,
  1,
  0,
  -1,
  -1,
  -1,
  0,
  1,
  1,
  -1,
  0,
  1,
  -1,
  -1,
  0,
  -1,
  1,
  -1,
  0,
  -1,
  -1,
  1,
  1,
  0,
  1,
  1,
  1,
  0,
  -1,
  1,
  -1,
  0,
  1,
  1,
  -1,
  0,
  -1,
  -1,
  1,
  0,
  1,
  -1,
  1,
  0,
  -1,
  -1,
  -1,
  0,
  1,
  -1,
  -1,
  0,
  -1,
  1,
  1,
  1,
  0,
  1,
  1,
  -1,
  0,
  1,
  -1,
  1,
  0,
  1,
  -1,
  -1,
  0,
  -1,
  1,
  1,
  0,
  -1,
  1,
  -1,
  0,
  -1,
  -1,
  1,
  0,
  -1,
  -1,
  -1,
  0
]);
function createNoise4D(random = Math.random) {
  const perm = buildPermutationTable(random);
  const permGrad4x = new Float64Array(perm).map((v4) => grad4[v4 % 32 * 4]);
  const permGrad4y = new Float64Array(perm).map((v4) => grad4[v4 % 32 * 4 + 1]);
  const permGrad4z = new Float64Array(perm).map((v4) => grad4[v4 % 32 * 4 + 2]);
  const permGrad4w = new Float64Array(perm).map((v4) => grad4[v4 % 32 * 4 + 3]);
  return function noise4D(x2, y, z, w) {
    let n0, n1, n2, n3, n4;
    const s = (x2 + y + z + w) * F4;
    const i = fastFloor(x2 + s);
    const j = fastFloor(y + s);
    const k = fastFloor(z + s);
    const l = fastFloor(w + s);
    const t2 = (i + j + k + l) * G4;
    const X0 = i - t2;
    const Y0 = j - t2;
    const Z0 = k - t2;
    const W0 = l - t2;
    const x0 = x2 - X0;
    const y0 = y - Y0;
    const z0 = z - Z0;
    const w0 = w - W0;
    let rankx = 0;
    let ranky = 0;
    let rankz = 0;
    let rankw = 0;
    if (x0 > y0)
      rankx++;
    else
      ranky++;
    if (x0 > z0)
      rankx++;
    else
      rankz++;
    if (x0 > w0)
      rankx++;
    else
      rankw++;
    if (y0 > z0)
      ranky++;
    else
      rankz++;
    if (y0 > w0)
      ranky++;
    else
      rankw++;
    if (z0 > w0)
      rankz++;
    else
      rankw++;
    const i1 = rankx >= 3 ? 1 : 0;
    const j1 = ranky >= 3 ? 1 : 0;
    const k1 = rankz >= 3 ? 1 : 0;
    const l1 = rankw >= 3 ? 1 : 0;
    const i2 = rankx >= 2 ? 1 : 0;
    const j2 = ranky >= 2 ? 1 : 0;
    const k2 = rankz >= 2 ? 1 : 0;
    const l2 = rankw >= 2 ? 1 : 0;
    const i3 = rankx >= 1 ? 1 : 0;
    const j3 = ranky >= 1 ? 1 : 0;
    const k3 = rankz >= 1 ? 1 : 0;
    const l3 = rankw >= 1 ? 1 : 0;
    const x1 = x0 - i1 + G4;
    const y1 = y0 - j1 + G4;
    const z1 = z0 - k1 + G4;
    const w1 = w0 - l1 + G4;
    const x22 = x0 - i2 + 2 * G4;
    const y2 = y0 - j2 + 2 * G4;
    const z2 = z0 - k2 + 2 * G4;
    const w2 = w0 - l2 + 2 * G4;
    const x3 = x0 - i3 + 3 * G4;
    const y3 = y0 - j3 + 3 * G4;
    const z3 = z0 - k3 + 3 * G4;
    const w3 = w0 - l3 + 3 * G4;
    const x4 = x0 - 1 + 4 * G4;
    const y4 = y0 - 1 + 4 * G4;
    const z4 = z0 - 1 + 4 * G4;
    const w4 = w0 - 1 + 4 * G4;
    const ii = i & 255;
    const jj = j & 255;
    const kk = k & 255;
    const ll = l & 255;
    let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
    if (t0 < 0)
      n0 = 0;
    else {
      const gi0 = ii + perm[jj + perm[kk + perm[ll]]];
      t0 *= t0;
      n0 = t0 * t0 * (permGrad4x[gi0] * x0 + permGrad4y[gi0] * y0 + permGrad4z[gi0] * z0 + permGrad4w[gi0] * w0);
    }
    let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
    if (t1 < 0)
      n1 = 0;
    else {
      const gi1 = ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]];
      t1 *= t1;
      n1 = t1 * t1 * (permGrad4x[gi1] * x1 + permGrad4y[gi1] * y1 + permGrad4z[gi1] * z1 + permGrad4w[gi1] * w1);
    }
    let t22 = 0.6 - x22 * x22 - y2 * y2 - z2 * z2 - w2 * w2;
    if (t22 < 0)
      n2 = 0;
    else {
      const gi2 = ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]];
      t22 *= t22;
      n2 = t22 * t22 * (permGrad4x[gi2] * x22 + permGrad4y[gi2] * y2 + permGrad4z[gi2] * z2 + permGrad4w[gi2] * w2);
    }
    let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
    if (t3 < 0)
      n3 = 0;
    else {
      const gi3 = ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]];
      t3 *= t3;
      n3 = t3 * t3 * (permGrad4x[gi3] * x3 + permGrad4y[gi3] * y3 + permGrad4z[gi3] * z3 + permGrad4w[gi3] * w3);
    }
    let t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
    if (t4 < 0)
      n4 = 0;
    else {
      const gi4 = ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]];
      t4 *= t4;
      n4 = t4 * t4 * (permGrad4x[gi4] * x4 + permGrad4y[gi4] * y4 + permGrad4z[gi4] * z4 + permGrad4w[gi4] * w4);
    }
    return 27 * (n0 + n1 + n2 + n3 + n4);
  };
}
function buildPermutationTable(random) {
  const tableSize = 512;
  const p = new Uint8Array(tableSize);
  for (let i = 0; i < tableSize / 2; i++) {
    p[i] = i;
  }
  for (let i = 0; i < tableSize / 2 - 1; i++) {
    const r = i + ~~(random() * (256 - i));
    const aux = p[i];
    p[i] = p[r];
    p[r] = aux;
  }
  for (let i = 256; i < tableSize; i++) {
    p[i] = p[i - 256];
  }
  return p;
}

// node_modules/@needle-tools/engine/lib/engine/extensions/NEEDLE_render_objects.js
var debug70 = getParam("debugstencil");
function matchesLayer(stencilLayer, comp) {
  return (stencilLayer & 1 << comp.layer) != 0;
}
var $stencils = Symbol("stencils");
var _NEEDLE_render_objects = class {
  constructor(parser, source) {
    __publicField(this, "parser");
    __publicField(this, "source");
    this.parser = parser;
    this.source = source;
  }
  get name() {
    return "NEEDLE_render_objects";
  }
  static applyStencil(obj) {
    if (!obj)
      return;
    const source = obj.sourceId;
    if (debug70)
      console.log(source, _NEEDLE_render_objects.stencils);
    if (!source)
      return;
    const settings = _NEEDLE_render_objects.stencils[source];
    if (!settings)
      return;
    for (let i = settings.length - 1; i >= 0; i--) {
      const stencil = settings[i];
      if (matchesLayer(stencil.layer, obj)) {
        if (debug70)
          console.log(stencil);
        setTimeout(() => {
          if (isLocalNetwork() && isUsingInstancing(obj.gameObject)) {
            showBalloonWarning("Stencil not supported on instanced objects");
            console.warn("Stencil not supported on instanced objects", obj);
          }
        }, 500);
        for (let i2 = 0; i2 < obj.sharedMaterials.length; i2++) {
          let mat = obj.sharedMaterials[i2];
          if (mat) {
            mat = mat.clone();
            mat[$stencils] = true;
            mat.stencilWrite = true;
            mat.stencilWriteMask = 255;
            mat.stencilFuncMask = 255;
            mat.stencilRef = stencil.value;
            mat.stencilFunc = stencil.compareFunc;
            mat.stencilZPass = stencil.passOp;
            mat.stencilFail = stencil.failOp;
            mat.stencilZFail = stencil.zFailOp;
            obj.sharedMaterials[i2] = mat;
          }
        }
        obj.gameObject.renderOrder = stencil.event * 1e3 + stencil.index * 50;
        break;
      }
    }
  }
  afterRoot(_result) {
    const extensions = this.parser.json.extensions;
    if (extensions) {
      const ext = extensions[EXTENSION_NAME4];
      if (ext) {
        if (debug70)
          console.log(ext);
        const stencils = ext.stencil;
        if (stencils && Array.isArray(stencils)) {
          for (const stencil of stencils) {
            const obj = { ...stencil };
            obj.compareFunc = ToThreeCompareFunction(obj.compareFunc);
            obj.passOp = ToThreeStencilOp(obj.passOp);
            obj.failOp = ToThreeStencilOp(obj.failOp);
            obj.zFailOp = ToThreeStencilOp(obj.zFailOp);
            if (!_NEEDLE_render_objects.stencils[this.source])
              _NEEDLE_render_objects.stencils[this.source] = [];
            _NEEDLE_render_objects.stencils[this.source].push(obj);
          }
        }
      }
    }
    return null;
  }
};
var NEEDLE_render_objects = _NEEDLE_render_objects;
__publicField(NEEDLE_render_objects, "stencils", {});
var StencilOp;
(function(StencilOp2) {
  StencilOp2[StencilOp2["Keep"] = 0] = "Keep";
  StencilOp2[StencilOp2["Zero"] = 1] = "Zero";
  StencilOp2[StencilOp2["Replace"] = 2] = "Replace";
  StencilOp2[StencilOp2["IncrementSaturate"] = 3] = "IncrementSaturate";
  StencilOp2[StencilOp2["DecrementSaturate"] = 4] = "DecrementSaturate";
  StencilOp2[StencilOp2["Invert"] = 5] = "Invert";
  StencilOp2[StencilOp2["IncrementWrap"] = 6] = "IncrementWrap";
  StencilOp2[StencilOp2["DecrementWrap"] = 7] = "DecrementWrap";
})(StencilOp || (StencilOp = {}));
var CompareFunction;
(function(CompareFunction2) {
  CompareFunction2[CompareFunction2["Disabled"] = 0] = "Disabled";
  CompareFunction2[CompareFunction2["Never"] = 1] = "Never";
  CompareFunction2[CompareFunction2["Less"] = 2] = "Less";
  CompareFunction2[CompareFunction2["Equal"] = 3] = "Equal";
  CompareFunction2[CompareFunction2["LessEqual"] = 4] = "LessEqual";
  CompareFunction2[CompareFunction2["Greater"] = 5] = "Greater";
  CompareFunction2[CompareFunction2["NotEqual"] = 6] = "NotEqual";
  CompareFunction2[CompareFunction2["GreaterEqual"] = 7] = "GreaterEqual";
  CompareFunction2[CompareFunction2["Always"] = 8] = "Always";
})(CompareFunction || (CompareFunction = {}));
function ToThreeStencilOp(op) {
  switch (op) {
    case StencilOp.Keep:
      return KeepStencilOp;
    case StencilOp.Zero:
      return ZeroStencilOp;
    case StencilOp.Replace:
      return ReplaceStencilOp;
    case StencilOp.IncrementSaturate:
      return IncrementStencilOp;
    case StencilOp.DecrementSaturate:
      return DecrementStencilOp;
    case StencilOp.IncrementWrap:
      return IncrementWrapStencilOp;
    case StencilOp.DecrementWrap:
      return DecrementWrapStencilOp;
    case StencilOp.Invert:
      return InvertStencilOp;
  }
  return 0;
}
function ToThreeCompareFunction(func) {
  switch (func) {
    case CompareFunction.Never:
      return NeverStencilFunc;
    case CompareFunction.Less:
      return LessStencilFunc;
    case CompareFunction.Equal:
      return EqualStencilFunc;
    case CompareFunction.LessEqual:
      return LessEqualStencilFunc;
    case CompareFunction.Greater:
      return GreaterStencilFunc;
    case CompareFunction.NotEqual:
      return NotEqualStencilFunc;
    case CompareFunction.GreaterEqual:
      return GreaterEqualStencilFunc;
    case CompareFunction.Always:
      return AlwaysStencilFunc;
  }
  return NeverStencilFunc;
}
var EXTENSION_NAME4 = "NEEDLE_render_objects";

// node_modules/@needle-tools/engine/lib/engine-components/ReflectionProbe.js
var __decorate42 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug71 = getParam("debugreflectionprobe");
var disable2 = getParam("noreflectionprobe");
var $reflectionProbeKey = Symbol("reflectionProbeKey");
var $originalMaterial = Symbol("original material");
var _ReflectionProbe = class extends Component2 {
  constructor() {
    var _a2;
    super();
    __publicField(this, "_texture");
    __publicField(this, "center");
    __publicField(this, "size");
    __publicField(this, "_boxHelper");
    if (!_ReflectionProbe._probes.has(this.context)) {
      _ReflectionProbe._probes.set(this.context, []);
    }
    (_a2 = _ReflectionProbe._probes.get(this.context)) == null ? void 0 : _a2.push(this);
  }
  static get(object, context, isAnchor, anchor) {
    if (!object || object.isObject3D !== true)
      return null;
    if (disable2)
      return null;
    const probes = _ReflectionProbe._probes.get(context);
    if (probes) {
      for (const probe of probes) {
        if (!probe.__didAwake)
          probe.__internalAwake();
        if (probe.enabled) {
          if (anchor) {
            if (probe.gameObject === anchor) {
              return probe;
            }
          }
        }
      }
    }
    if (debug71)
      console.debug("Did not find reflection probe", object.name, isAnchor, object);
    return null;
  }
  set texture(tex) {
    if (tex && !(tex instanceof Texture)) {
      console.error("ReflectionProbe.texture must be a Texture", tex);
      return;
    }
    this._texture = tex;
    if (tex) {
      tex.mapping = EquirectangularReflectionMapping;
      tex.colorSpace = SRGBColorSpace;
      tex.needsUpdate = true;
    }
  }
  get texture() {
    return this._texture;
  }
  isInBox(obj) {
    var _a2;
    return (_a2 = this._boxHelper) == null ? void 0 : _a2.isInBox(obj);
  }
  awake() {
    this._boxHelper = this.gameObject.addComponent(BoxHelperComponent);
    this._boxHelper.updateBox(true);
    if (debug71)
      this._boxHelper.showHelper(5592320, true);
    if (this.texture) {
      this.texture.mapping = EquirectangularReflectionMapping;
      this.texture.colorSpace = SRGBColorSpace;
      this.texture.needsUpdate = true;
    }
  }
  onDestroy() {
    const probes = _ReflectionProbe._probes.get(this.context);
    if (probes) {
      const index = probes.indexOf(this);
      if (index >= 0) {
        probes.splice(index, 1);
      }
    }
  }
  onSet(_rend) {
    var _a2;
    if (disable2)
      return;
    if (!this.enabled)
      return;
    if (((_a2 = _rend.sharedMaterials) == null ? void 0 : _a2.length) <= 0)
      return;
    if (!this.texture)
      return;
    let rendererCache = _ReflectionProbe._rendererMaterialsCache.get(_rend);
    if (!rendererCache) {
      rendererCache = [];
      _ReflectionProbe._rendererMaterialsCache.set(_rend, rendererCache);
    }
    for (let i = 0; i < _rend.sharedMaterials.length; i++) {
      const material = _rend.sharedMaterials[i];
      if (!material) {
        continue;
      }
      if (material["envMap"] === void 0) {
        continue;
      }
      if (material instanceof MeshBasicMaterial) {
        continue;
      }
      let cached = rendererCache[i];
      const isCachedInstance = material === (cached == null ? void 0 : cached.copy);
      const hasChanged = !cached || cached.material.uuid !== material.uuid || cached.copy.version !== material.version;
      if (!isCachedInstance && hasChanged) {
        if (debug71) {
          let reason = "";
          if (!cached)
            reason = "not cached";
          else if (cached.material !== material)
            reason = "reference changed; cached instance?: " + isCachedInstance;
          else if (cached.copy.version !== material.version)
            reason = "version changed";
          console.warn("Cloning material", material.name, material.version, "Reason:", reason, "\n", material.uuid, "\n", cached == null ? void 0 : cached.copy.uuid, "\n", _rend.name);
        }
        const clone = material.clone();
        clone.version = material.version;
        if (cached) {
          cached.copy = clone;
          cached.material = material;
        } else {
          cached = {
            material,
            copy: clone
          };
          rendererCache.push(cached);
        }
        clone[$reflectionProbeKey] = this;
        clone[$originalMaterial] = material;
        if (debug71)
          console.log("Set reflection", _rend.name, _rend.guid);
      }
      if (cached && cached.copy) {
        cached.copy.onBeforeCompile = material.onBeforeCompile;
      }
      const copy = cached == null ? void 0 : cached.copy;
      copy["envMap"] = this.texture;
      _rend.sharedMaterials[i] = copy;
    }
  }
  onUnset(_rend) {
    const rendererCache = _ReflectionProbe._rendererMaterialsCache.get(_rend);
    if (rendererCache) {
      for (let i = 0; i < rendererCache.length; i++) {
        const cached = rendererCache[i];
        _rend.sharedMaterials[i] = cached.material;
      }
    }
  }
};
var ReflectionProbe = _ReflectionProbe;
__publicField(ReflectionProbe, "_probes", /* @__PURE__ */ new Map());
// when objects are rendered and they share material
// and some need reflection probe and some don't
// we need to make sure we don't override the material but use a copy
__publicField(ReflectionProbe, "_rendererMaterialsCache", /* @__PURE__ */ new Map());
__decorate42([
  serializable(Vector32)
], ReflectionProbe.prototype, "center", void 0);
__decorate42([
  serializable(Vector32)
], ReflectionProbe.prototype, "size", void 0);

// node_modules/@needle-tools/engine/lib/engine/extensions/EXT_texture_exr.js
var debug72 = getParam("debugexr");
var EXT_texture_exr = class {
  constructor(parser) {
    __publicField(this, "parser");
    this.parser = parser;
    if (debug72)
      console.log(parser);
  }
  get name() {
    return "EXT_texture_exr";
  }
  loadTexture(textureIndex) {
    const name = this.name;
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (debug72)
      console.log("EXT_texture_exr.loadTexture", textureIndex, textureDef);
    if (!textureDef.extensions || !textureDef.extensions[name]) {
      return null;
    }
    const extension = textureDef.extensions[name];
    const loader2 = new EXRLoader(parser.options.manager);
    if (debug72)
      console.log("EXT_texture_exr.loadTexture", extension);
    const promise = parser.loadTextureImage(textureIndex, extension.source, loader2);
    return promise;
  }
};
if (typeof window !== "undefined")
  window.addEventListener("unhandledrejection", (_event2) => {
  });

// node_modules/@needle-tools/engine/lib/engine/extensions/NEEDLE_components.js
var debug73 = debugExtension;
var componentsArrayExportKey = "$___Export_Components";
var EXTENSION_NAME5 = "NEEDLE_components";
var _a;
var ExtensionData = class {
  constructor() {
    __publicField(this, _a);
  }
};
_a = builtinComponentKeyName;
var ExportData = class {
  constructor(node, nodeIndex, nodeDef) {
    __publicField(this, "node");
    __publicField(this, "nodeIndex");
    __publicField(this, "nodeDef");
    this.node = node;
    this.nodeIndex = nodeIndex;
    this.nodeDef = nodeDef;
  }
};
var NEEDLE_components = class {
  constructor() {
    // import
    __publicField(this, "parser");
    __publicField(this, "nodeToObjectMap", {});
    /** The loaded gltf */
    __publicField(this, "gltf", null);
    // export
    __publicField(this, "exportContext");
    __publicField(this, "objectToNodeMap", {});
    __publicField(this, "context");
    __publicField(this, "writer");
  }
  get name() {
    return EXTENSION_NAME5;
  }
  registerExport(exp) {
    exp.register((writer) => {
      if ("serializeUserData" in writer) {
        const originalFunction = writer.serializeUserData.bind(writer);
        this.writer = writer;
        writer.serializeUserData = (o, def) => {
          try {
            const hadUserData = this.serializeUserData(o, def);
            if (hadUserData)
              writer.extensionsUsed[this.name] = true;
            originalFunction(o, def);
          } finally {
            this.afterSerializeUserData(o, def);
          }
        };
      }
      return this;
    });
  }
  beforeParse() {
    this.exportContext = {};
    this.objectToNodeMap = {};
  }
  // https://github.com/mrdoob/three.js/blob/efbfc67edc7f65cfcc61a389ffc5fd43ea702bc6/examples/jsm/exporters/GLTFExporter.js#L532
  serializeUserData(node, _nodeDef) {
    var _a2;
    const components = (_a2 = node.userData) == null ? void 0 : _a2.components;
    if (!components || components.length <= 0)
      return false;
    delete node.userData.components;
    node[componentsArrayExportKey] = components;
    return true;
  }
  afterSerializeUserData(node, _nodeDef) {
    if (node.type === "Scene") {
      if (debug73)
        console.log("DONE", JSON.stringify(_nodeDef));
    }
    if (node[componentsArrayExportKey] === void 0)
      return;
    const components = node[componentsArrayExportKey];
    delete node[componentsArrayExportKey];
    if (components !== null) {
      node.userData.components = components;
    }
  }
  writeNode(node, nodeDef) {
    const nodeIndex = this.writer.json.nodes.length;
    if (debug73)
      console.log(node.name, nodeIndex, node.uuid);
    const context = new ExportData(node, nodeIndex, nodeDef);
    this.exportContext[nodeIndex] = context;
    this.objectToNodeMap[node.uuid] = nodeIndex;
  }
  afterParse(input) {
    var _a2;
    if (debug73)
      console.log("AFTER", input);
    for (const i in this.exportContext) {
      const context = this.exportContext[i];
      const node = context.node;
      const nodeDef = context.nodeDef;
      const nodeIndex = context.nodeIndex;
      const components = (_a2 = node.userData) == null ? void 0 : _a2.components;
      if (!components || components.length <= 0)
        continue;
      const data = new ExtensionData();
      nodeDef.extensions = nodeDef.extensions || {};
      nodeDef.extensions[this.name] = data;
      this.context.object = node;
      this.context.nodeId = nodeIndex;
      this.context.objectToNode = this.objectToNodeMap;
      const serializedComponentData = [];
      for (const comp of components) {
        this.context.target = comp;
        const res = getLoader().writeBuiltinComponentData(comp, this.context);
        if (res !== null) {
          serializedComponentData.push(res);
        }
      }
      if (serializedComponentData.length > 0) {
        data[builtinComponentKeyName] = serializedComponentData;
        if (debug73)
          console.log("DID WRITE", node, "nodeIndex", nodeIndex, serializedComponentData);
      }
    }
  }
  // -------------------------------------
  // LOADING 
  // called by GLTFLoader
  beforeRoot() {
    if (debug73)
      console.log("BEGIN LOAD");
    this.nodeToObjectMap = {};
    return null;
  }
  // called by GLTFLoader
  async afterRoot(result) {
    this.gltf = result;
    const parser = result.parser;
    const ext = parser == null ? void 0 : parser.extensions;
    if (!ext)
      return;
    const hasExtension = ext[this.name];
    if (debug73)
      console.log("After root", result, this.parser, ext);
    const loadComponents = [];
    if (hasExtension === true) {
      const nodes = parser.json.nodes;
      if (nodes) {
        for (let i = 0; i < nodes.length; i++) {
          const obj = await parser.getDependency("node", i);
          this.nodeToObjectMap[i] = obj;
        }
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          const index = i;
          const ext2 = node.extensions;
          if (!ext2)
            continue;
          const data = ext2[this.name];
          if (!data)
            continue;
          if (debug73)
            console.log("NODE", node);
          const obj = this.nodeToObjectMap[index];
          if (!obj) {
            console.error("Could not find object for node index: " + index, node, parser);
            continue;
          }
          apply(obj);
          loadComponents.push(this.createComponents(obj, data));
        }
      }
    }
    await Promise.all(loadComponents);
    for (const instance of parser.associations.keys()) {
      const value = parser.associations.get(instance);
      if ((value == null ? void 0 : value.materials) != void 0) {
        const key = "/materials/" + value.materials;
        maskGltfAssociation(instance, key);
      }
    }
  }
  async createComponents(obj, data) {
    if (!data)
      return;
    const componentData = data[builtinComponentKeyName];
    if (componentData) {
      const tasks = new Array();
      if (debug73)
        console.log(obj.name, componentData);
      for (const i in componentData) {
        const serializedData = componentData[i];
        if (debug73)
          console.log("Serialized data", JSON.parse(JSON.stringify(serializedData)));
        if (serializedData && this.parser) {
          tasks.push(resolveReferences(this.parser, serializedData).catch((e) => console.error(`Error while resolving references (see console for details)
`, e, obj, serializedData)));
        }
        obj.userData = obj.userData || {};
        obj.userData[builtinComponentKeyName] = obj.userData[builtinComponentKeyName] || [];
        obj.userData[builtinComponentKeyName].push(serializedData);
      }
      await Promise.all(tasks).catch((e) => {
        console.error("Error while loading components", e);
      });
    }
  }
};

// node_modules/@needle-tools/engine/lib/engine/extensions/NEEDLE_gameobject_data.js
var EXTENSION_NAME6 = "NEEDLE_gameobject_data";
var NEEDLE_gameobject_data = class {
  constructor(parser) {
    __publicField(this, "parser");
    this.parser = parser;
  }
  get name() {
    return EXTENSION_NAME6;
  }
  // private _lastIndex: number = -1;
  // createNodeAttachment(index): null {
  //     if (index === this._lastIndex) return null;
  //     this._lastIndex = index;
  //     const node = this.parser.json.nodes[index];
  //     if (node && node.extensions) {
  //         const ext = node.extensions[EXTENSION_NAME];
  //         if (ext)
  //             this.findAndApplyExtensionData(index, ext);
  //     }
  //     return null;
  // }
  // private lastIndex: number = -1;
  afterRoot(_result) {
    var _a2;
    const promises = [];
    for (let index = 0; index < ((_a2 = this.parser.json.nodes) == null ? void 0 : _a2.length); index++) {
      const node = this.parser.json.nodes[index];
      if (node && node.extensions) {
        const ext = node.extensions[EXTENSION_NAME6];
        if (ext) {
          const p = this.findAndApplyExtensionData(index, ext);
          promises.push(p);
        }
      }
    }
    return Promise.all(promises).then(() => null);
  }
  async findAndApplyExtensionData(nodeId, ext) {
    const obj = await this.parser.getDependency("node", nodeId);
    if (obj) {
      this.applyExtensionData(obj, ext);
    }
  }
  applyExtensionData(node, ext) {
    if (ext.layers === void 0)
      ext.layers = 0;
    node.userData.layer = ext.layers;
    node.layers.disableAll();
    node.layers.set(ext.layers);
    node.userData.tag = ext.tag ?? "none";
    node.userData.hideFlags = ext.hideFlags ?? 0;
    node.userData.static = ext.static ?? false;
    node.visible = ext.activeSelf ?? true;
    node["guid"] = ext.guid;
  }
};

// node_modules/@needle-tools/engine/lib/engine/extensions/NEEDLE_lighting_settings.js
var EXTENSION_NAME7 = "NEEDLE_lighting_settings";
var debug74 = getParam("debugenvlight");
var NEEDLE_lighting_settings = class {
  constructor(parser, sourceId, context) {
    __publicField(this, "parser");
    __publicField(this, "sourceId");
    __publicField(this, "context");
    this.parser = parser;
    this.sourceId = sourceId;
    this.context = context;
  }
  get name() {
    return EXTENSION_NAME7;
  }
  afterRoot(_result) {
    const extensions = this.parser.json.extensions;
    if (extensions) {
      const ext = extensions[EXTENSION_NAME7];
      if (ext) {
        if (debug74)
          console.log('Loaded "' + this.name + '", src: "' + this.sourceId + '"', ext);
        let settings = void 0;
        if (_result.scene.children.length === 1) {
          const obj = _result.scene.children[0];
          settings = GameObject.addComponent(obj, SceneLightSettings, {}, { callAwake: false });
        } else {
          const lightSettings = new Object3D();
          lightSettings.name = "LightSettings " + this.sourceId;
          _result.scene.add(lightSettings);
          settings = GameObject.addComponent(lightSettings, SceneLightSettings, {}, { callAwake: false });
        }
        settings.sourceId = this.sourceId;
        settings.ambientIntensity = ext.ambientIntensity;
        settings.ambientLight = new Color().fromArray(ext.ambientLight);
        if (Array.isArray(ext.ambientTrilight))
          settings.ambientTrilight = ext.ambientTrilight.map((c2) => new Color().fromArray(c2));
        settings.ambientMode = ext.ambientMode;
        settings.environmentReflectionSource = ext.environmentReflectionSource;
      }
    }
    return null;
  }
};
ContextRegistry.registerCallback(ContextEvent.ContextCreated, (e) => {
  const ctx = e.context;
  const lightingSettings = GameObject.findObjectOfType(SceneLightSettings, ctx);
  if (lightingSettings == null ? void 0 : lightingSettings.sourceId)
    lightingSettings.enabled = true;
});
var SceneLightSettings = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "ambientMode", AmbientMode.Skybox);
    __publicField(this, "ambientLight");
    __publicField(this, "ambientTrilight");
    __publicField(this, "ambientIntensity", 1);
    __publicField(this, "environmentReflectionSource", DefaultReflectionMode.Skybox);
    __publicField(this, "_hasReflection", false);
    __publicField(this, "_ambientLightObj");
    __publicField(this, "_hemisphereLightObj");
  }
  awake() {
    var _a2;
    if (this.sourceId) {
      const type = this.environmentReflectionSource === DefaultReflectionMode.Skybox ? LightmapType.Skybox : LightmapType.Reflection;
      const tex = this.context.lightmaps.tryGet(this.sourceId, type, 0);
      this._hasReflection = tex !== null && tex !== void 0;
      if (tex)
        this.context.sceneLighting.internalRegisterReflection(this.sourceId, tex);
    }
    this.enabled = false;
    this.context.sceneLighting.internalRegisterSceneLightSettings(this);
    if (debug74) {
      window.addEventListener("keydown", (evt) => {
        if (this.destroyed)
          return;
        switch (evt.key) {
          case "l":
            this.enabled = !this.enabled;
            break;
        }
      });
    }
    const comps = (_a2 = this.gameObject.userData) == null ? void 0 : _a2.components;
    if (comps) {
      const index = comps.indexOf(this);
      comps.splice(index, 1);
      comps.push(this);
    }
  }
  onDestroy() {
    this.context.sceneLighting.internalUnregisterSceneLightSettings(this);
  }
  calculateIntensityFactor(col2) {
    const intensity = Math.max(col2.r, col2.g, col2.b);
    const factor = 2.2 * Mathf.lerp(0, 1.33, intensity);
    return factor;
  }
  onEnable() {
    if (debug74)
      console.warn("💡🟡 >>> Enable lighting", this.sourceId, this.enabled, this);
    if (this.ambientMode == AmbientMode.Flat) {
      if (this.ambientLight && !this._ambientLightObj) {
        const factor = this.calculateIntensityFactor(this.ambientLight);
        this._ambientLightObj = new AmbientLight(this.ambientLight, this.ambientIntensity * factor);
        if (debug74)
          console.log("Created ambient light", this.sourceId, this._ambientLightObj, this.ambientIntensity, factor);
      }
      if (this._ambientLightObj) {
        this.gameObject.add(this._ambientLightObj);
      }
    } else if (this.ambientMode === AmbientMode.Trilight) {
      if (this.ambientTrilight) {
        const ground = this.ambientTrilight[0];
        const sky = this.ambientTrilight[this.ambientTrilight.length - 1];
        const factor = this.calculateIntensityFactor(sky);
        this._hemisphereLightObj = new HemisphereLight(sky, ground, this.ambientIntensity * factor);
        this.gameObject.add(this._hemisphereLightObj);
        if (debug74)
          console.log("Created hemisphere ambient light", this.sourceId, this._hemisphereLightObj, this.ambientIntensity, factor);
      }
    } else {
      if (this._ambientLightObj)
        this._ambientLightObj.removeFromParent();
      if (this._hemisphereLightObj)
        this._hemisphereLightObj.removeFromParent();
    }
    if (this.sourceId)
      this.context.sceneLighting.internalEnableReflection(this.sourceId);
  }
  onDisable() {
    if (debug74)
      console.warn("💡⚫ <<< Disable lighting:", this.sourceId, this);
    if (this._ambientLightObj)
      this._ambientLightObj.removeFromParent();
    if (this._hemisphereLightObj)
      this._hemisphereLightObj.removeFromParent();
    if (this.sourceId)
      this.context.sceneLighting.internalDisableReflection(this.sourceId);
  }
};

// node_modules/@needle-tools/engine/lib/engine/shaders/shaderData.js
var ShaderType;
(function(ShaderType2) {
  ShaderType2[ShaderType2["Fragment"] = 35632] = "Fragment";
  ShaderType2[ShaderType2["Vertex"] = 35633] = "Vertex";
})(ShaderType || (ShaderType = {}));
var UniformType;
(function(UniformType3) {
  UniformType3[UniformType3["INT"] = 5124] = "INT";
  UniformType3[UniformType3["FLOAT"] = 5126] = "FLOAT";
  UniformType3[UniformType3["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
  UniformType3[UniformType3["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
  UniformType3[UniformType3["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
  UniformType3[UniformType3["INT_VEC2"] = 35667] = "INT_VEC2";
  UniformType3[UniformType3["INT_VEC3"] = 35668] = "INT_VEC3";
  UniformType3[UniformType3["INT_VEC4"] = 35669] = "INT_VEC4";
  UniformType3[UniformType3["BOOL"] = 35670] = "BOOL";
  UniformType3[UniformType3["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
  UniformType3[UniformType3["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
  UniformType3[UniformType3["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
  UniformType3[UniformType3["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
  UniformType3[UniformType3["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
  UniformType3[UniformType3["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
  UniformType3[UniformType3["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
  UniformType3[UniformType3["SAMPLER_3D"] = 35680] = "SAMPLER_3D";
  UniformType3[UniformType3["SAMPLER_CUBE"] = 35681] = "SAMPLER_CUBE";
  UniformType3[UniformType3["UNKNOWN"] = 0] = "UNKNOWN";
})(UniformType || (UniformType = {}));

// node_modules/@needle-tools/engine/lib/engine/extensions/NEEDLE_techniques_webgl.js
var debug75 = getParam("debugcustomshader");
var NEEDLE_TECHNIQUES_WEBGL_NAME = "NEEDLE_techniques_webgl";
var UniformType2;
(function(UniformType3) {
  UniformType3[UniformType3["INT"] = 5124] = "INT";
  UniformType3[UniformType3["FLOAT"] = 5126] = "FLOAT";
  UniformType3[UniformType3["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
  UniformType3[UniformType3["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
  UniformType3[UniformType3["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
  UniformType3[UniformType3["INT_VEC2"] = 35667] = "INT_VEC2";
  UniformType3[UniformType3["INT_VEC3"] = 35668] = "INT_VEC3";
  UniformType3[UniformType3["INT_VEC4"] = 35669] = "INT_VEC4";
  UniformType3[UniformType3["BOOL"] = 35670] = "BOOL";
  UniformType3[UniformType3["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
  UniformType3[UniformType3["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
  UniformType3[UniformType3["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
  UniformType3[UniformType3["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
  UniformType3[UniformType3["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
  UniformType3[UniformType3["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
  UniformType3[UniformType3["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
  UniformType3[UniformType3["SAMPLER_3D"] = 35680] = "SAMPLER_3D";
  UniformType3[UniformType3["SAMPLER_CUBE"] = 35681] = "SAMPLER_CUBE";
  UniformType3[UniformType3["UNKNOWN"] = 0] = "UNKNOWN";
})(UniformType2 || (UniformType2 = {}));
var ObjectRendererData = class {
  constructor() {
    __publicField(this, "objectToWorldMatrix", new Matrix4());
    __publicField(this, "worldToObjectMatrix", new Matrix4());
    __publicField(this, "objectToWorld", new Array());
    __publicField(this, "worldToObject", new Array());
  }
  updateFrom(obj) {
    this.objectToWorldMatrix.copy(obj.matrixWorld);
    ToUnityMatrixArray(this.objectToWorldMatrix, this.objectToWorld);
    this.worldToObjectMatrix.copy(obj.matrixWorld).invert();
    ToUnityMatrixArray(this.worldToObjectMatrix, this.worldToObject);
  }
};
var CullMode;
(function(CullMode2) {
  CullMode2[CullMode2["Off"] = 0] = "Off";
  CullMode2[CullMode2["Front"] = 1] = "Front";
  CullMode2[CullMode2["Back"] = 2] = "Back";
})(CullMode || (CullMode = {}));
var ZTestMode;
(function(ZTestMode2) {
  ZTestMode2[ZTestMode2["Never"] = 1] = "Never";
  ZTestMode2[ZTestMode2["Less"] = 2] = "Less";
  ZTestMode2[ZTestMode2["Equal"] = 3] = "Equal";
  ZTestMode2[ZTestMode2["LEqual"] = 4] = "LEqual";
  ZTestMode2[ZTestMode2["Greater"] = 5] = "Greater";
  ZTestMode2[ZTestMode2["NotEqual"] = 6] = "NotEqual";
  ZTestMode2[ZTestMode2["GEqual"] = 7] = "GEqual";
  ZTestMode2[ZTestMode2["Always"] = 8] = "Always";
})(ZTestMode || (ZTestMode = {}));
var _CustomShader = class extends RawShaderMaterial {
  constructor(identifier, ...args) {
    super(...args);
    __publicField(this, "identifier");
    __publicField(this, "onBeforeRenderSceneCallback", this.onBeforeRenderScene.bind(this));
    /* REMOVED, we don't have Lit shader support for now
    async waitForLighting() {
        const context: Context = Context.Current;
        if (!context) {
            console.error("Missing context");
            return;
        }
        const data = await context.sceneLighting.internalGetSceneLightingData(this.identifier);
        if (!data || !data.array) {
            console.warn("Missing lighting data for custom shader, getSceneLightingData did not return anything");
            return;
        }
        if (debug)
            console.log(data);
        const array = data.array;
        const envTexture = data.texture;
        // console.log(envTexture);
        this.uniforms["unity_SpecCube0"] = { value: envTexture };
        SetUnitySphericalHarmonics(this.uniforms, array);
        const hdr = Math.sqrt(Math.PI * .5);
        this.uniforms["unity_SpecCube0_HDR"] = { value: new Vector4(hdr, hdr, hdr, hdr) };
        // this.needsUpdate = true;
        // this.uniformsNeedUpdate = true;
        if (debug) console.log("Set environment lighting", this.uniforms);
    }
    */
    __publicField(this, "_sphericalHarmonicsName", "unity_SpecCube0");
    __publicField(this, "_objToWorldName", "hlslcc_mtx4x4unity_ObjectToWorld");
    __publicField(this, "_worldToObjectName", "hlslcc_mtx4x4unity_WorldToObject");
    __publicField(this, "_viewProjectionName", "hlslcc_mtx4x4unity_MatrixVP");
    __publicField(this, "_viewMatrixName", "hlslcc_mtx4x4unity_MatrixV");
    __publicField(this, "_rendererData", new ObjectRendererData());
    this.identifier = identifier;
    if (debug75)
      console.log(this);
    this.type = "NEEDLE_CUSTOM_SHADER";
    if (!this.uniforms[this._objToWorldName])
      this.uniforms[this._objToWorldName] = { value: [] };
    if (!this.uniforms[this._worldToObjectName])
      this.uniforms[this._worldToObjectName] = { value: [] };
    if (!this.uniforms[this._viewProjectionName])
      this.uniforms[this._viewProjectionName] = { value: [] };
    if (this.uniforms[this._sphericalHarmonicsName]) {
    }
    if (this.depthTextureUniform || this.opaqueTextureUniform) {
      Context.Current.pre_render_callbacks.push(this.onBeforeRenderSceneCallback);
    }
  }
  clone() {
    const clone = super.clone();
    createUniformProperties(clone);
    return clone;
  }
  dispose() {
    super.dispose();
    const index = Context.Current.pre_render_callbacks.indexOf(this.onBeforeRenderSceneCallback);
    if (index >= 0)
      Context.Current.pre_render_callbacks.splice(index, 1);
  }
  get depthTextureUniform() {
    if (!this.uniforms)
      return void 0;
    return this.uniforms["_CameraDepthTexture"];
  }
  get opaqueTextureUniform() {
    if (!this.uniforms)
      return void 0;
    return this.uniforms["_CameraOpaqueTexture"];
  }
  onBeforeRenderScene() {
    if (this.opaqueTextureUniform) {
      Context.Current.setRequireColor(true);
    }
    if (this.depthTextureUniform) {
      Context.Current.setRequireDepth(true);
    }
  }
  onBeforeRender(_renderer3, _scene, camera, _geometry2, obj, _group) {
    if (!_geometry2.attributes["tangent"])
      _geometry2.computeTangents();
    this.onUpdateUniforms(camera, obj);
  }
  onUpdateUniforms(camera, obj) {
    const context = Context.Current;
    {
      if (camera) {
        if (_CustomShader.viewProjection && this.uniforms[this._viewProjectionName]) {
          _CustomShader.viewProjection.copy(camera.projectionMatrix).multiply(camera.matrixWorldInverse);
          ToUnityMatrixArray(_CustomShader.viewProjection, _CustomShader._viewProjectionValues);
        }
        if (_CustomShader.viewMatrix && this.uniforms[this._viewMatrixName]) {
          _CustomShader.viewMatrix.copy(camera.matrixWorldInverse);
          ToUnityMatrixArray(_CustomShader.viewMatrix, _CustomShader._viewMatrixValues);
        }
        if (this.uniforms[_CustomShader._worldSpaceCameraPosName]) {
          _CustomShader._worldSpaceCameraPos.setFromMatrixPosition(camera.matrixWorld);
        }
      }
    }
    if (this.uniforms["_TimeParameters"]) {
      this.uniforms["_TimeParameters"].value = context.sceneLighting.timeVec4;
    }
    if (this.uniforms["_Time"]) {
      const _time2 = this.uniforms["_Time"].value;
      _time2.x = context.sceneLighting.timeVec4.x / 20;
      _time2.y = context.sceneLighting.timeVec4.x;
      _time2.z = context.sceneLighting.timeVec4.x * 2;
      _time2.w = context.sceneLighting.timeVec4.x * 3;
    }
    if (this.uniforms["_SinTime"]) {
      const _time2 = this.uniforms["_SinTime"].value;
      _time2.x = Math.sin(context.sceneLighting.timeVec4.x / 8);
      _time2.y = Math.sin(context.sceneLighting.timeVec4.x / 4);
      _time2.z = Math.sin(context.sceneLighting.timeVec4.x / 2);
      _time2.w = Math.sin(context.sceneLighting.timeVec4.x);
    }
    if (this.uniforms["_CosTime"]) {
      const _time2 = this.uniforms["_CosTime"].value;
      _time2.x = Math.cos(context.sceneLighting.timeVec4.x / 8);
      _time2.y = Math.cos(context.sceneLighting.timeVec4.x / 4);
      _time2.z = Math.cos(context.sceneLighting.timeVec4.x / 2);
      _time2.w = Math.cos(context.sceneLighting.timeVec4.x);
    }
    if (this.uniforms["unity_DeltaTime"]) {
      const _time2 = this.uniforms["unity_DeltaTime"].value;
      _time2.x = context.time.deltaTime;
      _time2.y = 1 / context.time.deltaTime;
      _time2.z = context.time.smoothedDeltaTime;
      _time2.w = 1 / context.time.smoothedDeltaTime;
    }
    const mainLight = context.mainLight;
    if (mainLight) {
      const lp = getWorldPosition(mainLight.gameObject, _CustomShader._mainLightPosition);
      this.uniforms["_MainLightPosition"] = { value: lp.normalize() };
      _CustomShader._mainLightColor.set(mainLight.color.r, mainLight.color.g, mainLight.color.b, 0);
      this.uniforms["_MainLightColor"] = { value: _CustomShader._mainLightColor };
      const intensity = mainLight.intensity;
      _CustomShader._lightData.z = intensity;
      this.uniforms["unity_LightData"] = { value: _CustomShader._lightData };
    }
    if (camera) {
      if (_CustomShader.viewProjection && this.uniforms[this._viewProjectionName]) {
        this.uniforms[this._viewProjectionName].value = _CustomShader._viewProjectionValues;
      }
      if (_CustomShader.viewMatrix && this.uniforms[this._viewMatrixName]) {
        this.uniforms[this._viewMatrixName].value = _CustomShader._viewMatrixValues;
      }
      if (this.uniforms[_CustomShader._worldSpaceCameraPosName]) {
        this.uniforms[_CustomShader._worldSpaceCameraPosName] = { value: _CustomShader._worldSpaceCameraPos };
      }
      if (context.mainCameraComponent) {
        if (this.uniforms["_ProjectionParams"]) {
          const params = this.uniforms["_ProjectionParams"].value;
          params.x = 1;
          params.y = context.mainCameraComponent.nearClipPlane;
          params.z = context.mainCameraComponent.farClipPlane;
          params.w = 1 / params.z;
          this.uniforms["_ProjectionParams"].value = params;
        }
        if (this.uniforms["_ZBufferParams"]) {
          const params = this.uniforms["_ZBufferParams"].value;
          const cam = context.mainCameraComponent;
          params.x = 1 - cam.farClipPlane / cam.nearClipPlane;
          params.y = cam.farClipPlane / cam.nearClipPlane;
          params.z = params.x / cam.farClipPlane;
          params.w = params.y / cam.farClipPlane;
          this.uniforms["_ZBufferParams"].value = params;
        }
        if (this.uniforms["_ScreenParams"]) {
          const params = this.uniforms["_ScreenParams"].value;
          params.x = context.domWidth;
          params.y = context.domHeight;
          params.z = 1 + 1 / params.x;
          params.w = 1 + 1 / params.y;
          this.uniforms["_ScreenParams"].value = params;
        }
        if (this.uniforms["_ScaledScreenParams"]) {
          const params = this.uniforms["_ScaledScreenParams"].value;
          params.x = context.domWidth;
          params.y = context.domHeight;
          params.z = 1 + 1 / params.x;
          params.w = 1 + 1 / params.y;
          this.uniforms["_ScaledScreenParams"].value = params;
        }
      }
    }
    const depthTexture = this.depthTextureUniform;
    if (depthTexture) {
      depthTexture.value = context.depthTexture;
    }
    const colorTexture = this.opaqueTextureUniform;
    if (colorTexture) {
      colorTexture.value = context.opaqueColorTexture;
    }
    if (obj) {
      const objData = this._rendererData;
      objData.updateFrom(obj);
      this.uniforms[this._worldToObjectName].value = objData.worldToObject;
      this.uniforms[this._objToWorldName].value = objData.objectToWorld;
    }
    this.uniformsNeedUpdate = true;
  }
};
var CustomShader = _CustomShader;
__publicField(CustomShader, "viewProjection", new Matrix4());
__publicField(CustomShader, "_viewProjectionValues", []);
__publicField(CustomShader, "viewMatrix", new Matrix4());
__publicField(CustomShader, "_viewMatrixValues", []);
__publicField(CustomShader, "_worldSpaceCameraPosName", "_WorldSpaceCameraPos");
__publicField(CustomShader, "_worldSpaceCameraPos", new Vector32());
__publicField(CustomShader, "_mainLightColor", new Vector4());
__publicField(CustomShader, "_mainLightPosition", new Vector32());
__publicField(CustomShader, "_lightData", new Vector4());
var NEEDLE_techniques_webgl = class {
  constructor(loader2, identifier) {
    __publicField(this, "parser");
    __publicField(this, "identifier");
    this.parser = loader2;
    this.identifier = identifier;
  }
  get name() {
    return NEEDLE_TECHNIQUES_WEBGL_NAME;
  }
  loadMaterial(index) {
    const mat = this.parser.json.materials[index];
    if (!mat) {
      if (debug75)
        console.log(index, this.parser.json.materials);
      return null;
    }
    if (!mat.extensions || !mat.extensions[NEEDLE_TECHNIQUES_WEBGL_NAME]) {
      if (debug75)
        console.log(`Material ${index} does not use NEEDLE_techniques_webgl`);
      return null;
    }
    if (debug75)
      console.log(`Material ${index} uses NEEDLE_techniques_webgl`, mat);
    const techniqueIndex = mat.extensions[NEEDLE_TECHNIQUES_WEBGL_NAME].technique;
    if (techniqueIndex < 0) {
      console.debug(`Material ${index} does not have a valid technique index`);
      return null;
    }
    const shaders = this.parser.json.extensions[NEEDLE_TECHNIQUES_WEBGL_NAME];
    if (!shaders) {
      if (debug75)
        console.error("Missing shader data", this.parser.json.extensions);
      else
        console.debug("Missing custom shader data in parser.json.extensions");
      return null;
    }
    if (debug75)
      console.log(shaders);
    const technique = shaders.techniques[techniqueIndex];
    if (!technique)
      return null;
    return new Promise(async (resolve2, reject) => {
      var _a2, _b, _c;
      const bundle = await FindShaderTechniques(shaders, technique.program);
      const frag2 = bundle == null ? void 0 : bundle.fragmentShader;
      const vert2 = bundle == null ? void 0 : bundle.vertexShader;
      if (!frag2 || !vert2)
        return reject();
      if (debug75)
        console.log("loadMaterial", mat, bundle);
      const uniforms = {};
      const techniqueUniforms = technique.uniforms;
      if (vert2.includes("_Time") || frag2.includes("_Time"))
        uniforms["_Time"] = { value: new Vector4(0, 0, 0, 0) };
      if (vert2.includes("_SinTime") || frag2.includes("_SinTime"))
        uniforms["_SinTime"] = { value: new Vector4(0, 0, 0, 0) };
      if (vert2.includes("_CosTime") || frag2.includes("_CosTime"))
        uniforms["_CosTime"] = { value: new Vector4(0, 0, 0, 0) };
      if (vert2.includes("unity_DeltaTime") || frag2.includes("unity_DeltaTime"))
        uniforms["unity_DeltaTime"] = { value: new Vector4(0, 0, 0, 0) };
      for (const u2 in techniqueUniforms) {
        const uniformName = u2;
        switch (uniformName) {
          case "_TimeParameters":
            const timeUniform = new Vector4();
            uniforms[uniformName] = { value: timeUniform };
            break;
          case "hlslcc_mtx4x4unity_MatrixV":
          case "hlslcc_mtx4x4unity_MatrixVP":
            uniforms[uniformName] = { value: [] };
            break;
          case "_MainLightPosition":
          case "_MainLightColor":
          case "_WorldSpaceCameraPos":
            uniforms[uniformName] = { value: [0, 0, 0, 1] };
            break;
          case "unity_OrthoParams":
            break;
          case "unity_SpecCube0":
            uniforms[uniformName] = { value: null };
            break;
          default:
          case "_ScreenParams":
          case "_ZBufferParams":
          case "_ProjectionParams":
            uniforms[uniformName] = { value: [0, 0, 0, 0] };
            break;
          case "_CameraOpaqueTexture":
          case "_CameraDepthTexture":
            uniforms[uniformName] = { value: null };
            break;
            break;
        }
      }
      let isTransparent = false;
      if (mat.extensions && mat.extensions[NEEDLE_TECHNIQUES_WEBGL_NAME]) {
        const materialExtension = mat.extensions[NEEDLE_TECHNIQUES_WEBGL_NAME];
        if (materialExtension.technique === techniqueIndex) {
          if (debug75)
            console.log(mat.name, "Material Properties", materialExtension);
          for (const key in materialExtension.values) {
            const val = materialExtension.values[key];
            if (typeof val === "string") {
              if (val.startsWith("/textures/")) {
                const indexString = val.substring("/textures/".length);
                const texIndex = Number.parseInt(indexString);
                if (texIndex >= 0) {
                  const tex = await this.parser.getDependency("texture", texIndex);
                  if (tex instanceof Texture) {
                    tex.colorSpace = LinearSRGBColorSpace;
                    tex.needsUpdate = true;
                  }
                  uniforms[key] = { value: tex };
                  continue;
                }
              }
              switch (key) {
                case "alphaMode":
                  if (val === "BLEND")
                    isTransparent = true;
                  continue;
              }
            }
            if (Array.isArray(val) && val.length === 4) {
              uniforms[key] = { value: new Vector4(val[0], val[1], val[2], val[3]) };
              continue;
            }
            uniforms[key] = { value: val };
          }
        }
      }
      const material = new CustomShader(this.identifier, {
        name: mat.name ?? "",
        uniforms,
        vertexShader: vert2,
        fragmentShader: frag2,
        lights: false
        // defines: {
        //     "USE_SHADOWMAP" : true
        // },
      });
      material.glslVersion = GLSL3;
      material.vertexShader = material.vertexShader.replace("#version 300 es", "");
      material.fragmentShader = material.fragmentShader.replace("#version 300 es", "");
      const culling = (_a2 = uniforms["_Cull"]) == null ? void 0 : _a2.value;
      switch (culling) {
        case CullMode.Off:
          material.side = DoubleSide;
          break;
        case CullMode.Front:
          material.side = BackSide;
          break;
        case CullMode.Back:
          material.side = FrontSide;
          break;
        default:
          material.side = FrontSide;
          break;
      }
      const zTest = (_b = uniforms["_ZTest"]) == null ? void 0 : _b.value;
      switch (zTest) {
        case ZTestMode.Equal:
          material.depthTest = true;
          material.depthFunc = EqualDepth;
          break;
        case ZTestMode.NotEqual:
          material.depthTest = true;
          material.depthFunc = NotEqualDepth;
          break;
        case ZTestMode.Less:
          material.depthTest = true;
          material.depthFunc = LessDepth;
          break;
        case ZTestMode.LEqual:
          material.depthTest = true;
          material.depthFunc = LessEqualDepth;
          break;
        case ZTestMode.Greater:
          material.depthTest = true;
          material.depthFunc = GreaterDepth;
          break;
        case ZTestMode.GEqual:
          material.depthTest = true;
          material.depthFunc = GreaterEqualDepth;
          break;
        case ZTestMode.Always:
          material.depthTest = false;
          material.depthFunc = AlwaysDepth;
          break;
      }
      material.transparent = isTransparent;
      if (isTransparent)
        material.depthWrite = false;
      SetUnitySphericalHarmonics(uniforms);
      material.onUpdateUniforms();
      for (const u2 in techniqueUniforms) {
        const uniformName = u2;
        const type = techniqueUniforms[u2].type;
        if (((_c = uniforms[uniformName]) == null ? void 0 : _c.value) === void 0) {
          switch (type) {
            case UniformType.SAMPLER_2D:
              uniforms[uniformName] = { value: whiteDefaultTexture };
              console.warn("Missing/unassigned texture, fallback to white: " + uniformName);
              break;
            default:
              if (uniformName === "unity_OrthoParams") {
              } else
                console.warn("TODO: EXPECTED UNIFORM / fallback NOT SET: " + uniformName, techniqueUniforms[u2]);
              break;
          }
        }
      }
      if (debug75)
        console.log(material.uuid, uniforms);
      createUniformProperties(material);
      resolve2(material);
    });
  }
};
function createUniformProperties(material) {
  if (material.uniforms) {
    if (debug75)
      console.log("Uniforms:", material.uniforms);
    for (const key in material.uniforms) {
      defineProperty(key, key);
      switch (key) {
        case "_Color":
          defineProperty("color", key);
          break;
      }
    }
  }
  function defineProperty(key, uniformsKey) {
    if (!Object.getOwnPropertyDescriptor(material, key)) {
      Object.defineProperty(material, key, {
        get: () => material.uniforms[uniformsKey].value,
        set: (value) => {
          material.uniforms[uniformsKey].value = value;
          material.needsUpdate = true;
        }
      });
    }
  }
}

// node_modules/@needle-tools/engine/lib/engine/extensions/extensions.js
var debug76 = getParam("debugextensions");
var GLTFAnimationPointerExtension;
var KHR_ANIMATIONPOINTER_IMPORT = import("./GLTFLoaderAnimationPointer-PXFVHUIO.js").then(async (mod) => {
  GLTFAnimationPointerExtension = mod.GLTFAnimationPointerExtension;
  return GLTFAnimationPointerExtension;
}).catch((e) => {
  console.warn("Failed to import GLTFLoaderAnimationPointer. Please use @needle-tools/three for full KHR_animation support", e);
});
var _plugins = new Array();
function addCustomExtensionPlugin(ext) {
  if (!_plugins.includes(ext)) {
    _plugins.push(ext);
  }
}
function removeCustomImportExtensionType(ext) {
  const index = _plugins.indexOf(ext);
  if (index >= 0)
    _plugins.splice(index, 1);
}
function registerComponentExtension(loader2) {
  const ext = new NEEDLE_components();
  loader2.register((p) => {
    ext.parser = p;
    return ext;
  });
  return ext;
}
var PointerResolver = class {
  resolvePath(path) {
    if (path.includes("/extensions/builtin_components/"))
      return path.replace("/extensions/builtin_components/", "/userData/components/");
    if (path.includes("extensions/builtin_components/"))
      return path.replace("extensions/builtin_components/", "/userData/components/");
    return path;
  }
};
async function registerExtensions(loader2, context, url) {
  const idEnd = url.indexOf("?");
  if (idEnd >= 0)
    url = url.substring(0, idEnd);
  loader2.register((p) => new NEEDLE_gameobject_data(p));
  loader2.register((p) => new NEEDLE_persistent_assets(p));
  loader2.register((p) => new NEEDLE_lightmaps(p, context.lightmaps, url));
  loader2.register((p) => new NEEDLE_lighting_settings(p, url, context));
  loader2.register((p) => new NEEDLE_techniques_webgl(p, url));
  loader2.register((p) => new NEEDLE_render_objects(p, url));
  loader2.register((p) => new NEEDLE_progressive(p, url));
  loader2.register((p) => new EXT_texture_exr(p));
  if (isResourceTrackingEnabled())
    loader2.register((p) => new InternalUsageTrackerPlugin(p));
  await KHR_ANIMATIONPOINTER_IMPORT.catch((_) => {
  });
  loader2.register((p) => {
    if (GLTFAnimationPointerExtension) {
      const ext = new GLTFAnimationPointerExtension(p);
      const setPointerResolverFunction = ext.setAnimationPointerResolver;
      setPointerResolverFunction.bind(ext)(new PointerResolver());
      return ext;
    } else {
      if (debug76 || isDevEnvironment())
        console.error("Missing KHR_animation_pointer extension...");
      return {
        name: "KHR_animation_pointer_NOT_AVAILABLE"
      };
    }
  });
  for (const plugin of _plugins) {
    if (plugin.onImport)
      plugin.onImport(loader2, url, context);
  }
}
function registerExportExtensions(exp, context) {
  for (const ext of _plugins)
    if (ext.onExport)
      ext.onExport(exp, context);
}
function invokeAfterImportPluginHooks(url, gltf, context) {
  for (const ext of _plugins)
    if (ext.onLoaded)
      ext.onLoaded(url, gltf, context);
}

// node_modules/@needle-tools/engine/lib/engine-components/RendererInstancing.js
var debugInstancing = getParam("debuginstancing");
var _InstancingHandler = class {
  constructor() {
    __publicField(this, "objs", []);
  }
  setup(renderer, obj, context, handlesArray, args, level = 0) {
    renderer.applySettings(obj);
    const res = this.tryCreateOrAddInstance(obj, context, args);
    if (res) {
      if (handlesArray === null)
        handlesArray = [];
      handlesArray.push(res);
      NEEDLE_progressive.assignTextureLOD(res.renderer.material, 0);
      for (const mesh of renderer.sharedMeshes) {
        const geometry = mesh.geometry;
        NEEDLE_progressive.assignMeshLOD(mesh, 0).then((lod) => {
          if (lod && renderer.activeAndEnabled && geometry != lod) {
            res.setGeometry(lod);
          }
        });
      }
    } else if (level <= 0 && obj.type !== "Mesh") {
      const nextLevel = level + 1;
      for (const ch of obj.children) {
        handlesArray = this.setup(renderer, ch, context, handlesArray, args, nextLevel);
      }
    }
    if (level === 0) {
      if (args.useMatrixWorldAutoUpdate && handlesArray && handlesArray.length >= 0) {
        this.autoUpdateInstanceMatrix(obj);
      }
    }
    return handlesArray;
  }
  tryCreateOrAddInstance(obj, context, args) {
    if (obj.type === "Mesh") {
      const index = args.foundMeshes;
      args.foundMeshes += 1;
      if (!args.rend.enableInstancing)
        return null;
      if (args.rend.enableInstancing === true) {
      } else {
        if (index >= args.rend.enableInstancing.length) {
          if (debugInstancing)
            console.error("Something is wrong with instance setup", obj, args.rend.enableInstancing, index);
          return null;
        }
        if (!args.rend.enableInstancing[index]) {
          return null;
        }
      }
      const mesh = obj;
      const mat = mesh.material;
      for (const i2 of this.objs) {
        if (!i2.canAdd(mesh.geometry, mat))
          continue;
        const handle2 = i2.addInstance(mesh);
        return handle2;
      }
      const maxInstances = 16;
      let name = obj.name;
      if (!(name == null ? void 0 : name.length))
        name = makeIdFromRandomWords();
      const i = new InstancedMeshRenderer(name, mesh.geometry, mat, maxInstances, context);
      this.objs.push(i);
      const handle = i.addInstance(mesh);
      return handle;
    }
    return null;
  }
  autoUpdateInstanceMatrix(obj) {
    const original = obj.matrixWorld["multiplyMatrices"].bind(obj.matrixWorld);
    const previousMatrix = obj.matrixWorld.clone();
    const matrixChangeWrapper = (a, b) => {
      const newMatrixWorld = original(a, b);
      if (obj[NEED_UPDATE_INSTANCE_KEY] || previousMatrix.equals(newMatrixWorld) === false) {
        previousMatrix.copy(newMatrixWorld);
        obj[NEED_UPDATE_INSTANCE_KEY] = true;
      }
      return newMatrixWorld;
    };
    obj.matrixWorld["multiplyMatrices"] = matrixChangeWrapper;
  }
};
var InstancingHandler = _InstancingHandler;
__publicField(InstancingHandler, "instance", new _InstancingHandler());
var _InstanceHandle = class {
  constructor(originalObject, instancer) {
    /** The object that is being instanced */
    __publicField(this, "object");
    /** The instancer/BatchedMesh that is rendering this object*/
    __publicField(this, "renderer");
    /** @internal */
    __publicField(this, "__instanceIndex", -1);
    /** @internal */
    __publicField(this, "__reservedVertexRange", 0);
    /** @internal */
    __publicField(this, "__reservedIndexRange", 0);
    __publicField(this, "__geometryIndex", -1);
    /** The mesh information of the object */
    __publicField(this, "meshInformation");
    this.__instanceIndex = -1;
    this.object = originalObject;
    this.renderer = instancer;
    originalObject[$instancingRenderer] = instancer;
    this.meshInformation = getMeshInformation(originalObject.geometry);
    _InstanceHandle.all.push(this);
  }
  /** The name of the object */
  get name() {
    return this.object.name;
  }
  get isActive() {
    return this.__instanceIndex >= 0;
  }
  get vertexCount() {
    return this.object.geometry.attributes.position.count;
  }
  get maxVertexCount() {
    return this.meshInformation.vertexCount;
  }
  get reservedVertexCount() {
    return this.__reservedVertexRange;
  }
  get indexCount() {
    return this.object.geometry.index ? this.object.geometry.index.count : 0;
  }
  get maxIndexCount() {
    return this.meshInformation.indexCount;
  }
  get reservedIndexCount() {
    return this.__reservedIndexRange;
  }
  /** Updates the matrix from the rendered object. Will also call updateWorldMatrix internally */
  updateInstanceMatrix(updateChildren = false, updateMatrix = true) {
    if (this.__instanceIndex < 0)
      return;
    if (updateMatrix)
      this.object.updateWorldMatrix(true, updateChildren);
    this.renderer.updateInstance(this.object.matrixWorld, this.__instanceIndex);
  }
  /** Updates the matrix of the instance */
  setMatrix(matrix) {
    if (this.__instanceIndex < 0)
      return;
    this.renderer.updateInstance(matrix, this.__instanceIndex);
  }
  /** Can be used to change the geometry of this instance */
  setGeometry(geo) {
    if (this.__geometryIndex < 0)
      return false;
    if (this.vertexCount > this.__reservedVertexRange) {
      console.error(`Cannot update geometry, reserved vertex range is too small: ${this.__reservedVertexRange} < ${this.vertexCount} vertices for ${this.name}`);
      return false;
    }
    if (this.indexCount > this.__reservedIndexRange) {
      console.error(`Cannot update geometry, reserved index range is too small: ${this.__reservedIndexRange} < ${this.indexCount} indices for ${this.name}`);
      return false;
    }
    return this.renderer.updateGeometry(geo, this.__geometryIndex);
  }
  /** Adds this object to the instancing renderer (effectively activating instancing) */
  add() {
    if (this.__instanceIndex >= 0)
      return;
    this.renderer.add(this);
    GameObject.markAsInstancedRendered(this.object, true);
  }
  /** Removes this object from the instancing renderer */
  remove(delete_) {
    if (this.__instanceIndex < 0)
      return;
    this.renderer.remove(this, delete_);
    GameObject.markAsInstancedRendered(this.object, false);
    if (delete_) {
      const i = _InstanceHandle.all.indexOf(this);
      if (i >= 0) {
        _InstanceHandle.all.splice(i, 1);
      }
    }
  }
};
var InstanceHandle = _InstanceHandle;
__publicField(InstanceHandle, "all", []);
var InstancedMeshRenderer = class {
  constructor(name, geo, material, initialMaxCount, context) {
    /** If true, the instancer is allowed to grow when the max instance count is reached */
    __publicField(this, "allowResize", true);
    /** The name of the instancer */
    __publicField(this, "name", "");
    /** The added geometry */
    __publicField(this, "geometry");
    /** The material used for the instanced mesh */
    __publicField(this, "material");
    __publicField(this, "_context");
    __publicField(this, "_batchedMesh");
    __publicField(this, "_handles", []);
    __publicField(this, "_geometryIds", /* @__PURE__ */ new Map());
    __publicField(this, "_maxInstanceCount");
    __publicField(this, "_currentInstanceCount", 0);
    __publicField(this, "_currentVertexCount", 0);
    __publicField(this, "_currentIndexCount", 0);
    __publicField(this, "_maxVertexCount");
    __publicField(this, "_maxIndexCount");
    __publicField(this, "_needUpdateBounds", false);
    __publicField(this, "_debugMaterial", null);
    __publicField(this, "onBeforeRender", () => {
      this._batchedMesh.layers.enableAll();
      if (this._needUpdateBounds && this._batchedMesh[$instancingAutoUpdateBounds] === true) {
        if (debugInstancing)
          console.log("Update instancing bounds", this.name, this._batchedMesh.matrixWorldNeedsUpdate);
        this.updateBounds();
      }
    });
    __publicField(this, "onAfterRender", () => {
      this._batchedMesh.layers.disableAll();
    });
    __publicField(this, "_availableBuckets", new Array());
    __publicField(this, "_usedBuckets", new Array());
    this.name = name;
    this.geometry = geo;
    this.material = material;
    this._context = context;
    this._maxInstanceCount = Math.max(2, initialMaxCount);
    if (debugInstancing) {
      this._debugMaterial = createDebugMaterial();
    }
    const estimate = this.tryEstimateVertexCountSize(this._maxInstanceCount, [geo], initialMaxCount);
    this._maxVertexCount = estimate.vertexCount;
    this._maxIndexCount = estimate.indexCount;
    this._batchedMesh = new BatchedMesh(this._maxInstanceCount, this._maxVertexCount, this._maxIndexCount, this._debugMaterial ?? this.material);
    this._batchedMesh[$instancingAutoUpdateBounds] = true;
    this._batchedMesh.visible = true;
    this._context.scene.add(this._batchedMesh);
    if (material instanceof RawShaderMaterial) {
      material.defines["USE_INSTANCING"] = true;
      material.needsUpdate = true;
    }
    context.pre_render_callbacks.push(this.onBeforeRender);
    context.post_render_callbacks.push(this.onAfterRender);
    if (debugInstancing) {
      console.log(`Instanced renderer created with ${this._maxInstanceCount} instances, ${this._maxVertexCount} max vertices and ${this._maxIndexCount} max indices for "${name}"`);
    }
  }
  /** The three instanced mesh
   * @link https://threejs.org/docs/#api/en/objects/InstancedMesh
   */
  get batchedMesh() {
    return this._batchedMesh;
  }
  get visible() {
    return this._batchedMesh.visible;
  }
  set visible(val) {
    this._batchedMesh.visible = val;
  }
  get castShadow() {
    return this._batchedMesh.castShadow;
  }
  set castShadow(val) {
    this._batchedMesh.castShadow = val;
  }
  set receiveShadow(val) {
    this._batchedMesh.receiveShadow = val;
  }
  /** The current number of instances */
  get count() {
    return this._currentInstanceCount;
  }
  /** Update the bounding box and sphere of the instanced mesh
   * @param box If true, update the bounding box
   * @param sphere If true, update the bounding sphere
  */
  updateBounds(box2 = true, sphere = true) {
    this._needUpdateBounds = false;
    if (box2)
      this._batchedMesh.computeBoundingBox();
    if (sphere)
      this._batchedMesh.computeBoundingSphere();
  }
  /** Check if the geometry can be added to this instancer
   * @param geometry The geometry to check
   * @param material The material of the geometry
   * @returns true if the geometry can be added
   */
  canAdd(geometry, material) {
    if (this._maxVertexCount > 1e7)
      return false;
    if (material !== this.material)
      return false;
    if (!this.validateGeometry(geometry))
      return false;
    const hasSpace = !this.mustGrow(geometry);
    if (hasSpace)
      return true;
    if (this.allowResize)
      return true;
    return false;
  }
  dispose() {
    if (debugInstancing)
      console.warn("Dispose instanced renderer", this.name);
    this._context.scene.remove(this._batchedMesh);
    this._batchedMesh.dispose();
    this._batchedMesh = null;
    this._handles = [];
  }
  addInstance(obj) {
    const handle = new InstanceHandle(obj, this);
    if (obj.castShadow === true && this._batchedMesh.castShadow === false) {
      this._batchedMesh.castShadow = true;
    }
    if (obj.receiveShadow === true && this._batchedMesh.receiveShadow === false) {
      this._batchedMesh.receiveShadow = true;
    }
    try {
      this.add(handle);
    } catch (e) {
      console.error("Failed adding mesh to instancing\n", e);
      if (isDevEnvironment())
        showBalloonError("Failed instancing mesh. See the browser console for details.");
      return null;
    }
    return handle;
  }
  add(handle) {
    const geo = handle.object.geometry;
    if (!geo || !geo.attributes) {
      console.error("Cannot add object to instancing without geometry", handle.name);
      return false;
    }
    if (this.mustGrow(geo)) {
      if (this.allowResize) {
        this.grow(geo);
      } else {
        console.error("Cannot add instance, max count reached", this.name, this.count, this._maxInstanceCount);
        return false;
      }
    }
    handle.object.updateWorldMatrix(true, true);
    this.addGeometry(handle);
    this._handles[handle.__instanceIndex] = handle;
    this._currentInstanceCount += 1;
    this.markNeedsUpdate();
    if (this._currentInstanceCount > 0)
      this._batchedMesh.visible = true;
    return true;
  }
  remove(handle, delete_) {
    if (!handle) {
      return;
    }
    if (handle.__instanceIndex < 0 || this._handles[handle.__instanceIndex] != handle || this._currentInstanceCount <= 0) {
      return;
    }
    this.removeGeometry(handle, delete_);
    this._handles[handle.__instanceIndex] = null;
    handle.__instanceIndex = -1;
    if (this._currentInstanceCount > 0) {
      this._currentInstanceCount -= 1;
    }
    if (this._currentInstanceCount <= 0)
      this._batchedMesh.visible = false;
    this.markNeedsUpdate();
  }
  updateInstance(mat, index) {
    this._batchedMesh.setMatrixAt(index, mat);
    this.markNeedsUpdate();
  }
  updateGeometry(geo, index) {
    if (!this.validateGeometry(geo)) {
      return false;
    }
    if (this.mustGrow()) {
      this.grow(geo);
    }
    if (debugInstancing)
      console.debug("UPDATE MESH", index, this._batchedMesh["_geometryCount"], geo.name, getMeshInformation(geo), geo.attributes.position.count, geo.index ? geo.index.count : 0);
    this._batchedMesh.setGeometryAt(index, geo);
    this.markNeedsUpdate();
    return true;
  }
  validateGeometry(geometry) {
    const batchGeometry = this.geometry;
    for (const attributeName in batchGeometry.attributes) {
      if (attributeName === "batchId") {
        continue;
      }
      if (!geometry.hasAttribute(attributeName)) {
        if (isDevEnvironment())
          console.warn(`BatchedMesh: Added geometry missing "${attributeName}". All geometries must have consistent attributes.`);
        return false;
      }
    }
    return true;
  }
  markNeedsUpdate() {
    if (debugInstancing)
      console.warn("Marking instanced mesh dirty", this.name);
    this._needUpdateBounds = true;
  }
  /**
   * @param geo The geometry to add (if none is provided it means the geometry is already added and just updated)
   */
  mustGrow(geo) {
    if (this.count >= this._maxInstanceCount)
      return true;
    if (!geo || !geo.attributes)
      return false;
    const meshInfo = getMeshInformation(geo);
    const newVertexCount = meshInfo.vertexCount;
    const newIndexCount = meshInfo.indexCount;
    return this._currentVertexCount + newVertexCount > this._maxVertexCount || this._currentIndexCount + newIndexCount > this._maxIndexCount;
  }
  grow(geometry) {
    const newSize = this._maxInstanceCount * 2;
    const estimatedSpace = this.tryEstimateVertexCountSize(newSize, [geometry]);
    const newMaxVertexCount = Math.max(this._maxVertexCount, estimatedSpace.vertexCount);
    const newMaxIndexCount = Math.max(this._maxIndexCount, estimatedSpace.indexCount, this._maxVertexCount * 2);
    if (debugInstancing) {
      const geometryInfo = getMeshInformation(geometry);
      console.warn(`Growing batched mesh for "${this.name}/${geometry.name}" ${geometryInfo.vertexCount} vertices, ${geometryInfo.indexCount} indices
Max count ${this._maxInstanceCount} → ${newSize}
Max vertex count ${this._maxVertexCount} -> ${newMaxVertexCount}
Max index count ${this._maxIndexCount} -> ${newMaxIndexCount}`);
      this._debugMaterial = createDebugMaterial();
    }
    this._maxVertexCount = newMaxVertexCount;
    this._maxIndexCount = newMaxIndexCount;
    const newInst = new BatchedMesh(newSize, this._maxVertexCount, this._maxIndexCount, this._debugMaterial ?? this.material);
    newInst.layers = this._batchedMesh.layers;
    newInst.castShadow = this._batchedMesh.castShadow;
    newInst.receiveShadow = this._batchedMesh.receiveShadow;
    newInst.visible = this._batchedMesh.visible;
    newInst[$instancingAutoUpdateBounds] = this._batchedMesh[$instancingAutoUpdateBounds];
    newInst.matrixAutoUpdate = this._batchedMesh.matrixAutoUpdate;
    newInst.matrixWorldNeedsUpdate = this._batchedMesh.matrixWorldNeedsUpdate;
    newInst.matrixAutoUpdate = this._batchedMesh.matrixAutoUpdate;
    newInst.matrixWorld.copy(this._batchedMesh.matrixWorld);
    newInst.matrix.copy(this._batchedMesh.matrix);
    this._batchedMesh.dispose();
    this._batchedMesh.removeFromParent();
    this._geometryIds.clear();
    this._batchedMesh = newInst;
    this._maxInstanceCount = newSize;
    this._usedBuckets.length = 0;
    this._availableBuckets.length = 0;
    const original = [...this._handles];
    this._handles = [];
    for (const handle of original) {
      if (handle && handle.__instanceIndex >= 0) {
        this.addGeometry(handle);
        this._handles[handle.__instanceIndex] = handle;
      }
    }
    this._context.scene.add(newInst);
  }
  tryEstimateVertexCountSize(newMaxInstances, _newGeometries, newGeometriesFactor = 1) {
    const usedGeometries = /* @__PURE__ */ new Map();
    for (const handle of this._handles) {
      if (handle && handle.__instanceIndex >= 0 && handle.object.geometry) {
        if (!usedGeometries.has(handle.object.geometry)) {
          const data = getMeshInformation(handle.object.geometry);
          const meshinfo = { count: 1, ...data };
          usedGeometries.set(handle.object.geometry, meshinfo);
        } else {
          const entry = usedGeometries.get(handle.object.geometry);
          entry.count += 1;
        }
      }
    }
    let totalVertices = 0;
    let totalIndices = 0;
    for (const [_geo, data] of usedGeometries) {
      totalVertices += data.vertexCount * data.count;
      totalIndices += data.indexCount * data.count;
    }
    const averageVerts = Math.ceil(totalVertices / Math.max(1, this._currentInstanceCount));
    let maxVertexCount = averageVerts * newMaxInstances;
    const averageIndices = Math.ceil(totalIndices / Math.max(1, this._currentInstanceCount));
    let maxIndexCount = averageIndices * newMaxInstances * 2;
    if (_newGeometries) {
      for (const geo of _newGeometries) {
        const meshinfo = getMeshInformation(geo);
        if (meshinfo != null) {
          maxVertexCount += meshinfo.vertexCount * newGeometriesFactor;
          maxIndexCount += meshinfo.indexCount * newGeometriesFactor;
        }
      }
    }
    return { vertexCount: maxVertexCount, indexCount: maxIndexCount };
  }
  addGeometry(handle) {
    const geo = handle.object.geometry;
    if (!geo) {
      return;
    }
    let smallestBucket = null;
    let smallestBucketIndex = -1;
    for (let i2 = this._availableBuckets.length - 1; i2 >= 0; i2--) {
      const bucket = this._availableBuckets[i2];
      if (bucket.vertexCount >= handle.maxVertexCount && bucket.indexCount >= handle.maxIndexCount) {
        if (smallestBucket == null || bucket.vertexCount < smallestBucket.vertexCount) {
          smallestBucket = bucket;
          smallestBucketIndex = i2;
        }
      }
    }
    if (smallestBucket != null) {
      const bucket = smallestBucket;
      if (debugInstancing)
        console.debug(`RE-USE SPACE #${bucket.geometryIndex}, ${handle.maxVertexCount} vertices, ${handle.maxIndexCount} indices, ${handle.name}`);
      try {
        this._batchedMesh.setGeometryAt(bucket.geometryIndex, handle.object.geometry);
        const newIndex = this._batchedMesh.addInstance(bucket.geometryIndex);
        this._batchedMesh.setMatrixAt(newIndex, handle.object.matrixWorld);
        this._batchedMesh.setVisibleAt(newIndex, true);
        handle.__instanceIndex = newIndex;
        this._usedBuckets[bucket.geometryIndex] = bucket;
        this._availableBuckets.splice(smallestBucketIndex, 1);
        return;
      } catch (err) {
        if (debugInstancing)
          console.error("Failed to re-use space", err);
        else if (isDevEnvironment() && err instanceof Error) {
          console.warn(`Failed to re-use space "${err.message}" in bucket ${bucket.geometryIndex} (${bucket.vertexCount}) - will add new geometry instead`);
        }
      }
    }
    if (debugInstancing)
      console.debug("ADD GEOMETRY", geo.name, "\nvertex:", `${this._currentVertexCount} + ${handle.maxVertexCount} < ${this._maxVertexCount}?`, "\nindex:", handle.maxIndexCount, this._currentIndexCount, this._maxIndexCount);
    let geometryId = this._geometryIds.get(geo);
    if (geometryId === void 0 || geometryId === null) {
      geometryId = this._batchedMesh.addGeometry(geo, handle.maxVertexCount, handle.maxIndexCount);
      this._geometryIds.set(geo, geometryId);
    }
    const i = this._batchedMesh.addInstance(geometryId);
    handle.__geometryIndex = geometryId;
    handle.__instanceIndex = i;
    handle.__reservedVertexRange = handle.maxVertexCount;
    handle.__reservedIndexRange = handle.maxIndexCount;
    this._currentVertexCount += handle.maxVertexCount;
    this._currentIndexCount += handle.maxIndexCount;
    this._usedBuckets[i] = { geometryIndex: geometryId, vertexCount: handle.maxVertexCount, indexCount: handle.maxIndexCount };
    this._batchedMesh.setMatrixAt(i, handle.object.matrixWorld);
    if (debugInstancing)
      console.debug(`ADD MESH & RESERVE SPACE #${i}, ${handle.maxVertexCount} vertices, ${handle.maxIndexCount} indices, ${handle.name} ${handle.object.uuid}`);
  }
  removeGeometry(handle, _del) {
    if (handle.__instanceIndex < 0) {
      console.warn("Cannot remove geometry, instance index is invalid", handle.name);
      return;
    }
    this._usedBuckets.splice(handle.__instanceIndex, 1);
    this._batchedMesh.deleteInstance(handle.__instanceIndex);
    this._availableBuckets.push({
      geometryIndex: handle.__geometryIndex,
      vertexCount: handle.reservedVertexCount,
      indexCount: handle.reservedIndexCount
    });
  }
};
__publicField(InstancedMeshRenderer, "nullMatrix", new Matrix4());
function getMeshInformation(geo) {
  var _a2, _b;
  if (!geo) {
    if (isDevEnvironment())
      console.error("Cannot get mesh information from null geometry");
    return { vertexCount: 0, indexCount: 0 };
  }
  let vertexCount = ((_b = (_a2 = geo.attributes) == null ? void 0 : _a2.position) == null ? void 0 : _b.count) || 0;
  let indexCount = geo.index ? geo.index.count : 0;
  const lodInfo = NEEDLE_progressive.getMeshLODInformation(geo);
  if (lodInfo) {
    const lod0 = lodInfo.lods[0];
    let lod0Count = lod0.vertexCount;
    let lod0IndexCount = lod0.indexCount;
    const extra = Math.min(128, Math.ceil(lod0Count * 0.15));
    lod0Count += extra;
    lod0IndexCount += 20;
    vertexCount = Math.max(vertexCount, lod0Count);
    indexCount = Math.max(indexCount, lod0IndexCount);
  }
  vertexCount = Math.ceil(vertexCount);
  indexCount = Math.ceil(indexCount);
  return { vertexCount, indexCount };
}
function createDebugMaterial() {
  const mat = new MeshStandardMaterial({ color: new Color(Math.random(), Math.random(), Math.random()) });
  mat.emissive = mat.color;
  mat.emissiveIntensity = 0.3;
  if (getParam("wireframe"))
    mat.wireframe = true;
  return mat;
}

// node_modules/@needle-tools/engine/lib/engine-components/RendererLightmap.js
var debug77 = getParam("debuglightmaps");
var RendererLightmap = class {
  constructor(gameObject, context) {
    __publicField(this, "lightmapIndex", -1);
    __publicField(this, "lightmapScaleOffset", new Vector4(1, 1, 0, 0));
    __publicField(this, "context");
    __publicField(this, "gameObject");
    __publicField(this, "lightmapTexture", null);
    __publicField(this, "lightmapScaleOffsetUniform", { value: new Vector4(1, 1, 0, 0) });
    __publicField(this, "lightmapUniform", { value: null });
    __publicField(this, "onBeforeCompile", (shader, _) => {
      if (debug77)
        console.log("Lightmaps, before compile\n", shader);
      this.lightmapScaleOffsetUniform.value = this.lightmapScaleOffset;
      this.lightmapUniform.value = this.lightmapTexture;
      shader.uniforms.lightmapScaleOffset = this.lightmapScaleOffsetUniform;
    });
    this.gameObject = gameObject;
    this.context = context;
  }
  get lightmap() {
    return this.lightmapTexture;
  }
  set lightmap(tex) {
    if (tex !== this.lightmapTexture) {
      this.lightmapTexture = tex;
      this.applyLightmap();
      if (this.lightmapTexture) {
        NEEDLE_progressive.assignTextureLOD(this.lightmapTexture, 0).then((res) => {
          if (res == null ? void 0 : res.isTexture)
            this.lightmapTexture = res;
        });
      }
    }
  }
  init(lightmapIndex, lightmapScaleOffset, lightmapTexture) {
    console.assert(this.gameObject !== void 0 && this.gameObject !== null, "Missing gameobject", this);
    this.lightmapIndex = lightmapIndex;
    if (this.lightmapIndex < 0)
      return;
    this.lightmapScaleOffset = lightmapScaleOffset;
    this.lightmapTexture = lightmapTexture;
    NEEDLE_progressive.assignTextureLOD(lightmapTexture, 0).then((res) => {
      if (res == null ? void 0 : res.isTexture)
        this.lightmapTexture = res;
    });
    if (debug77 == "show") {
      console.log("Lightmap:", this.gameObject.name, lightmapIndex, "\nScaleOffset:", lightmapScaleOffset, "\nTexture:", lightmapTexture);
      this.setLightmapDebugMaterial();
    } else if (debug77)
      console.log("Use debuglightmaps=show to render lightmaps only in the scene.");
    this.applyLightmap();
  }
  updateLightmapUniforms(material) {
    const uniforms = material["uniforms"];
    if (uniforms && uniforms.lightmap) {
      this.lightmapScaleOffsetUniform.value = this.lightmapScaleOffset;
      uniforms.lightmapScaleOffset = this.lightmapScaleOffsetUniform;
    }
  }
  /**
   * Apply the lightmap to the object. This will clone the material and set the lightmap texture and scale/offset
   */
  applyLightmap() {
    if (this.gameObject.type === "Object3D") {
      if (debug77)
        console.warn("Can not add lightmap. Is this object missing a renderer?", this.gameObject.name);
      return;
    }
    if (this.gameObject.type === "Group") {
      if (this.gameObject["Needle:Multimaterial-LightmapWarning"] === void 0) {
        this.gameObject["Needle:Multimaterial-LightmapWarning"] = true;
        console.warn("Lightmap on multimaterial object is not supported yet... please open a feature request on https://github.com/needle-tools/needle-engine-support if your project requires it");
      }
      return;
    }
    console.assert(this.gameObject.type === "Mesh", "Lightmap only works on meshes", this);
    const mesh = this.gameObject;
    if (!mesh.geometry.getAttribute("uv1"))
      mesh.geometry.setAttribute("uv1", mesh.geometry.getAttribute("uv"));
    if (Array.isArray(this.gameObject.material)) {
      const mats = this.gameObject.material;
      for (let i = 0; i < mats.length; i++) {
        mats[i] = this.ensureLightmapMaterial(mats[i]);
      }
    } else {
      this.gameObject.material = this.ensureLightmapMaterial(this.gameObject.material);
    }
    if (this.lightmapIndex >= 0 && this.lightmapTexture) {
      this.lightmapTexture.channel = 1;
      const mat = this.gameObject.material;
      if (Array.isArray(mat)) {
        for (const entry of mat) {
          this.assignLightmapTexture(entry);
        }
      } else if (mat) {
        this.assignLightmapTexture(mat);
      }
    }
  }
  ensureLightmapMaterial(material) {
    if (!material.userData)
      material.userData = {};
    if (material["NEEDLE:lightmap-material-version"] != material.version) {
      if (material["NEEDLE:lightmap-material-version"] == void 0) {
        if (debug77)
          console.warn("Cloning material for lightmap " + material.name);
        const mat = material.clone();
        material = mat;
        material.onBeforeCompile = this.onBeforeCompile;
      } else {
      }
    }
    return material;
  }
  assignLightmapTexture(material) {
    if (!material)
      return;
    if (material instanceof MeshPhysicalMaterial && material.transmission > 0) {
      return;
    }
    const hasChanged = material.lightMap !== this.lightmapTexture || material["NEEDLE:lightmap-material-version"] !== material.version;
    if (!hasChanged) {
      return;
    }
    if (debug77)
      console.log("Assigning lightmap", material.name, material.version);
    material.lightMap = this.lightmapTexture;
    material["NEEDLE:lightmap-material-version"] = material.version;
  }
  setLightmapDebugMaterial() {
    this.gameObject["material"] = new ShaderMaterial({
      vertexShader: `
                varying vec2 vUv1;
                void main()
                {
                    vUv1 = uv1;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
                `,
      fragmentShader: `
                uniform sampler2D lightMap;
                uniform float lightMapIntensity;
                uniform vec4 lightmapScaleOffset;
                varying vec2 vUv1;

                // took from threejs 05fc79cd52b79e8c3e8dec1e7dca72c5c39983a4
                vec4 conv_sRGBToLinear( in vec4 value ) {
                    return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
                }

                void main() {
                    vec2 lUv = vUv1.xy * lightmapScaleOffset.xy + vec2(lightmapScaleOffset.z, (1. - (lightmapScaleOffset.y + lightmapScaleOffset.w)));
                    
                    vec4 lightMapTexel = texture2D( lightMap, lUv);
                    gl_FragColor = lightMapTexel;
                    gl_FragColor.a = 1.;
                }
                `,
      defines: { USE_LIGHTMAP: "" }
    });
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/Renderer.js
var __decorate43 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debugRenderer = getParam("debugrenderer");
var debugskinnedmesh = getParam("debugskinnedmesh");
var suppressInstancing = getParam("noinstancing");
var showWireframe = getParam("wireframe");
var ReflectionProbeUsage;
(function(ReflectionProbeUsage2) {
  ReflectionProbeUsage2[ReflectionProbeUsage2["Off"] = 0] = "Off";
  ReflectionProbeUsage2[ReflectionProbeUsage2["BlendProbes"] = 1] = "BlendProbes";
  ReflectionProbeUsage2[ReflectionProbeUsage2["BlendProbesAndSkybox"] = 2] = "BlendProbesAndSkybox";
  ReflectionProbeUsage2[ReflectionProbeUsage2["Simple"] = 3] = "Simple";
})(ReflectionProbeUsage || (ReflectionProbeUsage = {}));
var FieldWithDefault = class {
  constructor() {
    __publicField(this, "path", null);
    __publicField(this, "asset", null);
    __publicField(this, "default");
  }
};
var RenderState;
(function(RenderState2) {
  RenderState2[RenderState2["Both"] = 0] = "Both";
  RenderState2[RenderState2["Back"] = 1] = "Back";
  RenderState2[RenderState2["Front"] = 2] = "Front";
})(RenderState || (RenderState = {}));
var SharedMaterialArray = class {
  constructor(renderer, originalMaterials) {
    __publicField(this, "_renderer");
    __publicField(this, "_targets", []);
    __publicField(this, "_indexMapMaxIndex");
    __publicField(this, "_indexMap");
    __publicField(this, "_changed", false);
    this._renderer = renderer;
    const setMaterial = this.setMaterial.bind(this);
    const getMaterial = this.getMaterial.bind(this);
    const go = renderer.gameObject;
    this._targets = [];
    if (go) {
      switch (go.type) {
        case "Group":
          this._targets = [...go.children];
          break;
        case "SkinnedMesh":
        case "Mesh":
          this._targets.push(go);
          break;
      }
    }
    let hasMissingMaterials = false;
    let indexMap = void 0;
    let maxIndex = 0;
    for (let i = 0; i < this._targets.length; i++) {
      const target = this._targets[i];
      if (!target)
        continue;
      const mat = target.material;
      if (!mat)
        continue;
      mat.shadowSide = mat.side;
      for (let k = 0; k < originalMaterials.length; k++) {
        const orig = originalMaterials[k];
        if (!orig) {
          hasMissingMaterials = true;
          continue;
        }
        if (mat.name === orig.name) {
          if (indexMap === void 0)
            indexMap = /* @__PURE__ */ new Map();
          indexMap.set(k, i);
          maxIndex = Math.max(maxIndex, k);
          break;
        }
      }
    }
    if (hasMissingMaterials) {
      this._indexMapMaxIndex = maxIndex;
      this._indexMap = indexMap;
      const warningMessage = `Renderer ${renderer.name} was initialized with missing materials - this may lead to unexpected behaviour when trying to access sharedMaterials by index.`;
      console.warn(warningMessage);
      if (isLocalNetwork())
        showBalloonWarning("Found renderer with missing materials: please check the console for details.");
    }
    return new Proxy(this, {
      get(target, key) {
        if (typeof key === "string") {
          const index = parseInt(key);
          if (!isNaN(index)) {
            return getMaterial(index);
          }
        }
        return target[key];
      },
      set(target, key, value) {
        if (typeof key === "string")
          setMaterial(value, Number.parseInt(key));
        if (Reflect.set(target, key, value)) {
          if (value instanceof Material)
            target.changed = true;
          return true;
        }
        return false;
      }
    });
  }
  get changed() {
    return this._changed;
  }
  set changed(value) {
    if (value === true) {
      if (debugRenderer)
        console.warn("SharedMaterials have changed: " + this._renderer.name, this);
    }
    this._changed = value;
  }
  is(renderer) {
    return this._renderer === renderer;
  }
  get length() {
    if (this._indexMapMaxIndex !== void 0)
      return this._indexMapMaxIndex + 1;
    return this._targets.length;
  }
  // iterator to support: for(const mat of sharedMaterials)
  *[Symbol.iterator]() {
    for (let i = 0; i < this.length; i++) {
      yield this.getMaterial(i);
    }
  }
  resolveIndex(index) {
    const map = this._indexMap;
    if (map) {
      if (map.has(index))
        return map.get(index);
    }
    return index;
  }
  setMaterial(mat, index) {
    index = this.resolveIndex(index);
    if (index < 0 || index >= this._targets.length)
      return;
    const target = this._targets[index];
    if (!target || target["material"] === void 0)
      return;
    target["material"] = mat;
    this.changed = true;
  }
  getMaterial(index) {
    index = this.resolveIndex(index);
    if (index < 0)
      return null;
    const obj = this._targets;
    if (index >= obj.length)
      return null;
    const target = obj[index];
    if (!target)
      return null;
    return target["material"];
  }
};
var Renderer = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "receiveShadows", false);
    __publicField(this, "shadowCastingMode", ShadowCastingMode.Off);
    __publicField(this, "lightmapIndex", -1);
    __publicField(this, "lightmapScaleOffset", new Vector4(1, 1, 0, 0));
    /** If the renderer should use instancing
     * If this is a boolean (true) all materials will be instanced or (false) none of them.
     * If this is an array of booleans the materials will be instanced based on the index of the material.
     */
    __publicField(this, "enableInstancing");
    __publicField(this, "renderOrder");
    __publicField(this, "allowOcclusionWhenDynamic", true);
    __publicField(this, "probeAnchor");
    __publicField(this, "reflectionProbeUsage", ReflectionProbeUsage.Off);
    // custom shader
    // get materialProperties(): Array<MaterialProperties> | undefined {
    //     return this._materialProperties;
    // }
    // set materialProperties(value: Array<MaterialProperties> | undefined) {
    //     this._materialProperties = value;
    // }
    // private customShaderHandler: RendererCustomShader | undefined = undefined;
    // private _materialProperties: Array<MaterialProperties> | undefined = undefined;
    __publicField(this, "_lightmaps");
    __publicField(this, "_sharedMeshes", []);
    __publicField(this, "_sharedMaterials");
    __publicField(this, "_originalMaterials");
    __publicField(this, "_probeAnchorLastFrame");
    __publicField(this, "_lightmapTextureOverride");
    __publicField(this, "allowProgressiveLoading", true);
    __publicField(this, "_firstFrame", -1);
    __publicField(this, "_isInstancingEnabled", false);
    __publicField(this, "_handles");
    __publicField(this, "_handlesTempArray", []);
    __publicField(this, "onBeforeRenderThree", (_renderer3, _scene, _camera2, _geometry2, material, _group) => {
      var _a2;
      if (material.envMapIntensity !== void 0) {
        const factor = this.hasLightmap ? Math.PI : 1;
        const environmentIntensity = ((_a2 = this.context.mainCameraComponent) == null ? void 0 : _a2.environmentIntensity) ?? 1;
        material.envMapIntensity = Math.max(0, environmentIntensity * this.context.sceneLighting.environmentIntensity / factor);
      }
      if (this._lightmaps) {
        for (const lm of this._lightmaps) {
          lm.updateLightmapUniforms(material);
          lm.applyLightmap();
        }
      }
    });
    __publicField(this, "_reflectionProbe", null);
  }
  /** Enable or disable instancing for an object. This will create a Renderer component if it does not exist yet.
   * @returns the Renderer component that was created or already existed on the object
   */
  static setInstanced(obj, enableInstancing) {
    const renderer = getOrAddComponent(obj, Renderer);
    renderer.setInstancingEnabled(enableInstancing);
    return renderer;
  }
  /** Check if an object is currently rendered using instancing
   * @returns true if the object is rendered using instancing
   */
  static isInstanced(obj) {
    const renderer = getComponent(obj, Renderer);
    if (renderer)
      return renderer.isInstancingActive;
    return InstancingUtil.isUsingInstancing(obj);
  }
  /** Set the rendering state only of an object (makes it visible or invisible) without affecting component state or child hierarchy visibility! You can also just enable/disable the Renderer component on that object for the same effect!
   *
   * If you want to activate or deactivate a complete object you can use obj.visible as usual (it acts the same as setActive in Unity) */
  static setVisible(obj, visible) {
    setCustomVisibility(obj, visible);
  }
  /** Get the mesh Object3D for this renderer
   * Warn: if this is a multimaterial object it will return the first mesh only
   * @returns a mesh object3D.
   * */
  get sharedMesh() {
    if (this.gameObject.type === "Mesh") {
      return this.gameObject;
    } else if (this.gameObject.type === "SkinnesMesh") {
      return this.gameObject;
    } else if (this.gameObject.type === "Group") {
      return this.gameObject.children[0];
    }
    return void 0;
  }
  /** Get all the mesh Object3D for this renderer
   * @returns an array of mesh object3D.
   */
  get sharedMeshes() {
    if (this.destroyed || !this.gameObject)
      return this._sharedMeshes;
    this._sharedMeshes.length = 0;
    if (this.gameObject.type === "Group") {
      for (const ch of this.gameObject.children) {
        if (ch.type === "Mesh" || ch.type === "SkinnedMesh") {
          this._sharedMeshes.push(ch);
        }
      }
    } else if (this.gameObject.type === "Mesh" || this.gameObject.type === "SkinnedMesh") {
      this._sharedMeshes.push(this.gameObject);
    }
    return this._sharedMeshes;
  }
  get sharedMaterial() {
    return this.sharedMaterials[0];
  }
  set sharedMaterial(mat) {
    const cur = this.sharedMaterials[0];
    if (cur === mat)
      return;
    this.sharedMaterials[0] = mat;
    this.applyLightmapping();
  }
  /**@deprecated please use sharedMaterial */
  get material() {
    return this.sharedMaterials[0];
  }
  /**@deprecated please use sharedMaterial */
  set material(mat) {
    this.sharedMaterial = mat;
  }
  // this is just available during deserialization
  set sharedMaterials(_val) {
    if (!this._originalMaterials) {
      this._originalMaterials = _val;
    } else if (_val) {
      let didWarn = false;
      for (let i = 0; i < this._sharedMaterials.length; i++) {
        const mat = i < _val.length ? _val[i] : null;
        if (mat && mat instanceof Material) {
          this.sharedMaterials[i] = mat;
        } else {
          if (!didWarn) {
            didWarn = true;
            console.warn("Can not assign null as material: " + this.name, mat);
          }
        }
      }
    }
  }
  //@ts-ignore
  get sharedMaterials() {
    if (!this._sharedMaterials || !this._sharedMaterials.is(this)) {
      if (!this._originalMaterials)
        this._originalMaterials = [];
      this._sharedMaterials = new SharedMaterialArray(this, this._originalMaterials);
    }
    return this._sharedMaterials;
  }
  static get shouldSuppressInstancing() {
    return suppressInstancing;
  }
  get lightmap() {
    var _a2;
    if ((_a2 = this._lightmaps) == null ? void 0 : _a2.length) {
      return this._lightmaps[0].lightmap;
    }
    return null;
  }
  /** set undefined to return to default lightmap */
  set lightmap(tex) {
    var _a2;
    this._lightmapTextureOverride = tex;
    if (tex === void 0) {
      tex = this.context.lightmaps.tryGetLightmap(this.sourceId, this.lightmapIndex);
    }
    if ((_a2 = this._lightmaps) == null ? void 0 : _a2.length) {
      for (const lm of this._lightmaps) {
        lm.lightmap = tex;
      }
    }
  }
  get hasLightmap() {
    const lm = this.lightmap;
    return lm !== null && lm !== void 0;
  }
  registering() {
    if (!this.enabled) {
      this.setVisibility(false);
    }
  }
  awake() {
    this._firstFrame = this.context.time.frame;
    if (debugRenderer)
      console.log("Renderer ", this.name, this);
    this.clearInstancingState();
    if (this.probeAnchor && debugRenderer)
      this.probeAnchor.add(new AxesHelper(0.2));
    this._reflectionProbe = null;
    if (this.isMultiMaterialObject(this.gameObject)) {
      for (const child of this.gameObject.children) {
        this.context.addBeforeRenderListener(child, this.onBeforeRenderThree);
        child.layers.mask = this.gameObject.layers.mask;
      }
      if (this.renderOrder !== void 0) {
        let index = 0;
        for (let i = 0; i < this.gameObject.children.length; i++) {
          const ch = this.gameObject.children[i];
          if (!this.isMeshOrSkinnedMesh(ch) || GameObject.getComponent(ch, Renderer))
            continue;
          if (this.renderOrder.length <= index) {
            console.warn("Incorrect renderOrder element count", this, this.renderOrder.length + " but expected " + this.gameObject.children.length, "Index: " + index, "ChildElement:", ch);
            continue;
          }
          ch.renderOrder = this.renderOrder[index];
          index += 1;
        }
      }
    } else if (this.isMeshOrSkinnedMesh(this.gameObject)) {
      this.context.addBeforeRenderListener(this.gameObject, this.onBeforeRenderThree);
      if (this.renderOrder !== void 0 && this.renderOrder.length > 0)
        this.gameObject.renderOrder = this.renderOrder[0];
    } else {
      this.context.addBeforeRenderListener(this.gameObject, this.onBeforeRenderThree);
    }
    this.applyLightmapping();
    if (showWireframe) {
      for (let i = 0; i < this.sharedMaterials.length; i++) {
        const mat = this.sharedMaterials[i];
        if (mat) {
          mat.wireframe = true;
        }
      }
    }
  }
  applyLightmapping() {
    var _a2;
    if (this.lightmapIndex >= 0) {
      const type = this.gameObject.type;
      const tex = this._lightmapTextureOverride !== void 0 ? this._lightmapTextureOverride : this.context.lightmaps.tryGetLightmap(this.sourceId, this.lightmapIndex);
      if (tex) {
        if (!this._lightmaps)
          this._lightmaps = [];
        if (type === "Mesh") {
          const mat = this.gameObject["material"];
          if (!(mat == null ? void 0 : mat.isMeshBasicMaterial)) {
            if (this._lightmaps.length <= 0) {
              const rm2 = new RendererLightmap(this.gameObject, this.context);
              this._lightmaps.push(rm2);
            }
            const rm = this._lightmaps[0];
            rm.init(this.lightmapIndex, this.lightmapScaleOffset, tex);
          } else {
            if (mat)
              console.warn("Lightmapping is not supported on MeshBasicMaterial", mat.name);
          }
        } else if (this.isMultiMaterialObject(this.gameObject) && this.sharedMaterials.length > 0) {
          for (let i = 0; i < this.gameObject.children.length; i++) {
            const child = this.gameObject.children[i];
            if (!((_a2 = child["material"]) == null ? void 0 : _a2.isMeshBasicMaterial)) {
              let rm = void 0;
              if (i >= this._lightmaps.length) {
                rm = new RendererLightmap(child, this.context);
                this._lightmaps.push(rm);
              } else
                rm = this._lightmaps[i];
              rm.init(this.lightmapIndex, this.lightmapScaleOffset, tex);
            }
          }
        }
      } else {
        if (debugRenderer)
          console.warn("Lightmap not found", this.sourceId, this.lightmapIndex);
      }
    }
  }
  /**
   * @returns true if this renderer has instanced objects
   */
  get isInstancingActive() {
    return this._handles != void 0 && this._handles.length > 0 && this._isInstancingEnabled;
  }
  /** @returns the instancing handles */
  get instances() {
    if (!this._handles || this._handles.length <= 0) {
      return null;
    }
    this._handlesTempArray.length = 0;
    if (this._handles) {
      for (const h of this._handles) {
        this._handlesTempArray.push(h);
      }
    }
    return this._handlesTempArray;
  }
  /** Enable or disable instancing for this renderer.
   * @param enabled true to enable instancing, false to disable it
   */
  setInstancingEnabled(enabled) {
    if (this._isInstancingEnabled === enabled)
      return enabled && (this._handles === void 0 || this._handles != null && this._handles.length > 0);
    this._isInstancingEnabled = enabled;
    if (enabled) {
      if (this.enableInstancing === void 0)
        this.enableInstancing = true;
      if (this._handles === void 0) {
        this._handles = InstancingHandler.instance.setup(this, this.gameObject, this.context, null, { rend: this, foundMeshes: 0, useMatrixWorldAutoUpdate: this.useInstanceMatrixWorldAutoUpdate() });
        if (this._handles) {
          GameObject.markAsInstancedRendered(this.gameObject, true);
          return true;
        }
      } else if (this._handles !== null) {
        for (const handler of this._handles) {
          handler.updateInstanceMatrix(true);
          handler.add();
        }
        GameObject.markAsInstancedRendered(this.gameObject, true);
        return true;
      }
    } else {
      if (this._handles) {
        for (const handler of this._handles) {
          handler.remove(this.destroyed);
        }
      }
      return true;
    }
    return false;
  }
  clearInstancingState() {
    this._isInstancingEnabled = false;
    this._handles = void 0;
  }
  /** Return true to wrap matrix update events for instanced rendering to update instance matrices automatically when matrixWorld changes
   * This is a separate method to be overrideable from user code
   */
  useInstanceMatrixWorldAutoUpdate() {
    return true;
  }
  start() {
    if (this.enableInstancing && !suppressInstancing) {
      this.setInstancingEnabled(true);
      InstancingUtil.markDirty(this.gameObject);
    }
    this.gameObject.frustumCulled = this.allowOcclusionWhenDynamic;
    if (this.isMultiMaterialObject(this.gameObject)) {
      for (let i = 0; i < this.gameObject.children.length; i++) {
        const ch = this.gameObject.children[i];
        ch.frustumCulled = this.allowOcclusionWhenDynamic;
      }
    }
  }
  onEnable() {
    const _ = this.sharedMeshes;
    this.setVisibility(true);
    const isUsingInstancing2 = this._isInstancingEnabled || (this.enableInstancing == true || Array.isArray(this.enableInstancing) && this.enableInstancing.some((x2) => x2));
    if (isUsingInstancing2) {
      if (this.__internalDidAwakeAndStart)
        this.setInstancingEnabled(true);
    } else if (this.enabled) {
      this.applyStencil();
    }
    this.updateReflectionProbe();
  }
  onDisable() {
    this.setVisibility(false);
    if (this._handles && this._handles.length > 0) {
      this.setInstancingEnabled(false);
    }
  }
  onDestroy() {
    this._handles = null;
    if (this.isMultiMaterialObject(this.gameObject)) {
      for (const child of this.gameObject.children) {
        this.context.removeBeforeRenderListener(child, this.onBeforeRenderThree);
      }
    } else {
      this.context.removeBeforeRenderListener(this.gameObject, this.onBeforeRenderThree);
    }
  }
  onBeforeRender() {
    var _a2, _b, _c;
    if (!this.gameObject) {
      return;
    }
    if (this._probeAnchorLastFrame !== this.probeAnchor) {
      (_a2 = this._reflectionProbe) == null ? void 0 : _a2.onUnset(this);
      this.updateReflectionProbe();
    }
    if (debugRenderer == this.name && this.gameObject instanceof Mesh) {
      this.gameObject.geometry.computeBoundingSphere();
      const tempCenter = getTempVector(this.gameObject.geometry.boundingSphere.center).applyMatrix4(this.gameObject.matrixWorld);
      Gizmos.DrawWireSphere(tempCenter, this.gameObject.geometry.boundingSphere.radius, 56831);
    }
    if (this.isMultiMaterialObject(this.gameObject) && ((_b = this.gameObject.children) == null ? void 0 : _b.length) > 0) {
      for (const ch of this.gameObject.children) {
        this.applySettings(ch);
      }
    } else {
      this.applySettings(this.gameObject);
    }
    if (this.sharedMaterials.changed) {
      this.sharedMaterials.changed = false;
      this.applyLightmapping();
    }
    if ((_c = this._handles) == null ? void 0 : _c.length) {
      const needsUpdate = this.gameObject[NEED_UPDATE_INSTANCE_KEY] === true;
      if (needsUpdate) {
        this.gameObject[NEED_UPDATE_INSTANCE_KEY] = false;
        const remove = false;
        for (let i = this._handles.length - 1; i >= 0; i--) {
          const h = this._handles[i];
          if (remove) {
            h.remove(this.destroyed);
            this._handles.splice(i, 1);
          } else
            h.updateInstanceMatrix();
        }
        this.gameObject.matrixWorldNeedsUpdate = false;
      }
    }
    if (this._handles && this._handles.length <= 0) {
      GameObject.markAsInstancedRendered(this.gameObject, false);
    }
    if (this._isInstancingEnabled && this._handles) {
      for (let i = 0; i < this._handles.length; i++) {
        const handle = this._handles[i];
        setCustomVisibility(handle.object, false);
      }
    }
    if (this.reflectionProbeUsage !== ReflectionProbeUsage.Off && this._reflectionProbe) {
      this._reflectionProbe.onSet(this);
    }
  }
  onAfterRender() {
    if (this._isInstancingEnabled && this._handles) {
      for (let i = 0; i < this._handles.length; i++) {
        const handle = this._handles[i];
        setCustomVisibility(handle.object, true);
      }
    }
    if (this.reflectionProbeUsage !== ReflectionProbeUsage.Off && this._reflectionProbe) {
      this._reflectionProbe.onUnset(this);
    }
    if (this.static && this.gameObject.matrixAutoUpdate) {
      this.gameObject.matrixAutoUpdate = false;
    }
  }
  /** Applies stencil settings for this renderer's objects (if stencil settings are available) */
  applyStencil() {
    NEEDLE_render_objects.applyStencil(this);
  }
  /** Apply the settings of this renderer to the given object
   * Settings include shadow casting and receiving (e.g. this.receiveShadows, this.shadowCastingMode)
   */
  applySettings(go) {
    go.receiveShadow = this.receiveShadows;
    if (this.shadowCastingMode == ShadowCastingMode.On) {
      go.castShadow = true;
    } else
      go.castShadow = false;
  }
  updateReflectionProbe() {
    this._reflectionProbe = null;
    if (this.reflectionProbeUsage !== ReflectionProbeUsage.Off) {
      this.startCoroutine(this._updateReflectionProbe(), FrameEvent.LateUpdate);
      this._probeAnchorLastFrame = this.probeAnchor;
    }
  }
  *_updateReflectionProbe() {
    const obj = this.probeAnchor || this.gameObject;
    const isAnchor = this.probeAnchor ? true : false;
    this._reflectionProbe = ReflectionProbe.get(obj, this.context, isAnchor, this.probeAnchor);
  }
  setVisibility(visible) {
    if (!this.isMultiMaterialObject(this.gameObject)) {
      setCustomVisibility(this.gameObject, visible);
    } else {
      for (const ch of this.gameObject.children) {
        if (this.isMeshOrSkinnedMesh(ch)) {
          setCustomVisibility(ch, visible);
        }
      }
    }
  }
  isMultiMaterialObject(obj) {
    return obj.type === "Group";
  }
  isMeshOrSkinnedMesh(obj) {
    return obj.type === "Mesh" || obj.type === "SkinnedMesh";
  }
};
__decorate43([
  serializable()
], Renderer.prototype, "receiveShadows", void 0);
__decorate43([
  serializable()
], Renderer.prototype, "shadowCastingMode", void 0);
__decorate43([
  serializable()
], Renderer.prototype, "lightmapIndex", void 0);
__decorate43([
  serializable(Vector4)
], Renderer.prototype, "lightmapScaleOffset", void 0);
__decorate43([
  serializable()
], Renderer.prototype, "enableInstancing", void 0);
__decorate43([
  serializable()
], Renderer.prototype, "renderOrder", void 0);
__decorate43([
  serializable()
], Renderer.prototype, "allowOcclusionWhenDynamic", void 0);
__decorate43([
  serializable(Object3D)
], Renderer.prototype, "probeAnchor", void 0);
__decorate43([
  serializable()
], Renderer.prototype, "reflectionProbeUsage", void 0);
var MeshRenderer = class extends Renderer {
};
var SkinnedMeshRenderer = class extends MeshRenderer {
  constructor() {
    super(...arguments);
    __publicField(this, "_needUpdateBoundingSphere", false);
  }
  // private _lastWorldPosition = new Vector3();
  awake() {
    var _a2;
    super.awake();
    if (debugskinnedmesh)
      console.log('SkinnedMeshRenderer for "' + this.name + '"', this);
    this.allowOcclusionWhenDynamic = false;
    for (const mesh of this.sharedMeshes) {
      (_a2 = mesh.parent) == null ? void 0 : _a2.updateWorldMatrix(false, true);
      this.markBoundsDirty();
    }
  }
  onAfterRender() {
    super.onAfterRender();
    if (this._needUpdateBoundingSphere) {
      for (const mesh of this.sharedMeshes) {
        if (mesh instanceof SkinnedMesh) {
          this._needUpdateBoundingSphere = false;
          const geometry = mesh.geometry;
          const raycastmesh = getRaycastMesh(mesh);
          if (raycastmesh)
            mesh.geometry = raycastmesh;
          mesh.computeBoundingSphere();
          mesh.geometry = geometry;
        }
      }
    }
    if (debugskinnedmesh) {
      for (const mesh of this.sharedMeshes) {
        if (mesh instanceof SkinnedMesh && mesh.boundingSphere) {
          const tempCenter = getTempVector(mesh.boundingSphere.center).applyMatrix4(mesh.matrixWorld);
          Gizmos.DrawWireSphere(tempCenter, mesh.boundingSphere.radius, "red");
        }
      }
    }
  }
  markBoundsDirty() {
    this._needUpdateBoundingSphere = true;
  }
};
var ShadowCastingMode;
(function(ShadowCastingMode2) {
  ShadowCastingMode2[ShadowCastingMode2["Off"] = 0] = "Off";
  ShadowCastingMode2[ShadowCastingMode2["On"] = 1] = "On";
  ShadowCastingMode2[ShadowCastingMode2["TwoSided"] = 2] = "TwoSided";
  ShadowCastingMode2[ShadowCastingMode2["ShadowsOnly"] = 3] = "ShadowsOnly";
})(ShadowCastingMode || (ShadowCastingMode = {}));

// node_modules/@needle-tools/engine/lib/engine-components/particlesystem/ParticleSystemModules.js
var __decorate44 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug78 = getParam("debugparticles");
var ParticleSystemRenderMode;
(function(ParticleSystemRenderMode2) {
  ParticleSystemRenderMode2[ParticleSystemRenderMode2["Billboard"] = 0] = "Billboard";
  ParticleSystemRenderMode2[ParticleSystemRenderMode2["Stretch"] = 1] = "Stretch";
  ParticleSystemRenderMode2[ParticleSystemRenderMode2["HorizontalBillboard"] = 2] = "HorizontalBillboard";
  ParticleSystemRenderMode2[ParticleSystemRenderMode2["VerticalBillboard"] = 3] = "VerticalBillboard";
  ParticleSystemRenderMode2[ParticleSystemRenderMode2["Mesh"] = 4] = "Mesh";
})(ParticleSystemRenderMode || (ParticleSystemRenderMode = {}));
var Gradient = class {
  constructor() {
    __publicField(this, "alphaKeys", []);
    __publicField(this, "colorKeys", []);
  }
  get duration() {
    return 1;
  }
  evaluate(time, target) {
    let closestAlpha = void 0;
    let closestAlphaIndex = 0;
    let closestColor = null;
    let closestColorIndex = 0;
    for (let i = 0; i < this.alphaKeys.length; i++) {
      const key = this.alphaKeys[i];
      if (key.time < time || !closestAlpha) {
        closestAlpha = key;
        closestAlphaIndex = i;
      }
    }
    for (let i = 0; i < this.colorKeys.length; i++) {
      const key = this.colorKeys[i];
      if (key.time < time || !closestColor) {
        closestColor = key;
        closestColorIndex = i;
      }
    }
    if (closestColor) {
      const hasNextColor = closestColorIndex + 1 < this.colorKeys.length;
      if (hasNextColor) {
        const nextColor = this.colorKeys[closestColorIndex + 1];
        const t2 = Mathf.remap(time, closestColor.time, nextColor.time, 0, 1);
        target.r = Mathf.lerp(closestColor.color.r, nextColor.color.r, t2);
        target.g = Mathf.lerp(closestColor.color.g, nextColor.color.g, t2);
        target.b = Mathf.lerp(closestColor.color.b, nextColor.color.b, t2);
      } else {
        target.r = closestColor.color.r;
        target.g = closestColor.color.g;
        target.b = closestColor.color.b;
      }
    }
    if (closestAlpha) {
      const hasNextAlpha = closestAlphaIndex + 1 < this.alphaKeys.length;
      if (hasNextAlpha) {
        const nextAlpha = this.alphaKeys[closestAlphaIndex + 1];
        const t2 = Mathf.remap(time, closestAlpha.time, nextAlpha.time, 0, 1);
        target.alpha = Mathf.lerp(closestAlpha.alpha, nextAlpha.alpha, t2);
      } else {
        target.alpha = closestAlpha.alpha;
      }
    }
    return target;
  }
};
__decorate44([
  serializable()
], Gradient.prototype, "alphaKeys", void 0);
__decorate44([
  serializable()
], Gradient.prototype, "colorKeys", void 0);
var ParticleSystemCurveMode;
(function(ParticleSystemCurveMode2) {
  ParticleSystemCurveMode2[ParticleSystemCurveMode2["Constant"] = 0] = "Constant";
  ParticleSystemCurveMode2[ParticleSystemCurveMode2["Curve"] = 1] = "Curve";
  ParticleSystemCurveMode2[ParticleSystemCurveMode2["TwoCurves"] = 2] = "TwoCurves";
  ParticleSystemCurveMode2[ParticleSystemCurveMode2["TwoConstants"] = 3] = "TwoConstants";
})(ParticleSystemCurveMode || (ParticleSystemCurveMode = {}));
var ParticleSystemGradientMode;
(function(ParticleSystemGradientMode2) {
  ParticleSystemGradientMode2[ParticleSystemGradientMode2["Color"] = 0] = "Color";
  ParticleSystemGradientMode2[ParticleSystemGradientMode2["Gradient"] = 1] = "Gradient";
  ParticleSystemGradientMode2[ParticleSystemGradientMode2["TwoColors"] = 2] = "TwoColors";
  ParticleSystemGradientMode2[ParticleSystemGradientMode2["TwoGradients"] = 3] = "TwoGradients";
  ParticleSystemGradientMode2[ParticleSystemGradientMode2["RandomColor"] = 4] = "RandomColor";
})(ParticleSystemGradientMode || (ParticleSystemGradientMode = {}));
var ParticleSystemSimulationSpace;
(function(ParticleSystemSimulationSpace2) {
  ParticleSystemSimulationSpace2[ParticleSystemSimulationSpace2["Local"] = 0] = "Local";
  ParticleSystemSimulationSpace2[ParticleSystemSimulationSpace2["World"] = 1] = "World";
  ParticleSystemSimulationSpace2[ParticleSystemSimulationSpace2["Custom"] = 2] = "Custom";
})(ParticleSystemSimulationSpace || (ParticleSystemSimulationSpace = {}));
var ParticleSystemShapeType;
(function(ParticleSystemShapeType2) {
  ParticleSystemShapeType2[ParticleSystemShapeType2["Sphere"] = 0] = "Sphere";
  ParticleSystemShapeType2[ParticleSystemShapeType2["SphereShell"] = 1] = "SphereShell";
  ParticleSystemShapeType2[ParticleSystemShapeType2["Hemisphere"] = 2] = "Hemisphere";
  ParticleSystemShapeType2[ParticleSystemShapeType2["HemisphereShell"] = 3] = "HemisphereShell";
  ParticleSystemShapeType2[ParticleSystemShapeType2["Cone"] = 4] = "Cone";
  ParticleSystemShapeType2[ParticleSystemShapeType2["Box"] = 5] = "Box";
  ParticleSystemShapeType2[ParticleSystemShapeType2["Mesh"] = 6] = "Mesh";
  ParticleSystemShapeType2[ParticleSystemShapeType2["ConeShell"] = 7] = "ConeShell";
  ParticleSystemShapeType2[ParticleSystemShapeType2["ConeVolume"] = 8] = "ConeVolume";
  ParticleSystemShapeType2[ParticleSystemShapeType2["ConeVolumeShell"] = 9] = "ConeVolumeShell";
  ParticleSystemShapeType2[ParticleSystemShapeType2["Circle"] = 10] = "Circle";
  ParticleSystemShapeType2[ParticleSystemShapeType2["CircleEdge"] = 11] = "CircleEdge";
  ParticleSystemShapeType2[ParticleSystemShapeType2["SingleSidedEdge"] = 12] = "SingleSidedEdge";
  ParticleSystemShapeType2[ParticleSystemShapeType2["MeshRenderer"] = 13] = "MeshRenderer";
  ParticleSystemShapeType2[ParticleSystemShapeType2["SkinnedMeshRenderer"] = 14] = "SkinnedMeshRenderer";
  ParticleSystemShapeType2[ParticleSystemShapeType2["BoxShell"] = 15] = "BoxShell";
  ParticleSystemShapeType2[ParticleSystemShapeType2["BoxEdge"] = 16] = "BoxEdge";
  ParticleSystemShapeType2[ParticleSystemShapeType2["Donut"] = 17] = "Donut";
  ParticleSystemShapeType2[ParticleSystemShapeType2["Rectangle"] = 18] = "Rectangle";
  ParticleSystemShapeType2[ParticleSystemShapeType2["Sprite"] = 19] = "Sprite";
  ParticleSystemShapeType2[ParticleSystemShapeType2["SpriteRenderer"] = 20] = "SpriteRenderer";
})(ParticleSystemShapeType || (ParticleSystemShapeType = {}));
var ParticleSystemShapeMultiModeValue;
(function(ParticleSystemShapeMultiModeValue2) {
  ParticleSystemShapeMultiModeValue2[ParticleSystemShapeMultiModeValue2["Random"] = 0] = "Random";
  ParticleSystemShapeMultiModeValue2[ParticleSystemShapeMultiModeValue2["Loop"] = 1] = "Loop";
  ParticleSystemShapeMultiModeValue2[ParticleSystemShapeMultiModeValue2["PingPong"] = 2] = "PingPong";
  ParticleSystemShapeMultiModeValue2[ParticleSystemShapeMultiModeValue2["BurstSpread"] = 3] = "BurstSpread";
})(ParticleSystemShapeMultiModeValue || (ParticleSystemShapeMultiModeValue = {}));
var MinMaxCurve = class {
  constructor() {
    __publicField(this, "mode", "Constant");
    __publicField(this, "constant");
    __publicField(this, "constantMin");
    __publicField(this, "constantMax");
    __publicField(this, "curve");
    __publicField(this, "curveMin");
    __publicField(this, "curveMax");
    __publicField(this, "curveMultiplier");
  }
  static constant(val) {
    const obj = new MinMaxCurve();
    obj.setConstant(val);
    return obj;
  }
  static betweenTwoConstants(min, max) {
    const obj = new MinMaxCurve();
    obj.setMinMaxConstant(min, max);
    return obj;
  }
  static curve(curve, multiplier = 1) {
    const obj = new MinMaxCurve();
    obj.setCurve(curve, multiplier);
    return obj;
  }
  setConstant(val) {
    this.mode = ParticleSystemCurveMode.Constant;
    this.constant = val;
  }
  setMinMaxConstant(min, max) {
    this.mode = ParticleSystemCurveMode.TwoConstants;
    this.constantMin = min;
    this.constantMax = max;
  }
  setCurve(curve, multiplier = 1) {
    this.mode = ParticleSystemCurveMode.Curve;
    this.curve = curve;
    this.curveMultiplier = multiplier;
  }
  clone() {
    var _a2, _b, _c;
    const clone = new MinMaxCurve();
    clone.mode = this.mode;
    clone.constant = this.constant;
    clone.constantMin = this.constantMin;
    clone.constantMax = this.constantMax;
    clone.curve = (_a2 = this.curve) == null ? void 0 : _a2.clone();
    clone.curveMin = (_b = this.curveMin) == null ? void 0 : _b.clone();
    clone.curveMax = (_c = this.curveMax) == null ? void 0 : _c.clone();
    clone.curveMultiplier = this.curveMultiplier;
    return clone;
  }
  evaluate(t01, lerpFactor) {
    const t2 = lerpFactor === void 0 ? Math.random() : lerpFactor;
    switch (this.mode) {
      case ParticleSystemCurveMode.Constant:
      case "Constant":
        return this.constant;
      case ParticleSystemCurveMode.Curve:
      case "Curve":
        t01 = Mathf.clamp01(t01);
        return this.curve.evaluate(t01) * this.curveMultiplier;
      case ParticleSystemCurveMode.TwoCurves:
      case "TwoCurves":
        const t1 = t01 * this.curveMin.duration;
        const t22 = t01 * this.curveMax.duration;
        return Mathf.lerp(this.curveMin.evaluate(t1), this.curveMax.evaluate(t22), t2 % 1) * this.curveMultiplier;
      case ParticleSystemCurveMode.TwoConstants:
      case "TwoConstants":
        return Mathf.lerp(this.constantMin, this.constantMax, t2 % 1);
      default:
        this.curveMax.evaluate(t01) * this.curveMultiplier;
        break;
    }
    return 0;
  }
  getMax() {
    switch (this.mode) {
      case ParticleSystemCurveMode.Constant:
      case "Constant":
        return this.constant;
      case ParticleSystemCurveMode.Curve:
      case "Curve":
        return this.getMaxFromCurve(this.curve) * this.curveMultiplier;
      case ParticleSystemCurveMode.TwoCurves:
      case "TwoCurves":
        return Math.max(this.getMaxFromCurve(this.curveMin), this.getMaxFromCurve(this.curveMax)) * this.curveMultiplier;
      case ParticleSystemCurveMode.TwoConstants:
      case "TwoConstants":
        return Math.max(this.constantMin, this.constantMax);
      default:
        return 0;
    }
  }
  getMaxFromCurve(curve) {
    if (!curve)
      return 0;
    let maxNumber = Number.MIN_VALUE;
    for (let i = 0; i < curve.keys.length; i++) {
      const key = curve.keys[i];
      if (key.value > maxNumber) {
        maxNumber = key.value;
      }
    }
    return maxNumber;
  }
};
__decorate44([
  serializable()
], MinMaxCurve.prototype, "mode", void 0);
__decorate44([
  serializable()
], MinMaxCurve.prototype, "constant", void 0);
__decorate44([
  serializable()
], MinMaxCurve.prototype, "constantMin", void 0);
__decorate44([
  serializable()
], MinMaxCurve.prototype, "constantMax", void 0);
__decorate44([
  serializable(AnimationCurve)
], MinMaxCurve.prototype, "curve", void 0);
__decorate44([
  serializable(AnimationCurve)
], MinMaxCurve.prototype, "curveMin", void 0);
__decorate44([
  serializable(AnimationCurve)
], MinMaxCurve.prototype, "curveMax", void 0);
__decorate44([
  serializable()
], MinMaxCurve.prototype, "curveMultiplier", void 0);
var _MinMaxGradient = class {
  constructor() {
    /**
     * The mode of the gradient, which can be Color, Gradient, TwoColors or TwoGradients.
     */
    __publicField(this, "mode", ParticleSystemGradientMode.Color);
    __publicField(this, "color");
    __publicField(this, "colorMin");
    __publicField(this, "colorMax");
    __publicField(this, "gradient");
    __publicField(this, "gradientMin");
    __publicField(this, "gradientMax");
  }
  static constant(color2) {
    const obj = new _MinMaxGradient();
    obj.constant(color2);
    return obj;
  }
  static betweenTwoColors(color1, color2) {
    const obj = new _MinMaxGradient();
    obj.betweenTwoColors(color1, color2);
    return obj;
  }
  constant(color2) {
    this.mode = ParticleSystemGradientMode.Color;
    this.color = color2;
    return this;
  }
  betweenTwoColors(color1, color2) {
    this.mode = ParticleSystemGradientMode.TwoColors;
    this.colorMin = color1;
    this.colorMax = color2;
    return this;
  }
  evaluate(t01, lerpFactor) {
    const t2 = lerpFactor === void 0 ? Math.random() : lerpFactor;
    switch (this.mode) {
      case ParticleSystemGradientMode.Color:
      case "Color":
        return this.color;
      case ParticleSystemGradientMode.Gradient:
      case "Gradient":
        this.gradient.evaluate(t01, _MinMaxGradient._temp);
        return _MinMaxGradient._temp;
      case ParticleSystemGradientMode.TwoColors:
      case "TwoColors":
        const col1 = _MinMaxGradient._temp.lerpColors(this.colorMin, this.colorMax, t2);
        return col1;
      case ParticleSystemGradientMode.TwoGradients:
      case "TwoGradients":
        this.gradientMin.evaluate(t01, _MinMaxGradient._temp);
        this.gradientMax.evaluate(t01, _MinMaxGradient._temp2);
        return _MinMaxGradient._temp.lerp(_MinMaxGradient._temp2, t2);
    }
    _MinMaxGradient._temp.set(16711935);
    _MinMaxGradient._temp.alpha = 1;
    return _MinMaxGradient._temp;
  }
};
var MinMaxGradient = _MinMaxGradient;
__publicField(MinMaxGradient, "_temp", new RGBAColor(0, 0, 0, 1));
__publicField(MinMaxGradient, "_temp2", new RGBAColor(0, 0, 0, 1));
__decorate44([
  serializable()
], MinMaxGradient.prototype, "mode", void 0);
__decorate44([
  serializable(RGBAColor)
], MinMaxGradient.prototype, "color", void 0);
__decorate44([
  serializable(RGBAColor)
], MinMaxGradient.prototype, "colorMin", void 0);
__decorate44([
  serializable(RGBAColor)
], MinMaxGradient.prototype, "colorMax", void 0);
__decorate44([
  serializable(Gradient)
], MinMaxGradient.prototype, "gradient", void 0);
__decorate44([
  serializable(Gradient)
], MinMaxGradient.prototype, "gradientMin", void 0);
__decorate44([
  serializable(Gradient)
], MinMaxGradient.prototype, "gradientMax", void 0);
var ParticleSystemScalingMode;
(function(ParticleSystemScalingMode2) {
  ParticleSystemScalingMode2[ParticleSystemScalingMode2["Hierarchy"] = 0] = "Hierarchy";
  ParticleSystemScalingMode2[ParticleSystemScalingMode2["Local"] = 1] = "Local";
  ParticleSystemScalingMode2[ParticleSystemScalingMode2["Shape"] = 2] = "Shape";
})(ParticleSystemScalingMode || (ParticleSystemScalingMode = {}));
var MainModule = class {
  constructor() {
    __publicField(this, "cullingMode");
    __publicField(this, "duration");
    __publicField(this, "emitterVelocityMode");
    __publicField(this, "flipRotation");
    __publicField(this, "gravityModifier");
    __publicField(this, "gravityModifierMultiplier");
    __publicField(this, "loop");
    __publicField(this, "maxParticles");
    __publicField(this, "playOnAwake");
    __publicField(this, "prewarm");
    __publicField(this, "ringBufferLoopRange");
    __publicField(this, "ringBufferMode");
    __publicField(this, "scalingMode");
    __publicField(this, "simulationSpace");
    __publicField(this, "simulationSpeed");
    __publicField(this, "startColor");
    __publicField(this, "startDelay");
    __publicField(this, "startDelayMultiplier");
    __publicField(this, "startLifetime");
    __publicField(this, "startLifetimeMultiplier");
    __publicField(this, "startRotation");
    __publicField(this, "startRotationMultiplier");
    __publicField(this, "startRotation3D");
    __publicField(this, "startRotationX");
    __publicField(this, "startRotationXMultiplier");
    __publicField(this, "startRotationY");
    __publicField(this, "startRotationYMultiplier");
    __publicField(this, "startRotationZ");
    __publicField(this, "startRotationZMultiplier");
    __publicField(this, "startSize");
    __publicField(this, "startSize3D");
    __publicField(this, "startSizeMultiplier");
    __publicField(this, "startSizeX");
    __publicField(this, "startSizeXMultiplier");
    __publicField(this, "startSizeY");
    __publicField(this, "startSizeYMultiplier");
    __publicField(this, "startSizeZ");
    __publicField(this, "startSizeZMultiplier");
    __publicField(this, "startSpeed");
    __publicField(this, "startSpeedMultiplier");
    __publicField(this, "stopAction");
    __publicField(this, "useUnscaledTime");
  }
};
__decorate44([
  serializable(MinMaxCurve)
], MainModule.prototype, "gravityModifier", void 0);
__decorate44([
  serializable(MinMaxGradient)
], MainModule.prototype, "startColor", void 0);
__decorate44([
  serializable(MinMaxCurve)
], MainModule.prototype, "startDelay", void 0);
__decorate44([
  serializable(MinMaxCurve)
], MainModule.prototype, "startLifetime", void 0);
__decorate44([
  serializable(MinMaxCurve)
], MainModule.prototype, "startRotation", void 0);
__decorate44([
  serializable(MinMaxCurve)
], MainModule.prototype, "startRotationX", void 0);
__decorate44([
  serializable(MinMaxCurve)
], MainModule.prototype, "startRotationY", void 0);
__decorate44([
  serializable(MinMaxCurve)
], MainModule.prototype, "startRotationZ", void 0);
__decorate44([
  serializable(MinMaxCurve)
], MainModule.prototype, "startSize", void 0);
__decorate44([
  serializable(MinMaxCurve)
], MainModule.prototype, "startSizeX", void 0);
__decorate44([
  serializable(MinMaxCurve)
], MainModule.prototype, "startSizeY", void 0);
__decorate44([
  serializable(MinMaxCurve)
], MainModule.prototype, "startSizeZ", void 0);
__decorate44([
  serializable(MinMaxCurve)
], MainModule.prototype, "startSpeed", void 0);
var ParticleBurst = class {
  constructor() {
    __publicField(this, "cycleCount");
    __publicField(this, "maxCount");
    __publicField(this, "minCount");
    __publicField(this, "probability");
    __publicField(this, "repeatInterval");
    __publicField(this, "time");
    __publicField(this, "count");
    __publicField(this, "_performed", 0);
  }
  reset() {
    this._performed = 0;
  }
  run(time) {
    if (time <= this.time) {
      return 0;
    }
    let amount = 0;
    if (this.cycleCount === 0 || this._performed < this.cycleCount) {
      const nextTime = this.time + this.repeatInterval * this._performed;
      if (time >= nextTime) {
        this._performed += 1;
        if (Math.random() < this.probability) {
          switch (this.count.mode) {
            case ParticleSystemCurveMode.Constant:
              amount = this.count.constant;
              break;
            case ParticleSystemCurveMode.TwoConstants:
              amount = Mathf.lerp(this.count.constantMin, this.count.constantMax, Math.random());
              break;
            case ParticleSystemCurveMode.Curve:
              amount = this.count.curve.evaluate(Math.random());
              break;
            case ParticleSystemCurveMode.TwoCurves:
              const t2 = Math.random();
              amount = Mathf.lerp(this.count.curveMin.evaluate(t2), this.count.curveMax.evaluate(t2), Math.random());
              break;
          }
        }
      }
    }
    return amount;
  }
};
var EmissionModule = class {
  constructor() {
    __publicField(this, "enabled");
    __publicField(this, "bursts");
    __publicField(this, "rateOverTime");
    __publicField(this, "rateOverTimeMultiplier");
    __publicField(this, "rateOverDistance");
    __publicField(this, "rateOverDistanceMultiplier");
    /** set from system */
    __publicField(this, "system");
  }
  get burstCount() {
    var _a2;
    return ((_a2 = this.bursts) == null ? void 0 : _a2.length) ?? 0;
  }
  reset() {
    var _a2;
    (_a2 = this.bursts) == null ? void 0 : _a2.forEach((b) => b.reset());
  }
  getBurst() {
    let amount = 0;
    if (this.burstCount > 0) {
      for (let i = 0; i < this.burstCount; i++) {
        const burst = this.bursts[i];
        if (this.system.main.loop && burst.time >= this.system.time) {
          burst.reset();
        }
        amount += Math.round(burst.run(this.system.time));
      }
    }
    return amount;
  }
};
__decorate44([
  serializable()
], EmissionModule.prototype, "enabled", void 0);
__decorate44([
  serializable()
], EmissionModule.prototype, "bursts", void 0);
__decorate44([
  serializable(MinMaxCurve)
], EmissionModule.prototype, "rateOverTime", void 0);
__decorate44([
  serializable()
], EmissionModule.prototype, "rateOverTimeMultiplier", void 0);
__decorate44([
  serializable(MinMaxCurve)
], EmissionModule.prototype, "rateOverDistance", void 0);
__decorate44([
  serializable()
], EmissionModule.prototype, "rateOverDistanceMultiplier", void 0);
var ColorOverLifetimeModule = class {
  constructor() {
    __publicField(this, "enabled");
    __publicField(this, "color");
  }
};
__decorate44([
  serializable(MinMaxGradient)
], ColorOverLifetimeModule.prototype, "color", void 0);
var SizeOverLifetimeModule = class {
  constructor() {
    __publicField(this, "enabled");
    __publicField(this, "separateAxes");
    __publicField(this, "size");
    __publicField(this, "sizeMultiplier");
    __publicField(this, "x");
    __publicField(this, "xMultiplier");
    __publicField(this, "y");
    __publicField(this, "yMultiplier");
    __publicField(this, "z");
    __publicField(this, "zMultiplier");
    __publicField(this, "_time", 0);
    __publicField(this, "_temp", new Vector32());
  }
  evaluate(t01, target, lerpFactor) {
    if (!target)
      target = this._temp;
    if (!this.enabled) {
      target.x = target.y = target.z = 1;
      return target;
    }
    if (!this.separateAxes) {
      const scale = this.size.evaluate(t01, lerpFactor) * this.sizeMultiplier;
      target.x = scale;
    } else {
      target.x = this.x.evaluate(t01, lerpFactor) * this.xMultiplier;
      target.y = this.y.evaluate(t01, lerpFactor) * this.yMultiplier;
      target.z = this.z.evaluate(t01, lerpFactor) * this.zMultiplier;
    }
    return target;
  }
};
__decorate44([
  serializable(MinMaxCurve)
], SizeOverLifetimeModule.prototype, "size", void 0);
__decorate44([
  serializable(MinMaxCurve)
], SizeOverLifetimeModule.prototype, "x", void 0);
__decorate44([
  serializable(MinMaxCurve)
], SizeOverLifetimeModule.prototype, "y", void 0);
__decorate44([
  serializable(MinMaxCurve)
], SizeOverLifetimeModule.prototype, "z", void 0);
var ParticleSystemMeshShapeType;
(function(ParticleSystemMeshShapeType2) {
  ParticleSystemMeshShapeType2[ParticleSystemMeshShapeType2["Vertex"] = 0] = "Vertex";
  ParticleSystemMeshShapeType2[ParticleSystemMeshShapeType2["Edge"] = 1] = "Edge";
  ParticleSystemMeshShapeType2[ParticleSystemMeshShapeType2["Triangle"] = 2] = "Triangle";
})(ParticleSystemMeshShapeType || (ParticleSystemMeshShapeType = {}));
var _ShapeModule = class {
  constructor() {
    // EmitterShape end
    __publicField(this, "shapeType", ParticleSystemShapeType.Box);
    __publicField(this, "enabled", true);
    __publicField(this, "alignToDirection", false);
    __publicField(this, "angle", 0);
    __publicField(this, "arc", 360);
    __publicField(this, "arcSpread");
    __publicField(this, "arcSpeedMultiplier");
    __publicField(this, "arcMode");
    __publicField(this, "boxThickness");
    __publicField(this, "position");
    __publicField(this, "rotation");
    __publicField(this, "_rotation", new Euler());
    __publicField(this, "scale");
    __publicField(this, "radius");
    __publicField(this, "radiusThickness");
    __publicField(this, "sphericalDirectionAmount");
    __publicField(this, "randomDirectionAmount");
    __publicField(this, "randomPositionAmount");
    /** Controls if particles should spawn off vertices, faces or edges. `shapeType` must be set to `MeshRenderer` */
    __publicField(this, "meshShapeType");
    /** When assigned and `shapeType` is set to `MeshRenderer` particles will spawn using a mesh in the scene.
     * Use the `meshShapeType` to choose if particles should be spawned from vertices, faces or edges
     * To re-assign use the `setMesh` function to cache the mesh and geometry
     * */
    __publicField(this, "meshRenderer");
    __publicField(this, "_meshObj");
    __publicField(this, "_meshGeometry");
    __publicField(this, "system");
    __publicField(this, "_space");
    __publicField(this, "_worldSpaceMatrix", new Matrix4());
    __publicField(this, "_worldSpaceMatrixInverse", new Matrix4());
    /** nebula implementations: */
    /** initializer implementation */
    __publicField(this, "_vector", new Vector32(0, 0, 0));
    __publicField(this, "_temp", new Vector32(0, 0, 0));
    __publicField(this, "_triangle", new Triangle());
    __publicField(this, "_dir", new Vector32());
    __publicField(this, "_loopTime", 0);
    __publicField(this, "_loopDirection", 1);
    if (debug78)
      console.log(this);
  }
  // Emittershape start
  get type() {
    return ParticleSystemShapeType[this.shapeType];
  }
  initialize(particle) {
    this.onInitialize(particle);
    particle.position.x = this._vector.x;
    particle.position.y = this._vector.y;
    particle.position.z = this._vector.z;
  }
  toJSON() {
    return this;
  }
  clone() {
    return new _ShapeModule();
  }
  setMesh(mesh) {
    this.meshRenderer = mesh;
    if (mesh) {
      this._meshObj = mesh.sharedMeshes[Math.floor(Math.random() * mesh.sharedMeshes.length)];
      this._meshGeometry = this._meshObj.geometry;
    } else {
      this._meshObj = void 0;
      this._meshGeometry = void 0;
    }
  }
  update(_system, _delta2) {
    throw new Error("Method not implemented: use onUpdate");
  }
  onUpdate(system, _context, simulationSpace, obj) {
    this.system = system;
    this._space = simulationSpace;
    if (simulationSpace === ParticleSystemSimulationSpace.World) {
      this._worldSpaceMatrix.copy(obj.matrixWorld);
      this._worldSpaceMatrix.elements[0] = 1;
      this._worldSpaceMatrix.elements[5] = 1;
      this._worldSpaceMatrix.elements[10] = 1;
      this._worldSpaceMatrixInverse.copy(this._worldSpaceMatrix).invert();
    }
  }
  applyRotation(vector) {
    const isRotated = this.rotation.x !== 0 || this.rotation.y !== 0 || this.rotation.z !== 0;
    if (isRotated) {
      this._rotation.x = Mathf.toRadians(this.rotation.x);
      this._rotation.y = Mathf.toRadians(this.rotation.y);
      this._rotation.z = Mathf.toRadians(this.rotation.z);
      this._rotation.order = "ZYX";
      vector.applyEuler(this._rotation);
    }
    return isRotated;
  }
  onInitialize(particle) {
    this._vector.set(0, 0, 0);
    particle["mesh"] = void 0;
    particle["mesh_geometry"] = void 0;
    const pos = this._temp.copy(this.position);
    const isWorldSpace = this._space === ParticleSystemSimulationSpace.World;
    if (isWorldSpace) {
      pos.applyQuaternion(this.system.worldQuaternion);
    }
    let radius = this.radius;
    if (isWorldSpace)
      radius *= this.system.worldScale.x;
    if (this.enabled) {
      switch (this.shapeType) {
        case ParticleSystemShapeType.Box:
          if (debug78)
            Gizmos.DrawWireBox(this.position, this.scale, 14540253, 1);
          this._vector.x = Math.random() * this.scale.x - this.scale.x / 2;
          this._vector.y = Math.random() * this.scale.y - this.scale.y / 2;
          this._vector.z = Math.random() * this.scale.z - this.scale.z / 2;
          this._vector.add(pos);
          break;
        case ParticleSystemShapeType.Cone:
          this.randomConePoint(this.position, this.angle, radius, this.radiusThickness, this.arc, this.arcMode, this._vector);
          break;
        case ParticleSystemShapeType.Sphere:
          this.randomSpherePoint(this.position, radius, this.radiusThickness, this.arc, this._vector);
          break;
        case ParticleSystemShapeType.Circle:
          this.randomCirclePoint(this.position, radius, this.radiusThickness, this.arc, this._vector);
          break;
        case ParticleSystemShapeType.MeshRenderer:
          const renderer = this.meshRenderer;
          if ((renderer == null ? void 0 : renderer.destroyed) == false)
            this.setMesh(renderer);
          const mesh = particle["mesh"] = this._meshObj;
          const geometry = particle["mesh_geometry"] = this._meshGeometry;
          if (mesh && geometry) {
            switch (this.meshShapeType) {
              case ParticleSystemMeshShapeType.Vertex:
                {
                  const vertices = geometry.getAttribute("position");
                  const index = Math.floor(Math.random() * vertices.count);
                  this._vector.fromBufferAttribute(vertices, index);
                  this._vector.applyMatrix4(mesh.matrixWorld);
                  particle["mesh_normal"] = index;
                }
                break;
              case ParticleSystemMeshShapeType.Edge:
                break;
              case ParticleSystemMeshShapeType.Triangle:
                {
                  const faces = geometry.index;
                  if (faces) {
                    let u2 = Math.random();
                    let v4 = Math.random();
                    if (u2 + v4 > 1) {
                      u2 = 1 - u2;
                      v4 = 1 - v4;
                    }
                    const faceIndex = Math.floor(Math.random() * (faces.count / 3));
                    let i0 = faceIndex * 3;
                    let i1 = faceIndex * 3 + 1;
                    let i2 = faceIndex * 3 + 2;
                    i0 = faces.getX(i0);
                    i1 = faces.getX(i1);
                    i2 = faces.getX(i2);
                    const positionAttribute = geometry.getAttribute("position");
                    this._triangle.a.fromBufferAttribute(positionAttribute, i0);
                    this._triangle.b.fromBufferAttribute(positionAttribute, i1);
                    this._triangle.c.fromBufferAttribute(positionAttribute, i2);
                    this._vector.set(0, 0, 0).addScaledVector(this._triangle.a, u2).addScaledVector(this._triangle.b, v4).addScaledVector(this._triangle.c, 1 - (u2 + v4));
                    this._vector.applyMatrix4(mesh.matrixWorld);
                    particle["mesh_normal"] = faceIndex;
                  }
                }
                break;
            }
          }
          break;
        default:
          this._vector.set(0, 0, 0);
          if (isDevEnvironment() && !globalThis["__particlesystem_shapetype_unsupported"]) {
            console.warn("ParticleSystem ShapeType is not supported:", ParticleSystemShapeType[this.shapeType]);
            globalThis["__particlesystem_shapetype_unsupported"] = true;
          }
          break;
      }
      this.randomizePosition(this._vector, this.randomPositionAmount);
    }
    this.applyRotation(this._vector);
    if (isWorldSpace) {
      this._vector.applyQuaternion(this.system.worldQuaternion);
      this._vector.add(this.system.worldPos);
    }
    if (debug78) {
      Gizmos.DrawSphere(this._vector, 0.03, 16711680, 0.5, true);
    }
  }
  getDirection(particle, pos) {
    var _a2;
    if (!this.enabled) {
      this._dir.set(0, 0, 1);
      return this._dir;
    }
    switch (this.shapeType) {
      case ParticleSystemShapeType.Box:
        this._dir.set(0, 0, 1);
        break;
      case ParticleSystemShapeType.Cone:
        this._dir.set(0, 0, 1);
        break;
      case ParticleSystemShapeType.Circle:
      case ParticleSystemShapeType.Sphere:
        const rx = pos.x;
        const ry = pos.y;
        const rz = pos.z;
        this._dir.set(rx, ry, rz);
        if ((_a2 = this.system) == null ? void 0 : _a2.worldspace)
          this._dir.sub(this.system.worldPos);
        else
          this._dir.sub(this.position);
        break;
      case ParticleSystemShapeType.MeshRenderer:
        const mesh = particle["mesh"];
        const geometry = particle["mesh_geometry"];
        if (mesh && geometry) {
          switch (this.meshShapeType) {
            case ParticleSystemMeshShapeType.Vertex:
              {
                const normal = geometry.getAttribute("normal");
                const index = particle["mesh_normal"];
                this._dir.fromBufferAttribute(normal, index);
              }
              break;
            case ParticleSystemMeshShapeType.Edge:
              break;
            case ParticleSystemMeshShapeType.Triangle:
              {
                const faces = geometry.index;
                if (faces) {
                  const index = particle["mesh_normal"];
                  const i0 = faces.getX(index * 3);
                  const i1 = faces.getX(index * 3 + 1);
                  const i2 = faces.getX(index * 3 + 2);
                  const positionAttribute = geometry.getAttribute("position");
                  const a = getTempVector();
                  const b = getTempVector();
                  const c2 = getTempVector();
                  a.fromBufferAttribute(positionAttribute, i0);
                  b.fromBufferAttribute(positionAttribute, i1);
                  c2.fromBufferAttribute(positionAttribute, i2);
                  a.sub(b);
                  c2.sub(b);
                  a.cross(c2);
                  this._dir.copy(a).multiplyScalar(-1);
                  const rot = getWorldQuaternion(mesh);
                  this._dir.applyQuaternion(rot);
                }
              }
              break;
          }
        }
        break;
      default:
        this._dir.set(0, 0, 1);
        break;
    }
    if (this._space === ParticleSystemSimulationSpace.World) {
      this._dir.applyQuaternion(this.system.worldQuaternion);
    }
    this.applyRotation(this._dir);
    this._dir.normalize();
    this.spherizeDirection(this._dir, this.sphericalDirectionAmount);
    this.randomizeDirection(this._dir, this.randomDirectionAmount);
    if (debug78) {
      Gizmos.DrawSphere(pos, 0.01, 8925952, 0.5, true);
      Gizmos.DrawDirection(pos, this._dir, 8925952, 0.5, true);
    }
    return this._dir;
  }
  randomizePosition(pos, amount) {
    if (amount <= 0)
      return;
    const rp = _ShapeModule._tempVec;
    rp.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);
    rp.x *= amount * this.scale.x;
    rp.y *= amount * this.scale.y;
    rp.z *= amount * this.scale.z;
    pos.add(rp);
  }
  randomizeDirection(direction, amount) {
    if (amount === 0)
      return;
    const randomQuat = _ShapeModule._randomQuat;
    const tempVec4 = _ShapeModule._tempVec;
    tempVec4.set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
    randomQuat.setFromAxisAngle(tempVec4, amount * Math.random() * Math.PI);
    direction.applyQuaternion(randomQuat);
  }
  spherizeDirection(dir, amount) {
    if (amount === 0)
      return;
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos(1 - Math.random() * 2);
    const x2 = Math.sin(phi) * Math.cos(theta);
    const y = Math.sin(phi) * Math.sin(theta);
    const z = Math.cos(phi);
    const v4 = new Vector32(x2, y, z);
    dir.lerp(v4, amount);
  }
  randomSpherePoint(pos, radius, thickness, arc, vec2) {
    const u2 = Math.random();
    const v4 = Math.random();
    const theta = 2 * Math.PI * u2 * (arc / 360);
    const phi = Math.acos(2 * v4 - 1);
    const r = Mathf.lerp(1, 1 - Math.pow(1 - Math.random(), Math.PI), thickness) * radius;
    const x2 = pos.x + this.scale.x * (-r * Math.sin(phi) * Math.cos(theta));
    const y = pos.y + this.scale.y * (r * Math.sin(phi) * Math.sin(theta));
    const z = pos.z + this.scale.z * (r * Math.cos(phi));
    vec2.x = x2;
    vec2.y = y;
    vec2.z = z;
  }
  randomCirclePoint(pos, radius, thickness, arg, vec2) {
    const u2 = Math.random();
    const theta = 2 * Math.PI * u2 * (arg / 360);
    const r = Mathf.lerp(1, 1 - Math.pow(1 - Math.random(), Math.PI), thickness) * radius;
    const x2 = pos.x + this.scale.x * r * Math.cos(theta);
    const y = pos.y + this.scale.y * r * Math.sin(theta);
    const z = pos.z;
    vec2.x = x2;
    vec2.y = y;
    vec2.z = z;
  }
  randomConePoint(pos, _angle, radius, thickness, arc, arcMode, vec2) {
    let u2 = 0;
    let v4 = 0;
    switch (arcMode) {
      case ParticleSystemShapeMultiModeValue.Random:
        u2 = Math.random();
        v4 = Math.random();
        break;
      case ParticleSystemShapeMultiModeValue.PingPong:
        if (this._loopTime > 1)
          this._loopDirection = -1;
        if (this._loopTime < 0)
          this._loopDirection = 1;
      case ParticleSystemShapeMultiModeValue.Loop:
        u2 = 0.5;
        v4 = Math.random();
        this._loopTime += this.system.deltaTime * this._loopDirection;
        break;
    }
    let theta = 2 * Math.PI * u2 * (arc / 360);
    switch (arcMode) {
      case ParticleSystemShapeMultiModeValue.PingPong:
      case ParticleSystemShapeMultiModeValue.Loop:
        theta += Math.PI + 0.5;
        theta += this._loopTime * Math.PI * 2;
        theta %= Mathf.toRadians(arc);
        break;
    }
    const phi = Math.acos(2 * v4 - 1);
    const r = Mathf.lerp(1, 1 - Math.pow(1 - Math.random(), Math.PI), thickness) * radius;
    const x2 = pos.x + -r * Math.sin(phi) * Math.cos(theta);
    const y = pos.y + r * Math.sin(phi) * Math.sin(theta);
    const z = pos.z;
    vec2.x = x2 * this.scale.x;
    vec2.y = y * this.scale.y;
    vec2.z = z * this.scale.z;
  }
};
var ShapeModule = _ShapeModule;
__publicField(ShapeModule, "_randomQuat", new Quaternion());
__publicField(ShapeModule, "_tempVec", new Vector32());
__decorate44([
  serializable()
], ShapeModule.prototype, "shapeType", void 0);
__decorate44([
  serializable()
], ShapeModule.prototype, "enabled", void 0);
__decorate44([
  serializable()
], ShapeModule.prototype, "alignToDirection", void 0);
__decorate44([
  serializable()
], ShapeModule.prototype, "angle", void 0);
__decorate44([
  serializable()
], ShapeModule.prototype, "arc", void 0);
__decorate44([
  serializable()
], ShapeModule.prototype, "arcSpread", void 0);
__decorate44([
  serializable()
], ShapeModule.prototype, "arcSpeedMultiplier", void 0);
__decorate44([
  serializable()
], ShapeModule.prototype, "arcMode", void 0);
__decorate44([
  serializable(Vector32)
], ShapeModule.prototype, "boxThickness", void 0);
__decorate44([
  serializable(Vector32)
], ShapeModule.prototype, "position", void 0);
__decorate44([
  serializable(Vector32)
], ShapeModule.prototype, "rotation", void 0);
__decorate44([
  serializable(Vector32)
], ShapeModule.prototype, "scale", void 0);
__decorate44([
  serializable()
], ShapeModule.prototype, "radius", void 0);
__decorate44([
  serializable()
], ShapeModule.prototype, "radiusThickness", void 0);
__decorate44([
  serializable()
], ShapeModule.prototype, "sphericalDirectionAmount", void 0);
__decorate44([
  serializable()
], ShapeModule.prototype, "randomDirectionAmount", void 0);
__decorate44([
  serializable()
], ShapeModule.prototype, "randomPositionAmount", void 0);
__decorate44([
  serializable()
], ShapeModule.prototype, "meshShapeType", void 0);
__decorate44([
  serializable(MeshRenderer)
], ShapeModule.prototype, "meshRenderer", void 0);
var NoiseModule = class {
  constructor() {
    __publicField(this, "damping");
    __publicField(this, "enabled");
    __publicField(this, "frequency");
    __publicField(this, "octaveCount");
    __publicField(this, "octaveMultiplier");
    __publicField(this, "octaveScale");
    __publicField(this, "positionAmount");
    __publicField(this, "quality");
    __publicField(this, "remap");
    __publicField(this, "remapEnabled");
    __publicField(this, "remapMultiplier");
    __publicField(this, "remapX");
    __publicField(this, "remapXMultiplier");
    __publicField(this, "remapY");
    __publicField(this, "remapYMultiplier");
    __publicField(this, "remapZ");
    __publicField(this, "remapZMultiplier");
    __publicField(this, "scrollSpeedMultiplier");
    __publicField(this, "separateAxes");
    __publicField(this, "strengthMultiplier");
    __publicField(this, "strengthX");
    __publicField(this, "strengthXMultiplier");
    __publicField(this, "strengthY");
    __publicField(this, "strengthYMultiplier");
    __publicField(this, "strengthZ");
    __publicField(this, "strengthZMultiplier");
    __publicField(this, "_noise");
    __publicField(this, "_time", 0);
    /** nebula implementations: */
    __publicField(this, "_temp", new Vector32());
  }
  update(context) {
    this._time += context.time.deltaTime * this.scrollSpeedMultiplier;
  }
  apply(_index, pos, vel, _deltaTime, age, life) {
    if (!this.enabled)
      return;
    if (!this._noise) {
      this._noise = createNoise4D(() => 0);
    }
    const temp = this._temp.set(pos.x, pos.y, pos.z).multiplyScalar(this.frequency);
    const nx = this._noise(temp.x, temp.y, temp.z, this._time);
    const ny = this._noise(temp.x, temp.y, temp.z, this._time + 1e3 * this.frequency);
    const nz = this._noise(temp.x, temp.y, temp.z, this._time + 2e3 * this.frequency);
    this._temp.set(nx, ny, nz).normalize();
    const t2 = age / life;
    let strengthFactor = this.positionAmount.evaluate(t2);
    if (!this.separateAxes) {
      if (this.strengthX) {
        strengthFactor *= this.strengthX.evaluate(t2) * 1.5;
      }
      this._temp.multiplyScalar(strengthFactor);
    } else {
      this._temp.x *= strengthFactor * this.strengthXMultiplier;
      this._temp.y *= strengthFactor * this.strengthYMultiplier;
      this._temp.z *= strengthFactor * this.strengthZMultiplier;
    }
    vel.x += this._temp.x;
    vel.y += this._temp.y;
    vel.z += this._temp.z;
  }
};
__decorate44([
  serializable()
], NoiseModule.prototype, "damping", void 0);
__decorate44([
  serializable()
], NoiseModule.prototype, "enabled", void 0);
__decorate44([
  serializable()
], NoiseModule.prototype, "frequency", void 0);
__decorate44([
  serializable()
], NoiseModule.prototype, "octaveCount", void 0);
__decorate44([
  serializable()
], NoiseModule.prototype, "octaveMultiplier", void 0);
__decorate44([
  serializable()
], NoiseModule.prototype, "octaveScale", void 0);
__decorate44([
  serializable(MinMaxCurve)
], NoiseModule.prototype, "positionAmount", void 0);
__decorate44([
  serializable()
], NoiseModule.prototype, "quality", void 0);
__decorate44([
  serializable(MinMaxCurve)
], NoiseModule.prototype, "remap", void 0);
__decorate44([
  serializable()
], NoiseModule.prototype, "remapEnabled", void 0);
__decorate44([
  serializable()
], NoiseModule.prototype, "remapMultiplier", void 0);
__decorate44([
  serializable(MinMaxCurve)
], NoiseModule.prototype, "remapX", void 0);
__decorate44([
  serializable()
], NoiseModule.prototype, "remapXMultiplier", void 0);
__decorate44([
  serializable(MinMaxCurve)
], NoiseModule.prototype, "remapY", void 0);
__decorate44([
  serializable()
], NoiseModule.prototype, "remapYMultiplier", void 0);
__decorate44([
  serializable(MinMaxCurve)
], NoiseModule.prototype, "remapZ", void 0);
__decorate44([
  serializable()
], NoiseModule.prototype, "remapZMultiplier", void 0);
__decorate44([
  serializable()
], NoiseModule.prototype, "scrollSpeedMultiplier", void 0);
__decorate44([
  serializable()
], NoiseModule.prototype, "separateAxes", void 0);
__decorate44([
  serializable()
], NoiseModule.prototype, "strengthMultiplier", void 0);
__decorate44([
  serializable(MinMaxCurve)
], NoiseModule.prototype, "strengthX", void 0);
__decorate44([
  serializable()
], NoiseModule.prototype, "strengthXMultiplier", void 0);
__decorate44([
  serializable(MinMaxCurve)
], NoiseModule.prototype, "strengthY", void 0);
__decorate44([
  serializable()
], NoiseModule.prototype, "strengthYMultiplier", void 0);
__decorate44([
  serializable(MinMaxCurve)
], NoiseModule.prototype, "strengthZ", void 0);
__decorate44([
  serializable()
], NoiseModule.prototype, "strengthZMultiplier", void 0);
var ParticleSystemTrailMode;
(function(ParticleSystemTrailMode2) {
  ParticleSystemTrailMode2[ParticleSystemTrailMode2["PerParticle"] = 0] = "PerParticle";
  ParticleSystemTrailMode2[ParticleSystemTrailMode2["Ribbon"] = 1] = "Ribbon";
})(ParticleSystemTrailMode || (ParticleSystemTrailMode = {}));
var ParticleSystemTrailTextureMode;
(function(ParticleSystemTrailTextureMode2) {
  ParticleSystemTrailTextureMode2[ParticleSystemTrailTextureMode2["Stretch"] = 0] = "Stretch";
  ParticleSystemTrailTextureMode2[ParticleSystemTrailTextureMode2["Tile"] = 1] = "Tile";
  ParticleSystemTrailTextureMode2[ParticleSystemTrailTextureMode2["DistributePerSegment"] = 2] = "DistributePerSegment";
  ParticleSystemTrailTextureMode2[ParticleSystemTrailTextureMode2["RepeatPerSegment"] = 3] = "RepeatPerSegment";
})(ParticleSystemTrailTextureMode || (ParticleSystemTrailTextureMode = {}));
var TrailModule = class {
  constructor() {
    __publicField(this, "enabled");
    __publicField(this, "attachRibbonToTransform", false);
    __publicField(this, "colorOverLifetime");
    __publicField(this, "colorOverTrail");
    __publicField(this, "dieWithParticles", true);
    __publicField(this, "inheritParticleColor", true);
    __publicField(this, "lifetime");
    __publicField(this, "lifetimeMultiplier");
    __publicField(this, "minVertexDistance", 0.2);
    __publicField(this, "mode", ParticleSystemTrailMode.PerParticle);
    __publicField(this, "ratio", 1);
    __publicField(this, "ribbonCount", 1);
    __publicField(this, "shadowBias", 0);
    __publicField(this, "sizeAffectsLifetime", false);
    __publicField(this, "sizeAffectsWidth", false);
    __publicField(this, "splitSubEmitterRibbons", false);
    __publicField(this, "textureMode", ParticleSystemTrailTextureMode.Stretch);
    __publicField(this, "widthOverTrail");
    __publicField(this, "widthOverTrailMultiplier");
    __publicField(this, "worldSpace", false);
  }
  getWidth(size, _life01, pos01, t2) {
    const res = this.widthOverTrail.evaluate(pos01, t2);
    size *= res;
    return size;
  }
  getColor(color2, life01, pos01) {
    const overTrail = this.colorOverTrail.evaluate(pos01);
    const overLife = this.colorOverLifetime.evaluate(life01);
    color2.x *= overTrail.r * overLife.r;
    color2.y *= overTrail.g * overLife.g;
    color2.z *= overTrail.b * overLife.b;
    if ("alpha" in overTrail && "alpha" in overLife)
      color2.w *= overTrail.alpha * overLife.alpha;
  }
};
__decorate44([
  serializable()
], TrailModule.prototype, "enabled", void 0);
__decorate44([
  serializable()
], TrailModule.prototype, "attachRibbonToTransform", void 0);
__decorate44([
  serializable(MinMaxGradient)
], TrailModule.prototype, "colorOverLifetime", void 0);
__decorate44([
  serializable(MinMaxGradient)
], TrailModule.prototype, "colorOverTrail", void 0);
__decorate44([
  serializable()
], TrailModule.prototype, "dieWithParticles", void 0);
__decorate44([
  serializable()
], TrailModule.prototype, "inheritParticleColor", void 0);
__decorate44([
  serializable(MinMaxCurve)
], TrailModule.prototype, "lifetime", void 0);
__decorate44([
  serializable()
], TrailModule.prototype, "lifetimeMultiplier", void 0);
__decorate44([
  serializable()
], TrailModule.prototype, "minVertexDistance", void 0);
__decorate44([
  serializable()
], TrailModule.prototype, "mode", void 0);
__decorate44([
  serializable()
], TrailModule.prototype, "ratio", void 0);
__decorate44([
  serializable()
], TrailModule.prototype, "ribbonCount", void 0);
__decorate44([
  serializable()
], TrailModule.prototype, "shadowBias", void 0);
__decorate44([
  serializable()
], TrailModule.prototype, "sizeAffectsLifetime", void 0);
__decorate44([
  serializable()
], TrailModule.prototype, "sizeAffectsWidth", void 0);
__decorate44([
  serializable()
], TrailModule.prototype, "splitSubEmitterRibbons", void 0);
__decorate44([
  serializable()
], TrailModule.prototype, "textureMode", void 0);
__decorate44([
  serializable(MinMaxCurve)
], TrailModule.prototype, "widthOverTrail", void 0);
__decorate44([
  serializable()
], TrailModule.prototype, "widthOverTrailMultiplier", void 0);
__decorate44([
  serializable()
], TrailModule.prototype, "worldSpace", void 0);
var VelocityOverLifetimeModule = class {
  constructor() {
    __publicField(this, "enabled");
    __publicField(this, "space", ParticleSystemSimulationSpace.Local);
    __publicField(this, "orbitalX");
    __publicField(this, "orbitalY");
    __publicField(this, "orbitalZ");
    __publicField(this, "orbitalXMultiplier");
    __publicField(this, "orbitalYMultiplier");
    __publicField(this, "orbitalZMultiplier");
    __publicField(this, "orbitalOffsetX");
    __publicField(this, "orbitalOffsetY");
    __publicField(this, "orbitalOffsetZ");
    __publicField(this, "speedModifier");
    __publicField(this, "speedModifierMultiplier");
    __publicField(this, "x");
    __publicField(this, "xMultiplier");
    __publicField(this, "y");
    __publicField(this, "yMultiplier");
    __publicField(this, "z");
    __publicField(this, "zMultiplier");
    __publicField(this, "_system");
    __publicField(this, "_temp", new Vector32());
    __publicField(this, "_temp2", new Vector32());
    __publicField(this, "_temp3", new Vector32());
    __publicField(this, "_hasOrbital", false);
    __publicField(this, "_index", 0);
    __publicField(this, "_orbitalMatrix", new Matrix4());
  }
  // private _worldRotation: Quaternion = new Quaternion();
  update(system) {
    this._system = system;
  }
  init(particle) {
    if (this._index == 0)
      particle["debug"] = true;
    this._index += 1;
    particle["orbitx"] = this.orbitalX.evaluate(Math.random());
    particle["orbity"] = this.orbitalY.evaluate(Math.random());
    particle["orbitz"] = this.orbitalZ.evaluate(Math.random());
    this._hasOrbital = particle["orbitx"] != 0 || particle["orbity"] != 0 || particle["orbitz"] != 0;
  }
  apply(_particle, _index, _pos, vel, _dt, age, life) {
    var _a2;
    if (!this.enabled)
      return;
    const t2 = age / life;
    const speed = this.speedModifier.evaluate(t2) * this.speedModifierMultiplier;
    const x2 = this.x.evaluate(t2);
    const y = this.y.evaluate(t2);
    const z = this.z.evaluate(t2);
    this._temp.set(-x2, y, z);
    if (this._system) {
      if (this._system.main.simulationSpace === ParticleSystemSimulationSpace.World) {
        this._temp.applyQuaternion(this._system.worldQuaternion);
      }
    }
    if (this._hasOrbital) {
      const position = (_a2 = this._system) == null ? void 0 : _a2.worldPos;
      if (position) {
        const pos = this._temp2.set(_pos.x, _pos.y, _pos.z);
        const ox = this.orbitalXMultiplier;
        const oy = this.orbitalYMultiplier;
        const oz = this.orbitalZMultiplier;
        const angle = speed * Math.PI * 2 * 10;
        const cosX = Math.cos(angle * ox);
        const sinX = Math.sin(angle * ox);
        const cosY = Math.cos(angle * oy);
        const sinY = Math.sin(angle * oy);
        const cosZ = Math.cos(angle * oz);
        const sinZ = Math.sin(angle * oz);
        const newX = pos.x * (cosY * cosZ) + pos.y * (cosY * sinZ) + pos.z * -sinY;
        const newY = pos.x * (sinX * sinY * cosZ - cosX * sinZ) + pos.y * (sinX * sinY * sinZ + cosX * cosZ) + pos.z * (sinX * cosY);
        const newZ = pos.x * (cosX * sinY * cosZ + sinX * sinZ) + pos.y * (cosX * sinY * sinZ - sinX * cosZ) + pos.z * (cosX * cosY);
        const v4 = this._temp3.set(pos.x - newX, pos.y - newY, pos.z - newZ);
        v4.normalize();
        v4.multiplyScalar(0.2 / _dt * Math.max(this.orbitalXMultiplier, this.orbitalYMultiplier, this.orbitalZMultiplier));
        vel.x += v4.x;
        vel.y += v4.y;
        vel.z += v4.z;
      }
    }
    vel.x += this._temp.x;
    vel.y += this._temp.y;
    vel.z += this._temp.z;
    vel.x *= speed;
    vel.y *= speed;
    vel.z *= speed;
  }
};
__decorate44([
  serializable()
], VelocityOverLifetimeModule.prototype, "enabled", void 0);
__decorate44([
  serializable()
], VelocityOverLifetimeModule.prototype, "space", void 0);
__decorate44([
  serializable(MinMaxCurve)
], VelocityOverLifetimeModule.prototype, "orbitalX", void 0);
__decorate44([
  serializable(MinMaxCurve)
], VelocityOverLifetimeModule.prototype, "orbitalY", void 0);
__decorate44([
  serializable(MinMaxCurve)
], VelocityOverLifetimeModule.prototype, "orbitalZ", void 0);
__decorate44([
  serializable()
], VelocityOverLifetimeModule.prototype, "orbitalXMultiplier", void 0);
__decorate44([
  serializable()
], VelocityOverLifetimeModule.prototype, "orbitalYMultiplier", void 0);
__decorate44([
  serializable()
], VelocityOverLifetimeModule.prototype, "orbitalZMultiplier", void 0);
__decorate44([
  serializable()
], VelocityOverLifetimeModule.prototype, "orbitalOffsetX", void 0);
__decorate44([
  serializable()
], VelocityOverLifetimeModule.prototype, "orbitalOffsetY", void 0);
__decorate44([
  serializable()
], VelocityOverLifetimeModule.prototype, "orbitalOffsetZ", void 0);
__decorate44([
  serializable(MinMaxCurve)
], VelocityOverLifetimeModule.prototype, "speedModifier", void 0);
__decorate44([
  serializable()
], VelocityOverLifetimeModule.prototype, "speedModifierMultiplier", void 0);
__decorate44([
  serializable(MinMaxCurve)
], VelocityOverLifetimeModule.prototype, "x", void 0);
__decorate44([
  serializable()
], VelocityOverLifetimeModule.prototype, "xMultiplier", void 0);
__decorate44([
  serializable(MinMaxCurve)
], VelocityOverLifetimeModule.prototype, "y", void 0);
__decorate44([
  serializable()
], VelocityOverLifetimeModule.prototype, "yMultiplier", void 0);
__decorate44([
  serializable(MinMaxCurve)
], VelocityOverLifetimeModule.prototype, "z", void 0);
__decorate44([
  serializable()
], VelocityOverLifetimeModule.prototype, "zMultiplier", void 0);
var ParticleSystemAnimationTimeMode;
(function(ParticleSystemAnimationTimeMode2) {
  ParticleSystemAnimationTimeMode2[ParticleSystemAnimationTimeMode2["Lifetime"] = 0] = "Lifetime";
  ParticleSystemAnimationTimeMode2[ParticleSystemAnimationTimeMode2["Speed"] = 1] = "Speed";
  ParticleSystemAnimationTimeMode2[ParticleSystemAnimationTimeMode2["FPS"] = 2] = "FPS";
})(ParticleSystemAnimationTimeMode || (ParticleSystemAnimationTimeMode = {}));
var ParticleSystemAnimationMode;
(function(ParticleSystemAnimationMode2) {
  ParticleSystemAnimationMode2[ParticleSystemAnimationMode2["Grid"] = 0] = "Grid";
  ParticleSystemAnimationMode2[ParticleSystemAnimationMode2["Sprites"] = 1] = "Sprites";
})(ParticleSystemAnimationMode || (ParticleSystemAnimationMode = {}));
var ParticleSystemAnimationRowMode;
(function(ParticleSystemAnimationRowMode2) {
  ParticleSystemAnimationRowMode2[ParticleSystemAnimationRowMode2["Custom"] = 0] = "Custom";
  ParticleSystemAnimationRowMode2[ParticleSystemAnimationRowMode2["Random"] = 1] = "Random";
  ParticleSystemAnimationRowMode2[ParticleSystemAnimationRowMode2["MeshIndex"] = 2] = "MeshIndex";
})(ParticleSystemAnimationRowMode || (ParticleSystemAnimationRowMode = {}));
var ParticleSystemAnimationType;
(function(ParticleSystemAnimationType2) {
  ParticleSystemAnimationType2[ParticleSystemAnimationType2["WholeSheet"] = 0] = "WholeSheet";
  ParticleSystemAnimationType2[ParticleSystemAnimationType2["SingleRow"] = 1] = "SingleRow";
})(ParticleSystemAnimationType || (ParticleSystemAnimationType = {}));
var TextureSheetAnimationModule = class {
  constructor() {
    __publicField(this, "animation");
    __publicField(this, "enabled");
    __publicField(this, "cycleCount");
    __publicField(this, "frameOverTime");
    __publicField(this, "frameOverTimeMultiplier");
    __publicField(this, "numTilesX");
    __publicField(this, "numTilesY");
    __publicField(this, "startFrame");
    __publicField(this, "startFrameMultiplier");
    __publicField(this, "rowMode");
    __publicField(this, "rowIndex");
    __publicField(this, "spriteCount");
    __publicField(this, "timeMode");
  }
  sampleOnceAtStart() {
    if (this.timeMode === ParticleSystemAnimationTimeMode.Lifetime) {
      switch (this.frameOverTime.mode) {
        case ParticleSystemCurveMode.Constant:
        case ParticleSystemCurveMode.TwoConstants:
        case ParticleSystemCurveMode.TwoCurves:
        case ParticleSystemCurveMode.Curve:
          return true;
      }
    }
    return false;
  }
  getStartIndex() {
    if (this.sampleOnceAtStart()) {
      const start = Math.random();
      return start * (this.numTilesX * this.numTilesY);
    }
    return 0;
  }
  evaluate(t01) {
    if (this.sampleOnceAtStart()) {
      return void 0;
    }
    return this.getIndex(t01);
  }
  getIndex(t01) {
    const tiles = this.numTilesX * this.numTilesY;
    t01 = t01 * this.cycleCount;
    let index = this.frameOverTime.evaluate(t01 % 1);
    index *= this.frameOverTimeMultiplier;
    index *= tiles;
    index = index % tiles;
    index = Math.floor(index);
    return index;
  }
};
__decorate44([
  serializable()
], TextureSheetAnimationModule.prototype, "animation", void 0);
__decorate44([
  serializable()
], TextureSheetAnimationModule.prototype, "enabled", void 0);
__decorate44([
  serializable()
], TextureSheetAnimationModule.prototype, "cycleCount", void 0);
__decorate44([
  serializable(MinMaxCurve)
], TextureSheetAnimationModule.prototype, "frameOverTime", void 0);
__decorate44([
  serializable()
], TextureSheetAnimationModule.prototype, "frameOverTimeMultiplier", void 0);
__decorate44([
  serializable()
], TextureSheetAnimationModule.prototype, "numTilesX", void 0);
__decorate44([
  serializable()
], TextureSheetAnimationModule.prototype, "numTilesY", void 0);
__decorate44([
  serializable(MinMaxCurve)
], TextureSheetAnimationModule.prototype, "startFrame", void 0);
__decorate44([
  serializable()
], TextureSheetAnimationModule.prototype, "startFrameMultiplier", void 0);
__decorate44([
  serializable()
], TextureSheetAnimationModule.prototype, "rowMode", void 0);
__decorate44([
  serializable()
], TextureSheetAnimationModule.prototype, "rowIndex", void 0);
__decorate44([
  serializable()
], TextureSheetAnimationModule.prototype, "spriteCount", void 0);
__decorate44([
  serializable()
], TextureSheetAnimationModule.prototype, "timeMode", void 0);
var RotationOverLifetimeModule = class {
  constructor() {
    __publicField(this, "enabled");
    __publicField(this, "separateAxes");
    __publicField(this, "x");
    __publicField(this, "xMultiplier");
    __publicField(this, "y");
    __publicField(this, "yMultiplier");
    __publicField(this, "z");
    __publicField(this, "zMultiplier");
  }
  evaluate(t01, t2) {
    if (!this.enabled)
      return 0;
    if (!this.separateAxes) {
      const rot = this.z.evaluate(t01, t2) * -1;
      return rot;
    }
    return 0;
  }
};
__decorate44([
  serializable()
], RotationOverLifetimeModule.prototype, "enabled", void 0);
__decorate44([
  serializable()
], RotationOverLifetimeModule.prototype, "separateAxes", void 0);
__decorate44([
  serializable(MinMaxCurve)
], RotationOverLifetimeModule.prototype, "x", void 0);
__decorate44([
  serializable()
], RotationOverLifetimeModule.prototype, "xMultiplier", void 0);
__decorate44([
  serializable(MinMaxCurve)
], RotationOverLifetimeModule.prototype, "y", void 0);
__decorate44([
  serializable()
], RotationOverLifetimeModule.prototype, "yMultiplier", void 0);
__decorate44([
  serializable(MinMaxCurve)
], RotationOverLifetimeModule.prototype, "z", void 0);
__decorate44([
  serializable()
], RotationOverLifetimeModule.prototype, "zMultiplier", void 0);
var RotationBySpeedModule = class {
  constructor() {
    __publicField(this, "enabled");
    __publicField(this, "range");
    __publicField(this, "separateAxes");
    __publicField(this, "x");
    __publicField(this, "xMultiplier");
    __publicField(this, "y");
    __publicField(this, "yMultiplier");
    __publicField(this, "z");
    __publicField(this, "zMultiplier");
  }
  evaluate(_t01, speed) {
    if (!this.enabled)
      return 0;
    if (!this.separateAxes) {
      const t2 = Mathf.lerp(this.range.x, this.range.y, speed);
      const rot = this.z.evaluate(t2) * -1;
      return rot;
    }
    return 0;
  }
};
__decorate44([
  serializable()
], RotationBySpeedModule.prototype, "enabled", void 0);
__decorate44([
  serializable()
], RotationBySpeedModule.prototype, "range", void 0);
__decorate44([
  serializable()
], RotationBySpeedModule.prototype, "separateAxes", void 0);
__decorate44([
  serializable(MinMaxCurve)
], RotationBySpeedModule.prototype, "x", void 0);
__decorate44([
  serializable()
], RotationBySpeedModule.prototype, "xMultiplier", void 0);
__decorate44([
  serializable(MinMaxCurve)
], RotationBySpeedModule.prototype, "y", void 0);
__decorate44([
  serializable()
], RotationBySpeedModule.prototype, "yMultiplier", void 0);
__decorate44([
  serializable(MinMaxCurve)
], RotationBySpeedModule.prototype, "z", void 0);
__decorate44([
  serializable()
], RotationBySpeedModule.prototype, "zMultiplier", void 0);
var LimitVelocityOverLifetimeModule = class {
  constructor() {
    __publicField(this, "enabled");
    __publicField(this, "dampen");
    __publicField(this, "drag");
    __publicField(this, "dragMultiplier");
    __publicField(this, "limit");
    __publicField(this, "limitMultiplier");
    __publicField(this, "separateAxes");
    __publicField(this, "limitX");
    __publicField(this, "limitXMultiplier");
    __publicField(this, "limitY");
    __publicField(this, "limitYMultiplier");
    __publicField(this, "limitZ");
    __publicField(this, "limitZMultiplier");
    __publicField(this, "multiplyDragByParticleSize", false);
    __publicField(this, "multiplyDragByParticleVelocity", false);
    __publicField(this, "space");
    __publicField(this, "_temp", new Vector32());
    __publicField(this, "_temp2", new Vector32());
  }
  apply(_position, baseVelocity, currentVelocity, _size, t01, _dt, _scale) {
    if (!this.enabled)
      return;
    {
      const max = this.limit.evaluate(t01) * this.limitMultiplier;
      const speed = baseVelocity.length();
      if (speed > max) {
        this._temp.copy(baseVelocity).normalize().multiplyScalar(max);
        const t2 = this.dampen * 0.5;
        baseVelocity.x = Mathf.lerp(baseVelocity.x, this._temp.x, t2);
        baseVelocity.y = Mathf.lerp(baseVelocity.y, this._temp.y, t2);
        baseVelocity.z = Mathf.lerp(baseVelocity.z, this._temp.z, t2);
        currentVelocity.x = Mathf.lerp(currentVelocity.x, this._temp.x, t2);
        currentVelocity.y = Mathf.lerp(currentVelocity.y, this._temp.y, t2);
        currentVelocity.z = Mathf.lerp(currentVelocity.z, this._temp.z, t2);
      }
    }
  }
};
__decorate44([
  serializable()
], LimitVelocityOverLifetimeModule.prototype, "enabled", void 0);
__decorate44([
  serializable()
], LimitVelocityOverLifetimeModule.prototype, "dampen", void 0);
__decorate44([
  serializable(MinMaxCurve)
], LimitVelocityOverLifetimeModule.prototype, "drag", void 0);
__decorate44([
  serializable()
], LimitVelocityOverLifetimeModule.prototype, "dragMultiplier", void 0);
__decorate44([
  serializable(MinMaxCurve)
], LimitVelocityOverLifetimeModule.prototype, "limit", void 0);
__decorate44([
  serializable()
], LimitVelocityOverLifetimeModule.prototype, "limitMultiplier", void 0);
__decorate44([
  serializable()
], LimitVelocityOverLifetimeModule.prototype, "separateAxes", void 0);
__decorate44([
  serializable(MinMaxCurve)
], LimitVelocityOverLifetimeModule.prototype, "limitX", void 0);
__decorate44([
  serializable()
], LimitVelocityOverLifetimeModule.prototype, "limitXMultiplier", void 0);
__decorate44([
  serializable(MinMaxCurve)
], LimitVelocityOverLifetimeModule.prototype, "limitY", void 0);
__decorate44([
  serializable()
], LimitVelocityOverLifetimeModule.prototype, "limitYMultiplier", void 0);
__decorate44([
  serializable(MinMaxCurve)
], LimitVelocityOverLifetimeModule.prototype, "limitZ", void 0);
__decorate44([
  serializable()
], LimitVelocityOverLifetimeModule.prototype, "limitZMultiplier", void 0);
__decorate44([
  serializable()
], LimitVelocityOverLifetimeModule.prototype, "multiplyDragByParticleSize", void 0);
__decorate44([
  serializable()
], LimitVelocityOverLifetimeModule.prototype, "multiplyDragByParticleVelocity", void 0);
__decorate44([
  serializable()
], LimitVelocityOverLifetimeModule.prototype, "space", void 0);
var ParticleSystemInheritVelocityMode;
(function(ParticleSystemInheritVelocityMode2) {
  ParticleSystemInheritVelocityMode2[ParticleSystemInheritVelocityMode2["Initial"] = 0] = "Initial";
  ParticleSystemInheritVelocityMode2[ParticleSystemInheritVelocityMode2["Current"] = 1] = "Current";
})(ParticleSystemInheritVelocityMode || (ParticleSystemInheritVelocityMode = {}));
var InheritVelocityModule = class {
  constructor() {
    __publicField(this, "enabled");
    __publicField(this, "curve");
    __publicField(this, "curveMultiplier");
    __publicField(this, "mode");
    __publicField(this, "system");
    __publicField(this, "_temp", new Vector32());
    __publicField(this, "_firstUpdate", true);
    __publicField(this, "_frames", 0);
  }
  clone() {
    var _a2;
    const ni = new InheritVelocityModule();
    ni.enabled = this.enabled;
    ni.curve = (_a2 = this.curve) == null ? void 0 : _a2.clone();
    ni.curveMultiplier = this.curveMultiplier;
    ni.mode = this.mode;
    return ni;
  }
  get _lastWorldPosition() {
    if (!this.system["_iv_lastWorldPosition"]) {
      this.system["_iv_lastWorldPosition"] = new Vector32();
    }
    return this.system["_iv_lastWorldPosition"];
  }
  get _velocity() {
    if (!this.system["_iv_velocity"]) {
      this.system["_iv_velocity"] = new Vector32();
    }
    return this.system["_iv_velocity"];
  }
  awake(system) {
    this.system = system;
    this.reset();
  }
  reset() {
    this._firstUpdate = true;
  }
  update(_context) {
    if (!this.enabled)
      return;
    if (this.system.worldspace === false)
      return;
    if (this._firstUpdate) {
      this._firstUpdate = false;
      this._velocity.set(0, 0, 0);
      this._lastWorldPosition.copy(this.system.worldPos);
    } else if (this._lastWorldPosition) {
      this._velocity.copy(this.system.worldPos).sub(this._lastWorldPosition).multiplyScalar(1 / this.system.deltaTime);
      this._lastWorldPosition.copy(this.system.worldPos);
    }
  }
  // TODO: make work for subsystems
  applyInitial(vel) {
    if (!this.enabled)
      return;
    if (this.system.worldspace === false)
      return;
    if (this.mode === ParticleSystemInheritVelocityMode.Initial) {
      const factor = this.curve.evaluate(Math.random(), Math.random());
      this._temp.copy(this._velocity).multiplyScalar(factor);
      vel.x += this._temp.x;
      vel.y += this._temp.y;
      vel.z += this._temp.z;
    }
  }
  applyCurrent(vel, t01, lerpFactor) {
    if (!this.enabled)
      return;
    if (!this.system)
      return;
    if (this.system.worldspace === false)
      return;
    if (this.mode === ParticleSystemInheritVelocityMode.Current) {
      const factor = this.curve.evaluate(t01, lerpFactor);
      this._temp.copy(this._velocity).multiplyScalar(factor);
      vel.x += this._temp.x;
      vel.y += this._temp.y;
      vel.z += this._temp.z;
    }
  }
};
__decorate44([
  serializable()
], InheritVelocityModule.prototype, "enabled", void 0);
__decorate44([
  serializable(MinMaxCurve)
], InheritVelocityModule.prototype, "curve", void 0);
__decorate44([
  serializable()
], InheritVelocityModule.prototype, "curveMultiplier", void 0);
__decorate44([
  serializable()
], InheritVelocityModule.prototype, "mode", void 0);
var SizeBySpeedModule = class {
  constructor() {
    __publicField(this, "enabled");
    __publicField(this, "range");
    __publicField(this, "separateAxes");
    __publicField(this, "size");
    __publicField(this, "sizeMultiplier");
    __publicField(this, "x");
    __publicField(this, "xMultiplier");
    __publicField(this, "y");
    __publicField(this, "yMultiplier");
    __publicField(this, "z");
    __publicField(this, "zMultiplier");
  }
  evaluate(vel, _t01, lerpFactor, size) {
    const speed = vel.length();
    const x2 = Mathf.remap(speed, this.range.x, this.range.y, 0, 1);
    const factor = this.size.evaluate(x2, lerpFactor);
    size.x *= factor;
    size.y *= factor;
    size.z *= factor;
    return size;
  }
};
__decorate44([
  serializable()
], SizeBySpeedModule.prototype, "enabled", void 0);
__decorate44([
  serializable(Vector2)
], SizeBySpeedModule.prototype, "range", void 0);
__decorate44([
  serializable()
], SizeBySpeedModule.prototype, "separateAxes", void 0);
__decorate44([
  serializable(MinMaxCurve)
], SizeBySpeedModule.prototype, "size", void 0);
__decorate44([
  serializable()
], SizeBySpeedModule.prototype, "sizeMultiplier", void 0);
__decorate44([
  serializable(MinMaxCurve)
], SizeBySpeedModule.prototype, "x", void 0);
__decorate44([
  serializable()
], SizeBySpeedModule.prototype, "xMultiplier", void 0);
__decorate44([
  serializable(MinMaxCurve)
], SizeBySpeedModule.prototype, "y", void 0);
__decorate44([
  serializable()
], SizeBySpeedModule.prototype, "yMultiplier", void 0);
__decorate44([
  serializable(MinMaxCurve)
], SizeBySpeedModule.prototype, "z", void 0);
__decorate44([
  serializable()
], SizeBySpeedModule.prototype, "zMultiplier", void 0);
var ColorBySpeedModule = class {
  constructor() {
    __publicField(this, "enabled");
    __publicField(this, "range");
    __publicField(this, "color");
  }
  evaluate(vel, lerpFactor, color2) {
    const speed = vel.length();
    const x2 = Mathf.remap(speed, this.range.x, this.range.y, 0, 1);
    const res = this.color.evaluate(x2, lerpFactor);
    color2.x *= res.r;
    color2.y *= res.g;
    color2.z *= res.b;
    if ("alpha" in res)
      color2.w *= res.alpha;
  }
};
__decorate44([
  serializable()
], ColorBySpeedModule.prototype, "enabled", void 0);
__decorate44([
  serializable(Vector2)
], ColorBySpeedModule.prototype, "range", void 0);
__decorate44([
  serializable(MinMaxGradient)
], ColorBySpeedModule.prototype, "color", void 0);

// node_modules/three/examples/jsm/shaders/HorizontalBlurShader.js
var HorizontalBlurShader = {
  name: "HorizontalBlurShader",
  uniforms: {
    "tDiffuse": { value: null },
    "h": { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform float h;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

			gl_FragColor = sum;

		}`
  )
};

// node_modules/three/examples/jsm/shaders/VerticalBlurShader.js
var VerticalBlurShader = {
  name: "VerticalBlurShader",
  uniforms: {
    "tDiffuse": { value: null },
    "v": { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform float v;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

			gl_FragColor = sum;

		}`
  )
};

// node_modules/@needle-tools/engine/lib/engine-components/ContactShadows.js
var __decorate45 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug79 = getParam("debugcontactshadows");
onStart((ctx) => {
  const val = ctx.domElement.getAttribute("contactshadows");
  if (val != void 0 && val != "0" && val != "false") {
    ContactShadows.auto(ctx);
  }
});
var _ContactShadows = class extends Component2 {
  constructor() {
    super(...arguments);
    /**
     * When enabled the contact shadows component will be created to fit the whole scene.
     */
    __publicField(this, "autoFit", false);
    /**
     * Darkness of the shadows.
     * @default 0.5
     */
    __publicField(this, "darkness", 0.5);
    /**
     * Opacity of the shadows.
     * @default 0.5
     */
    __publicField(this, "opacity", 0.5);
    /**
     * Blur of the shadows.
     * @default 4.0
     */
    __publicField(this, "blur", 4);
    /**
     * When enabled objects will not be visible below the shadow plane
     * @default false
     */
    __publicField(this, "occludeBelowGround", false);
    /**
     * When enabled the backfaces of objects will cast shadows as well.
     * @default true
     */
    __publicField(this, "backfaceShadows", true);
    /**
     * The minimum size of the shadows box
     */
    __publicField(this, "minSize");
    /** All shadow objects are parented to this object.
     * The gameObject itself should not be transformed because we want the ContactShadows object e.g. also have a GroundProjectedEnv component
     * in which case ContactShadows scale would affect the projection
     **/
    __publicField(this, "shadowsRoot", new Object3D());
    __publicField(this, "shadowCamera");
    __publicField(this, "shadowGroup", new Group());
    __publicField(this, "renderTarget");
    __publicField(this, "renderTargetBlur");
    __publicField(this, "plane");
    __publicField(this, "occluderMesh");
    __publicField(this, "blurPlane");
    __publicField(this, "depthMaterial");
    __publicField(this, "horizontalBlurMaterial");
    __publicField(this, "verticalBlurMaterial");
    __publicField(this, "textureSize", 512);
  }
  /**
   * Create contact shadows for the scene. Automatically fits the shadows to the scene.
   * The instance of contact shadows will be created only once.
   * @param context The context to create the contact shadows in.
   * @returns The instance of the contact shadows.
   */
  static auto(context) {
    if (!context)
      context = Context.Current;
    if (!context) {
      throw new Error("No context provided and no current context set.");
    }
    let instance = this._instances.get(context);
    if (!instance || instance.destroyed) {
      const obj = new Object3D();
      instance = addComponent(obj, _ContactShadows, {
        autoFit: false,
        occludeBelowGround: false
      });
      this._instances.set(context, instance);
    }
    context.scene.add(instance.gameObject);
    instance.fitShadows();
    return instance;
  }
  /**
   * Call to fit the shadows to the scene.
   */
  fitShadows() {
    if (debug79)
      console.warn("Fitting shadows to scene");
    setAutoFitEnabled(this.shadowsRoot, false);
    const box2 = getBoundingBox(this.context.scene.children, [this.shadowsRoot]);
    const expandFactor = Math.max(1, this.blur / 32);
    const sizeX = box2.max.x - box2.min.x;
    const sizeZ = box2.max.z - box2.min.z;
    box2.expandByVector(new Vector32(expandFactor * sizeX, 0, expandFactor * sizeZ));
    if (debug79)
      Gizmos.DrawWireBox3(box2, 16776960, 60);
    if (this.gameObject.parent) {
      box2.applyMatrix4(this.gameObject.parent.matrixWorld.clone().invert());
    }
    const min = box2.min;
    const offset = Math.max(1e-5, (box2.max.y - min.y) * 2e-3);
    box2.max.y += offset;
    this.shadowsRoot.position.set((min.x + box2.max.x) / 2, min.y - offset, (min.z + box2.max.z) / 2);
    this.shadowsRoot.scale.set(box2.max.x - min.x, box2.max.y - min.y, box2.max.z - min.z);
    this.applyMinSize();
    this.shadowsRoot.matrixWorldNeedsUpdate = true;
    if (debug79)
      console.log("Fitted shadows to scene", this.shadowsRoot.scale.clone());
  }
  /** @internal */
  awake() {
    setAutoFitEnabled(this.shadowsRoot, false);
  }
  /** @internal */
  start() {
    if (debug79)
      console.log("Create ContactShadows on " + this.gameObject.name, this);
    this.gameObject.add(this.shadowsRoot);
    this.shadowsRoot.add(this.shadowGroup);
    this.renderTarget = new WebGLRenderTarget(this.textureSize, this.textureSize);
    this.renderTarget.texture.generateMipmaps = false;
    this.renderTargetBlur = new WebGLRenderTarget(this.textureSize, this.textureSize);
    this.renderTargetBlur.texture.generateMipmaps = false;
    const planeGeometry = new PlaneGeometry(1, 1).rotateX(Math.PI / 2);
    if (this.gameObject instanceof Mesh) {
      console.warn("ContactShadows can not be added to a Mesh. Please add it to a Group or an empty Object");
      setCustomVisibility(this.gameObject, false);
    }
    const planeMaterial = new MeshBasicMaterial({
      map: this.renderTarget.texture,
      opacity: this.opacity,
      color: 0,
      transparent: true,
      depthWrite: false,
      side: FrontSide
    });
    this.plane = new Mesh(planeGeometry, planeMaterial);
    this.plane.scale.y = -1;
    this.plane.layers.set(2);
    this.shadowsRoot.add(this.plane);
    if (this.plane)
      this.plane.renderOrder = 1;
    this.occluderMesh = new Mesh(this.plane.geometry, new MeshBasicMaterial({
      depthWrite: true,
      stencilWrite: true,
      colorWrite: false,
      side: BackSide
    })).translateY(-1e-4);
    this.occluderMesh.renderOrder = -100;
    this.occluderMesh.layers.set(2);
    this.shadowsRoot.add(this.occluderMesh);
    this.blurPlane = new Mesh(planeGeometry);
    this.blurPlane.visible = false;
    this.shadowGroup.add(this.blurPlane);
    const near = 0;
    const far = 1;
    this.shadowCamera = new OrthographicCamera(-1 / 2, 1 / 2, 1 / 2, -1 / 2, near, far);
    this.shadowCamera.layers.enableAll();
    this.shadowCamera.rotation.x = Math.PI / 2;
    this.shadowGroup.add(this.shadowCamera);
    this.depthMaterial = new MeshDepthMaterial();
    this.depthMaterial.userData.darkness = { value: this.darkness };
    this.depthMaterial.blending = CustomBlending;
    this.depthMaterial.blendEquation = MaxEquation;
    this.depthMaterial.onBeforeCompile = (shader) => {
      if (!this.depthMaterial)
        return;
      shader.uniforms.darkness = this.depthMaterial.userData.darkness;
      shader.fragmentShader = /* glsl */
      `
                uniform float darkness;
                ${shader.fragmentShader.replace(
        "gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );",
        // we're scaling the shadow value down a bit when it's a backface (looks better)
        "gl_FragColor = vec4( vec3( 1.0 ), ( 1.0 - fragCoordZ ) * darkness * opacity * (gl_FrontFacing ? 1.0 : 0.66) );"
      )}
            `;
    };
    this.depthMaterial.depthTest = false;
    this.depthMaterial.depthWrite = false;
    this.horizontalBlurMaterial = new ShaderMaterial(HorizontalBlurShader);
    this.horizontalBlurMaterial.depthTest = false;
    this.verticalBlurMaterial = new ShaderMaterial(VerticalBlurShader);
    this.verticalBlurMaterial.depthTest = false;
    this.shadowGroup.visible = false;
    if (this.autoFit)
      this.fitShadows();
    else
      this.applyMinSize();
  }
  /** @internal */
  onDestroy() {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    (_a2 = this.renderTarget) == null ? void 0 : _a2.dispose();
    (_b = this.renderTargetBlur) == null ? void 0 : _b.dispose();
    (_c = this.depthMaterial) == null ? void 0 : _c.dispose();
    (_d = this.horizontalBlurMaterial) == null ? void 0 : _d.dispose();
    (_e = this.verticalBlurMaterial) == null ? void 0 : _e.dispose();
    (_f = this.blurPlane) == null ? void 0 : _f.geometry.dispose();
    (_g = this.plane) == null ? void 0 : _g.geometry.dispose();
    (_h = this.occluderMesh) == null ? void 0 : _h.geometry.dispose();
  }
  /** @internal */
  onBeforeRender(_frame2) {
    if (!this.renderTarget || !this.renderTargetBlur || !this.depthMaterial || !this.shadowCamera || !this.blurPlane || !this.shadowGroup || !this.plane || !this.horizontalBlurMaterial || !this.verticalBlurMaterial) {
      if (debug79)
        console.error("ContactShadows: not initialized yet");
      return;
    }
    const scene = this.context.scene;
    const renderer = this.context.renderer;
    const initialRenderTarget = renderer.getRenderTarget();
    this.shadowGroup.visible = true;
    if (this.occluderMesh)
      this.occluderMesh.visible = false;
    const planeWasVisible = this.plane.visible;
    this.plane.visible = false;
    if (this.gameObject instanceof Mesh) {
      setCustomVisibility(this.gameObject, false);
    }
    const initialBackground = scene.background;
    scene.background = null;
    scene.overrideMaterial = this.depthMaterial;
    if (this.backfaceShadows)
      this.depthMaterial.side = DoubleSide;
    else {
      this.depthMaterial.side = FrontSide;
    }
    const initialClearAlpha = renderer.getClearAlpha();
    renderer.setClearAlpha(0);
    const prevXRState = renderer.xr.enabled;
    renderer.xr.enabled = false;
    const prevSceneMatrixAutoUpdate = this.context.scene.matrixWorldAutoUpdate;
    this.context.scene.matrixWorldAutoUpdate = false;
    const list = renderer.renderLists.get(scene, 0);
    const prevTransparent = list.transparent;
    empty_buffer.length = 0;
    list.transparent = empty_buffer;
    objects_hidden.length = 0;
    for (const entry of list.opaque) {
      if (!entry.object.visible)
        continue;
      const mat = entry.material;
      let hide2 = entry.material.colorWrite == false || mat.wireframe === true || getVisibleInCustomShadowRendering(entry.object) === false;
      if (!hide2 && entry.material.linewidth != void 0) {
        hide2 = true;
      }
      if (hide2) {
        objects_hidden.push(entry.object);
        entry.object["needle:visible"] = entry.object.visible;
        entry.object.visible = false;
      }
    }
    renderer.setRenderTarget(this.renderTarget);
    renderer.clear();
    renderer.render(scene, this.shadowCamera);
    list.transparent = prevTransparent;
    for (const object of objects_hidden) {
      if (object["needle:visible"] != void 0) {
        object.visible = object["needle:visible"];
      }
    }
    scene.overrideMaterial = null;
    const blurAmount = Math.max(this.blur, 0.05);
    this.blurShadow(blurAmount * 2);
    this.blurShadow(blurAmount * 0.5);
    this.shadowGroup.visible = false;
    if (this.occluderMesh)
      this.occluderMesh.visible = this.occludeBelowGround;
    this.plane.visible = planeWasVisible;
    renderer.setRenderTarget(initialRenderTarget);
    renderer.setClearAlpha(initialClearAlpha);
    scene.background = initialBackground;
    renderer.xr.enabled = prevXRState;
    this.context.scene.matrixWorldAutoUpdate = prevSceneMatrixAutoUpdate;
  }
  // renderTarget --> blurPlane (horizontalBlur) --> renderTargetBlur --> blurPlane (verticalBlur) --> renderTarget
  blurShadow(amount) {
    if (!this.blurPlane || !this.shadowCamera || !this.renderTarget || !this.renderTargetBlur || !this.horizontalBlurMaterial || !this.verticalBlurMaterial)
      return;
    this.blurPlane.visible = true;
    const ws = this.shadowsRoot.worldScale;
    const avg = (ws.x + ws.z) / 2;
    const aspectX = ws.z / avg;
    const aspectZ = ws.x / avg;
    this.blurPlane.material = this.horizontalBlurMaterial;
    this.blurPlane.material.uniforms.tDiffuse.value = this.renderTarget.texture;
    this.horizontalBlurMaterial.uniforms.h.value = amount * 1 / this.textureSize * aspectX;
    const renderer = this.context.renderer;
    const currentRt = renderer.getRenderTarget();
    renderer.setRenderTarget(this.renderTargetBlur);
    renderer.render(this.blurPlane, this.shadowCamera);
    this.blurPlane.material = this.verticalBlurMaterial;
    this.blurPlane.material.uniforms.tDiffuse.value = this.renderTargetBlur.texture;
    this.verticalBlurMaterial.uniforms.v.value = amount * 1 / this.textureSize * aspectZ;
    renderer.setRenderTarget(this.renderTarget);
    renderer.render(this.blurPlane, this.shadowCamera);
    this.blurPlane.visible = false;
    renderer.setRenderTarget(currentRt);
  }
  applyMinSize() {
    if (this.minSize) {
      this.shadowsRoot.scale.set(Math.max(this.minSize.x || 0, this.shadowsRoot.scale.x), Math.max(this.minSize.y || 0, this.shadowsRoot.scale.y), Math.max(this.minSize.z || 0, this.shadowsRoot.scale.z));
    }
  }
};
var ContactShadows = _ContactShadows;
__publicField(ContactShadows, "_instances", /* @__PURE__ */ new Map());
__decorate45([
  serializable()
], ContactShadows.prototype, "autoFit", void 0);
__decorate45([
  serializable()
], ContactShadows.prototype, "darkness", void 0);
__decorate45([
  serializable()
], ContactShadows.prototype, "opacity", void 0);
__decorate45([
  serializable()
], ContactShadows.prototype, "blur", void 0);
__decorate45([
  serializable()
], ContactShadows.prototype, "occludeBelowGround", void 0);
__decorate45([
  serializable()
], ContactShadows.prototype, "backfaceShadows", void 0);
var empty_buffer = [];
var objects_hidden = new Array();

// node_modules/@needle-tools/engine/lib/engine/webcomponents/WebXRButtons.js
var _WebXRButtonFactory = class {
  constructor() {
    __publicField(this, "_quicklookButton");
    __publicField(this, "_arButton");
    __publicField(this, "_vrButton");
    __publicField(this, "_sendToQuestButton");
  }
  static create() {
    return new _WebXRButtonFactory();
  }
  static getOrCreate() {
    if (!this._instance) {
      this._instance = this.create();
    }
    return this._instance;
  }
  get isSecureConnection() {
    return window.location.protocol === "https:";
  }
  get quicklookButton() {
    return this._quicklookButton;
  }
  get arButton() {
    return this._arButton;
  }
  get vrButton() {
    return this._vrButton;
  }
  get sendToQuestButton() {
    return this._sendToQuestButton;
  }
  get qrButton() {
    return ButtonsFactory.getOrCreate().createQRCode();
  }
  /** get or create the quicklook button
   * Behaviour of the button:
   * - if the button is clicked a USDZExporter component will be searched for in the scene and if found, it will be used to export the scene to USDZ / Quicklook
  */
  createQuicklookButton() {
    if (this._quicklookButton)
      return this._quicklookButton;
    const button = document.createElement("button");
    this._quicklookButton = button;
    button.dataset["needle"] = "quicklook-button";
    const supportsQuickLook = DeviceUtilities.supportsQuickLookAR();
    if (supportsQuickLook) {
      button.innerText = "View in AR";
    } else {
      button.innerText = "View in AR";
    }
    button.prepend(getIconElement("view_in_ar"));
    let createdExporter = false;
    let usdzExporter = null;
    button.addEventListener("click", () => {
      usdzExporter = findObjectOfType(USDZExporter2);
      if (!usdzExporter) {
        createdExporter = true;
        usdzExporter = new USDZExporter2();
      }
      if (createdExporter)
        usdzExporter.objectToExport = Context.Current.scene;
      if (usdzExporter) {
        button.classList.add("this-mode-is-requested");
        usdzExporter.exportAndOpen().then(() => {
          button.classList.remove("this-mode-is-requested");
        }).catch((err) => {
          button.classList.remove("this-mode-is-requested");
          console.error(err);
        });
      } else {
        console.warn("No USDZExporter component found in the scene");
      }
    });
    this.hideElementDuringXRSession(button);
    return button;
  }
  /** get or create the WebXR AR button
   * @param init optional session init options
   * Behaviour of the button:
   * - if the device supports AR, the button will be visible and clickable
   * - if the device does not support AR, the button will be hidden
   * - if the device changes and now supports AR, the button will be visible
   */
  createARButton(init) {
    var _a2;
    if (this._arButton)
      return this._arButton;
    const mode = "immersive-ar";
    const button = document.createElement("button");
    this._arButton = button;
    button.classList.add("webxr-button");
    button.dataset["needle"] = "webxr-ar-button";
    button.innerText = "Enter AR";
    button.prepend(getIconElement("view_in_ar"));
    button.title = "Click to start an AR session";
    button.addEventListener("click", () => NeedleXRSession.start(mode, init));
    this.updateSessionSupported(button, mode);
    this.listenToXRSessionState(button, mode);
    this.hideElementDuringXRSession(button);
    if (!this.isSecureConnection) {
      button.disabled = true;
      button.title = "WebXR requires a secure connection (HTTPS)";
    }
    if (!DeviceUtilities.isMozillaXR())
      (_a2 = navigator.xr) == null ? void 0 : _a2.addEventListener("devicechange", () => this.updateSessionSupported(button, mode));
    return button;
  }
  /** get or create the WebXR VR button
   * @param init optional session init options
   * Behaviour of the button:
   * - if the device supports VR, the button will be visible and clickable
   * - if the device does not support VR, the button will be hidden
   * - if the device changes and now supports VR, the button will be visible
  */
  createVRButton(init) {
    var _a2;
    if (this._vrButton)
      return this._vrButton;
    const mode = "immersive-vr";
    const button = document.createElement("button");
    this._vrButton = button;
    button.classList.add("webxr-button");
    button.dataset["needle"] = "webxr-vr-button";
    button.innerText = "Enter VR";
    button.prepend(getIconElement("panorama_photosphere"));
    button.title = "Click to start a VR session";
    button.addEventListener("click", () => NeedleXRSession.start(mode, init));
    this.updateSessionSupported(button, mode);
    this.listenToXRSessionState(button, mode);
    this.hideElementDuringXRSession(button);
    if (!this.isSecureConnection) {
      button.disabled = true;
      button.title = "WebXR requires a secure connection (HTTPS)";
    }
    if (!DeviceUtilities.isMozillaXR())
      (_a2 = navigator.xr) == null ? void 0 : _a2.addEventListener("devicechange", () => this.updateSessionSupported(button, mode));
    return button;
  }
  /** get or create the Send To Quest button
   * Behaviour of the button:
   * - if the button is clicked, the current URL will be sent to the Oculus Browser on the Quest
  */
  createSendToQuestButton() {
    var _a2;
    if (this._sendToQuestButton)
      return this._sendToQuestButton;
    const baseUrl = `https://oculus.com/open_url/?url=`;
    const button = document.createElement("button");
    this._sendToQuestButton = button;
    button.dataset["needle"] = "webxr-sendtoquest-button";
    button.innerText = "Open on Quest";
    button.prepend(getIconElement("share_windows"));
    button.title = "Click to send this page to the Oculus Browser on your Quest";
    button.addEventListener("click", () => {
      const urlParameter = encodeURIComponent(window.location.href);
      const url = baseUrl + urlParameter;
      if (window.open(url) == null) {
        showBalloonMessage("This page doesn't allow popups. Please paste " + url + " into your browser.");
      }
    });
    this.listenToXRSessionState(button);
    this.hideElementDuringXRSession(button);
    if (!DeviceUtilities.isMozillaXR()) {
      (_a2 = navigator.xr) == null ? void 0 : _a2.addEventListener("devicechange", () => {
        var _a3;
        if ((_a3 = navigator.xr) == null ? void 0 : _a3.isSessionSupported("immersive-vr")) {
          button.style.display = "none";
        } else {
          button.style.display = "";
        }
      });
    }
    return button;
  }
  /**
   * @deprecated please use ButtonsFactory.getOrCreate().createQRCode(). This method will be removed in a future update
   */
  createQRCode() {
    return ButtonsFactory.getOrCreate().createQRCode();
  }
  updateSessionSupported(button, mode) {
    if (!("xr" in navigator)) {
      button.style.display = "none";
      return;
    }
    NeedleXRSession.isSessionSupported(mode).then((supported) => {
      button.style.display = !supported ? "none" : "";
      if (isDevEnvironment() && !supported)
        console.log('[WebXR] "' + mode + '" is not supported on this device – make sure your server runs using HTTPS and you have a device connected that supports ' + mode);
    });
  }
  hideElementDuringXRSession(element) {
    onXRSessionStart((_) => {
      element["previous-display"] = element.style.display;
      element.style.display = "none";
    });
    onXRSessionEnd((_) => {
      if (element["previous-display"] != void 0)
        element.style.display = element["previous-display"];
    });
  }
  listenToXRSessionState(button, mode) {
    if (mode) {
      NeedleXRSession.onSessionRequestStart((args) => {
        if (args.mode === mode) {
          button.classList.add("this-mode-is-requested");
        } else {
          button["was-disabled"] = button.disabled;
          button.disabled = true;
          button.classList.add("other-mode-is-requested");
        }
      });
      NeedleXRSession.onSessionRequestEnd((_) => {
        button.classList.remove("this-mode-is-requested");
        button.classList.remove("other-mode-is-requested");
        button.disabled = button["was-disabled"];
      });
    }
  }
};
var WebXRButtonFactory = _WebXRButtonFactory;
__publicField(WebXRButtonFactory, "_instance");

// node_modules/@needle-tools/engine/lib/engine-components/SpriteRenderer.js
var __decorate46 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug80 = getParam("debugspriterenderer");
var showWireframe2 = getParam("wireframe");
var _SpriteUtils = class {
  static getOrCreateGeometry(sprite) {
    if (sprite.__cached_geometry)
      return sprite.__cached_geometry;
    if (sprite.guid) {
      if (_SpriteUtils.cache[sprite.guid]) {
        if (debug80)
          console.log("Take cached geometry for sprite", sprite.guid);
        return _SpriteUtils.cache[sprite.guid];
      }
    }
    const geo = new BufferGeometry();
    sprite.__cached_geometry = geo;
    const vertices = new Float32Array(sprite.triangles.length * 3);
    const uvs = new Float32Array(sprite.triangles.length * 2);
    for (let i = 0; i < sprite.triangles.length; i += 1) {
      const index = sprite.triangles[i];
      vertices[i * 3] = -sprite.vertices[index].x;
      vertices[i * 3 + 1] = sprite.vertices[index].y;
      vertices[i * 3 + 2] = 0;
      const uv = sprite.uv[index];
      uvs[i * 2] = uv.x;
      uvs[i * 2 + 1] = 1 - uv.y;
    }
    geo.setAttribute("position", new BufferAttribute2(vertices, 3));
    geo.setAttribute("uv", new BufferAttribute2(uvs, 2));
    if (sprite.guid)
      this.cache[sprite.guid] = geo;
    if (debug80)
      console.log("Built sprite geometry", sprite, geo);
    return geo;
  }
};
var SpriteUtils = _SpriteUtils;
__publicField(SpriteUtils, "cache", {});
var SpriteDrawMode;
(function(SpriteDrawMode2) {
  SpriteDrawMode2[SpriteDrawMode2["Simple"] = 0] = "Simple";
  SpriteDrawMode2[SpriteDrawMode2["Sliced"] = 1] = "Sliced";
  SpriteDrawMode2[SpriteDrawMode2["Tiled"] = 2] = "Tiled";
})(SpriteDrawMode || (SpriteDrawMode = {}));
var Vec22 = class {
  constructor() {
    __publicField(this, "x");
    __publicField(this, "y");
  }
};
function updateTextureIfNecessary(tex) {
  if (!tex)
    return;
  if (tex.colorSpace != SRGBColorSpace) {
    tex.colorSpace = SRGBColorSpace;
    tex.needsUpdate = true;
  }
  if (tex.minFilter == NearestFilter && tex.magFilter == NearestFilter) {
    tex.anisotropy = 1;
    tex.needsUpdate = true;
  }
}
var Sprite3 = class {
  constructor(texture) {
    __publicField(this, "guid");
    __publicField(this, "texture");
    __publicField(this, "triangles");
    __publicField(this, "uv");
    __publicField(this, "vertices");
    /** @internal */
    __publicField(this, "__cached_geometry");
    __publicField(this, "_mesh");
    __publicField(this, "_material");
    if (texture) {
      this.texture = texture;
      this.triangles = [0, 1, 2, 0, 2, 3];
      this.uv = [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 1, y: 1 }, { x: 0, y: 1 }];
      this.vertices = [{ x: -0.5, y: -0.5 }, { x: 0.5, y: -0.5 }, { x: 0.5, y: 0.5 }, { x: -0.5, y: 0.5 }];
    }
  }
  /**
   * The mesh that represents the sprite
   */
  get mesh() {
    if (!this._mesh) {
      this._mesh = new Mesh(SpriteUtils.getOrCreateGeometry(this), this.material);
    }
    return this._mesh;
  }
  /**
   * The material used to render the sprite
   */
  get material() {
    if (!this._material) {
      if (this.texture) {
        updateTextureIfNecessary(this.texture);
      }
      this._material = new MeshBasicMaterial({
        map: this.texture,
        color: 16777215,
        side: DoubleSide,
        transparent: true
      });
    }
    return this._material;
  }
  /**
   * The geometry of the sprite that can be used to create a mesh
   */
  getGeometry() {
    return SpriteUtils.getOrCreateGeometry(this);
  }
};
__decorate46([
  serializable()
], Sprite3.prototype, "guid", void 0);
__decorate46([
  serializable(Texture)
], Sprite3.prototype, "texture", void 0);
__decorate46([
  serializeable()
], Sprite3.prototype, "triangles", void 0);
__decorate46([
  serializeable()
], Sprite3.prototype, "uv", void 0);
__decorate46([
  serializeable()
], Sprite3.prototype, "vertices", void 0);
var $spriteTexOwner = Symbol("spriteOwner");
var SpriteSheet = class {
  constructor() {
    __publicField(this, "sprites");
  }
};
__decorate46([
  serializable(Sprite3)
], SpriteSheet.prototype, "sprites", void 0);
var SpriteData = class {
  // we don't assign anything here because it's used by the serialization system.
  // there's currently a limitation in the serializer when e.g. spriteSheet is already assigned it will not be overriden by the serializer
  // hence the spriteSheet field is undefined by default
  constructor() {
    /**
     * The spritesheet holds all sprites that can be rendered by the sprite renderer
     */
    __publicField(this, "spriteSheet");
    /**
     * The index of the sprite to be rendered in the currently assigned sprite sheet
     */
    __publicField(this, "index", 0);
  }
  static create() {
    const i = new SpriteData();
    i.spriteSheet = new SpriteSheet();
    return i;
  }
  /**
   * Set the sprite to be rendered in the currently assigned sprite sheet at the currently active index {@link index}
   */
  set sprite(sprite) {
    if (!sprite) {
      return;
    }
    if (!this.spriteSheet) {
      this.spriteSheet = new SpriteSheet();
      this.spriteSheet.sprites = [sprite];
      this.index = 0;
    } else {
      if (this.index === null || this.index === void 0)
        this.index = 0;
      this.spriteSheet.sprites[this.index] = sprite;
    }
  }
  /** The currently active sprite */
  get sprite() {
    if (!this.spriteSheet)
      return void 0;
    return this.spriteSheet.sprites[this.index];
  }
  update(material) {
    if (!this.spriteSheet)
      return;
    const index = this.index;
    if (index < 0 || index >= this.spriteSheet.sprites.length)
      return;
    const sprite = this.spriteSheet.sprites[index];
    const tex = sprite == null ? void 0 : sprite.texture;
    if (!tex)
      return;
    updateTextureIfNecessary(tex);
    if (!sprite["__hasLoadedProgressive"]) {
      sprite["__hasLoadedProgressive"] = true;
      const previousTexture = tex;
      NEEDLE_progressive.assignTextureLOD(tex, 0).then((res) => {
        if (res instanceof Texture) {
          sprite.texture = res;
          const shouldUpdateInMaterial = (material == null ? void 0 : material["map"]) === previousTexture;
          if (shouldUpdateInMaterial) {
            material["map"] = res;
            material.needsUpdate = true;
          }
        }
      });
    }
  }
};
__decorate46([
  serializable(SpriteSheet)
], SpriteData.prototype, "spriteSheet", void 0);
__decorate46([
  serializable()
], SpriteData.prototype, "index", void 0);
var SpriteRenderer = class extends Component2 {
  constructor() {
    super(...arguments);
    /** @internal The draw mode of the sprite renderer */
    __publicField(this, "drawMode", SpriteDrawMode.Simple);
    /** @internal Used when drawMode is set to Tiled */
    __publicField(this, "size", { x: 1, y: 1 });
    __publicField(this, "color");
    /**
     * The material that is used to render the sprite
     */
    __publicField(this, "sharedMaterial");
    // additional data
    __publicField(this, "transparent", true);
    __publicField(this, "cutoutThreshold", 0);
    __publicField(this, "castShadows", false);
    __publicField(this, "renderOrder", 0);
    __publicField(this, "toneMapped", true);
    __publicField(this, "_spriteSheet");
    __publicField(this, "_currentSprite");
  }
  /**
   * Assign a new texture to the currently active sprite
   */
  set texture(value) {
    var _a2;
    if (!this._spriteSheet)
      return;
    const currentSprite = (_a2 = this._spriteSheet.spriteSheet) == null ? void 0 : _a2.sprites[this.spriteIndex];
    if (!currentSprite)
      return;
    currentSprite.texture = value;
    this.updateSprite();
  }
  /**
   * Add a new sprite to the currently assigned sprite sheet. The sprite will be added to the end of the sprite sheet.
   * Note that the sprite will not be rendered by default - set the `spriteIndex` to the index of the sprite to be rendered.
   * @param sprite The sprite to be added
   * @returns The index of the sprite in the sprite sheet
   * @example
   * ```typescript
   * const spriteRenderer = gameObject.addComponent(SpriteRenderer);
   * const index = spriteRenderer.addSprite(mySprite);
   * if(index >= 0)
   *   spriteRenderer.spriteIndex = index;
   * ```
   */
  addSprite(sprite, setActive2 = false) {
    var _a2, _b;
    if (!this._spriteSheet) {
      this._spriteSheet = SpriteData.create();
    }
    if (!this._spriteSheet.spriteSheet)
      return -1;
    (_a2 = this._spriteSheet.spriteSheet) == null ? void 0 : _a2.sprites.push(sprite);
    const index = ((_b = this._spriteSheet.spriteSheet) == null ? void 0 : _b.sprites.length) - 1;
    if (setActive2) {
      this.spriteIndex = index;
    }
    return index;
  }
  /**
   * Get the currently active sprite
   */
  get sprite() {
    return this._spriteSheet;
  }
  /**
   * Set the sprite to be rendered in the currently assigned sprite sheet at the currently active index {@link spriteIndex}
   */
  set sprite(value) {
    if (value === this._spriteSheet)
      return;
    if (typeof value === "number") {
      const index = Math.floor(value);
      this.spriteIndex = index;
      return;
    } else if (value instanceof Sprite3) {
      if (!this._spriteSheet) {
        this._spriteSheet = SpriteData.create();
      }
      if (this._spriteSheet.sprite != value) {
        this._spriteSheet.sprite = value;
        this.updateSprite();
      }
    } else if (value != this._spriteSheet) {
      this._spriteSheet = value;
      this.updateSprite();
    }
  }
  /**
   * Set the index of the sprite to be rendered in the currently assigned sprite sheet
   */
  set spriteIndex(value) {
    if (!this._spriteSheet)
      return;
    if (value === this.spriteIndex)
      return;
    this._spriteSheet.index = value;
    this.updateSprite();
  }
  get spriteIndex() {
    var _a2;
    return ((_a2 = this._spriteSheet) == null ? void 0 : _a2.index) ?? 0;
  }
  /**
   * Get the number of sprites in the currently assigned sprite sheet
   */
  get spriteFrames() {
    var _a2, _b;
    return ((_b = (_a2 = this._spriteSheet) == null ? void 0 : _a2.spriteSheet) == null ? void 0 : _b.sprites.length) ?? 0;
  }
  /** @internal */
  awake() {
    this._currentSprite = void 0;
    if (!this._spriteSheet) {
      this._spriteSheet = new SpriteData();
      this._spriteSheet.spriteSheet = new SpriteSheet();
    }
    if (debug80) {
      console.log("Awake", this.name, this, this.sprite);
    }
  }
  /** @internal */
  start() {
    if (!this._currentSprite)
      this.updateSprite();
    else if (this.gameObject)
      this.gameObject.add(this._currentSprite);
  }
  /**
   * Update the sprite. Modified properties will be applied to the sprite mesh. This method is called automatically when the sprite is changed.
   * @param force If true, the sprite will be forced to update.
   * @returns True if the sprite was updated successfully
   */
  updateSprite(force = false) {
    var _a2;
    if (!this.__didAwake && !force)
      return false;
    const data = this._spriteSheet;
    if (!((_a2 = data == null ? void 0 : data.spriteSheet) == null ? void 0 : _a2.sprites)) {
      console.warn("SpriteRenderer has no data or spritesheet assigned...");
      return false;
    }
    const sprite = data.spriteSheet.sprites[this.spriteIndex];
    if (!sprite) {
      if (debug80)
        console.warn("Sprite not found", this.spriteIndex, data.spriteSheet.sprites);
      return false;
    }
    if (!this._currentSprite) {
      const mat = new MeshBasicMaterial({ color: 16777215, side: DoubleSide });
      if (showWireframe2)
        mat.wireframe = true;
      if (this.color) {
        if (!mat["color"])
          mat["color"] = new Color();
        mat["color"].copy(this.color);
        mat["opacity"] = this.color.alpha;
      }
      mat.transparent = true;
      mat.toneMapped = this.toneMapped;
      if (sprite.texture && !mat.wireframe) {
        let tex = sprite.texture;
        if (tex[$spriteTexOwner] !== void 0 && tex[$spriteTexOwner] !== this && this.spriteFrames > 1) {
          tex = sprite.texture = tex.clone();
        }
        tex[$spriteTexOwner] = this;
        mat["map"] = tex;
      }
      this.sharedMaterial = mat;
      this._currentSprite = new Mesh(SpriteUtils.getOrCreateGeometry(sprite), mat);
      this._currentSprite.renderOrder = Math.round(this.renderOrder);
      NEEDLE_progressive.assignTextureLOD(mat, 0);
    } else {
      this._currentSprite.geometry = SpriteUtils.getOrCreateGeometry(sprite);
      this._currentSprite.material["map"] = sprite.texture;
    }
    if (this._currentSprite.parent !== this.gameObject) {
      if (this.drawMode === SpriteDrawMode.Tiled)
        this._currentSprite.scale.set(this.size.x, this.size.y, 1);
      if (this.gameObject)
        this.gameObject.add(this._currentSprite);
    }
    if (this._currentSprite) {
      this._currentSprite.layers.set(this.layer);
    }
    if (this.sharedMaterial) {
      this.sharedMaterial.alphaTest = this.cutoutThreshold;
      this.sharedMaterial.transparent = this.transparent;
    }
    this._currentSprite.castShadow = this.castShadows;
    data == null ? void 0 : data.update(this.sharedMaterial);
    return true;
  }
};
__decorate46([
  serializable()
], SpriteRenderer.prototype, "drawMode", void 0);
__decorate46([
  serializable(Vec22)
], SpriteRenderer.prototype, "size", void 0);
__decorate46([
  serializable(RGBAColor)
], SpriteRenderer.prototype, "color", void 0);
__decorate46([
  serializable(Material)
], SpriteRenderer.prototype, "sharedMaterial", void 0);
__decorate46([
  serializable()
], SpriteRenderer.prototype, "transparent", void 0);
__decorate46([
  serializable()
], SpriteRenderer.prototype, "cutoutThreshold", void 0);
__decorate46([
  serializable()
], SpriteRenderer.prototype, "castShadows", void 0);
__decorate46([
  serializable()
], SpriteRenderer.prototype, "renderOrder", void 0);
__decorate46([
  serializable()
], SpriteRenderer.prototype, "toneMapped", void 0);
__decorate46([
  serializable(SpriteData)
], SpriteRenderer.prototype, "sprite", null);

// node_modules/@needle-tools/engine/lib/engine-components/webxr/WebARSessionRoot.js
var debug81 = getParam("debugwebxr");
var invertForwardMatrix = new Matrix4().makeRotationY(Math.PI);
var WebARSessionRoot = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "_arScale", 1);
    /** When enabled the placed scene forward direction will towards the XRRig
     * @deprecated
     * @default false
    */
    __publicField(this, "invertForward", false);
    /** When assigned this asset will be loaded and visualize the placement while in AR
     * @default null
     */
    __publicField(this, "customReticle");
    /** Enable touch transform to translate, rotate and scale the scene in AR with multitouch
     * @default true
     */
    __publicField(this, "arTouchTransform", true);
    /** When enabled the scene will be placed automatically when a point in the real world is found
     * @default false
     */
    __publicField(this, "autoPlace", false);
    /** When enabled the scene center will be automatically calculated from the content in the scene */
    __publicField(this, "autoCenter", false);
    /** Experimental: When enabled we will create a XR anchor for the scene placement
     * and make sure the scene is at that anchored point during a XR session
     * @default false
     **/
    __publicField(this, "useXRAnchor", false);
    /** true if we're currently placing the scene */
    __publicField(this, "_isPlacing", true);
    /** This is the world matrix of the ar session root when entering webxr
     * it is applied when the scene has been placed (e.g. if the session root is x:10, z:10 we want this position to be the center of the scene)
     */
    __publicField(this, "_startOffset", new Matrix4());
    __publicField(this, "_createdPlacementObject", null);
    __publicField(this, "_reparentedComponents", []);
    // move objects into a temporary scene while placing (which is not rendered) so that the components won't be disabled during this process
    // e.g. we want the avatar to still be updated while placing
    // another possibly solution would be to ensure from this component that the Rig is *also* not disabled while placing
    __publicField(this, "_placementScene", new Scene());
    /** the reticles used for placement */
    __publicField(this, "_reticle", []);
    /** needs to be in sync with the reticles */
    __publicField(this, "_hits", []);
    __publicField(this, "_placementStartTime", -1);
    __publicField(this, "_rigPlacementMatrix");
    /** if useAnchor is enabled this is the anchor we have created on placing the scene using the placement hit */
    __publicField(this, "_anchor", null);
    /** user input is used for ar touch transform */
    __publicField(this, "userInput");
    __publicField(this, "onPlaceScene", (evt) => {
      var _a2;
      if (this._isPlacing == false)
        return;
      if (evt == null ? void 0 : evt.used)
        return;
      let reticle = this._reticle[0];
      if (!reticle) {
        console.warn("No reticle to place...");
        return;
      }
      if (!reticle.visible && !this.autoPlace) {
        console.warn("Reticle is not visible (can not place)");
        return;
      }
      if ((_a2 = NeedleXRSession.active) == null ? void 0 : _a2.isTrackingImages) {
        console.warn("Scene Placement is disabled while images are being tracked");
        return;
      }
      let hit = this._hits[0];
      if (evt && evt.origin instanceof NeedleXRController) {
        const controllerReticle = this._reticle[evt.origin.index];
        if (controllerReticle) {
          reticle = controllerReticle;
          hit = this._hits[evt.origin.index];
        }
      }
      if (evt) {
        evt.stopImmediatePropagation();
        evt.stopPropagation();
        evt.use();
      }
      this._isPlacing = false;
      this.context.input.removeEventListener("pointerup", this.onPlaceScene);
      this.onRevertSceneChanges();
      reticle.position.copy(reticle["lastPos"]);
      reticle.quaternion.copy(reticle["lastQuat"]);
      this.onApplyPose(reticle);
      if (this.useXRAnchor) {
        this.onCreateAnchor(NeedleXRSession.active, hit);
      }
      if (this.context.xr) {
        for (const ctrl of this.context.xr.controllers) {
          ctrl.cancelHitTestSource();
        }
      }
    });
    __publicField(this, "upVec", new Vector32(0, 1, 0));
    __publicField(this, "lookPoint", new Vector32());
    __publicField(this, "worldUpVec", new Vector32(0, 1, 0));
  }
  /**
   * Event that is called when the scene has been placed in AR.
   * @param cb the callback that is called when the scene has been placed
   * @returns a function to remove the event listener
   */
  static onPlaced(cb) {
    const event = "placed";
    if (!this._eventListeners[event])
      this._eventListeners[event] = [];
    this._eventListeners[event].push(cb);
    return () => {
      const index = this._eventListeners[event].indexOf(cb);
      if (index >= 0)
        this._eventListeners[event].splice(index, 1);
    };
  }
  /** The scale of a user in AR:
   * Note: a large value makes the scene appear smaller
   * @default 1
   */
  get arScale() {
    return this._arScale;
  }
  set arScale(val) {
    if (val === this._arScale)
      return;
    this._arScale = val;
    this.onScaleChanged();
  }
  onEnable() {
    var _a2;
    (_a2 = this.customReticle) == null ? void 0 : _a2.preload();
  }
  supportsXR(mode) {
    return mode === "immersive-ar";
  }
  onEnterXR(_args) {
    if (debug81)
      console.log("ENTER WEBXR: SessionRoot start...");
    this._anchor = null;
    this.gameObject.updateMatrixWorld();
    this._startOffset.copy(this.gameObject.matrixWorld);
    const rootObject = new Object3D();
    this._createdPlacementObject = rootObject;
    rootObject.name = "AR Session Root";
    this._placementScene.name = "AR Placement Scene";
    this._placementScene.children.length = 0;
    for (let i = this.context.scene.children.length - 1; i >= 0; i--) {
      const ch = this.context.scene.children[i];
      this._placementScene.add(ch);
    }
    this.context.scene.add(rootObject);
    if (this.autoCenter) {
      const bounds = getBoundingBox(this._placementScene.children);
      const center = bounds.getCenter(new Vector32());
      const size = bounds.getSize(new Vector32());
      const matrix = new Matrix4();
      matrix.makeTranslation(center.x, center.y - size.y * 0.5, center.z);
      this._startOffset.multiply(matrix);
    }
    this._reparentedComponents.length = 0;
    this._reparentedComponents.push({ comp: this, originalObject: this.gameObject });
    GameObject.addComponent(rootObject, this);
    for (const ret of this._reticle) {
      destroy(ret);
    }
    this._reticle.length = 0;
    this._isPlacing = true;
    this.context.input.addEventListener("pointerup", this.onPlaceScene, { queue: InputEventQueue.Early });
  }
  onLeaveXR() {
    this.context.input.removeEventListener("pointerup", this.onPlaceScene, { queue: InputEventQueue.Early });
    this.onRevertSceneChanges();
    this._anchor = null;
    this._rigPlacementMatrix = void 0;
  }
  onUpdateXR(args) {
    var _a2, _b, _c, _d;
    if (args.xr.isTrackingImages) {
      for (const ret of this._reticle)
        ret.visible = false;
      return;
    }
    if (this._isPlacing) {
      const rigObject = (_a2 = args.xr.rig) == null ? void 0 : _a2.gameObject;
      if (rigObject && rigObject.parent !== this.context.scene) {
        this.context.scene.add(rigObject);
      }
      let controllersDidHit = false;
      if (args.xr.isPassThrough && args.xr.controllers.length > 0 && !this.autoPlace) {
        for (const ctrl of args.xr.controllers) {
          const hit = ctrl.getHitTest();
          if (hit) {
            controllersDidHit = true;
            this.updateReticleAndHits(args.xr, ctrl.index, hit, args.xr.rigScale);
          }
        }
      }
      if (!controllersDidHit) {
        const hit = args.xr.getHitTest();
        if (hit) {
          this.updateReticleAndHits(args.xr, 0, hit, args.xr.rigScale);
        }
      }
    } else {
      if (this._anchor && args.xr.referenceSpace) {
        const pose = args.xr.frame.getPose(this._anchor.anchorSpace, args.xr.referenceSpace);
        if (pose && this.context.time.frame % 20 === 0) {
          const converted = args.xr.convertSpace(pose.transform);
          const reticle = this._reticle[0];
          if (reticle) {
            reticle.position.copy(converted.position);
            reticle.quaternion.copy(converted.quaternion);
            this.onApplyPose(reticle);
          }
        }
      }
      if (this.arTouchTransform) {
        if (!this.userInput)
          this.userInput = new WebXRSessionRootUserInput(this.context);
        (_b = this.userInput) == null ? void 0 : _b.enable();
      } else
        (_c = this.userInput) == null ? void 0 : _c.disable();
      if (this.arTouchTransform && ((_d = this.userInput) == null ? void 0 : _d.hasChanged)) {
        if (args.xr.rig) {
          const rig = args.xr.rig.gameObject;
          this.userInput.applyMatrixTo(rig.matrix, true);
          rig.matrix.decompose(rig.position, rig.quaternion, rig.scale);
          this.userInput.factor = rig.scale.x;
        }
        this.userInput.reset();
      }
    }
  }
  updateReticleAndHits(_xr, i, hit, scale) {
    this._hits[i] = hit.hit;
    let reticle = this._reticle[i];
    if (!reticle) {
      if (this.customReticle) {
        if (this.customReticle.asset) {
          reticle = instantiate(this.customReticle.asset);
        } else {
          this.customReticle.loadAssetAsync();
          return;
        }
      } else {
        reticle = new Mesh(new RingGeometry(0.07, 0.09, 32).rotateX(-Math.PI / 2), new MeshBasicMaterial({ side: DoubleSide, depthTest: false, depthWrite: false, transparent: true, opacity: 1, color: 15658734 }));
        reticle.name = "AR Placement Reticle";
      }
      if (debug81) {
        const axes = new AxesHelper(1);
        axes.position.y += 0.01;
        reticle.add(axes);
      }
      this._reticle[i] = reticle;
      reticle.matrixAutoUpdate = false;
      reticle.visible = false;
    }
    reticle["lastPos"] = reticle["lastPos"] || hit.position.clone();
    reticle["lastQuat"] = reticle["lastQuat"] || hit.quaternion.clone();
    reticle.position.copy(reticle["lastPos"].lerp(hit.position, this.context.time.deltaTime / 0.1));
    reticle["lastPos"].copy(reticle.position);
    reticle.quaternion.copy(reticle["lastQuat"].slerp(hit.quaternion, this.context.time.deltaTime / 0.05));
    reticle["lastQuat"].copy(reticle.quaternion);
    reticle.scale.set(scale, scale, scale);
    if (this.customReticle)
      this.applyViewBasedTransform(reticle);
    reticle.updateMatrix();
    reticle.visible = true;
    if (reticle.parent !== this.context.scene)
      this.context.scene.add(reticle);
    if (this._placementStartTime < 0) {
      this._placementStartTime = this.context.time.realtimeSinceStartup;
    }
    if (this.autoPlace) {
      this.upVec.set(0, 1, 0).applyQuaternion(reticle.quaternion);
      const isUp = this.upVec.dot(getTempVector(0, 1, 0)) > 0.9;
      if (isUp) {
        let autoplace_timer = reticle["autoplace:timer"] || 0;
        if (autoplace_timer >= 1) {
          reticle.visible = false;
          this.onPlaceScene(null);
        } else {
          autoplace_timer += this.context.time.deltaTime;
          reticle["autoplace:timer"] = autoplace_timer;
        }
      } else {
        reticle["autoplace:timer"] = 0;
      }
    }
  }
  onScaleChanged() {
  }
  onRevertSceneChanges() {
    var _a2;
    for (const ret of this._reticle) {
      if (!ret)
        continue;
      ret.visible = false;
      ret == null ? void 0 : ret.removeFromParent();
    }
    this._reticle.length = 0;
    for (let i = this._placementScene.children.length - 1; i >= 0; i--) {
      const ch = this._placementScene.children[i];
      this.context.scene.add(ch);
    }
    (_a2 = this._createdPlacementObject) == null ? void 0 : _a2.removeFromParent();
    for (const reparented of this._reparentedComponents) {
      GameObject.addComponent(reparented.originalObject, reparented.comp);
    }
  }
  async onCreateAnchor(session, hit) {
    if (hit.createAnchor === void 0) {
      console.warn("Hit does not support creating an anchor", hit);
      if (isDevEnvironment())
        showBalloonWarning("Hit does not support creating an anchor");
      return;
    } else {
      const anchor = await hit.createAnchor(session.viewerPose.transform);
      if (session.running && anchor) {
        this._anchor = anchor;
      }
    }
  }
  applyViewBasedTransform(reticle) {
    const camGo = this.context.mainCamera;
    const reticleGo = reticle;
    const camWP = camGo.worldPosition;
    const reticleWp = reticleGo.worldPosition;
    this.upVec.set(0, 1, 0).applyQuaternion(reticle.quaternion);
    const camPos = camGo.worldPosition;
    if (camPos) {
      const camToReticle = reticle.position.clone().sub(camPos);
      const angle = camToReticle.angleTo(this.upVec);
      if (angle < Math.PI / 2) {
        this.upVec.negate();
      }
    }
    const upAngle = this.upVec.angleTo(this.worldUpVec) * 180 / Math.PI;
    const angleForWallPlacement = 30;
    if (upAngle > angleForWallPlacement && upAngle < 180 - angleForWallPlacement || upAngle < -angleForWallPlacement && upAngle > -180 + angleForWallPlacement) {
      this.lookPoint.copy(reticle.position).add(this.upVec);
      this.lookPoint.y = reticle.position.y;
      reticle.lookAt(this.lookPoint);
    } else {
      camWP.y = reticleWp.y;
      reticle.lookAt(camWP);
    }
  }
  onApplyPose(reticle) {
    var _a2, _b, _c, _d;
    const rigObject = (_b = (_a2 = NeedleXRSession.active) == null ? void 0 : _a2.rig) == null ? void 0 : _b.gameObject;
    if (!rigObject) {
      console.warn("No rig object to place");
      return;
    }
    const rigScale = ((_c = NeedleXRSession.active) == null ? void 0 : _c.rigScale) || 1;
    const previousParent = rigObject.parent || this.context.scene;
    if (this._rigPlacementMatrix) {
      (_d = this._rigPlacementMatrix) == null ? void 0 : _d.decompose(rigObject.position, rigObject.quaternion, rigObject.scale);
    } else {
      this._rigPlacementMatrix = rigObject.matrix.clone();
    }
    this.applyViewBasedTransform(reticle);
    reticle.updateMatrix();
    this.context.scene.add(reticle);
    reticle.attach(rigObject);
    reticle.removeFromParent();
    rigObject.scale.set(this.arScale, this.arScale, this.arScale);
    rigObject.position.multiplyScalar(this.arScale);
    rigObject.updateMatrix();
    if (this.invertForward)
      rigObject.matrix.premultiply(invertForwardMatrix);
    rigObject.matrix.premultiply(this._startOffset);
    rigObject.matrix.decompose(rigObject.position, rigObject.quaternion, rigObject.scale);
    previousParent.add(rigObject);
  }
};
__publicField(WebARSessionRoot, "_eventListeners", {});
var _WebXRSessionRootUserInput = class {
  // readonly translate: Vector3 = new Vector3();
  // readonly rotation: Quaternion = new Quaternion();
  // readonly scale: Vector3 = new Vector3(1, 1, 1);
  constructor(context) {
    __publicField(this, "oneFingerDrag", true);
    __publicField(this, "twoFingerRotate", true);
    __publicField(this, "twoFingerScale", true);
    __publicField(this, "factor", 1);
    __publicField(this, "context");
    __publicField(this, "offset");
    __publicField(this, "plane");
    __publicField(this, "_scale", 1);
    __publicField(this, "_hasChanged", false);
    __publicField(this, "_enabled", false);
    __publicField(this, "currentlyUsedPointerIds", /* @__PURE__ */ new Set());
    __publicField(this, "currentlyUnusedPointerIds", /* @__PURE__ */ new Set());
    __publicField(this, "onPointerDownEarly", (e) => {
      if (this.isActive)
        e.stopPropagation();
    });
    __publicField(this, "onPointerDownLate", (e) => {
      if (e.used)
        this.currentlyUsedPointerIds.add(e.pointerId);
      else if (this.currentlyUsedPointerIds.size <= 0)
        this.currentlyUnusedPointerIds.add(e.pointerId);
    });
    __publicField(this, "onPointerUpEarly", (e) => {
      this.currentlyUsedPointerIds.delete(e.pointerId);
      this.currentlyUnusedPointerIds.delete(e.pointerId);
    });
    // private _needsUpdate: boolean = true;
    // private _rotationMatrix: Matrix4 = new Matrix4();
    // private updateMatrix() {
    //     this._needsUpdate = false;
    //     this._rotationMatrix.makeRotationFromQuaternion(this.rotation);
    //     this.offset.compose(this.translate, new Quaternion(), this.scale);
    //     // const rot = this._tempMatrix.makeRotationY(this.angle);
    //     // this.translate.applyMatrix4(rot);
    //     // this.offset.elements[12] = this.translate.x;
    //     // this.offset.elements[13] = this.translate.y;
    //     // this.offset.elements[14] = this.translate.z;
    //     // this.offset.premultiply(rot);
    //     // const s = this.scale;
    //     // this.offset.premultiply(this._tempMatrix.makeScale(s, s, s));
    // }
    __publicField(this, "prev", /* @__PURE__ */ new Map());
    __publicField(this, "_didMultitouch", false);
    __publicField(this, "touchStart", (evt) => {
      if (evt.defaultPrevented)
        return;
      for (let i = 0; i < evt.changedTouches.length; i++) {
        const touch = evt.changedTouches[i];
        const ignore = DeviceUtilities.isAndroidDevice() && touch.clientY < window.innerHeight * 0.1;
        if (!this.prev.has(touch.identifier))
          this.prev.set(touch.identifier, {
            ignore,
            x: 0,
            z: 0,
            screenx: 0,
            screeny: 0
          });
        const prev = this.prev.get(touch.identifier);
        if (prev) {
          const pos = this.getPositionOnPlane(touch.clientX, touch.clientY);
          prev.x = pos.x;
          prev.z = pos.z;
          prev.screenx = touch.clientX;
          prev.screeny = touch.clientY;
        }
      }
    });
    __publicField(this, "touchEnd", (evt) => {
      if (evt.touches.length <= 0) {
        this._didMultitouch = false;
      }
      for (let i = 0; i < evt.changedTouches.length; i++) {
        const touch = evt.changedTouches[i];
        this.prev.delete(touch.identifier);
      }
    });
    __publicField(this, "touchMove", (evt) => {
      if (evt.defaultPrevented)
        return;
      if (!this.isActive)
        return;
      if (evt.touches.length === 1) {
        if (this._didMultitouch) {
          return;
        }
        const touch = evt.touches[0];
        const prev = this.prev.get(touch.identifier);
        if (!prev || prev.ignore)
          return;
        const pos = this.getPositionOnPlane(touch.clientX, touch.clientY);
        const dx = pos.x - prev.x;
        const dy = pos.z - prev.z;
        if (dx === 0 && dy === 0)
          return;
        if (this.oneFingerDrag)
          this.addMovement(dx, dy);
        prev.x = pos.x;
        prev.z = pos.z;
        prev.screenx = touch.clientX;
        prev.screeny = touch.clientY;
        return;
      } else if (evt.touches.length === 2) {
        this._didMultitouch = true;
        const touch1 = evt.touches[0];
        const touch2 = evt.touches[1];
        const prev1 = this.prev.get(touch1.identifier);
        const prev2 = this.prev.get(touch2.identifier);
        if (!prev1 || !prev2)
          return;
        if (this.twoFingerRotate) {
          const angle1 = Math.atan2(touch1.clientY - touch2.clientY, touch1.clientX - touch2.clientX);
          const lastAngle = Math.atan2(prev1.screeny - prev2.screeny, prev1.screenx - prev2.screenx);
          const angleDiff = angle1 - lastAngle;
          if (Math.abs(angleDiff) > 1e-3) {
            this.addRotation(angleDiff);
          }
        }
        if (this.twoFingerScale) {
          const distx = touch1.clientX - touch2.clientX;
          const disty = touch1.clientY - touch2.clientY;
          const dist = Math.sqrt(distx * distx + disty * disty);
          const lastDistx = prev1.screenx - prev2.screenx;
          const lastDisty = prev1.screeny - prev2.screeny;
          const lastDist = Math.sqrt(lastDistx * lastDistx + lastDisty * lastDisty);
          const distDiff = dist - lastDist;
          if (Math.abs(distDiff) > 2) {
            this.addScale(distDiff);
          }
        }
        prev1.screenx = touch1.clientX;
        prev1.screeny = touch1.clientY;
        prev2.screenx = touch2.clientX;
        prev2.screeny = touch2.clientY;
      }
    });
    __publicField(this, "_raycaster", new Raycaster());
    __publicField(this, "_intersection", new Vector32());
    __publicField(this, "_screenPos", new Vector32());
    __publicField(this, "_tempMatrix", new Matrix4());
    this.context = context;
    this.offset = new Matrix4();
    this.plane = new Plane();
    this.plane.setFromNormalAndCoplanarPoint(_WebXRSessionRootUserInput.up, _WebXRSessionRootUserInput.zero);
  }
  reset() {
    this._scale = 1;
    this.offset.identity();
  }
  get hasChanged() {
    return this._hasChanged;
  }
  /**
   * Applies the matrix to the offset matrix
   * @param matrix the matrix to apply the drag offset to
   * @param invert if true the offset matrix will be inverted before applying it to the matrix and premultiplied
   */
  applyMatrixTo(matrix, invert) {
    this._hasChanged = false;
    if (invert) {
      this.offset.invert();
      matrix.premultiply(this.offset);
    } else
      matrix.multiply(this.offset);
  }
  get isActive() {
    return this.currentlyUsedPointerIds.size <= 0 && this.currentlyUnusedPointerIds.size > 0;
  }
  enable() {
    if (this._enabled)
      return;
    this._enabled = true;
    this.context.input.addEventListener("pointerdown", this.onPointerDownEarly, { queue: InputEventQueue.Early });
    this.context.input.addEventListener("pointerdown", this.onPointerDownLate, { queue: InputEventQueue.Late });
    this.context.input.addEventListener("pointerup", this.onPointerUpEarly, { queue: InputEventQueue.Early });
    window.addEventListener("touchstart", this.touchStart, { passive: false });
    window.addEventListener("touchmove", this.touchMove, { passive: false });
    window.addEventListener("touchend", this.touchEnd, { passive: false });
  }
  disable() {
    if (!this._enabled)
      return;
    this._enabled = false;
    this.context.input.removeEventListener("pointerdown", this.onPointerDownEarly, { queue: InputEventQueue.Early });
    this.context.input.removeEventListener("pointerdown", this.onPointerDownLate, { queue: InputEventQueue.Late });
    this.context.input.removeEventListener("pointerup", this.onPointerUpEarly, { queue: InputEventQueue.Early });
    window.removeEventListener("touchstart", this.touchStart);
    window.removeEventListener("touchmove", this.touchMove);
    window.removeEventListener("touchend", this.touchEnd);
  }
  getPositionOnPlane(tx, ty) {
    const camera = this.context.mainCamera;
    this._screenPos.x = tx / window.innerWidth * 2 - 1;
    this._screenPos.y = -(ty / window.innerHeight) * 2 + 1;
    this._screenPos.z = 1;
    this._screenPos.unproject(camera);
    this._raycaster.set(camera.position, this._screenPos.sub(camera.position));
    this._raycaster.ray.intersectPlane(this.plane, this._intersection);
    return this._intersection;
  }
  addMovement(dx, dz) {
    dx /= this._scale;
    dz /= this._scale;
    dx *= this.factor;
    dz *= this.factor;
    this.offset.elements[12] += dx;
    this.offset.elements[14] += dz;
    if (dx !== 0 || dz !== 0)
      this._hasChanged = true;
  }
  addScale(diff) {
    diff /= window.innerWidth;
    diff *= -1;
    this._scale *= 1 + diff;
    this._tempMatrix.makeScale(1 - diff, 1 - diff, 1 - diff);
    this.offset.premultiply(this._tempMatrix);
    if (diff !== 0)
      this._hasChanged = true;
  }
  addRotation(rot) {
    rot *= -1;
    this._tempMatrix.makeRotationY(rot);
    this.offset.premultiply(this._tempMatrix);
    if (rot !== 0)
      this._hasChanged = true;
  }
};
var WebXRSessionRootUserInput = _WebXRSessionRootUserInput;
__publicField(WebXRSessionRootUserInput, "up", new Vector32(0, 1, 0));
__publicField(WebXRSessionRootUserInput, "zero", new Vector32(0, 0, 0));
__publicField(WebXRSessionRootUserInput, "one", new Vector32(1, 1, 1));

// node_modules/@needle-tools/engine/lib/engine-components/NeedleMenu.js
var __decorate47 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var NeedleMenu2 = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "position", "bottom");
    /** Show the Needle logo in the menu (requires PRO license) */
    __publicField(this, "showNeedleLogo", true);
    /** When enabled the menu will also be visible in VR/AR when you look up
     * @default undefined
    */
    __publicField(this, "showSpatialMenu");
    /** When enabled a button to enter fullscreen will be added to the menu
     * @default undefined
    */
    __publicField(this, "createFullscreenButton");
    /** When enabled a button to mute the application will be added to the menu
     * @default undefined
    */
    __publicField(this, "createMuteButton");
    /**
     * When enabled a button to show a QR code will be added to the menu.
     * @default undefined
     */
    __publicField(this, "createQRCodeButton");
  }
  /** @hidden */
  onEnable() {
    this.applyOptions();
  }
  /** applies the options to `this.context.menu` */
  applyOptions() {
    this.context.menu.setPosition(this.position);
    this.context.menu.showNeedleLogo(this.showNeedleLogo);
    if (this.createFullscreenButton === true)
      this.context.menu.showFullscreenOption(true);
    if (this.createMuteButton === true)
      this.context.menu.showAudioPlaybackOption(true);
    if (this.showSpatialMenu === true)
      this.context.menu.showSpatialMenu(this.showSpatialMenu);
    if (this.createQRCodeButton === true) {
      if (!DeviceUtilities.isMobileDevice()) {
        this.context.menu.showQRCodeButton(true);
      }
    }
  }
};
__decorate47([
  serializable()
], NeedleMenu2.prototype, "position", void 0);
__decorate47([
  serializable()
], NeedleMenu2.prototype, "showNeedleLogo", void 0);
__decorate47([
  serializable()
], NeedleMenu2.prototype, "showSpatialMenu", void 0);
__decorate47([
  serializable()
], NeedleMenu2.prototype, "createFullscreenButton", void 0);
__decorate47([
  serializable()
], NeedleMenu2.prototype, "createMuteButton", void 0);
__decorate47([
  serializable()
], NeedleMenu2.prototype, "createQRCodeButton", void 0);

// node_modules/three/examples/jsm/libs/motion-controllers.module.js
var Constants2 = {
  Handedness: Object.freeze({
    NONE: "none",
    LEFT: "left",
    RIGHT: "right"
  }),
  ComponentState: Object.freeze({
    DEFAULT: "default",
    TOUCHED: "touched",
    PRESSED: "pressed"
  }),
  ComponentProperty: Object.freeze({
    BUTTON: "button",
    X_AXIS: "xAxis",
    Y_AXIS: "yAxis",
    STATE: "state"
  }),
  ComponentType: Object.freeze({
    TRIGGER: "trigger",
    SQUEEZE: "squeeze",
    TOUCHPAD: "touchpad",
    THUMBSTICK: "thumbstick",
    BUTTON: "button"
  }),
  ButtonTouchThreshold: 0.05,
  AxisTouchThreshold: 0.1,
  VisualResponseProperty: Object.freeze({
    TRANSFORM: "transform",
    VISIBILITY: "visibility"
  })
};
async function fetchJsonFile2(path) {
  const response = await fetch(path);
  if (!response.ok) {
    throw new Error(response.statusText);
  } else {
    return response.json();
  }
}
async function fetchProfilesList2(basePath) {
  if (!basePath) {
    throw new Error("No basePath supplied");
  }
  const profileListFileName = "profilesList.json";
  const profilesList = await fetchJsonFile2(`${basePath}/${profileListFileName}`);
  return profilesList;
}
async function fetchProfile2(xrInputSource, basePath, defaultProfile = null, getAssetPath = true) {
  if (!xrInputSource) {
    throw new Error("No xrInputSource supplied");
  }
  if (!basePath) {
    throw new Error("No basePath supplied");
  }
  const supportedProfilesList = await fetchProfilesList2(basePath);
  let match;
  xrInputSource.profiles.some((profileId) => {
    const supportedProfile = supportedProfilesList[profileId];
    if (supportedProfile) {
      match = {
        profileId,
        profilePath: `${basePath}/${supportedProfile.path}`,
        deprecated: !!supportedProfile.deprecated
      };
    }
    return !!match;
  });
  if (!match) {
    if (!defaultProfile) {
      throw new Error("No matching profile name found");
    }
    const supportedProfile = supportedProfilesList[defaultProfile];
    if (!supportedProfile) {
      throw new Error(`No matching profile name found and default profile "${defaultProfile}" missing.`);
    }
    match = {
      profileId: defaultProfile,
      profilePath: `${basePath}/${supportedProfile.path}`,
      deprecated: !!supportedProfile.deprecated
    };
  }
  const profile = await fetchJsonFile2(match.profilePath);
  let assetPath;
  if (getAssetPath) {
    let layout;
    if (xrInputSource.handedness === "any") {
      layout = profile.layouts[Object.keys(profile.layouts)[0]];
    } else {
      layout = profile.layouts[xrInputSource.handedness];
    }
    if (!layout) {
      throw new Error(
        `No matching handedness, ${xrInputSource.handedness}, in profile ${match.profileId}`
      );
    }
    if (layout.assetPath) {
      assetPath = match.profilePath.replace("profile.json", layout.assetPath);
    }
  }
  return { profile, assetPath };
}
var defaultComponentValues2 = {
  xAxis: 0,
  yAxis: 0,
  button: 0,
  state: Constants2.ComponentState.DEFAULT
};
function normalizeAxes2(x2 = 0, y = 0) {
  let xAxis = x2;
  let yAxis = y;
  const hypotenuse = Math.sqrt(x2 * x2 + y * y);
  if (hypotenuse > 1) {
    const theta = Math.atan2(y, x2);
    xAxis = Math.cos(theta);
    yAxis = Math.sin(theta);
  }
  const result = {
    normalizedXAxis: xAxis * 0.5 + 0.5,
    normalizedYAxis: yAxis * 0.5 + 0.5
  };
  return result;
}
var VisualResponse2 = class {
  constructor(visualResponseDescription) {
    this.componentProperty = visualResponseDescription.componentProperty;
    this.states = visualResponseDescription.states;
    this.valueNodeName = visualResponseDescription.valueNodeName;
    this.valueNodeProperty = visualResponseDescription.valueNodeProperty;
    if (this.valueNodeProperty === Constants2.VisualResponseProperty.TRANSFORM) {
      this.minNodeName = visualResponseDescription.minNodeName;
      this.maxNodeName = visualResponseDescription.maxNodeName;
    }
    this.value = 0;
    this.updateFromComponent(defaultComponentValues2);
  }
  /**
   * Computes the visual response's interpolation weight based on component state
   * @param {Object} componentValues - The component from which to update
   * @param {number} xAxis - The reported X axis value of the component
   * @param {number} yAxis - The reported Y axis value of the component
   * @param {number} button - The reported value of the component's button
   * @param {string} state - The component's active state
   */
  updateFromComponent({
    xAxis,
    yAxis,
    button,
    state
  }) {
    const { normalizedXAxis, normalizedYAxis } = normalizeAxes2(xAxis, yAxis);
    switch (this.componentProperty) {
      case Constants2.ComponentProperty.X_AXIS:
        this.value = this.states.includes(state) ? normalizedXAxis : 0.5;
        break;
      case Constants2.ComponentProperty.Y_AXIS:
        this.value = this.states.includes(state) ? normalizedYAxis : 0.5;
        break;
      case Constants2.ComponentProperty.BUTTON:
        this.value = this.states.includes(state) ? button : 0;
        break;
      case Constants2.ComponentProperty.STATE:
        if (this.valueNodeProperty === Constants2.VisualResponseProperty.VISIBILITY) {
          this.value = this.states.includes(state);
        } else {
          this.value = this.states.includes(state) ? 1 : 0;
        }
        break;
      default:
        throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`);
    }
  }
};
var Component3 = class {
  /**
   * @param {Object} componentId - Id of the component
   * @param {Object} componentDescription - Description of the component to be created
   */
  constructor(componentId, componentDescription) {
    if (!componentId || !componentDescription || !componentDescription.visualResponses || !componentDescription.gamepadIndices || Object.keys(componentDescription.gamepadIndices).length === 0) {
      throw new Error("Invalid arguments supplied");
    }
    this.id = componentId;
    this.type = componentDescription.type;
    this.rootNodeName = componentDescription.rootNodeName;
    this.touchPointNodeName = componentDescription.touchPointNodeName;
    this.visualResponses = {};
    Object.keys(componentDescription.visualResponses).forEach((responseName) => {
      const visualResponse = new VisualResponse2(componentDescription.visualResponses[responseName]);
      this.visualResponses[responseName] = visualResponse;
    });
    this.gamepadIndices = Object.assign({}, componentDescription.gamepadIndices);
    this.values = {
      state: Constants2.ComponentState.DEFAULT,
      button: this.gamepadIndices.button !== void 0 ? 0 : void 0,
      xAxis: this.gamepadIndices.xAxis !== void 0 ? 0 : void 0,
      yAxis: this.gamepadIndices.yAxis !== void 0 ? 0 : void 0
    };
  }
  get data() {
    const data = { id: this.id, ...this.values };
    return data;
  }
  /**
   * @description Poll for updated data based on current gamepad state
   * @param {Object} gamepad - The gamepad object from which the component data should be polled
   */
  updateFromGamepad(gamepad) {
    this.values.state = Constants2.ComponentState.DEFAULT;
    if (this.gamepadIndices.button !== void 0 && gamepad.buttons.length > this.gamepadIndices.button) {
      const gamepadButton = gamepad.buttons[this.gamepadIndices.button];
      this.values.button = gamepadButton.value;
      this.values.button = this.values.button < 0 ? 0 : this.values.button;
      this.values.button = this.values.button > 1 ? 1 : this.values.button;
      if (gamepadButton.pressed || this.values.button === 1) {
        this.values.state = Constants2.ComponentState.PRESSED;
      } else if (gamepadButton.touched || this.values.button > Constants2.ButtonTouchThreshold) {
        this.values.state = Constants2.ComponentState.TOUCHED;
      }
    }
    if (this.gamepadIndices.xAxis !== void 0 && gamepad.axes.length > this.gamepadIndices.xAxis) {
      this.values.xAxis = gamepad.axes[this.gamepadIndices.xAxis];
      this.values.xAxis = this.values.xAxis < -1 ? -1 : this.values.xAxis;
      this.values.xAxis = this.values.xAxis > 1 ? 1 : this.values.xAxis;
      if (this.values.state === Constants2.ComponentState.DEFAULT && Math.abs(this.values.xAxis) > Constants2.AxisTouchThreshold) {
        this.values.state = Constants2.ComponentState.TOUCHED;
      }
    }
    if (this.gamepadIndices.yAxis !== void 0 && gamepad.axes.length > this.gamepadIndices.yAxis) {
      this.values.yAxis = gamepad.axes[this.gamepadIndices.yAxis];
      this.values.yAxis = this.values.yAxis < -1 ? -1 : this.values.yAxis;
      this.values.yAxis = this.values.yAxis > 1 ? 1 : this.values.yAxis;
      if (this.values.state === Constants2.ComponentState.DEFAULT && Math.abs(this.values.yAxis) > Constants2.AxisTouchThreshold) {
        this.values.state = Constants2.ComponentState.TOUCHED;
      }
    }
    Object.values(this.visualResponses).forEach((visualResponse) => {
      visualResponse.updateFromComponent(this.values);
    });
  }
};
var MotionController2 = class {
  /**
   * @param {Object} xrInputSource - The XRInputSource to build the MotionController around
   * @param {Object} profile - The best matched profile description for the supplied xrInputSource
   * @param {Object} assetUrl
   */
  constructor(xrInputSource, profile, assetUrl) {
    if (!xrInputSource) {
      throw new Error("No xrInputSource supplied");
    }
    if (!profile) {
      throw new Error("No profile supplied");
    }
    this.xrInputSource = xrInputSource;
    this.assetUrl = assetUrl;
    this.id = profile.profileId;
    this.layoutDescription = profile.layouts[xrInputSource.handedness];
    this.components = {};
    Object.keys(this.layoutDescription.components).forEach((componentId) => {
      const componentDescription = this.layoutDescription.components[componentId];
      this.components[componentId] = new Component3(componentId, componentDescription);
    });
    this.updateFromGamepad();
  }
  get gripSpace() {
    return this.xrInputSource.gripSpace;
  }
  get targetRaySpace() {
    return this.xrInputSource.targetRaySpace;
  }
  /**
   * @description Returns a subset of component data for simplified debugging
   */
  get data() {
    const data = [];
    Object.values(this.components).forEach((component) => {
      data.push(component.data);
    });
    return data;
  }
  /**
   * @description Poll for updated data based on current gamepad state
   */
  updateFromGamepad() {
    Object.values(this.components).forEach((component) => {
      component.updateFromGamepad(this.xrInputSource.gamepad);
    });
  }
};

// node_modules/three/examples/jsm/webxr/XRControllerModelFactory.js
var DEFAULT_PROFILES_PATH2 = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles";
var DEFAULT_PROFILE2 = "generic-trigger";
var XRControllerModel = class extends Object3D {
  constructor() {
    super();
    this.motionController = null;
    this.envMap = null;
  }
  setEnvironmentMap(envMap) {
    if (this.envMap == envMap) {
      return this;
    }
    this.envMap = envMap;
    this.traverse((child) => {
      if (child.isMesh) {
        child.material.envMap = this.envMap;
        child.material.needsUpdate = true;
      }
    });
    return this;
  }
  /**
   * Polls data from the XRInputSource and updates the model's components to match
   * the real world data
   */
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (!this.motionController)
      return;
    this.motionController.updateFromGamepad();
    Object.values(this.motionController.components).forEach((component) => {
      Object.values(component.visualResponses).forEach((visualResponse) => {
        const { valueNode, minNode, maxNode, value, valueNodeProperty } = visualResponse;
        if (!valueNode)
          return;
        if (valueNodeProperty === Constants2.VisualResponseProperty.VISIBILITY) {
          valueNode.visible = value;
        } else if (valueNodeProperty === Constants2.VisualResponseProperty.TRANSFORM) {
          valueNode.quaternion.slerpQuaternions(
            minNode.quaternion,
            maxNode.quaternion,
            value
          );
          valueNode.position.lerpVectors(
            minNode.position,
            maxNode.position,
            value
          );
        }
      });
    });
  }
};
function findNodes(motionController, scene) {
  Object.values(motionController.components).forEach((component) => {
    const { type, touchPointNodeName, visualResponses } = component;
    if (type === Constants2.ComponentType.TOUCHPAD) {
      component.touchPointNode = scene.getObjectByName(touchPointNodeName);
      if (component.touchPointNode) {
        const sphereGeometry = new SphereGeometry(1e-3);
        const material = new MeshBasicMaterial({ color: 255 });
        const sphere = new Mesh(sphereGeometry, material);
        component.touchPointNode.add(sphere);
      } else {
        console.warn(`Could not find touch dot, ${component.touchPointNodeName}, in touchpad component ${component.id}`);
      }
    }
    Object.values(visualResponses).forEach((visualResponse) => {
      const { valueNodeName, minNodeName, maxNodeName, valueNodeProperty } = visualResponse;
      if (valueNodeProperty === Constants2.VisualResponseProperty.TRANSFORM) {
        visualResponse.minNode = scene.getObjectByName(minNodeName);
        visualResponse.maxNode = scene.getObjectByName(maxNodeName);
        if (!visualResponse.minNode) {
          console.warn(`Could not find ${minNodeName} in the model`);
          return;
        }
        if (!visualResponse.maxNode) {
          console.warn(`Could not find ${maxNodeName} in the model`);
          return;
        }
      }
      visualResponse.valueNode = scene.getObjectByName(valueNodeName);
      if (!visualResponse.valueNode) {
        console.warn(`Could not find ${valueNodeName} in the model`);
      }
    });
  });
}
function addAssetSceneToControllerModel(controllerModel, scene) {
  findNodes(controllerModel.motionController, scene);
  if (controllerModel.envMap) {
    scene.traverse((child) => {
      if (child.isMesh) {
        child.material.envMap = controllerModel.envMap;
        child.material.needsUpdate = true;
      }
    });
  }
  if (controllerModel.layers.mask != 0) {
    scene.traverse((child) => {
      child.layers.mask = controllerModel.layers.mask;
    });
  }
  controllerModel.add(scene);
}
var XRControllerModelFactory = class {
  constructor(gltfLoader2 = null, onLoad2 = null) {
    this.gltfLoader = gltfLoader2;
    this.path = DEFAULT_PROFILES_PATH2;
    this._assetCache = {};
    this.onLoad = onLoad2;
    if (!this.gltfLoader) {
      this.gltfLoader = new GLTFLoader();
    }
  }
  setPath(path) {
    this.path = path;
    return this;
  }
  createControllerModel(controller) {
    const controllerModel = new XRControllerModel();
    let scene = null;
    controller.addEventListener("connected", (event) => {
      const xrInputSource = event.data;
      if (xrInputSource.targetRayMode !== "tracked-pointer" || !xrInputSource.gamepad || xrInputSource.hand)
        return;
      fetchProfile2(xrInputSource, this.path, DEFAULT_PROFILE2).then(({ profile, assetPath }) => {
        controllerModel.motionController = new MotionController2(
          xrInputSource,
          profile,
          assetPath
        );
        const cachedAsset = this._assetCache[controllerModel.motionController.assetUrl];
        if (cachedAsset) {
          scene = cachedAsset.scene.clone();
          addAssetSceneToControllerModel(controllerModel, scene);
          if (this.onLoad)
            this.onLoad(scene);
        } else {
          if (!this.gltfLoader) {
            throw new Error("GLTFLoader not set.");
          }
          this.gltfLoader.setPath("");
          this.gltfLoader.load(
            controllerModel.motionController.assetUrl,
            (asset) => {
              this._assetCache[controllerModel.motionController.assetUrl] = asset;
              scene = asset.scene.clone();
              addAssetSceneToControllerModel(controllerModel, scene);
              if (this.onLoad)
                this.onLoad(scene);
            },
            null,
            () => {
              throw new Error(`Asset ${controllerModel.motionController.assetUrl} missing or malformed.`);
            }
          );
        }
      }).catch((err) => {
        console.warn(err);
      });
    });
    controller.addEventListener("disconnected", () => {
      controllerModel.motionController = null;
      controllerModel.remove(scene);
      scene = null;
    });
    return controllerModel;
  }
};

// node_modules/three/examples/jsm/webxr/XRHandMeshModel.js
var DEFAULT_HAND_PROFILE_PATH = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles/generic-hand/";
var XRHandMeshModel = class {
  constructor(handModel, controller, path, handedness, loader2 = null, onLoad2 = null) {
    this.controller = controller;
    this.handModel = handModel;
    this.bones = [];
    if (loader2 === null) {
      loader2 = new GLTFLoader();
      loader2.setPath(path || DEFAULT_HAND_PROFILE_PATH);
    }
    loader2.load(`${handedness}.glb`, (gltf) => {
      const object = gltf.scene.children[0];
      this.handModel.add(object);
      object.layers.mask = this.handModel.layers.mask;
      const mesh = object.getObjectByProperty("type", "SkinnedMesh");
      mesh.frustumCulled = false;
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      const joints = [
        "wrist",
        "thumb-metacarpal",
        "thumb-phalanx-proximal",
        "thumb-phalanx-distal",
        "thumb-tip",
        "index-finger-metacarpal",
        "index-finger-phalanx-proximal",
        "index-finger-phalanx-intermediate",
        "index-finger-phalanx-distal",
        "index-finger-tip",
        "middle-finger-metacarpal",
        "middle-finger-phalanx-proximal",
        "middle-finger-phalanx-intermediate",
        "middle-finger-phalanx-distal",
        "middle-finger-tip",
        "ring-finger-metacarpal",
        "ring-finger-phalanx-proximal",
        "ring-finger-phalanx-intermediate",
        "ring-finger-phalanx-distal",
        "ring-finger-tip",
        "pinky-finger-metacarpal",
        "pinky-finger-phalanx-proximal",
        "pinky-finger-phalanx-intermediate",
        "pinky-finger-phalanx-distal",
        "pinky-finger-tip"
      ];
      joints.forEach((jointName) => {
        const bone = object.getObjectByName(jointName);
        if (bone !== void 0) {
          bone.jointName = jointName;
        } else {
          console.warn(`Couldn't find ${jointName} in ${handedness} hand mesh`);
        }
        this.bones.push(bone);
      });
      if (onLoad2)
        onLoad2(object);
    });
  }
  updateMesh() {
    const XRJoints = this.controller.joints;
    for (let i = 0; i < this.bones.length; i++) {
      const bone = this.bones[i];
      if (bone) {
        const XRJoint = XRJoints[bone.jointName];
        if (XRJoint.visible) {
          const position = XRJoint.position;
          bone.position.copy(position);
          bone.quaternion.copy(XRJoint.quaternion);
        }
      }
    }
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/webxr/controllers/XRControllerModel.js
var __decorate48 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug82 = getParam("debugwebxr");
var handsJointBuffer = new Float32Array(16 * 25);
var renderingUpdateTimings = new Array();
var XRControllerModel2 = class extends Component2 {
  constructor() {
    super(...arguments);
    /**
     * If true, the controller model will be created when a controller is added/connected
     * @default true
     */
    __publicField(this, "createControllerModel", true);
    /**
     * If true, the hand model will be created when a hand is "added"/tracked
     * @default true
     */
    __publicField(this, "createHandModel", true);
    /** assign a model or model url to create custom hand models */
    __publicField(this, "customLeftHand");
    /** assign a model or model url to create custom hand models */
    __publicField(this, "customRightHand");
    __publicField(this, "_models", new Array());
  }
  supportsXR(mode) {
    return mode === "immersive-vr" || mode === "immersive-ar";
  }
  async onXRControllerAdded(args) {
    var _a2;
    const isSupportedSession = args.xr.isVR || args.xr.isPassThrough;
    if (!isSupportedSession)
      return;
    const { controller } = args;
    if (debug82)
      console.warn("Add Controller Model for", controller.side, controller.index);
    if (this.createControllerModel || this.createHandModel) {
      if (controller.hand) {
        if (this.createHandModel) {
          const res = await this.loadHandModel(this, controller);
          if (!res || !controller.connected || !controller.isHand) {
            if (res == null ? void 0 : res.handObject)
              setDontDestroy(res.handObject, false);
            (_a2 = res == null ? void 0 : res.handObject) == null ? void 0 : _a2.destroy();
            return;
          }
          this._models.push({ controller, model: res.handObject, handmesh: res.handmesh });
          this._models.sort((a, b) => a.controller.index - b.controller.index);
          this.scene.add(res.handObject);
          controller.model = res.handObject;
        }
      } else {
        if (this.createControllerModel) {
          const assetUrl = await controller.getModelUrl();
          if (assetUrl) {
            const model = await this.loadModel(controller, assetUrl);
            if (!model || !controller.connected || controller.isHand) {
              return;
            }
            this._models.push({ controller, model });
            this._models.sort((a, b) => a.controller.index - b.controller.index);
            this.scene.add(model);
            model.traverse((child) => {
              child.layers.set(2);
              child.matrixAutoUpdate = false;
              child.updateMatrix();
            });
            controller.model = model;
          } else if (controller.targetRayMode !== "transient-pointer") {
            console.warn("XRControllerModel: no model found for " + controller.side);
          }
        }
      }
    }
  }
  onXRControllerRemoved(args) {
    console.debug("XR Controller Removed", args.controller.side, args.controller.index);
    const indexInArray = this._models.findIndex((m2) => m2.controller === args.controller);
    const entry = this._models[indexInArray];
    if (!entry)
      return;
    this._models.splice(indexInArray, 1);
    if (entry.model) {
      setDontDestroy(entry.model, false);
      entry.model.destroy();
      entry.model = void 0;
    }
  }
  onLeaveXR(_args) {
    for (const entry of this._models) {
      if (!entry)
        continue;
      if (entry.model) {
        setDontDestroy(entry.model, false);
        entry.model.destroy();
        entry.model = void 0;
      }
      if (entry.controller.model === entry.model) {
        entry.controller.model = null;
      }
    }
    this._models.length = 0;
  }
  onBeforeRender() {
    if (!NeedleXRSession.active)
      return;
    if (debug82)
      renderingUpdateTimings[0] = Date.now();
    this.updateRendering(NeedleXRSession.active);
    if (debug82) {
      const dt = Date.now() - renderingUpdateTimings[0];
      renderingUpdateTimings.push(dt);
      if (renderingUpdateTimings.length >= 30) {
        renderingUpdateTimings[0] = 0;
        const avrg = renderingUpdateTimings.reduce((a, b) => a + b, 0) / renderingUpdateTimings.length;
        renderingUpdateTimings.length = 0;
      }
    }
  }
  updateRendering(xr) {
    var _a2, _b, _c, _d, _e;
    for (let i = 0; i < this._models.length; i++) {
      const entry = this._models[i];
      if (!entry)
        continue;
      const ctrl = entry.controller;
      if (!ctrl.connected) {
        if (debug82)
          console.warn("XRControllerModel.onUpdateXR: controller is not connected anymore", ctrl.side, ctrl.hand);
        continue;
      }
      if (entry.model && !entry.handmesh) {
        entry.model.matrixAutoUpdate = false;
        entry.model.matrix.copy(ctrl.gripMatrix);
        entry.model.visible = ctrl.isTracking;
        (_a2 = xr.rig) == null ? void 0 : _a2.gameObject.add(entry.model);
      } else if (ctrl.inputSource.hand && entry.handmesh) {
        const referenceSpace = xr.referenceSpace;
        const hand = this.context.renderer.xr.getHand(ctrl.index);
        if (referenceSpace && xr.frame.getJointPose) {
          for (const inputjoint of ctrl.inputSource.hand.values()) {
            const joint = hand.joints[inputjoint.jointName];
            if (joint) {
              const jointPose = ctrl.getHandJointPose(inputjoint);
              if (jointPose) {
                const position = jointPose.transform.position;
                const quaternion = jointPose.transform.orientation;
                joint.position.copy(position);
                joint.quaternion.copy(quaternion);
                joint.matrixAutoUpdate = false;
              }
              joint.visible = jointPose != null;
            }
          }
          if (entry.model) {
            entry.model.visible = ctrl.isTracking;
            if (entry.model.visible && entry.model.parent !== ((_b = xr.rig) == null ? void 0 : _b.gameObject)) {
              (_c = xr.rig) == null ? void 0 : _c.gameObject.add(entry.model);
            }
          }
          if ((_d = entry.model) == null ? void 0 : _d.visible) {
            (_e = entry.handmesh) == null ? void 0 : _e.updateMesh();
            entry.model.matrixAutoUpdate = false;
            entry.model.matrix.identity();
            entry.model.applyMatrix4(flipForwardMatrix);
          }
        }
      }
    }
  }
  async loadModel(controller, url) {
    var _a2;
    if (!controller.connected) {
      console.warn("XRControllerModel.onXRControllerAdded: controller is not connected anymore", controller.side);
      return null;
    }
    const assetReference = AssetReference.getOrCreate("", url);
    const model = await assetReference.instantiate();
    setDontDestroy(model);
    if ((_a2 = NeedleXRSession.active) == null ? void 0 : _a2.isPassThrough) {
      model.traverseVisible((obj) => {
        this.makeOccluder(obj);
      });
    }
    return model;
  }
  async loadHandModel(comp, controller) {
    const context = this.context;
    const hand = context.renderer.xr.getHand(controller.index);
    if (!hand) {
      if (debug82)
        Gizmos.DrawLabel(controller.rayWorldPosition, "No hand found for index " + controller.index, 0.05, 5);
      else
        console.warn("No hand found for index " + controller.index);
    }
    const loader2 = new GLTFLoader();
    addDracoAndKTX2Loaders2(loader2, context);
    await registerExtensions(loader2, context, this.sourceId ?? "");
    const componentsExtension = registerComponentExtension(loader2);
    let filename = "";
    const customHand = controller.side === "left" ? this.customLeftHand : this.customRightHand;
    if (customHand) {
      const urlWithoutExtension = customHand.url.split(".").slice(0, -1).join(".");
      filename = urlWithoutExtension;
      loader2.setPath("");
    } else {
      filename = controller.inputSource.handedness === "left" ? "left" : "right";
      loader2.setPath("https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles/generic-hand/");
    }
    const handObject = new Object3D();
    setDontDestroy(handObject);
    const handmesh = new XRHandMeshModel(handObject, hand, loader2.path, filename, loader2, (object) => {
      var _a2;
      const gltf = componentsExtension.gltf;
      if (((_a2 = gltf == null ? void 0 : gltf.scene.children) == null ? void 0 : _a2.length) === 0) {
        gltf.scene.children[0] = object;
      }
      getLoader().createBuiltinComponents(comp.context, comp.sourceId || filename, componentsExtension.gltf, null, componentsExtension);
      object.traverse((child) => {
        var _a3;
        child.layers.set(2);
        if (((_a3 = NeedleXRSession.active) == null ? void 0 : _a3.isPassThrough) && !customHand)
          this.makeOccluder(child);
        if (child instanceof Mesh) {
          NEEDLE_progressive.assignMeshLOD(child, 0);
        }
      });
      if (!controller.connected) {
        if (debug82)
          Gizmos.DrawLabel(controller.rayWorldPosition, "Hand is loaded but not connected anymore", 0.05, 5);
        object.removeFromParent();
      }
    });
    if (debug82)
      handObject.add(new AxesHelper(0.5));
    if (controller.inputSource.hand) {
      if (debug82)
        console.log(controller.inputSource.hand);
      for (const inputjoint of controller.inputSource.hand.values()) {
        if (hand.joints[inputjoint.jointName] === void 0) {
          const joint = new Group();
          joint.matrixAutoUpdate = false;
          joint.visible = true;
          hand.joints[inputjoint.jointName] = joint;
          hand.add(joint);
        }
      }
    } else {
      if (debug82) {
        Gizmos.DrawLabel(controller.rayWorldPosition, "No inputSource.hand found for index " + controller.index, 0.05, 5);
      }
    }
    return { handObject, handmesh };
  }
  makeOccluder(obj) {
    if (obj instanceof Mesh) {
      let mat = obj.material;
      if (mat instanceof Material) {
        mat = obj.material = mat.clone();
        mat.depthWrite = true;
        mat.depthTest = true;
        mat.colorWrite = false;
        obj.receiveShadow = false;
        obj.renderOrder = -100;
      }
    }
  }
};
__publicField(XRControllerModel2, "factory", new XRControllerModelFactory());
__decorate48([
  serializable()
], XRControllerModel2.prototype, "createControllerModel", void 0);
__decorate48([
  serializable()
], XRControllerModel2.prototype, "createHandModel", void 0);
__decorate48([
  serializable(AssetReference)
], XRControllerModel2.prototype, "customLeftHand", void 0);
__decorate48([
  serializable(AssetReference)
], XRControllerModel2.prototype, "customRightHand", void 0);

// node_modules/three/examples/jsm/lines/LineSegmentsGeometry.js
var _box = new Box3();
var _vector = new Vector32();
var LineSegmentsGeometry = class extends InstancedBufferGeometry {
  constructor() {
    super();
    this.isLineSegmentsGeometry = true;
    this.type = "LineSegmentsGeometry";
    const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];
    const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];
    const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(index);
    this.setAttribute("position", new Float32BufferAttribute2(positions, 3));
    this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
  }
  applyMatrix4(matrix) {
    const start = this.attributes.instanceStart;
    const end = this.attributes.instanceEnd;
    if (start !== void 0) {
      start.applyMatrix4(matrix);
      end.applyMatrix4(matrix);
      start.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  }
  setPositions(array) {
    let lineSegments;
    if (array instanceof Float32Array) {
      lineSegments = array;
    } else if (Array.isArray(array)) {
      lineSegments = new Float32Array(array);
    }
    const instanceBuffer = new InstancedInterleavedBuffer(lineSegments, 6, 1);
    this.setAttribute("instanceStart", new InterleavedBufferAttribute2(instanceBuffer, 3, 0));
    this.setAttribute("instanceEnd", new InterleavedBufferAttribute2(instanceBuffer, 3, 3));
    this.computeBoundingBox();
    this.computeBoundingSphere();
    return this;
  }
  setColors(array) {
    let colors;
    if (array instanceof Float32Array) {
      colors = array;
    } else if (Array.isArray(array)) {
      colors = new Float32Array(array);
    }
    const instanceColorBuffer = new InstancedInterleavedBuffer(colors, 6, 1);
    this.setAttribute("instanceColorStart", new InterleavedBufferAttribute2(instanceColorBuffer, 3, 0));
    this.setAttribute("instanceColorEnd", new InterleavedBufferAttribute2(instanceColorBuffer, 3, 3));
    return this;
  }
  fromWireframeGeometry(geometry) {
    this.setPositions(geometry.attributes.position.array);
    return this;
  }
  fromEdgesGeometry(geometry) {
    this.setPositions(geometry.attributes.position.array);
    return this;
  }
  fromMesh(mesh) {
    this.fromWireframeGeometry(new WireframeGeometry(mesh.geometry));
    return this;
  }
  fromLineSegments(lineSegments) {
    const geometry = lineSegments.geometry;
    this.setPositions(geometry.attributes.position.array);
    return this;
  }
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const start = this.attributes.instanceStart;
    const end = this.attributes.instanceEnd;
    if (start !== void 0 && end !== void 0) {
      this.boundingBox.setFromBufferAttribute(start);
      _box.setFromBufferAttribute(end);
      this.boundingBox.union(_box);
    }
  }
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    if (this.boundingBox === null) {
      this.computeBoundingBox();
    }
    const start = this.attributes.instanceStart;
    const end = this.attributes.instanceEnd;
    if (start !== void 0 && end !== void 0) {
      const center = this.boundingSphere.center;
      this.boundingBox.getCenter(center);
      let maxRadiusSq = 0;
      for (let i = 0, il = start.count; i < il; i++) {
        _vector.fromBufferAttribute(start, i);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));
        _vector.fromBufferAttribute(end, i);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
      }
    }
  }
  toJSON() {
  }
  applyMatrix(matrix) {
    console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().");
    return this.applyMatrix4(matrix);
  }
};

// node_modules/three/examples/jsm/lines/LineMaterial.js
UniformsLib.line = {
  worldUnits: { value: 1 },
  linewidth: { value: 1 },
  resolution: { value: new Vector2(1, 1) },
  dashOffset: { value: 0 },
  dashScale: { value: 1 },
  dashSize: { value: 1 },
  gapSize: { value: 1 }
  // todo FIX - maybe change to totalSize
};
ShaderLib["line"] = {
  uniforms: UniformsUtils.merge([
    UniformsLib.common,
    UniformsLib.fog,
    UniformsLib.line
  ]),
  vertexShader: (
    /* glsl */
    `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );
				vec3 worldUp = normalize( cross( worldDir, tmpFwd ) );
				vec3 worldFwd = cross( worldDir, worldUp );
				worldPos = position.y < 0.5 ? start: end;

				// height offset
				float hw = linewidth * 0.5;
				worldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// cap extension
					worldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;

					// add width to the box
					worldPos.xyz += worldFwd * hw;

					// endcaps
					if ( position.y > 1.0 || position.y < 0.0 ) {

						worldPos.xyz -= worldFwd * 2.0 * hw;

					}

				#endif

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
  )
};
var LineMaterial = class extends ShaderMaterial {
  constructor(parameters) {
    super({
      type: "LineMaterial",
      uniforms: UniformsUtils.clone(ShaderLib["line"].uniforms),
      vertexShader: ShaderLib["line"].vertexShader,
      fragmentShader: ShaderLib["line"].fragmentShader,
      clipping: true
      // required for clipping support
    });
    this.isLineMaterial = true;
    this.setValues(parameters);
  }
  get color() {
    return this.uniforms.diffuse.value;
  }
  set color(value) {
    this.uniforms.diffuse.value = value;
  }
  get worldUnits() {
    return "WORLD_UNITS" in this.defines;
  }
  set worldUnits(value) {
    if (value === true) {
      this.defines.WORLD_UNITS = "";
    } else {
      delete this.defines.WORLD_UNITS;
    }
  }
  get linewidth() {
    return this.uniforms.linewidth.value;
  }
  set linewidth(value) {
    if (!this.uniforms.linewidth)
      return;
    this.uniforms.linewidth.value = value;
  }
  get dashed() {
    return "USE_DASH" in this.defines;
  }
  set dashed(value) {
    if (value === true !== this.dashed) {
      this.needsUpdate = true;
    }
    if (value === true) {
      this.defines.USE_DASH = "";
    } else {
      delete this.defines.USE_DASH;
    }
  }
  get dashScale() {
    return this.uniforms.dashScale.value;
  }
  set dashScale(value) {
    this.uniforms.dashScale.value = value;
  }
  get dashSize() {
    return this.uniforms.dashSize.value;
  }
  set dashSize(value) {
    this.uniforms.dashSize.value = value;
  }
  get dashOffset() {
    return this.uniforms.dashOffset.value;
  }
  set dashOffset(value) {
    this.uniforms.dashOffset.value = value;
  }
  get gapSize() {
    return this.uniforms.gapSize.value;
  }
  set gapSize(value) {
    this.uniforms.gapSize.value = value;
  }
  get opacity() {
    return this.uniforms.opacity.value;
  }
  set opacity(value) {
    if (!this.uniforms)
      return;
    this.uniforms.opacity.value = value;
  }
  get resolution() {
    return this.uniforms.resolution.value;
  }
  set resolution(value) {
    this.uniforms.resolution.value.copy(value);
  }
  get alphaToCoverage() {
    return "USE_ALPHA_TO_COVERAGE" in this.defines;
  }
  set alphaToCoverage(value) {
    if (!this.defines)
      return;
    if (value === true !== this.alphaToCoverage) {
      this.needsUpdate = true;
    }
    if (value === true) {
      this.defines.USE_ALPHA_TO_COVERAGE = "";
    } else {
      delete this.defines.USE_ALPHA_TO_COVERAGE;
    }
  }
};

// node_modules/three/examples/jsm/lines/LineSegments2.js
var _viewport = new Vector4();
var _start = new Vector32();
var _end = new Vector32();
var _start4 = new Vector4();
var _end4 = new Vector4();
var _ssOrigin = new Vector4();
var _ssOrigin3 = new Vector32();
var _mvMatrix = new Matrix4();
var _line = new Line3();
var _closestPoint = new Vector32();
var _box2 = new Box3();
var _sphere = new Sphere();
var _clipToWorldVector = new Vector4();
var _ray2;
var _lineWidth;
function getWorldSpaceHalfWidth(camera, distance, resolution) {
  _clipToWorldVector.set(0, 0, -distance, 1).applyMatrix4(camera.projectionMatrix);
  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);
  _clipToWorldVector.x = _lineWidth / resolution.width;
  _clipToWorldVector.y = _lineWidth / resolution.height;
  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse);
  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);
  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y));
}
function raycastWorldUnits(lineSegments, intersects) {
  const matrixWorld = lineSegments.matrixWorld;
  const geometry = lineSegments.geometry;
  const instanceStart = geometry.attributes.instanceStart;
  const instanceEnd = geometry.attributes.instanceEnd;
  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);
  for (let i = 0, l = segmentCount; i < l; i++) {
    _line.start.fromBufferAttribute(instanceStart, i);
    _line.end.fromBufferAttribute(instanceEnd, i);
    _line.applyMatrix4(matrixWorld);
    const pointOnLine = new Vector32();
    const point = new Vector32();
    _ray2.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);
    const isInside = point.distanceTo(pointOnLine) < _lineWidth * 0.5;
    if (isInside) {
      intersects.push({
        point,
        pointOnLine,
        distance: _ray2.origin.distanceTo(point),
        object: lineSegments,
        face: null,
        faceIndex: i,
        uv: null,
        uv1: null
      });
    }
  }
}
function raycastScreenSpace(lineSegments, camera, intersects) {
  const projectionMatrix = camera.projectionMatrix;
  const material = lineSegments.material;
  const resolution = material.resolution;
  const matrixWorld = lineSegments.matrixWorld;
  const geometry = lineSegments.geometry;
  const instanceStart = geometry.attributes.instanceStart;
  const instanceEnd = geometry.attributes.instanceEnd;
  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);
  const near = -camera.near;
  _ray2.at(1, _ssOrigin);
  _ssOrigin.w = 1;
  _ssOrigin.applyMatrix4(camera.matrixWorldInverse);
  _ssOrigin.applyMatrix4(projectionMatrix);
  _ssOrigin.multiplyScalar(1 / _ssOrigin.w);
  _ssOrigin.x *= resolution.x / 2;
  _ssOrigin.y *= resolution.y / 2;
  _ssOrigin.z = 0;
  _ssOrigin3.copy(_ssOrigin);
  _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);
  for (let i = 0, l = segmentCount; i < l; i++) {
    _start4.fromBufferAttribute(instanceStart, i);
    _end4.fromBufferAttribute(instanceEnd, i);
    _start4.w = 1;
    _end4.w = 1;
    _start4.applyMatrix4(_mvMatrix);
    _end4.applyMatrix4(_mvMatrix);
    const isBehindCameraNear = _start4.z > near && _end4.z > near;
    if (isBehindCameraNear) {
      continue;
    }
    if (_start4.z > near) {
      const deltaDist = _start4.z - _end4.z;
      const t2 = (_start4.z - near) / deltaDist;
      _start4.lerp(_end4, t2);
    } else if (_end4.z > near) {
      const deltaDist = _end4.z - _start4.z;
      const t2 = (_end4.z - near) / deltaDist;
      _end4.lerp(_start4, t2);
    }
    _start4.applyMatrix4(projectionMatrix);
    _end4.applyMatrix4(projectionMatrix);
    _start4.multiplyScalar(1 / _start4.w);
    _end4.multiplyScalar(1 / _end4.w);
    _start4.x *= resolution.x / 2;
    _start4.y *= resolution.y / 2;
    _end4.x *= resolution.x / 2;
    _end4.y *= resolution.y / 2;
    _line.start.copy(_start4);
    _line.start.z = 0;
    _line.end.copy(_end4);
    _line.end.z = 0;
    const param = _line.closestPointToPointParameter(_ssOrigin3, true);
    _line.at(param, _closestPoint);
    const zPos = MathUtils.lerp(_start4.z, _end4.z, param);
    const isInClipSpace = zPos >= -1 && zPos <= 1;
    const isInside = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5;
    if (isInClipSpace && isInside) {
      _line.start.fromBufferAttribute(instanceStart, i);
      _line.end.fromBufferAttribute(instanceEnd, i);
      _line.start.applyMatrix4(matrixWorld);
      _line.end.applyMatrix4(matrixWorld);
      const pointOnLine = new Vector32();
      const point = new Vector32();
      _ray2.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);
      intersects.push({
        point,
        pointOnLine,
        distance: _ray2.origin.distanceTo(point),
        object: lineSegments,
        face: null,
        faceIndex: i,
        uv: null,
        uv1: null
      });
    }
  }
}
var LineSegments2 = class extends Mesh {
  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({ color: Math.random() * 16777215 })) {
    super(geometry, material);
    this.isLineSegments2 = true;
    this.type = "LineSegments2";
  }
  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...
  computeLineDistances() {
    const geometry = this.geometry;
    const instanceStart = geometry.attributes.instanceStart;
    const instanceEnd = geometry.attributes.instanceEnd;
    const lineDistances = new Float32Array(2 * instanceStart.count);
    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {
      _start.fromBufferAttribute(instanceStart, i);
      _end.fromBufferAttribute(instanceEnd, i);
      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];
      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);
    }
    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1);
    geometry.setAttribute("instanceDistanceStart", new InterleavedBufferAttribute2(instanceDistanceBuffer, 1, 0));
    geometry.setAttribute("instanceDistanceEnd", new InterleavedBufferAttribute2(instanceDistanceBuffer, 1, 1));
    return this;
  }
  raycast(raycaster, intersects) {
    const worldUnits = this.material.worldUnits;
    const camera = raycaster.camera;
    if (camera === null && !worldUnits) {
      console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
    }
    const threshold = raycaster.params.Line2 !== void 0 ? raycaster.params.Line2.threshold || 0 : 0;
    _ray2 = raycaster.ray;
    const matrixWorld = this.matrixWorld;
    const geometry = this.geometry;
    const material = this.material;
    _lineWidth = material.linewidth + threshold;
    if (geometry.boundingSphere === null) {
      geometry.computeBoundingSphere();
    }
    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);
    let sphereMargin;
    if (worldUnits) {
      sphereMargin = _lineWidth * 0.5;
    } else {
      const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(_ray2.origin));
      sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution);
    }
    _sphere.radius += sphereMargin;
    if (_ray2.intersectsSphere(_sphere) === false) {
      return;
    }
    if (geometry.boundingBox === null) {
      geometry.computeBoundingBox();
    }
    _box2.copy(geometry.boundingBox).applyMatrix4(matrixWorld);
    let boxMargin;
    if (worldUnits) {
      boxMargin = _lineWidth * 0.5;
    } else {
      const distanceToBox = Math.max(camera.near, _box2.distanceToPoint(_ray2.origin));
      boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution);
    }
    _box2.expandByScalar(boxMargin);
    if (_ray2.intersectsBox(_box2) === false) {
      return;
    }
    if (worldUnits) {
      raycastWorldUnits(this, intersects);
    } else {
      raycastScreenSpace(this, camera, intersects);
    }
  }
  onBeforeRender(renderer) {
    const uniforms = this.material.uniforms;
    if (uniforms && uniforms.resolution) {
      renderer.getViewport(_viewport);
      this.material.uniforms.resolution.value.set(_viewport.z, _viewport.w);
    }
  }
};

// node_modules/three/examples/jsm/lines/LineGeometry.js
var LineGeometry = class extends LineSegmentsGeometry {
  constructor() {
    super();
    this.isLineGeometry = true;
    this.type = "LineGeometry";
  }
  setPositions(array) {
    const length = array.length - 3;
    const points = new Float32Array(2 * length);
    for (let i = 0; i < length; i += 3) {
      points[2 * i] = array[i];
      points[2 * i + 1] = array[i + 1];
      points[2 * i + 2] = array[i + 2];
      points[2 * i + 3] = array[i + 3];
      points[2 * i + 4] = array[i + 4];
      points[2 * i + 5] = array[i + 5];
    }
    super.setPositions(points);
    return this;
  }
  setColors(array) {
    const length = array.length - 3;
    const colors = new Float32Array(2 * length);
    for (let i = 0; i < length; i += 3) {
      colors[2 * i] = array[i];
      colors[2 * i + 1] = array[i + 1];
      colors[2 * i + 2] = array[i + 2];
      colors[2 * i + 3] = array[i + 3];
      colors[2 * i + 4] = array[i + 4];
      colors[2 * i + 5] = array[i + 5];
    }
    super.setColors(colors);
    return this;
  }
  fromLine(line) {
    const geometry = line.geometry;
    this.setPositions(geometry.attributes.position.array);
    return this;
  }
};

// node_modules/three/examples/jsm/lines/Line2.js
var Line22 = class extends LineSegments2 {
  constructor(geometry = new LineGeometry(), material = new LineMaterial({ color: Math.random() * 16777215 })) {
    super(geometry, material);
    this.isLine2 = true;
    this.type = "Line2";
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/webxr/TeleportTarget.js
var TeleportTarget = class extends Component2 {
};

// node_modules/@needle-tools/engine/lib/engine-components/webxr/controllers/XRControllerMovement.js
var __decorate49 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug83 = getParam("debugwebxr");
var XRControllerMovement = class extends Component2 {
  constructor() {
    super(...arguments);
    /** Movement speed in meters per second
     * @default 1.5
    */
    __publicField(this, "movementSpeed", 1.5);
    /** How many degrees to rotate the XR rig when using the rotation trigger
     * @default 30
     */
    __publicField(this, "rotationStep", 30);
    /** When enabled you can teleport using the right XR controller's thumbstick by pressing forward
     * @default true
    */
    __publicField(this, "useTeleport", true);
    /**
     * When enabled you can teleport by pinching the right XR controller's index finger tip in front of the hand
     * @default true
     */
    __publicField(this, "usePinchToTeleport", true);
    /** Enable to only allow teleporting on objects with a teleport target component
     * @default false
    */
    __publicField(this, "useTeleportTarget", false);
    /** Enable to fade out the scene when teleporting
     * @default false
    */
    __publicField(this, "useTeleportFade", false);
    /** enable to visualize controller rays in the 3D scene
     * @default true
    */
    __publicField(this, "showRays", true);
    /** enable to visualize pointer targets in the 3D scene
     * @default false
    */
    __publicField(this, "showHits", true);
    __publicField(this, "isXRMovementHandler", true);
    __publicField(this, "xrSessionMode", "immersive-vr");
    __publicField(this, "_didApplyRotation", false);
    __publicField(this, "_didTeleport", false);
    __publicField(this, "_teleportBuffer", new Array());
    __publicField(this, "_plane", null);
    __publicField(this, "_lines", []);
    __publicField(this, "_hitDiscs", []);
    __publicField(this, "_hitDistances", []);
    __publicField(this, "_lastHitDistances", []);
    __publicField(this, "hitPointRaycastFilter", (obj) => {
      if (obj.type === "SkinnedMesh")
        return "continue in children";
      return true;
    });
  }
  onUpdateXR(args) {
    const rig = args.xr.rig;
    if (!(rig == null ? void 0 : rig.gameObject))
      return;
    if (args.xr.isPassThrough) {
      return;
    }
    const movementController = args.xr.leftController;
    const teleportController = args.xr.rightController;
    if (movementController)
      this.onHandleMovement(movementController, rig.gameObject);
    if (teleportController) {
      this.onHandleRotation(teleportController, rig.gameObject);
      if (this.useTeleport)
        this.onHandleTeleport(teleportController, rig.gameObject);
    }
  }
  onLeaveXR(_) {
    for (const line of this._lines) {
      line.removeFromParent();
    }
    for (const disc of this._hitDiscs) {
      disc == null ? void 0 : disc.removeFromParent();
    }
  }
  onBeforeRender() {
    var _a2;
    if ((_a2 = this.context.xr) == null ? void 0 : _a2.running) {
      if (this.showRays)
        this.renderRays(this.context.xr);
      if (this.showHits)
        this.renderHits(this.context.xr);
    }
  }
  onHandleMovement(controller, rig) {
    const stick = controller.getStick("xr-standard-thumbstick");
    if (stick.x != 0 || stick.y != 0) {
      const vec2 = getTempVector(stick.x, 0, stick.y);
      vec2.multiplyScalar(this.context.time.deltaTimeUnscaled * this.movementSpeed);
      const scale = getWorldScale(rig);
      vec2.multiplyScalar(scale.x);
      vec2.applyQuaternion(controller.xr.poseOrientation);
      vec2.y = 0;
      vec2.applyQuaternion(rig.worldQuaternion);
      rig.position.add(vec2);
      rig.updateWorldMatrix(false, false);
      for (const ch of rig.children)
        ch.updateWorldMatrix(false, false);
    }
  }
  onHandleRotation(controller, rig) {
    if (controller["_isMxInk"])
      return;
    const stick = controller.getStick("xr-standard-thumbstick");
    const rotationInput = stick.x;
    if (this._didApplyRotation) {
      if (Math.abs(rotationInput) < 0.3) {
        this._didApplyRotation = false;
      }
    } else if (Math.abs(rotationInput) > 0.5) {
      this._didApplyRotation = true;
      const dir = rotationInput > 0 ? 1 : -1;
      const start_worldpos = getWorldPosition(this.context.mainCamera).clone();
      rig.rotateY(dir * Mathf.toRadians(this.rotationStep));
      const end_worldpos = getWorldPosition(this.context.mainCamera).clone();
      const diff = end_worldpos.sub(start_worldpos);
      diff.y = 0;
      rig.position.sub(diff);
    }
  }
  onHandleTeleport(controller, rig) {
    var _a2, _b, _c, _d, _e;
    let teleportInput = 0;
    if (controller.hand && this.usePinchToTeleport && controller.isTeleportGesture) {
      const pointerId = controller.getPointerId("primary");
      if (pointerId != void 0 && this.context.input.getIsPointerIdInUse(pointerId)) {
        return;
      }
      const pinch = controller.getGesture("pinch");
      if (pinch) {
        teleportInput = pinch.value;
      }
    } else {
      teleportInput = (_a2 = controller.getStick("xr-standard-thumbstick")) == null ? void 0 : _a2.y;
    }
    if (this._didTeleport) {
      if (teleportInput >= 0 && teleportInput < 0.4) {
        this._didTeleport = false;
      } else if (teleportInput < 0 && teleportInput > -0.4) {
        this._didTeleport = false;
      }
    } else if (teleportInput > 0.8) {
      this._didTeleport = true;
      const hit = this.context.physics.raycastFromRay(controller.ray)[0];
      if (hit && hit.object instanceof GroundedSkybox) {
        const dot_up = (_b = hit.normal) == null ? void 0 : _b.dot(getTempVector(0, 1, 0));
        if (dot_up !== void 0 && dot_up < 0.4) {
          return;
        }
      }
      let point = hit == null ? void 0 : hit.point;
      if (!point && !this.useTeleportTarget) {
        if (!this._plane) {
          this._plane = new Plane(new Vector32(0, 1, 0), 0);
        }
        const currentPosition = rig.worldPosition;
        this._plane.setFromNormalAndCoplanarPoint(new Vector32(0, 1, 0), currentPosition);
        const ray = controller.ray;
        point = currentPosition.clone();
        this._plane.intersectLine(new Line3(ray.origin, getTempVector(ray.direction).multiplyScalar(1e4).add(ray.origin)), point);
        if (point.distanceTo(currentPosition) > rig.scale.x * 10) {
          point = null;
        }
      }
      if (point) {
        if (this.useTeleportTarget) {
          const teleportTarget = GameObject.getComponentInParent(hit.object, TeleportTarget);
          if (!teleportTarget)
            return;
        }
        const cloned = point.clone();
        if (debug83)
          Gizmos.DrawSphere(point, 0.025, 16711680, 5);
        const positionInRig = (_c = this.context.mainCamera) == null ? void 0 : _c.position;
        if (positionInRig) {
          const vec2 = (_d = this.context.xr) == null ? void 0 : _d.getUserOffsetInRig();
          if (vec2) {
            vec2.y = 0;
            cloned.sub(vec2);
            if (debug83)
              Gizmos.DrawWireSphere(vec2.add(cloned), 0.025, 65280, 5);
          }
        }
        this._teleportBuffer.push(rig.matrix.clone());
        if (this._teleportBuffer.length > 10) {
          this._teleportBuffer.shift();
        }
        if (this.useTeleportFade) {
          (_e = controller.xr.fadeTransition()) == null ? void 0 : _e.then(() => {
            rig.worldPosition = cloned;
          });
        } else {
          rig.worldPosition = cloned;
        }
      }
    } else if (teleportInput < -0.8) {
      this._didTeleport = true;
      if (this._teleportBuffer.length > 0) {
        const prev = this._teleportBuffer.pop();
        if (prev) {
          prev.decompose(rig.position, rig.quaternion, rig.scale);
        }
      }
    }
  }
  renderRays(session) {
    var _a2;
    for (let i = 0; i < this._lines.length; i++) {
      const line = this._lines[i];
      if (line)
        line.visible = false;
    }
    for (let i = 0; i < session.controllers.length; i++) {
      const ctrl = session.controllers[i];
      let line = this._lines[i];
      if (!ctrl.connected || !ctrl.isTracking || !ctrl.ray || ctrl.targetRayMode === "transient-pointer" || !ctrl.hasSelectEvent) {
        if (line)
          line.visible = false;
        continue;
      }
      if (!line) {
        line = this.createRayLineObject();
        line.scale.z = 0.5;
        this._lines[i] = line;
      }
      ctrl.updateRayWorldPosition();
      ctrl.updateRayWorldQuaternion();
      const pos = ctrl.rayWorldPosition;
      const rot = ctrl.rayWorldQuaternion;
      line.position.copy(pos);
      line.quaternion.copy(rot);
      const scale = session.rigScale;
      const forceShowRay = this.usePinchToTeleport && ctrl.isTeleportGesture;
      const distance = this._lastHitDistances[i];
      const hasHit = this._hitDistances[i] != null;
      const dist = distance != null ? distance : scale;
      line.scale.set(scale, scale, dist);
      line.visible = true;
      line.layers.disableAll();
      line.layers.enable(2);
      let targetOpacity = line.material.opacity;
      if (forceShowRay) {
        targetOpacity = 1;
      } else if (this.showHits && dist < session.rigScale * 0.5) {
        targetOpacity = 0;
      } else if ((_a2 = ctrl.getButton("primary")) == null ? void 0 : _a2.pressed) {
        targetOpacity = 0.5;
      } else {
        targetOpacity = hasHit ? 0.2 : 0.1;
      }
      line.material.opacity = Mathf.lerp(line.material.opacity, targetOpacity, this.context.time.deltaTimeUnscaled / 0.1);
      if (line.parent !== this.context.scene)
        this.context.scene.add(line);
    }
  }
  renderHits(session) {
    var _a2;
    for (const disc of this._hitDiscs) {
      if (!disc)
        continue;
      const ctrl = disc["controller"];
      if (!ctrl || !ctrl.connected || !ctrl.isTracking) {
        disc.visible = false;
        continue;
      }
    }
    for (let i = 0; i < session.controllers.length; i++) {
      const ctrl = session.controllers[i];
      if (!ctrl.connected || !ctrl.isTracking || !ctrl.ray || !ctrl.hasSelectEvent)
        continue;
      let disc = this._hitDiscs[i];
      let runRaycast = true;
      const pointerId = ctrl.getPointerId("primary");
      if (pointerId != void 0) {
        const isCurrentlyUsed = this.context.input.getIsPointerIdInUse(pointerId);
        if (isCurrentlyUsed) {
          if (disc)
            disc.visible = false;
          this._hitDistances[i] = null;
          this._lastHitDistances[i] = 0;
          runRaycast = false;
        }
      }
      const interval = this.context.time.smoothedFps >= 59 ? 1 : 10;
      if ((this.context.time.frame + ctrl.index) % interval !== 0) {
        runRaycast = false;
      }
      if (!runRaycast) {
        const disc2 = this._hitDiscs[i];
        if (disc2 && disc2.visible && disc2["hit"]) {
          this.updateHitPointerPosition(ctrl, disc2, disc2["hit"].distance);
        }
        continue;
      }
      const hits = this.context.physics.raycastFromRay(ctrl.ray, { testObject: this.hitPointRaycastFilter, precise: false });
      let hit = hits.find((hit2) => {
        if (this.usePinchToTeleport && ctrl.isTeleportGesture)
          return true;
        return this.isObjectWithInteractiveComponent(hit2.object);
      });
      if (!hit) {
        hit = hits[0];
      }
      if (disc) {
        disc["controller"] = ctrl;
        disc["hit"] = hit;
      }
      this._hitDistances[i] = (hit == null ? void 0 : hit.distance) || null;
      if (hit) {
        this._lastHitDistances[i] = hit.distance;
        const rigScale = session.rigScale ?? 1;
        if (debug83) {
          Gizmos.DrawWireSphere(hit.point, 0.025 * rigScale, 16711680);
          Gizmos.DrawLabel(getTempVector(0, 0.2, 0).add(hit.point), hit.object.name, 0.02, 0);
        }
        if (!disc) {
          disc = this.createHitPointObject();
          this._hitDiscs[i] = disc;
        }
        disc["hit"] = hit;
        disc.visible = hit.distance > rigScale * 0.05;
        let size = 0.01 * (rigScale + hit.distance);
        const primaryPressed = (_a2 = ctrl.getButton("primary")) == null ? void 0 : _a2.pressed;
        if (primaryPressed)
          size *= 1.1;
        disc.scale.set(size, size, size);
        disc.layers.set(2);
        let targetOpacity = disc.material.opacity;
        if (primaryPressed) {
          targetOpacity = 1;
        } else {
          targetOpacity = hit.distance < 0.15 * rigScale ? 0.2 : 0.6;
        }
        disc.material.opacity = Mathf.lerp(disc.material.opacity, targetOpacity, this.context.time.deltaTimeUnscaled / 0.1);
        if (disc.visible) {
          if (hit.normal) {
            this.updateHitPointerPosition(ctrl, disc, hit.distance);
            const worldNormal = hit.normal.applyQuaternion(getWorldQuaternion(hit.object));
            disc.quaternion.setFromUnitVectors(up, worldNormal);
          } else {
            this.updateHitPointerPosition(ctrl, disc, hit.distance);
          }
          if (disc.parent !== this.context.scene) {
            this.context.scene.add(disc);
          }
        }
      } else {
        if (this._hitDiscs[i]) {
          this._hitDiscs[i].visible = false;
        }
      }
    }
  }
  isObjectWithInteractiveComponent(object, level = 0) {
    if (hasPointerEventComponent(object) || object["isUI"] === true)
      return true;
    if (object.isScene)
      return false;
    if (object.parent)
      return this.isObjectWithInteractiveComponent(object.parent, level + 1);
    return false;
  }
  updateHitPointerPosition(ctrl, pt, distance) {
    const targetPos = getTempVector(ctrl.rayWorldPosition);
    targetPos.add(getTempVector(0, 0, distance - 0.01).applyQuaternion(ctrl.rayWorldQuaternion));
    pt.position.lerp(targetPos, this.context.time.deltaTimeUnscaled / 0.05);
  }
  /** create an object to visualize hit points in the scene */
  createHitPointObject() {
    const mesh = new Mesh(
      new SphereGeometry(0.3, 6, 6),
      // new RingGeometry(.3, 0.5, 32).rotateX(- Math.PI / 2),
      new MeshBasicMaterial({
        color: 15658734,
        opacity: 0.7,
        transparent: true,
        depthTest: false,
        depthWrite: false,
        side: DoubleSide
      })
    );
    mesh.layers.disableAll();
    mesh.layers.enable(2);
    return mesh;
  }
  /** create an object to visualize controller rays */
  createRayLineObject() {
    const line = new Line22();
    line.layers.disableAll();
    line.layers.enable(2);
    const geometry = new LineGeometry();
    line.geometry = geometry;
    const positions = new Float32Array(9);
    positions.set([0, 0, 0.02, 0, 0, 0.4, 0, 0, 1]);
    geometry.setPositions(positions);
    const colors = new Float32Array(9);
    colors.set([1, 1, 1, 0.1, 0.1, 0.1, 0, 0, 0]);
    geometry.setColors(colors);
    const mat = new LineMaterial({
      color: 16777215,
      vertexColors: true,
      worldUnits: true,
      linewidth: 4e-3,
      transparent: true,
      depthWrite: false,
      // TODO: this doesnt work with passthrough
      blending: AdditiveBlending,
      dashed: false
      // alphaToCoverage: true,
    });
    line.material = mat;
    return line;
  }
};
__decorate49([
  serializable()
], XRControllerMovement.prototype, "movementSpeed", void 0);
__decorate49([
  serializable()
], XRControllerMovement.prototype, "rotationStep", void 0);
__decorate49([
  serializable()
], XRControllerMovement.prototype, "useTeleport", void 0);
__decorate49([
  serializable()
], XRControllerMovement.prototype, "usePinchToTeleport", void 0);
__decorate49([
  serializable()
], XRControllerMovement.prototype, "useTeleportTarget", void 0);
__decorate49([
  serializable()
], XRControllerMovement.prototype, "useTeleportFade", void 0);
__decorate49([
  serializable()
], XRControllerMovement.prototype, "showRays", void 0);
__decorate49([
  serializable()
], XRControllerMovement.prototype, "showHits", void 0);
var up = new Vector32(0, 1, 0);

// node_modules/@needle-tools/engine/lib/engine-components/webxr/WebXR.js
var __decorate50 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug84 = getParam("debugwebxr");
var debugQuicklook = getParam("debugusdz");
var _WebXR = class extends Component2 {
  constructor() {
    super(...arguments);
    // UI
    /** When enabled a button will be added to the UI to enter VR */
    __publicField(this, "createVRButton", true);
    /** When enabled a button will be added to the UI to enter AR */
    __publicField(this, "createARButton", true);
    /** When enabled a send to quest button will be shown if the device does not support VR */
    __publicField(this, "createSendToQuestButton", true);
    /** When enabled a QRCode will be created to open the website on a mobile device */
    __publicField(this, "createQRCode", true);
    // VR Settings
    /** When enabled default movement behaviour will be added */
    __publicField(this, "useDefaultControls", true);
    /** When enabled controller models will automatically be created and updated when you are using controllers in WebXR */
    __publicField(this, "showControllerModels", true);
    /** When enabled hand models will automatically be created and updated when you are using hands in WebXR */
    __publicField(this, "showHandModels", true);
    // AR Settings
    /** When enabled the scene must be placed in AR */
    __publicField(this, "usePlacementReticle", true);
    /** When assigned this object will be used as the AR placement reticle */
    __publicField(this, "customARPlacementReticle");
    /** When enabled you can position, rotate or scale your AR scene with one or two fingers */
    __publicField(this, "usePlacementAdjustment", true);
    /** Used when `usePlacementReticle` is enabled. This is the scale of the user in the scene in AR. Larger values make the 3D content appear smaller */
    __publicField(this, "arScale", 1);
    /** Experimental: When enabled an XRAnchor will be created for the AR scene and the position will be updated to the anchor position every few frames */
    __publicField(this, "useXRAnchor", false);
    /**
     * When enabled the scene will be placed automatically when a point in the real world is found
     */
    __publicField(this, "autoPlace", true);
    /** When enabled the AR session root center will be automatically adjusted to place the center of the scene */
    __publicField(this, "autoCenter", false);
    /** When enabled a USDZExporter component will be added to the scene (if none is found) */
    __publicField(this, "useQuicklookExport", false);
    /** Preview feature enabling occlusion (when available: https://github.com/cabanier/three.js/commit/b6ee92bcd8f20718c186120b7f19a3b68a1d4e47)
     * Enables the 'depth-sensing' WebXR feature to provide realtime depth occlusion. Only supported on Oculus Quest right now.
     */
    __publicField(this, "useDepthSensing", false);
    /**
     * When enabled the spatial grab raycaster will be added or enabled in the scene
     * @default true
     */
    __publicField(this, "useSpatialGrab", true);
    /** This avatar representation will be spawned when you enter a webxr session */
    __publicField(this, "defaultAvatar");
    __publicField(this, "_playerSync");
    /** these components were created by the WebXR component on session start and will be cleaned up again in session end */
    __publicField(this, "_createdComponentsInSession", []);
    __publicField(this, "_usdzExporter");
    __publicField(this, "_exitXRMenuButton");
    __publicField(this, "_previousXRState", 0);
    __publicField(this, "_spatialGrabRaycaster");
    __publicField(this, "onAvatarSpawned", (instance) => {
      if (debug84)
        console.log("WebXR.onAvatarSpawned", instance);
      let avatar = GameObject.getComponentInChildren(instance, Avatar);
      avatar ?? (avatar = GameObject.addComponent(instance, Avatar));
    });
    __publicField(this, "_buttonFactory");
    __publicField(this, "_buttons", []);
  }
  awake() {
    NeedleXRSession.getXRSync(this.context);
  }
  onEnable() {
    var _a2, _b;
    if (window.location.protocol !== "https:") {
      showBalloonWarning('<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebXR_Device_API" target="_blank">WebXR</a> only works on secure connections (https).');
    }
    if (this.useQuicklookExport) {
      const existingUSDZExporter = GameObject.findObjectOfType(USDZExporter2);
      if (!existingUSDZExporter) {
        if (debug84)
          console.log("WebXR: Adding USDZExporter");
        this._usdzExporter = GameObject.addComponent(this.gameObject, USDZExporter2);
        this._usdzExporter.objectToExport = this.context.scene;
        this._usdzExporter.autoExportAnimations = true;
        this._usdzExporter.autoExportAudioSources = true;
      }
    }
    this.handleCreatingHTML();
    this.handleOfferSession();
    if (this.defaultAvatar === true) {
      if (debug84)
        console.warn("WebXR: No default avatar set, using static default avatar");
      this.defaultAvatar = new AssetReference("https://cdn.needle.tools/static/avatars/DefaultAvatar.glb");
    }
    if (this.defaultAvatar) {
      this._playerSync = this.gameObject.getOrAddComponent(PlayerSync);
      this._playerSync.autoSync = false;
    }
    if (this._playerSync && typeof this.defaultAvatar != "boolean") {
      this._playerSync.asset = this.defaultAvatar;
      (_a2 = this._playerSync.onPlayerSpawned) == null ? void 0 : _a2.removeEventListener(this.onAvatarSpawned);
      (_b = this._playerSync.onPlayerSpawned) == null ? void 0 : _b.addEventListener(this.onAvatarSpawned);
    }
  }
  onDisable() {
    var _a2;
    (_a2 = this._usdzExporter) == null ? void 0 : _a2.destroy();
    this.removeButtons();
  }
  async handleOfferSession() {
    if (this.createVRButton) {
      const hasVRSupport = await NeedleXRSession.isVRSupported();
      if (hasVRSupport && this.createVRButton) {
        return NeedleXRSession.offerSession("immersive-vr", "default", this.context);
      }
    }
    if (this.createARButton) {
      const hasARSupport = await NeedleXRSession.isARSupported();
      if (hasARSupport && this.createARButton) {
        return NeedleXRSession.offerSession("immersive-ar", "default", this.context);
      }
    }
    return false;
  }
  /** the currently active webxr input session */
  get session() {
    return NeedleXRSession.active ?? null;
  }
  /** immersive-vr or immersive-ar */
  get sessionMode() {
    return NeedleXRSession.activeMode ?? null;
    ;
  }
  /** Call to start an WebVR session */
  async enterVR(init) {
    return NeedleXRSession.start("immersive-vr", init, this.context);
  }
  /** Call to start an WebAR session */
  async enterAR(init) {
    return NeedleXRSession.start("immersive-ar", init, this.context);
  }
  /** Call to end a WebXR (AR or VR) session */
  exitXR() {
    NeedleXRSession.stop();
  }
  get isActiveWebXR() {
    return !_WebXR.activeWebXRComponent || _WebXR.activeWebXRComponent === this;
  }
  onBeforeXR(_mode, args) {
    var _a2;
    if (!this.isActiveWebXR) {
      console.warn(`WebXR: another WebXR component is already active (${(_a2 = _WebXR.activeWebXRComponent) == null ? void 0 : _a2.name}). This is ignored: ${this.name}`);
      return;
    }
    _WebXR.activeWebXRComponent = this;
    if (_mode == "immersive-ar" && this.useDepthSensing) {
      args.optionalFeatures = args.optionalFeatures || [];
      args.optionalFeatures.push("depth-sensing");
    }
  }
  async onEnterXR(args) {
    if (!this.isActiveWebXR)
      return;
    if (debug84)
      console.log("WebXR onEnterXR");
    this._previousXRState = XRState.Global.Mask;
    const isVR = args.xr.isVR;
    XRState.Global.Set(isVR ? XRStateFlag.VR : XRStateFlag.AR);
    if (this.usePlacementReticle && args.xr.isAR) {
      let sessionroot = GameObject.findObjectOfType(WebARSessionRoot);
      if (!sessionroot) {
        const implicitSessionRoot = new Object3D();
        for (const ch of this.context.scene.children)
          implicitSessionRoot.add(ch);
        this.context.scene.add(implicitSessionRoot);
        sessionroot = GameObject.addComponent(implicitSessionRoot, WebARSessionRoot);
        this._createdComponentsInSession.push(sessionroot);
      }
      sessionroot.customReticle = this.customARPlacementReticle;
      sessionroot.arScale = this.arScale;
      sessionroot.arTouchTransform = this.usePlacementAdjustment;
      sessionroot.autoPlace = this.autoPlace;
      sessionroot.autoCenter = this.autoCenter;
      sessionroot.useXRAnchor = this.useXRAnchor;
    }
    if (this.useDefaultControls) {
      this.setDefaultMovementEnabled(true);
    }
    if (this.showControllerModels || this.showHandModels) {
      this.setDefaultControllerRenderingEnabled(true);
    }
    if (this.useSpatialGrab) {
      this._spatialGrabRaycaster = GameObject.findObjectOfType(SpatialGrabRaycaster) ?? void 0;
      if (!this._spatialGrabRaycaster) {
        this._spatialGrabRaycaster = this.gameObject.addComponent(SpatialGrabRaycaster);
      }
    }
    this.createLocalAvatar(args.xr);
    if (args.xr.isScreenBasedAR) {
    } else {
      this._exitXRMenuButton = this.context.menu.appendChild({
        label: "Quit XR",
        onClick: () => this.exitXR(),
        icon: "exit_to_app",
        priority: 2e4
      });
    }
  }
  onUpdateXR(_args) {
    if (!this.isActiveWebXR)
      return;
    if (this._spatialGrabRaycaster) {
      this._spatialGrabRaycaster.enabled = this.useSpatialGrab;
    }
  }
  onLeaveXR(_) {
    var _a2, _b;
    (_a2 = this._exitXRMenuButton) == null ? void 0 : _a2.remove();
    if (!this.isActiveWebXR)
      return;
    XRState.Global.Set(this._previousXRState);
    (_b = this._playerSync) == null ? void 0 : _b.destroyInstance();
    for (const comp of this._createdComponentsInSession) {
      comp.destroy();
    }
    this._createdComponentsInSession.length = 0;
    this.handleOfferSession();
    delayForFrames(1).then(() => _WebXR.activeWebXRComponent = null);
  }
  /** Call to enable or disable default controller behaviour */
  setDefaultMovementEnabled(enabled) {
    let movement = this.gameObject.getComponent(XRControllerMovement);
    if (!movement && enabled) {
      movement = this.gameObject.addComponent(XRControllerMovement);
      this._createdComponentsInSession.push(movement);
    }
    if (movement)
      movement.enabled = enabled;
    return movement;
  }
  /** Call to enable or disable default controller rendering */
  setDefaultControllerRenderingEnabled(enabled) {
    let models = this.gameObject.getComponent(XRControllerModel2);
    if (!models && enabled) {
      models = this.gameObject.addComponent(XRControllerModel2);
      this._createdComponentsInSession.push(models);
      models.createControllerModel = this.showControllerModels;
      models.createHandModel == this.showHandModels;
    }
    if (models)
      models.enabled = enabled;
    return models;
  }
  async createLocalAvatar(xr) {
    if (this._playerSync && xr.running && typeof this.defaultAvatar != "boolean") {
      this._playerSync.asset = this.defaultAvatar;
      await this._playerSync.getInstance();
    }
  }
  // HTML UI
  /** @deprecated use `getButtonsFactory()` or access `WebXRButtonFactory.getOrCreate()` directory */
  getButtonsContainer() {
    return this.getButtonsFactory();
  }
  /** Calling this function will get the Needle WebXR button factory (it will be created if it doesnt exist yet)
   * @returns the Needle WebXR button factory */
  getButtonsFactory() {
    if (!this._buttonFactory) {
      this._buttonFactory = WebXRButtonFactory.getOrCreate();
    }
    return this._buttonFactory;
  }
  handleCreatingHTML() {
    const xrButtonsPriority = 50;
    if (this.createARButton || this.createVRButton || this.useQuicklookExport) {
      if (DeviceUtilities.isiOS() && DeviceUtilities.isSafari() || debugQuicklook) {
        if (this.useQuicklookExport) {
          const usdzExporter = GameObject.findObjectOfType(USDZExporter2);
          if (!usdzExporter || usdzExporter && usdzExporter.allowCreateQuicklookButton) {
            const button = this.getButtonsFactory().createQuicklookButton();
            this.addButton(button, xrButtonsPriority);
          }
        }
      }
      if (this.createARButton) {
        const arbutton = this.getButtonsFactory().createARButton();
        this.addButton(arbutton, xrButtonsPriority);
      }
      if (this.createVRButton) {
        const vrbutton = this.getButtonsFactory().createVRButton();
        this.addButton(vrbutton, xrButtonsPriority);
      }
    }
    if (this.createSendToQuestButton && !DeviceUtilities.isQuest()) {
      NeedleXRSession.isVRSupported().then((supported) => {
        if (!supported) {
          const button = this.getButtonsFactory().createSendToQuestButton();
          this.addButton(button, xrButtonsPriority);
        }
      });
    }
    if (this.createQRCode) {
      const menu = findObjectOfType(NeedleMenu2);
      if (menu && menu.createQRCodeButton === false) {
        if (isDevEnvironment())
          console.warn("WebXR: QRCode button is disabled in the Needle Menu component");
      } else if (!DeviceUtilities.isMobileDevice()) {
        const qrCode = ButtonsFactory.getOrCreate().createQRCode();
        this.addButton(qrCode, xrButtonsPriority);
      }
    }
  }
  addButton(button, priority) {
    this._buttons.push(button);
    button.setAttribute("priority", priority.toString());
    this.context.menu.appendChild(button);
  }
  removeButtons() {
    for (const button of this._buttons) {
      button.remove();
    }
    this._buttons.length = 0;
  }
};
var WebXR = _WebXR;
__publicField(WebXR, "activeWebXRComponent", null);
__decorate50([
  serializable()
], WebXR.prototype, "createVRButton", void 0);
__decorate50([
  serializable()
], WebXR.prototype, "createARButton", void 0);
__decorate50([
  serializable()
], WebXR.prototype, "createSendToQuestButton", void 0);
__decorate50([
  serializable()
], WebXR.prototype, "createQRCode", void 0);
__decorate50([
  serializable()
], WebXR.prototype, "useDefaultControls", void 0);
__decorate50([
  serializable()
], WebXR.prototype, "showControllerModels", void 0);
__decorate50([
  serializable()
], WebXR.prototype, "showHandModels", void 0);
__decorate50([
  serializable()
], WebXR.prototype, "usePlacementReticle", void 0);
__decorate50([
  serializable(AssetReference)
], WebXR.prototype, "customARPlacementReticle", void 0);
__decorate50([
  serializable()
], WebXR.prototype, "usePlacementAdjustment", void 0);
__decorate50([
  serializable()
], WebXR.prototype, "arScale", void 0);
__decorate50([
  serializable()
], WebXR.prototype, "useXRAnchor", void 0);
__decorate50([
  serializable()
], WebXR.prototype, "autoPlace", void 0);
__decorate50([
  serializable()
], WebXR.prototype, "autoCenter", void 0);
__decorate50([
  serializable()
], WebXR.prototype, "useQuicklookExport", void 0);
__decorate50([
  serializable()
], WebXR.prototype, "useDepthSensing", void 0);
__decorate50([
  serializable()
], WebXR.prototype, "useSpatialGrab", void 0);
__decorate50([
  serializable(AssetReference)
], WebXR.prototype, "defaultAvatar", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/export/usdz/extensions/behavior/PhysicsExtension.js
var PhysicsExtension = class {
  get extensionName() {
    return "Physics";
  }
  onExportObject(object, model, _context) {
    const rigidBodySources = GameObject.getComponents(object, Rigidbody).filter((c2) => c2.enabled);
    const colliderSources = GameObject.getComponents(object, Collider).filter((c2) => c2.enabled && !c2.isTrigger);
    let rigidBody = rigidBodySources.length > 0 ? rigidBodySources[0] : null;
    const colliderSource = colliderSources.length > 0 ? colliderSources[0] : null;
    let temporaryRigidbody = void 0;
    if (colliderSource && !rigidBody) {
      rigidBody = new Rigidbody();
      rigidBody.isKinematic = true;
      temporaryRigidbody = rigidBody;
    }
    if (rigidBody) {
      model.addEventListener("serialize", (writer, _context2) => {
        var _a2, _b, _c;
        if (!rigidBody)
          return;
        writer.appendLine();
        writer.beginBlock(`def RealityKitComponent "RigidBody"`, "{", true);
        if (!rigidBody.useGravity) {
          writer.appendLine(`bool gravityEnabled = 0`);
        }
        writer.appendLine(`uniform token info:id = "RealityKit.RigidBody"`);
        if (rigidBody.isKinematic) {
          writer.appendLine(`token motionType = "Kinematic"`);
        }
        writer.beginBlock(`def RealityKitStruct "massFrame"`, "{", true);
        writer.appendLine(`float m_mass = ${rigidBody.mass}`);
        writer.beginBlock(`def RealityKitStruct "m_pose"`, "{", true);
        writer.appendLine(`float3 position = (${rigidBody.centerOfMass.x}, ${rigidBody.centerOfMass.y}, ${rigidBody.centerOfMass.z})`);
        writer.closeBlock("}");
        writer.closeBlock("}");
        if (colliderSources.length > 0) {
          const colliderSource2 = colliderSources[0];
          writer.beginBlock(`def RealityKitStruct "material"`, "{", true);
          const mat = colliderSource2.sharedMaterial;
          if (mat && mat.dynamicFriction !== void 0)
            writer.appendLine(`double dynamicFriction = ${(_a2 = colliderSource2.sharedMaterial) == null ? void 0 : _a2.dynamicFriction}`);
          if (mat && mat.bounciness !== void 0)
            writer.appendLine(`double restitution = ${(_b = colliderSource2.sharedMaterial) == null ? void 0 : _b.bounciness}`);
          if (mat && mat.staticFriction !== void 0)
            writer.appendLine(`double staticFriction = ${(_c = colliderSource2.sharedMaterial) == null ? void 0 : _c.staticFriction}`);
          writer.closeBlock("}");
        }
        writer.closeBlock("}");
      });
    }
    if (colliderSource) {
      model.addEventListener("serialize", (writer, _context2) => {
        var _a2;
        writer.beginBlock(`def RealityKitComponent "Collider"`, "{", true);
        writer.appendLine(`uint group = 1`);
        writer.appendLine(`uniform token info:id = "RealityKit.Collider"`);
        writer.appendLine(`uint mask = 4294967295`);
        const isTrigger = colliderSource.isTrigger;
        const typeName = isTrigger ? "Trigger" : "Default";
        writer.appendLine(`token type = "${typeName}"`);
        writer.beginBlock(`def RealityKitStruct "Shape"`, "{", true);
        if (colliderSource instanceof SphereCollider) {
          const sphereCollider = colliderSource;
          writer.appendLine(`token shapeType = "Sphere"`);
          writer.appendLine(`float radius = ${sphereCollider.radius}`);
        } else if (colliderSource instanceof BoxCollider) {
          const boxCollider = colliderSource;
          writer.appendLine(`token shapeType = "Box"`);
          writer.appendLine(`float3 extent = (${boxCollider.size.x}, ${boxCollider.size.y}, ${boxCollider.size.z})`);
        } else if (colliderSource instanceof CapsuleCollider) {
          const capsuleCollider = colliderSource;
          writer.appendLine(`token shapeType = "Capsule"`);
          writer.appendLine(`float radius = ${capsuleCollider.radius}`);
          writer.appendLine(`float height = ${capsuleCollider.height}`);
        } else if (colliderSource instanceof MeshCollider && ((_a2 = colliderSource.sharedMesh) == null ? void 0 : _a2.geometry)) {
          const geo = colliderSource.sharedMesh.geometry;
          if (!geo.boundingBox)
            geo.computeBoundingBox();
          const box2 = colliderSource.sharedMesh.geometry.boundingBox;
          if (box2) {
            writer.appendLine(`token shapeType = "Box"`);
            writer.appendLine(`float3 extent = (${box2.max.x - box2.min.x}, ${box2.max.y - box2.min.y}, ${box2.max.z - box2.min.z})`);
            console.log("[USDZ] Only Box, Sphere, and Capsule colliders are supported in visionOS/iOS. MeshCollider will be exported as Box", colliderSource);
          }
        } else {
          console.warn("[USDZ] Only Box, Sphere, and Capsule colliders are supported in visionOS/iOS. Ignoring collider:", colliderSource);
        }
        writer.beginBlock(`def RealityKitStruct "pose"`, "{", true);
        writer.closeBlock("}");
        writer.closeBlock("}");
        writer.closeBlock("}");
      });
      if (colliderSources.length > 1) {
        console.log("WARNING: Multiple colliders detected. visionOS / iOS can only support objects with a single collider, only exporting the first collider: ", colliderSource);
      }
    }
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/ui/Text.js
var __decorate51 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug85 = getParam("debugtext");
var TextAnchor2;
(function(TextAnchor3) {
  TextAnchor3[TextAnchor3["UpperLeft"] = 0] = "UpperLeft";
  TextAnchor3[TextAnchor3["UpperCenter"] = 1] = "UpperCenter";
  TextAnchor3[TextAnchor3["UpperRight"] = 2] = "UpperRight";
  TextAnchor3[TextAnchor3["MiddleLeft"] = 3] = "MiddleLeft";
  TextAnchor3[TextAnchor3["MiddleCenter"] = 4] = "MiddleCenter";
  TextAnchor3[TextAnchor3["MiddleRight"] = 5] = "MiddleRight";
  TextAnchor3[TextAnchor3["LowerLeft"] = 6] = "LowerLeft";
  TextAnchor3[TextAnchor3["LowerCenter"] = 7] = "LowerCenter";
  TextAnchor3[TextAnchor3["LowerRight"] = 8] = "LowerRight";
})(TextAnchor2 || (TextAnchor2 = {}));
var VerticalWrapMode;
(function(VerticalWrapMode2) {
  VerticalWrapMode2[VerticalWrapMode2["Truncate"] = 0] = "Truncate";
  VerticalWrapMode2[VerticalWrapMode2["Overflow"] = 1] = "Overflow";
})(VerticalWrapMode || (VerticalWrapMode = {}));
var HorizontalWrapMode;
(function(HorizontalWrapMode2) {
  HorizontalWrapMode2[HorizontalWrapMode2["Wrap"] = 0] = "Wrap";
  HorizontalWrapMode2[HorizontalWrapMode2["Overflow"] = 1] = "Overflow";
})(HorizontalWrapMode || (HorizontalWrapMode = {}));
var FontStyle;
(function(FontStyle2) {
  FontStyle2[FontStyle2["Normal"] = 0] = "Normal";
  FontStyle2[FontStyle2["Bold"] = 1] = "Bold";
  FontStyle2[FontStyle2["Italic"] = 2] = "Italic";
  FontStyle2[FontStyle2["BoldAndItalic"] = 3] = "BoldAndItalic";
})(FontStyle || (FontStyle = {}));
var Text = class extends Graphic {
  constructor() {
    super(...arguments);
    __publicField(this, "alignment", TextAnchor2.UpperLeft);
    __publicField(this, "verticalOverflow", VerticalWrapMode.Truncate);
    __publicField(this, "horizontalOverflow", HorizontalWrapMode.Wrap);
    __publicField(this, "lineSpacing", 1);
    __publicField(this, "supportRichText", false);
    __publicField(this, "font");
    __publicField(this, "fontStyle", FontStyle.Normal);
    __publicField(this, "sRGBTextColor", new Color(1, 0, 1));
    __publicField(this, "_text", "");
    __publicField(this, "_fontSize", 12);
    __publicField(this, "_textMeshUi", null);
    __publicField(this, "_didHandleTextRenderOnTop", false);
  }
  // private _alphaFactor : number = 1;
  setAlphaFactor(factor) {
    var _a2;
    super.setAlphaFactor(factor);
    (_a2 = this.uiObject) == null ? void 0 : _a2.set({ fontOpacity: this.color.alpha * this.alphaFactor });
    this.markDirty();
  }
  get text() {
    return this._text;
  }
  set text(val) {
    if (val !== this._text) {
      this._text = val;
      this.feedText(this.text, this.supportRichText);
      this.markDirty();
    }
  }
  set_text(val) {
    this.text = val;
  }
  get fontSize() {
    return this._fontSize;
  }
  set fontSize(val) {
    var _a2;
    this._fontSize = val;
    (_a2 = this.uiObject) == null ? void 0 : _a2.set({ fontSize: val });
  }
  onColorChanged() {
    var _a2;
    this.sRGBTextColor.copy(this.color);
    this.sRGBTextColor.convertLinearToSRGB();
    (_a2 = this.uiObject) == null ? void 0 : _a2.set({ color: this.sRGBTextColor, fontOpacity: this.color.alpha });
  }
  onParentRectTransformChanged() {
    super.onParentRectTransformChanged();
    if (this.uiObject) {
      this.updateOverflow();
    }
  }
  // onBeforeRender(): void {
  //     // TODO TMUI @swingingtom this is so we don't have text clipping
  //     if (this.uiObject && (this.Canvas?.screenspace || this.context.isInVR)) {
  //         this.updateOverflow();
  //     }
  // }
  onBeforeCanvasRender(_canvas) {
    this.updateOverflow();
  }
  updateOverflow() {
    var _a2;
    const overflow = (_a2 = this.uiObject) == null ? void 0 : _a2._overflow;
    if (overflow) {
      overflow._needsUpdate = true;
    }
  }
  onCreate(_opts) {
    if (debug85)
      console.log(this);
    if (this.horizontalOverflow == HorizontalWrapMode.Overflow) {
      _opts.whiteSpace = "pre";
    }
    if (this.verticalOverflow == VerticalWrapMode.Truncate) {
      this.context.renderer.localClippingEnabled = true;
      _opts.overflow = "hidden";
    }
    if (this.horizontalOverflow == HorizontalWrapMode.Overflow && this.verticalOverflow == VerticalWrapMode.Truncate) {
    }
    _opts.lineHeight = this.lineSpacing;
    delete _opts.backgroundOpacity;
    delete _opts.backgroundColor;
    if (debug85) {
      _opts.backgroundColor = 16750848;
      _opts.backgroundOpacity = 0.5;
    }
    const rt = this.rectTransform;
    _opts = { ..._opts, ...this.getTextOpts() };
    this.getAlignment(_opts);
    if (debug85) {
      _opts.backgroundColor = Math.random() * 16777215;
      _opts.backgroundOpacity = 0.1;
    }
    this.uiObject = rt.createNewText(_opts);
    this.feedText(this.text, this.supportRichText);
  }
  onAfterAddedToScene() {
    super.onAfterAddedToScene();
    this.handleTextRenderOnTop();
  }
  getTextOpts() {
    const fontSize = this.fontSize;
    const textOpts = {
      color: this.color,
      fontOpacity: this.color.alpha,
      fontSize,
      fontKerning: "normal"
    };
    this.setFont(textOpts, this.fontStyle);
    return textOpts;
  }
  onEnable() {
    var _a2;
    super.onEnable();
    this._didHandleTextRenderOnTop = false;
    if (this.uiObject) {
      this.uiObject.addAfterUpdate(() => {
        this.setShadowComponentOwner(this.uiObject);
        this.markDirty();
      });
    }
    setTimeout(() => this.markDirty(), 10);
    (_a2 = this.canvas) == null ? void 0 : _a2.registerEventReceiver(this);
  }
  onDisable() {
    var _a2;
    super.onDisable();
    (_a2 = this.canvas) == null ? void 0 : _a2.unregisterEventReceiver(this);
  }
  getAlignment(opts) {
    opts.flexDirection = "column";
    switch (this.alignment) {
      case TextAnchor2.UpperLeft:
      case TextAnchor2.MiddleLeft:
      case TextAnchor2.LowerLeft:
        opts.textAlign = "left";
        break;
      case TextAnchor2.UpperCenter:
      case TextAnchor2.MiddleCenter:
      case TextAnchor2.LowerCenter:
        opts.textAlign = "center";
        break;
      case TextAnchor2.UpperRight:
      case TextAnchor2.MiddleRight:
      case TextAnchor2.LowerRight:
        opts.textAlign = "right";
        break;
    }
    switch (this.alignment) {
      default:
      case TextAnchor2.UpperLeft:
      case TextAnchor2.UpperCenter:
      case TextAnchor2.UpperRight:
        opts.alignItems = "start";
        break;
      case TextAnchor2.MiddleLeft:
      case TextAnchor2.MiddleCenter:
      case TextAnchor2.MiddleRight:
        opts.alignItems = "center";
        break;
      case TextAnchor2.LowerLeft:
      case TextAnchor2.LowerCenter:
      case TextAnchor2.LowerRight:
        opts.alignItems = "end";
        break;
    }
    return opts;
  }
  feedText(text, richText) {
    var _a2, _b, _c;
    if (debug85)
      console.log("feedText", this.uiObject, text, richText);
    if (!this.uiObject)
      return;
    if (!this._textMeshUi)
      this._textMeshUi = [];
    this.uiObject.children.length = 0;
    if (!richText || text.length === 0) {
      this.uiObject.textContent = text;
    } else {
      let currentTag = this.getNextTag(text);
      if (!currentTag) {
        this.uiObject.textContent = "";
        this.setOptions({ textContent: text });
        return;
      } else if (currentTag.startIndex > 0) {
        for (let i = this.uiObject.children.length - 1; i >= 0; i--) {
          const child = this.uiObject.children[i];
          if (child.isUI) {
            this.uiObject.remove(child);
            child.clear();
          }
        }
        const el = new __webpack_exports__Inline({ textContent: text.substring(0, currentTag.startIndex), color: "inherit" });
        this.uiObject.add(el);
      }
      const stackArray = [];
      while (currentTag) {
        const next = this.getNextTag(text, currentTag.endIndex);
        const opts = {
          fontFamily: (_a2 = this.uiObject) == null ? void 0 : _a2.get("fontFamily"),
          color: "inherit",
          textContent: ""
        };
        if (next) {
          opts.textContent = this.getText(text, currentTag, next);
          this.handleTag(currentTag, opts, stackArray);
          const el = new __webpack_exports__Inline(opts);
          (_b = this.uiObject) == null ? void 0 : _b.add(el);
        } else {
          opts.textContent = text.substring(currentTag.endIndex);
          this.handleTag(currentTag, opts, stackArray);
          const el = new __webpack_exports__Inline(opts);
          (_c = this.uiObject) == null ? void 0 : _c.add(el);
        }
        currentTag = next;
      }
    }
  }
  handleTextRenderOnTop() {
    if (this._didHandleTextRenderOnTop)
      return;
    this._didHandleTextRenderOnTop = true;
    this.startCoroutine(this.renderOnTopCoroutine());
  }
  // waits for all the text objects to be ready to set the render on top setting
  // @THH :  this isn't true anymore. We can set mesh and material properties before their counterparts are created.
  //         Values would automatically be passed when created. Not sure for depthWrite but it can be added;
  *renderOnTopCoroutine() {
    if (!this.canvas)
      return;
    const updatedRendering = [];
    const canvas = this.canvas;
    const settings = {
      renderOnTop: canvas.renderOnTop,
      depthWrite: canvas.depthWrite,
      doubleSided: canvas.doubleSided
    };
    while (true) {
      let isWaitingForElementToUpdate = false;
      if (this._textMeshUi) {
        for (let i = 0; i < this._textMeshUi.length; i++) {
          if (updatedRendering[i] === true)
            continue;
          isWaitingForElementToUpdate = true;
          const textMeshObject = this._textMeshUi[i];
          if (!textMeshObject["textContent"])
            continue;
          updateRenderSettings(textMeshObject, settings);
          updatedRendering[i] = true;
        }
      }
      if (!isWaitingForElementToUpdate)
        break;
      yield;
    }
  }
  handleTag(tag, opts, stackArray) {
    if (!tag.isEndTag) {
      if (tag.type.includes("color")) {
        const stackEntry = new TagStackEntry(tag, { color: opts.color });
        stackArray.push(stackEntry);
        if (tag.type.length > 6) {
          const col2 = parseInt("0x" + tag.type.substring(7));
          opts.color = col2;
        } else {
          opts.color = new Color(1, 1, 1);
        }
      } else if (tag.type == "b") {
        this.setFont(opts, FontStyle.Bold);
        const stackEntry = new TagStackEntry(tag, {
          fontWeight: 700
        });
        stackArray.push(stackEntry);
      } else if (tag.type == "i") {
        this.setFont(opts, FontStyle.Italic);
        const stackEntry = new TagStackEntry(tag, {
          fontStyle: "italic"
        });
        stackArray.push(stackEntry);
      }
    }
  }
  getText(text, start, end) {
    return text.substring(start.endIndex, end.startIndex);
  }
  getNextTag(text, startIndex = 0) {
    const start = text.indexOf("<", startIndex);
    const end = text.indexOf(">", start);
    if (start >= 0 && end >= 0) {
      const tag = text.substring(start + 1, end);
      return { type: tag, startIndex: start, endIndex: end + 1, isEndTag: tag.startsWith("/") };
    }
    return null;
  }
  /**
   * Update provided opts to have a proper fontDefinition : family+weight+style
   * Ensure Family and Variant are registered in FontLibrary
   *
   * @param opts
   * @param fontStyle
   * @private
   */
  setFont(opts, fontStyle) {
    if (!this.font)
      return;
    const fontName = this.font;
    const familyName = this.getFamilyNameWithCorrectSuffix(fontName, fontStyle);
    if (debug85)
      console.log("Selected font family:" + familyName);
    let fontFamily = __webpack_exports__FontLibrary.getFontFamily(familyName);
    if (!fontFamily)
      fontFamily = __webpack_exports__FontLibrary.addFontFamily(familyName);
    opts.fontFamily = fontFamily;
    switch (fontStyle) {
      default:
      case FontStyle.Normal:
        opts.fontWeight = 400;
        opts.fontStyle = "normal";
        break;
      case FontStyle.Bold:
        opts.fontWeight = 700;
        opts.fontStyle = "normal";
        break;
      case FontStyle.Italic:
        opts.fontWeight = 400;
        opts.fontStyle = "italic";
        break;
      case FontStyle.BoldAndItalic:
        opts.fontStyle = "italic";
        opts.fontWeight = 400;
    }
    let fontVariant = fontFamily.getVariant(opts.fontWeight, opts.fontStyle);
    if (!fontVariant) {
      let jsonPath = familyName;
      if (!(jsonPath == null ? void 0 : jsonPath.endsWith("-msdf.json")))
        jsonPath += "-msdf.json";
      let texturePath = familyName;
      if (!(texturePath == null ? void 0 : texturePath.endsWith(".png")))
        texturePath += ".png";
      fontVariant = fontFamily.addVariant(opts.fontWeight, opts.fontStyle, jsonPath, texturePath);
      fontVariant == null ? void 0 : fontVariant.addEventListener("ready", () => {
        this.markDirty();
      });
    }
  }
  getFamilyNameWithCorrectSuffix(familyName, style) {
    var _a2;
    const styleSeparator = familyName.lastIndexOf("-");
    if (styleSeparator < 0)
      return familyName;
    const styleName = (_a2 = familyName.substring(styleSeparator + 1)) == null ? void 0 : _a2.toLowerCase();
    if (unsupportedStyleNames.includes(styleName)) {
      if (debug85)
        console.warn("Unsupported font style: " + styleName);
      return familyName;
    }
    const pathSeparatorIndex = familyName.lastIndexOf("/");
    let fontBaseName = familyName;
    if (pathSeparatorIndex >= 0) {
      fontBaseName = fontBaseName.substring(pathSeparatorIndex + 1);
    }
    const isUpperCase2 = fontBaseName[0] === fontBaseName[0].toUpperCase();
    const fontNameWithoutSuffix = familyName.substring(0, styleSeparator);
    if (debug85)
      console.log("Select font: ", familyName, FontStyle[style], fontBaseName, isUpperCase2, fontNameWithoutSuffix);
    switch (style) {
      case FontStyle.Normal:
        if (isUpperCase2)
          return fontNameWithoutSuffix + "-Regular";
        else
          return fontNameWithoutSuffix + "-regular";
      case FontStyle.Bold:
        if (isUpperCase2)
          return fontNameWithoutSuffix + "-Bold";
        else
          return fontNameWithoutSuffix + "-bold";
      case FontStyle.Italic:
        if (isUpperCase2)
          return fontNameWithoutSuffix + "-Italic";
        else
          return fontNameWithoutSuffix + "-italic";
      case FontStyle.BoldAndItalic:
        if (isUpperCase2)
          return fontNameWithoutSuffix + "-BoldItalic";
        else
          return fontNameWithoutSuffix + "-bolditalic";
      default:
        return familyName;
    }
  }
};
__decorate51([
  serializable()
], Text.prototype, "alignment", void 0);
__decorate51([
  serializable()
], Text.prototype, "verticalOverflow", void 0);
__decorate51([
  serializable()
], Text.prototype, "horizontalOverflow", void 0);
__decorate51([
  serializable()
], Text.prototype, "lineSpacing", void 0);
__decorate51([
  serializable()
], Text.prototype, "supportRichText", void 0);
__decorate51([
  serializable(URL)
], Text.prototype, "font", void 0);
__decorate51([
  serializable()
], Text.prototype, "fontStyle", void 0);
__decorate51([
  serializable()
], Text.prototype, "text", null);
__decorate51([
  serializable()
], Text.prototype, "fontSize", null);
var TagStackEntry = class {
  constructor(tag, previousValues) {
    __publicField(this, "tag");
    __publicField(this, "previousValues");
    this.tag = tag;
    this.previousValues = previousValues;
  }
};
var unsupportedStyleNames = [
  "medium",
  "mediumitalic",
  "black",
  "blackitalic",
  "thin",
  "thinitalic",
  "extrabold",
  "light",
  "lightitalic",
  "semibold"
];

// node_modules/@needle-tools/engine/lib/engine-components/export/usdz/extensions/USDZText.js
var TextWrapMode;
(function(TextWrapMode2) {
  TextWrapMode2["singleLine"] = "singleLine";
  TextWrapMode2["hardBreaks"] = "hardBreaks";
  TextWrapMode2["flowing"] = "flowing";
})(TextWrapMode || (TextWrapMode = {}));
var HorizontalAlignment;
(function(HorizontalAlignment2) {
  HorizontalAlignment2["left"] = "left";
  HorizontalAlignment2["center"] = "center";
  HorizontalAlignment2["right"] = "right";
  HorizontalAlignment2["justified"] = "justified";
})(HorizontalAlignment || (HorizontalAlignment = {}));
var VerticalAlignment;
(function(VerticalAlignment2) {
  VerticalAlignment2["top"] = "top";
  VerticalAlignment2["middle"] = "middle";
  VerticalAlignment2["lowerMiddle"] = "lowerMiddle";
  VerticalAlignment2["baseline"] = "baseline";
  VerticalAlignment2["bottom"] = "bottom";
})(VerticalAlignment || (VerticalAlignment = {}));
var USDZText = class {
  constructor(id) {
    __publicField(this, "id");
    __publicField(this, "content", "");
    __publicField(this, "font", []);
    __publicField(this, "pointSize", 144);
    __publicField(this, "width");
    __publicField(this, "height");
    __publicField(this, "depth");
    __publicField(this, "wrapMode");
    __publicField(this, "horizontalAlignment");
    __publicField(this, "verticalAlignment");
    __publicField(this, "material");
    this.id = id;
  }
  static getId() {
    return this.global_id++;
  }
  setDepth(depth) {
    this.depth = depth;
    return this;
  }
  setPointSize(pointSize) {
    this.pointSize = pointSize;
    return this;
  }
  setHorizontalAlignment(align) {
    this.horizontalAlignment = align;
    return this;
  }
  setVerticalAlignment(align) {
    this.verticalAlignment = align;
    return this;
  }
  writeTo(_document, writer) {
    var _a2;
    writer.beginBlock(`def Preliminary_Text "${this.id}"`, "(", false);
    writer.appendLine(`prepend apiSchemas = ["MaterialBindingAPI"]`);
    writer.closeBlock(")");
    writer.beginBlock();
    if (this.content)
      writer.appendLine(`string content = "${this.content}"`);
    if (!this.font || this.font.length <= 0) {
      this.font || (this.font = []);
      (_a2 = this.font) == null ? void 0 : _a2.push("sans-serif");
    }
    const str = this.font.map((s) => `"${s}"`).join(", ");
    writer.appendLine(`string[] font = [ ${str} ]`);
    writer.appendLine(`double pointSize = ${this.pointSize}`);
    if (typeof this.width === "number")
      writer.appendLine(`double width = ${this.width}`);
    if (typeof this.height === "number")
      writer.appendLine(`double height = ${this.height}`);
    if (typeof this.depth === "number")
      writer.appendLine(`double depth = ${this.depth}`);
    if (this.wrapMode)
      writer.appendLine(`token wrapMode = "${this.wrapMode}"`);
    if (this.horizontalAlignment)
      writer.appendLine(`token horizontalAlignment = "${this.horizontalAlignment}"`);
    if (this.verticalAlignment)
      writer.appendLine(`token verticalAlignment = "${this.verticalAlignment}"`);
    if (this.material !== void 0) {
      writer.appendLine(`rel material:binding = </StageRoot/Materials/${getMaterialName(this.material)}>`);
    }
    writer.closeBlock();
  }
};
__publicField(USDZText, "global_id", 0);
var TextBuilder = class {
  static singleLine(str, pointSize, depth) {
    const text = new USDZText("text_" + USDZText.getId());
    text.content = str;
    if (pointSize)
      text.pointSize = pointSize;
    if (depth)
      text.depth = depth;
    return text;
  }
  static multiLine(str, width, height, horizontal, vertical, wrapMode) {
    const text = new USDZText("text_" + USDZText.getId());
    text.content = str;
    text.width = width;
    text.height = height;
    text.horizontalAlignment = horizontal;
    text.verticalAlignment = vertical;
    if (wrapMode !== void 0)
      text.wrapMode = wrapMode;
    return text;
  }
};
var rotateYAxisMatrix = new Matrix4().makeRotationY(Math.PI);
var invertX = new Matrix4().makeScale(-1, 1, -1);
var TextExtension = class {
  get extensionName() {
    return "text";
  }
  exportText(object, newModel, _context) {
    const text = GameObject.getComponent(object, Text);
    if (!text)
      return;
    const rt = GameObject.getComponent(object, RectTransform);
    let width = 100;
    let height = 100;
    if (rt) {
      width = rt.width;
      height = rt.height;
    }
    const mat = rotateYAxisMatrix.clone();
    if (rt)
      mat.premultiply(invertX);
    newModel.setMatrix(mat);
    const color2 = text.color.clone();
    newModel.material = new MeshStandardMaterial({ color: color2, emissive: color2 });
    newModel.addEventListener("serialize", (writer, _context2) => {
      let txt = text.text;
      txt = txt.replace(/\r/g, "");
      txt = txt.replace(/\n/g, "\\n");
      const textObj = TextBuilder.multiLine(txt, width, height, HorizontalAlignment.center, VerticalAlignment.bottom, TextWrapMode.flowing);
      this.setTextAlignment(textObj, text.alignment);
      this.setOverflow(textObj, text);
      if (newModel.material)
        textObj.material = newModel.material;
      textObj.pointSize = this.convertToTextSize(text.fontSize);
      textObj.depth = 1e-3;
      textObj.writeTo(void 0, writer);
    });
  }
  convertToTextSize(pixel) {
    return 1 / 0.0502 * 144 * pixel;
  }
  setOverflow(textObj, text) {
    if (text.horizontalOverflow) {
      textObj.wrapMode = TextWrapMode.singleLine;
    } else {
      textObj.wrapMode = TextWrapMode.flowing;
    }
  }
  setTextAlignment(text, alignment) {
    switch (alignment) {
      case TextAnchor2.LowerLeft:
      case TextAnchor2.MiddleLeft:
      case TextAnchor2.UpperLeft:
        text.horizontalAlignment = HorizontalAlignment.left;
        break;
      case TextAnchor2.LowerCenter:
      case TextAnchor2.MiddleCenter:
      case TextAnchor2.UpperCenter:
        text.horizontalAlignment = HorizontalAlignment.center;
        break;
      case TextAnchor2.LowerRight:
      case TextAnchor2.MiddleRight:
      case TextAnchor2.UpperRight:
        text.horizontalAlignment = HorizontalAlignment.right;
        break;
    }
    switch (alignment) {
      case TextAnchor2.LowerLeft:
      case TextAnchor2.LowerCenter:
      case TextAnchor2.LowerRight:
        text.verticalAlignment = VerticalAlignment.bottom;
        break;
      case TextAnchor2.MiddleLeft:
      case TextAnchor2.MiddleCenter:
      case TextAnchor2.MiddleRight:
        text.verticalAlignment = VerticalAlignment.middle;
        break;
      case TextAnchor2.UpperLeft:
      case TextAnchor2.UpperCenter:
      case TextAnchor2.UpperRight:
        text.verticalAlignment = VerticalAlignment.top;
        break;
    }
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/export/usdz/extensions/USDZUI.js
var USDZUIExtension = class {
  get extensionName() {
    return "tmui";
  }
  // TODO would probably be better to export each object instead of the entire Canvas
  // so that we don't export them twice (once as regular hierarchy, once as part of Canvas export)
  onExportObject(object, model, _context) {
    const canvas = GameObject.getComponent(object, Canvas);
    if (canvas && canvas.enabled && canvas.renderMode === RenderMode.WorldSpace) {
      const textExt = new TextExtension();
      const rt = GameObject.getComponent(object, RectTransform);
      const canvasGroup = GameObject.getComponent(object, CanvasGroup);
      const revertActions = new Array();
      let width = 100;
      let height = 100;
      if (rt) {
        if (!GameObject.isActiveSelf(object)) {
          const wasActive = GameObject.isActiveSelf(object);
          GameObject.setActive(object, true);
          rt.onEnable();
          rt.updateTransform();
          revertActions.push(() => {
            rt.onDisable();
            GameObject.setActive(object, wasActive);
          });
        }
        object.traverse((child) => {
          if (!GameObject.isActiveInHierarchy(child)) {
            const wasActive = GameObject.isActiveSelf(child);
            GameObject.setActive(child, true);
            const baseUIComponent = GameObject.getComponent(child, BaseUIComponent);
            if (baseUIComponent) {
              baseUIComponent.onEnable();
              revertActions.push(() => {
                baseUIComponent.onDisable();
              });
            }
            const rectTransform = GameObject.getComponent(child, RectTransform);
            if (rectTransform) {
              rectTransform.onEnable();
              rectTransform.updateTransform();
              rectTransform["onApplyTransform"]();
              revertActions.push(() => {
                rectTransform.onDisable();
              });
            }
            const text = GameObject.getComponent(child, Text);
            if (text) {
              text.onEnable();
              revertActions.push(() => {
                text.onDisable();
              });
            }
            revertActions.push(() => {
              GameObject.setActive(child, wasActive);
            });
          }
        });
        width = rt.width;
        height = rt.height;
        const shadowRootModel = USDObject.createEmpty();
        const shadowComponent = rt.shadowComponent;
        model.add(shadowRootModel);
        if (shadowComponent) {
          const mat = shadowComponent.matrix;
          shadowRootModel.setMatrix(mat);
          const usdObjectMap = /* @__PURE__ */ new Map();
          const opacityMap = /* @__PURE__ */ new Map();
          usdObjectMap.set(shadowComponent, shadowRootModel);
          opacityMap.set(shadowComponent, canvasGroup ? canvasGroup.alpha : 1);
          shadowComponent.traverse((child) => {
            if (child === shadowComponent)
              return;
            const childModel = USDObject.createEmpty();
            childModel.setMatrix(child.matrix);
            const childParent = child.parent;
            const isText = !!childParent && typeof childParent["textContent"] === "string" && childParent["textContent"].length > 0;
            let hierarchyOpacity = opacityMap.get(childParent) || 1;
            const canvasGroup2 = GameObject.getComponent(child, CanvasGroup);
            if (canvasGroup2)
              hierarchyOpacity *= canvasGroup2.alpha;
            if (child instanceof Mesh && isText) {
              const shadowDomOwner = child[$shadowDomOwner];
              if (!shadowDomOwner)
                console.error("Error when exporting UI: shadow component owner not found. This is likely a bug.", child);
              else
                textExt.exportText(shadowDomOwner.gameObject, childModel, _context);
            }
            if (child instanceof Mesh && !isText) {
              const clonedGeo = child.geometry.clone();
              clonedGeo.scale(1, 1, -1);
              this.flipWindingOrder(clonedGeo);
              childModel.geometry = clonedGeo;
              const color2 = new Color();
              const ownOpacity = child.material.opacity;
              color2.copy(child.material.color);
              childModel.material = new MeshBasicMaterial({
                color: color2,
                opacity: ownOpacity * hierarchyOpacity,
                map: child.material.map,
                transparent: true
              });
            }
            usdObjectMap.set(child, childModel);
            opacityMap.set(child, hierarchyOpacity);
            const parentUsdzObject = usdObjectMap.get(childParent);
            if (!parentUsdzObject) {
              console.error("Error when exporting UI: shadow component parent not found!", child, child.parent);
              return;
            }
            parentUsdzObject.add(childModel);
          });
        }
      }
      for (const revert of revertActions) {
        revert();
      }
    }
  }
  flipWindingOrder(geometry) {
    const index = geometry.index.array;
    for (let i = 0, il = index.length / 3; i < il; i++) {
      const x2 = index[i * 3];
      index[i * 3] = index[i * 3 + 2];
      index[i * 3 + 2] = x2;
    }
    geometry.index.needsUpdate = true;
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/export/usdz/utils/animationutils.js
var debug86 = getParam("debugusdz");
function registerAnimatorsImplictly(root, ext) {
  var _a2;
  const animationClips = [];
  const animators = GameObject.getComponentsInChildren(root, Animator);
  const animationComponents = GameObject.getComponentsInChildren(root, Animation);
  const animatorsWithPlayAtStart = new Array();
  const constructedObjects = new Array();
  if (ext.injectImplicitBehaviours) {
    for (const animator of animators) {
      if (!animator || !animator.runtimeAnimatorController || !animator.enabled)
        continue;
      const activeState = animator.runtimeAnimatorController.activeState;
      if (!activeState)
        continue;
      if (!activeState.motion || !activeState.motion.clip)
        continue;
      if (((_a2 = activeState.motion.clip.tracks) == null ? void 0 : _a2.length) < 1)
        continue;
      if (animatorsWithPlayAtStart.includes(animator))
        continue;
      const newComponent = new PlayAnimationOnClick();
      newComponent.animator = animator;
      newComponent.stateName = activeState.name;
      newComponent.trigger = "start";
      newComponent.name = "PlayAnimationOnClick_implicitAtStart_" + newComponent.stateName;
      const go = new Object3D();
      GameObject.addComponent(go, newComponent);
      constructedObjects.push(go);
      animatorsWithPlayAtStart.push(animator);
      root.add(go);
    }
  } else {
    for (const animator of animators) {
      if (!animator || !animator.runtimeAnimatorController || !animator.enabled)
        continue;
      if (debug86)
        console.log(animator);
      const clips = [];
      for (const action of animator.runtimeAnimatorController.enumerateActions()) {
        if (debug86)
          console.log(action);
        const clip = action.getClip();
        if (!clips.includes(clip))
          clips.push(clip);
      }
      animationClips.push({ root: animator.gameObject, clips });
    }
  }
  if (ext.injectImplicitBehaviours) {
    for (const animationComponent of animationComponents) {
      if (!animationComponent || !animationComponent.clip || !animationComponent.enabled)
        continue;
      if (!animationComponent.playAutomatically)
        continue;
      if (animatorsWithPlayAtStart.includes(animationComponent))
        continue;
      const newComponent = new PlayAnimationOnClick();
      newComponent.animation = animationComponent;
      newComponent.stateName = animationComponent.clip.name;
      newComponent.trigger = "start";
      newComponent.name = "PlayAnimationOnClick_implicitAtStart_" + newComponent.stateName;
      const go = new Object3D();
      GameObject.addComponent(go, newComponent);
      constructedObjects.push(go);
      animatorsWithPlayAtStart.push(animationComponent);
      root.add(go);
    }
  } else {
    for (const animationComponent of animationComponents) {
      if (debug86)
        console.log(animationComponent);
      const clips = [];
      for (const clip of animationComponent.animations) {
        if (!clips.includes(clip))
          clips.push(clip);
      }
      animationClips.push({ root: animationComponent.gameObject, clips });
    }
  }
  if (debug86 && (animationClips == null ? void 0 : animationClips.length) > 0)
    console.log("USDZ Animation Clips without behaviours", animationClips);
  for (const pair of animationClips) {
    for (const clip of pair.clips)
      ext.registerAnimation(pair.root, clip);
  }
  return constructedObjects;
}
function registerAudioSourcesImplictly(root, _ext) {
  const audioSources = GameObject.getComponentsInChildren(root, AudioSource);
  const playAudioOnClicks = GameObject.getComponentsInChildren(root, PlayAudioOnClick);
  const audioWithPlayAtStart = new Array();
  const constructedObjects = new Array();
  if (debug86) {
    console.log({ audioSources, playAudioOnClicks });
  }
  for (const player of playAudioOnClicks) {
    if (!player.target)
      continue;
    const index = audioSources.indexOf(player.target);
    if (index > -1)
      audioSources.splice(index, 1);
  }
  for (const audioSource of audioSources) {
    if (!audioSource || !audioSource.clip)
      continue;
    if (audioSource.volume <= 0)
      continue;
    if (audioWithPlayAtStart.includes(audioSource))
      continue;
    const newComponent = new PlayAudioOnClick();
    newComponent.target = audioSource;
    newComponent.name = "PlayAudioOnClick_implicitAtStart_";
    newComponent.trigger = "start";
    const go = new Object3D();
    GameObject.addComponent(go, newComponent);
    console.log("implicit PlayAudioOnStart", go, newComponent);
    constructedObjects.push(go);
    audioWithPlayAtStart.push(audioSource);
    root.add(go);
  }
  return constructedObjects;
}
function disableObjectsAtStart(objects) {
  const newComponent = new BehaviorModel("DisableAtStart", TriggerBuilder.sceneStartTrigger(), ActionBuilder.fadeAction(objects, 0, false));
  return newComponent;
}

// node_modules/@needle-tools/engine/lib/engine-components/export/usdz/utils/quicklook.js
function ensureQuicklookLinkIsCreated(context, supportsQuickLook) {
  const existingLink = context.domElement.shadowRoot.querySelector("link[rel='ar']");
  if (existingLink)
    return existingLink;
  const div = document.createElement("div");
  div.classList.add("menu");
  div.classList.add("quicklook-menu");
  div.style.display = "none";
  div.style.visibility = "hidden";
  const button = document.createElement("button");
  button.id = "open-in-ar";
  if (supportsQuickLook) {
    button.innerText = "View in AR";
    button.title = "View this scene in AR. The scene will be exported to USDZ and opened with Apple's QuickLook.";
  } else {
    button.innerText = "View in AR";
    button.title = "Download this scene for AR. Open the downloaded USDZ file to view it in AR using Apple's QuickLook.";
  }
  div.appendChild(button);
  const link = document.createElement("a");
  link.id = "needle-usdz-link";
  link.style.display = "none";
  link.rel = "ar";
  link.href = "";
  link.target = "_blank";
  div.appendChild(link);
  const img = document.createElement("img");
  img.id = "button";
  link.appendChild(img);
  context.domElement.shadowRoot.appendChild(div);
  return link;
}

// node_modules/@needle-tools/engine/lib/engine-components/export/usdz/USDZExporter.js
var __decorate52 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug87 = getParam("debugusdz");
var debugUsdzPruning = getParam("debugusdzpruning");
var CustomBranding = class {
  constructor() {
    /** The call to action button text. If not set, the button will close the QuickLook overlay. */
    __publicField(this, "callToAction");
    /** The title of the overlay. */
    __publicField(this, "checkoutTitle");
    /** The subtitle of the overlay. */
    __publicField(this, "checkoutSubtitle");
    /** if assigned the call to action button in quicklook will open the URL. Otherwise it will just close quicklook. */
    __publicField(this, "callToActionURL");
  }
};
__decorate52([
  serializable()
], CustomBranding.prototype, "callToAction", void 0);
__decorate52([
  serializable()
], CustomBranding.prototype, "checkoutTitle", void 0);
__decorate52([
  serializable()
], CustomBranding.prototype, "checkoutSubtitle", void 0);
__decorate52([
  serializable()
], CustomBranding.prototype, "callToActionURL", void 0);
var _USDZExporter = class extends Component2 {
  constructor() {
    super(...arguments);
    /**
     * Assign the object to export as USDZ file. If undefined or null, the whole scene will be exported.
     */
    __publicField(this, "objectToExport");
    /** Collect all Animations/Animators automatically on export and emit them as playing at the start.
     * Animator state chains and loops will automatically be collected and exported in order as well.
     * If this setting is off, Animators need to be registered by components – for example from PlayAnimationOnClick.
    */
    __publicField(this, "autoExportAnimations", true);
    /** Collect all AudioSources automatically on export and emit them as playing at the start.
     * They will loop according to their settings.
     * If this setting is off, Audio Sources need to be registered by components – for example from PlayAudioOnClick.
    */
    __publicField(this, "autoExportAudioSources", true);
    __publicField(this, "exportFileName");
    __publicField(this, "customUsdzFile");
    __publicField(this, "customBranding");
    // Currently not exposed to integrations - not fully tested. Set from code (e.g. image tracking)
    __publicField(this, "anchoringType", "plane");
    __publicField(this, "maxTextureSize", 2048);
    // Currently not exposed to integrations - not fully tested. Set from code (e.g. image tracking)
    __publicField(this, "planeAnchoringAlignment", "horizontal");
    /** Enabling this option will export QuickLook-specific preliminary behaviours along with the USDZ files.
     * These extensions are only supported on QuickLook on iOS/visionOS/MacOS.
     * Keep this option off for general USDZ usage.
     */
    __publicField(this, "interactive", true);
    /** Enabling this option will export the USDZ file with RealityKit physics components.
     * Rigidbody and Collider components will be converted to their RealityKit counterparts.
     * Physics are supported on QuickLook in iOS 18+ and VisionOS 1+.
     * Physics export is automatically turned off when there are no Rigidbody components anywhere on the exported object.
     */
    __publicField(this, "physics", true);
    __publicField(this, "allowCreateQuicklookButton", true);
    __publicField(this, "quickLookCompatible", true);
    /**
     * Extensions to add custom behaviors and interactions to the USDZ file.
     * You can add your own extensions here by extending {@link IUSDExporterExtension}.
     */
    __publicField(this, "extensions", []);
    __publicField(this, "link");
    __publicField(this, "button");
    __publicField(this, "onClickedOpenInARElement", (evt) => {
      evt.preventDefault();
      this.exportAndOpen();
    });
    __publicField(this, "_currentExportTasks", /* @__PURE__ */ new Map());
    __publicField(this, "_previousTimeScale", 1);
    __publicField(this, "lastCallback");
    __publicField(this, "_rootSessionRootWasAppliedTo", null);
    __publicField(this, "_rootPositionBeforeExport", new Vector32());
    __publicField(this, "_rootRotationBeforeExport", new Quaternion());
    __publicField(this, "_rootScaleBeforeExport", new Vector32());
  }
  /** @internal */
  start() {
    var _a2, _b, _c;
    if (debug87) {
      console.log("USDZExporter", this);
      console.log("Debug USDZ Mode. Press 'T' to export");
      window.addEventListener("keydown", (evt) => {
        switch (evt.key) {
          case "t":
            this.exportAndOpen();
            break;
        }
      });
    }
    if (!this.objectToExport)
      this.objectToExport = this.gameObject;
    if (!((_b = (_a2 = this.objectToExport) == null ? void 0 : _a2.children) == null ? void 0 : _b.length) && !((_c = this.objectToExport) == null ? void 0 : _c.isMesh))
      this.objectToExport = this.context.scene;
  }
  /** @internal */
  onEnable() {
    var _a2;
    const supportsQuickLook = DeviceUtilities.supportsQuickLookAR();
    const ios = DeviceUtilities.isiOS() || DeviceUtilities.isiPad();
    if (!this.button && (debug87 || supportsQuickLook || ios)) {
      if (this.allowCreateQuicklookButton)
        this.button = this.createQuicklookButton();
      this.lastCallback = this.quicklookCallback.bind(this);
      this.link = ensureQuicklookLinkIsCreated(this.context, supportsQuickLook);
      this.link.addEventListener("message", this.lastCallback);
    }
    if (debug87)
      showBalloonMessage("USDZ Exporter enabled: " + this.name);
    (_a2 = document.getElementById("open-in-ar")) == null ? void 0 : _a2.addEventListener("click", this.onClickedOpenInARElement);
    InternalUSDZRegistry.registerExporter(this);
  }
  /** @internal */
  onDisable() {
    var _a2, _b, _c;
    (_a2 = this.button) == null ? void 0 : _a2.remove();
    (_b = this.link) == null ? void 0 : _b.removeEventListener("message", this.lastCallback);
    if (debug87)
      showBalloonMessage("USDZ Exporter disabled: " + this.name);
    (_c = document.getElementById("open-in-ar")) == null ? void 0 : _c.removeEventListener("click", this.onClickedOpenInARElement);
    InternalUSDZRegistry.unregisterExporter(this);
  }
  /**
   * Creates an USDZ file from the current scene or assigned objectToExport and opens it in QuickLook.
   * Use the various public properties of USDZExporter to customize export behaviour.
   * @deprecated use {@link exportAndOpen} instead
   */
  async exportAsync() {
    return this.exportAndOpen();
  }
  /**
   * Creates an USDZ file from the current scene or assigned objectToExport and opens it in QuickLook.
   * @returns a Promise<Blob> containing the USDZ file
   */
  async exportAndOpen() {
    var _a2;
    let name = this.exportFileName ?? ((_a2 = this.objectToExport) == null ? void 0 : _a2.name) ?? this.name;
    name += "-" + getFormattedDate();
    if (!hasProLicense()) {
      if (name !== "")
        name += "-";
      name += "MadeWithNeedle";
    }
    if (!this.link)
      this.link = ensureQuicklookLinkIsCreated(this.context, DeviceUtilities.supportsQuickLookAR());
    if (this.customUsdzFile) {
      if (debug87)
        console.log("Exporting custom usdz", this.customUsdzFile);
      this.openInQuickLook(this.customUsdzFile, name);
      return null;
    }
    if (!this.objectToExport) {
      console.warn("No object to export", this);
      return null;
    }
    const blob = await this.export(this.objectToExport);
    if (!blob) {
      console.error("USDZ generation failed. Please report a bug", this);
      return null;
    }
    if (debug87)
      console.log("USDZ generation done. Downloading as " + name);
    this.openInQuickLook(blob, name);
    return blob;
  }
  /**
   * Creates an USDZ file from the current scene or assigned objectToExport and opens it in QuickLook.
   * @returns a Promise<Blob> containing the USDZ file
   */
  async export(objectToExport) {
    if (!objectToExport) {
      console.warn("No object to export");
      return null;
    }
    const taskForThisObject = this._currentExportTasks.get(objectToExport);
    if (taskForThisObject) {
      return taskForThisObject;
    }
    const task = this.internalExport(objectToExport);
    if (task instanceof Promise) {
      this._currentExportTasks.set(objectToExport, task);
      return task.then((blob) => {
        this._currentExportTasks.delete(objectToExport);
        return blob;
      }).catch((e) => {
        this._currentExportTasks.delete(objectToExport);
        console.error("Error during USDZ export – please report a bug!", e);
        return null;
      });
    }
    return task;
  }
  async internalExport(objectToExport) {
    Progress.start("export-usdz", {
      onProgress: (progress) => {
        this.dispatchEvent(new CustomEvent("export-progress", { detail: { progress } }));
      }
    });
    Progress.report("export-usdz", { message: "Starting export", totalSteps: 40, currentStep: 0 });
    Progress.report("export-usdz", { message: "Load progressive textures", autoStep: 5 });
    Progress.start("export-usdz-textures", "export-usdz");
    const sprites = GameObject.getComponentsInChildren(objectToExport, SpriteRenderer);
    for (const sprite of sprites) {
      if (sprite && sprite.enabled) {
        sprite.updateSprite(true);
      }
    }
    const renderers = GameObject.getComponentsInChildren(objectToExport, Renderer);
    const progressiveLoading = new Array();
    let progressiveTasks = 0;
    for (const rend of renderers) {
      for (const mesh of rend.sharedMeshes) {
        if (mesh) {
          const task = NEEDLE_progressive.assignMeshLOD(mesh, 0);
          if (task instanceof Promise)
            progressiveLoading.push(new Promise((resolve2, reject) => {
              task.then(() => {
                progressiveTasks++;
                Progress.report("export-usdz-textures", { message: "Loaded progressive mesh", currentStep: progressiveTasks, totalSteps: progressiveLoading.length });
                resolve2();
              }).catch((err) => reject(err));
            }));
        }
      }
      for (const mat of rend.sharedMaterials) {
        if (mat) {
          const task = NEEDLE_progressive.assignTextureLOD(mat, 0);
          if (task instanceof Promise)
            progressiveLoading.push(new Promise((resolve2, reject) => {
              task.then(() => {
                progressiveTasks++;
                Progress.report("export-usdz-textures", { message: "Loaded progressive texture", currentStep: progressiveTasks, totalSteps: progressiveLoading.length });
                resolve2();
              }).catch((err) => reject(err));
            }));
        }
      }
    }
    if (debug87)
      showBalloonMessage("Progressive Loading: " + progressiveLoading.length);
    await Promise.all(progressiveLoading);
    if (debug87)
      showBalloonMessage("Progressive Loading: done");
    Progress.end("export-usdz-textures");
    const currentXRState = XRState.Global.Mask;
    XRState.Global.Set(XRStateFlag.AR);
    const exporter = new USDZExporter();
    const animExt = new AnimationExtension(this.quickLookCompatible);
    let physicsExt = void 0;
    const defaultExtensions = [];
    if (this.interactive) {
      defaultExtensions.push(new BehaviorExtension());
      defaultExtensions.push(new AudioExtension());
      if (globalThis["NEEDLE_USE_RAPIER"]) {
        const rigidbodies = GameObject.getComponentsInChildren(objectToExport, Rigidbody);
        if (rigidbodies.length > 0) {
          if (this.physics) {
            physicsExt = new PhysicsExtension();
            defaultExtensions.push(physicsExt);
          } else if (isDevEnvironment()) {
            console.warn("USDZExporter: Physics export is disabled, but there are active Rigidbody components in the scene. They will not be exported.");
          }
        }
      }
      defaultExtensions.push(new TextExtension());
      defaultExtensions.push(new USDZUIExtension());
    }
    const extensions = [animExt, ...defaultExtensions, ...this.extensions];
    const eventArgs = { self: this, exporter, extensions, object: objectToExport };
    Progress.report("export-usdz", "Invoking before-export");
    this.dispatchEvent(new CustomEvent("before-export", { detail: eventArgs }));
    this.applyWebARSessionRoot();
    this._previousTimeScale = this.context.time.timeScale;
    this.context.time.timeScale = 0;
    Progress.report("export-usdz", "auto export animations and audio sources");
    const implicitBehaviors = new Array();
    if (this.autoExportAnimations) {
      implicitBehaviors.push(...registerAnimatorsImplictly(objectToExport, animExt));
    }
    const audioExt = this.extensions.find((ext) => ext.extensionName === "Audio");
    if (audioExt && this.autoExportAudioSources)
      implicitBehaviors.push(...registerAudioSourcesImplictly(objectToExport, audioExt));
    exporter.debug = debug87;
    exporter.pruneUnusedNodes = !debugUsdzPruning;
    const instancedRenderers = InstancingHandler.instance.objs.map((x2) => x2.batchedMesh);
    exporter.keepObject = (object) => {
      let keep = true;
      const renderer = GameObject.getComponent(object, Renderer);
      if (renderer && !renderer.enabled)
        keep = false;
      if (keep && instancedRenderers.includes(object))
        keep = false;
      if (keep && GameObject.getComponentInParent(object, ContactShadows))
        keep = false;
      if (keep && GameObject.getComponentInParent(object, GroundProjectedEnv))
        keep = false;
      if (debug87 && !keep)
        console.log("USDZExporter: Discarding object", object);
      return keep;
    };
    exporter.beforeWritingDocument = () => {
      if (isDevEnvironment() && animExt && physicsExt) {
        const animatedObjects = animExt.animatedRoots;
        for (const object of animatedObjects) {
          const rigidBodySources = GameObject.getComponentsInChildren(object, Rigidbody).filter((c2) => c2.enabled);
          const colliderSources = GameObject.getComponents(object, Collider).filter((c2) => c2.enabled && !c2.isTrigger);
          if (rigidBodySources.length > 0 || colliderSources.length > 0) {
            console.error("An animated object has physics components in its child hierarchy. This can lead to undefined behaviour due to a bug in Apple's QuickLook (FB15925487). Remove the physics components from child objects or verify that you get the expected results.", object);
          }
        }
      }
    };
    const objectsToDisableAtSceneStart = new Array();
    if (this.objectToExport && this.quickLookCompatible && this.interactive) {
      this.objectToExport.traverse((obj) => {
        if (!obj.visible) {
          objectsToDisableAtSceneStart.push(obj);
        }
      });
    }
    const behaviorExt = this.extensions.find((ext) => ext.extensionName === "Behaviour");
    if (this.interactive && behaviorExt && objectsToDisableAtSceneStart.length > 0) {
      behaviorExt.addBehavior(disableObjectsAtStart(objectsToDisableAtSceneStart));
    }
    let exportInvisible = true;
    if (this.quickLookCompatible && !this.interactive)
      exportInvisible = false;
    if (this.anchoringType !== "plane" && this.anchoringType !== "none" && this.anchoringType !== "image" && this.anchoringType !== "face")
      this.anchoringType = "plane";
    if (this.planeAnchoringAlignment !== "horizontal" && this.planeAnchoringAlignment !== "vertical" && this.planeAnchoringAlignment !== "any")
      this.planeAnchoringAlignment = "horizontal";
    Progress.report("export-usdz", "Invoking exporter.parse");
    const arraybuffer = await exporter.parse(this.objectToExport, {
      ar: {
        anchoring: {
          type: this.anchoringType
        },
        planeAnchoring: {
          alignment: this.planeAnchoringAlignment
        }
      },
      extensions,
      quickLookCompatible: this.quickLookCompatible,
      maxTextureSize: this.maxTextureSize,
      exportInvisible
    });
    const blob = new Blob([arraybuffer], { type: "model/vnd.usdz+zip" });
    this.revertWebARSessionRoot();
    this.context.time.timeScale = this._previousTimeScale;
    Progress.report("export-usdz", "Invoking after-export");
    this.dispatchEvent(new CustomEvent("after-export", { detail: eventArgs }));
    for (const go of implicitBehaviors) {
      GameObject.destroy(go);
    }
    XRState.Global.Set(currentXRState);
    Progress.end("export-usdz");
    return blob;
  }
  /**
   * Opens QuickLook on iOS/iPadOS/visionOS with the given content in AR mode.
   * @param content The URL to the .usdz or .reality file or a blob containing an USDZ file.
   * @param name Download filename
   */
  openInQuickLook(content, name) {
    const url = content instanceof Blob ? URL.createObjectURL(content) : content;
    const overlay = this.buildQuicklookOverlay();
    if (debug87)
      console.log("QuickLook Overlay", overlay);
    const callToAction = overlay.callToAction ? encodeURIComponent(overlay.callToAction) : "";
    const checkoutTitle = overlay.checkoutTitle ? encodeURIComponent(overlay.checkoutTitle) : "";
    const checkoutSubtitle = overlay.checkoutSubtitle ? encodeURIComponent(overlay.checkoutSubtitle) : "";
    this.link.href = url + `#callToAction=${callToAction}&checkoutTitle=${checkoutTitle}&checkoutSubtitle=${checkoutSubtitle}&callToActionURL=${overlay.callToActionURL}`;
    if (!this.lastCallback) {
      this.lastCallback = this.quicklookCallback.bind(this);
      this.link.addEventListener("message", this.lastCallback);
    }
    this.link.download = name + ".usdz";
    this.link.click();
  }
  /**
   * Downloads the given blob as a file.
   */
  download(blob, name) {
    _USDZExporter.save(blob, name);
  }
  // Matches GltfExport.save(blob, filename)
  static save(blob, filename) {
    const link = document.createElement("a");
    link.style.display = "none";
    document.body.appendChild(link);
    if (typeof blob === "string")
      link.href = blob;
    else
      link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
    link.remove();
  }
  quicklookCallback(event) {
    if ((event == null ? void 0 : event.data) == "_apple_ar_quicklook_button_tapped") {
      if (debug87)
        showBalloonWarning("Quicklook closed via call to action button");
      var evt = new CustomEvent("quicklook-button-tapped", { detail: this });
      this.dispatchEvent(evt);
      if (!evt.defaultPrevented) {
        const url = new URLSearchParams(this.link.href);
        if (url) {
          const callToActionURL = url.get("callToActionURL");
          if (debug87)
            showBalloonMessage("Quicklook url: " + callToActionURL);
          if (callToActionURL) {
            if (!hasProLicense()) {
              console.warn("Quicklook closed: custom redirects require a Needle Engine Pro license: https://needle.tools/pricing", callToActionURL);
            } else {
              globalThis.open(callToActionURL, "_blank");
            }
          }
        }
      }
    }
  }
  buildQuicklookOverlay() {
    var _a2, _b, _c, _d, _e, _f;
    const obj = {};
    if (this.customBranding)
      Object.assign(obj, this.customBranding);
    if (!hasProLicense()) {
      console.log("Custom Quicklook banner text requires pro license: https://needle.tools/pricing");
      obj.callToAction = "Close";
      obj.checkoutTitle = "🌵 Made with Needle";
      obj.checkoutSubtitle = "_";
    }
    const needsDefaultValues = ((_a2 = obj.callToAction) == null ? void 0 : _a2.length) || ((_b = obj.checkoutTitle) == null ? void 0 : _b.length) || ((_c = obj.checkoutSubtitle) == null ? void 0 : _c.length);
    if (needsDefaultValues) {
      if (!((_d = obj.callToAction) == null ? void 0 : _d.length))
        obj.callToAction = "\0";
      if (!((_e = obj.checkoutTitle) == null ? void 0 : _e.length))
        obj.checkoutTitle = "\0";
      if (!((_f = obj.checkoutSubtitle) == null ? void 0 : _f.length))
        obj.checkoutSubtitle = "\0";
    }
    this.dispatchEvent(new CustomEvent("quicklook-overlay", { detail: obj }));
    return obj;
  }
  getARScaleAndTarget() {
    if (!this.objectToExport)
      return { scale: 1, _invertForward: false, target: this.gameObject, sessionRoot: null };
    const xr = GameObject.findObjectOfType(WebXR);
    let sessionRoot = GameObject.getComponentInParent(this.objectToExport, WebARSessionRoot);
    if (!sessionRoot)
      sessionRoot = GameObject.getComponentInChildren(this.objectToExport, WebARSessionRoot);
    let arScale = 1;
    let _invertForward = false;
    const target = this.objectToExport;
    if (xr) {
      arScale = xr.arScale;
    } else if (sessionRoot) {
      arScale = sessionRoot.arScale;
      _invertForward = sessionRoot.invertForward;
    }
    const scale = 1 / arScale;
    const result = { scale, _invertForward, target, sessionRoot: (sessionRoot == null ? void 0 : sessionRoot.gameObject) ?? null };
    return result;
  }
  applyWebARSessionRoot() {
    if (!this.objectToExport)
      return;
    const { scale, _invertForward, target, sessionRoot } = this.getARScaleAndTarget();
    const sessionRootMatrixWorld = sessionRoot == null ? void 0 : sessionRoot.matrixWorld.clone().invert();
    this._rootSessionRootWasAppliedTo = target;
    this._rootPositionBeforeExport.copy(target.position);
    this._rootRotationBeforeExport.copy(target.quaternion);
    this._rootScaleBeforeExport.copy(target.scale);
    target.scale.multiplyScalar(scale);
    if (_invertForward)
      target.quaternion.multiply(_USDZExporter.invertForwardQuaternion);
    target.updateMatrix();
    target.updateMatrixWorld(true);
    if (sessionRoot && sessionRootMatrixWorld)
      target.matrix.premultiply(sessionRootMatrixWorld);
  }
  revertWebARSessionRoot() {
    if (!this.objectToExport)
      return;
    if (!this._rootSessionRootWasAppliedTo)
      return;
    const target = this._rootSessionRootWasAppliedTo;
    target.position.copy(this._rootPositionBeforeExport);
    target.quaternion.copy(this._rootRotationBeforeExport);
    target.scale.copy(this._rootScaleBeforeExport);
    target.updateMatrix();
    target.updateMatrixWorld(true);
    this._rootSessionRootWasAppliedTo = null;
  }
  createQuicklookButton() {
    const buttoncontainer = WebXRButtonFactory.getOrCreate();
    const button = buttoncontainer.createQuicklookButton();
    if (!button.parentNode)
      this.context.menu.appendChild(button);
    return button;
  }
};
var USDZExporter2 = _USDZExporter;
__publicField(USDZExporter2, "invertForwardMatrix", new Matrix4().makeRotationY(Math.PI));
__publicField(USDZExporter2, "invertForwardQuaternion", new Quaternion().setFromEuler(new Euler(0, Math.PI, 0)));
__decorate52([
  serializable(Object3D)
], USDZExporter2.prototype, "objectToExport", void 0);
__decorate52([
  serializable()
], USDZExporter2.prototype, "autoExportAnimations", void 0);
__decorate52([
  serializable()
], USDZExporter2.prototype, "autoExportAudioSources", void 0);
__decorate52([
  serializable()
], USDZExporter2.prototype, "exportFileName", void 0);
__decorate52([
  serializable(URL)
], USDZExporter2.prototype, "customUsdzFile", void 0);
__decorate52([
  serializable(CustomBranding)
], USDZExporter2.prototype, "customBranding", void 0);
__decorate52([
  serializable()
], USDZExporter2.prototype, "anchoringType", void 0);
__decorate52([
  serializable()
], USDZExporter2.prototype, "maxTextureSize", void 0);
__decorate52([
  serializable()
], USDZExporter2.prototype, "planeAnchoringAlignment", void 0);
__decorate52([
  serializable()
], USDZExporter2.prototype, "interactive", void 0);
__decorate52([
  serializable()
], USDZExporter2.prototype, "physics", void 0);
__decorate52([
  serializable()
], USDZExporter2.prototype, "allowCreateQuicklookButton", void 0);
__decorate52([
  serializable()
], USDZExporter2.prototype, "quickLookCompatible", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/Interactable.js
var UsageMarker = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "isUsed", true);
    __publicField(this, "usedBy", null);
  }
};
var Interactable = class extends Component2 {
};

// node_modules/@needle-tools/engine/lib/engine-components/DeleteBox.js
var debug88 = getParam("debugdeletable");
var _DeleteBox = class extends BoxHelperComponent {
  onEnable() {
    _DeleteBox._instances.push(this);
  }
  onDisable() {
    const idx = _DeleteBox._instances.indexOf(this);
    if (idx >= 0)
      _DeleteBox._instances.splice(idx, 1);
  }
};
var DeleteBox = _DeleteBox;
__publicField(DeleteBox, "_instances", []);
var Deletable = class extends Component2 {
  update() {
    for (const box2 of DeleteBox._instances) {
      const obj = this.gameObject;
      const res = box2.isInBox(obj);
      if (res === true) {
        const marker = GameObject.getComponentInParent(this.gameObject, UsageMarker);
        if (!marker) {
          if (debug88) {
            try {
              if (box2["box"]) {
                const deleteBoxArea = box2["box"];
                const deletedObjectArea = BoxHelperComponent["testBox"];
                Gizmos.DrawWireBox3(deleteBoxArea, 16711680, 5);
                Gizmos.DrawWireBox3(deletedObjectArea, 255, 5);
                console.log("DeleteBox: Destroying", this.gameObject, { deleteBoxArea, deletedObjectArea });
              } else {
                console.log("DeleteBox: Destroying", this.gameObject);
              }
            } catch (_e) {
            }
          }
          syncDestroy(this.gameObject, this.context.connection);
        } else if (debug88)
          console.warn("DeleteBox: Not deleting object with usage marker", this.guid, marker);
      }
    }
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/postprocessing/Effects/DepthOfField.js
var __decorate53 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DepthOfFieldMode;
(function(DepthOfFieldMode2) {
  DepthOfFieldMode2[DepthOfFieldMode2["Off"] = 0] = "Off";
  DepthOfFieldMode2[DepthOfFieldMode2["Gaussian"] = 1] = "Gaussian";
  DepthOfFieldMode2[DepthOfFieldMode2["Bokeh"] = 2] = "Bokeh";
})(DepthOfFieldMode || (DepthOfFieldMode = {}));
var debug89 = getParam("debugpost");
var DepthOfField = class extends PostProcessingEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "mode");
    __publicField(this, "focusDistance", new VolumeParameter(1));
    __publicField(this, "focalLength", new VolumeParameter(0.2));
    __publicField(this, "aperture", new VolumeParameter(20));
    __publicField(this, "gaussianMaxRadius", new VolumeParameter());
    __publicField(this, "resolutionScale", new VolumeParameter(1 * 1 / window.devicePixelRatio));
    __publicField(this, "bokehScale", new VolumeParameter());
  }
  get typeName() {
    return "DepthOfField";
  }
  init() {
    this.focalLength.valueProcessor = (v4) => {
      const t2 = v4 / 300;
      const max = 2;
      return Mathf.lerp(max, 0.01, t2);
    };
    const maxBokehScale = 20;
    this.aperture.valueProcessor = (v4) => {
      const t2 = 1 - v4 / 32;
      return Mathf.lerp(1, maxBokehScale, t2);
    };
  }
  onCreateEffect() {
    if (this.mode === DepthOfFieldMode.Off) {
      if (debug89)
        console.warn("DepthOfField: Mode is set to Off");
      return void 0;
    }
    const dof = new DepthOfFieldEffect(this.context.mainCamera, {
      worldFocusRange: 0.2,
      focalLength: 1,
      bokehScale: 20,
      resolutionScale: this.resolutionScale.value
    });
    this.focusDistance.onValueChanged = (v4) => {
      dof.cocMaterial.worldFocusDistance = v4;
    };
    this.focalLength.onValueChanged = (v4) => dof.cocMaterial.worldFocusRange = v4;
    this.aperture.onValueChanged = (v4) => dof.bokehScale = v4;
    if (this.resolutionScale)
      this.resolutionScale.onValueChanged = (v4) => dof.resolution.scale = v4;
    return [dof];
  }
  unapply() {
  }
};
__decorate53([
  serializable()
], DepthOfField.prototype, "mode", void 0);
__decorate53([
  serializable(VolumeParameter)
], DepthOfField.prototype, "focusDistance", void 0);
__decorate53([
  serializable(VolumeParameter)
], DepthOfField.prototype, "focalLength", void 0);
__decorate53([
  serializable(VolumeParameter)
], DepthOfField.prototype, "aperture", void 0);
__decorate53([
  serializable(VolumeParameter)
], DepthOfField.prototype, "gaussianMaxRadius", void 0);
__decorate53([
  serializable(VolumeParameter)
], DepthOfField.prototype, "resolutionScale", void 0);
__decorate53([
  serializable(VolumeParameter)
], DepthOfField.prototype, "bokehScale", void 0);
registerCustomEffectType("DepthOfField", DepthOfField);

// node_modules/@needle-tools/engine/lib/engine-components/DeviceFlag.js
var __decorate54 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DeviceType;
(function(DeviceType2) {
  DeviceType2[DeviceType2["Never"] = 0] = "Never";
  DeviceType2[DeviceType2["Desktop"] = 1] = "Desktop";
  DeviceType2[DeviceType2["Mobile"] = 2] = "Mobile";
})(DeviceType || (DeviceType = {}));
var DeviceFlag = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "visibleOn");
  }
  onEnable() {
    this.apply();
  }
  apply() {
    if (!this.test()) {
      GameObject.setActive(this.gameObject, false);
    }
  }
  test() {
    if (this.visibleOn < 0)
      return true;
    if (DeviceUtilities.isMobileDevice()) {
      return (this.visibleOn & DeviceType.Mobile) !== 0;
    }
    const allowDesktop = (this.visibleOn & DeviceType.Desktop) !== 0;
    return allowDesktop;
  }
};
__decorate54([
  serializable()
], DeviceFlag.prototype, "visibleOn", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/export/usdz/extensions/DocumentExtension.js
var DocumentExtension = class {
  get extensionName() {
    return "DocumentExtension";
  }
  onAfterBuildDocument(_context) {
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/DragControls.js
var __decorate55 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug90 = getParam("debugdrag");
var dragControlsBuffer = [];
var DragMode;
(function(DragMode2) {
  DragMode2[DragMode2["XZPlane"] = 0] = "XZPlane";
  DragMode2[DragMode2["Attached"] = 1] = "Attached";
  DragMode2[DragMode2["HitNormal"] = 2] = "HitNormal";
  DragMode2[DragMode2["DynamicViewAngle"] = 3] = "DynamicViewAngle";
  DragMode2[DragMode2["SnapToSurfaces"] = 4] = "SnapToSurfaces";
  DragMode2[DragMode2["None"] = 5] = "None";
})(DragMode || (DragMode = {}));
var _DragControls = class extends Component2 {
  constructor() {
    super(...arguments);
    // dragPlane (floor, object, view)
    // snap to surface (snap orientation?)
    // two-handed drag (scale, rotate, move)
    // keep upright (no tilt)
    /** How and where the object is dragged along. */
    __publicField(this, "dragMode", DragMode.DynamicViewAngle);
    /** Snap dragged objects to a XYZ grid – 0 means: no snapping. */
    __publicField(this, "snapGridResolution", 0);
    /** Keep the original rotation of the dragged object. */
    __publicField(this, "keepRotation", true);
    /** How and where the object is dragged along while dragging in XR. */
    __publicField(this, "xrDragMode", DragMode.Attached);
    /** Keep the original rotation of the dragged object while dragging in XR. */
    __publicField(this, "xrKeepRotation", false);
    /** Accelerate dragging objects closer / further away when in XR */
    __publicField(this, "xrDistanceDragFactor", 1);
    /** When enabled, draws a line from the dragged object downwards to the next raycast hit. */
    __publicField(this, "showGizmo", false);
    __publicField(this, "_rigidbody", null);
    // future:
    // constraints?
    /** The object to be dragged – we pass this to handlers when they are created */
    __publicField(this, "_targetObject", null);
    __publicField(this, "_dragHelper", null);
    __publicField(this, "_draggingRigidbodies", []);
    __publicField(this, "_potentialDragStartEvt", null);
    __publicField(this, "_dragHandlers", /* @__PURE__ */ new Map());
    __publicField(this, "_totalMovement", new Vector32());
    /** A marker is attached to components that are currently interacted with, to e.g. prevent them from being deleted. */
    __publicField(this, "_marker", null);
    __publicField(this, "_isDragging", false);
    __publicField(this, "_didDrag", false);
  }
  /**
   * @returns True if any DragControls component is currently active
   */
  static get HasAnySelected() {
    return this._active > 0;
  }
  /** @returns a list of DragControl components that are currently active */
  static get CurrentlySelected() {
    dragControlsBuffer.length = 0;
    for (const dc of this._instances) {
      if (dc._isDragging) {
        dragControlsBuffer.push(dc);
      }
    }
    return dragControlsBuffer;
  }
  /** The currently dragged object (if any) */
  get draggedObject() {
    return this._targetObject;
  }
  /**
   * Use to update the object that is being dragged by the DragControls
   */
  setTargetObject(obj) {
    var _a2, _b;
    this._targetObject = obj;
    for (const handler of this._dragHandlers.values()) {
      handler.setTargetObject(obj);
    }
    const wasKinematicKey = "_rigidbody-was-kinematic";
    if (((_a2 = this._rigidbody) == null ? void 0 : _a2[wasKinematicKey]) === false) {
      this._rigidbody.isKinematic = false;
      this._rigidbody[wasKinematicKey] = void 0;
    }
    this._rigidbody = null;
    if (obj) {
      this._rigidbody = GameObject.getComponentInChildren(obj, Rigidbody);
      if (((_b = this._rigidbody) == null ? void 0 : _b.isKinematic) === false) {
        this._rigidbody.isKinematic = true;
        this._rigidbody[wasKinematicKey] = false;
      }
    }
  }
  /** @internal */
  awake() {
    this._potentialDragStartEvt = null;
    this._dragHandlers = /* @__PURE__ */ new Map();
    this._totalMovement = new Vector32();
    this._marker = null;
    this._isDragging = false;
    this._didDrag = false;
    this._dragHelper = null;
    this._draggingRigidbodies = [];
  }
  /** @internal */
  start() {
    if (!this.gameObject.getComponentInParent(ObjectRaycaster))
      this.gameObject.addComponent(ObjectRaycaster);
  }
  /** @internal */
  onEnable() {
    _DragControls._instances.push(this);
  }
  /** @internal */
  onDisable() {
    _DragControls._instances = _DragControls._instances.filter((i) => i !== this);
  }
  allowEdit(_obj = null) {
    return this.context.connection.allowEditing;
  }
  /** @internal */
  onPointerEnter(evt) {
    if (!this.allowEdit(this.gameObject))
      return;
    if (evt.mode !== "screen")
      return;
    const isSpatialInput = evt.event.mode === "tracked-pointer" || evt.event.mode === "transient-pointer";
    const dragMode = isSpatialInput ? this.xrDragMode : this.dragMode;
    if (dragMode === DragMode.None)
      return;
    const dc = GameObject.getComponentInParent(evt.object, _DragControls);
    if (!dc || dc !== this)
      return;
    _DragControls.lastHovered = evt.object;
    this.context.domElement.style.cursor = "pointer";
  }
  /** @internal */
  onPointerMove(args) {
    if (this._isDragging || this._potentialDragStartEvt !== null)
      args.use();
  }
  /** @internal */
  onPointerExit(evt) {
    if (!this.allowEdit(this.gameObject))
      return;
    if (evt.mode !== "screen")
      return;
    if (_DragControls.lastHovered !== evt.object)
      return;
    this.context.domElement.style.cursor = "auto";
  }
  /** @internal */
  onPointerDown(args) {
    if (!this.allowEdit(this.gameObject))
      return;
    if (args.used)
      return;
    const isSpatialInput = args.mode === "tracked-pointer" || args.mode === "transient-pointer";
    const dragMode = isSpatialInput ? this.xrDragMode : this.dragMode;
    if (dragMode === DragMode.None)
      return;
    _DragControls.lastHovered = args.object;
    if (args.button === 0) {
      if (this._dragHandlers.size === 0) {
        this._didDrag = false;
        this._totalMovement.set(0, 0, 0);
        this._potentialDragStartEvt = args;
      }
      if (!this._targetObject) {
        this.setTargetObject(this.gameObject);
      }
      _DragControls._active += 1;
      const newDragHandler = new DragPointerHandler(this, this._targetObject);
      this._dragHandlers.set(args.event.space, newDragHandler);
      newDragHandler.onDragStart(args);
      if (this._dragHandlers.size === 2) {
        const iterator = this._dragHandlers.values();
        const a = iterator.next().value;
        const b = iterator.next().value;
        const mtHandler = new MultiTouchDragHandler(this, this._targetObject, a, b);
        this._dragHandlers.set(this.gameObject, mtHandler);
        mtHandler.onDragStart(args);
      }
      args.use();
    }
  }
  /** @internal */
  onPointerUp(args) {
    if (debug90)
      Gizmos.DrawLabel(args.point ?? this.gameObject.worldPosition, "POINTERUP:" + args.pointerId + ", " + args.button, 0.03, 3);
    if (!this.allowEdit(this.gameObject))
      return;
    if (args.button !== 0)
      return;
    this._potentialDragStartEvt = null;
    const handler = this._dragHandlers.get(args.event.space);
    const mtHandler = this._dragHandlers.get(this.gameObject);
    if (mtHandler && (mtHandler.handlerA === handler || mtHandler.handlerB === handler)) {
      this._dragHandlers.delete(this.gameObject);
      mtHandler.onDragEnd(args);
    }
    if (handler) {
      if (_DragControls._active > 0)
        _DragControls._active -= 1;
      this.setTargetObject(null);
      if (handler.onDragEnd)
        handler.onDragEnd(args);
      this._dragHandlers.delete(args.event.space);
      if (this._dragHandlers.size === 0) {
        this.onLastDragEnd(args);
      }
      args.use();
    }
  }
  /** @internal */
  update() {
    for (const handler of this._dragHandlers.values()) {
      if (handler.collectMovementInfo)
        handler.collectMovementInfo();
      if (handler.getTotalMovement)
        this._totalMovement.add(handler.getTotalMovement());
    }
    if (this._potentialDragStartEvt) {
      if (!this._didDrag) {
        if (this._totalMovement.length() > 3e-4)
          this._didDrag = true;
        else
          return;
      }
      const args = this._potentialDragStartEvt;
      this._potentialDragStartEvt = null;
      this.onFirstDragStart(args);
    }
    for (const handler of this._dragHandlers.values())
      if (handler.onDragUpdate)
        handler.onDragUpdate(this._dragHandlers.size);
    if (this._dragHelper && this._dragHelper.hasSelected)
      this.onAnyDragUpdate();
  }
  /** Called when the first pointer starts dragging on this object. Not called for subsequent pointers on the same object. */
  onFirstDragStart(evt) {
    if (!evt || !evt.object)
      return;
    const dc = GameObject.getComponentInParent(evt.object, _DragControls);
    if (!dc || dc !== this && dc._isDragging)
      return;
    const object = this._targetObject || this.gameObject;
    if (!object)
      return;
    this._isDragging = true;
    const sync = GameObject.getComponentInChildren(object, SyncedTransform);
    if (debug90)
      console.log("DRAG START", sync, object);
    if (sync) {
      sync.fastMode = true;
      sync == null ? void 0 : sync.requestOwnership();
    }
    this._marker = GameObject.addComponent(object, UsageMarker);
    this._draggingRigidbodies.length = 0;
    const rbs = GameObject.getComponentsInChildren(object, Rigidbody);
    if (rbs)
      this._draggingRigidbodies.push(...rbs);
  }
  /** Called each frame as long as any pointer is dragging this object. */
  onAnyDragUpdate() {
    if (!this._dragHelper)
      return;
    this._dragHelper.showGizmo = this.showGizmo;
    this._dragHelper.onUpdate(this.context);
    for (const rb of this._draggingRigidbodies) {
      rb.wakeUp();
      rb.resetVelocities();
      rb.resetForcesAndTorques();
    }
    const object = this._targetObject || this.gameObject;
    InstancingUtil.markDirty(object);
  }
  /** Called when the last pointer has been removed from this object. */
  onLastDragEnd(evt) {
    if (!this || !this._isDragging)
      return;
    this._isDragging = false;
    for (const rb of this._draggingRigidbodies) {
      rb.setVelocity(rb.smoothedVelocity);
    }
    this._draggingRigidbodies.length = 0;
    this._targetObject = null;
    if (evt == null ? void 0 : evt.object) {
      const sync = GameObject.getComponentInChildren(evt.object, SyncedTransform);
      if (sync) {
        sync.fastMode = false;
      }
    }
    if (this._marker)
      this._marker.destroy();
    if (!this._dragHelper)
      return;
    const selected = this._dragHelper.selected;
    if (debug90)
      console.log("DRAG END", selected, selected == null ? void 0 : selected.visible);
    this._dragHelper.setSelected(null, this.context);
  }
};
var DragControls = _DragControls;
__publicField(DragControls, "_active", 0);
/** Currently active and enabled DragControls components */
__publicField(DragControls, "_instances", []);
__publicField(DragControls, "lastHovered");
__decorate55([
  serializable()
], DragControls.prototype, "dragMode", void 0);
__decorate55([
  serializable()
], DragControls.prototype, "snapGridResolution", void 0);
__decorate55([
  serializable()
], DragControls.prototype, "keepRotation", void 0);
__decorate55([
  serializable()
], DragControls.prototype, "xrDragMode", void 0);
__decorate55([
  serializable()
], DragControls.prototype, "xrKeepRotation", void 0);
__decorate55([
  serializable()
], DragControls.prototype, "xrDistanceDragFactor", void 0);
__decorate55([
  serializable()
], DragControls.prototype, "showGizmo", void 0);
var MultiTouchDragHandler = class {
  constructor(dragControls, gameObject, pointerA, pointerB) {
    __publicField(this, "handlerA");
    __publicField(this, "handlerB");
    __publicField(this, "context");
    __publicField(this, "settings");
    __publicField(this, "gameObject");
    __publicField(this, "_handlerAAttachmentPoint", new Vector32());
    __publicField(this, "_handlerBAttachmentPoint", new Vector32());
    __publicField(this, "_followObject");
    __publicField(this, "_manipulatorObject");
    __publicField(this, "_deviceMode");
    __publicField(this, "_followObjectStartWorldQuaternion", new Quaternion());
    __publicField(this, "_manipulatorPosOffset", new Vector32());
    __publicField(this, "_manipulatorRotOffset", new Quaternion());
    __publicField(this, "_manipulatorScaleOffset", new Vector32());
    __publicField(this, "_tempVec1", new Vector32());
    __publicField(this, "_tempVec2", new Vector32());
    __publicField(this, "_tempVec3", new Vector32());
    __publicField(this, "tempLookMatrix", new Matrix4());
    __publicField(this, "_initialScale", new Vector32());
    __publicField(this, "_initialDistance", 0);
    var _a2, _b;
    this.context = dragControls.context;
    this.settings = dragControls;
    this.gameObject = gameObject;
    this.handlerA = pointerA;
    this.handlerB = pointerB;
    this._followObject = new Object3D();
    this._manipulatorObject = new Object3D();
    this.context.scene.add(this._manipulatorObject);
    const rig = (_b = (_a2 = NeedleXRSession.active) == null ? void 0 : _a2.rig) == null ? void 0 : _b.gameObject;
    if (!this.handlerA || !this.handlerB || !this.handlerA.hitPointInLocalSpace || !this.handlerB.hitPointInLocalSpace) {
      console.error("Invalid: MultiTouchDragHandler needs two valid DragPointerHandlers with hitPointInLocalSpace set.");
      return;
    }
    this._tempVec1.copy(this.handlerA.hitPointInLocalSpace);
    this._tempVec2.copy(this.handlerB.hitPointInLocalSpace);
    this.gameObject.localToWorld(this._tempVec1);
    this.gameObject.localToWorld(this._tempVec2);
    if (rig) {
      rig.worldToLocal(this._tempVec1);
      rig.worldToLocal(this._tempVec2);
    }
    this._initialDistance = this._tempVec1.distanceTo(this._tempVec2);
    if (this._initialDistance < 0.02) {
      if (debug90) {
        console.log("Finding alternative drag attachment points since initial distance is too low: " + this._initialDistance.toFixed(2));
      }
      this.handlerA.followObject.parent.getWorldPosition(this._tempVec1);
      this.handlerB.followObject.parent.getWorldPosition(this._tempVec2);
      this._handlerAAttachmentPoint.copy(this._tempVec1);
      this._handlerBAttachmentPoint.copy(this._tempVec2);
      this.gameObject.worldToLocal(this._handlerAAttachmentPoint);
      this.gameObject.worldToLocal(this._handlerBAttachmentPoint);
      this._initialDistance = this._tempVec1.distanceTo(this._tempVec2);
      if (this._initialDistance < 1e-3) {
        console.warn("Not supported right now – controller drag points for multitouch are too close!");
        this._initialDistance = 1;
      }
    } else {
      this._handlerAAttachmentPoint.copy(this.handlerA.hitPointInLocalSpace);
      this._handlerBAttachmentPoint.copy(this.handlerB.hitPointInLocalSpace);
    }
    this._tempVec3.lerpVectors(this._tempVec1, this._tempVec2, 0.5);
    this._initialScale.copy(gameObject.scale);
    if (debug90) {
      this._followObject.add(new AxesHelper(2));
      this._manipulatorObject.add(new AxesHelper(5));
      const formatVec = (v4) => `${v4.x.toFixed(2)}, ${v4.y.toFixed(2)}, ${v4.z.toFixed(2)}`;
      Gizmos.DrawLine(this._tempVec1, this._tempVec2, 65535, 0, false);
      Gizmos.DrawLabel(this._tempVec3, "A:B " + this._initialDistance.toFixed(2) + "\n" + formatVec(this._tempVec1) + "\n" + formatVec(this._tempVec2), 0.03, 5);
    }
  }
  onDragStart(_args) {
    this.gameObject.add(this._followObject);
    this._followObject.matrixAutoUpdate = false;
    this._followObject.matrix.identity();
    this._deviceMode = _args.mode;
    this._followObjectStartWorldQuaternion.copy(this._followObject.worldQuaternion);
    this.alignManipulator();
    this._manipulatorObject.attach(this._followObject);
    this._manipulatorPosOffset.copy(this._followObject.position);
    this._manipulatorRotOffset.copy(this._followObject.quaternion);
    this._manipulatorScaleOffset.copy(this._followObject.scale);
  }
  onDragEnd(_args) {
    if (!this.handlerA || !this.handlerB) {
      console.error("onDragEnd called on MultiTouchDragHandler without valid handlers. This is likely a bug.");
      return;
    }
    this.handlerA.recenter();
    this.handlerB.recenter();
    this._manipulatorObject.removeFromParent();
    this._followObject.removeFromParent();
    this._manipulatorObject.destroy();
    this._followObject.destroy();
  }
  alignManipulator() {
    if (!this.handlerA || !this.handlerB) {
      console.error("alignManipulator called on MultiTouchDragHandler without valid handlers. This is likely a bug.", this);
      return;
    }
    if (!this.handlerA.followObject || !this.handlerB.followObject) {
      console.error("alignManipulator called on MultiTouchDragHandler without valid follow objects. This is likely a bug.", this.handlerA, this.handlerB);
      return;
    }
    this._tempVec1.copy(this._handlerAAttachmentPoint);
    this._tempVec2.copy(this._handlerBAttachmentPoint);
    this.handlerA.followObject.localToWorld(this._tempVec1);
    this.handlerB.followObject.localToWorld(this._tempVec2);
    this._tempVec3.lerpVectors(this._tempVec1, this._tempVec2, 0.5);
    this._manipulatorObject.position.copy(this._tempVec3);
    const camera = this.context.mainCamera;
    this.tempLookMatrix.lookAt(this._tempVec3, this._tempVec2, camera.worldUp);
    this._manipulatorObject.quaternion.setFromRotationMatrix(this.tempLookMatrix);
    const dist = this._tempVec1.distanceTo(this._tempVec2);
    this._manipulatorObject.scale.copy(this._initialScale).multiplyScalar(dist / this._initialDistance);
    this._manipulatorObject.updateMatrix();
    this._manipulatorObject.updateMatrixWorld(true);
    if (debug90) {
      Gizmos.DrawLabel(this._tempVec3.clone().add(new Vector32(0, 0.2, 0)), "A:B " + dist.toFixed(2), 0.03);
      Gizmos.DrawLine(this._tempVec1, this._tempVec2, 65280, 0, false);
    }
  }
  onDragUpdate() {
    this.alignManipulator();
    const lerpStrength = 30;
    const lerpFactor = 1;
    this._followObject.position.copy(this._manipulatorPosOffset);
    this._followObject.quaternion.copy(this._manipulatorRotOffset);
    this._followObject.scale.copy(this._manipulatorScaleOffset);
    const draggedObject = this.gameObject;
    const targetObject = this._followObject;
    targetObject.updateMatrix();
    targetObject.updateMatrixWorld(true);
    const isSpatialInput = this._deviceMode === "tracked-pointer" || this._deviceMode === "transient-pointer";
    const keepRotation = isSpatialInput ? this.settings.xrKeepRotation : this.settings.keepRotation;
    if (this.settings.snapGridResolution > 0) {
      const wp2 = this._followObject.worldPosition;
      const snap = this.settings.snapGridResolution;
      wp2.x = Math.round(wp2.x / snap) * snap;
      wp2.y = Math.round(wp2.y / snap) * snap;
      wp2.z = Math.round(wp2.z / snap) * snap;
      this._followObject.worldPosition = wp2;
      this._followObject.updateMatrix();
    }
    if (keepRotation) {
      this._followObject.worldQuaternion = this._followObjectStartWorldQuaternion;
      this._followObject.updateMatrix();
    }
    const t2 = Mathf.clamp01(this.context.time.deltaTime * lerpStrength * lerpFactor);
    const wp = draggedObject.worldPosition;
    wp.lerp(targetObject.worldPosition, t2);
    draggedObject.worldPosition = wp;
    const rot = draggedObject.worldQuaternion;
    rot.slerp(targetObject.worldQuaternion, t2);
    draggedObject.worldQuaternion = rot;
    const scl = draggedObject.worldScale;
    scl.lerp(targetObject.worldScale, t2);
    draggedObject.worldScale = scl;
  }
  setTargetObject(obj) {
    this.gameObject = obj;
  }
};
var DragPointerHandler = class {
  constructor(dragControls, gameObject) {
    __publicField(this, "context");
    __publicField(this, "gameObject");
    __publicField(this, "settings");
    __publicField(this, "_lastRig");
    /** This object is placed at the pivot of the dragged object, and parented to the control space. */
    __publicField(this, "_followObject");
    __publicField(this, "_totalMovement", new Vector32());
    /** Motion along the pointer ray. On screens this doesn't change. In XR it can be used to determine how much
     * effort someone is putting into moving an object closer or further away. */
    __publicField(this, "_totalMovementAlongRayDirection", 0);
    /** Distance between _followObject and its parent at grab start, in local space */
    __publicField(this, "_grabStartDistance", 0);
    __publicField(this, "_deviceMode");
    __publicField(this, "_followObjectStartPosition", new Vector32());
    __publicField(this, "_followObjectStartQuaternion", new Quaternion());
    __publicField(this, "_followObjectStartWorldQuaternion", new Quaternion());
    __publicField(this, "_lastDragPosRigSpace");
    __publicField(this, "_tempVec", new Vector32());
    __publicField(this, "_tempMat", new Matrix4());
    __publicField(this, "_hitPointInLocalSpace", new Vector32());
    __publicField(this, "_hitNormalInLocalSpace", new Vector32());
    __publicField(this, "_bottomCenter", new Vector32());
    __publicField(this, "_backCenter", new Vector32());
    __publicField(this, "_backBottomCenter", new Vector32());
    __publicField(this, "_bounds", new Box3());
    __publicField(this, "_dragPlane", new Plane(new Vector32(0, 1, 0)));
    __publicField(this, "_draggedOverObject", null);
    __publicField(this, "_draggedOverObjectLastSetUp", null);
    __publicField(this, "_draggedOverObjectLastNormal", new Vector32());
    __publicField(this, "_draggedOverObjectDuration", 0);
    __publicField(this, "_hasLastSurfaceHitPoint", false);
    __publicField(this, "_lastSurfaceHitPoint", new Vector32());
    this.settings = dragControls;
    this.context = dragControls.context;
    this.gameObject = gameObject;
    this._followObject = new Object3D();
  }
  /** Absolute movement of the pointer. Used for determining if a motion/drag is happening.
   * This is in world units, so very small for screens (near-plane space change) */
  getTotalMovement() {
    return this._totalMovement;
  }
  get followObject() {
    return this._followObject;
  }
  get hitPointInLocalSpace() {
    return this._hitPointInLocalSpace;
  }
  /** Allows overriding which object is dragged while a drag is already ongoing. Used for example by Duplicatable */
  setTargetObject(obj) {
    this.gameObject = obj;
  }
  recenter() {
    var _a2, _b;
    if (!this._followObject.parent) {
      console.warn("Error: space follow object doesn't have parent but recenter() is called. This is likely a bug");
      return;
    }
    if (!this.gameObject) {
      console.warn("Error: space follow object doesn't have a gameObject");
      return;
    }
    const p = this._followObject.parent;
    this.gameObject.add(this._followObject);
    this._followObject.matrixAutoUpdate = false;
    this._followObject.position.set(0, 0, 0);
    this._followObject.quaternion.set(0, 0, 0, 1);
    this._followObject.scale.set(1, 1, 1);
    this._followObject.updateMatrix();
    this._followObject.updateMatrixWorld(true);
    p.attach(this._followObject);
    this._followObjectStartPosition.copy(this._followObject.position);
    this._followObjectStartQuaternion.copy(this._followObject.quaternion);
    this._followObjectStartWorldQuaternion.copy(this._followObject.worldQuaternion);
    this._followObject.updateMatrix();
    this._followObject.updateMatrixWorld(true);
    const hitPointWP = this._hitPointInLocalSpace.clone();
    this.gameObject.localToWorld(hitPointWP);
    this._grabStartDistance = hitPointWP.distanceTo(p.worldPosition);
    const rig = (_b = (_a2 = NeedleXRSession.active) == null ? void 0 : _a2.rig) == null ? void 0 : _b.gameObject;
    const rigScale = (rig == null ? void 0 : rig.worldScale.x) || 1;
    this._grabStartDistance /= rigScale;
    this._totalMovementAlongRayDirection = 0;
    this._lastDragPosRigSpace = void 0;
    if (debug90) {
      Gizmos.DrawLine(hitPointWP, p.worldPosition, 65280, 0.5, false);
      Gizmos.DrawLabel(p.worldPosition.add(new Vector32(0, 0.1, 0)), this._grabStartDistance.toFixed(2), 0.03, 0.5);
    }
  }
  onDragStart(args) {
    if (!this.gameObject) {
      console.warn("Error: space follow object doesn't have a gameObject");
      return;
    }
    args.event.space.add(this._followObject);
    this._lastDragPosRigSpace = void 0;
    if (args.point && args.normal) {
      this._hitPointInLocalSpace.copy(args.point);
      this.gameObject.worldToLocal(this._hitPointInLocalSpace);
      this._hitNormalInLocalSpace.copy(args.normal);
    } else if (args) {
      const controller = args.event.space;
      const controllerWp = controller.worldPosition;
      this.gameObject.worldToLocal(controllerWp);
      this._hitPointInLocalSpace.copy(controllerWp);
      const controllerUp = controller.worldUp;
      this._tempMat.copy(this.gameObject.matrixWorld).invert();
      controllerUp.transformDirection(this._tempMat);
      this._hitNormalInLocalSpace.copy(controllerUp);
    }
    this.recenter();
    this._totalMovement.set(0, 0, 0);
    this._deviceMode = args.mode;
    const dragSource = this._followObject.parent;
    const rayDirection = dragSource.worldForward;
    const isSpatialInput = this._deviceMode === "tracked-pointer" || this._deviceMode === "transient-pointer";
    const dragMode = isSpatialInput ? this.settings.xrDragMode : this.settings.dragMode;
    const hitWP = this._hitPointInLocalSpace.clone();
    this.gameObject.localToWorld(hitWP);
    switch (dragMode) {
      case DragMode.XZPlane:
        const up2 = new Vector32(0, 1, 0);
        if (this.gameObject.parent) {
          up2.transformDirection(this.gameObject.parent.matrixWorld.clone().invert());
        }
        this._dragPlane.setFromNormalAndCoplanarPoint(up2, hitWP);
        break;
      case DragMode.HitNormal:
        const hitNormal = this._hitNormalInLocalSpace.clone();
        hitNormal.transformDirection(this.gameObject.matrixWorld);
        this._dragPlane.setFromNormalAndCoplanarPoint(hitNormal, hitWP);
        break;
      case DragMode.Attached:
        this._dragPlane.setFromNormalAndCoplanarPoint(rayDirection, hitWP);
        break;
      case DragMode.DynamicViewAngle:
        this.setPlaneViewAligned(hitWP, true);
        break;
      case DragMode.SnapToSurfaces:
        this.setPlaneViewAligned(hitWP, false);
        break;
      case DragMode.None:
        break;
    }
    const p = this.gameObject.parent;
    const localP = this.gameObject.position.clone();
    const localQ = this.gameObject.quaternion.clone();
    const localS = this.gameObject.scale.clone();
    const matrixWorld = this.gameObject.matrixWorld.clone();
    if (p)
      p.remove(this.gameObject);
    this.gameObject.position.set(0, 0, 0);
    this.gameObject.quaternion.set(0, 0, 0, 1);
    this.gameObject.scale.set(1, 1, 1);
    const bbox = getBoundingBox([this.gameObject]);
    bbox.expandByPoint(this.gameObject.worldPosition);
    const bboxCenter = new Vector32();
    bbox.getCenter(bboxCenter);
    const bboxSize = new Vector32();
    bbox.getSize(bboxSize);
    this._bottomCenter.copy(bboxCenter.clone().add(new Vector32(0, -bboxSize.y / 2, 0)));
    this._backCenter.copy(bboxCenter.clone().add(new Vector32(0, 0, bboxSize.z / 2)));
    this._backBottomCenter.copy(bboxCenter.clone().add(new Vector32(0, -bboxSize.y / 2, bboxSize.z / 2)));
    this._bounds.copy(bbox);
    if (p)
      p.add(this.gameObject);
    this.gameObject.position.copy(localP);
    this.gameObject.quaternion.copy(localQ);
    this.gameObject.scale.copy(localS);
    this.gameObject.matrixWorld.copy(matrixWorld);
    this._draggedOverObject = null;
    this._draggedOverObjectLastSetUp = null;
    this._draggedOverObjectLastNormal.set(0, 1, 0);
    this._draggedOverObjectDuration = 0;
  }
  collectMovementInfo() {
    var _a2, _b;
    if (!this._followObject.parent)
      return;
    const dragSource = this._followObject.parent;
    this._followObject.updateMatrix();
    const dragPosRigSpace = dragSource.worldPosition;
    const rig = (_b = (_a2 = NeedleXRSession.active) == null ? void 0 : _a2.rig) == null ? void 0 : _b.gameObject;
    if (rig)
      rig.worldToLocal(dragPosRigSpace);
    if (this._lastDragPosRigSpace === void 0 || rig != this._lastRig) {
      this._lastDragPosRigSpace = dragPosRigSpace.clone();
      this._lastRig = rig;
    }
    this._tempVec.copy(dragPosRigSpace).sub(this._lastDragPosRigSpace);
    const rayDirectionRigSpace = dragSource.worldForward;
    if (rig) {
      this._tempMat.copy(rig.matrixWorld).invert();
      rayDirectionRigSpace.transformDirection(this._tempMat);
    }
    this._totalMovementAlongRayDirection += rayDirectionRigSpace.dot(this._tempVec);
    this._tempVec.x = Math.abs(this._tempVec.x);
    this._tempVec.y = Math.abs(this._tempVec.y);
    this._tempVec.z = Math.abs(this._tempVec.z);
    this._totalMovement.add(this._tempVec);
    this._lastDragPosRigSpace.copy(dragPosRigSpace);
    if (debug90) {
      let wp = dragPosRigSpace;
      if (rig) {
        wp = wp.clone();
        wp.transformDirection(rig.matrixWorld);
      }
      Gizmos.DrawRay(wp, rayDirectionRigSpace, 255);
    }
  }
  onDragUpdate(numberOfPointers) {
    if (numberOfPointers > 1)
      return;
    const draggedObject = this.gameObject;
    if (!draggedObject || !this._followObject) {
      console.warn("Warning: DragPointerHandler doesn't have a dragged object. This is likely a bug.");
      return;
    }
    const dragSource = this._followObject.parent;
    if (!dragSource) {
      console.warn("Warning: DragPointerHandler doesn't have a drag source. This is likely a bug.");
      return;
    }
    this._followObject.updateMatrix();
    const dragSourceWP = dragSource.worldPosition;
    const rayDirection = dragSource.worldForward;
    const isSpatialInput = this._deviceMode === "tracked-pointer" || this._deviceMode === "transient-pointer";
    const keepRotation = isSpatialInput ? this.settings.xrKeepRotation : this.settings.keepRotation;
    const dragMode = isSpatialInput ? this.settings.xrDragMode : this.settings.dragMode;
    if (dragMode === DragMode.None)
      return;
    const lerpStrength = 10;
    if (keepRotation)
      this._followObject.worldQuaternion = this._followObjectStartWorldQuaternion;
    this._followObject.updateMatrix();
    this._followObject.updateMatrixWorld(true);
    let currentDist = 1;
    let lerpFactor = 2;
    if (isSpatialInput && this._grabStartDistance > 0.5) {
      const factor = 1 + this._totalMovementAlongRayDirection * (2 * this.settings.xrDistanceDragFactor);
      currentDist = Math.max(0, factor);
      currentDist = currentDist * currentDist * currentDist;
    } else if (this._grabStartDistance <= 0.5) {
      lerpFactor = 3;
    }
    this._followObject.position.copy(this._followObjectStartPosition);
    if (!keepRotation)
      this._followObject.quaternion.copy(this._followObjectStartQuaternion);
    this._followObject.position.multiplyScalar(currentDist);
    this._followObject.updateMatrix();
    const didHaveSurfaceHitPointLastFrame = this._hasLastSurfaceHitPoint;
    this._hasLastSurfaceHitPoint = false;
    const ray = new Ray(dragSourceWP, rayDirection);
    let didHit = false;
    if (dragMode == DragMode.SnapToSurfaces) {
      const hits = this.context.physics.raycastFromRay(ray, {
        testObject: (o) => o !== this.followObject && o !== dragSource && o !== draggedObject
        // && !(o instanceof GroundedSkybox)
      });
      if (hits.length > 0) {
        const hit = hits[0];
        if (this._draggedOverObject === hit.object)
          this._draggedOverObjectDuration += this.context.time.deltaTime;
        else {
          this._draggedOverObject = hit.object;
          this._draggedOverObjectDuration = 0;
        }
        if (hit.face) {
          didHit = true;
          this._hasLastSurfaceHitPoint = true;
          this._lastSurfaceHitPoint.copy(hit.point);
          const dragTimeThreshold = 0.15;
          const dragTimeSatisfied = this._draggedOverObjectDuration >= dragTimeThreshold;
          const dragDistance = 1e-3;
          const dragDistanceSatisfied = this._totalMovement.length() >= dragDistance;
          const worldNormal = getTempVector(hit.normal || hit.face.normal).applyQuaternion(hit.object.worldQuaternion);
          if ((dragTimeSatisfied || dragDistanceSatisfied) && (this._draggedOverObjectLastSetUp !== this._draggedOverObject || this._draggedOverObjectLastNormal.dot(worldNormal) < 0.999999 || this.context.time.frame % 60 === 0)) {
            this._draggedOverObjectLastSetUp = this._draggedOverObject;
            this._draggedOverObjectLastNormal.copy(hit.face.normal);
            const center = getTempVector();
            const size = getTempVector();
            this._bounds.getCenter(center);
            this._bounds.getSize(size);
            center.sub(size.multiplyScalar(0.5).multiply(worldNormal));
            this._hitPointInLocalSpace.copy(center);
            this._hitNormalInLocalSpace.copy(hit.face.normal);
            this._bounds.getCenter(center);
            this._bounds.getSize(size);
            center.add(size.multiplyScalar(0.5).multiply(hit.face.normal));
            const offset = getTempVector(this._hitPointInLocalSpace).add(center);
            this._followObject.localToWorld(offset);
            const point = hit.point;
            this._dragPlane.setFromNormalAndCoplanarPoint(worldNormal, point);
          } else if (!(dragTimeSatisfied || dragDistanceSatisfied)) {
            return;
          }
        }
      } else if (didHaveSurfaceHitPointLastFrame) {
        if (this.gameObject)
          this.setPlaneViewAligned(this.gameObject.worldPosition, false);
      }
    }
    if (dragMode !== DragMode.Attached && ray.intersectPlane(this._dragPlane, this._tempVec)) {
      this._followObject.worldPosition = this._tempVec;
      this._followObject.updateMatrix();
      this._followObject.updateMatrixWorld(true);
      const newWP = getTempVector(this._hitPointInLocalSpace);
      this._followObject.localToWorld(newWP);
      if (debug90) {
        Gizmos.DrawLine(newWP, this._tempVec, 65535, 0, false);
      }
      this._followObject.worldPosition = this._tempVec.multiplyScalar(2).sub(newWP);
      this._followObject.updateMatrix();
      this._followObject.updateMatrix();
    }
    if (this.settings.snapGridResolution > 0) {
      const wp2 = this._followObject.worldPosition;
      const snap = this.settings.snapGridResolution;
      wp2.x = Math.round(wp2.x / snap) * snap;
      wp2.y = Math.round(wp2.y / snap) * snap;
      wp2.z = Math.round(wp2.z / snap) * snap;
      this._followObject.worldPosition = wp2;
      this._followObject.updateMatrix();
    }
    if (keepRotation) {
      this._followObject.worldQuaternion = this._followObjectStartWorldQuaternion;
      this._followObject.updateMatrix();
    }
    const t2 = Mathf.clamp01(this.context.time.deltaTime * lerpStrength * lerpFactor);
    const t_rotation = Mathf.clamp01(this.context.time.deltaTime * lerpStrength * 0.5 * lerpFactor);
    const wp = draggedObject.worldPosition;
    wp.lerp(this._followObject.worldPosition, t2);
    draggedObject.worldPosition = wp;
    const rot = draggedObject.worldQuaternion;
    rot.slerp(this._followObject.worldQuaternion, t_rotation);
    draggedObject.worldQuaternion = rot;
    if (debug90) {
      const hitPointWP = this._hitPointInLocalSpace.clone();
      draggedObject.localToWorld(hitPointWP);
      Gizmos.DrawSphere(hitPointWP, 0.02, 16711680);
      const hitNormalWP = this._hitNormalInLocalSpace.clone();
      hitNormalWP.applyQuaternion(rot);
      Gizmos.DrawRay(hitPointWP, hitNormalWP, 16711680);
      Gizmos.DrawLabel(wp.add(new Vector32(0, 0.25, 0)), `Distance: ${this._totalMovement.length().toFixed(2)}

                Along Ray: ${this._totalMovementAlongRayDirection.toFixed(2)}

                Session: ${!!NeedleXRSession.active}

                Device: ${this._deviceMode}

                `, 0.03);
      const bottomCenter = this._bottomCenter.clone();
      const backCenter = this._backCenter.clone();
      const backBottomCenter = this._backBottomCenter.clone();
      draggedObject.localToWorld(bottomCenter);
      draggedObject.localToWorld(backCenter);
      draggedObject.localToWorld(backBottomCenter);
      Gizmos.DrawSphere(bottomCenter, 0.01, 65280, 0, false);
      Gizmos.DrawSphere(backCenter, 0.01, 255, 0, false);
      Gizmos.DrawSphere(backBottomCenter, 0.01, 16711935, 0, false);
      Gizmos.DrawLine(bottomCenter, backBottomCenter, 65535, 0, false);
      Gizmos.DrawLine(backBottomCenter, backCenter, 65535, 0, false);
    }
  }
  onDragEnd(args) {
    console.assert(this._followObject.parent === args.event.space, "Drag end: _followObject is not parented to the space object");
    this._followObject.removeFromParent();
    this._followObject.destroy();
    this._lastDragPosRigSpace = void 0;
  }
  setPlaneViewAligned(worldPoint, useUpAngle) {
    if (!this._followObject.parent) {
      return false;
    }
    const viewDirection = this._followObject.parent.worldForward;
    ;
    const v0 = getTempVector(0, 1, 0);
    const v1 = viewDirection;
    const angle = v0.angleTo(v1);
    const angleThreshold = 0.5;
    if (useUpAngle && (angle > Math.PI / 2 + angleThreshold || angle < Math.PI / 2 - angleThreshold))
      this._dragPlane.setFromNormalAndCoplanarPoint(v0, worldPoint);
    else
      this._dragPlane.setFromNormalAndCoplanarPoint(viewDirection, worldPoint);
    return true;
  }
};
var _LegacyDragVisualsHelper = class {
  constructor(camera) {
    __publicField(this, "showGizmo", true);
    __publicField(this, "useViewAngle", true);
    __publicField(this, "_selected", null);
    __publicField(this, "_context", null);
    __publicField(this, "_camera");
    __publicField(this, "_cameraPlane", new Plane());
    __publicField(this, "_hasGroundPlane", false);
    __publicField(this, "_groundPlane", new Plane());
    __publicField(this, "_groundOffset", new Vector32());
    __publicField(this, "_groundOffsetFactor", 0);
    __publicField(this, "_groundDistance", 0);
    __publicField(this, "_groundPlanePoint", new Vector32());
    __publicField(this, "_raycaster", new Raycaster());
    __publicField(this, "_cameraPlaneOffset", new Vector32());
    __publicField(this, "_intersection", new Vector32());
    __publicField(this, "_worldPosition", new Vector32());
    __publicField(this, "_inverseMatrix", new Matrix4());
    __publicField(this, "_rbs", []);
    __publicField(this, "_groundLine");
    __publicField(this, "_groundMarker");
    __publicField(this, "_groundOffsetVector", new Vector32(0, 1, 0));
    __publicField(this, "_requireUpdateGroundPlane", true);
    __publicField(this, "_didDragOnGroundPlaneLastFrame", false);
    this._camera = camera;
    const line = new Line(_LegacyDragVisualsHelper.geometry);
    const mat = line.material;
    mat.color = new Color(0.4, 0.4, 0.4);
    line.layers.set(2);
    line.name = "line";
    line.scale.y = 1;
    this._groundLine = line;
    const geometry = new SphereGeometry(0.5, 22, 22);
    const material = new MeshBasicMaterial({ color: mat.color });
    const sphere = new Mesh(geometry, material);
    sphere.visible = false;
    sphere.layers.set(2);
    this._groundMarker = sphere;
  }
  get hasSelected() {
    return this._selected !== null && this._selected !== void 0;
  }
  get selected() {
    return this._selected;
  }
  setSelected(newSelected, context) {
    if (this._selected && context) {
      for (const rb of this._rbs) {
        rb.wakeUp();
        rb.setVelocity(0, 0, 0);
      }
    }
    if (this._selected) {
      Avatar_POI.Remove(context, this._selected);
    }
    this._selected = newSelected;
    this._context = context;
    this._rbs.length = 0;
    if (newSelected) {
      context.scene.add(this._groundLine);
      context.scene.add(this._groundMarker);
    } else {
      this._groundLine.removeFromParent();
      this._groundMarker.removeFromParent();
    }
    if (this._selected) {
      if (!context) {
        console.error("DragHelper: no context");
        return;
      }
      Avatar_POI.Add(context, this._selected, null);
      this._groundOffsetFactor = 0;
      this._hasGroundPlane = true;
      this._groundOffset.set(0, 0, 0);
      this._requireUpdateGroundPlane = true;
      this.onUpdateScreenSpacePlane();
    }
  }
  onUpdate(_context) {
    if (!this._selected)
      return;
  }
  onUpdateWorldPosition(wp, pointOnPlane, heightOnly) {
    if (!this._selected)
      return;
    if (heightOnly) {
      const cur = getWorldPosition(this._selected);
      cur.y = wp.y;
      wp = cur;
    }
    setWorldPosition(this._selected, wp);
    setWorldPosition(this._groundLine, wp);
    if (this._hasGroundPlane) {
      this._groundLine.scale.y = this._groundDistance;
    } else
      this._groundLine.scale.y = 1e3;
    this._groundLine.visible = this.showGizmo;
    this._groundMarker.visible = pointOnPlane !== null && this.showGizmo;
    if (pointOnPlane) {
      const s = getWorldPosition(this._camera).distanceTo(pointOnPlane) * 0.01;
      this._groundMarker.scale.set(s, s, s);
      setWorldPosition(this._groundMarker, pointOnPlane);
    }
  }
  onUpdateScreenSpacePlane() {
    if (!this._selected || !this._context)
      return;
    const rc = this._context.input.getPointerPositionRC(0);
    if (!rc)
      return;
    this._raycaster.setFromCamera(rc, this._camera);
    this._cameraPlane.setFromNormalAndCoplanarPoint(this._camera.getWorldDirection(this._cameraPlane.normal), this._worldPosition.setFromMatrixPosition(this._selected.matrixWorld));
    if (this._raycaster.ray.intersectPlane(this._cameraPlane, this._intersection) && this._selected.parent) {
      this._inverseMatrix.copy(this._selected.parent.matrixWorld).invert();
      this._cameraPlaneOffset.copy(this._intersection).sub(this._worldPosition.setFromMatrixPosition(this._selected.matrixWorld));
    }
  }
  onUpdateGroundPlane() {
    if (!this._selected || !this._context)
      return;
    const wp = getWorldPosition(this._selected);
    const ray = new Ray(getTempVector(0, 0.1, 0).add(wp), getTempVector(0, -1, 0));
    const opts = new RaycastOptions();
    opts.testObject = (o) => o !== this._selected;
    const hits = this._context.physics.raycastFromRay(ray, opts);
    for (let i = 0; i < hits.length; i++) {
      const hit = hits[i];
      if (!hit.face || this.contains(this._selected, hit.object)) {
        continue;
      }
      const normal = getTempVector(0, 1, 0);
      this._groundPlane.setFromNormalAndCoplanarPoint(normal, hit.point);
      break;
    }
    this._hasGroundPlane = true;
    this._groundPlane.setFromNormalAndCoplanarPoint(ray.direction.multiplyScalar(-1), ray.origin);
    this._raycaster.ray.intersectPlane(this._groundPlane, this._intersection);
    this._groundDistance = this._intersection.distanceTo(wp);
    this._groundOffset.copy(this._intersection).sub(wp);
  }
  contains(obj, toSearch) {
    if (obj === toSearch)
      return true;
    if (obj.children) {
      for (const child of obj.children) {
        if (this.contains(child, toSearch))
          return true;
      }
    }
    return false;
  }
};
var LegacyDragVisualsHelper = _LegacyDragVisualsHelper;
__publicField(LegacyDragVisualsHelper, "geometry", new BufferGeometry().setFromPoints([new Vector32(0, 0, 0), new Vector32(0, -1, 0)]));

// node_modules/@needle-tools/engine/lib/engine/engine_networking_files.js
var File_Event;
(function(File_Event2) {
  File_Event2["File_Spawned"] = "file-spawned";
})(File_Event || (File_Event = {}));
var FileSpawnModel = class {
  constructor(connectionId, seed, guid, name, hash, size, position, scale, downloadUrl) {
    __publicField(this, "guid");
    __publicField(this, "file_name");
    __publicField(this, "file_hash");
    __publicField(this, "file_size");
    __publicField(this, "position");
    __publicField(this, "scale");
    __publicField(this, "seed");
    __publicField(this, "sender");
    /** the url to download the file */
    __publicField(this, "downloadUrl");
    __publicField(this, "parentGuid");
    __publicField(this, "boundsSize");
    this.seed = seed;
    this.guid = guid;
    this.file_name = name;
    this.file_hash = hash;
    this.file_size = size;
    this.position = position;
    this.scale = scale;
    this.sender = connectionId;
    this.downloadUrl = downloadUrl;
  }
};
var PreviewHelper;
(function(PreviewHelper2) {
  const previews = /* @__PURE__ */ new Map();
  function addPreview(params) {
    var _a2;
    if (previews.has(params.guid)) {
      removePreview(params.guid);
    }
    const root = new Object3D();
    previews.set(params.guid, root);
    const rendering = new Object3D();
    rendering.position.y = -0.5;
    root.add(rendering);
    const outline = new Mesh(new BoxGeometry(1, 1, 1, 1, 1, 1), new MeshBasicMaterial({ color: 14540253, wireframe: true, transparent: true, opacity: 0.3 }));
    outline.position.y = 0.5;
    rendering.add(outline);
    const progress = new Object3D();
    rendering.add(progress);
    const progressMesh = new Mesh(new BoxGeometry(1, 1, 1, 1, 1, 1), new MeshBasicMaterial({
      color: 12307660,
      transparent: true,
      opacity: 0.4
    }));
    progressMesh.position.y = 0.5;
    progress.scale.y = 0.01;
    progress.add(progressMesh);
    const progressMeshTopPlane = new Mesh(new PlaneGeometry(1, 1, 1, 1), new MeshBasicMaterial({
      color: 34,
      transparent: true,
      opacity: 0.05,
      depthTest: false
    }));
    progressMeshTopPlane.rotateX(-Math.PI / 2);
    progressMeshTopPlane.position.y = 0.51;
    progressMesh.add(progressMeshTopPlane);
    params.parent.add(root);
    root.rotateY(Math.PI / 2);
    if (params.position)
      (_a2 = root.position) == null ? void 0 : _a2.copy(params.position);
    if (params.size) {
      root.worldScale = new Vector32().copy(params.size);
    }
    root.position.y = root.scale.y / 2;
    return {
      object: root,
      onProgress: (downloadProgress) => {
        if (progress instanceof Object3D) {
          progress.scale.set(1, downloadProgress, 1);
        }
      }
    };
  }
  PreviewHelper2.addPreview = addPreview;
  function removePreview(guid) {
    const existing = previews.get(guid);
    if (existing) {
      previews.delete(guid);
      existing.removeFromParent();
    }
  }
  PreviewHelper2.removePreview = removePreview;
})(PreviewHelper || (PreviewHelper = {}));

// node_modules/@needle-tools/engine/lib/engine-components/DropListener.js
var __decorate56 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug91 = getParam("debugdroplistener");
var DropListenerEvents;
(function(DropListenerEvents2) {
  DropListenerEvents2["FileDropped"] = "file-dropped";
  DropListenerEvents2["ObjectAdded"] = "object-added";
})(DropListenerEvents || (DropListenerEvents = {}));
var DropListenerAddedEvent = class extends CustomEvent {
  constructor(detail) {
    super(DropListenerEvents.ObjectAdded, { detail });
  }
};
var blobKeyName = "blob";
var DropListener = class extends Component2 {
  constructor() {
    super(...arguments);
    /**
     * When enabled the DropListener will automatically network dropped files to other clients.
     */
    __publicField(this, "useNetworking", true);
    /**
     * When assigned the Droplistener will only accept files that are dropped on this object.
     */
    __publicField(this, "dropArea");
    /**
     * When enabled the object will be fitted into a volume. Use {@link fitVolumeSize} to specify the volume size.
     * @default false
     */
    __publicField(this, "fitIntoVolume", false);
    /**
     * The volume size will be used to fit the object into the volume. Use {@link fitIntoVolume} to enable this feature.
     */
    __publicField(this, "fitVolumeSize", new Vector32(1, 1, 1));
    /** When enabled the object will be placed at the drop position (under the cursor)
     * @default true
     */
    __publicField(this, "placeAtHitPosition", true);
    /**
     * Invoked after a file has been **added** to the scene.
     * Arguments are {@link AddedEventArguments}
     * @event object-added
     * @param {AddedEventArguments} evt
     * @example
     * ```typescript
     * dropListener.onDropped.addEventListener((evt) => {
     *  console.log("Object added", evt.model);
     * });
     */
    __publicField(this, "onDropped", new EventList());
    __publicField(this, "onNetworkEvent", (evt) => {
      var _a2;
      if (!this.useNetworking) {
        if (debug91)
          console.debug("[DropListener] Ignoring networked event because networking is disabled", evt);
        return;
      }
      if ((_a2 = evt.guid) == null ? void 0 : _a2.startsWith(this.guid)) {
        const url = evt.url;
        console.debug("[DropListener] Received networked event", evt);
        if (url) {
          if (Array.isArray(url)) {
            for (const _url of url) {
              this.addFromUrl(_url, { screenposition: new Vector2(), point: evt.point, size: evt.size }, true);
            }
          } else {
            this.addFromUrl(url, { screenposition: new Vector2(), point: evt.point, size: evt.size }, true);
          }
        }
      }
    });
    __publicField(this, "handlePaste", (evt) => {
      if (this.context.connection.allowEditing === false)
        return;
      if (evt.defaultPrevented)
        return;
      const clipboard = navigator.clipboard;
      clipboard.readText().then((value) => {
        if (value) {
          const isUrl = value.startsWith("http") || value.startsWith("https") || value.startsWith("blob");
          if (isUrl) {
            const ctx = { screenposition: new Vector2(this.context.input.mousePosition.x, this.context.input.mousePosition.y) };
            if (this.testIfIsInDropArea(ctx))
              this.addFromUrl(value, ctx, false);
          }
        }
      }).catch(console.warn);
    });
    __publicField(this, "onDrag", (evt) => {
      if (this.context.connection.allowEditing === false)
        return;
      evt.preventDefault();
    });
    __publicField(this, "onDrop", async (evt) => {
      if (this.context.connection.allowEditing === false)
        return;
      if (debug91)
        console.log(evt);
      if (!(evt == null ? void 0 : evt.dataTransfer))
        return;
      if (evt["droplistener:handled"])
        return;
      evt.preventDefault();
      const ctx = { screenposition: new Vector2(evt.offsetX, evt.offsetY) };
      if (this.dropArea) {
        const res = this.testIfIsInDropArea(ctx);
        if (res === false)
          return;
      }
      evt["droplistener:handled"] = true;
      const items = evt.dataTransfer.items;
      if (!items)
        return;
      const files = [];
      for (const ite in items) {
        const it2 = items[ite];
        if (it2.kind === "file") {
          const file = it2.getAsFile();
          if (!file)
            continue;
          files.push(file);
        } else if (it2.kind === "string" && it2.type == "text/plain") {
          it2.getAsString((str) => {
            this.addFromUrl(str, ctx, false);
          });
        }
      }
      if (files.length > 0) {
        await this.addDroppedFiles(files, ctx);
      }
    });
    __publicField(this, "_abort", null);
    /** Previously added objects */
    __publicField(this, "_addedObjects", new Array());
    __publicField(this, "_addedModels", new Array());
  }
  /** @internal */
  onEnable() {
    this.context.renderer.domElement.addEventListener("dragover", this.onDrag);
    this.context.renderer.domElement.addEventListener("drop", this.onDrop);
    window.addEventListener("paste", this.handlePaste);
    this.context.connection.beginListen("droplistener", this.onNetworkEvent);
  }
  /** @internal */
  onDisable() {
    this.context.renderer.domElement.removeEventListener("dragover", this.onDrag);
    this.context.renderer.domElement.removeEventListener("drop", this.onDrop);
    window.removeEventListener("paste", this.handlePaste);
    this.context.connection.stopListen("droplistener", this.onNetworkEvent);
  }
  /**
   * Loads a file from the given URL and adds it to the scene.
   */
  loadFromURL(url, data) {
    this.addFromUrl(url, { screenposition: new Vector2(), point: data == null ? void 0 : data.point, size: data == null ? void 0 : data.size }, true);
  }
  /**
   * Forgets all previously added objects.
   * The droplistener will then not be able to remove previously added objects.
   */
  forgetObjects() {
    this.removePreviouslyAddedObjects(false);
  }
  async addFromUrl(url, ctx, isRemote) {
    if (debug91)
      console.log("dropped url", url);
    try {
      if (url.startsWith("https://github.com/")) {
        const parts = url.split("/");
        const user = parts[3];
        const repo = parts[4];
        const branch = parts[6];
        const path = parts.slice(7).join("/");
        url = `https://raw.githubusercontent.com/${user}/${repo}/${branch}/${path}`;
      } else if (url.startsWith("https://polyhaven.com/a")) {
        url = tryResolvePolyhavenAssetUrl(url);
      }
      if (!url)
        return null;
      const lowercaseUrl = url.toLowerCase();
      if (lowercaseUrl.endsWith(".hdr") || lowercaseUrl.endsWith(".hdri") || lowercaseUrl.endsWith(".exr") || lowercaseUrl.endsWith(".png") || lowercaseUrl.endsWith(".jpg") || lowercaseUrl.endsWith(".jpeg")) {
        return null;
      }
      this.removePreviouslyAddedObjects();
      const res = await FileHelper.loadFileFromURL(new URL(url), {
        guid: this.guid,
        context: this.context,
        parent: this.gameObject,
        point: ctx.point,
        size: ctx.size
      });
      if (res && this._addedObjects.length <= 0) {
        ctx.url = url;
        const obj = this.addObject(res, ctx, isRemote);
        return obj;
      }
    } catch (_) {
      console.warn("String is not a valid URL", url);
    }
    return null;
  }
  async addDroppedFiles(fileList, ctx) {
    var _a2, _b;
    if (debug91)
      console.log("Add files", fileList);
    if (!Array.isArray(fileList))
      return;
    if (!fileList.length)
      return;
    this.deleteDropEvent();
    this.removePreviouslyAddedObjects();
    setParamWithoutReload(blobKeyName, null);
    (_a2 = this._abort) == null ? void 0 : _a2.abort("New files dropped");
    this._abort = new AbortController();
    for (const file of fileList) {
      if (!file)
        continue;
      console.debug("Load file " + file.name);
      const res = await FileHelper.loadFile(file, this.context, { guid: this.guid });
      if (res) {
        this.dispatchEvent(new CustomEvent(DropListenerEvents.FileDropped, { detail: file }));
        ctx.file = file;
        const obj = this.addObject(res, ctx, false);
        if (obj && this.context.connection.isConnected && this.useNetworking) {
          console.debug("Uploading dropped file to blob storage");
          BlobStorage.upload(file, { abort: (_b = this._abort) == null ? void 0 : _b.signal }).then((upload) => {
            if ((upload == null ? void 0 : upload.download_url) && this._addedObjects.includes(obj)) {
              this.sendDropEvent(upload.download_url, obj, res.contentMD5);
            }
          }).catch(console.warn);
        }
        break;
      }
    }
  }
  /** Removes all previously added objects from the scene and removes those object references  */
  removePreviouslyAddedObjects(doDestroy = true) {
    if (doDestroy) {
      for (const prev of this._addedObjects) {
        if (prev.parent === this.gameObject) {
          destroy(prev, true, true);
        }
      }
    }
    this._addedObjects.length = 0;
    this._addedModels.length = 0;
  }
  /**
   * Adds the object to the scene and fits it into the volume if {@link fitIntoVolume} is enabled.
   */
  addObject(data, ctx, isRemote) {
    var _a2, _b;
    const { model, contentMD5 } = data;
    if (debug91)
      console.log(`Dropped ${this.gameObject.name}`, model);
    if (!(model == null ? void 0 : model.scene)) {
      console.warn("No object specified to add to scene", model);
      return null;
    }
    this.removePreviouslyAddedObjects();
    const obj = model.scene;
    this.gameObject.attach(obj);
    obj.position.set(0, 0, 0);
    obj.quaternion.identity();
    this._addedObjects.push(obj);
    this._addedModels.push(model);
    const volume = new Box3().setFromCenterAndSize(new Vector32(0, this.fitVolumeSize.y * 0.5, 0).add(this.gameObject.worldPosition), this.fitVolumeSize);
    if (debug91)
      Gizmos.DrawWireBox3(volume, 255, 5);
    if (this.fitIntoVolume) {
      fitObjectIntoVolume(obj, volume, {
        position: !this.placeAtHitPosition
      });
    }
    if (this.placeAtHitPosition && ctx && ctx.screenposition) {
      obj.visible = false;
      const rc = this.context.physics.raycast({ screenPoint: this.context.input.convertScreenspaceToRaycastSpace(ctx.screenposition.clone()) });
      obj.visible = true;
      if (rc && rc.length > 0) {
        for (const hit of rc) {
          const pos = hit.point.clone();
          if (debug91)
            console.log("Place object at hit", hit);
          placeOnSurface(obj, pos);
          break;
        }
      }
    }
    AnimationUtils.assignAnimationsFromFile(model, {
      createAnimationComponent: (obj2) => addComponent(obj2, Animation)
    });
    const evt = new DropListenerAddedEvent({
      sender: this,
      gltf: model,
      model,
      object: obj,
      contentMD5,
      dropped: ctx.file || (ctx.url ? new URL(ctx.url) : void 0)
    });
    this.dispatchEvent(evt);
    (_a2 = this.onDropped) == null ? void 0 : _a2.invoke(evt.detail);
    if (!isRemote && ((_b = ctx.url) == null ? void 0 : _b.startsWith("http")) && this.context.connection.isConnected && obj) {
      this.sendDropEvent(ctx.url, obj, contentMD5);
    }
    return obj;
  }
  async sendDropEvent(url, obj, contentmd5) {
    if (!this.useNetworking) {
      if (debug91)
        console.debug("[DropListener] Ignoring networked event because networking is disabled", url);
      return;
    }
    if (this.context.connection.isConnected) {
      console.debug('Sending drop event "' + obj.name + '"', url);
      const bounds = getBoundingBox([obj]);
      const evt = {
        name: obj.name,
        guid: this.guid,
        url,
        point: obj.worldPosition.clone(),
        size: bounds.getSize(new Vector32()),
        contentMD5: contentmd5
      };
      this.context.connection.send("droplistener", evt);
    }
  }
  deleteDropEvent() {
    this.context.connection.sendDeleteRemoteState(this.guid);
  }
  testIfIsInDropArea(ctx) {
    if (this.dropArea) {
      const screenPoint = this.context.input.convertScreenspaceToRaycastSpace(ctx.screenposition.clone());
      const hits = this.context.physics.raycast({
        targets: [this.dropArea],
        screenPoint,
        recursive: true,
        testObject: (obj) => {
          if (this._addedObjects.includes(obj))
            return false;
          return true;
        }
      });
      if (!hits.length) {
        if (isDevEnvironment())
          console.log(`Dropped outside of drop area for DropListener "${this.name}".`);
        return false;
      }
    }
    return true;
  }
};
__decorate56([
  serializable()
], DropListener.prototype, "useNetworking", void 0);
__decorate56([
  serializable(Object3D)
], DropListener.prototype, "dropArea", void 0);
__decorate56([
  serializable()
], DropListener.prototype, "fitIntoVolume", void 0);
__decorate56([
  serializable(Vector32)
], DropListener.prototype, "fitVolumeSize", void 0);
__decorate56([
  serializable()
], DropListener.prototype, "placeAtHitPosition", void 0);
__decorate56([
  serializable(EventList)
], DropListener.prototype, "onDropped", void 0);
function tryResolvePolyhavenAssetUrl(urlStr) {
  if (!urlStr.startsWith("https://polyhaven.com/"))
    return urlStr;
  const baseUrl = "https://dl.polyhaven.org/file/ph-assets/Models/gltf/4k/";
  const url = new URL(urlStr);
  const path = url.pathname;
  const name = path.split("/").pop();
  const assetUrl = `${baseUrl}${name}/${name}_4k.gltf`;
  console.log("Resolved polyhaven asset url", urlStr, "→", assetUrl);
  return assetUrl;
}
var FileHelper;
(function(FileHelper2) {
  async function loadFile(file, context, args) {
    const name = file.name.toLowerCase();
    if (name.endsWith(".gltf") || name.endsWith(".glb") || name.endsWith(".fbx") || name.endsWith(".obj") || name.endsWith(".usdz") || name.endsWith(".vrm") || file.type === "model/gltf+json" || file.type === "model/gltf-binary") {
      return new Promise((resolve2, _reject) => {
        const reader = new FileReader();
        reader.readAsArrayBuffer(file);
        reader.onloadend = async (_ev) => {
          const content = reader.result;
          const seed = args.guid;
          const prov = new InstantiateIdProvider(seed);
          const model = await getLoader().parseSync(context, content, file.name, prov);
          if (model) {
            const hash = BlobStorage.hashMD5(content);
            resolve2({ model, contentMD5: hash });
          }
        };
      });
    } else {
      console.warn("Unsupported file type: " + name, file.type);
    }
    return null;
  }
  FileHelper2.loadFile = loadFile;
  async function loadFileFromURL(url, args) {
    return new Promise(async (resolve2, _reject) => {
      const prov = new InstantiateIdProvider(args.guid);
      const urlStr = url.toString();
      if (debug91)
        Gizmos.DrawWireSphere(args.point, 0.1, 16711680, 3);
      const preview = PreviewHelper.addPreview({
        guid: args.guid,
        parent: args.parent,
        position: args == null ? void 0 : args.point,
        size: args == null ? void 0 : args.size
      });
      const model = await getLoader().loadSync(args.context, urlStr, urlStr, prov, (prog) => {
        preview.onProgress(prog.loaded / prog.total);
      }).catch(console.warn);
      if (model) {
        const binary = await fetch(urlStr).then((res) => res.arrayBuffer());
        const hash = BlobStorage.hashMD5(binary);
        if (debug91)
          setTimeout(() => PreviewHelper.removePreview(args.guid), 3e3);
        else
          PreviewHelper.removePreview(args.guid);
        resolve2({ model, contentMD5: hash });
      } else {
        if (debug91)
          setTimeout(() => PreviewHelper.removePreview(args.guid), 3e3);
        else
          PreviewHelper.removePreview(args.guid);
        console.warn("Unsupported file type: " + url.toString());
      }
    });
  }
  FileHelper2.loadFileFromURL = loadFileFromURL;
})(FileHelper || (FileHelper = {}));

// node_modules/@needle-tools/engine/lib/engine-components/Duplicatable.js
var __decorate57 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var Duplicatable = class extends Component2 {
  constructor() {
    super(...arguments);
    /** Duplicates will be parented into the set object. If not defined, this GameObject will be used as parent. */
    __publicField(this, "parent", null);
    /** The object to be duplicated. If no object is assigned then the object the Duplicatable component is attached to will be used for cloning.
     * @default null
     */
    __publicField(this, "object", null);
    /**
     * The maximum number of objects that can be duplicated in the interval.
     * @default 10
     */
    __publicField(this, "limitCount", 10);
    /**
     * The interval in seconds in which the limitCount is reset.
     * @default 60
     */
    __publicField(this, "limitInterval", 60);
    __publicField(this, "_currentCount", 0);
    __publicField(this, "_startPosition", null);
    __publicField(this, "_startQuaternion", null);
    __publicField(this, "_forwardPointerEvents", /* @__PURE__ */ new Map());
  }
  start() {
    var _a2, _b;
    this._currentCount = 0;
    this._startPosition = null;
    this._startQuaternion = null;
    if (!this.object) {
      this.object = this.gameObject;
    }
    if (this.object) {
      if (this.object === this.gameObject) {
        const instanceIdProvider = new InstantiateIdProvider(this.guid);
        this.object = GameObject.instantiate(this.object, { idProvider: instanceIdProvider, keepWorldPosition: false });
        const duplicatable = GameObject.getComponent(this.object, Duplicatable);
        duplicatable == null ? void 0 : duplicatable.destroy();
        let dragControls2 = this.object.getComponentInChildren(DragControls);
        if (!dragControls2) {
          dragControls2 = this.object.addComponent(DragControls, {
            dragMode: DragMode.SnapToSurfaces
          });
          dragControls2.guid = instanceIdProvider.generateUUID();
        }
        let syncedTransfrom = GameObject.getComponent(dragControls2.gameObject, SyncedTransform);
        if (!syncedTransfrom) {
          syncedTransfrom = dragControls2.gameObject.addComponent(SyncedTransform);
          syncedTransfrom.guid = instanceIdProvider.generateUUID();
        }
      }
      this.object.visible = false;
      const dragControls = this.gameObject.getComponent(DragControls);
      if (dragControls) {
        dragControls.enabled = false;
      }
      this._startPosition = ((_a2 = this.object.position) == null ? void 0 : _a2.clone()) ?? new Vector32(0, 0, 0);
      this._startQuaternion = ((_b = this.object.quaternion) == null ? void 0 : _b.clone()) ?? new Quaternion(0, 0, 0, 1);
    }
    if (!this.gameObject.getComponentInParent(ObjectRaycaster))
      this.gameObject.addComponent(ObjectRaycaster);
    this.cloneLimitIntervalFn();
  }
  onPointerEnter(args) {
    if (args.used)
      return;
    if (!this.object)
      return;
    if (!this.context.connection.allowEditing)
      return;
    if (args.button !== 0)
      return;
    this.context.input.setCursorPointer();
  }
  onPointerExit(args) {
    if (args.used)
      return;
    if (!this.object)
      return;
    if (!this.context.connection.allowEditing)
      return;
    if (args.button !== 0)
      return;
    this.context.input.setCursorNormal();
  }
  /** @internal */
  onPointerDown(args) {
    if (args.used)
      return;
    if (!this.object)
      return;
    if (!this.context.connection.allowEditing)
      return;
    if (args.button !== 0)
      return;
    const res = this.handleDuplication();
    if (res) {
      const dragControls = GameObject.getComponent(res, DragControls);
      if (!dragControls)
        console.warn("Duplicated object does not have DragControls", res);
      else {
        dragControls.onPointerDown(args);
        this._forwardPointerEvents.set(args.event.space, dragControls);
      }
    } else {
      console.warn("Could not duplicate object. Has the target object been destroyed?", this);
    }
  }
  /** @internal */
  onPointerUp(args) {
    if (args.used)
      return;
    const dragControls = this._forwardPointerEvents.get(args.event.space);
    if (dragControls) {
      dragControls.onPointerUp(args);
      this._forwardPointerEvents.delete(args.event.space);
    }
  }
  cloneLimitIntervalFn() {
    if (this.destroyed)
      return;
    if (this._currentCount > 0) {
      this._currentCount -= 1;
    }
    setTimeout(() => {
      this.cloneLimitIntervalFn();
    }, this.limitInterval / this.limitCount * 1e3);
  }
  handleDuplication() {
    var _a2;
    if (!this.object)
      return null;
    if (this._currentCount >= this.limitCount)
      return null;
    if (this.object === this.gameObject)
      return null;
    if (GameObject.isDestroyed(this.object)) {
      this.object = null;
      return null;
    }
    this.object.visible = true;
    if (this._startPosition)
      this.object.position.copy(this._startPosition);
    if (this._startQuaternion)
      this.object.quaternion.copy(this._startQuaternion);
    const opts = new InstantiateOptions();
    if (!this.parent)
      this.parent = this.gameObject.parent;
    if (this.parent) {
      opts.parent = this.parent.guid ?? ((_a2 = this.parent.userData) == null ? void 0 : _a2.guid);
      opts.keepWorldPosition = true;
    }
    opts.position = this.worldPosition;
    opts.rotation = this.worldQuaternion;
    opts.context = this.context;
    this._currentCount += 1;
    const newInstance = GameObject.instantiateSynced(this.object, opts);
    console.assert(newInstance !== this.object, "Duplicated object is original");
    this.object.visible = false;
    if (this._startPosition)
      this.object.position.clone().copy(this._startPosition);
    if (this._startQuaternion)
      this.object.quaternion.clone().copy(this._startQuaternion);
    return newInstance;
  }
};
__decorate57([
  serializable(Object3D)
], Duplicatable.prototype, "parent", void 0);
__decorate57([
  serializable(Object3D)
], Duplicatable.prototype, "object", void 0);
__decorate57([
  serializable()
], Duplicatable.prototype, "limitCount", void 0);
__decorate57([
  serializable()
], Duplicatable.prototype, "limitInterval", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/postprocessing/Effects/EffectWrapper.js
var EffectWrapper = class extends PostProcessingEffect {
  constructor(effect) {
    super();
    __publicField(this, "effect");
    this.effect = effect;
  }
  get typeName() {
    return this.effect.constructor.name;
  }
  onCreateEffect() {
    return this.effect;
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/EventType.js
var EventType;
(function(EventType2) {
  EventType2[EventType2["PointerEnter"] = 0] = "PointerEnter";
  EventType2[EventType2["PointerExit"] = 1] = "PointerExit";
  EventType2[EventType2["PointerDown"] = 2] = "PointerDown";
  EventType2[EventType2["PointerUp"] = 3] = "PointerUp";
  EventType2[EventType2["PointerClick"] = 4] = "PointerClick";
  EventType2[EventType2["Drag"] = 5] = "Drag";
  EventType2[EventType2["Drop"] = 6] = "Drop";
  EventType2[EventType2["Scroll"] = 7] = "Scroll";
  EventType2[EventType2["UpdateSelected"] = 8] = "UpdateSelected";
  EventType2[EventType2["Select"] = 9] = "Select";
  EventType2[EventType2["Deselect"] = 10] = "Deselect";
  EventType2[EventType2["Move"] = 11] = "Move";
  EventType2[EventType2["InitializePotentialDrag"] = 12] = "InitializePotentialDrag";
  EventType2[EventType2["BeginDrag"] = 13] = "BeginDrag";
  EventType2[EventType2["EndDrag"] = 14] = "EndDrag";
  EventType2[EventType2["Submit"] = 15] = "Submit";
  EventType2[EventType2["Cancel"] = 16] = "Cancel";
})(EventType || (EventType = {}));

// node_modules/@needle-tools/engine/lib/engine-components/EventTrigger.js
var __decorate58 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var TriggerEvent = class {
  constructor() {
    __publicField(this, "eventID");
    __publicField(this, "callback", new EventList());
  }
};
__decorate58([
  serializable()
], TriggerEvent.prototype, "eventID", void 0);
__decorate58([
  serializable(EventList)
], TriggerEvent.prototype, "callback", void 0);
var EventTrigger = class extends Component2 {
  constructor() {
    super(...arguments);
    /** A list of events that should be triggered when a pointer event occurs on the GameObject. */
    __publicField(this, "triggers", []);
  }
  /** @internal */
  invoke(type) {
    var _a2;
    if (!this.triggers)
      return;
    for (const trigger of this.triggers) {
      if (trigger.eventID === type) {
        (_a2 = trigger.callback) == null ? void 0 : _a2.invoke();
      }
    }
  }
  /** @internal */
  onPointerClick(_) {
    this.invoke(EventType.PointerClick);
  }
  /** @internal */
  onPointerEnter(_) {
    this.invoke(EventType.PointerEnter);
  }
  /** @internal */
  onPointerExit(_) {
    this.invoke(EventType.PointerExit);
  }
  /** @internal */
  onPointerDown(_) {
    this.invoke(EventType.PointerDown);
  }
  /** @internal */
  onPointerUp(_) {
    this.invoke(EventType.PointerUp);
  }
};
__decorate58([
  serializable(TriggerEvent)
], EventTrigger.prototype, "triggers", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/Joints.js
var __decorate59 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var Joint = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "connectedBody");
    __publicField(this, "_rigidBody", null);
  }
  get rigidBody() {
    return this._rigidBody;
  }
  onEnable() {
    if (!this._rigidBody)
      this._rigidBody = this.gameObject.getComponent(Rigidbody);
    if (this.rigidBody && this.connectedBody)
      this.startCoroutine(this.create());
  }
  *create() {
    yield;
    if (this.rigidBody && this.connectedBody && this.activeAndEnabled) {
      this.createJoint(this.rigidBody, this.connectedBody);
    }
  }
};
__decorate59([
  serializable(Rigidbody)
], Joint.prototype, "connectedBody", void 0);
var FixedJoint = class extends Joint {
  createJoint(self2, other) {
    var _a2;
    (_a2 = this.context.physics.engine) == null ? void 0 : _a2.addFixedJoint(self2, other);
  }
};
var HingeJoint = class extends Joint {
  constructor() {
    super(...arguments);
    __publicField(this, "anchor");
    __publicField(this, "axis");
  }
  createJoint(self2, other) {
    var _a2;
    if (this.axis && this.anchor)
      (_a2 = this.context.physics.engine) == null ? void 0 : _a2.addHingeJoint(self2, other, this.anchor, this.axis);
  }
};
__decorate59([
  serializable(Vector32)
], HingeJoint.prototype, "anchor", void 0);
__decorate59([
  serializable(Vector32)
], HingeJoint.prototype, "axis", void 0);

// node_modules/three/examples/jsm/controls/FlyControls.js
var _changeEvent3 = { type: "change" };
var _EPS2 = 1e-6;
var _tmpQuaternion = new Quaternion();
var FlyControls = class extends Controls {
  constructor(object, domElement = null) {
    super(object, domElement);
    this.movementSpeed = 1;
    this.rollSpeed = 5e-3;
    this.dragToLook = false;
    this.autoForward = false;
    this._moveState = { up: 0, down: 0, left: 0, right: 0, forward: 0, back: 0, pitchUp: 0, pitchDown: 0, yawLeft: 0, yawRight: 0, rollLeft: 0, rollRight: 0 };
    this._moveVector = new Vector32(0, 0, 0);
    this._rotationVector = new Vector32(0, 0, 0);
    this._lastQuaternion = new Quaternion();
    this._lastPosition = new Vector32();
    this._status = 0;
    this._onKeyDown = onKeyDown2.bind(this);
    this._onKeyUp = onKeyUp.bind(this);
    this._onPointerMove = onPointerMove3.bind(this);
    this._onPointerDown = onPointerDown3.bind(this);
    this._onPointerUp = onPointerUp3.bind(this);
    this._onPointerCancel = onPointerCancel.bind(this);
    this._onContextMenu = onContextMenu2.bind(this);
    if (domElement !== null) {
      this.connect();
    }
  }
  connect() {
    window.addEventListener("keydown", this._onKeyDown);
    window.addEventListener("keyup", this._onKeyUp);
    this.domElement.addEventListener("pointermove", this._onPointerMove);
    this.domElement.addEventListener("pointerdown", this._onPointerDown);
    this.domElement.addEventListener("pointerup", this._onPointerUp);
    this.domElement.addEventListener("pointercancel", this._onPointerCancel);
    this.domElement.addEventListener("contextmenu", this._onContextMenu);
  }
  disconnect() {
    window.removeEventListener("keydown", this._onKeyDown);
    window.removeEventListener("keyup", this._onKeyUp);
    this.domElement.removeEventListener("pointermove", this._onPointerMove);
    this.domElement.removeEventListener("pointerdown", this._onPointerDown);
    this.domElement.removeEventListener("pointerup", this._onPointerUp);
    this.domElement.removeEventListener("pointercancel", this._onPointerCancel);
    this.domElement.removeEventListener("contextmenu", this._onContextMenu);
  }
  dispose() {
    this.disconnect();
  }
  update(delta) {
    if (this.enabled === false)
      return;
    const object = this.object;
    const moveMult = delta * this.movementSpeed;
    const rotMult = delta * this.rollSpeed;
    object.translateX(this._moveVector.x * moveMult);
    object.translateY(this._moveVector.y * moveMult);
    object.translateZ(this._moveVector.z * moveMult);
    _tmpQuaternion.set(this._rotationVector.x * rotMult, this._rotationVector.y * rotMult, this._rotationVector.z * rotMult, 1).normalize();
    object.quaternion.multiply(_tmpQuaternion);
    if (this._lastPosition.distanceToSquared(object.position) > _EPS2 || 8 * (1 - this._lastQuaternion.dot(object.quaternion)) > _EPS2) {
      this.dispatchEvent(_changeEvent3);
      this._lastQuaternion.copy(object.quaternion);
      this._lastPosition.copy(object.position);
    }
  }
  // private
  _updateMovementVector() {
    const forward2 = this._moveState.forward || this.autoForward && !this._moveState.back ? 1 : 0;
    this._moveVector.x = -this._moveState.left + this._moveState.right;
    this._moveVector.y = -this._moveState.down + this._moveState.up;
    this._moveVector.z = -forward2 + this._moveState.back;
  }
  _updateRotationVector() {
    this._rotationVector.x = -this._moveState.pitchDown + this._moveState.pitchUp;
    this._rotationVector.y = -this._moveState.yawRight + this._moveState.yawLeft;
    this._rotationVector.z = -this._moveState.rollRight + this._moveState.rollLeft;
  }
  _getContainerDimensions() {
    if (this.domElement != document) {
      return {
        size: [this.domElement.offsetWidth, this.domElement.offsetHeight],
        offset: [this.domElement.offsetLeft, this.domElement.offsetTop]
      };
    } else {
      return {
        size: [window.innerWidth, window.innerHeight],
        offset: [0, 0]
      };
    }
  }
};
function onKeyDown2(event) {
  if (event.altKey || this.enabled === false) {
    return;
  }
  switch (event.code) {
    case "ShiftLeft":
    case "ShiftRight":
      this.movementSpeedMultiplier = 0.1;
      break;
    case "KeyW":
      this._moveState.forward = 1;
      break;
    case "KeyS":
      this._moveState.back = 1;
      break;
    case "KeyA":
      this._moveState.left = 1;
      break;
    case "KeyD":
      this._moveState.right = 1;
      break;
    case "KeyR":
      this._moveState.up = 1;
      break;
    case "KeyF":
      this._moveState.down = 1;
      break;
    case "ArrowUp":
      this._moveState.pitchUp = 1;
      break;
    case "ArrowDown":
      this._moveState.pitchDown = 1;
      break;
    case "ArrowLeft":
      this._moveState.yawLeft = 1;
      break;
    case "ArrowRight":
      this._moveState.yawRight = 1;
      break;
    case "KeyQ":
      this._moveState.rollLeft = 1;
      break;
    case "KeyE":
      this._moveState.rollRight = 1;
      break;
  }
  this._updateMovementVector();
  this._updateRotationVector();
}
function onKeyUp(event) {
  if (this.enabled === false)
    return;
  switch (event.code) {
    case "ShiftLeft":
    case "ShiftRight":
      this.movementSpeedMultiplier = 1;
      break;
    case "KeyW":
      this._moveState.forward = 0;
      break;
    case "KeyS":
      this._moveState.back = 0;
      break;
    case "KeyA":
      this._moveState.left = 0;
      break;
    case "KeyD":
      this._moveState.right = 0;
      break;
    case "KeyR":
      this._moveState.up = 0;
      break;
    case "KeyF":
      this._moveState.down = 0;
      break;
    case "ArrowUp":
      this._moveState.pitchUp = 0;
      break;
    case "ArrowDown":
      this._moveState.pitchDown = 0;
      break;
    case "ArrowLeft":
      this._moveState.yawLeft = 0;
      break;
    case "ArrowRight":
      this._moveState.yawRight = 0;
      break;
    case "KeyQ":
      this._moveState.rollLeft = 0;
      break;
    case "KeyE":
      this._moveState.rollRight = 0;
      break;
  }
  this._updateMovementVector();
  this._updateRotationVector();
}
function onPointerDown3(event) {
  if (this.enabled === false)
    return;
  if (this.dragToLook) {
    this._status++;
  } else {
    switch (event.button) {
      case 0:
        this._moveState.forward = 1;
        break;
      case 2:
        this._moveState.back = 1;
        break;
    }
    this._updateMovementVector();
  }
}
function onPointerMove3(event) {
  if (this.enabled === false)
    return;
  if (!this.dragToLook || this._status > 0) {
    const container = this._getContainerDimensions();
    const halfWidth = container.size[0] / 2;
    const halfHeight = container.size[1] / 2;
    this._moveState.yawLeft = -(event.pageX - container.offset[0] - halfWidth) / halfWidth;
    this._moveState.pitchDown = (event.pageY - container.offset[1] - halfHeight) / halfHeight;
    this._updateRotationVector();
  }
}
function onPointerUp3(event) {
  if (this.enabled === false)
    return;
  if (this.dragToLook) {
    this._status--;
    this._moveState.yawLeft = this._moveState.pitchDown = 0;
  } else {
    switch (event.button) {
      case 0:
        this._moveState.forward = 0;
        break;
      case 2:
        this._moveState.back = 0;
        break;
    }
    this._updateMovementVector();
  }
  this._updateRotationVector();
}
function onPointerCancel() {
  if (this.enabled === false)
    return;
  if (this.dragToLook) {
    this._status = 0;
    this._moveState.yawLeft = this._moveState.pitchDown = 0;
  } else {
    this._moveState.forward = 0;
    this._moveState.back = 0;
    this._updateMovementVector();
  }
  this._updateRotationVector();
}
function onContextMenu2(event) {
  if (this.enabled === false)
    return;
  event.preventDefault();
}

// node_modules/@needle-tools/engine/lib/engine-components/FlyControls.js
var FlyControls2 = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "_controls", null);
  }
  onEnable() {
    var _a2;
    const cam = (_a2 = GameObject.getComponent(this.gameObject, Camera2)) == null ? void 0 : _a2.threeCamera;
    if (!cam) {
      console.warn("FlyControls: Requires a Camera component on the same object as this component.");
      return;
    }
    this._controls = new FlyControls(cam, this.context.renderer.domElement);
    this._controls.rollSpeed = 0.5;
    this._controls.movementSpeed = 3;
    this._controls.dragToLook = true;
  }
  onDisable() {
    var _a2;
    (_a2 = this._controls) == null ? void 0 : _a2.dispose();
    this._controls = null;
  }
  update() {
    if (this._controls)
      this._controls.update(this.context.time.deltaTime);
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/Fog.js
var __decorate60 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var FogMode;
(function(FogMode2) {
  FogMode2[FogMode2["Linear"] = 1] = "Linear";
  FogMode2[FogMode2["Exponential"] = 2] = "Exponential";
  FogMode2[FogMode2["ExponentialSquared"] = 3] = "ExponentialSquared";
})(FogMode || (FogMode = {}));
var Fog2 = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "_fog");
  }
  get fog() {
    if (!this._fog)
      this._fog = new Fog(0, 0, 50);
    return this._fog;
  }
  get mode() {
    return FogMode.Linear;
  }
  set near(value) {
    this.fog.near = value;
  }
  get near() {
    return this.fog.near;
  }
  set far(value) {
    this.fog.far = value;
  }
  get far() {
    return this.fog.far;
  }
  set color(value) {
    this.fog.color.copy(value);
  }
  get color() {
    return this.fog.color;
  }
  onEnable() {
    this.scene.fog = this.fog;
  }
  onDisable() {
    if (this.scene.fog === this._fog)
      this.scene.fog = null;
  }
};
__decorate60([
  serializable()
], Fog2.prototype, "near", null);
__decorate60([
  serializable()
], Fog2.prototype, "far", null);
__decorate60([
  serializable(Color)
], Fog2.prototype, "color", null);

// node_modules/three/examples/jsm/utils/TextureUtils.js
var _renderer2;
var fullscreenQuadGeometry2;
var fullscreenQuadMaterial2;
var fullscreenQuad2;
function decompress(texture, maxTextureSize = Infinity, renderer = null) {
  if (!fullscreenQuadGeometry2)
    fullscreenQuadGeometry2 = new PlaneGeometry(2, 2, 1, 1);
  if (!fullscreenQuadMaterial2)
    fullscreenQuadMaterial2 = new ShaderMaterial({
      uniforms: { blitTexture: new Uniform$1(texture) },
      vertexShader: `
			varying vec2 vUv;
			void main(){
				vUv = uv;
				gl_Position = vec4(position.xy * 1.0,0.,.999999);
			}`,
      fragmentShader: `
			uniform sampler2D blitTexture; 
			varying vec2 vUv;

			void main(){ 
				gl_FragColor = vec4(vUv.xy, 0, 1);
				
				#ifdef IS_SRGB
				gl_FragColor = sRGBTransferOETF( texture2D( blitTexture, vUv) );
				#else
				gl_FragColor = texture2D( blitTexture, vUv);
				#endif
			}`
    });
  fullscreenQuadMaterial2.uniforms.blitTexture.value = texture;
  fullscreenQuadMaterial2.defines.IS_SRGB = texture.colorSpace == SRGBColorSpace;
  fullscreenQuadMaterial2.needsUpdate = true;
  if (!fullscreenQuad2) {
    fullscreenQuad2 = new Mesh(fullscreenQuadGeometry2, fullscreenQuadMaterial2);
    fullscreenQuad2.frustumCulled = false;
  }
  const _camera2 = new PerspectiveCamera();
  const _scene = new Scene();
  _scene.add(fullscreenQuad2);
  if (renderer === null) {
    renderer = _renderer2 = new WebGLRenderer({ antialias: false });
  }
  const width = Math.min(texture.image.width, maxTextureSize);
  const height = Math.min(texture.image.height, maxTextureSize);
  renderer.setSize(width, height);
  renderer.clear();
  renderer.render(_scene, _camera2);
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("2d");
  canvas.width = width;
  canvas.height = height;
  context.drawImage(renderer.domElement, 0, 0, width, height);
  const readableTexture = new CanvasTexture(canvas);
  readableTexture.minFilter = texture.minFilter;
  readableTexture.magFilter = texture.magFilter;
  readableTexture.wrapS = texture.wrapS;
  readableTexture.wrapT = texture.wrapT;
  readableTexture.colorSpace = texture.colorSpace;
  readableTexture.name = texture.name;
  if (_renderer2) {
    _renderer2.forceContextLoss();
    _renderer2.dispose();
    _renderer2 = null;
  }
  return readableTexture;
}

// node_modules/three/examples/jsm/exporters/GLTFExporter.js
var KHR_mesh_quantization_ExtraAttrTypes = {
  POSITION: [
    "byte",
    "byte normalized",
    "unsigned byte",
    "unsigned byte normalized",
    "short",
    "short normalized",
    "unsigned short",
    "unsigned short normalized"
  ],
  NORMAL: [
    "byte normalized",
    "short normalized"
  ],
  TANGENT: [
    "byte normalized",
    "short normalized"
  ],
  TEXCOORD: [
    "byte",
    "byte normalized",
    "unsigned byte",
    "short",
    "short normalized",
    "unsigned short"
  ]
};
var GLTFExporter = class {
  constructor() {
    this.pluginCallbacks = [];
    this.register(function(writer) {
      return new GLTFLightExtension(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsUnlitExtension2(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsTransmissionExtension2(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsVolumeExtension2(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsIorExtension2(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsSpecularExtension2(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsClearcoatExtension2(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsDispersionExtension2(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsIridescenceExtension2(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsSheenExtension2(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsAnisotropyExtension2(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsEmissiveStrengthExtension2(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsBumpExtension2(writer);
    });
    this.register(function(writer) {
      return new GLTFMeshGpuInstancing2(writer);
    });
  }
  register(callback) {
    if (this.pluginCallbacks.indexOf(callback) === -1) {
      this.pluginCallbacks.push(callback);
    }
    return this;
  }
  unregister(callback) {
    if (this.pluginCallbacks.indexOf(callback) !== -1) {
      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
    }
    return this;
  }
  /**
   * Parse scenes and generate GLTF output
   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
   * @param  {Function} onDone  Callback on completed
   * @param  {Function} onError  Callback on errors
   * @param  {Object} options options
   */
  parse(input, onDone, onError2, options) {
    const writer = new GLTFWriter();
    const plugins2 = [];
    for (let i = 0, il = this.pluginCallbacks.length; i < il; i++) {
      plugins2.push(this.pluginCallbacks[i](writer));
    }
    writer.setPlugins(plugins2);
    writer.write(input, onDone, options).catch(onError2);
  }
  parseAsync(input, options) {
    const scope = this;
    return new Promise(function(resolve2, reject) {
      scope.parse(input, resolve2, reject, options);
    });
  }
};
var WEBGL_CONSTANTS2 = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  BYTE: 5120,
  UNSIGNED_BYTE: 5121,
  SHORT: 5122,
  UNSIGNED_SHORT: 5123,
  INT: 5124,
  UNSIGNED_INT: 5125,
  FLOAT: 5126,
  ARRAY_BUFFER: 34962,
  ELEMENT_ARRAY_BUFFER: 34963,
  NEAREST: 9728,
  LINEAR: 9729,
  NEAREST_MIPMAP_NEAREST: 9984,
  LINEAR_MIPMAP_NEAREST: 9985,
  NEAREST_MIPMAP_LINEAR: 9986,
  LINEAR_MIPMAP_LINEAR: 9987,
  CLAMP_TO_EDGE: 33071,
  MIRRORED_REPEAT: 33648,
  REPEAT: 10497
};
var KHR_MESH_QUANTIZATION = "KHR_mesh_quantization";
var THREE_TO_WEBGL = {};
THREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS2.NEAREST;
THREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS2.NEAREST_MIPMAP_NEAREST;
THREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS2.NEAREST_MIPMAP_LINEAR;
THREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS2.LINEAR;
THREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS2.LINEAR_MIPMAP_NEAREST;
THREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS2.LINEAR_MIPMAP_LINEAR;
THREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS2.CLAMP_TO_EDGE;
THREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS2.REPEAT;
THREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS2.MIRRORED_REPEAT;
var PATH_PROPERTIES2 = {
  scale: "scale",
  position: "translation",
  quaternion: "rotation",
  morphTargetInfluences: "weights"
};
var DEFAULT_SPECULAR_COLOR = new Color();
var GLB_HEADER_BYTES = 12;
var GLB_HEADER_MAGIC = 1179937895;
var GLB_VERSION = 2;
var GLB_CHUNK_PREFIX_BYTES = 8;
var GLB_CHUNK_TYPE_JSON = 1313821514;
var GLB_CHUNK_TYPE_BIN = 5130562;
function equalArray(array1, array2) {
  return array1.length === array2.length && array1.every(function(element, index) {
    return element === array2[index];
  });
}
function stringToArrayBuffer(text) {
  return new TextEncoder().encode(text).buffer;
}
function isIdentityMatrix(matrix) {
  return equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
}
function getMinMax(attribute, start, count) {
  const output = {
    min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),
    max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)
  };
  for (let i = start; i < start + count; i++) {
    for (let a = 0; a < attribute.itemSize; a++) {
      let value;
      if (attribute.itemSize > 4) {
        value = attribute.array[i * attribute.itemSize + a];
      } else {
        if (a === 0)
          value = attribute.getX(i);
        else if (a === 1)
          value = attribute.getY(i);
        else if (a === 2)
          value = attribute.getZ(i);
        else if (a === 3)
          value = attribute.getW(i);
        if (attribute.normalized === true) {
          value = MathUtils.normalize(value, attribute.array);
        }
      }
      output.min[a] = Math.min(output.min[a], value);
      output.max[a] = Math.max(output.max[a], value);
    }
  }
  return output;
}
function getPaddedBufferSize(bufferSize) {
  return Math.ceil(bufferSize / 4) * 4;
}
function getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {
  const paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);
  if (paddedLength !== arrayBuffer.byteLength) {
    const array = new Uint8Array(paddedLength);
    array.set(new Uint8Array(arrayBuffer));
    if (paddingByte !== 0) {
      for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {
        array[i] = paddingByte;
      }
    }
    return array.buffer;
  }
  return arrayBuffer;
}
function getCanvas() {
  if (typeof document === "undefined" && typeof OffscreenCanvas !== "undefined") {
    return new OffscreenCanvas(1, 1);
  }
  return document.createElement("canvas");
}
function getToBlobPromise(canvas, mimeType) {
  if (canvas.toBlob !== void 0) {
    return new Promise((resolve2) => canvas.toBlob(resolve2, mimeType));
  }
  let quality;
  if (mimeType === "image/jpeg") {
    quality = 0.92;
  } else if (mimeType === "image/webp") {
    quality = 0.8;
  }
  return canvas.convertToBlob({
    type: mimeType,
    quality
  });
}
var GLTFWriter = class {
  constructor() {
    this.plugins = [];
    this.options = {};
    this.pending = [];
    this.buffers = [];
    this.byteOffset = 0;
    this.buffers = [];
    this.nodeMap = /* @__PURE__ */ new Map();
    this.skins = [];
    this.extensionsUsed = {};
    this.extensionsRequired = {};
    this.uids = /* @__PURE__ */ new Map();
    this.uid = 0;
    this.json = {
      asset: {
        version: "2.0",
        generator: "THREE.GLTFExporter r" + REVISION
      }
    };
    this.cache = {
      meshes: /* @__PURE__ */ new Map(),
      attributes: /* @__PURE__ */ new Map(),
      attributesNormalized: /* @__PURE__ */ new Map(),
      materials: /* @__PURE__ */ new Map(),
      textures: /* @__PURE__ */ new Map(),
      images: /* @__PURE__ */ new Map()
    };
  }
  setPlugins(plugins2) {
    this.plugins = plugins2;
  }
  /**
   * Parse scenes and generate GLTF output
   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
   * @param  {Function} onDone  Callback on completed
   * @param  {Object} options options
   */
  async write(input, onDone, options = {}) {
    this.options = Object.assign({
      // default options
      binary: false,
      trs: false,
      onlyVisible: true,
      maxTextureSize: Infinity,
      animations: [],
      includeCustomExtensions: false
    }, options);
    if (this.options.animations.length > 0) {
      this.options.trs = true;
    }
    this.processInput(input);
    await Promise.all(this.pending);
    const writer = this;
    const buffers = writer.buffers;
    const json = writer.json;
    options = writer.options;
    const extensionsUsed = writer.extensionsUsed;
    const extensionsRequired = writer.extensionsRequired;
    const blob = new Blob(buffers, { type: "application/octet-stream" });
    const extensionsUsedList = Object.keys(extensionsUsed);
    const extensionsRequiredList = Object.keys(extensionsRequired);
    if (extensionsUsedList.length > 0)
      json.extensionsUsed = extensionsUsedList;
    if (extensionsRequiredList.length > 0)
      json.extensionsRequired = extensionsRequiredList;
    if (json.buffers && json.buffers.length > 0)
      json.buffers[0].byteLength = blob.size;
    if (options.binary === true) {
      const reader = new FileReader();
      reader.readAsArrayBuffer(blob);
      reader.onloadend = function() {
        const binaryChunk = getPaddedArrayBuffer(reader.result);
        const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));
        binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);
        binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true);
        const jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 32);
        const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));
        jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);
        jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true);
        const header = new ArrayBuffer(GLB_HEADER_BYTES);
        const headerView = new DataView(header);
        headerView.setUint32(0, GLB_HEADER_MAGIC, true);
        headerView.setUint32(4, GLB_VERSION, true);
        const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;
        headerView.setUint32(8, totalByteLength, true);
        const glbBlob = new Blob([
          header,
          jsonChunkPrefix,
          jsonChunk,
          binaryChunkPrefix,
          binaryChunk
        ], { type: "application/octet-stream" });
        const glbReader = new FileReader();
        glbReader.readAsArrayBuffer(glbBlob);
        glbReader.onloadend = function() {
          onDone(glbReader.result);
        };
      };
    } else {
      if (json.buffers && json.buffers.length > 0) {
        const reader = new FileReader();
        reader.readAsDataURL(blob);
        reader.onloadend = function() {
          const base64data = reader.result;
          json.buffers[0].uri = base64data;
          onDone(json);
        };
      } else {
        onDone(json);
      }
    }
  }
  /**
   * Serializes a userData.
   *
   * @param {THREE.Object3D|THREE.Material} object
   * @param {Object} objectDef
   */
  serializeUserData(object, objectDef) {
    if (Object.keys(object.userData).length === 0)
      return;
    const options = this.options;
    const extensionsUsed = this.extensionsUsed;
    try {
      const json = JSON.parse(JSON.stringify(object.userData));
      if (options.includeCustomExtensions && json.gltfExtensions) {
        if (objectDef.extensions === void 0)
          objectDef.extensions = {};
        for (const extensionName in json.gltfExtensions) {
          objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];
          extensionsUsed[extensionName] = true;
        }
        delete json.gltfExtensions;
      }
      if (Object.keys(json).length > 0)
        objectDef.extras = json;
    } catch (error) {
      console.warn("THREE.GLTFExporter: userData of '" + object.name + "' won't be serialized because of JSON.stringify error - " + error.message);
    }
  }
  /**
   * Returns ids for buffer attributes.
   * @param  {Object} object
   * @return {Integer}
   */
  getUID(attribute, isRelativeCopy = false) {
    if (this.uids.has(attribute) === false) {
      const uids2 = /* @__PURE__ */ new Map();
      uids2.set(true, this.uid++);
      uids2.set(false, this.uid++);
      this.uids.set(attribute, uids2);
    }
    const uids = this.uids.get(attribute);
    return uids.get(isRelativeCopy);
  }
  /**
   * Checks if normal attribute values are normalized.
   *
   * @param {BufferAttribute} normal
   * @returns {Boolean}
   */
  isNormalizedNormalAttribute(normal) {
    const cache = this.cache;
    if (cache.attributesNormalized.has(normal))
      return false;
    const v4 = new Vector32();
    for (let i = 0, il = normal.count; i < il; i++) {
      if (Math.abs(v4.fromBufferAttribute(normal, i).length() - 1) > 5e-4)
        return false;
    }
    return true;
  }
  /**
   * Creates normalized normal buffer attribute.
   *
   * @param {BufferAttribute} normal
   * @returns {BufferAttribute}
   *
   */
  createNormalizedNormalAttribute(normal) {
    const cache = this.cache;
    if (cache.attributesNormalized.has(normal))
      return cache.attributesNormalized.get(normal);
    const attribute = normal.clone();
    const v4 = new Vector32();
    for (let i = 0, il = attribute.count; i < il; i++) {
      v4.fromBufferAttribute(attribute, i);
      if (v4.x === 0 && v4.y === 0 && v4.z === 0) {
        v4.setX(1);
      } else {
        v4.normalize();
      }
      attribute.setXYZ(i, v4.x, v4.y, v4.z);
    }
    cache.attributesNormalized.set(normal, attribute);
    return attribute;
  }
  /**
   * Applies a texture transform, if present, to the map definition. Requires
   * the KHR_texture_transform extension.
   *
   * @param {Object} mapDef
   * @param {THREE.Texture} texture
   */
  applyTextureTransform(mapDef, texture) {
    let didTransform = false;
    const transformDef = {};
    if (texture.offset.x !== 0 || texture.offset.y !== 0) {
      transformDef.offset = texture.offset.toArray();
      didTransform = true;
    }
    if (texture.rotation !== 0) {
      transformDef.rotation = texture.rotation;
      didTransform = true;
    }
    if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {
      transformDef.scale = texture.repeat.toArray();
      didTransform = true;
    }
    if (didTransform) {
      mapDef.extensions = mapDef.extensions || {};
      mapDef.extensions["KHR_texture_transform"] = transformDef;
      this.extensionsUsed["KHR_texture_transform"] = true;
    }
  }
  buildMetalRoughTexture(metalnessMap, roughnessMap) {
    if (metalnessMap === roughnessMap)
      return metalnessMap;
    function getEncodingConversion(map) {
      if (map.colorSpace === SRGBColorSpace) {
        return function SRGBToLinear(c2) {
          return c2 < 0.04045 ? c2 * 0.0773993808 : Math.pow(c2 * 0.9478672986 + 0.0521327014, 2.4);
        };
      }
      return function LinearToLinear(c2) {
        return c2;
      };
    }
    console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.");
    if (metalnessMap instanceof CompressedTexture) {
      metalnessMap = decompress(metalnessMap);
    }
    if (roughnessMap instanceof CompressedTexture) {
      roughnessMap = decompress(roughnessMap);
    }
    const metalness = metalnessMap ? metalnessMap.image : null;
    const roughness = roughnessMap ? roughnessMap.image : null;
    const width = Math.max(metalness ? metalness.width : 0, roughness ? roughness.width : 0);
    const height = Math.max(metalness ? metalness.height : 0, roughness ? roughness.height : 0);
    const canvas = getCanvas();
    canvas.width = width;
    canvas.height = height;
    const context = canvas.getContext("2d", {
      willReadFrequently: true
    });
    context.fillStyle = "#00ffff";
    context.fillRect(0, 0, width, height);
    const composite = context.getImageData(0, 0, width, height);
    if (metalness) {
      context.drawImage(metalness, 0, 0, width, height);
      const convert = getEncodingConversion(metalnessMap);
      const data = context.getImageData(0, 0, width, height).data;
      for (let i = 2; i < data.length; i += 4) {
        composite.data[i] = convert(data[i] / 256) * 256;
      }
    }
    if (roughness) {
      context.drawImage(roughness, 0, 0, width, height);
      const convert = getEncodingConversion(roughnessMap);
      const data = context.getImageData(0, 0, width, height).data;
      for (let i = 1; i < data.length; i += 4) {
        composite.data[i] = convert(data[i] / 256) * 256;
      }
    }
    context.putImageData(composite, 0, 0);
    const reference = metalnessMap || roughnessMap;
    const texture = reference.clone();
    texture.source = new Source(canvas);
    texture.colorSpace = NoColorSpace;
    texture.channel = (metalnessMap || roughnessMap).channel;
    if (metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel) {
      console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.");
    }
    return texture;
  }
  /**
   * Process a buffer to append to the default one.
   * @param  {ArrayBuffer} buffer
   * @return {Integer}
   */
  processBuffer(buffer2) {
    const json = this.json;
    const buffers = this.buffers;
    if (!json.buffers)
      json.buffers = [{ byteLength: 0 }];
    buffers.push(buffer2);
    return 0;
  }
  /**
   * Process and generate a BufferView
   * @param  {BufferAttribute} attribute
   * @param  {number} componentType
   * @param  {number} start
   * @param  {number} count
   * @param  {number} target (Optional) Target usage of the BufferView
   * @return {Object}
   */
  processBufferView(attribute, componentType, start, count, target) {
    const json = this.json;
    if (!json.bufferViews)
      json.bufferViews = [];
    let componentSize;
    switch (componentType) {
      case WEBGL_CONSTANTS2.BYTE:
      case WEBGL_CONSTANTS2.UNSIGNED_BYTE:
        componentSize = 1;
        break;
      case WEBGL_CONSTANTS2.SHORT:
      case WEBGL_CONSTANTS2.UNSIGNED_SHORT:
        componentSize = 2;
        break;
      default:
        componentSize = 4;
    }
    let byteStride = attribute.itemSize * componentSize;
    if (target === WEBGL_CONSTANTS2.ARRAY_BUFFER) {
      byteStride = Math.ceil(byteStride / 4) * 4;
    }
    const byteLength = getPaddedBufferSize(count * byteStride);
    const dataView = new DataView(new ArrayBuffer(byteLength));
    let offset = 0;
    for (let i = start; i < start + count; i++) {
      for (let a = 0; a < attribute.itemSize; a++) {
        let value;
        if (attribute.itemSize > 4) {
          value = attribute.array[i * attribute.itemSize + a];
        } else {
          if (a === 0)
            value = attribute.getX(i);
          else if (a === 1)
            value = attribute.getY(i);
          else if (a === 2)
            value = attribute.getZ(i);
          else if (a === 3)
            value = attribute.getW(i);
          if (attribute.normalized === true) {
            value = MathUtils.normalize(value, attribute.array);
          }
        }
        if (componentType === WEBGL_CONSTANTS2.FLOAT) {
          dataView.setFloat32(offset, value, true);
        } else if (componentType === WEBGL_CONSTANTS2.INT) {
          dataView.setInt32(offset, value, true);
        } else if (componentType === WEBGL_CONSTANTS2.UNSIGNED_INT) {
          dataView.setUint32(offset, value, true);
        } else if (componentType === WEBGL_CONSTANTS2.SHORT) {
          dataView.setInt16(offset, value, true);
        } else if (componentType === WEBGL_CONSTANTS2.UNSIGNED_SHORT) {
          dataView.setUint16(offset, value, true);
        } else if (componentType === WEBGL_CONSTANTS2.BYTE) {
          dataView.setInt8(offset, value);
        } else if (componentType === WEBGL_CONSTANTS2.UNSIGNED_BYTE) {
          dataView.setUint8(offset, value);
        }
        offset += componentSize;
      }
      if (offset % byteStride !== 0) {
        offset += byteStride - offset % byteStride;
      }
    }
    const bufferViewDef = {
      buffer: this.processBuffer(dataView.buffer),
      byteOffset: this.byteOffset,
      byteLength
    };
    if (target !== void 0)
      bufferViewDef.target = target;
    if (target === WEBGL_CONSTANTS2.ARRAY_BUFFER) {
      bufferViewDef.byteStride = byteStride;
    }
    this.byteOffset += byteLength;
    json.bufferViews.push(bufferViewDef);
    const output = {
      id: json.bufferViews.length - 1,
      byteLength: 0
    };
    return output;
  }
  /**
   * Process and generate a BufferView from an image Blob.
   * @param {Blob} blob
   * @return {Promise<Integer>}
   */
  processBufferViewImage(blob) {
    const writer = this;
    const json = writer.json;
    if (!json.bufferViews)
      json.bufferViews = [];
    return new Promise(function(resolve2) {
      const reader = new FileReader();
      reader.readAsArrayBuffer(blob);
      reader.onloadend = function() {
        const buffer2 = getPaddedArrayBuffer(reader.result);
        const bufferViewDef = {
          buffer: writer.processBuffer(buffer2),
          byteOffset: writer.byteOffset,
          byteLength: buffer2.byteLength
        };
        writer.byteOffset += buffer2.byteLength;
        resolve2(json.bufferViews.push(bufferViewDef) - 1);
      };
    });
  }
  /**
   * Process attribute to generate an accessor
   * @param  {BufferAttribute} attribute Attribute to process
   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range
   * @param  {Integer} start (Optional)
   * @param  {Integer} count (Optional)
   * @return {Integer|null} Index of the processed accessor on the "accessors" array
   */
  processAccessor(attribute, geometry, start, count) {
    const json = this.json;
    const types = {
      1: "SCALAR",
      2: "VEC2",
      3: "VEC3",
      4: "VEC4",
      9: "MAT3",
      16: "MAT4"
    };
    let componentType;
    if (attribute.array.constructor === Float32Array) {
      componentType = WEBGL_CONSTANTS2.FLOAT;
    } else if (attribute.array.constructor === Int32Array) {
      componentType = WEBGL_CONSTANTS2.INT;
    } else if (attribute.array.constructor === Uint32Array) {
      componentType = WEBGL_CONSTANTS2.UNSIGNED_INT;
    } else if (attribute.array.constructor === Int16Array) {
      componentType = WEBGL_CONSTANTS2.SHORT;
    } else if (attribute.array.constructor === Uint16Array) {
      componentType = WEBGL_CONSTANTS2.UNSIGNED_SHORT;
    } else if (attribute.array.constructor === Int8Array) {
      componentType = WEBGL_CONSTANTS2.BYTE;
    } else if (attribute.array.constructor === Uint8Array) {
      componentType = WEBGL_CONSTANTS2.UNSIGNED_BYTE;
    } else {
      throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type: " + attribute.array.constructor.name);
    }
    if (start === void 0)
      start = 0;
    if (count === void 0 || count === Infinity)
      count = attribute.count;
    if (count === 0)
      return null;
    const minMax = getMinMax(attribute, start, count);
    let bufferViewTarget;
    if (geometry !== void 0) {
      bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS2.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS2.ARRAY_BUFFER;
    }
    const bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);
    const accessorDef = {
      bufferView: bufferView.id,
      byteOffset: bufferView.byteOffset,
      componentType,
      count,
      max: minMax.max,
      min: minMax.min,
      type: types[attribute.itemSize]
    };
    if (attribute.normalized === true)
      accessorDef.normalized = true;
    if (!json.accessors)
      json.accessors = [];
    return json.accessors.push(accessorDef) - 1;
  }
  /**
   * Process image
   * @param  {Image} image to process
   * @param  {Integer} format of the image (RGBAFormat)
   * @param  {Boolean} flipY before writing out the image
   * @param  {String} mimeType export format
   * @return {Integer}     Index of the processed texture in the "images" array
   */
  processImage(image, format, flipY, mimeType = "image/png") {
    if (image !== null) {
      const writer = this;
      const cache = writer.cache;
      const json = writer.json;
      const options = writer.options;
      const pending = writer.pending;
      if (!cache.images.has(image))
        cache.images.set(image, {});
      const cachedImages = cache.images.get(image);
      const key = mimeType + ":flipY/" + flipY.toString();
      if (cachedImages[key] !== void 0)
        return cachedImages[key];
      if (!json.images)
        json.images = [];
      const imageDef = { mimeType };
      const canvas = getCanvas();
      canvas.width = Math.min(image.width, options.maxTextureSize);
      canvas.height = Math.min(image.height, options.maxTextureSize);
      const ctx = canvas.getContext("2d", {
        willReadFrequently: true
      });
      if (flipY === true) {
        ctx.translate(0, canvas.height);
        ctx.scale(1, -1);
      }
      if (image.data !== void 0) {
        if (format !== RGBAFormat) {
          console.error("GLTFExporter: Only RGBAFormat is supported.", format);
        }
        if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {
          console.warn("GLTFExporter: Image size is bigger than maxTextureSize", image);
        }
        const data = new Uint8ClampedArray(image.height * image.width * 4);
        for (let i = 0; i < data.length; i += 4) {
          data[i + 0] = image.data[i + 0];
          data[i + 1] = image.data[i + 1];
          data[i + 2] = image.data[i + 2];
          data[i + 3] = image.data[i + 3];
        }
        ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);
      } else {
        if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap || typeof OffscreenCanvas !== "undefined" && image instanceof OffscreenCanvas) {
          ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
        } else {
          throw new Error("THREE.GLTFExporter: Invalid image type. Use HTMLImageElement, HTMLCanvasElement, ImageBitmap or OffscreenCanvas.");
        }
      }
      if (options.binary === true) {
        pending.push(
          getToBlobPromise(canvas, mimeType).then((blob) => writer.processBufferViewImage(blob)).then((bufferViewIndex) => {
            imageDef.bufferView = bufferViewIndex;
          })
        );
      } else {
        if (canvas.toDataURL !== void 0) {
          imageDef.uri = canvas.toDataURL(mimeType);
        } else {
          pending.push(
            getToBlobPromise(canvas, mimeType).then((blob) => new FileReader().readAsDataURL(blob)).then((dataURL) => {
              imageDef.uri = dataURL;
            })
          );
        }
      }
      const index = json.images.push(imageDef) - 1;
      cachedImages[key] = index;
      return index;
    } else {
      throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.");
    }
  }
  /**
   * Process sampler
   * @param  {Texture} map Texture to process
   * @return {Integer}     Index of the processed texture in the "samplers" array
   */
  processSampler(map) {
    const json = this.json;
    if (!json.samplers)
      json.samplers = [];
    const samplerDef = {
      magFilter: THREE_TO_WEBGL[map.magFilter],
      minFilter: THREE_TO_WEBGL[map.minFilter],
      wrapS: THREE_TO_WEBGL[map.wrapS],
      wrapT: THREE_TO_WEBGL[map.wrapT]
    };
    return json.samplers.push(samplerDef) - 1;
  }
  /**
   * Process texture
   * @param  {Texture} map Map to process
   * @return {Integer} Index of the processed texture in the "textures" array
   */
  processTexture(map) {
    const writer = this;
    const options = writer.options;
    const cache = this.cache;
    const json = this.json;
    if (cache.textures.has(map))
      return cache.textures.get(map);
    const beforeWriteArgs = { keep: true, newTexture: null };
    this._invokeAll(function(ext) {
      ext.beforeWriteTexture && ext.beforeWriteTexture(map, beforeWriteArgs);
    });
    if (beforeWriteArgs.keep === false)
      return null;
    if (beforeWriteArgs.newTexture != null)
      map = beforeWriteArgs.newTexture;
    if (!json.textures)
      json.textures = [];
    if (map instanceof CompressedTexture) {
      map = decompress(map, options.maxTextureSize);
    }
    let mimeType = map.userData.mimeType;
    if (mimeType === "image/webp")
      mimeType = "image/png";
    const textureDef = {
      sampler: this.processSampler(map),
      source: this.processImage(map.image, map.format, map.flipY, mimeType)
    };
    if (map.name)
      textureDef.name = map.name;
    this._invokeAll(function(ext) {
      ext.writeTexture && ext.writeTexture(map, textureDef);
    });
    const index = json.textures.push(textureDef) - 1;
    cache.textures.set(map, index);
    return index;
  }
  /**
   * Process material
   * @param  {THREE.Material} material Material to process
   * @return {Integer|null} Index of the processed material in the "materials" array
   */
  processMaterial(material) {
    var _a2, _b, _c, _d, _e;
    const cache = this.cache;
    const json = this.json;
    if (cache.materials.has(material))
      return cache.materials.get(material);
    if (material.isShaderMaterial) {
      console.warn("GLTFExporter: THREE.ShaderMaterial not supported.");
      return null;
    }
    if (!json.materials)
      json.materials = [];
    const materialDef = { pbrMetallicRoughness: {} };
    if (material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true) {
      console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
    }
    const color2 = material.color.toArray().concat([material.opacity]);
    if (!equalArray(color2, [1, 1, 1, 1])) {
      materialDef.pbrMetallicRoughness.baseColorFactor = color2;
    }
    if (material.isMeshStandardMaterial) {
      materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;
      materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;
    } else {
      materialDef.pbrMetallicRoughness.metallicFactor = 0.5;
      materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;
    }
    const metalnessMap = ((_a2 = material.metalnessMap) == null ? void 0 : _a2.image) ? material.metalnessMap : void 0;
    const roughnessMap = ((_b = material.roughnessMap) == null ? void 0 : _b.image) ? material.roughnessMap : void 0;
    if (metalnessMap || roughnessMap) {
      const metalRoughTexture = this.buildMetalRoughTexture(metalnessMap, roughnessMap);
      const metalRoughMapDef = {
        index: this.processTexture(metalRoughTexture),
        channel: metalRoughTexture.channel
      };
      this.applyTextureTransform(metalRoughMapDef, metalRoughTexture);
      materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;
    }
    if (material.map) {
      const baseColorMapDef = {
        index: this.processTexture(material.map),
        texCoord: material.map.channel
      };
      this.applyTextureTransform(baseColorMapDef, material.map);
      materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;
    }
    if (material.emissive) {
      const emissive = material.emissive;
      const maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);
      if (maxEmissiveComponent > 0) {
        materialDef.emissiveFactor = material.emissive.toArray();
      }
      if ((_c = material.emissiveMap) == null ? void 0 : _c.image) {
        const emissiveMapDef = {
          index: this.processTexture(material.emissiveMap),
          texCoord: material.emissiveMap.channel
        };
        this.applyTextureTransform(emissiveMapDef, material.emissiveMap);
        materialDef.emissiveTexture = emissiveMapDef;
      }
    }
    if ((_d = material.normalMap) == null ? void 0 : _d.image) {
      const normalMapDef = {
        index: this.processTexture(material.normalMap),
        texCoord: material.normalMap.channel
      };
      if (material.normalScale && material.normalScale.x !== 1) {
        normalMapDef.scale = material.normalScale.x;
      }
      this.applyTextureTransform(normalMapDef, material.normalMap);
      materialDef.normalTexture = normalMapDef;
    }
    if ((_e = material.aoMap) == null ? void 0 : _e.image) {
      const occlusionMapDef = {
        index: this.processTexture(material.aoMap),
        texCoord: material.aoMap.channel
      };
      if (material.aoMapIntensity !== 1) {
        occlusionMapDef.strength = material.aoMapIntensity;
      }
      this.applyTextureTransform(occlusionMapDef, material.aoMap);
      materialDef.occlusionTexture = occlusionMapDef;
    }
    if (material.transparent) {
      materialDef.alphaMode = "BLEND";
    } else {
      if (material.alphaTest > 0) {
        materialDef.alphaMode = "MASK";
        materialDef.alphaCutoff = material.alphaTest;
      }
    }
    if (material.side === DoubleSide)
      materialDef.doubleSided = true;
    if (material.name !== "")
      materialDef.name = material.name;
    this.serializeUserData(material, materialDef);
    this._invokeAll(function(ext) {
      ext.writeMaterial && ext.writeMaterial(material, materialDef);
    });
    const index = json.materials.push(materialDef) - 1;
    cache.materials.set(material, index);
    return index;
  }
  /**
   * Process mesh
   * @param  {THREE.Mesh} mesh Mesh to process
   * @return {Integer|null} Index of the processed mesh in the "meshes" array
   */
  processMesh(mesh) {
    const beforeWriteArgs = { keep: true };
    this._invokeAll(function(ext) {
      ext.beforeWriteMesh && ext.beforeWriteMesh(mesh, beforeWriteArgs);
    });
    if (beforeWriteArgs.keep != true) {
      return null;
    }
    const cache = this.cache;
    const json = this.json;
    const meshCacheKeyParts = [mesh.geometry.uuid];
    if (Array.isArray(mesh.material)) {
      for (let i = 0, l = mesh.material.length; i < l; i++) {
        meshCacheKeyParts.push(mesh.material[i].uuid);
      }
    } else {
      meshCacheKeyParts.push(mesh.material.uuid);
    }
    const meshCacheKey = meshCacheKeyParts.join(":");
    if (cache.meshes.has(meshCacheKey))
      return cache.meshes.get(meshCacheKey);
    const geometry = mesh.geometry;
    let mode;
    if (mesh.isLineSegments) {
      mode = WEBGL_CONSTANTS2.LINES;
    } else if (mesh.isLineLoop) {
      mode = WEBGL_CONSTANTS2.LINE_LOOP;
    } else if (mesh.isLine) {
      mode = WEBGL_CONSTANTS2.LINE_STRIP;
    } else if (mesh.isPoints) {
      mode = WEBGL_CONSTANTS2.POINTS;
    } else {
      mode = mesh.material.wireframe ? WEBGL_CONSTANTS2.LINES : WEBGL_CONSTANTS2.TRIANGLES;
    }
    const meshDef = {};
    const attributes = {};
    const primitives = [];
    const targets = [];
    const nameConversion = {
      uv: "TEXCOORD_0",
      uv1: "TEXCOORD_1",
      uv2: "TEXCOORD_2",
      uv3: "TEXCOORD_3",
      color: "COLOR_0",
      skinWeight: "WEIGHTS_0",
      skinIndex: "JOINTS_0"
    };
    const originalNormal = geometry.getAttribute("normal");
    if (originalNormal !== void 0 && !this.isNormalizedNormalAttribute(originalNormal)) {
      console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.");
      geometry.setAttribute("normal", this.createNormalizedNormalAttribute(originalNormal));
    }
    let modifiedAttribute = null;
    for (let attributeName in geometry.attributes) {
      if (attributeName.slice(0, 5) === "morph")
        continue;
      const attribute = geometry.attributes[attributeName];
      attributeName = nameConversion[attributeName] || attributeName.toUpperCase();
      const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/;
      if (!validVertexAttributes.test(attributeName))
        attributeName = "_" + attributeName;
      if (cache.attributes.has(this.getUID(attribute))) {
        attributes[attributeName] = cache.attributes.get(this.getUID(attribute));
        continue;
      }
      modifiedAttribute = null;
      const array = attribute.array;
      if (attributeName === "JOINTS_0" && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {
        console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.');
        modifiedAttribute = new BufferAttribute2(new Uint16Array(array), attribute.itemSize, attribute.normalized);
      }
      const accessor = this.processAccessor(modifiedAttribute || attribute, geometry);
      if (accessor !== null) {
        if (!attributeName.startsWith("_")) {
          this.detectMeshQuantization(attributeName, attribute);
        }
        attributes[attributeName] = accessor;
        cache.attributes.set(this.getUID(attribute), accessor);
      }
    }
    if (originalNormal !== void 0)
      geometry.setAttribute("normal", originalNormal);
    if (Object.keys(attributes).length === 0)
      return null;
    if (mesh.morphTargetInfluences !== void 0 && mesh.morphTargetInfluences.length > 0) {
      const weights = [];
      const targetNames = [];
      const reverseDictionary = {};
      if (mesh.morphTargetDictionary !== void 0) {
        for (const key in mesh.morphTargetDictionary) {
          reverseDictionary[mesh.morphTargetDictionary[key]] = key;
        }
      }
      for (let i = 0; i < mesh.morphTargetInfluences.length; ++i) {
        const target = {};
        let warned = false;
        for (const attributeName in geometry.morphAttributes) {
          if (attributeName !== "position" && attributeName !== "normal") {
            if (!warned) {
              console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported.");
              warned = true;
            }
            continue;
          }
          const attribute = geometry.morphAttributes[attributeName][i];
          const gltfAttributeName = attributeName.toUpperCase();
          const baseAttribute = geometry.attributes[attributeName];
          if (cache.attributes.has(this.getUID(attribute, true))) {
            target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute, true));
            continue;
          }
          const relativeAttribute = attribute.clone();
          if (!geometry.morphTargetsRelative) {
            for (let j = 0, jl = attribute.count; j < jl; j++) {
              for (let a = 0; a < attribute.itemSize; a++) {
                if (a === 0)
                  relativeAttribute.setX(j, attribute.getX(j) - baseAttribute.getX(j));
                if (a === 1)
                  relativeAttribute.setY(j, attribute.getY(j) - baseAttribute.getY(j));
                if (a === 2)
                  relativeAttribute.setZ(j, attribute.getZ(j) - baseAttribute.getZ(j));
                if (a === 3)
                  relativeAttribute.setW(j, attribute.getW(j) - baseAttribute.getW(j));
              }
            }
          }
          target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry);
          cache.attributes.set(this.getUID(baseAttribute, true), target[gltfAttributeName]);
        }
        targets.push(target);
        weights.push(mesh.morphTargetInfluences[i]);
        if (mesh.morphTargetDictionary !== void 0)
          targetNames.push(reverseDictionary[i]);
      }
      meshDef.weights = weights;
      if (targetNames.length > 0) {
        meshDef.extras = {};
        meshDef.extras.targetNames = targetNames;
      }
    }
    const isMultiMaterial = Array.isArray(mesh.material);
    if (isMultiMaterial && geometry.groups.length === 0)
      return null;
    let didForceIndices = false;
    if (isMultiMaterial && geometry.index === null) {
      const indices = [];
      for (let i = 0, il = geometry.attributes.position.count; i < il; i++) {
        indices[i] = i;
      }
      geometry.setIndex(indices);
      didForceIndices = true;
    }
    const materials = isMultiMaterial ? mesh.material : [mesh.material];
    const groups = isMultiMaterial ? geometry.groups : [{ materialIndex: 0, start: void 0, count: void 0 }];
    for (let i = 0, il = groups.length; i < il; i++) {
      const primitive = {
        mode,
        attributes
      };
      this.serializeUserData(geometry, primitive);
      if (targets.length > 0)
        primitive.targets = targets;
      if (geometry.index !== null) {
        let cacheKey = this.getUID(geometry.index);
        if (groups[i].start !== void 0 || groups[i].count !== void 0) {
          cacheKey += ":" + groups[i].start + ":" + groups[i].count;
        }
        if (cache.attributes.has(cacheKey)) {
          primitive.indices = cache.attributes.get(cacheKey);
        } else {
          primitive.indices = this.processAccessor(geometry.index, geometry, groups[i].start, groups[i].count);
          cache.attributes.set(cacheKey, primitive.indices);
        }
        if (primitive.indices === null)
          delete primitive.indices;
      }
      const material = this.processMaterial(materials[groups[i].materialIndex]);
      if (material !== null)
        primitive.material = material;
      primitives.push(primitive);
    }
    if (didForceIndices === true) {
      geometry.setIndex(null);
    }
    meshDef.primitives = primitives;
    if (!json.meshes)
      json.meshes = [];
    this._invokeAll(function(ext) {
      ext.writeMesh && ext.writeMesh(mesh, meshDef);
    });
    const index = json.meshes.push(meshDef) - 1;
    cache.meshes.set(meshCacheKey, index);
    return index;
  }
  /**
   * If a vertex attribute with a
   * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)
   * is used, it is checked whether it is a valid data type according to the
   * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)
   * extension.
   * In this case the extension is automatically added to the list of used extensions.
   *
   * @param {string} attributeName
   * @param {THREE.BufferAttribute} attribute
   */
  detectMeshQuantization(attributeName, attribute) {
    if (this.extensionsUsed[KHR_MESH_QUANTIZATION])
      return;
    let attrType = void 0;
    switch (attribute.array.constructor) {
      case Int8Array:
        attrType = "byte";
        break;
      case Uint8Array:
        attrType = "unsigned byte";
        break;
      case Int16Array:
        attrType = "short";
        break;
      case Uint16Array:
        attrType = "unsigned short";
        break;
      default:
        return;
    }
    if (attribute.normalized)
      attrType += " normalized";
    const attrNamePrefix = attributeName.split("_", 1)[0];
    if (KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix] && KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix].includes(attrType)) {
      this.extensionsUsed[KHR_MESH_QUANTIZATION] = true;
      this.extensionsRequired[KHR_MESH_QUANTIZATION] = true;
    }
  }
  /**
   * Process camera
   * @param  {THREE.Camera} camera Camera to process
   * @return {Integer}      Index of the processed mesh in the "camera" array
   */
  processCamera(camera) {
    const json = this.json;
    if (!json.cameras)
      json.cameras = [];
    const isOrtho = camera.isOrthographicCamera;
    const cameraDef = {
      type: isOrtho ? "orthographic" : "perspective"
    };
    if (isOrtho) {
      cameraDef.orthographic = {
        xmag: camera.right * 2,
        ymag: camera.top * 2,
        zfar: camera.far <= 0 ? 1e-3 : camera.far,
        znear: camera.near < 0 ? 0 : camera.near
      };
    } else {
      cameraDef.perspective = {
        aspectRatio: camera.aspect,
        yfov: MathUtils.degToRad(camera.fov),
        zfar: camera.far <= 0 ? 1e-3 : camera.far,
        znear: camera.near < 0 ? 0 : camera.near
      };
    }
    if (camera.name !== "")
      cameraDef.name = camera.type;
    return json.cameras.push(cameraDef) - 1;
  }
  /**
   * Creates glTF animation entry from AnimationClip object.
   *
   * Status:
   * - Only properties listed in PATH_PROPERTIES may be animated.
   *
   * @param {THREE.AnimationClip} clip
   * @param {THREE.Object3D} root
   * @return {number|null}
   */
  processAnimation(clip, root) {
    const json = this.json;
    const nodeMap = this.nodeMap;
    if (!json.animations)
      json.animations = [];
    clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);
    const tracks = clip.tracks;
    const channels = [];
    const samplers = [];
    for (let i = 0; i < tracks.length; ++i) {
      const track = tracks[i];
      const trackBinding = PropertyBinding.parseTrackName(track.name);
      let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);
      const trackProperty = PATH_PROPERTIES2[trackBinding.propertyName];
      if (trackBinding.objectName === "bones") {
        if (trackNode.isSkinnedMesh === true) {
          trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);
        } else {
          trackNode = void 0;
        }
      }
      if (!trackNode || !trackProperty) {
        console.warn('THREE.GLTFExporter: Could not export animation track "%s".', track.name);
        continue;
      }
      const inputItemSize = 1;
      let outputItemSize = track.values.length / track.times.length;
      if (trackProperty === PATH_PROPERTIES2.morphTargetInfluences) {
        outputItemSize /= trackNode.morphTargetInfluences.length;
      }
      let interpolation;
      if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {
        interpolation = "CUBICSPLINE";
        outputItemSize /= 3;
      } else if (track.getInterpolation() === InterpolateDiscrete) {
        interpolation = "STEP";
      } else {
        interpolation = "LINEAR";
      }
      samplers.push({
        input: this.processAccessor(new BufferAttribute2(track.times, inputItemSize)),
        output: this.processAccessor(new BufferAttribute2(track.values, outputItemSize)),
        interpolation
      });
      channels.push({
        sampler: samplers.length - 1,
        target: {
          node: nodeMap.get(trackNode),
          path: trackProperty
        }
      });
    }
    json.animations.push({
      name: clip.name || "clip_" + json.animations.length,
      samplers,
      channels
    });
    return json.animations.length - 1;
  }
  /**
   * @param {THREE.Object3D} object
   * @return {number|null}
   */
  processSkin(object) {
    const json = this.json;
    const nodeMap = this.nodeMap;
    const node = json.nodes[nodeMap.get(object)];
    const skeleton = object.skeleton;
    if (skeleton === void 0)
      return null;
    const rootJoint = object.skeleton.bones[0];
    if (rootJoint === void 0)
      return null;
    const joints = [];
    const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);
    const temporaryBoneInverse = new Matrix4();
    for (let i = 0; i < skeleton.bones.length; ++i) {
      joints.push(nodeMap.get(skeleton.bones[i]));
      temporaryBoneInverse.copy(skeleton.boneInverses[i]);
      temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);
    }
    if (json.skins === void 0)
      json.skins = [];
    json.skins.push({
      inverseBindMatrices: this.processAccessor(new BufferAttribute2(inverseBindMatrices, 16)),
      joints,
      skeleton: nodeMap.get(rootJoint)
    });
    const skinIndex = node.skin = json.skins.length - 1;
    return skinIndex;
  }
  /**
   * Process Object3D node
   * @param  {THREE.Object3D} node Object3D to processNode
   * @return {Integer} Index of the node in the nodes list
   */
  processNode(object) {
    const beforeWriteArgs = { keep: true };
    this._invokeAll(function(ext) {
      ext.beforeWriteNode && ext.beforeWriteNode(object, beforeWriteArgs);
    });
    if (beforeWriteArgs.keep != true) {
      return null;
    }
    const json = this.json;
    const options = this.options;
    const nodeMap = this.nodeMap;
    if (!json.nodes)
      json.nodes = [];
    const nodeDef = {};
    if (options.trs) {
      const rotation = object.quaternion.toArray();
      const position = object.position.toArray();
      const scale = object.scale.toArray();
      if (!equalArray(rotation, [0, 0, 0, 1])) {
        nodeDef.rotation = rotation;
      }
      if (!equalArray(position, [0, 0, 0])) {
        nodeDef.translation = position;
      }
      if (!equalArray(scale, [1, 1, 1])) {
        nodeDef.scale = scale;
      }
    } else {
      if (object.matrixAutoUpdate) {
        object.updateMatrix();
      }
      if (isIdentityMatrix(object.matrix) === false) {
        nodeDef.matrix = object.matrix.elements;
      }
    }
    if (object.name !== "")
      nodeDef.name = String(object.name);
    this.serializeUserData(object, nodeDef);
    if (object.isMesh || object.isLine || object.isPoints) {
      const meshIndex = this.processMesh(object);
      if (meshIndex !== null)
        nodeDef.mesh = meshIndex;
    } else if (object.isCamera) {
      nodeDef.camera = this.processCamera(object);
    }
    if (object.isSkinnedMesh)
      this.skins.push(object);
    if (object.children.length > 0) {
      const children = [];
      for (let i = 0, l = object.children.length; i < l; i++) {
        const child = object.children[i];
        if (child.visible || options.onlyVisible === false) {
          const nodeIndex2 = this.processNode(child);
          if (nodeIndex2 !== null)
            children.push(nodeIndex2);
        }
      }
      if (children.length > 0)
        nodeDef.children = children;
    }
    this._invokeAll(function(ext) {
      ext.writeNode && ext.writeNode(object, nodeDef);
    });
    const nodeIndex = json.nodes.push(nodeDef) - 1;
    nodeMap.set(object, nodeIndex);
    return nodeIndex;
  }
  /**
   * Process Scene
   * @param  {Scene} node Scene to process
   */
  processScene(scene) {
    const json = this.json;
    const options = this.options;
    if (!json.scenes) {
      json.scenes = [];
      json.scene = 0;
    }
    const sceneDef = {};
    if (scene.name !== "")
      sceneDef.name = scene.name;
    json.scenes.push(sceneDef);
    const nodes = [];
    for (let i = 0, l = scene.children.length; i < l; i++) {
      const child = scene.children[i];
      if (child.visible || options.onlyVisible === false) {
        const nodeIndex = this.processNode(child);
        if (nodeIndex !== null)
          nodes.push(nodeIndex);
      }
    }
    if (nodes.length > 0)
      sceneDef.nodes = nodes;
    this.serializeUserData(scene, sceneDef);
  }
  /**
   * Creates a Scene to hold a list of objects and parse it
   * @param  {Array} objects List of objects to process
   */
  processObjects(objects) {
    const scene = new Scene();
    scene.name = "AuxScene";
    for (let i = 0; i < objects.length; i++) {
      scene.children.push(objects[i]);
    }
    this.processScene(scene);
  }
  /**
   * @param {THREE.Object3D|Array<THREE.Object3D>} input
   */
  processInput(input) {
    const options = this.options;
    input = input instanceof Array ? input : [input];
    this._invokeAll(function(ext) {
      ext.beforeParse && ext.beforeParse(input);
    });
    const objectsWithoutScene = [];
    for (let i = 0; i < input.length; i++) {
      if (input[i] instanceof Scene) {
        this.processScene(input[i]);
      } else {
        objectsWithoutScene.push(input[i]);
      }
    }
    if (objectsWithoutScene.length > 0)
      this.processObjects(objectsWithoutScene);
    for (let i = 0; i < this.skins.length; ++i) {
      this.processSkin(this.skins[i]);
    }
    for (let i = 0; i < options.animations.length; ++i) {
      this.processAnimation(options.animations[i], input[0]);
    }
    this._invokeAll(function(ext) {
      ext.afterParse && ext.afterParse(input);
    });
  }
  _invokeAll(func) {
    for (let i = 0, il = this.plugins.length; i < il; i++) {
      func(this.plugins[i]);
    }
  }
};
var GLTFLightExtension = class {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_lights_punctual";
  }
  writeNode(light, nodeDef) {
    if (!light.isLight)
      return;
    if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {
      console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", light);
      return;
    }
    const writer = this.writer;
    const json = writer.json;
    const extensionsUsed = writer.extensionsUsed;
    const lightDef = {};
    if (light.name)
      lightDef.name = light.name;
    lightDef.color = light.color.toArray();
    lightDef.intensity = light.intensity;
    if (light.isDirectionalLight) {
      lightDef.type = "directional";
    } else if (light.isPointLight) {
      lightDef.type = "point";
      if (light.distance > 0)
        lightDef.range = light.distance;
    } else if (light.isSpotLight) {
      lightDef.type = "spot";
      if (light.distance > 0)
        lightDef.range = light.distance;
      lightDef.spot = {};
      lightDef.spot.innerConeAngle = (1 - light.penumbra) * light.angle;
      lightDef.spot.outerConeAngle = light.angle;
    }
    if (light.decay !== void 0 && light.decay !== 2) {
      console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2.");
    }
    if (light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {
      console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1.");
    }
    if (!extensionsUsed[this.name]) {
      json.extensions = json.extensions || {};
      json.extensions[this.name] = { lights: [] };
      extensionsUsed[this.name] = true;
    }
    const lights = json.extensions[this.name].lights;
    lights.push(lightDef);
    nodeDef.extensions = nodeDef.extensions || {};
    nodeDef.extensions[this.name] = { light: lights.length - 1 };
  }
};
var GLTFMaterialsUnlitExtension2 = class {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_materials_unlit";
  }
  writeMaterial(material, materialDef) {
    if (!material.isMeshBasicMaterial)
      return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = {};
    extensionsUsed[this.name] = true;
    materialDef.pbrMetallicRoughness.metallicFactor = 0;
    materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;
  }
};
var GLTFMaterialsClearcoatExtension2 = class {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_materials_clearcoat";
  }
  writeMaterial(material, materialDef) {
    if (!material.isMeshPhysicalMaterial || material.clearcoat === 0)
      return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    extensionDef.clearcoatFactor = material.clearcoat;
    if (material.clearcoatMap) {
      const clearcoatMapDef = {
        index: writer.processTexture(material.clearcoatMap),
        texCoord: material.clearcoatMap.channel
      };
      writer.applyTextureTransform(clearcoatMapDef, material.clearcoatMap);
      extensionDef.clearcoatTexture = clearcoatMapDef;
    }
    extensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;
    if (material.clearcoatRoughnessMap) {
      const clearcoatRoughnessMapDef = {
        index: writer.processTexture(material.clearcoatRoughnessMap),
        texCoord: material.clearcoatRoughnessMap.channel
      };
      writer.applyTextureTransform(clearcoatRoughnessMapDef, material.clearcoatRoughnessMap);
      extensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;
    }
    if (material.clearcoatNormalMap) {
      const clearcoatNormalMapDef = {
        index: writer.processTexture(material.clearcoatNormalMap),
        texCoord: material.clearcoatNormalMap.channel
      };
      if (material.clearcoatNormalScale.x !== 1)
        clearcoatNormalMapDef.scale = material.clearcoatNormalScale.x;
      writer.applyTextureTransform(clearcoatNormalMapDef, material.clearcoatNormalMap);
      extensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;
    }
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsDispersionExtension2 = class {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_materials_dispersion";
  }
  writeMaterial(material, materialDef) {
    if (!material.isMeshPhysicalMaterial || material.dispersion === 0)
      return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    extensionDef.dispersion = material.dispersion;
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsIridescenceExtension2 = class {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_materials_iridescence";
  }
  writeMaterial(material, materialDef) {
    if (!material.isMeshPhysicalMaterial || material.iridescence === 0)
      return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    extensionDef.iridescenceFactor = material.iridescence;
    if (material.iridescenceMap) {
      const iridescenceMapDef = {
        index: writer.processTexture(material.iridescenceMap),
        texCoord: material.iridescenceMap.channel
      };
      writer.applyTextureTransform(iridescenceMapDef, material.iridescenceMap);
      extensionDef.iridescenceTexture = iridescenceMapDef;
    }
    extensionDef.iridescenceIor = material.iridescenceIOR;
    extensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[0];
    extensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[1];
    if (material.iridescenceThicknessMap) {
      const iridescenceThicknessMapDef = {
        index: writer.processTexture(material.iridescenceThicknessMap),
        texCoord: material.iridescenceThicknessMap.channel
      };
      writer.applyTextureTransform(iridescenceThicknessMapDef, material.iridescenceThicknessMap);
      extensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;
    }
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsTransmissionExtension2 = class {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_materials_transmission";
  }
  writeMaterial(material, materialDef) {
    if (!material.isMeshPhysicalMaterial || material.transmission === 0)
      return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    extensionDef.transmissionFactor = material.transmission;
    if (material.transmissionMap) {
      const transmissionMapDef = {
        index: writer.processTexture(material.transmissionMap),
        texCoord: material.transmissionMap.channel
      };
      writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);
      extensionDef.transmissionTexture = transmissionMapDef;
    }
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsVolumeExtension2 = class {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_materials_volume";
  }
  writeMaterial(material, materialDef) {
    if (!material.isMeshPhysicalMaterial || material.transmission === 0)
      return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    extensionDef.thicknessFactor = material.thickness;
    if (material.thicknessMap) {
      const thicknessMapDef = {
        index: writer.processTexture(material.thicknessMap),
        texCoord: material.thicknessMap.channel
      };
      writer.applyTextureTransform(thicknessMapDef, material.thicknessMap);
      extensionDef.thicknessTexture = thicknessMapDef;
    }
    if (material.attenuationDistance !== Infinity) {
      extensionDef.attenuationDistance = material.attenuationDistance;
    }
    extensionDef.attenuationColor = material.attenuationColor.toArray();
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsIorExtension2 = class {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_materials_ior";
  }
  writeMaterial(material, materialDef) {
    if (!material.isMeshPhysicalMaterial || material.ior === 1.5)
      return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    extensionDef.ior = material.ior;
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsSpecularExtension2 = class {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_materials_specular";
  }
  writeMaterial(material, materialDef) {
    if (!material.isMeshPhysicalMaterial || material.specularIntensity === 1 && material.specularColor.equals(DEFAULT_SPECULAR_COLOR) && !material.specularIntensityMap && !material.specularColorMap)
      return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    if (material.specularIntensityMap) {
      const specularIntensityMapDef = {
        index: writer.processTexture(material.specularIntensityMap),
        texCoord: material.specularIntensityMap.channel
      };
      writer.applyTextureTransform(specularIntensityMapDef, material.specularIntensityMap);
      extensionDef.specularTexture = specularIntensityMapDef;
    }
    if (material.specularColorMap) {
      const specularColorMapDef = {
        index: writer.processTexture(material.specularColorMap),
        texCoord: material.specularColorMap.channel
      };
      writer.applyTextureTransform(specularColorMapDef, material.specularColorMap);
      extensionDef.specularColorTexture = specularColorMapDef;
    }
    extensionDef.specularFactor = material.specularIntensity;
    extensionDef.specularColorFactor = material.specularColor.toArray();
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsSheenExtension2 = class {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_materials_sheen";
  }
  writeMaterial(material, materialDef) {
    if (!material.isMeshPhysicalMaterial || material.sheen == 0)
      return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    if (material.sheenRoughnessMap) {
      const sheenRoughnessMapDef = {
        index: writer.processTexture(material.sheenRoughnessMap),
        texCoord: material.sheenRoughnessMap.channel
      };
      writer.applyTextureTransform(sheenRoughnessMapDef, material.sheenRoughnessMap);
      extensionDef.sheenRoughnessTexture = sheenRoughnessMapDef;
    }
    if (material.sheenColorMap) {
      const sheenColorMapDef = {
        index: writer.processTexture(material.sheenColorMap),
        texCoord: material.sheenColorMap.channel
      };
      writer.applyTextureTransform(sheenColorMapDef, material.sheenColorMap);
      extensionDef.sheenColorTexture = sheenColorMapDef;
    }
    extensionDef.sheenRoughnessFactor = material.sheenRoughness;
    extensionDef.sheenColorFactor = material.sheenColor.toArray();
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsAnisotropyExtension2 = class {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_materials_anisotropy";
  }
  writeMaterial(material, materialDef) {
    if (!material.isMeshPhysicalMaterial || material.anisotropy == 0)
      return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    if (material.anisotropyMap) {
      const anisotropyMapDef = { index: writer.processTexture(material.anisotropyMap) };
      writer.applyTextureTransform(anisotropyMapDef, material.anisotropyMap);
      extensionDef.anisotropyTexture = anisotropyMapDef;
    }
    extensionDef.anisotropyStrength = material.anisotropy;
    extensionDef.anisotropyRotation = material.anisotropyRotation;
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsEmissiveStrengthExtension2 = class {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_materials_emissive_strength";
  }
  writeMaterial(material, materialDef) {
    if (!material.isMeshStandardMaterial || material.emissiveIntensity === 1)
      return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    extensionDef.emissiveStrength = material.emissiveIntensity;
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsBumpExtension2 = class {
  constructor(writer) {
    this.writer = writer;
    this.name = "EXT_materials_bump";
  }
  writeMaterial(material, materialDef) {
    if (!material.isMeshStandardMaterial || material.bumpScale === 1 && !material.bumpMap)
      return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    if (material.bumpMap) {
      const bumpMapDef = {
        index: writer.processTexture(material.bumpMap),
        texCoord: material.bumpMap.channel
      };
      writer.applyTextureTransform(bumpMapDef, material.bumpMap);
      extensionDef.bumpTexture = bumpMapDef;
    }
    extensionDef.bumpFactor = material.bumpScale;
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMeshGpuInstancing2 = class {
  constructor(writer) {
    this.writer = writer;
    this.name = "EXT_mesh_gpu_instancing";
  }
  writeNode(object, nodeDef) {
    if (!object.isInstancedMesh)
      return;
    const writer = this.writer;
    const mesh = object;
    const translationAttr = new Float32Array(mesh.count * 3);
    const rotationAttr = new Float32Array(mesh.count * 4);
    const scaleAttr = new Float32Array(mesh.count * 3);
    const matrix = new Matrix4();
    const position = new Vector32();
    const quaternion = new Quaternion();
    const scale = new Vector32();
    for (let i = 0; i < mesh.count; i++) {
      mesh.getMatrixAt(i, matrix);
      matrix.decompose(position, quaternion, scale);
      position.toArray(translationAttr, i * 3);
      quaternion.toArray(rotationAttr, i * 4);
      scale.toArray(scaleAttr, i * 3);
    }
    const attributes = {
      TRANSLATION: writer.processAccessor(new BufferAttribute2(translationAttr, 3)),
      ROTATION: writer.processAccessor(new BufferAttribute2(rotationAttr, 4)),
      SCALE: writer.processAccessor(new BufferAttribute2(scaleAttr, 3))
    };
    if (mesh.instanceColor)
      attributes._COLOR_0 = writer.processAccessor(mesh.instanceColor);
    nodeDef.extensions = nodeDef.extensions || {};
    nodeDef.extensions[this.name] = { attributes };
    writer.extensionsUsed[this.name] = true;
    writer.extensionsRequired[this.name] = true;
  }
};
GLTFExporter.Utils = {
  insertKeyframe: function(track, time) {
    const tolerance = 1e-3;
    const valueSize = track.getValueSize();
    const times = new track.TimeBufferType(track.times.length + 1);
    const values = new track.ValueBufferType(track.values.length + valueSize);
    const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));
    let index;
    if (track.times.length === 0) {
      times[0] = time;
      for (let i = 0; i < valueSize; i++) {
        values[i] = 0;
      }
      index = 0;
    } else if (time < track.times[0]) {
      if (Math.abs(track.times[0] - time) < tolerance)
        return 0;
      times[0] = time;
      times.set(track.times, 1);
      values.set(interpolant.evaluate(time), 0);
      values.set(track.values, valueSize);
      index = 0;
    } else if (time > track.times[track.times.length - 1]) {
      if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {
        return track.times.length - 1;
      }
      times[times.length - 1] = time;
      times.set(track.times, 0);
      values.set(track.values, 0);
      values.set(interpolant.evaluate(time), track.values.length);
      index = times.length - 1;
    } else {
      for (let i = 0; i < track.times.length; i++) {
        if (Math.abs(track.times[i] - time) < tolerance)
          return i;
        if (track.times[i] < time && track.times[i + 1] > time) {
          times.set(track.times.slice(0, i + 1), 0);
          times[i + 1] = time;
          times.set(track.times.slice(i + 1), i + 2);
          values.set(track.values.slice(0, (i + 1) * valueSize), 0);
          values.set(interpolant.evaluate(time), (i + 1) * valueSize);
          values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize);
          index = i + 1;
          break;
        }
      }
    }
    track.times = times;
    track.values = values;
    return index;
  },
  mergeMorphTargetTracks: function(clip, root) {
    const tracks = [];
    const mergedTracks = {};
    const sourceTracks = clip.tracks;
    for (let i = 0; i < sourceTracks.length; ++i) {
      let sourceTrack = sourceTracks[i];
      const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);
      const sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);
      if (sourceTrackBinding.propertyName !== "morphTargetInfluences" || sourceTrackBinding.propertyIndex === void 0) {
        tracks.push(sourceTrack);
        continue;
      }
      if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {
        if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
          throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
        }
        console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.");
        sourceTrack = sourceTrack.clone();
        sourceTrack.setInterpolation(InterpolateLinear);
      }
      const targetCount = sourceTrackNode.morphTargetInfluences.length;
      const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];
      if (targetIndex === void 0) {
        throw new Error("THREE.GLTFExporter: Morph target name not found: " + sourceTrackBinding.propertyIndex);
      }
      let mergedTrack;
      if (mergedTracks[sourceTrackNode.uuid] === void 0) {
        mergedTrack = sourceTrack.clone();
        const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);
        for (let j = 0; j < mergedTrack.times.length; j++) {
          values[j * targetCount + targetIndex] = mergedTrack.values[j];
        }
        mergedTrack.name = (sourceTrackBinding.nodeName || "") + ".morphTargetInfluences";
        mergedTrack.values = values;
        mergedTracks[sourceTrackNode.uuid] = mergedTrack;
        tracks.push(mergedTrack);
        continue;
      }
      const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));
      mergedTrack = mergedTracks[sourceTrackNode.uuid];
      for (let j = 0; j < mergedTrack.times.length; j++) {
        mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j]);
      }
      for (let j = 0; j < sourceTrack.times.length; j++) {
        const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j]);
        mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j];
      }
    }
    clip.tracks = tracks;
    return clip;
  }
};

// node_modules/@needle-tools/engine/lib/include/three/EXT_mesh_gpu_instancing_exporter.js
var GLTFMeshGPUInstancingExtension = class {
  constructor(writer) {
    this.writer = writer;
    this.name = "EXT_mesh_gpu_instancing";
  }
  writeNode(node, nodeDef) {
    if (node.constructor.name !== "InstancedMesh")
      return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    nodeDef.extensions = nodeDef.extensions || {};
    nodeDef.extensions[this.name] = extensionDef;
    let mat = new Matrix4();
    const pos0 = new Array();
    const rot0 = new Array();
    const scl0 = new Array();
    for (let i = 0; i < node.count; i++) {
      node.getMatrixAt(i, mat);
      let p = new Vector32();
      let r = new Quaternion();
      let s = new Vector32();
      mat.decompose(p, r, s);
      pos0.push(p.x, p.y, p.z);
      rot0.push(r.x, r.y, r.z, r.w);
      scl0.push(s.x, s.y, s.z);
    }
    ;
    const pos = new Float32Array(pos0);
    const rot = new Float32Array(rot0);
    const scl = new Float32Array(scl0);
    extensionDef.attributes = {
      "TRANSLATION": writer.processAccessor(new BufferAttribute2(pos, 3)),
      "ROTATION": writer.processAccessor(new BufferAttribute2(rot, 4)),
      "SCALE": writer.processAccessor(new BufferAttribute2(scl, 3))
    };
    extensionsUsed[this.name] = true;
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/export/gltf/GltfExport.js
var __decorate61 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debugExport = getParam("debuggltfexport");
var GltfExportBox = class extends BoxHelperComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "sceneRoot");
  }
};
var GltfExport = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "binary", true);
    __publicField(this, "objects", []);
    __publicField(this, "ext");
  }
  async exportNow(name, opts) {
    if (debugExport)
      console.log("Exporting objects as glTF", this.objects);
    if (!name)
      name = "scene";
    if (!this.objects || this.objects.length <= 0)
      this.objects = [this.context.scene];
    const options = {
      binary: this.binary,
      pivot: GltfExport.calculateCenter(this.objects),
      ...opts
    };
    const res = await this.export(this.objects, options).catch((err) => {
      console.error(err);
      return false;
    });
    if (res === false)
      return false;
    if (!this.binary) {
      if (!name.endsWith(".gltf"))
        name += ".gltf";
    } else if (!name.endsWith(".glb"))
      name += ".glb";
    if (this.binary)
      GltfExport.saveArrayBuffer(res, name);
    else
      GltfExport.saveJson(res, name);
    return true;
  }
  async export(objectsToExport, opts) {
    if (!objectsToExport || objectsToExport.length <= 0) {
      console.warn("No objects set to export");
      return;
    }
    const exporter = new GLTFExporter();
    exporter.register((writer) => new GLTFMeshGPUInstancingExtension(writer));
    registerExportExtensions(exporter, this.context);
    GltfExport.filterTopmostParent(objectsToExport);
    const options = {
      trs: false,
      onlyVisible: true,
      truncateDrawRange: false,
      binary: true,
      maxTextureSize: Infinity,
      embedImages: true,
      includeCustomExtensions: true,
      animations: (opts == null ? void 0 : opts.animations) || GltfExport.collectAnimations(objectsToExport),
      ...opts
    };
    const exportScene = new Object3D();
    if (opts == null ? void 0 : opts.pivot)
      exportScene.position.sub(opts.pivot);
    if (debugExport)
      console.log("EXPORT", objectsToExport);
    objectsToExport.forEach((obj) => {
      if (obj) {
        exportScene.children.push(obj);
        obj.matrixAutoUpdate = false;
        obj.matrix.copy(obj.matrixWorld);
        GameObject.getComponentsInChildren(obj, Renderer).forEach((r) => {
          if (GameObject.isActiveInHierarchy(r.gameObject))
            r.setInstancingEnabled(false);
        });
      }
    });
    const serializationContext = new SerializationContext(exportScene);
    if (opts == null ? void 0 : opts.needleComponents) {
      this.ext = new NEEDLE_components();
    }
    if (this.ext) {
      this.ext.registerExport(exporter);
      this.ext.context = serializationContext;
    }
    return new Promise((resolve2, reject) => {
      if (debugExport)
        console.log("Starting glTF export.");
      try {
        exporter == null ? void 0 : exporter.parse(
          exportScene,
          // called when the gltf has been generated
          (res) => {
            cleanup();
            resolve2(res);
          },
          // called when there is an error in the generation
          (err) => {
            cleanup();
            reject(err);
          },
          options
        );
      } catch (err) {
        console.error(err);
        reject(err);
      } finally {
        if (debugExport)
          console.log("Finished glTF export.");
      }
    });
    function cleanup() {
      objectsToExport.forEach((obj) => {
        if (!obj)
          return;
        obj.matrixAutoUpdate = true;
        GameObject.getComponentsInChildren(obj, Renderer).forEach((r) => {
          if (GameObject.isActiveInHierarchy(r.gameObject))
            r.setInstancingEnabled(false);
        });
      });
    }
  }
  static saveArrayBuffer(buffer2, filename) {
    this.save(new Blob([buffer2], { type: "application/octet-stream" }), filename);
  }
  static saveJson(json, filename) {
    this.save("data: text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(json)), filename);
  }
  static save(blob, filename) {
    const link = document.createElement("a");
    link.style.display = "none";
    document.body.appendChild(link);
    if (typeof blob === "string")
      link.href = blob;
    else
      link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
    link.remove();
  }
  static collectAnimations(objs, target) {
    target = target || [];
    for (const obj of objs) {
      if (!obj)
        continue;
      obj.traverseVisible((o) => {
        if (o.animations && o.animations.length > 0)
          target.push(...o.animations);
      });
    }
    return target;
  }
  static calculateCenter(objs, target) {
    const center = target || new Vector32();
    center.set(0, 0, 0);
    objs.forEach((obj) => {
      center.add(getWorldPosition(obj));
    });
    center.divideScalar(objs.length);
    return center;
  }
  static filterTopmostParent(objs) {
    if (objs.length <= 0)
      return;
    for (let index = 0; index < objs.length; index++) {
      let obj = objs[index];
      if (!obj) {
        objs.splice(index, 1);
        index--;
        continue;
      }
      while (obj.parent) {
        if (objs.includes(obj.parent)) {
          objs.splice(index, 1);
          index--;
          break;
        }
        obj = obj.parent;
      }
    }
  }
};
__decorate61([
  serializable()
], GltfExport.prototype, "binary", void 0);
__decorate61([
  serializable(Object3D)
], GltfExport.prototype, "objects", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/GridHelper.js
var __decorate62 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var GridHelper2 = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "isGizmo", false);
    __publicField(this, "color0");
    __publicField(this, "color1");
    __publicField(this, "gridHelper");
    __publicField(this, "size");
    __publicField(this, "divisions");
    __publicField(this, "offset");
  }
  /** @internal */
  onEnable() {
    if (this.isGizmo && !showGizmos)
      return;
    const size = this.size;
    const divisions = this.divisions;
    if (!this.gridHelper) {
      this.gridHelper = new GridHelper(size, divisions, this.color0 ?? new Color(0.4, 0.4, 0.4), this.color1 ?? new Color(0.6, 0.6, 0.6));
      if (this.offset !== void 0)
        this.gridHelper.position.y += this.offset;
    }
    if (this.gridHelper)
      this.gameObject.add(this.gridHelper);
  }
  /** @internal */
  onDisable() {
    if (this.gridHelper) {
      this.gameObject.remove(this.gridHelper);
      this.gridHelper = null;
    }
  }
};
__decorate62([
  serializable()
], GridHelper2.prototype, "isGizmo", void 0);
__decorate62([
  serializable(Color)
], GridHelper2.prototype, "color0", void 0);
__decorate62([
  serializable(Color)
], GridHelper2.prototype, "color1", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/ui/InputField.js
var __decorate63 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug92 = getParam("debuginputfield");
var _InputField = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "textComponent");
    __publicField(this, "placeholder");
    __publicField(this, "onValueChanged");
    __publicField(this, "onEndEdit");
    __publicField(this, "inputEventFn");
    __publicField(this, "_iosEventFn");
  }
  get text() {
    var _a2;
    return ((_a2 = this.textComponent) == null ? void 0 : _a2.text) ?? "";
  }
  get isFocused() {
    return _InputField.active === this;
  }
  start() {
    if (debug92)
      console.log(this.name, this);
  }
  onEnable() {
    var _a2;
    if (!_InputField.htmlField) {
      _InputField.htmlField = document.createElement("input");
      _InputField.htmlField.style.width = "0px";
      _InputField.htmlField.style.height = "0px";
      _InputField.htmlField.style.padding = "0px";
      _InputField.htmlField.style.border = "none";
      _InputField.htmlField.style.overflow = "hidden";
      _InputField.htmlField.style.caretColor = "transparent";
      _InputField.htmlField.style.outline = "none";
      _InputField.htmlField.classList.add("ar");
      _InputField.htmlField.onfocus = () => _InputField.htmlFieldFocused = true;
      _InputField.htmlField.onblur = () => _InputField.htmlFieldFocused = false;
      document.body.append(_InputField.htmlField);
    }
    if (!this.inputEventFn) {
      this.inputEventFn = this.onInput.bind(this);
    }
    _InputField.htmlField.addEventListener("keyup", this.inputEventFn);
    if (this.placeholder && ((_a2 = this.textComponent) == null ? void 0 : _a2.text.length)) {
      GameObject.setActive(this.placeholder.gameObject, false);
    }
    if (DeviceUtilities.isiOS()) {
      this._iosEventFn = this.processInputOniOS.bind(this);
      window.addEventListener("click", this._iosEventFn);
    }
  }
  onDisable() {
    var _a2;
    (_a2 = _InputField.htmlField) == null ? void 0 : _a2.removeEventListener("keyup", this.inputEventFn);
    this.onDeselected();
    if (this._iosEventFn) {
      window.removeEventListener("click", this._iosEventFn);
    }
  }
  /** Clear the input field if it's currently active */
  clear() {
    if (_InputField.active === this && _InputField.htmlField) {
      _InputField.htmlField.value = "";
      this.setTextFromInputField();
    } else {
      if (this.textComponent)
        this.textComponent.text = "";
      if (this.placeholder)
        GameObject.setActive(this.placeholder.gameObject, true);
    }
  }
  /** Select the input field, set it active to receive keyboard input */
  select() {
    this.onSelected();
  }
  /** Deselect the input field, stop receiving keyboard input */
  deselect() {
    this.onDeselected();
  }
  onPointerClick(_args) {
    if (debug92)
      console.log("CLICK", _args, _InputField.active);
    _InputField.activeTime = this.context.time.time;
    if (_InputField.active !== this) {
      this.startCoroutine(this.activeLoop(), FrameEvent.LateUpdate);
    }
    this.selectInputField();
  }
  *activeLoop() {
    this.onSelected();
    while (_InputField.active === this) {
      if (this.context.input.getPointerClicked(0)) {
        if (this.context.time.time - _InputField.activeTime > 0.2) {
          break;
        }
      }
      this.setTextFromInputField();
      yield;
    }
    this.onDeselected();
  }
  onSelected() {
    var _a2, _b, _c, _d;
    if (_InputField.active === this)
      return;
    if (debug92)
      console.log("Select", this.name, this, _InputField.htmlField, this.context.isInXR, this.context.arOverlayElement, (_a2 = this.textComponent) == null ? void 0 : _a2.text, (_b = _InputField.htmlField) == null ? void 0 : _b.value);
    (_c = _InputField.active) == null ? void 0 : _c.onDeselected();
    _InputField.active = this;
    if (this.placeholder)
      GameObject.setActive(this.placeholder.gameObject, false);
    if (_InputField.htmlField) {
      _InputField.htmlField.value = ((_d = this.textComponent) == null ? void 0 : _d.text) || "";
      if (debug92)
        console.log("set input field value", _InputField.htmlField.value);
      if (this.context.isInXR) {
        const overlay = this.context.arOverlayElement;
        if (overlay) {
          overlay.append(_InputField.htmlField);
        }
      }
      this.selectInputField();
    }
  }
  onDeselected() {
    var _a2;
    if (_InputField.active !== this)
      return;
    _InputField.active = null;
    if (debug92)
      console.log("Deselect", this.name, this);
    if (_InputField.htmlField) {
      _InputField.htmlField.blur();
      document.body.append(_InputField.htmlField);
    }
    if (this.placeholder && (!this.textComponent || this.textComponent.text.length <= 0))
      GameObject.setActive(this.placeholder.gameObject, true);
    if (_InputField.htmlField)
      (_a2 = this.onEndEdit) == null ? void 0 : _a2.invoke(_InputField.htmlField.value);
  }
  // @Marwie, I can provide this fix. But the issue seems to comes from Raycaster+EventSystem
  // As we rollout InputField, and no others elements is behind raycast,
  // ThreeMeshUI.update is not called.
  update() {
    var _a2;
    if (_InputField.active === this) {
      (_a2 = this.textComponent) == null ? void 0 : _a2.markDirty();
    }
  }
  onInput(evt) {
    var _a2, _b;
    if (_InputField.active !== this)
      return;
    if (debug92)
      console.log(evt.code, evt, (_a2 = _InputField.htmlField) == null ? void 0 : _a2.value, (_b = this.textComponent) == null ? void 0 : _b.text);
    if (evt.code === "Escape" || evt.code === "Enter") {
      this.onDeselected();
      return;
    }
    if (_InputField.htmlField) {
      if (this.textComponent) {
        this.setTextFromInputField();
        if (this.placeholder) {
          GameObject.setActive(this.placeholder.gameObject, this.textComponent.text.length <= 0);
        }
      }
      this.selectInputField();
    }
  }
  setTextFromInputField() {
    var _a2;
    if (this.textComponent && _InputField.htmlField) {
      if (this.textComponent.text !== _InputField.htmlField.value) {
        if (debug92)
          console.log("VALUE CHANGED");
        const oldValue = this.textComponent.text;
        const newValue = _InputField.htmlField.value;
        (_a2 = this.onValueChanged) == null ? void 0 : _a2.invoke(newValue, oldValue);
      }
      this.textComponent.text = _InputField.htmlField.value;
    }
  }
  selectInputField() {
    if (_InputField.htmlField) {
      if (debug92)
        console.log("Focus Inputfield", _InputField.htmlFieldFocused);
      _InputField.htmlField.setSelectionRange(_InputField.htmlField.value.length, _InputField.htmlField.value.length);
      if (DeviceUtilities.isiOS())
        _InputField.htmlField.focus({ preventScroll: true });
      else {
        setTimeout(() => {
          var _a2;
          return (_a2 = _InputField.htmlField) == null ? void 0 : _a2.focus();
        }, 1);
      }
    }
  }
  processInputOniOS() {
    const hits = this.context.physics.raycast();
    if (!hits.length)
      return;
    const hit = hits[0];
    const obj = hit.object;
    const component = tryGetUIComponent(obj);
    if ((component == null ? void 0 : component.gameObject) === this.gameObject || (component == null ? void 0 : component.gameObject.parent) === this.gameObject)
      this.selectInputField();
  }
};
var InputField = _InputField;
__publicField(InputField, "active", null);
__publicField(InputField, "activeTime", -1);
__publicField(InputField, "htmlField", null);
__publicField(InputField, "htmlFieldFocused", false);
__decorate63([
  serializable(Text)
], InputField.prototype, "textComponent", void 0);
__decorate63([
  serializable(Text)
], InputField.prototype, "placeholder", void 0);
__decorate63([
  serializable(EventList)
], InputField.prototype, "onValueChanged", void 0);
__decorate63([
  serializable(EventList)
], InputField.prototype, "onEndEdit", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/Light.js
var __decorate64 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
function toRadians(degrees) {
  return degrees * Math.PI / 180;
}
var shadowMaxDistance = 300;
var debug93 = getParam("debuglights");
var LightType;
(function(LightType2) {
  LightType2[LightType2["Spot"] = 0] = "Spot";
  LightType2[LightType2["Directional"] = 1] = "Directional";
  LightType2[LightType2["Point"] = 2] = "Point";
  LightType2[LightType2["Area"] = 3] = "Area";
  LightType2[LightType2["Rectangle"] = 3] = "Rectangle";
  LightType2[LightType2["Disc"] = 4] = "Disc";
})(LightType || (LightType = {}));
var LightmapBakeType;
(function(LightmapBakeType2) {
  LightmapBakeType2[LightmapBakeType2["Realtime"] = 4] = "Realtime";
  LightmapBakeType2[LightmapBakeType2["Baked"] = 2] = "Baked";
  LightmapBakeType2[LightmapBakeType2["Mixed"] = 1] = "Mixed";
})(LightmapBakeType || (LightmapBakeType = {}));
var LightShadows;
(function(LightShadows2) {
  LightShadows2[LightShadows2["None"] = 0] = "None";
  LightShadows2[LightShadows2["Hard"] = 1] = "Hard";
  LightShadows2[LightShadows2["Soft"] = 2] = "Soft";
})(LightShadows || (LightShadows = {}));
var Light = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "type", 0);
    __publicField(this, "range", 1);
    __publicField(this, "spotAngle", 1);
    __publicField(this, "innerSpotAngle", 1);
    __publicField(this, "_color", new Color(16777215));
    __publicField(this, "_shadowNearPlane", 0.1);
    __publicField(this, "_shadowBias", 0);
    __publicField(this, "_shadowNormalBias", 0);
    /** when enabled this will remove the multiplication when setting the shadow bias settings initially */
    __publicField(this, "_overrideShadowBiasSettings", false);
    __publicField(this, "_shadows", 1);
    __publicField(this, "lightmapBakeType", LightmapBakeType.Realtime);
    __publicField(this, "_intensity", -1);
    __publicField(this, "_shadowDistance");
    // set from additional component
    __publicField(this, "shadowWidth");
    __publicField(this, "shadowHeight");
    __publicField(this, "_shadowResolution");
    __publicField(this, "light");
    __publicField(this, "_webXRStartedListener");
    __publicField(this, "_webXREndedListener");
    __publicField(this, "_webARRoot");
  }
  set color(val) {
    this._color = val;
    if (this.light !== void 0) {
      this.light.color = val;
    }
  }
  get color() {
    if (this.light)
      return this.light.color;
    return this._color;
  }
  set shadowNearPlane(val) {
    var _a2, _b;
    if (val === this._shadowNearPlane)
      return;
    this._shadowNearPlane = val;
    if (((_b = (_a2 = this.light) == null ? void 0 : _a2.shadow) == null ? void 0 : _b.camera) !== void 0) {
      const cam = this.light.shadow.camera;
      cam.near = val;
    }
  }
  get shadowNearPlane() {
    return this._shadowNearPlane;
  }
  set shadowBias(val) {
    var _a2, _b;
    if (val === this._shadowBias)
      return;
    this._shadowBias = val;
    if (((_b = (_a2 = this.light) == null ? void 0 : _a2.shadow) == null ? void 0 : _b.bias) !== void 0) {
      this.light.shadow.bias = val;
      this.light.shadow.needsUpdate = true;
    }
  }
  get shadowBias() {
    return this._shadowBias;
  }
  set shadowNormalBias(val) {
    var _a2, _b;
    if (val === this._shadowNormalBias)
      return;
    this._shadowNormalBias = val;
    if (((_b = (_a2 = this.light) == null ? void 0 : _a2.shadow) == null ? void 0 : _b.normalBias) !== void 0) {
      this.light.shadow.normalBias = val;
      this.light.shadow.needsUpdate = true;
    }
  }
  get shadowNormalBias() {
    return this._shadowNormalBias;
  }
  set shadows(val) {
    this._shadows = val;
    if (this.light) {
      this.light.castShadow = val !== LightShadows.None;
      this.updateShadowSoftHard();
    }
  }
  get shadows() {
    return this._shadows;
  }
  set intensity(val) {
    var _a2;
    this._intensity = val;
    if (this.light) {
      let factor = 1;
      if (this.context.isInXR && this._webARRoot) {
        const scaleFactor = (_a2 = this._webARRoot) == null ? void 0 : _a2.arScale;
        if (typeof scaleFactor === "number" && scaleFactor > 0) {
          factor /= scaleFactor;
        }
      }
      this.light.intensity = val * factor;
    }
    if (debug93)
      console.log("Set light intensity to " + this._intensity, val, this);
  }
  get intensity() {
    return this._intensity;
  }
  get shadowDistance() {
    const light = this.light;
    if (light == null ? void 0 : light.shadow) {
      const cam = light.shadow.camera;
      return cam.far;
    }
    return -1;
  }
  set shadowDistance(val) {
    this._shadowDistance = val;
    const light = this.light;
    if (light == null ? void 0 : light.shadow) {
      const cam = light.shadow.camera;
      cam.far = val;
      cam.updateProjectionMatrix();
    }
  }
  get shadowResolution() {
    const light = this.light;
    if (light == null ? void 0 : light.shadow) {
      return light.shadow.mapSize.x;
    }
    return -1;
  }
  set shadowResolution(val) {
    if (val === this._shadowResolution)
      return;
    this._shadowResolution = val;
    const light = this.light;
    if (light == null ? void 0 : light.shadow) {
      light.shadow.mapSize.set(val, val);
      light.shadow.needsUpdate = true;
    }
  }
  get isBaked() {
    return this.lightmapBakeType === LightmapBakeType.Baked;
  }
  get selfIsLight() {
    if (this.gameObject["isLight"] === true)
      return true;
    switch (this.gameObject.type) {
      case "SpotLight":
      case "PointLight":
      case "DirectionalLight":
        return true;
    }
    return false;
  }
  getWorldPosition(vec2) {
    if (this.light) {
      if (this.type === LightType.Directional) {
        return this.light.getWorldPosition(vec2).multiplyScalar(1);
      }
      return this.light.getWorldPosition(vec2);
    }
    return vec2;
  }
  // public updateIntensity() {
  //     this.intensity = this._intensity;
  // }
  awake() {
    this.color = new Color(this.color ?? 16777215);
    if (debug93)
      console.log(this.name, this);
  }
  onEnable() {
    if (debug93)
      console.log("ENABLE LIGHT", this.name);
    this.createLight();
    if (this.isBaked)
      return;
    else if (this.light) {
      this.light.visible = true;
      this.light.intensity = this._intensity;
      if (debug93)
        console.log("Set light intensity to " + this.light.intensity, this.name);
      if (this.selfIsLight) {
      } else if (this.light.parent !== this.gameObject)
        this.gameObject.add(this.light);
    }
    if (this.type === LightType.Directional)
      this.startCoroutine(this.updateMainLightRoutine(), FrameEvent.LateUpdate);
  }
  onDisable() {
    if (debug93)
      console.log("DISABLE LIGHT", this.name);
    if (this.light) {
      if (this.selfIsLight)
        this.light.intensity = 0;
      else
        this.light.visible = false;
    }
  }
  onEnterXR(_args) {
    this._webARRoot = GameObject.getComponentInParent(this.gameObject, WebARSessionRoot) ?? void 0;
  }
  // private *_updateLightIntensityInARRoutine() {
  //     while (this.context.isInAR) {
  //         yield;
  //         // this.updateIntensity();
  //         for (let i = 0; i < 30; i++) yield;
  //     }
  // }
  onLeaveXR(_args) {
  }
  createLight() {
    const lightAlreadyCreated = this.selfIsLight;
    if (lightAlreadyCreated && !this.light) {
      this.light = this.gameObject;
      this.light.name = this.name;
      this._intensity = this.light.intensity;
      switch (this.type) {
        case LightType.Directional:
          this.setDirectionalLight(this.light);
          break;
      }
    } else if (!this.light) {
      switch (this.type) {
        case LightType.Directional:
          const dirLight = new DirectionalLight(this.color, this.intensity * Math.PI);
          dirLight.position.set(0, 0, -shadowMaxDistance * 0.5).applyQuaternion(this.gameObject.quaternion);
          this.gameObject.add(dirLight.target);
          setWorldPositionXYZ(dirLight.target, 0, 0, 0);
          this.light = dirLight;
          this.gameObject.position.set(0, 0, 0);
          this.gameObject.rotation.set(0, 0, 0);
          if (debug93) {
            const spotLightHelper = new DirectionalLightHelper(this.light, 0.2, this.color);
            this.context.scene.add(spotLightHelper);
          }
          break;
        case LightType.Spot:
          const spotLight = new SpotLight(this.color, this.intensity * Math.PI, this.range, toRadians(this.spotAngle / 2), 1 - toRadians(this.innerSpotAngle / 2) / toRadians(this.spotAngle / 2), 2);
          spotLight.position.set(0, 0, 0);
          spotLight.rotation.set(0, 0, 0);
          this.light = spotLight;
          const spotLightTarget = spotLight.target;
          spotLight.add(spotLightTarget);
          spotLightTarget.position.set(0, 0, this.range);
          spotLightTarget.rotation.set(0, 0, 0);
          break;
        case LightType.Point:
          const pointLight = new PointLight(this.color, this.intensity * Math.PI, this.range);
          this.light = pointLight;
          break;
      }
    }
    if (this.light) {
      if (this._intensity >= 0)
        this.light.intensity = this._intensity;
      else
        this._intensity = this.light.intensity;
      if (this.shadows !== LightShadows.None) {
        this.light.castShadow = true;
      } else
        this.light.castShadow = false;
      if (this.light.shadow) {
        if (this._shadowResolution !== void 0 && this._shadowResolution > 4) {
          this.light.shadow.mapSize.width = this._shadowResolution;
          this.light.shadow.mapSize.height = this._shadowResolution;
        } else {
          this.light.shadow.mapSize.width = 2048;
          this.light.shadow.mapSize.height = 2048;
        }
        if (debug93)
          console.log("Override shadow bias?", this._overrideShadowBiasSettings, this.shadowBias, this.shadowNormalBias);
        this.light.shadow.bias = this.shadowBias;
        this.light.shadow.normalBias = this.shadowNormalBias;
        this.updateShadowSoftHard();
        const cam = this.light.shadow.camera;
        cam.near = this.shadowNearPlane;
        if (this._shadowDistance !== void 0 && typeof this._shadowDistance === "number")
          cam.far = this._shadowDistance;
        else
          cam.far = shadowMaxDistance * Math.abs(this.gameObject.scale.z);
        this.gameObject.scale.set(1, 1, 1);
        if (this.shadowWidth !== void 0) {
          cam.left = -this.shadowWidth / 2;
          cam.right = this.shadowWidth / 2;
        } else {
          const sx = this.gameObject.scale.x;
          cam.left *= sx;
          cam.right *= sx;
        }
        if (this.shadowHeight !== void 0) {
          cam.top = this.shadowHeight / 2;
          cam.bottom = -this.shadowHeight / 2;
        } else {
          const sy = this.gameObject.scale.y;
          cam.top *= sy;
          cam.bottom *= sy;
        }
        this.light.shadow.needsUpdate = true;
        if (debug93)
          this.context.scene.add(new CameraHelper(cam));
      }
      if (this.isBaked) {
        this.light.removeFromParent();
      } else if (!lightAlreadyCreated)
        this.gameObject.add(this.light);
    }
  }
  *updateMainLightRoutine() {
    while (true) {
      if (this.type === LightType.Directional) {
        if (!this.context.mainLight || this.intensity > this.context.mainLight.intensity) {
          this.context.mainLight = this;
        }
        yield;
      }
      break;
    }
  }
  updateShadowSoftHard() {
    if (!this.light)
      return;
    if (!this.light.shadow)
      return;
    if (this.shadows === LightShadows.Soft) {
    } else {
      this.light.shadow.radius = 1;
      this.light.shadow.blurSamples = 1;
    }
  }
  setDirectionalLight(dirLight) {
    dirLight.add(dirLight.target);
    dirLight.target.position.set(0, 0, -1);
  }
};
__publicField(Light, "allowChangingRendererShadowMapType", true);
__decorate64([
  serializable()
], Light.prototype, "type", void 0);
__decorate64([
  serializable(Color)
], Light.prototype, "color", null);
__decorate64([
  serializable()
], Light.prototype, "shadowNearPlane", null);
__decorate64([
  serializable()
], Light.prototype, "shadowBias", null);
__decorate64([
  serializable()
], Light.prototype, "shadowNormalBias", null);
__decorate64([
  serializable()
], Light.prototype, "shadows", null);
__decorate64([
  serializable()
], Light.prototype, "lightmapBakeType", void 0);
__decorate64([
  serializable()
], Light.prototype, "intensity", null);
__decorate64([
  serializable()
], Light.prototype, "shadowDistance", null);
__decorate64([
  serializable()
], Light.prototype, "shadowResolution", null);
var vec = new Vector32(0, 0, 0);

// node_modules/@needle-tools/engine/lib/engine-components/LODGroup.js
var __decorate65 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug94 = getParam("debuglods");
var noLods = getParam("nolods");
var LODFadeMode;
(function(LODFadeMode2) {
  LODFadeMode2[LODFadeMode2["None"] = 0] = "None";
  LODFadeMode2[LODFadeMode2["CrossFade"] = 1] = "CrossFade";
  LODFadeMode2[LODFadeMode2["SpeedTree"] = 2] = "SpeedTree";
})(LODFadeMode || (LODFadeMode = {}));
var LODModel = class {
  constructor() {
    __publicField(this, "screenRelativeTransitionHeight");
    __publicField(this, "distance");
    __publicField(this, "renderers");
  }
};
__decorate65([
  serializable()
], LODModel.prototype, "screenRelativeTransitionHeight", void 0);
__decorate65([
  serializable()
], LODModel.prototype, "distance", void 0);
__decorate65([
  serializable(Renderer)
], LODModel.prototype, "renderers", void 0);
var LOD2 = class {
  constructor(model) {
    __publicField(this, "model");
    this.model = model;
  }
  get renderers() {
    return this.model.renderers;
  }
};
var LODGroup = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "fadeMode", LODFadeMode.None);
    __publicField(this, "localReferencePoint");
    __publicField(this, "lodCount", 0);
    __publicField(this, "size", 0);
    __publicField(this, "animateCrossFading", false);
    __publicField(this, "lodModels");
    __publicField(this, "_lods", []);
    __publicField(this, "_settings", []);
    // https://threejs.org/docs/#api/en/objects/LOD
    __publicField(this, "_lodsHandler");
    __publicField(this, "_distanceFactor", 1);
  }
  start() {
    if (debug94)
      console.log("LODGROUP", this.name, this.lodModels, this);
    if (noLods)
      return;
    if (this._lodsHandler)
      return;
    if (!this.gameObject)
      return;
    if (this.lodModels && Array.isArray(this.lodModels)) {
      const renderers = [];
      for (const model of this.lodModels) {
        const lod = new LOD2(model);
        this._lods.push(lod);
        for (const rend of lod.renderers) {
          if (!renderers.includes(rend))
            renderers.push(rend);
        }
      }
      this._lodsHandler = new Array();
      for (let i = 0; i < renderers.length; i++) {
        const handler = new LOD();
        this._lodsHandler.push(handler);
        this.gameObject.add(handler);
      }
      const empty = new Object3D();
      empty.name = "Cull " + this.name;
      for (let i = 0; i < renderers.length; i++) {
        const rend = renderers[i];
        const handler = this._lodsHandler[i];
        const obj = rend.gameObject;
        if (debug94)
          console.log(i, obj.name);
        for (const lod of this._lods) {
          const dist = lod.model.distance;
          let object = null;
          if (lod.renderers.includes(rend)) {
            object = obj;
          } else {
            object = empty;
          }
          if (object.type === "Group") {
            console.warn(`LODGroup ${this.name}: Group or MultiMaterial object's are not supported as LOD object: ${object.name}`);
            continue;
          }
          if (debug94)
            console.log("LEVEL", object.name, dist);
          handler.autoUpdate = false;
          this.onAddLodLevel(handler, object, lod.model.distance);
        }
      }
    }
  }
  onAfterRender() {
    if (!this.gameObject)
      return;
    if (!this._lodsHandler)
      return;
    const cam = this.context.mainCamera;
    if (!cam)
      return;
    for (const h of this._lodsHandler) {
      h.update(cam);
      const levelIndex = h.getCurrentLevel();
      const level = h.levels[levelIndex];
      h.layers.mask = level.object.layers.mask;
    }
  }
  onAddLodLevel(lod, obj, dist) {
    if (obj === this.gameObject) {
      console.warn("LODGroup component must be on parent object and not mesh directly at the moment", obj.name, obj);
      return;
    }
    lod.addLevel(obj, dist * this._distanceFactor, 0.01);
    const setting = { lod, levelIndex: lod.levels.length - 1, distance: dist };
    this._settings.push(setting);
  }
  distanceFactor(factor) {
    if (factor === this._distanceFactor)
      return;
    this._distanceFactor = factor;
    for (const setting of this._settings) {
      const level = setting.lod.levels[setting.levelIndex];
      level.distance = setting.distance * factor;
    }
  }
};
__decorate65([
  serializable(Vector32)
], LODGroup.prototype, "localReferencePoint", void 0);
__decorate65([
  serializable(LODModel)
], LODGroup.prototype, "lodModels", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/debug/LogStats.js
var debug95 = getParam("logstats");
var LogStats = class extends Component2 {
  onEnable() {
    console.log(this);
    if (debug95)
      this.startCoroutine(this.run(), FrameEvent.OnAfterRender);
  }
  *run() {
    while (this.enabled) {
      const info = this.context.renderer.info;
      console.log(info.memory, info.render, info.programs);
      yield;
    }
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/utils/LookAt.js
var __decorate66 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var _LookAt = class extends Component2 {
  constructor() {
    super(...arguments);
    /**
     * The target object to look at. If not set, the main camera will be used.
     */
    __publicField(this, "target");
    /**
     * Inverts the forward direction.
     */
    __publicField(this, "invertForward", false);
    /**
     * Keep the up direction.
     */
    __publicField(this, "keepUpDirection", true);
    /**
     * Copy the target rotation.
     */
    __publicField(this, "copyTargetRotation", false);
  }
  /** @internal */
  onBeforeRender() {
    let target = this.target;
    if (!target)
      target = this.context.mainCamera;
    if (!target)
      return;
    let copyTargetRotation = this.copyTargetRotation;
    if (this.context.isInVR || this.context.isInPassThrough) {
      copyTargetRotation = false;
    }
    lookAtObject(this.gameObject, target, this.keepUpDirection, copyTargetRotation);
    if (this.invertForward)
      this.gameObject.quaternion.multiply(_LookAt.flipYQuat);
  }
  /** @internal */
  createBehaviours(ext, model, _context) {
    if (model.uuid === this.gameObject.uuid) {
      let alignmentTarget = model;
      if (this.keepUpDirection) {
        const parent = USDObject.createEmptyParent(model);
        alignmentTarget = parent;
        const flip = this.invertForward ? -1 : 1;
        parent.setMatrix(parent.getMatrix().multiply(new Matrix4().makeRotationZ(Math.PI / 2 * flip)));
        model.setMatrix(model.getMatrix().multiply(new Matrix4().makeRotationZ(-Math.PI / 2 * flip)));
      }
      const lookAt = new BehaviorModel("lookat " + this.name, TriggerBuilder.sceneStartTrigger(), ActionBuilder.lookAtCameraAction(alignmentTarget, void 0, this.invertForward ? Vec3.back : Vec3.forward, this.keepUpDirection ? Vec3.up : Vec3.zero));
      ext.addBehavior(lookAt);
    }
  }
};
var LookAt = _LookAt;
__publicField(LookAt, "flipYQuat", new Quaternion().setFromAxisAngle(new Vector32(0, 1, 0), Math.PI));
__decorate66([
  serializable(Object3D)
], LookAt.prototype, "target", void 0);
__decorate66([
  serializable()
], LookAt.prototype, "invertForward", void 0);
__decorate66([
  serializable()
], LookAt.prototype, "keepUpDirection", void 0);
__decorate66([
  serializable()
], LookAt.prototype, "copyTargetRotation", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/NestedGltf.js
var __decorate67 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug96 = getParam("debugnestedgltf");
var NestedGltf = class extends Component2 {
  constructor() {
    super(...arguments);
    /**
     * A reference to the gltf file that should be loaded
     */
    __publicField(this, "filePath");
    /**
     * EXPERIMENTAL for cloud asset loading
     */
    __publicField(this, "loadAssetInParent", true);
    __publicField(this, "_isLoadingOrDoneLoading", false);
  }
  /** Register a callback that will be called when the progress of the loading changes */
  listenToProgress(evt) {
    var _a2;
    (_a2 = this.filePath) == null ? void 0 : _a2.beginListenDownload(evt);
  }
  /** Begin loading the referenced gltf file in filePath */
  preload() {
    var _a2;
    (_a2 = this.filePath) == null ? void 0 : _a2.preload();
  }
  /** @internal */
  async start() {
    var _a2, _b, _c, _d, _e;
    if (this._isLoadingOrDoneLoading)
      return;
    if (debug96)
      console.log(this, this.guid);
    const parent = this.gameObject.parent;
    if (parent) {
      this._isLoadingOrDoneLoading = true;
      const opts = new InstantiateOptions();
      opts.idProvider = new InstantiateIdProvider(this.hash(this.guid));
      opts.parent = this.loadAssetInParent !== false ? parent : this.gameObject;
      this.gameObject.updateMatrix();
      const matrix = this.gameObject.matrix;
      if (debug96)
        console.log("Load nested:", ((_a2 = this.filePath) == null ? void 0 : _a2.url) ?? this.filePath, this.gameObject.position);
      const res = await ((_c = (_b = this.filePath) == null ? void 0 : _b.instantiate) == null ? void 0 : _c.call(this.filePath, opts));
      if (debug96)
        console.log("Nested loaded:", ((_d = this.filePath) == null ? void 0 : _d.url) ?? this.filePath, res);
      if (res && this.loadAssetInParent !== false) {
        res.matrixAutoUpdate = false;
        res.matrix.identity();
        res.applyMatrix4(matrix);
        res.matrixAutoUpdate = true;
        res.layers.disableAll();
        res.layers.set(this.layer);
        this.dispatchEvent(new CustomEvent("loaded", { detail: { instance: res, assetReference: this.filePath } }));
      }
      if (debug96)
        console.log("Nested loading done:", ((_e = this.filePath) == null ? void 0 : _e.url) ?? this.filePath, res);
    }
  }
  /** @internal */
  onDestroy() {
    var _a2;
    (_a2 = this.filePath) == null ? void 0 : _a2.unload();
  }
  hash(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      hash = str.charCodeAt(i) + ((hash << 5) - hash);
    }
    return hash;
  }
};
__decorate67([
  serializable(AssetReference)
], NestedGltf.prototype, "filePath", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/Networking.js
var __decorate68 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug97 = getParam("debugnet");
var Networking = class extends Component2 {
  constructor() {
    super(...arguments);
    /** The url that should be used for the websocket connection */
    __publicField(this, "url", null);
    /** The name of the url parameter that should be used to override the url. When set the url will be overridden by the url parameter e.g. when `urlParameterName=ws` `?ws=ws://localhost:8080` */
    __publicField(this, "urlParameterName", null);
    /** Thie localhost url that should be used when the networking is running on a local network. This is useful when the server is running on the same machine as the client.
     */
    __publicField(this, "localhost", null);
  }
  /** @internal */
  awake() {
    if (debug97)
      console.log(this);
    this.context.connection.registerProvider(this);
  }
  /** @internal */
  getWebsocketUrl() {
    let socketurl = this.url ? Networking.GetUrl(this.url, this.localhost) : null;
    if (this.urlParameterName) {
      const res = getParam(this.urlParameterName);
      if (res && typeof res === "string") {
        socketurl = res;
      }
    }
    if (!socketurl)
      return null;
    const regex = new RegExp("(((https?)|(?<socket_prefix>wss?))://)?(www.)?(?<url>.+)", "gm");
    const match = regex.exec(socketurl);
    if (!(match == null ? void 0 : match.groups))
      return null;
    const socketPrefix = match == null ? void 0 : match.groups["socket_prefix"];
    if (socketPrefix)
      return socketurl;
    return "wss://" + (match == null ? void 0 : match.groups["url"]);
  }
  static GetUrl(url, localhostFallback) {
    let result = url;
    const useLocalHostUrl = Networking.IsLocalNetwork() && localhostFallback;
    if (useLocalHostUrl) {
      result = localhostFallback;
    }
    if (url == null ? void 0 : url.startsWith("/")) {
      const base = useLocalHostUrl ? result : window.location.origin;
      if ((base == null ? void 0 : base.endsWith("/")) && url.startsWith("/"))
        url = url.substring(1);
      result = base + url;
    }
    return result;
  }
  static IsLocalNetwork(hostname = window.location.hostname) {
    return isLocalNetwork(hostname);
  }
};
__decorate68([
  serializable()
], Networking.prototype, "url", void 0);
__decorate68([
  serializable()
], Networking.prototype, "urlParameterName", void 0);
__decorate68([
  serializable()
], Networking.prototype, "localhost", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/OffsetConstraint.js
var __decorate69 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var OffsetConstraint = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "referenceSpace");
    __publicField(this, "from");
    __publicField(this, "affectPosition", false);
    __publicField(this, "affectRotation", false);
    __publicField(this, "alignLookDirection", false);
    __publicField(this, "levelLookDirection", false);
    __publicField(this, "levelPosition", false);
    __publicField(this, "positionOffset", new Vector32(0, 0, 0));
    __publicField(this, "rotationOffset", new Vector32(0, 0, 0));
    __publicField(this, "offset", new Vector32(0, 0, 0));
  }
  update() {
    if (!this.from)
      return;
    var pos = getWorldPosition(this.from);
    var rot = getWorldQuaternion(this.from);
    this.offset.copy(this.positionOffset);
    const l = this.offset.length();
    if (this.referenceSpace)
      this.offset.transformDirection(this.referenceSpace.matrixWorld).multiplyScalar(l);
    pos.add(this.offset);
    if (this.levelPosition && this.referenceSpace) {
      const plane = new Plane(this.gameObject.up, 0);
      const refSpacePoint = getWorldPosition(this.referenceSpace);
      plane.setFromNormalAndCoplanarPoint(this.gameObject.up, refSpacePoint);
      const v22 = new Vector32(0, 0, 0);
      plane.projectPoint(pos, v22);
      pos.copy(v22);
    }
    if (this.affectPosition)
      setWorldPosition(this.gameObject, pos);
    const euler2 = new Euler(this.rotationOffset.x, this.rotationOffset.y, this.rotationOffset.z);
    const quat = new Quaternion().setFromEuler(euler2);
    if (this.affectRotation)
      setWorldQuaternion(this.gameObject, rot.multiply(quat));
    const lookDirection = new Vector32();
    this.from.getWorldDirection(lookDirection).multiplyScalar(50);
    if (this.levelLookDirection)
      lookDirection.y = 0;
    if (this.alignLookDirection)
      this.gameObject.lookAt(lookDirection);
  }
};
__decorate69([
  serializable(GameObject)
], OffsetConstraint.prototype, "referenceSpace", void 0);
__decorate69([
  serializable(GameObject)
], OffsetConstraint.prototype, "from", void 0);
__decorate69([
  serializable(Vector32)
], OffsetConstraint.prototype, "positionOffset", void 0);
__decorate69([
  serializable(Vector32)
], OffsetConstraint.prototype, "rotationOffset", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/utils/OpenURL.js
var __decorate70 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var OpenURLMode;
(function(OpenURLMode2) {
  OpenURLMode2[OpenURLMode2["NewTab"] = 0] = "NewTab";
  OpenURLMode2[OpenURLMode2["SameTab"] = 1] = "SameTab";
  OpenURLMode2[OpenURLMode2["NewWindow"] = 2] = "NewWindow";
})(OpenURLMode || (OpenURLMode = {}));
var OpenURL = class extends Component2 {
  constructor() {
    super(...arguments);
    /**
     * The URL to open.
     */
    __publicField(this, "url");
    /**
     * The mode in which the URL should be opened: NewTab, SameTab, NewWindow.
     */
    __publicField(this, "mode", OpenURLMode.NewTab);
    /**
     * If true, the URL will be opened when the object with this component is clicked.
     */
    __publicField(this, "clickable", true);
  }
  /**
   * Opens the URL in a new tab or window.
   */
  async open() {
    if (!this.url) {
      console.warn("OpenURL: URL is not set, can't open.", this);
      return;
    }
    this._validateUrl();
    let url = this.url;
    if (!url.startsWith("mailto:") && url.includes("@")) {
      url = "mailto:" + url;
    }
    if (isDevEnvironment())
      showBalloonMessage("Open URL: " + url);
    switch (this.mode) {
      case OpenURLMode.NewTab:
        if (DeviceUtilities.isSafari()) {
          globalThis.open(url, "_blank");
        } else
          globalThis.open(url, "_blank");
        break;
      case OpenURLMode.SameTab:
        if (DeviceUtilities.isSafari() && DeviceUtilities.isiOS()) {
          globalThis.open(url, "_top");
        } else
          globalThis.open(url, "_self");
        break;
      case OpenURLMode.NewWindow:
        if (DeviceUtilities.isSafari()) {
          globalThis.open(url, "_top");
        } else
          globalThis.open(url, "_new");
        break;
    }
  }
  /** @internal */
  start() {
    const raycaster = this.gameObject.getComponentInParent(ObjectRaycaster);
    if (!raycaster)
      this.gameObject.addComponent(ObjectRaycaster);
  }
  /** @internal */
  onPointerEnter(args) {
    if (!args.used && this.clickable)
      this.context.input.setCursorPointer();
  }
  /** @internal */
  onPointerExit() {
    if (this.clickable)
      this.context.input.setCursorNormal();
  }
  /** @internal */
  onPointerClick(args) {
    var _a2;
    if (this.clickable && !args.used && ((_a2 = this.url) == null ? void 0 : _a2.length))
      this.open();
  }
  _validateUrl() {
    if (!this.url)
      return;
    if (this.url.startsWith("www.")) {
      if (isDevEnvironment()) {
        console.warn("URL is not valid, adding https:// to the start of the URL", this.url);
      }
      this.url = "https://" + this.url;
    }
  }
};
__decorate70([
  serializable()
], OpenURL.prototype, "url", void 0);
__decorate70([
  serializable()
], OpenURL.prototype, "mode", void 0);
__decorate70([
  serializable()
], OpenURL.prototype, "clickable", void 0);

// node_modules/quarks.core/dist/quarks.core.esm.js
var _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
var _seed = 1234567;
var DEG2RAD = Math.PI / 180;
var RAD2DEG = 180 / Math.PI;
function generateUUID() {
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d2 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
  return uuid.toLowerCase();
}
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function euclideanModulo(n2, m2) {
  return (n2 % m2 + m2) % m2;
}
function mapLinear(x2, a1, a2, b1, b2) {
  return b1 + (x2 - a1) * (b2 - b1) / (a2 - a1);
}
function inverseLerp(x2, y, value) {
  if (x2 !== y) {
    return (value - x2) / (y - x2);
  } else {
    return 0;
  }
}
function lerp(x2, y, t2) {
  return (1 - t2) * x2 + t2 * y;
}
function damp(x2, y, lambda, dt) {
  return lerp(x2, y, 1 - Math.exp(-lambda * dt));
}
function pingpong(x2, length = 1) {
  return length - Math.abs(euclideanModulo(x2, length * 2) - length);
}
function smoothstep(x2, min, max) {
  if (x2 <= min)
    return 0;
  if (x2 >= max)
    return 1;
  x2 = (x2 - min) / (max - min);
  return x2 * x2 * (3 - 2 * x2);
}
function smootherstep(x2, min, max) {
  if (x2 <= min)
    return 0;
  if (x2 >= max)
    return 1;
  x2 = (x2 - min) / (max - min);
  return x2 * x2 * x2 * (x2 * (x2 * 6 - 15) + 10);
}
function randInt(low, high) {
  return low + Math.floor(Math.random() * (high - low + 1));
}
function randFloat(low, high) {
  return low + Math.random() * (high - low);
}
function randFloatSpread(range) {
  return range * (0.5 - Math.random());
}
function seededRandom(s) {
  if (s !== void 0)
    _seed = s;
  let t2 = _seed += 1831565813;
  t2 = Math.imul(t2 ^ t2 >>> 15, t2 | 1);
  t2 ^= t2 + Math.imul(t2 ^ t2 >>> 7, t2 | 61);
  return ((t2 ^ t2 >>> 14) >>> 0) / 4294967296;
}
function degToRad(degrees) {
  return degrees * DEG2RAD;
}
function radToDeg(radians) {
  return radians * RAD2DEG;
}
function isPowerOfTwo(value) {
  return (value & value - 1) === 0 && value !== 0;
}
function ceilPowerOfTwo(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}
function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
function setQuaternionFromProperEuler(q, a, b, c2, order) {
  const cos = Math.cos;
  const sin = Math.sin;
  const c22 = cos(b / 2);
  const s2 = sin(b / 2);
  const c13 = cos((a + c2) / 2);
  const s13 = sin((a + c2) / 2);
  const c1_3 = cos((a - c2) / 2);
  const s1_3 = sin((a - c2) / 2);
  const c3_1 = cos((c2 - a) / 2);
  const s3_1 = sin((c2 - a) / 2);
  switch (order) {
    case "XYX":
      q.set(c22 * s13, s2 * c1_3, s2 * s1_3, c22 * c13);
      break;
    case "YZY":
      q.set(s2 * s1_3, c22 * s13, s2 * c1_3, c22 * c13);
      break;
    case "ZXZ":
      q.set(s2 * c1_3, s2 * s1_3, c22 * s13, c22 * c13);
      break;
    case "XZX":
      q.set(c22 * s13, s2 * s3_1, s2 * c3_1, c22 * c13);
      break;
    case "YXY":
      q.set(s2 * c3_1, c22 * s13, s2 * s3_1, c22 * c13);
      break;
    case "ZYZ":
      q.set(s2 * s3_1, s2 * c3_1, c22 * s13, c22 * c13);
      break;
    default:
      console.warn("../math.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
  }
}
function denormalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return value / 4294967295;
    case Uint16Array:
      return value / 65535;
    case Uint8Array:
      return value / 255;
    case Int32Array:
      return Math.max(value / 2147483647, -1);
    case Int16Array:
      return Math.max(value / 32767, -1);
    case Int8Array:
      return Math.max(value / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function normalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return Math.round(value * 4294967295);
    case Uint16Array:
      return Math.round(value * 65535);
    case Uint8Array:
      return Math.round(value * 255);
    case Int32Array:
      return Math.round(value * 2147483647);
    case Int16Array:
      return Math.round(value * 32767);
    case Int8Array:
      return Math.round(value * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
var MathUtils2 = {
  DEG2RAD,
  RAD2DEG,
  generateUUID,
  clamp,
  euclideanModulo,
  mapLinear,
  inverseLerp,
  lerp,
  damp,
  pingpong,
  smoothstep,
  smootherstep,
  randInt,
  randFloat,
  randFloatSpread,
  seededRandom,
  degToRad,
  radToDeg,
  isPowerOfTwo,
  ceilPowerOfTwo,
  floorPowerOfTwo,
  setQuaternionFromProperEuler,
  normalize,
  denormalize
};
var Quaternion2 = class {
  constructor(x2 = 0, y = 0, z = 0, w = 1) {
    this.isQuaternion = true;
    this._x = x2;
    this._y = y;
    this._z = z;
    this._w = w;
  }
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t2) {
    let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
    if (t2 === 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
      return;
    }
    if (t2 === 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w1;
      return;
    }
    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s = 1 - t2;
      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
        s = Math.sin(s * len) / sin;
        t2 = Math.sin(t2 * len) / sin;
      }
      const tDir = t2 * dir;
      x0 = x0 * s + x1 * tDir;
      y0 = y0 * s + y1 * tDir;
      z0 = z0 * s + z1 * tDir;
      w0 = w0 * s + w1 * tDir;
      if (s === 1 - t2) {
        const f2 = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f2;
        y0 *= f2;
        z0 *= f2;
        w0 *= f2;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._onChangeCallback();
  }
  set(x2, y, z, w) {
    this._x = x2;
    this._y = y;
    this._z = z;
    this._w = w;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new Quaternion2(this._x, this._y, this._z, this._w);
  }
  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this._onChangeCallback();
    return this;
  }
  setFromEuler(euler2, update2 = true) {
    const x2 = euler2._x, y = euler2._y, z = euler2._z, order = euler2._order;
    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x2 / 2);
    const c2 = cos(y / 2);
    const c3 = cos(z / 2);
    const s1 = sin(x2 / 2);
    const s2 = sin(y / 2);
    const s3 = sin(z / 2);
    switch (order) {
      case "XYZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "YXZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "ZXY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "ZYX":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "YZX":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "XZY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      default:
        console.warn("../math.Quaternion: .setFromEuler() encountered an unknown order: " + order);
    }
    if (update2 === true)
      this._onChangeCallback();
    return this;
  }
  setFromAxisAngle(axis, angle) {
    const halfAngle = angle / 2, s = Math.sin(halfAngle);
    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m2) {
    const te2 = m2.elements, m11 = te2[0], m12 = te2[4], m13 = te2[8], m21 = te2[1], m22 = te2[5], m23 = te2[9], m31 = te2[2], m32 = te2[6], m33 = te2[10], trace = m11 + m22 + m33;
    if (trace > 0) {
      const s = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {
      const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {
      const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }
    this._onChangeCallback();
    return this;
  }
  setFromUnitVectors(vFrom, vTo) {
    let r = vFrom.dot(vTo) + 1;
    if (r < Number.EPSILON) {
      r = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r;
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r;
    }
    return this.normalize();
  }
  angleTo(q) {
    return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
  }
  rotateTowards(q, step) {
    const angle = this.angleTo(q);
    if (angle === 0)
      return this;
    const t2 = Math.min(1, step / angle);
    this.slerp(q, t2);
    return this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }
  dot(v4) {
    return this._x * v4._x + this._y * v4._y + this._z * v4._z + this._w * v4._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let l = this.length();
    if (l === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l = 1 / l;
      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }
    this._onChangeCallback();
    return this;
  }
  multiply(q) {
    return this.multiplyQuaternions(this, q);
  }
  premultiply(q) {
    return this.multiplyQuaternions(q, this);
  }
  multiplyQuaternions(a, b) {
    const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._onChangeCallback();
    return this;
  }
  slerp(qb, t2) {
    if (t2 === 0)
      return this;
    if (t2 === 1)
      return this.copy(qb);
    const x2 = this._x, y = this._y, z = this._z, w = this._w;
    let cosHalfTheta = w * qb._w + x2 * qb._x + y * qb._y + z * qb._z;
    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1) {
      this._w = w;
      this._x = x2;
      this._y = y;
      this._z = z;
      return this;
    }
    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s = 1 - t2;
      this._w = s * w + t2 * this._w;
      this._x = s * x2 + t2 * this._x;
      this._y = s * y + t2 * this._y;
      this._z = s * z + t2 * this._z;
      this.normalize();
      return this;
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t2) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t2 * halfTheta) / sinHalfTheta;
    this._w = w * ratioA + this._w * ratioB;
    this._x = x2 * ratioA + this._x * ratioB;
    this._y = y * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;
    this._onChangeCallback();
    return this;
  }
  slerpQuaternions(qa, qb, t2) {
    return this.copy(qa).slerp(qb, t2);
  }
  random() {
    const theta1 = 2 * Math.PI * Math.random();
    const theta2 = 2 * Math.PI * Math.random();
    const x0 = Math.random();
    const r1 = Math.sqrt(1 - x0);
    const r2 = Math.sqrt(x0);
    return this.set(r1 * Math.sin(theta1), r1 * Math.cos(theta1), r2 * Math.sin(theta2), r2 * Math.cos(theta2));
  }
  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }
  fromArray(array, offset = 0) {
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._w;
  }
};
var Vector33 = class {
  constructor(x2 = 0, y = 0, z = 0) {
    this.isVector3 = true;
    Vector33.prototype.isVector3 = true;
    this.x = x2;
    this.y = y;
    this.z = z;
  }
  set(x2, y, z) {
    if (z === void 0)
      z = this.z;
    this.x = x2;
    this.y = y;
    this.z = z;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }
  setX(x2) {
    this.x = x2;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setZ(z) {
    this.z = z;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new Vector33(this.x, this.y, this.z);
  }
  copy(v4) {
    this.x = v4.x;
    this.y = v4.y;
    this.z = v4.z;
    return this;
  }
  add(v4) {
    this.x += v4.x;
    this.y += v4.y;
    this.z += v4.z;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  }
  addScaledVector(v4, s) {
    this.x += v4.x * s;
    this.y += v4.y * s;
    this.z += v4.z * s;
    return this;
  }
  sub(v4) {
    this.x -= v4.x;
    this.y -= v4.y;
    this.z -= v4.z;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  }
  multiply(v4) {
    this.x *= v4.x;
    this.y *= v4.y;
    this.z *= v4.z;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  multiplyVectors(a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  }
  applyEuler(euler2) {
    return this.applyQuaternion(_quaternion$1.setFromEuler(euler2));
  }
  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion$1.setFromAxisAngle(axis, angle));
  }
  applyMatrix3(m2) {
    const x2 = this.x, y = this.y, z = this.z;
    const e = m2.elements;
    this.x = e[0] * x2 + e[3] * y + e[6] * z;
    this.y = e[1] * x2 + e[4] * y + e[7] * z;
    this.z = e[2] * x2 + e[5] * y + e[8] * z;
    return this;
  }
  applyNormalMatrix(m2) {
    return this.applyMatrix3(m2).normalize();
  }
  applyMatrix4(m2) {
    const x2 = this.x, y = this.y, z = this.z;
    const e = m2.elements;
    const w = 1 / (e[3] * x2 + e[7] * y + e[11] * z + e[15]);
    this.x = (e[0] * x2 + e[4] * y + e[8] * z + e[12]) * w;
    this.y = (e[1] * x2 + e[5] * y + e[9] * z + e[13]) * w;
    this.z = (e[2] * x2 + e[6] * y + e[10] * z + e[14]) * w;
    return this;
  }
  applyQuaternion(q) {
    const vx = this.x, vy = this.y, vz = this.z;
    const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
    const tx = 2 * (qy * vz - qz * vy);
    const ty = 2 * (qz * vx - qx * vz);
    const tz = 2 * (qx * vy - qy * vx);
    this.x = vx + qw * tx + qy * tz - qz * ty;
    this.y = vy + qw * ty + qz * tx - qx * tz;
    this.z = vz + qw * tz + qx * ty - qy * tx;
    return this;
  }
  transformDirection(m2) {
    const x2 = this.x, y = this.y, z = this.z;
    const e = m2.elements;
    this.x = e[0] * x2 + e[4] * y + e[8] * z;
    this.y = e[1] * x2 + e[5] * y + e[9] * z;
    this.z = e[2] * x2 + e[6] * y + e[10] * z;
    return this.normalize();
  }
  divide(v4) {
    this.x /= v4.x;
    this.y /= v4.y;
    this.z /= v4.z;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v4) {
    this.x = Math.min(this.x, v4.x);
    this.y = Math.min(this.y, v4.y);
    this.z = Math.min(this.z, v4.z);
    return this;
  }
  max(v4) {
    this.x = Math.max(this.x, v4.x);
    this.y = Math.max(this.y, v4.y);
    this.z = Math.max(this.z, v4.z);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  dot(v4) {
    return this.x * v4.x + this.y * v4.y + this.z * v4.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v4, alpha) {
    this.x += (v4.x - this.x) * alpha;
    this.y += (v4.y - this.y) * alpha;
    this.z += (v4.z - this.z) * alpha;
    return this;
  }
  lerpVectors(v1, v22, alpha) {
    this.x = v1.x + (v22.x - v1.x) * alpha;
    this.y = v1.y + (v22.y - v1.y) * alpha;
    this.z = v1.z + (v22.z - v1.z) * alpha;
    return this;
  }
  cross(v4) {
    return this.crossVectors(this, v4);
  }
  crossVectors(a, b) {
    const ax = a.x, ay = a.y, az = a.z;
    const bx = b.x, by = b.y, bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
  projectOnVector(v4) {
    const denominator = v4.lengthSq();
    if (denominator === 0)
      return this.set(0, 0, 0);
    const scalar = v4.dot(this) / denominator;
    return this.copy(v4).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    _vector2.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector2);
  }
  reflect(normal) {
    return this.sub(_vector2.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }
  angleTo(v4) {
    const denominator = Math.sqrt(this.lengthSq() * v4.lengthSq());
    if (denominator === 0)
      return Math.PI / 2;
    const theta = this.dot(v4) / denominator;
    return Math.acos(clamp(theta, -1, 1));
  }
  distanceTo(v4) {
    return Math.sqrt(this.distanceToSquared(v4));
  }
  distanceToSquared(v4) {
    const dx = this.x - v4.x, dy = this.y - v4.y, dz = this.z - v4.z;
    return dx * dx + dy * dy + dz * dz;
  }
  manhattanDistanceTo(v4) {
    return Math.abs(this.x - v4.x) + Math.abs(this.y - v4.y) + Math.abs(this.z - v4.z);
  }
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }
  setFromCylindricalCoords(radius, theta, y) {
    this.x = radius * Math.sin(theta);
    this.y = y;
    this.z = radius * Math.cos(theta);
    return this;
  }
  setFromMatrixPosition(m2) {
    const e = m2.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    return this;
  }
  setFromMatrixScale(m2) {
    const sx = this.setFromMatrixColumn(m2, 0).length();
    const sy = this.setFromMatrixColumn(m2, 1).length();
    const sz = this.setFromMatrixColumn(m2, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }
  setFromMatrixColumn(m2, index) {
    return this.fromArray(m2.elements, index * 4);
  }
  setFromMatrix3Column(m2, index) {
    return this.fromArray(m2.elements, index * 3);
  }
  setFromEuler(e) {
    this.x = e._x;
    this.y = e._y;
    this.z = e._z;
    return this;
  }
  equals(v4) {
    return v4.x === this.x && v4.y === this.y && v4.z === this.z;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
  randomDirection() {
    const theta = Math.random() * Math.PI * 2;
    const u2 = Math.random() * 2 - 1;
    const c2 = Math.sqrt(1 - u2 * u2);
    this.x = c2 * Math.cos(theta);
    this.y = u2;
    this.z = c2 * Math.sin(theta);
    return this;
  }
  abs() {
    this.x = Math.abs(this.x);
    this.y = Math.abs(this.y);
    this.z = Math.abs(this.z);
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
  }
};
var _vector2 = new Vector33();
var _quaternion$1 = new Quaternion2();
var WebGLCoordinateSystem = 2e3;
var WebGPUCoordinateSystem = 2001;
var Matrix42 = class {
  constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    this.isMatrix4 = true;
    Matrix42.prototype.isMatrix4 = true;
    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    if (n11 !== void 0) {
      this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
    }
  }
  extractPosition(m2) {
    console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
    return this.copyPosition(m2);
  }
  multiplyToArray(a, b, r) {
    console.error("THREE.Matrix4: .multiplyToArray() has been removed.");
    return this;
  }
  setRotationFromQuaternion(q) {
    return this.makeRotationFromQuaternion(q);
  }
  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te2 = this.elements;
    te2[0] = n11;
    te2[4] = n12;
    te2[8] = n13;
    te2[12] = n14;
    te2[1] = n21;
    te2[5] = n22;
    te2[9] = n23;
    te2[13] = n24;
    te2[2] = n31;
    te2[6] = n32;
    te2[10] = n33;
    te2[14] = n34;
    te2[3] = n41;
    te2[7] = n42;
    te2[11] = n43;
    te2[15] = n44;
    return this;
  }
  identity() {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  clone() {
    return new Matrix42().fromArray(this.elements);
  }
  copy(m2) {
    const te2 = this.elements;
    const me = m2.elements;
    te2[0] = me[0];
    te2[1] = me[1];
    te2[2] = me[2];
    te2[3] = me[3];
    te2[4] = me[4];
    te2[5] = me[5];
    te2[6] = me[6];
    te2[7] = me[7];
    te2[8] = me[8];
    te2[9] = me[9];
    te2[10] = me[10];
    te2[11] = me[11];
    te2[12] = me[12];
    te2[13] = me[13];
    te2[14] = me[14];
    te2[15] = me[15];
    return this;
  }
  copyPosition(m2) {
    const te2 = this.elements, me = m2.elements;
    te2[12] = me[12];
    te2[13] = me[13];
    te2[14] = me[14];
    return this;
  }
  setFromMatrix3(m2) {
    const me = m2.elements;
    this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }
  makeBasis(xAxis, yAxis, zAxis) {
    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
    return this;
  }
  extractRotation(m2) {
    const te2 = this.elements;
    const me = m2.elements;
    const scaleX = 1 / _v12.setFromMatrixColumn(m2, 0).length();
    const scaleY = 1 / _v12.setFromMatrixColumn(m2, 1).length();
    const scaleZ = 1 / _v12.setFromMatrixColumn(m2, 2).length();
    te2[0] = me[0] * scaleX;
    te2[1] = me[1] * scaleX;
    te2[2] = me[2] * scaleX;
    te2[3] = 0;
    te2[4] = me[4] * scaleY;
    te2[5] = me[5] * scaleY;
    te2[6] = me[6] * scaleY;
    te2[7] = 0;
    te2[8] = me[8] * scaleZ;
    te2[9] = me[9] * scaleZ;
    te2[10] = me[10] * scaleZ;
    te2[11] = 0;
    te2[12] = 0;
    te2[13] = 0;
    te2[14] = 0;
    te2[15] = 1;
    return this;
  }
  makeRotationFromEuler(euler2) {
    const te2 = this.elements;
    const x2 = euler2.x, y = euler2.y, z = euler2.z;
    const a = Math.cos(x2), b = Math.sin(x2);
    const c2 = Math.cos(y), d = Math.sin(y);
    const e = Math.cos(z), f2 = Math.sin(z);
    if (euler2.order === "XYZ") {
      const ae2 = a * e, af = a * f2, be = b * e, bf = b * f2;
      te2[0] = c2 * e;
      te2[4] = -c2 * f2;
      te2[8] = d;
      te2[1] = af + be * d;
      te2[5] = ae2 - bf * d;
      te2[9] = -b * c2;
      te2[2] = bf - ae2 * d;
      te2[6] = be + af * d;
      te2[10] = a * c2;
    } else if (euler2.order === "YXZ") {
      const ce = c2 * e, cf = c2 * f2, de = d * e, df = d * f2;
      te2[0] = ce + df * b;
      te2[4] = de * b - cf;
      te2[8] = a * d;
      te2[1] = a * f2;
      te2[5] = a * e;
      te2[9] = -b;
      te2[2] = cf * b - de;
      te2[6] = df + ce * b;
      te2[10] = a * c2;
    } else if (euler2.order === "ZXY") {
      const ce = c2 * e, cf = c2 * f2, de = d * e, df = d * f2;
      te2[0] = ce - df * b;
      te2[4] = -a * f2;
      te2[8] = de + cf * b;
      te2[1] = cf + de * b;
      te2[5] = a * e;
      te2[9] = df - ce * b;
      te2[2] = -a * d;
      te2[6] = b;
      te2[10] = a * c2;
    } else if (euler2.order === "ZYX") {
      const ae2 = a * e, af = a * f2, be = b * e, bf = b * f2;
      te2[0] = c2 * e;
      te2[4] = be * d - af;
      te2[8] = ae2 * d + bf;
      te2[1] = c2 * f2;
      te2[5] = bf * d + ae2;
      te2[9] = af * d - be;
      te2[2] = -d;
      te2[6] = b * c2;
      te2[10] = a * c2;
    } else if (euler2.order === "YZX") {
      const ac = a * c2, ad = a * d, bc = b * c2, bd = b * d;
      te2[0] = c2 * e;
      te2[4] = bd - ac * f2;
      te2[8] = bc * f2 + ad;
      te2[1] = f2;
      te2[5] = a * e;
      te2[9] = -b * e;
      te2[2] = -d * e;
      te2[6] = ad * f2 + bc;
      te2[10] = ac - bd * f2;
    } else if (euler2.order === "XZY") {
      const ac = a * c2, ad = a * d, bc = b * c2, bd = b * d;
      te2[0] = c2 * e;
      te2[4] = -f2;
      te2[8] = d * e;
      te2[1] = ac * f2 + bd;
      te2[5] = a * e;
      te2[9] = ad * f2 - bc;
      te2[2] = bc * f2 - ad;
      te2[6] = b * e;
      te2[10] = bd * f2 + ac;
    }
    te2[3] = 0;
    te2[7] = 0;
    te2[11] = 0;
    te2[12] = 0;
    te2[13] = 0;
    te2[14] = 0;
    te2[15] = 1;
    return this;
  }
  makeRotationFromQuaternion(q) {
    return this.compose(_zero, q, _one);
  }
  lookAt(eye, target, up2) {
    const te2 = this.elements;
    _z.subVectors(eye, target);
    if (_z.lengthSq() === 0) {
      _z.z = 1;
    }
    _z.normalize();
    _x.crossVectors(up2, _z);
    if (_x.lengthSq() === 0) {
      if (Math.abs(up2.z) === 1) {
        _z.x += 1e-4;
      } else {
        _z.z += 1e-4;
      }
      _z.normalize();
      _x.crossVectors(up2, _z);
    }
    _x.normalize();
    _y.crossVectors(_z, _x);
    te2[0] = _x.x;
    te2[4] = _y.x;
    te2[8] = _z.x;
    te2[1] = _x.y;
    te2[5] = _y.y;
    te2[9] = _z.y;
    te2[2] = _x.z;
    te2[6] = _y.z;
    te2[10] = _z.z;
    return this;
  }
  multiply(m2) {
    return this.multiplyMatrices(this, m2);
  }
  premultiply(m2) {
    return this.multiplyMatrices(m2, this);
  }
  multiplyMatrices(a, b) {
    const ae2 = a.elements;
    const be = b.elements;
    const te2 = this.elements;
    const a11 = ae2[0], a12 = ae2[4], a13 = ae2[8], a14 = ae2[12];
    const a21 = ae2[1], a22 = ae2[5], a23 = ae2[9], a24 = ae2[13];
    const a31 = ae2[2], a32 = ae2[6], a33 = ae2[10], a34 = ae2[14];
    const a41 = ae2[3], a42 = ae2[7], a43 = ae2[11], a44 = ae2[15];
    const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
    const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
    te2[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te2[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te2[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te2[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te2[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te2[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te2[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te2[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te2[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te2[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te2[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te2[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te2[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te2[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te2[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te2[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  multiplyScalar(s) {
    const te2 = this.elements;
    te2[0] *= s;
    te2[4] *= s;
    te2[8] *= s;
    te2[12] *= s;
    te2[1] *= s;
    te2[5] *= s;
    te2[9] *= s;
    te2[13] *= s;
    te2[2] *= s;
    te2[6] *= s;
    te2[10] *= s;
    te2[14] *= s;
    te2[3] *= s;
    te2[7] *= s;
    te2[11] *= s;
    te2[15] *= s;
    return this;
  }
  determinant() {
    const te2 = this.elements;
    const n11 = te2[0], n12 = te2[4], n13 = te2[8], n14 = te2[12];
    const n21 = te2[1], n22 = te2[5], n23 = te2[9], n24 = te2[13];
    const n31 = te2[2], n32 = te2[6], n33 = te2[10], n34 = te2[14];
    const n41 = te2[3], n42 = te2[7], n43 = te2[11], n44 = te2[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }
  transpose() {
    const te2 = this.elements;
    let tmp;
    tmp = te2[1];
    te2[1] = te2[4];
    te2[4] = tmp;
    tmp = te2[2];
    te2[2] = te2[8];
    te2[8] = tmp;
    tmp = te2[6];
    te2[6] = te2[9];
    te2[9] = tmp;
    tmp = te2[3];
    te2[3] = te2[12];
    te2[12] = tmp;
    tmp = te2[7];
    te2[7] = te2[13];
    te2[13] = tmp;
    tmp = te2[11];
    te2[11] = te2[14];
    te2[14] = tmp;
    return this;
  }
  setPosition(x2, y, z) {
    const te2 = this.elements;
    if (x2.isVector3) {
      te2[12] = x2.x;
      te2[13] = x2.y;
      te2[14] = x2.z;
    } else {
      te2[12] = x2;
      te2[13] = y;
      te2[14] = z;
    }
    return this;
  }
  invert() {
    const te2 = this.elements, n11 = te2[0], n21 = te2[1], n31 = te2[2], n41 = te2[3], n12 = te2[4], n22 = te2[5], n32 = te2[6], n42 = te2[7], n13 = te2[8], n23 = te2[9], n33 = te2[10], n43 = te2[11], n14 = te2[12], n24 = te2[13], n34 = te2[14], n44 = te2[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te2[0] = t11 * detInv;
    te2[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te2[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te2[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te2[4] = t12 * detInv;
    te2[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te2[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te2[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te2[8] = t13 * detInv;
    te2[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te2[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te2[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te2[12] = t14 * detInv;
    te2[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te2[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te2[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  scale(v4) {
    const te2 = this.elements;
    const x2 = v4.x, y = v4.y, z = v4.z;
    te2[0] *= x2;
    te2[4] *= y;
    te2[8] *= z;
    te2[1] *= x2;
    te2[5] *= y;
    te2[9] *= z;
    te2[2] *= x2;
    te2[6] *= y;
    te2[10] *= z;
    te2[3] *= x2;
    te2[7] *= y;
    te2[11] *= z;
    return this;
  }
  getMaxScaleOnAxis() {
    const te2 = this.elements;
    const scaleXSq = te2[0] * te2[0] + te2[1] * te2[1] + te2[2] * te2[2];
    const scaleYSq = te2[4] * te2[4] + te2[5] * te2[5] + te2[6] * te2[6];
    const scaleZSq = te2[8] * te2[8] + te2[9] * te2[9] + te2[10] * te2[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  makeTranslation(x2, y, z) {
    if (x2.isVector3) {
      this.set(1, 0, 0, x2.x, 0, 1, 0, x2.y, 0, 0, 1, x2.z, 0, 0, 0, 1);
    } else {
      this.set(1, 0, 0, x2, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
    }
    return this;
  }
  makeRotationX(theta) {
    const c2 = Math.cos(theta), s = Math.sin(theta);
    this.set(1, 0, 0, 0, 0, c2, -s, 0, 0, s, c2, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationY(theta) {
    const c2 = Math.cos(theta), s = Math.sin(theta);
    this.set(c2, 0, s, 0, 0, 1, 0, 0, -s, 0, c2, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationZ(theta) {
    const c2 = Math.cos(theta), s = Math.sin(theta);
    this.set(c2, -s, 0, 0, s, c2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationAxis(axis, angle) {
    const c2 = Math.cos(angle);
    const s = Math.sin(angle);
    const t2 = 1 - c2;
    const x2 = axis.x, y = axis.y, z = axis.z;
    const tx = t2 * x2, ty = t2 * y;
    this.set(tx * x2 + c2, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c2, ty * z - s * x2, 0, tx * z - s * y, ty * z + s * x2, t2 * z * z + c2, 0, 0, 0, 0, 1);
    return this;
  }
  makeScale(x2, y, z) {
    this.set(x2, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
    return this;
  }
  makeShear(xy, xz, yx, yz, zx, zy) {
    this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
    return this;
  }
  compose(position, quaternion, scale) {
    const te2 = this.elements;
    const x2 = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
    const x22 = x2 + x2, y2 = y + y, z2 = z + z;
    const xx = x2 * x22, xy = x2 * y2, xz = x2 * z2;
    const yy = y * y2, yz = y * z2, zz = z * z2;
    const wx = w * x22, wy = w * y2, wz = w * z2;
    const sx = scale.x, sy = scale.y, sz = scale.z;
    te2[0] = (1 - (yy + zz)) * sx;
    te2[1] = (xy + wz) * sx;
    te2[2] = (xz - wy) * sx;
    te2[3] = 0;
    te2[4] = (xy - wz) * sy;
    te2[5] = (1 - (xx + zz)) * sy;
    te2[6] = (yz + wx) * sy;
    te2[7] = 0;
    te2[8] = (xz + wy) * sz;
    te2[9] = (yz - wx) * sz;
    te2[10] = (1 - (xx + yy)) * sz;
    te2[11] = 0;
    te2[12] = position.x;
    te2[13] = position.y;
    te2[14] = position.z;
    te2[15] = 1;
    return this;
  }
  decompose(position, quaternion, scale) {
    const te2 = this.elements;
    let sx = _v12.set(te2[0], te2[1], te2[2]).length();
    const sy = _v12.set(te2[4], te2[5], te2[6]).length();
    const sz = _v12.set(te2[8], te2[9], te2[10]).length();
    const det = this.determinant();
    if (det < 0)
      sx = -sx;
    position.x = te2[12];
    position.y = te2[13];
    position.z = te2[14];
    _m1.copy(this);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1.elements[0] *= invSX;
    _m1.elements[1] *= invSX;
    _m1.elements[2] *= invSX;
    _m1.elements[4] *= invSY;
    _m1.elements[5] *= invSY;
    _m1.elements[6] *= invSY;
    _m1.elements[8] *= invSZ;
    _m1.elements[9] *= invSZ;
    _m1.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
  }
  makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
    const te2 = this.elements;
    const x2 = 2 * near / (right - left);
    const y = 2 * near / (top - bottom);
    const a = (right + left) / (right - left);
    const b = (top + bottom) / (top - bottom);
    let c2, d;
    if (coordinateSystem === WebGLCoordinateSystem) {
      c2 = -(far + near) / (far - near);
      d = -2 * far * near / (far - near);
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      c2 = -far / (far - near);
      d = -far * near / (far - near);
    } else {
      throw new Error("Matrix4.makePerspective(): Invalid coordinate system: " + coordinateSystem);
    }
    te2[0] = x2;
    te2[4] = 0;
    te2[8] = a;
    te2[12] = 0;
    te2[1] = 0;
    te2[5] = y;
    te2[9] = b;
    te2[13] = 0;
    te2[2] = 0;
    te2[6] = 0;
    te2[10] = c2;
    te2[14] = d;
    te2[3] = 0;
    te2[7] = 0;
    te2[11] = -1;
    te2[15] = 0;
    return this;
  }
  makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
    const te2 = this.elements;
    const w = 1 / (right - left);
    const h = 1 / (top - bottom);
    const p = 1 / (far - near);
    const x2 = (right + left) * w;
    const y = (top + bottom) * h;
    let z, zInv;
    if (coordinateSystem === WebGLCoordinateSystem) {
      z = (far + near) * p;
      zInv = -2 * p;
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      z = near * p;
      zInv = -1 * p;
    } else {
      throw new Error("../math.Matrix4.makeOrthographic(): Invalid coordinate system: " + coordinateSystem);
    }
    te2[0] = 2 * w;
    te2[4] = 0;
    te2[8] = 0;
    te2[12] = -x2;
    te2[1] = 0;
    te2[5] = 2 * h;
    te2[9] = 0;
    te2[13] = -y;
    te2[2] = 0;
    te2[6] = 0;
    te2[10] = zInv;
    te2[14] = -z;
    te2[3] = 0;
    te2[7] = 0;
    te2[11] = 0;
    te2[15] = 1;
    return this;
  }
  equals(matrix) {
    const te2 = this.elements;
    const me = matrix.elements;
    for (let i = 0; i < 16; i++) {
      if (te2[i] !== me[i])
        return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < 16; i++) {
      this.elements[i] = array[i + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te2 = this.elements;
    array[offset] = te2[0];
    array[offset + 1] = te2[1];
    array[offset + 2] = te2[2];
    array[offset + 3] = te2[3];
    array[offset + 4] = te2[4];
    array[offset + 5] = te2[5];
    array[offset + 6] = te2[6];
    array[offset + 7] = te2[7];
    array[offset + 8] = te2[8];
    array[offset + 9] = te2[9];
    array[offset + 10] = te2[10];
    array[offset + 11] = te2[11];
    array[offset + 12] = te2[12];
    array[offset + 13] = te2[13];
    array[offset + 14] = te2[14];
    array[offset + 15] = te2[15];
    return array;
  }
};
var _v12 = new Vector33();
var _m1 = new Matrix42();
var _zero = new Vector33(0, 0, 0);
var _one = new Vector33(1, 1, 1);
var _x = new Vector33();
var _y = new Vector33();
var _z = new Vector33();
var _matrix = new Matrix42();
var _quaternion = new Quaternion2();
var Euler2 = class {
  constructor(x2 = 0, y = 0, z = 0, order = Euler2.DEFAULT_ORDER) {
    this.isEuler = true;
    this._x = x2;
    this._y = y;
    this._z = z;
    this._order = order;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(value) {
    this._order = value;
    this._onChangeCallback();
  }
  set(x2, y, z, order = this._order) {
    this._x = x2;
    this._y = y;
    this._z = z;
    this._order = order;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new Euler2(this._x, this._y, this._z, this._order);
  }
  copy(euler2) {
    this._x = euler2._x;
    this._y = euler2._y;
    this._z = euler2._z;
    this._order = euler2._order;
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m2, order = this._order, update2 = true) {
    const te2 = m2.elements;
    const m11 = te2[0], m12 = te2[4], m13 = te2[8];
    const m21 = te2[1], m22 = te2[5], m23 = te2[9];
    const m31 = te2[2], m32 = te2[6], m33 = te2[10];
    switch (order) {
      case "XYZ":
        this._y = Math.asin(clamp(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
        break;
      case "YXZ":
        this._x = Math.asin(-clamp(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
        break;
      case "ZXY":
        this._x = Math.asin(clamp(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
        break;
      case "ZYX":
        this._y = Math.asin(-clamp(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
        break;
      case "YZX":
        this._z = Math.asin(clamp(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
        break;
      case "XZY":
        this._z = Math.asin(-clamp(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
        break;
      default:
        console.warn("../math.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
    }
    this._order = order;
    if (update2 === true)
      this._onChangeCallback();
    return this;
  }
  setFromQuaternion(q, order, update2) {
    _matrix.makeRotationFromQuaternion(q);
    return this.setFromRotationMatrix(_matrix, order, update2);
  }
  setFromVector3(v4, order = this._order) {
    return this.set(v4.x, v4.y, v4.z, order);
  }
  reorder(newOrder) {
    _quaternion.setFromEuler(this);
    return this.setFromQuaternion(_quaternion, newOrder);
  }
  equals(euler2) {
    return euler2._x === this._x && euler2._y === this._y && euler2._z === this._z && euler2._order === this._order;
  }
  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== void 0)
      this._order = array[3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback(euler2) {
  }
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._order;
  }
};
Euler2.DEFAULT_ORDER = "XYZ";
var Vector22 = class {
  constructor(x2 = 0, y = 0) {
    this.x = x2;
    this.y = y;
  }
  get width() {
    return this.x;
  }
  set width(value) {
    this.x = value;
  }
  get height() {
    return this.y;
  }
  set height(value) {
    this.y = value;
  }
  set(x2, y) {
    this.x = x2;
    this.y = y;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }
  setX(x2) {
    this.x = x2;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new Vector22(this.x, this.y);
  }
  copy(v4) {
    this.x = v4.x;
    this.y = v4.y;
    return this;
  }
  add(v4) {
    this.x += v4.x;
    this.y += v4.y;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  }
  addScaledVector(v4, s) {
    this.x += v4.x * s;
    this.y += v4.y * s;
    return this;
  }
  sub(v4) {
    this.x -= v4.x;
    this.y -= v4.y;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  }
  multiply(v4) {
    this.x *= v4.x;
    this.y *= v4.y;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  divide(v4) {
    this.x /= v4.x;
    this.y /= v4.y;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  applyMatrix3(m2) {
    const x2 = this.x, y = this.y;
    const e = m2.elements;
    this.x = e[0] * x2 + e[3] * y + e[6];
    this.y = e[1] * x2 + e[4] * y + e[7];
    return this;
  }
  min(v4) {
    this.x = Math.min(this.x, v4.x);
    this.y = Math.min(this.y, v4.y);
    return this;
  }
  max(v4) {
    this.x = Math.max(this.x, v4.x);
    this.y = Math.max(this.y, v4.y);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  dot(v4) {
    return this.x * v4.x + this.y * v4.y;
  }
  cross(v4) {
    return this.x * v4.y - this.y * v4.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }
  angleTo(v4) {
    const denominator = Math.sqrt(this.lengthSq() * v4.lengthSq());
    if (denominator === 0)
      return Math.PI / 2;
    const theta = this.dot(v4) / denominator;
    return Math.acos(clamp(theta, -1, 1));
  }
  distanceTo(v4) {
    return Math.sqrt(this.distanceToSquared(v4));
  }
  distanceToSquared(v4) {
    const dx = this.x - v4.x, dy = this.y - v4.y;
    return dx * dx + dy * dy;
  }
  manhattanDistanceTo(v4) {
    return Math.abs(this.x - v4.x) + Math.abs(this.y - v4.y);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v4, alpha) {
    this.x += (v4.x - this.x) * alpha;
    this.y += (v4.y - this.y) * alpha;
    return this;
  }
  lerpVectors(v1, v22, alpha) {
    this.x = v1.x + (v22.x - v1.x) * alpha;
    this.y = v1.y + (v22.y - v1.y) * alpha;
    return this;
  }
  equals(v4) {
    return v4.x === this.x && v4.y === this.y;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  }
  rotateAround(center, angle) {
    const c2 = Math.cos(angle), s = Math.sin(angle);
    const x2 = this.x - center.x;
    const y = this.y - center.y;
    this.x = x2 * c2 - y * s + center.x;
    this.y = x2 * s + y * c2 + center.y;
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
  }
};
Vector22.isVector2 = true;
var Vector42 = class {
  constructor(x2 = 0, y = 0, z = 0, w = 1) {
    Vector42.prototype.isVector4 = true;
    this.x = x2;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  get width() {
    return this.z;
  }
  set width(value) {
    this.z = value;
  }
  get height() {
    return this.w;
  }
  set height(value) {
    this.w = value;
  }
  set(x2, y, z, w) {
    this.x = x2;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  }
  setX(x2) {
    this.x = x2;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setZ(z) {
    this.z = z;
    return this;
  }
  setW(w) {
    this.w = w;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      case 3:
        this.w = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new Vector42(this.x, this.y, this.z, this.w);
  }
  copy(v4) {
    this.x = v4.x;
    this.y = v4.y;
    this.z = v4.z;
    this.w = v4.w;
    return this;
  }
  add(v4) {
    this.x += v4.x;
    this.y += v4.y;
    this.z += v4.z;
    this.w += v4.w;
    return this;
  }
  addScalar(scalar) {
    this.x += scalar;
    this.y += scalar;
    this.z += scalar;
    this.w += scalar;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;
    return this;
  }
  addScaledVector(v4, s) {
    this.x += v4.x * s;
    this.y += v4.y * s;
    this.z += v4.z * s;
    this.w += v4.w * s;
    return this;
  }
  sub(v4) {
    this.x -= v4.x;
    this.y -= v4.y;
    this.z -= v4.z;
    this.w -= v4.w;
    return this;
  }
  subScalar(scalar) {
    this.x -= scalar;
    this.y -= scalar;
    this.z -= scalar;
    this.w -= scalar;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;
    return this;
  }
  multiply(v4) {
    this.x *= v4.x;
    this.y *= v4.y;
    this.z *= v4.z;
    this.w *= v4.w;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }
  applyMatrix4(m2) {
    const x2 = this.x, y = this.y, z = this.z, w = this.w;
    const e = m2.elements;
    this.x = e[0] * x2 + e[4] * y + e[8] * z + e[12] * w;
    this.y = e[1] * x2 + e[5] * y + e[9] * z + e[13] * w;
    this.z = e[2] * x2 + e[6] * y + e[10] * z + e[14] * w;
    this.w = e[3] * x2 + e[7] * y + e[11] * z + e[15] * w;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  setAxisAngleFromQuaternion(q) {
    this.w = 2 * Math.acos(q.w);
    const s = Math.sqrt(1 - q.w * q.w);
    if (s < 1e-4) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q.x / s;
      this.y = q.y / s;
      this.z = q.z / s;
    }
    return this;
  }
  setAxisAngleFromRotationMatrix(m2) {
    let angle, x2, y, z;
    const epsilon = 0.01, epsilon2 = 0.1, te2 = m2.elements, m11 = te2[0], m12 = te2[4], m13 = te2[8], m21 = te2[1], m22 = te2[5], m23 = te2[9], m31 = te2[2], m32 = te2[6], m33 = te2[10];
    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle = Math.PI;
      const xx = (m11 + 1) / 2;
      const yy = (m22 + 1) / 2;
      const zz = (m33 + 1) / 2;
      const xy = (m12 + m21) / 4;
      const xz = (m13 + m31) / 4;
      const yz = (m23 + m32) / 4;
      if (xx > yy && xx > zz) {
        if (xx < epsilon) {
          x2 = 0;
          y = 0.707106781;
          z = 0.707106781;
        } else {
          x2 = Math.sqrt(xx);
          y = xy / x2;
          z = xz / x2;
        }
      } else if (yy > zz) {
        if (yy < epsilon) {
          x2 = 0.707106781;
          y = 0;
          z = 0.707106781;
        } else {
          y = Math.sqrt(yy);
          x2 = xy / y;
          z = yz / y;
        }
      } else {
        if (zz < epsilon) {
          x2 = 0.707106781;
          y = 0.707106781;
          z = 0;
        } else {
          z = Math.sqrt(zz);
          x2 = xz / z;
          y = yz / z;
        }
      }
      this.set(x2, y, z, angle);
      return this;
    }
    let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    if (Math.abs(s) < 1e-3)
      s = 1;
    this.x = (m32 - m23) / s;
    this.y = (m13 - m31) / s;
    this.z = (m21 - m12) / s;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  }
  min(v4) {
    this.x = Math.min(this.x, v4.x);
    this.y = Math.min(this.y, v4.y);
    this.z = Math.min(this.z, v4.z);
    this.w = Math.min(this.w, v4.w);
    return this;
  }
  max(v4) {
    this.x = Math.max(this.x, v4.x);
    this.y = Math.max(this.y, v4.y);
    this.z = Math.max(this.z, v4.z);
    this.w = Math.max(this.w, v4.w);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    this.w = Math.max(min.w, Math.min(max.w, this.w));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    this.w = Math.max(minVal, Math.min(maxVal, this.w));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    this.w = Math.trunc(this.w);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }
  dot(v4) {
    return this.x * v4.x + this.y * v4.y + this.z * v4.z + this.w * v4.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v4, alpha) {
    this.x += (v4.x - this.x) * alpha;
    this.y += (v4.y - this.y) * alpha;
    this.z += (v4.z - this.z) * alpha;
    this.w += (v4.w - this.w) * alpha;
    return this;
  }
  lerpVectors(v1, v22, alpha) {
    this.x = v1.x + (v22.x - v1.x) * alpha;
    this.y = v1.y + (v22.y - v1.y) * alpha;
    this.z = v1.z + (v22.z - v1.z) * alpha;
    this.w = v1.w + (v22.w - v1.w) * alpha;
    return this;
  }
  equals(v4) {
    return v4.x === this.x && v4.y === this.y && v4.z === this.z && v4.w === this.w;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;
    return array;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
    yield this.w;
  }
};
var Matrix32 = class {
  constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    Matrix32.prototype.isMatrix3 = true;
    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (n11 !== void 0) {
      this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
    }
  }
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te2 = this.elements;
    te2[0] = n11;
    te2[1] = n21;
    te2[2] = n31;
    te2[3] = n12;
    te2[4] = n22;
    te2[5] = n32;
    te2[6] = n13;
    te2[7] = n23;
    te2[8] = n33;
    return this;
  }
  identity() {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  }
  copy(m2) {
    const te2 = this.elements;
    const me = m2.elements;
    te2[0] = me[0];
    te2[1] = me[1];
    te2[2] = me[2];
    te2[3] = me[3];
    te2[4] = me[4];
    te2[5] = me[5];
    te2[6] = me[6];
    te2[7] = me[7];
    te2[8] = me[8];
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }
  setFromMatrix4(m2) {
    const me = m2.elements;
    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
    return this;
  }
  multiply(m2) {
    return this.multiplyMatrices(this, m2);
  }
  premultiply(m2) {
    return this.multiplyMatrices(m2, this);
  }
  multiplyMatrices(a, b) {
    const ae2 = a.elements;
    const be = b.elements;
    const te2 = this.elements;
    const a11 = ae2[0], a12 = ae2[3], a13 = ae2[6];
    const a21 = ae2[1], a22 = ae2[4], a23 = ae2[7];
    const a31 = ae2[2], a32 = ae2[5], a33 = ae2[8];
    const b11 = be[0], b12 = be[3], b13 = be[6];
    const b21 = be[1], b22 = be[4], b23 = be[7];
    const b31 = be[2], b32 = be[5], b33 = be[8];
    te2[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te2[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te2[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te2[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te2[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te2[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te2[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te2[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te2[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }
  multiplyScalar(s) {
    const te2 = this.elements;
    te2[0] *= s;
    te2[3] *= s;
    te2[6] *= s;
    te2[1] *= s;
    te2[4] *= s;
    te2[7] *= s;
    te2[2] *= s;
    te2[5] *= s;
    te2[8] *= s;
    return this;
  }
  determinant() {
    const te2 = this.elements;
    const a = te2[0], b = te2[1], c2 = te2[2], d = te2[3], e = te2[4], f2 = te2[5], g3 = te2[6], h = te2[7], i = te2[8];
    return a * e * i - a * f2 * h - b * d * i + b * f2 * g3 + c2 * d * h - c2 * e * g3;
  }
  invert() {
    const te2 = this.elements, n11 = te2[0], n21 = te2[1], n31 = te2[2], n12 = te2[3], n22 = te2[4], n32 = te2[5], n13 = te2[6], n23 = te2[7], n33 = te2[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te2[0] = t11 * detInv;
    te2[1] = (n31 * n23 - n33 * n21) * detInv;
    te2[2] = (n32 * n21 - n31 * n22) * detInv;
    te2[3] = t12 * detInv;
    te2[4] = (n33 * n11 - n31 * n13) * detInv;
    te2[5] = (n31 * n12 - n32 * n11) * detInv;
    te2[6] = t13 * detInv;
    te2[7] = (n21 * n13 - n23 * n11) * detInv;
    te2[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }
  transpose() {
    let tmp;
    const m2 = this.elements;
    tmp = m2[1];
    m2[1] = m2[3];
    m2[3] = tmp;
    tmp = m2[2];
    m2[2] = m2[6];
    m2[6] = tmp;
    tmp = m2[5];
    m2[5] = m2[7];
    m2[7] = tmp;
    return this;
  }
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }
  transposeIntoArray(r) {
    const m2 = this.elements;
    r[0] = m2[0];
    r[1] = m2[3];
    r[2] = m2[6];
    r[3] = m2[1];
    r[4] = m2[4];
    r[5] = m2[7];
    r[6] = m2[2];
    r[7] = m2[5];
    r[8] = m2[8];
    return this;
  }
  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c2 = Math.cos(rotation);
    const s = Math.sin(rotation);
    this.set(sx * c2, sx * s, -sx * (c2 * cx + s * cy) + cx + tx, -sy * s, sy * c2, -sy * (-s * cx + c2 * cy) + cy + ty, 0, 0, 1);
    return this;
  }
  scale(sx, sy) {
    this.premultiply(_m3.makeScale(sx, sy));
    return this;
  }
  rotate(theta) {
    this.premultiply(_m3.makeRotation(-theta));
    return this;
  }
  translate(tx, ty) {
    this.premultiply(_m3.makeTranslation(tx, ty));
    return this;
  }
  makeTranslation(x2, y) {
    if (x2.isVector2) {
      this.set(1, 0, x2.x, 0, 1, x2.y, 0, 0, 1);
    } else {
      this.set(1, 0, x2, 0, 1, y, 0, 0, 1);
    }
    return this;
  }
  makeRotation(theta) {
    const c2 = Math.cos(theta);
    const s = Math.sin(theta);
    this.set(c2, -s, 0, s, c2, 0, 0, 0, 1);
    return this;
  }
  makeScale(x2, y) {
    this.set(x2, 0, 0, 0, y, 0, 0, 0, 1);
    return this;
  }
  equals(matrix) {
    const te2 = this.elements;
    const me = matrix.elements;
    for (let i = 0; i < 9; i++) {
      if (te2[i] !== me[i])
        return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < 9; i++) {
      this.elements[i] = array[i + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te2 = this.elements;
    array[offset] = te2[0];
    array[offset + 1] = te2[1];
    array[offset + 2] = te2[2];
    array[offset + 3] = te2[3];
    array[offset + 4] = te2[4];
    array[offset + 5] = te2[5];
    array[offset + 6] = te2[6];
    array[offset + 7] = te2[7];
    array[offset + 8] = te2[8];
    return array;
  }
  clone() {
    return new Matrix32().fromArray(this.elements);
  }
};
var _m3 = new Matrix32();
var EmitterMode;
(function(EmitterMode2) {
  EmitterMode2[EmitterMode2["Random"] = 0] = "Random";
  EmitterMode2[EmitterMode2["Loop"] = 1] = "Loop";
  EmitterMode2[EmitterMode2["PingPong"] = 2] = "PingPong";
  EmitterMode2[EmitterMode2["Burst"] = 3] = "Burst";
})(EmitterMode || (EmitterMode = {}));
function getValueFromEmitterMode(mode, currentValue, spread, emissionState) {
  let u2;
  if (EmitterMode.Random === mode) {
    currentValue = Math.random();
  } else if (EmitterMode.Burst === mode && emissionState.isBursting) {
    currentValue = emissionState.burstParticleIndex / emissionState.burstParticleCount;
  }
  if (spread > 0) {
    u2 = Math.floor(currentValue / spread) * spread;
  } else {
    u2 = currentValue;
  }
  switch (mode) {
    case EmitterMode.Loop:
      u2 = u2 % 1;
      break;
    case EmitterMode.PingPong:
      u2 = Math.abs(u2 % 2 - 1);
      break;
  }
  return u2;
}
var Bezier = class {
  constructor(p1, p2, p3, p4) {
    this.p = [p1, p2, p3, p4];
  }
  genValue(t2) {
    const t22 = t2 * t2;
    const t3 = t2 * t2 * t2;
    const mt = 1 - t2;
    const mt2 = mt * mt;
    const mt3 = mt2 * mt;
    return this.p[0] * mt3 + this.p[1] * mt2 * t2 * 3 + this.p[2] * mt * t22 * 3 + this.p[3] * t3;
  }
  derivativeCoefficients(points) {
    const dpoints = [];
    for (let p = points, c2 = p.length - 1; c2 > 0; c2--) {
      const list = [];
      for (let j = 0; j < c2; j++) {
        const dpt = c2 * (p[j + 1] - p[j]);
        list.push(dpt);
      }
      dpoints.push(list);
      p = list;
    }
    return dpoints;
  }
  getSlope(t2) {
    const p = this.derivativeCoefficients(this.p)[0];
    const mt = 1 - t2;
    const a = mt * mt;
    const b = mt * t2 * 2;
    const c2 = t2 * t2;
    return a * p[0] + b * p[1] + c2 * p[2];
  }
  controlCurve(d0, d1) {
    this.p[1] = d0 / 3 + this.p[0];
    this.p[2] = this.p[3] - d1 / 3;
  }
  hull(t2) {
    let p = this.p;
    let _p2 = [], pt, idx = 0, i = 0, l = 0;
    const q = [];
    q[idx++] = p[0];
    q[idx++] = p[1];
    q[idx++] = p[2];
    q[idx++] = p[3];
    while (p.length > 1) {
      _p2 = [];
      for (i = 0, l = p.length - 1; i < l; i++) {
        pt = t2 * p[i] + (1 - t2) * p[i + 1];
        q[idx++] = pt;
        _p2.push(pt);
      }
      p = _p2;
    }
    return q;
  }
  split(t2) {
    const q = this.hull(t2);
    const result = {
      left: new Bezier(q[0], q[4], q[7], q[9]),
      right: new Bezier(q[9], q[8], q[6], q[3]),
      span: q
    };
    return result;
  }
  clone() {
    return new Bezier(this.p[0], this.p[1], this.p[2], this.p[3]);
  }
  toJSON() {
    return {
      p0: this.p[0],
      p1: this.p[1],
      p2: this.p[2],
      p3: this.p[3]
    };
  }
  static fromJSON(json) {
    return new Bezier(json.p0, json.p1, json.p2, json.p3);
  }
};
var ColorToJSON = (color2) => {
  return { r: color2.x, g: color2.y, b: color2.z, a: color2.w };
};
var JSONToColor = (json) => {
  return new Vector42(json.r, json.g, json.b, json.a);
};
var JSONToValue = (json, type) => {
  switch (type) {
    case "Vector3":
      return new Vector33(json.x, json.y, json.z);
    case "Vector4":
      return new Vector42(json.x, json.y, json.z, json.w);
    case "Color":
      return new Vector33(json.r, json.g, json.b);
    case "Number":
      return json;
    default:
      return json;
  }
};
var ValueToJSON = (value, type) => {
  switch (type) {
    case "Vector3":
      return { x: value.x, y: value.y, z: value.z };
    case "Vector4":
      return { x: value.x, y: value.y, z: value.z, w: value.w };
    case "Color":
      return { r: value.x, g: value.y, b: value.z };
    case "Number":
      return value;
    default:
      return value;
  }
};
var RandomColor = class {
  constructor(a, b) {
    this.a = a;
    this.b = b;
    this.type = "value";
  }
  startGen(memory) {
  }
  genColor(memory, color2) {
    const rand = Math.random();
    return color2.copy(this.a).lerp(this.b, rand);
  }
  toJSON() {
    return {
      type: "RandomColor",
      a: ColorToJSON(this.a),
      b: ColorToJSON(this.b)
    };
  }
  static fromJSON(json) {
    return new RandomColor(JSONToColor(json.a), JSONToColor(json.b));
  }
  clone() {
    return new RandomColor(this.a.clone(), this.b.clone());
  }
};
var ColorRange = class {
  constructor(a, b) {
    this.a = a;
    this.b = b;
    this.indexCount = -1;
    this.type = "value";
  }
  startGen(memory) {
    this.indexCount = memory.length;
    memory.push(Math.random());
  }
  genColor(memory, color2) {
    if (this.indexCount === -1) {
      this.startGen(memory);
    }
    return color2.copy(this.a).lerp(this.b, memory[this.indexCount]);
  }
  toJSON() {
    return {
      type: "ColorRange",
      a: ColorToJSON(this.a),
      b: ColorToJSON(this.b)
    };
  }
  static fromJSON(json) {
    return new ColorRange(JSONToColor(json.a), JSONToColor(json.b));
  }
  clone() {
    return new ColorRange(this.a.clone(), this.b.clone());
  }
};
var ContinuousLinearFunction = class {
  constructor(keys, subType) {
    this.subType = subType;
    this.type = "function";
    this.keys = keys;
  }
  findKey(t2) {
    let mid = 0;
    let left = 0, right = this.keys.length - 1;
    while (left + 1 < right) {
      mid = Math.floor((left + right) / 2);
      if (t2 < this.getStartX(mid))
        right = mid - 1;
      else if (t2 > this.getEndX(mid))
        left = mid + 1;
      else
        return mid;
    }
    for (let i = left; i <= right; i++) {
      if (t2 >= this.getStartX(i) && t2 <= this.getEndX(i))
        return i;
    }
    return -1;
  }
  getStartX(index) {
    return this.keys[index][1];
  }
  getEndX(index) {
    if (index + 1 < this.keys.length)
      return this.keys[index + 1][1];
    return 1;
  }
  genValue(value, t2) {
    const index = this.findKey(t2);
    if (this.subType === "Number") {
      if (index === -1) {
        return this.keys[0][0];
      } else if (index + 1 >= this.keys.length) {
        return this.keys[this.keys.length - 1][0];
      }
      return (this.keys[index + 1][0] - this.keys[index][0]) * ((t2 - this.getStartX(index)) / (this.getEndX(index) - this.getStartX(index))) + this.keys[index][0];
    } else {
      if (index === -1) {
        return value.copy(this.keys[0][0]);
      }
      if (index + 1 >= this.keys.length) {
        return value.copy(this.keys[this.keys.length - 1][0]);
      }
      return value.copy(this.keys[index][0]).lerp(this.keys[index + 1][0], (t2 - this.getStartX(index)) / (this.getEndX(index) - this.getStartX(index)));
    }
  }
  toJSON() {
    this.keys[0][0].constructor.name;
    return {
      type: "CLinearFunction",
      subType: this.subType,
      keys: this.keys.map(([color2, pos]) => ({ value: ValueToJSON(color2, this.subType), pos }))
    };
  }
  static fromJSON(json) {
    return new ContinuousLinearFunction(json.keys.map((pair) => [JSONToValue(pair.value, json.subType), pair.pos]), json.subType);
  }
  clone() {
    if (this.subType === "Number") {
      return new ContinuousLinearFunction(this.keys.map(([value, pos]) => [value, pos]), this.subType);
    } else {
      return new ContinuousLinearFunction(this.keys.map(([value, pos]) => [value.clone(), pos]), this.subType);
    }
  }
};
var tempVec3 = new Vector33();
var Gradient2 = class {
  constructor(color2 = [
    [new Vector33(0, 0, 0), 0],
    [new Vector33(1, 1, 1), 0]
  ], alpha = [
    [1, 0],
    [1, 1]
  ]) {
    this.type = "function";
    this.color = new ContinuousLinearFunction(color2, "Color");
    this.alpha = new ContinuousLinearFunction(alpha, "Number");
  }
  genColor(memory, color2, t2) {
    this.color.genValue(tempVec3, t2);
    return color2.set(tempVec3.x, tempVec3.y, tempVec3.z, this.alpha.genValue(1, t2));
  }
  toJSON() {
    return {
      type: "Gradient",
      color: this.color.toJSON(),
      alpha: this.alpha.toJSON()
    };
  }
  static fromJSON(json) {
    if (json.functions) {
      const keys = json.functions.map((func) => [ColorRange.fromJSON(func.function).a, func.start]);
      if (json.functions.length > 0) {
        keys.push([ColorRange.fromJSON(json.functions[json.functions.length - 1].function).b, 1]);
      }
      return new Gradient2(keys.map((key) => [new Vector33(key[0].x, key[0].y, key[0].z), key[1]]), keys.map((key) => [key[0].w, key[1]]));
    } else {
      const gradient = new Gradient2();
      gradient.alpha = ContinuousLinearFunction.fromJSON(json.alpha);
      gradient.color = ContinuousLinearFunction.fromJSON(json.color);
      return gradient;
    }
  }
  clone() {
    const gradient = new Gradient2();
    gradient.alpha = this.alpha.clone();
    gradient.color = this.color.clone();
    return gradient;
  }
  startGen(memory) {
  }
};
var tempColor = new Vector42();
var RandomColorBetweenGradient = class {
  constructor(gradient1, gradient2) {
    this.indexCount = 0;
    this.type = "function";
    this.gradient1 = gradient1;
    this.gradient2 = gradient2;
  }
  startGen(memory) {
    this.indexCount = memory.length;
    memory.push(Math.random());
  }
  genColor(memory, color2, t2) {
    this.gradient1.genColor(memory, color2, t2);
    this.gradient2.genColor(memory, tempColor, t2);
    if (memory && memory[this.indexCount] !== void 0) {
      color2.lerp(tempColor, memory[this.indexCount]);
    } else {
      color2.lerp(tempColor, Math.random());
    }
    return color2;
  }
  toJSON() {
    return {
      type: "RandomColorBetweenGradient",
      gradient1: this.gradient1.toJSON(),
      gradient2: this.gradient2.toJSON()
    };
  }
  static fromJSON(json) {
    return new RandomColorBetweenGradient(Gradient2.fromJSON(json.gradient1), Gradient2.fromJSON(json.gradient2));
  }
  clone() {
    return new RandomColorBetweenGradient(this.gradient1.clone(), this.gradient2.clone());
  }
};
var ConstantColor = class {
  constructor(color2) {
    this.color = color2;
    this.type = "value";
  }
  startGen(memory) {
  }
  genColor(memoryGenerator, color2) {
    return color2.copy(this.color);
  }
  toJSON() {
    return {
      type: "ConstantColor",
      color: ColorToJSON(this.color)
    };
  }
  static fromJSON(json) {
    return new ConstantColor(JSONToColor(json.color));
  }
  clone() {
    return new ConstantColor(this.color.clone());
  }
};
function ColorGeneratorFromJSON(json) {
  switch (json.type) {
    case "ConstantColor":
      return ConstantColor.fromJSON(json);
    case "ColorRange":
      return ColorRange.fromJSON(json);
    case "RandomColor":
      return RandomColor.fromJSON(json);
    case "Gradient":
      return Gradient2.fromJSON(json);
    case "RandomColorBetweenGradient":
      return RandomColorBetweenGradient.fromJSON(json);
    default:
      return new ConstantColor(new Vector42(1, 1, 1, 1));
  }
}
var ConstantValue = class {
  constructor(value) {
    this.value = value;
    this.type = "value";
  }
  startGen(memory) {
  }
  genValue(memory) {
    return this.value;
  }
  toJSON() {
    return {
      type: "ConstantValue",
      value: this.value
    };
  }
  static fromJSON(json) {
    return new ConstantValue(json.value);
  }
  clone() {
    return new ConstantValue(this.value);
  }
};
var IntervalValue = class {
  constructor(a, b) {
    this.a = a;
    this.b = b;
    this.indexCount = -1;
    this.type = "value";
  }
  startGen(memory) {
    this.indexCount = memory.length;
    memory.push(Math.random());
  }
  genValue(memory) {
    if (this.indexCount === -1) {
      this.startGen(memory);
    }
    return MathUtils2.lerp(this.a, this.b, memory[this.indexCount]);
  }
  toJSON() {
    return {
      type: "IntervalValue",
      a: this.a,
      b: this.b
    };
  }
  static fromJSON(json) {
    return new IntervalValue(json.a, json.b);
  }
  clone() {
    return new IntervalValue(this.a, this.b);
  }
};
var PiecewiseFunction = class {
  constructor() {
    this.functions = new Array();
  }
  findFunction(t2) {
    let mid = 0;
    let left = 0, right = this.functions.length - 1;
    while (left + 1 < right) {
      mid = Math.floor((left + right) / 2);
      if (t2 < this.getStartX(mid))
        right = mid - 1;
      else if (t2 > this.getEndX(mid))
        left = mid + 1;
      else
        return mid;
    }
    for (let i = left; i <= right; i++) {
      if (t2 >= this.functions[i][1] && t2 <= this.getEndX(i))
        return i;
    }
    return -1;
  }
  getStartX(index) {
    return this.functions[index][1];
  }
  setStartX(index, x2) {
    if (index > 0)
      this.functions[index][1] = x2;
  }
  getEndX(index) {
    if (index + 1 < this.functions.length)
      return this.functions[index + 1][1];
    return 1;
  }
  setEndX(index, x2) {
    if (index + 1 < this.functions.length)
      this.functions[index + 1][1] = x2;
  }
  insertFunction(t2, func) {
    const index = this.findFunction(t2);
    this.functions.splice(index + 1, 0, [func, t2]);
  }
  removeFunction(index) {
    return this.functions.splice(index, 1)[0][0];
  }
  getFunction(index) {
    return this.functions[index][0];
  }
  setFunction(index, func) {
    this.functions[index][0] = func;
  }
  get numOfFunctions() {
    return this.functions.length;
  }
};
var PiecewiseBezier = class extends PiecewiseFunction {
  constructor(curves = [[new Bezier(0, 1 / 3, 1 / 3 * 2, 1), 0]]) {
    super();
    this.type = "function";
    this.functions = curves;
  }
  genValue(memory, t2 = 0) {
    const index = this.findFunction(t2);
    if (index === -1) {
      return 0;
    }
    return this.functions[index][0].genValue((t2 - this.getStartX(index)) / (this.getEndX(index) - this.getStartX(index)));
  }
  toSVG(length, segments) {
    if (segments < 1)
      return "";
    let result = ["M", 0, this.functions[0][0].p[0]].join(" ");
    for (let i = 1 / segments; i <= 1; i += 1 / segments) {
      result = [result, "L", i * length, this.genValue(void 0, i)].join(" ");
    }
    return result;
  }
  toJSON() {
    return {
      type: "PiecewiseBezier",
      functions: this.functions.map(([bezier, start]) => ({ function: bezier.toJSON(), start }))
    };
  }
  static fromJSON(json) {
    return new PiecewiseBezier(json.functions.map((piecewiseFunction) => [
      Bezier.fromJSON(piecewiseFunction.function),
      piecewiseFunction.start
    ]));
  }
  clone() {
    return new PiecewiseBezier(this.functions.map(([bezier, start]) => [bezier.clone(), start]));
  }
  startGen(memory) {
  }
};
function ValueGeneratorFromJSON(json) {
  switch (json.type) {
    case "ConstantValue":
      return ConstantValue.fromJSON(json);
    case "IntervalValue":
      return IntervalValue.fromJSON(json);
    case "PiecewiseBezier":
      return PiecewiseBezier.fromJSON(json);
    default:
      return new ConstantValue(0);
  }
}
var RandomQuatGenerator = class {
  constructor() {
    this.indexCount = 0;
    this.type = "rotation";
  }
  startGen(memory) {
    this.indexCount = memory.length;
    memory.push(new Quaternion2());
    let x2, y, z, u2, v4, w;
    do {
      x2 = Math.random() * 2 - 1;
      y = Math.random() * 2 - 1;
      z = x2 * x2 + y * y;
    } while (z > 1);
    do {
      u2 = Math.random() * 2 - 1;
      v4 = Math.random() * 2 - 1;
      w = u2 * u2 + v4 * v4;
    } while (w > 1);
    const s = Math.sqrt((1 - z) / w);
    memory[this.indexCount].set(x2, y, s * u2, s * v4);
  }
  genValue(memory, quat, delta, t2) {
    if (this.indexCount === -1) {
      this.startGen(memory);
    }
    quat.copy(memory[this.indexCount]);
    return quat;
  }
  toJSON() {
    return {
      type: "RandomQuat"
    };
  }
  static fromJSON(json) {
    return new RandomQuatGenerator();
  }
  clone() {
    return new RandomQuatGenerator();
  }
};
var AxisAngleGenerator = class {
  constructor(axis, angle) {
    this.axis = axis;
    this.angle = angle;
    this.type = "rotation";
  }
  startGen(memory) {
    this.angle.startGen(memory);
  }
  genValue(memory, quat, delta, t2) {
    return quat.setFromAxisAngle(this.axis, this.angle.genValue(memory, t2) * delta);
  }
  toJSON() {
    return {
      type: "AxisAngle",
      axis: { x: this.axis.x, y: this.axis.y, z: this.axis.z },
      angle: this.angle.toJSON()
    };
  }
  static fromJSON(json) {
    return new AxisAngleGenerator(new Vector33(json.axis.x, json.axis.y, json.axis.z), ValueGeneratorFromJSON(json.angle));
  }
  clone() {
    return new AxisAngleGenerator(this.axis.clone(), this.angle.clone());
  }
};
var EulerGenerator = class {
  constructor(angleX, angleY, angleZ, eulerOrder) {
    this.angleX = angleX;
    this.angleY = angleY;
    this.angleZ = angleZ;
    this.type = "rotation";
    this.eular = new Euler2(0, 0, 0, eulerOrder);
  }
  startGen(memory) {
    this.angleX.startGen(memory);
    this.angleY.startGen(memory);
    this.angleZ.startGen(memory);
  }
  genValue(memory, quat, delta, t2) {
    this.eular.set(this.angleX.genValue(memory, t2) * delta, this.angleY.genValue(memory, t2) * delta, this.angleZ.genValue(memory, t2) * delta);
    return quat.setFromEuler(this.eular);
  }
  toJSON() {
    return {
      type: "Euler",
      angleX: this.angleX.toJSON(),
      angleY: this.angleY.toJSON(),
      angleZ: this.angleZ.toJSON(),
      eulerOrder: this.eular.order
    };
  }
  static fromJSON(json) {
    return new EulerGenerator(ValueGeneratorFromJSON(json.angleX), ValueGeneratorFromJSON(json.angleY), ValueGeneratorFromJSON(json.angleZ), json.eulerOrder);
  }
  clone() {
    return new EulerGenerator(this.angleX, this.angleY, this.angleZ, this.eular.order);
  }
};
function RotationGeneratorFromJSON(json) {
  switch (json.type) {
    case "AxisAngle":
      return AxisAngleGenerator.fromJSON(json);
    case "Euler":
      return EulerGenerator.fromJSON(json);
    case "RandomQuat":
      return RandomQuatGenerator.fromJSON(json);
    default:
      return new RandomQuatGenerator();
  }
}
var Vector3Function = class {
  constructor(x2, y, z) {
    this.x = x2;
    this.y = y;
    this.z = z;
    this.type = "vec3function";
  }
  startGen(memory) {
    this.x.startGen(memory);
    this.y.startGen(memory);
    this.z.startGen(memory);
  }
  genValue(memory, vec2, t2) {
    return vec2.set(this.x.genValue(memory, t2), this.y.genValue(memory, t2), this.z.genValue(memory, t2));
  }
  toJSON() {
    return {
      type: "Vector3Function",
      x: this.x.toJSON(),
      y: this.y.toJSON(),
      z: this.z.toJSON()
    };
  }
  static fromJSON(json) {
    return new Vector3Function(ValueGeneratorFromJSON(json.x), ValueGeneratorFromJSON(json.y), ValueGeneratorFromJSON(json.z));
  }
  clone() {
    return new Vector3Function(this.x, this.y, this.z);
  }
};
function Vector3GeneratorFromJSON(json) {
  switch (json.type) {
    case "Vector3Function":
      return Vector3Function.fromJSON(json);
    default:
      return new Vector3Function(new ConstantValue(0), new ConstantValue(0), new ConstantValue(0));
  }
}
function GeneratorFromJSON(json) {
  switch (json.type) {
    case "ConstantValue":
    case "IntervalValue":
    case "PiecewiseBezier":
      return ValueGeneratorFromJSON(json);
    case "AxisAngle":
    case "RandomQuat":
    case "Euler":
      return RotationGeneratorFromJSON(json);
    case "Vector3Function":
      return Vector3GeneratorFromJSON(json);
    default:
      return new ConstantValue(0);
  }
}
var ConeEmitter = class {
  constructor(parameters = {}) {
    var _a2, _b, _c, _d, _e, _f, _g;
    this.type = "cone";
    this.currentValue = 0;
    this.radius = (_a2 = parameters.radius) !== null && _a2 !== void 0 ? _a2 : 10;
    this.arc = (_b = parameters.arc) !== null && _b !== void 0 ? _b : 2 * Math.PI;
    this.thickness = (_c = parameters.thickness) !== null && _c !== void 0 ? _c : 1;
    this.angle = (_d = parameters.angle) !== null && _d !== void 0 ? _d : Math.PI / 6;
    this.mode = (_e = parameters.mode) !== null && _e !== void 0 ? _e : EmitterMode.Random;
    this.spread = (_f = parameters.spread) !== null && _f !== void 0 ? _f : 0;
    this.speed = (_g = parameters.speed) !== null && _g !== void 0 ? _g : new ConstantValue(1);
    this.memory = [];
  }
  update(system, delta) {
    if (EmitterMode.Random != this.mode) {
      this.currentValue += this.speed.genValue(this.memory, system.emissionState.time / system.duration) * delta;
    }
  }
  initialize(p, emissionState) {
    const u2 = getValueFromEmitterMode(this.mode, this.currentValue, this.spread, emissionState);
    const rand = MathUtils2.lerp(1 - this.thickness, 1, Math.random());
    const theta = u2 * this.arc;
    const r = Math.sqrt(rand);
    const sinTheta = Math.sin(theta);
    const cosTheta = Math.cos(theta);
    p.position.x = r * cosTheta;
    p.position.y = r * sinTheta;
    p.position.z = 0;
    const angle = this.angle * r;
    p.velocity.set(0, 0, Math.cos(angle)).addScaledVector(p.position, Math.sin(angle)).multiplyScalar(p.startSpeed);
    p.position.multiplyScalar(this.radius);
  }
  toJSON() {
    return {
      type: "cone",
      radius: this.radius,
      arc: this.arc,
      thickness: this.thickness,
      angle: this.angle,
      mode: this.mode,
      spread: this.spread,
      speed: this.speed.toJSON()
    };
  }
  static fromJSON(json) {
    return new ConeEmitter({
      radius: json.radius,
      arc: json.arc,
      thickness: json.thickness,
      angle: json.angle,
      mode: json.mode,
      speed: json.speed ? ValueGeneratorFromJSON(json.speed) : void 0,
      spread: json.spread
    });
  }
  clone() {
    return new ConeEmitter({
      radius: this.radius,
      arc: this.arc,
      thickness: this.thickness,
      angle: this.angle,
      mode: this.mode,
      speed: this.speed.clone(),
      spread: this.spread
    });
  }
};
var CircleEmitter = class {
  constructor(parameters = {}) {
    var _a2, _b, _c, _d, _e, _f;
    this.type = "circle";
    this.currentValue = 0;
    this.radius = (_a2 = parameters.radius) !== null && _a2 !== void 0 ? _a2 : 10;
    this.arc = (_b = parameters.arc) !== null && _b !== void 0 ? _b : 2 * Math.PI;
    this.thickness = (_c = parameters.thickness) !== null && _c !== void 0 ? _c : 1;
    this.mode = (_d = parameters.mode) !== null && _d !== void 0 ? _d : EmitterMode.Random;
    this.spread = (_e = parameters.spread) !== null && _e !== void 0 ? _e : 0;
    this.speed = (_f = parameters.speed) !== null && _f !== void 0 ? _f : new ConstantValue(1);
    this.memory = [];
  }
  update(system, delta) {
    this.currentValue += this.speed.genValue(this.memory, system.emissionState.time / system.duration) * delta;
  }
  initialize(p, emissionState) {
    const u2 = getValueFromEmitterMode(this.mode, this.currentValue, this.spread, emissionState);
    const r = MathUtils2.lerp(1 - this.thickness, 1, Math.random());
    const theta = u2 * this.arc;
    p.position.x = Math.cos(theta);
    p.position.y = Math.sin(theta);
    p.position.z = 0;
    p.velocity.copy(p.position).multiplyScalar(p.startSpeed);
    p.position.multiplyScalar(this.radius * r);
  }
  toJSON() {
    return {
      type: "circle",
      radius: this.radius,
      arc: this.arc,
      thickness: this.thickness,
      mode: this.mode,
      spread: this.spread,
      speed: this.speed.toJSON()
    };
  }
  static fromJSON(json) {
    return new CircleEmitter({
      radius: json.radius,
      arc: json.arc,
      thickness: json.thickness,
      mode: json.mode,
      speed: json.speed ? ValueGeneratorFromJSON(json.speed) : void 0,
      spread: json.spread
    });
  }
  clone() {
    return new CircleEmitter({
      radius: this.radius,
      arc: this.arc,
      thickness: this.thickness,
      mode: this.mode,
      speed: this.speed.clone(),
      spread: this.spread
    });
  }
};
var DonutEmitter = class {
  constructor(parameters = {}) {
    var _a2, _b, _c, _d, _e, _f, _g;
    this.type = "donut";
    this.currentValue = 0;
    this.radius = (_a2 = parameters.radius) !== null && _a2 !== void 0 ? _a2 : 10;
    this.arc = (_b = parameters.arc) !== null && _b !== void 0 ? _b : 2 * Math.PI;
    this.thickness = (_c = parameters.thickness) !== null && _c !== void 0 ? _c : 1;
    this.donutRadius = (_d = parameters.donutRadius) !== null && _d !== void 0 ? _d : this.radius * 0.2;
    this.mode = (_e = parameters.mode) !== null && _e !== void 0 ? _e : EmitterMode.Random;
    this.spread = (_f = parameters.spread) !== null && _f !== void 0 ? _f : 0;
    this.speed = (_g = parameters.speed) !== null && _g !== void 0 ? _g : new ConstantValue(1);
    this.memory = [];
  }
  update(system, delta) {
    if (EmitterMode.Random != this.mode) {
      this.currentValue += this.speed.genValue(this.memory, system.emissionState.time / system.duration) * delta;
    }
  }
  initialize(p, emissionState) {
    const u2 = getValueFromEmitterMode(this.mode, this.currentValue, this.spread, emissionState);
    const v4 = Math.random();
    const rand = MathUtils2.lerp(1 - this.thickness, 1, Math.random());
    const theta = u2 * this.arc;
    const phi = v4 * Math.PI * 2;
    const sinTheta = Math.sin(theta);
    const cosTheta = Math.cos(theta);
    p.position.x = this.radius * cosTheta;
    p.position.y = this.radius * sinTheta;
    p.position.z = 0;
    p.velocity.z = this.donutRadius * rand * Math.sin(phi);
    p.velocity.x = this.donutRadius * rand * Math.cos(phi) * cosTheta;
    p.velocity.y = this.donutRadius * rand * Math.cos(phi) * sinTheta;
    p.position.add(p.velocity);
    p.velocity.normalize().multiplyScalar(p.startSpeed);
  }
  toJSON() {
    return {
      type: "donut",
      radius: this.radius,
      arc: this.arc,
      thickness: this.thickness,
      donutRadius: this.donutRadius,
      mode: this.mode,
      spread: this.spread,
      speed: this.speed.toJSON()
    };
  }
  static fromJSON(json) {
    return new DonutEmitter({
      radius: json.radius,
      arc: json.arc,
      thickness: json.thickness,
      donutRadius: json.donutRadius,
      mode: json.mode,
      speed: json.speed ? ValueGeneratorFromJSON(json.speed) : void 0,
      spread: json.spread
    });
  }
  clone() {
    return new DonutEmitter({
      radius: this.radius,
      arc: this.arc,
      thickness: this.thickness,
      donutRadius: this.donutRadius,
      mode: this.mode,
      speed: this.speed.clone(),
      spread: this.spread
    });
  }
};
var PointEmitter = class {
  constructor() {
    this.type = "point";
  }
  update(system, delta) {
  }
  initialize(p) {
    const u2 = Math.random();
    const v4 = Math.random();
    const theta = u2 * Math.PI * 2;
    const phi = Math.acos(2 * v4 - 1);
    const r = Math.cbrt(Math.random());
    const sinTheta = Math.sin(theta);
    const cosTheta = Math.cos(theta);
    const sinPhi = Math.sin(phi);
    const cosPhi = Math.cos(phi);
    p.velocity.x = r * sinPhi * cosTheta;
    p.velocity.y = r * sinPhi * sinTheta;
    p.velocity.z = r * cosPhi;
    p.velocity.multiplyScalar(p.startSpeed);
    p.position.setScalar(0);
  }
  toJSON() {
    return {
      type: "point"
    };
  }
  static fromJSON(json) {
    return new PointEmitter();
  }
  clone() {
    return new PointEmitter();
  }
};
var SphereEmitter = class {
  constructor(parameters = {}) {
    var _a2, _b, _c, _d, _e, _f;
    this.type = "sphere";
    this.currentValue = 0;
    this.radius = (_a2 = parameters.radius) !== null && _a2 !== void 0 ? _a2 : 10;
    this.arc = (_b = parameters.arc) !== null && _b !== void 0 ? _b : 2 * Math.PI;
    this.thickness = (_c = parameters.thickness) !== null && _c !== void 0 ? _c : 1;
    this.mode = (_d = parameters.mode) !== null && _d !== void 0 ? _d : EmitterMode.Random;
    this.spread = (_e = parameters.spread) !== null && _e !== void 0 ? _e : 0;
    this.speed = (_f = parameters.speed) !== null && _f !== void 0 ? _f : new ConstantValue(1);
    this.memory = [];
  }
  update(system, delta) {
    if (EmitterMode.Random != this.mode) {
      this.currentValue += this.speed.genValue(this.memory, system.emissionState.time / system.duration) * delta;
    }
  }
  initialize(p, emissionState) {
    const u2 = getValueFromEmitterMode(this.mode, this.currentValue, this.spread, emissionState);
    const v4 = Math.random();
    const rand = MathUtils2.lerp(1 - this.thickness, 1, Math.random());
    const theta = u2 * this.arc;
    const phi = Math.acos(2 * v4 - 1);
    const sinTheta = Math.sin(theta);
    const cosTheta = Math.cos(theta);
    const sinPhi = Math.sin(phi);
    const cosPhi = Math.cos(phi);
    p.position.x = sinPhi * cosTheta;
    p.position.y = sinPhi * sinTheta;
    p.position.z = cosPhi;
    p.velocity.copy(p.position).multiplyScalar(p.startSpeed);
    p.position.multiplyScalar(this.radius * rand);
  }
  toJSON() {
    return {
      type: "sphere",
      radius: this.radius,
      arc: this.arc,
      thickness: this.thickness,
      mode: this.mode,
      spread: this.spread,
      speed: this.speed.toJSON()
    };
  }
  static fromJSON(json) {
    return new SphereEmitter({
      radius: json.radius,
      arc: json.arc,
      thickness: json.thickness,
      mode: json.mode,
      speed: json.speed ? ValueGeneratorFromJSON(json.speed) : void 0,
      spread: json.spread
    });
  }
  clone() {
    return new SphereEmitter({
      radius: this.radius,
      arc: this.arc,
      thickness: this.thickness,
      mode: this.mode,
      speed: this.speed.clone(),
      spread: this.spread
    });
  }
};
var HemisphereEmitter = class {
  constructor(parameters = {}) {
    var _a2, _b, _c, _d, _e, _f;
    this.type = "sphere";
    this.currentValue = 0;
    this.radius = (_a2 = parameters.radius) !== null && _a2 !== void 0 ? _a2 : 10;
    this.arc = (_b = parameters.arc) !== null && _b !== void 0 ? _b : 2 * Math.PI;
    this.thickness = (_c = parameters.thickness) !== null && _c !== void 0 ? _c : 1;
    this.mode = (_d = parameters.mode) !== null && _d !== void 0 ? _d : EmitterMode.Random;
    this.spread = (_e = parameters.spread) !== null && _e !== void 0 ? _e : 0;
    this.speed = (_f = parameters.speed) !== null && _f !== void 0 ? _f : new ConstantValue(1);
    this.memory = [];
  }
  update(system, delta) {
    if (EmitterMode.Random != this.mode) {
      this.currentValue += this.speed.genValue(this.memory, system.emissionState.time / system.duration) * delta;
    }
  }
  initialize(p, emissionState) {
    const u2 = getValueFromEmitterMode(this.mode, this.currentValue, this.spread, emissionState);
    const v4 = Math.random();
    const rand = MathUtils2.lerp(1 - this.thickness, 1, Math.random());
    const theta = u2 * this.arc;
    const phi = Math.acos(v4);
    const sinTheta = Math.sin(theta);
    const cosTheta = Math.cos(theta);
    const sinPhi = Math.sin(phi);
    const cosPhi = Math.cos(phi);
    p.position.x = sinPhi * cosTheta;
    p.position.y = sinPhi * sinTheta;
    p.position.z = cosPhi;
    p.velocity.copy(p.position).multiplyScalar(p.startSpeed);
    p.position.multiplyScalar(this.radius * rand);
  }
  toJSON() {
    return {
      type: "hemisphere",
      radius: this.radius,
      arc: this.arc,
      thickness: this.thickness,
      mode: this.mode,
      spread: this.spread,
      speed: this.speed.toJSON()
    };
  }
  static fromJSON(json) {
    return new HemisphereEmitter({
      radius: json.radius,
      arc: json.arc,
      thickness: json.thickness,
      mode: json.mode,
      speed: json.speed ? ValueGeneratorFromJSON(json.speed) : void 0,
      spread: json.spread
    });
  }
  clone() {
    return new HemisphereEmitter({
      radius: this.radius,
      arc: this.arc,
      thickness: this.thickness,
      mode: this.mode,
      speed: this.speed.clone(),
      spread: this.spread
    });
  }
};
var GridEmitter = class {
  constructor(parameters = {}) {
    var _a2, _b, _c, _d;
    this.type = "grid";
    this.width = (_a2 = parameters.width) !== null && _a2 !== void 0 ? _a2 : 1;
    this.height = (_b = parameters.height) !== null && _b !== void 0 ? _b : 1;
    this.column = (_c = parameters.column) !== null && _c !== void 0 ? _c : 10;
    this.row = (_d = parameters.row) !== null && _d !== void 0 ? _d : 10;
  }
  initialize(p) {
    const r = Math.floor(Math.random() * this.row);
    const c2 = Math.floor(Math.random() * this.column);
    p.position.x = c2 * this.width / this.column - this.width / 2;
    p.position.y = r * this.height / this.row - this.height / 2;
    p.position.z = 0;
    p.velocity.set(0, 0, p.startSpeed);
  }
  toJSON() {
    return {
      type: "grid",
      width: this.width,
      height: this.height,
      column: this.column,
      row: this.row
    };
  }
  static fromJSON(json) {
    return new GridEmitter(json);
  }
  clone() {
    return new GridEmitter({
      width: this.width,
      height: this.height,
      column: this.column,
      row: this.row
    });
  }
  update(system, delta) {
  }
};
var EmitterShapes = {
  circle: {
    type: "circle",
    params: [
      ["radius", ["number"]],
      ["arc", ["radian"]],
      ["thickness", ["number"]],
      ["mode", ["emitterMode"]],
      ["spread", ["number"]],
      ["speed", ["valueFunc"]]
    ],
    constructor: CircleEmitter,
    loadJSON: CircleEmitter.fromJSON
  },
  cone: {
    type: "cone",
    params: [
      ["radius", ["number"]],
      ["arc", ["radian"]],
      ["thickness", ["number"]],
      ["angle", ["radian"]],
      ["mode", ["emitterMode"]],
      ["spread", ["number"]],
      ["speed", ["valueFunc"]]
    ],
    constructor: ConeEmitter,
    loadJSON: ConeEmitter.fromJSON
  },
  donut: {
    type: "donut",
    params: [
      ["radius", ["number"]],
      ["arc", ["radian"]],
      ["thickness", ["number"]],
      ["donutRadius", ["number"]],
      ["mode", ["emitterMode"]],
      ["spread", ["number"]],
      ["speed", ["valueFunc"]]
    ],
    constructor: DonutEmitter,
    loadJSON: DonutEmitter.fromJSON
  },
  point: { type: "point", params: [], constructor: PointEmitter, loadJSON: PointEmitter.fromJSON },
  sphere: {
    type: "sphere",
    params: [
      ["radius", ["number"]],
      ["arc", ["radian"]],
      ["thickness", ["number"]],
      ["angle", ["radian"]],
      ["mode", ["emitterMode"]],
      ["spread", ["number"]],
      ["speed", ["valueFunc"]]
    ],
    constructor: SphereEmitter,
    loadJSON: SphereEmitter.fromJSON
  },
  hemisphere: {
    type: "hemisphere",
    params: [
      ["radius", ["number"]],
      ["arc", ["radian"]],
      ["thickness", ["number"]],
      ["angle", ["radian"]],
      ["mode", ["emitterMode"]],
      ["spread", ["number"]],
      ["speed", ["valueFunc"]]
    ],
    constructor: HemisphereEmitter,
    loadJSON: HemisphereEmitter.fromJSON
  },
  grid: {
    type: "grid",
    params: [
      ["width", ["number"]],
      ["height", ["number"]],
      ["rows", ["number"]],
      ["column", ["number"]]
    ],
    constructor: GridEmitter,
    loadJSON: GridEmitter.fromJSON
  }
};
function EmitterFromJSON(json, meta) {
  return EmitterShapes[json.type].loadJSON(json, meta);
}
var ColorOverLife = class {
  constructor(color2) {
    this.color = color2;
    this.type = "ColorOverLife";
  }
  initialize(particle) {
    this.color.startGen(particle.memory);
  }
  update(particle, delta) {
    this.color.genColor(particle.memory, particle.color, particle.age / particle.life);
    particle.color.x *= particle.startColor.x;
    particle.color.y *= particle.startColor.y;
    particle.color.z *= particle.startColor.z;
    particle.color.w *= particle.startColor.w;
  }
  frameUpdate(delta) {
  }
  toJSON() {
    return {
      type: this.type,
      color: this.color.toJSON()
    };
  }
  static fromJSON(json) {
    return new ColorOverLife(ColorGeneratorFromJSON(json.color));
  }
  clone() {
    return new ColorOverLife(this.color.clone());
  }
  reset() {
  }
};
var RotationOverLife = class {
  constructor(angularVelocity) {
    this.angularVelocity = angularVelocity;
    this.type = "RotationOverLife";
  }
  initialize(particle) {
    if (typeof particle.rotation === "number") {
      this.angularVelocity.startGen(particle.memory);
    }
  }
  update(particle, delta) {
    if (typeof particle.rotation === "number") {
      particle.rotation += delta * this.angularVelocity.genValue(particle.memory, particle.age / particle.life);
    }
  }
  toJSON() {
    return {
      type: this.type,
      angularVelocity: this.angularVelocity.toJSON()
    };
  }
  static fromJSON(json) {
    return new RotationOverLife(ValueGeneratorFromJSON(json.angularVelocity));
  }
  frameUpdate(delta) {
  }
  clone() {
    return new RotationOverLife(this.angularVelocity.clone());
  }
  reset() {
  }
};
var Rotation3DOverLife = class {
  constructor(angularVelocity) {
    this.angularVelocity = angularVelocity;
    this.type = "Rotation3DOverLife";
    this.tempQuat = new Quaternion2();
    this.tempQuat2 = new Quaternion2();
  }
  initialize(particle) {
    if (particle.rotation instanceof Quaternion2) {
      particle.angularVelocity = new Quaternion2();
      this.angularVelocity.startGen(particle.memory);
    }
  }
  update(particle, delta) {
    if (particle.rotation instanceof Quaternion2) {
      this.angularVelocity.genValue(particle.memory, this.tempQuat, delta, particle.age / particle.life);
      particle.rotation.multiply(this.tempQuat);
    }
  }
  toJSON() {
    return {
      type: this.type,
      angularVelocity: this.angularVelocity.toJSON()
    };
  }
  static fromJSON(json) {
    return new Rotation3DOverLife(RotationGeneratorFromJSON(json.angularVelocity));
  }
  frameUpdate(delta) {
  }
  clone() {
    return new Rotation3DOverLife(this.angularVelocity.clone());
  }
  reset() {
  }
};
var ForceOverLife = class {
  initialize(particle, particleSystem) {
    this.ps = particleSystem;
    this.x.startGen(particle.memory);
    this.y.startGen(particle.memory);
    this.z.startGen(particle.memory);
  }
  constructor(x2, y, z) {
    this.x = x2;
    this.y = y;
    this.z = z;
    this.type = "ForceOverLife";
    this._temp = new Vector33();
    this._tempScale = new Vector33();
    this._tempQ = new Quaternion2();
  }
  update(particle, delta) {
    this._temp.set(this.x.genValue(particle.memory, particle.age / particle.life), this.y.genValue(particle.memory, particle.age / particle.life), this.z.genValue(particle.memory, particle.age / particle.life));
    if (this.ps.worldSpace) {
      particle.velocity.addScaledVector(this._temp, delta);
    } else {
      this._temp.multiply(this._tempScale).applyQuaternion(this._tempQ);
      particle.velocity.addScaledVector(this._temp, delta);
    }
  }
  toJSON() {
    return {
      type: this.type,
      x: this.x.toJSON(),
      y: this.y.toJSON(),
      z: this.z.toJSON()
    };
  }
  static fromJSON(json) {
    return new ForceOverLife(ValueGeneratorFromJSON(json.x), ValueGeneratorFromJSON(json.y), ValueGeneratorFromJSON(json.z));
  }
  frameUpdate(delta) {
    if (this.ps && !this.ps.worldSpace) {
      const translation = this._temp;
      const quaternion = this._tempQ;
      const scale = this._tempScale;
      this.ps.emitter.matrixWorld.decompose(translation, quaternion, scale);
      quaternion.invert();
      scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z);
    }
  }
  clone() {
    return new ForceOverLife(this.x.clone(), this.y.clone(), this.z.clone());
  }
  reset() {
  }
};
var SizeOverLife = class {
  initialize(particle) {
    this.size.startGen(particle.memory);
  }
  constructor(size) {
    this.size = size;
    this.type = "SizeOverLife";
  }
  update(particle) {
    if (this.size instanceof Vector3Function) {
      this.size.genValue(particle.memory, particle.size, particle.age / particle.life).multiply(particle.startSize);
    } else {
      particle.size.copy(particle.startSize).multiplyScalar(this.size.genValue(particle.memory, particle.age / particle.life));
    }
  }
  toJSON() {
    return {
      type: this.type,
      size: this.size.toJSON()
    };
  }
  static fromJSON(json) {
    return new SizeOverLife(GeneratorFromJSON(json.size));
  }
  frameUpdate(delta) {
  }
  clone() {
    return new SizeOverLife(this.size.clone());
  }
  reset() {
  }
};
var SpeedOverLife = class {
  initialize(particle) {
    this.speed.startGen(particle.memory);
  }
  constructor(speed) {
    this.speed = speed;
    this.type = "SpeedOverLife";
  }
  update(particle) {
    particle.speedModifier = this.speed.genValue(particle.memory, particle.age / particle.life);
  }
  toJSON() {
    return {
      type: this.type,
      speed: this.speed.toJSON()
    };
  }
  static fromJSON(json) {
    return new SpeedOverLife(ValueGeneratorFromJSON(json.speed));
  }
  frameUpdate(delta) {
  }
  clone() {
    return new SpeedOverLife(this.speed.clone());
  }
  reset() {
  }
};
var FrameOverLife = class {
  constructor(frame) {
    this.frame = frame;
    this.type = "FrameOverLife";
  }
  initialize(particle) {
    this.frame.startGen(particle.memory);
  }
  update(particle, delta) {
    if (this.frame instanceof PiecewiseBezier) {
      particle.uvTile = this.frame.genValue(particle.memory, particle.age / particle.life);
    }
  }
  frameUpdate(delta) {
  }
  toJSON() {
    return {
      type: this.type,
      frame: this.frame.toJSON()
    };
  }
  static fromJSON(json) {
    return new FrameOverLife(ValueGeneratorFromJSON(json.frame));
  }
  clone() {
    return new FrameOverLife(this.frame.clone());
  }
  reset() {
  }
};
new Vector33(0, 0, 1);
var OrbitOverLife = class {
  constructor(orbitSpeed, axis = new Vector33(0, 1, 0)) {
    this.orbitSpeed = orbitSpeed;
    this.axis = axis;
    this.type = "OrbitOverLife";
    this.temp = new Vector33();
    this.rotation = new Quaternion2();
  }
  initialize(particle) {
    this.orbitSpeed.startGen(particle.memory);
  }
  update(particle, delta) {
    this.temp.copy(particle.position).projectOnVector(this.axis);
    this.rotation.setFromAxisAngle(this.axis, this.orbitSpeed.genValue(particle.memory, particle.age / particle.life) * delta);
    particle.position.sub(this.temp);
    particle.position.applyQuaternion(this.rotation);
    particle.position.add(this.temp);
  }
  frameUpdate(delta) {
  }
  toJSON() {
    return {
      type: this.type,
      orbitSpeed: this.orbitSpeed.toJSON(),
      axis: [this.axis.x, this.axis.y, this.axis.z]
    };
  }
  static fromJSON(json) {
    return new OrbitOverLife(ValueGeneratorFromJSON(json.orbitSpeed), json.axis ? new Vector33(json.axis[0], json.axis[1], json.axis[2]) : void 0);
  }
  clone() {
    return new OrbitOverLife(this.orbitSpeed.clone());
  }
  reset() {
  }
};
var LinkedListNode = class {
  constructor(data) {
    this.data = data;
    this.next = null;
    this.prev = null;
  }
  hasPrev() {
    return this.prev !== null;
  }
  hasNext() {
    return this.next !== null;
  }
};
var LinkedList = class {
  constructor() {
    this.length = 0;
    this.head = this.tail = null;
  }
  isEmpty() {
    return this.head === null;
  }
  clear() {
    this.length = 0;
    this.head = this.tail = null;
  }
  front() {
    if (this.head === null)
      return null;
    return this.head.data;
  }
  back() {
    if (this.tail === null)
      return null;
    return this.tail.data;
  }
  dequeue() {
    if (this.head) {
      const value = this.head.data;
      this.head = this.head.next;
      if (!this.head) {
        this.tail = null;
      } else {
        this.head.prev = null;
      }
      this.length--;
      return value;
    }
    return void 0;
  }
  pop() {
    if (this.tail) {
      const value = this.tail.data;
      this.tail = this.tail.prev;
      if (!this.tail) {
        this.head = null;
      } else {
        this.tail.next = null;
      }
      this.length--;
      return value;
    }
    return void 0;
  }
  queue(data) {
    const node = new LinkedListNode(data);
    if (!this.tail) {
      this.tail = node;
    }
    if (this.head) {
      this.head.prev = node;
      node.next = this.head;
    }
    this.head = node;
    this.length++;
  }
  push(data) {
    const node = new LinkedListNode(data);
    if (!this.head) {
      this.head = node;
    }
    if (this.tail) {
      this.tail.next = node;
      node.prev = this.tail;
    }
    this.tail = node;
    this.length++;
  }
  insertBefore(node, data) {
    const newNode = new LinkedListNode(data);
    newNode.next = node;
    newNode.prev = node.prev;
    if (newNode.prev !== null) {
      newNode.prev.next = newNode;
    }
    newNode.next.prev = newNode;
    if (node == this.head) {
      this.head = newNode;
    }
    this.length++;
  }
  remove(data) {
    if (this.head === null || this.tail === null) {
      return;
    }
    let tempNode = this.head;
    if (data === this.head.data) {
      this.head = this.head.next;
    }
    if (data === this.tail.data) {
      this.tail = this.tail.prev;
    }
    while (tempNode.next !== null && tempNode.data !== data) {
      tempNode = tempNode.next;
    }
    if (tempNode.data === data) {
      if (tempNode.prev !== null)
        tempNode.prev.next = tempNode.next;
      if (tempNode.next !== null)
        tempNode.next.prev = tempNode.prev;
      this.length--;
    }
  }
  *values() {
    let current = this.head;
    while (current !== null) {
      yield current.data;
      current = current.next;
    }
  }
};
var SpriteParticle = class {
  constructor() {
    this.startSpeed = 0;
    this.startColor = new Vector42();
    this.startSize = new Vector33(1, 1, 1);
    this.position = new Vector33();
    this.velocity = new Vector33();
    this.age = 0;
    this.life = 1;
    this.size = new Vector33(1, 1, 1);
    this.speedModifier = 1;
    this.rotation = 0;
    this.color = new Vector42();
    this.uvTile = 0;
    this.memory = [];
  }
  get died() {
    return this.age >= this.life;
  }
  reset() {
    this.memory.length = 0;
  }
};
var RecordState = class {
  constructor(position, size, color2) {
    this.position = position;
    this.size = size;
    this.color = color2;
  }
};
var TrailParticle = class {
  constructor() {
    this.startSpeed = 0;
    this.startColor = new Vector42();
    this.startSize = new Vector33(1, 1, 1);
    this.position = new Vector33();
    this.velocity = new Vector33();
    this.age = 0;
    this.life = 1;
    this.size = new Vector33(1, 1, 1);
    this.length = 100;
    this.speedModifier = 1;
    this.color = new Vector42();
    this.previous = new LinkedList();
    this.uvTile = 0;
    this.memory = [];
  }
  update() {
    if (this.age <= this.life) {
      this.previous.push(new RecordState(this.position.clone(), this.size.x, this.color.clone()));
    } else {
      if (this.previous.length > 0) {
        this.previous.dequeue();
      }
    }
    while (this.previous.length > this.length) {
      this.previous.dequeue();
    }
  }
  get died() {
    return this.age >= this.life;
  }
  reset() {
    this.memory.length = 0;
    this.previous.clear();
  }
};
var WidthOverLength = class {
  initialize(particle) {
    this.width.startGen(particle.memory);
  }
  constructor(width) {
    this.width = width;
    this.type = "WidthOverLength";
  }
  update(particle) {
    if (particle instanceof TrailParticle) {
      const iter = particle.previous.values();
      for (let i = 0; i < particle.previous.length; i++) {
        const cur = iter.next();
        cur.value.size = this.width.genValue(particle.memory, (particle.previous.length - i) / particle.length);
      }
    }
  }
  frameUpdate(delta) {
  }
  toJSON() {
    return {
      type: this.type,
      width: this.width.toJSON()
    };
  }
  static fromJSON(json) {
    return new WidthOverLength(ValueGeneratorFromJSON(json.width));
  }
  clone() {
    return new WidthOverLength(this.width.clone());
  }
  reset() {
  }
};
var ApplyForce = class {
  constructor(direction, magnitude) {
    this.direction = direction;
    this.magnitude = magnitude;
    this.type = "ApplyForce";
    this.memory = {
      data: [],
      dataCount: 0
    };
    this.magnitudeValue = this.magnitude.genValue(this.memory);
  }
  initialize(particle) {
  }
  update(particle, delta) {
    particle.velocity.addScaledVector(this.direction, this.magnitudeValue * delta);
  }
  frameUpdate(delta) {
    this.magnitudeValue = this.magnitude.genValue(this.memory);
  }
  toJSON() {
    return {
      type: this.type,
      direction: [this.direction.x, this.direction.y, this.direction.z],
      magnitude: this.magnitude.toJSON()
    };
  }
  static fromJSON(json) {
    var _a2;
    return new ApplyForce(new Vector33(json.direction[0], json.direction[1], json.direction[2]), ValueGeneratorFromJSON((_a2 = json.magnitude) !== null && _a2 !== void 0 ? _a2 : json.force));
  }
  clone() {
    return new ApplyForce(this.direction.clone(), this.magnitude.clone());
  }
  reset() {
  }
};
var GravityForce = class {
  constructor(center, magnitude) {
    this.center = center;
    this.magnitude = magnitude;
    this.type = "GravityForce";
    this.temp = new Vector33();
  }
  initialize(particle) {
  }
  update(particle, delta) {
    this.temp.copy(this.center).sub(particle.position).normalize();
    particle.velocity.addScaledVector(this.temp, this.magnitude / particle.position.distanceToSquared(this.center) * delta);
  }
  frameUpdate(delta) {
  }
  toJSON() {
    return {
      type: this.type,
      center: [this.center.x, this.center.y, this.center.z],
      magnitude: this.magnitude
    };
  }
  static fromJSON(json) {
    return new GravityForce(new Vector33(json.center[0], json.center[1], json.center[2]), json.magnitude);
  }
  clone() {
    return new GravityForce(this.center.clone(), this.magnitude);
  }
  reset() {
  }
};
new Vector33(0, 0, 1);
var ChangeEmitDirection = class {
  constructor(angle) {
    this.angle = angle;
    this.type = "ChangeEmitDirection";
    this._temp = new Vector33();
    this._q = new Quaternion2();
    this.memory = { data: [], dataCount: 0 };
  }
  initialize(particle) {
    const len = particle.velocity.length();
    if (len == 0)
      return;
    particle.velocity.normalize();
    if (particle.velocity.x === 0 && particle.velocity.y === 0) {
      this._temp.set(0, particle.velocity.z, 0);
    } else {
      this._temp.set(-particle.velocity.y, particle.velocity.x, 0);
    }
    this.angle.startGen(this.memory);
    this._q.setFromAxisAngle(this._temp.normalize(), this.angle.genValue(this.memory));
    this._temp.copy(particle.velocity);
    particle.velocity.applyQuaternion(this._q);
    this._q.setFromAxisAngle(this._temp, Math.random() * Math.PI * 2);
    particle.velocity.applyQuaternion(this._q);
    particle.velocity.setLength(len);
  }
  update(particle, delta) {
  }
  frameUpdate(delta) {
  }
  toJSON() {
    return {
      type: this.type,
      angle: this.angle.toJSON()
    };
  }
  static fromJSON(json) {
    return new ChangeEmitDirection(ValueGeneratorFromJSON(json.angle));
  }
  clone() {
    return new ChangeEmitDirection(this.angle);
  }
  reset() {
  }
};
var VECTOR_ONE = new Vector33(1, 1, 1);
var VECTOR_Z = new Vector33(0, 0, 1);
var SubParticleEmitMode;
(function(SubParticleEmitMode2) {
  SubParticleEmitMode2[SubParticleEmitMode2["Death"] = 0] = "Death";
  SubParticleEmitMode2[SubParticleEmitMode2["Birth"] = 1] = "Birth";
  SubParticleEmitMode2[SubParticleEmitMode2["Frame"] = 2] = "Frame";
})(SubParticleEmitMode || (SubParticleEmitMode = {}));
var EmitSubParticleSystem = class {
  constructor(particleSystem, useVelocityAsBasis, subParticleSystem, mode = SubParticleEmitMode.Frame, emitProbability = 1) {
    this.particleSystem = particleSystem;
    this.useVelocityAsBasis = useVelocityAsBasis;
    this.subParticleSystem = subParticleSystem;
    this.mode = mode;
    this.emitProbability = emitProbability;
    this.type = "EmitSubParticleSystem";
    this.q_ = new Quaternion2();
    this.v_ = new Vector33();
    this.v2_ = new Vector33();
    this.subEmissions = new Array();
    if (this.subParticleSystem && this.subParticleSystem.system) {
      this.subParticleSystem.system.onlyUsedByOther = true;
    }
  }
  initialize(particle) {
  }
  update(particle, delta) {
    if (this.mode === SubParticleEmitMode.Frame) {
      this.emit(particle, delta);
    } else if (this.mode === SubParticleEmitMode.Birth && particle.age === 0) {
      this.emit(particle, delta);
    } else if (this.mode === SubParticleEmitMode.Death && particle.age + delta >= particle.life) {
      this.emit(particle, delta);
    }
  }
  emit(particle, delta) {
    if (!this.subParticleSystem)
      return;
    if (Math.random() > this.emitProbability) {
      return;
    }
    const m2 = new Matrix42();
    this.setMatrixFromParticle(m2, particle);
    this.subEmissions.push({
      burstParticleCount: 0,
      burstParticleIndex: 0,
      isBursting: false,
      burstIndex: 0,
      burstWaveIndex: 0,
      time: 0,
      waitEmiting: 0,
      matrix: m2,
      travelDistance: 0,
      particle
    });
  }
  frameUpdate(delta) {
    if (!this.subParticleSystem)
      return;
    for (let i = 0; i < this.subEmissions.length; i++) {
      if (this.subEmissions[i].time >= this.subParticleSystem.system.duration) {
        this.subEmissions[i] = this.subEmissions[this.subEmissions.length - 1];
        this.subEmissions.length = this.subEmissions.length - 1;
        i--;
      } else {
        const subEmissionState = this.subEmissions[i];
        if (subEmissionState.particle && subEmissionState.particle.age < subEmissionState.particle.life) {
          this.setMatrixFromParticle(subEmissionState.matrix, subEmissionState.particle);
        } else {
          subEmissionState.particle = void 0;
        }
        this.subParticleSystem.system.emit(delta, subEmissionState, subEmissionState.matrix);
      }
    }
  }
  toJSON() {
    return {
      type: this.type,
      subParticleSystem: this.subParticleSystem ? this.subParticleSystem.uuid : "",
      useVelocityAsBasis: this.useVelocityAsBasis,
      mode: this.mode,
      emitProbability: this.emitProbability
    };
  }
  static fromJSON(json, particleSystem) {
    return new EmitSubParticleSystem(particleSystem, json.useVelocityAsBasis, json.subParticleSystem, json.mode, json.emitProbability);
  }
  clone() {
    return new EmitSubParticleSystem(this.particleSystem, this.useVelocityAsBasis, this.subParticleSystem, this.mode, this.emitProbability);
  }
  reset() {
  }
  setMatrixFromParticle(m2, particle) {
    let rotation;
    if (particle.rotation === void 0 || this.useVelocityAsBasis) {
      if (particle.velocity.x === 0 && particle.velocity.y === 0 && (particle.velocity.z === 1 || particle.velocity.z === 0)) {
        m2.set(1, 0, 0, particle.position.x, 0, 1, 0, particle.position.y, 0, 0, 1, particle.position.z, 0, 0, 0, 1);
      } else {
        this.v_.copy(VECTOR_Z).cross(particle.velocity);
        this.v2_.copy(particle.velocity).cross(this.v_);
        const len = this.v_.length();
        const len2 = this.v2_.length();
        m2.set(this.v_.x / len, this.v2_.x / len2, particle.velocity.x, particle.position.x, this.v_.y / len, this.v2_.y / len2, particle.velocity.y, particle.position.y, this.v_.z / len, this.v2_.z / len2, particle.velocity.z, particle.position.z, 0, 0, 0, 1);
      }
    } else {
      if (particle.rotation instanceof Quaternion2) {
        rotation = particle.rotation;
      } else {
        this.q_.setFromAxisAngle(VECTOR_Z, particle.rotation);
        rotation = this.q_;
      }
      m2.compose(particle.position, rotation, VECTOR_ONE);
    }
    if (!this.particleSystem.worldSpace) {
      m2.multiplyMatrices(this.particleSystem.emitter.matrixWorld, m2);
    }
  }
};
var F22 = 0.5 * (Math.sqrt(3) - 1);
var G22 = (3 - Math.sqrt(3)) / 6;
var F32 = 1 / 3;
var G32 = 1 / 6;
var F42 = (Math.sqrt(5) - 1) / 4;
var G42 = (5 - Math.sqrt(5)) / 20;
var grad32 = new Float32Array([
  1,
  1,
  0,
  -1,
  1,
  0,
  1,
  -1,
  0,
  -1,
  -1,
  0,
  1,
  0,
  1,
  -1,
  0,
  1,
  1,
  0,
  -1,
  -1,
  0,
  -1,
  0,
  1,
  1,
  0,
  -1,
  1,
  0,
  1,
  -1,
  0,
  -1,
  -1
]);
var grad42 = new Float32Array([
  0,
  1,
  1,
  1,
  0,
  1,
  1,
  -1,
  0,
  1,
  -1,
  1,
  0,
  1,
  -1,
  -1,
  0,
  -1,
  1,
  1,
  0,
  -1,
  1,
  -1,
  0,
  -1,
  -1,
  1,
  0,
  -1,
  -1,
  -1,
  1,
  0,
  1,
  1,
  1,
  0,
  1,
  -1,
  1,
  0,
  -1,
  1,
  1,
  0,
  -1,
  -1,
  -1,
  0,
  1,
  1,
  -1,
  0,
  1,
  -1,
  -1,
  0,
  -1,
  1,
  -1,
  0,
  -1,
  -1,
  1,
  1,
  0,
  1,
  1,
  1,
  0,
  -1,
  1,
  -1,
  0,
  1,
  1,
  -1,
  0,
  -1,
  -1,
  1,
  0,
  1,
  -1,
  1,
  0,
  -1,
  -1,
  -1,
  0,
  1,
  -1,
  -1,
  0,
  -1,
  1,
  1,
  1,
  0,
  1,
  1,
  -1,
  0,
  1,
  -1,
  1,
  0,
  1,
  -1,
  -1,
  0,
  -1,
  1,
  1,
  0,
  -1,
  1,
  -1,
  0,
  -1,
  -1,
  1,
  0,
  -1,
  -1,
  -1,
  0
]);
var SimplexNoise = class {
  constructor(randomOrSeed = Math.random) {
    const random = typeof randomOrSeed == "function" ? randomOrSeed : alea(randomOrSeed);
    this.p = buildPermutationTable2(random);
    this.perm = new Uint8Array(512);
    this.permMod12 = new Uint8Array(512);
    for (let i = 0; i < 512; i++) {
      this.perm[i] = this.p[i & 255];
      this.permMod12[i] = this.perm[i] % 12;
    }
  }
  noise2D(x2, y) {
    const permMod12 = this.permMod12;
    const perm = this.perm;
    let n0 = 0;
    let n1 = 0;
    let n2 = 0;
    const s = (x2 + y) * F22;
    const i = Math.floor(x2 + s);
    const j = Math.floor(y + s);
    const t2 = (i + j) * G22;
    const X0 = i - t2;
    const Y0 = j - t2;
    const x0 = x2 - X0;
    const y0 = y - Y0;
    let i1, j1;
    if (x0 > y0) {
      i1 = 1;
      j1 = 0;
    } else {
      i1 = 0;
      j1 = 1;
    }
    const x1 = x0 - i1 + G22;
    const y1 = y0 - j1 + G22;
    const x22 = x0 - 1 + 2 * G22;
    const y2 = y0 - 1 + 2 * G22;
    const ii = i & 255;
    const jj = j & 255;
    let t0 = 0.5 - x0 * x0 - y0 * y0;
    if (t0 >= 0) {
      const gi0 = permMod12[ii + perm[jj]] * 3;
      t0 *= t0;
      n0 = t0 * t0 * (grad32[gi0] * x0 + grad32[gi0 + 1] * y0);
    }
    let t1 = 0.5 - x1 * x1 - y1 * y1;
    if (t1 >= 0) {
      const gi1 = permMod12[ii + i1 + perm[jj + j1]] * 3;
      t1 *= t1;
      n1 = t1 * t1 * (grad32[gi1] * x1 + grad32[gi1 + 1] * y1);
    }
    let t22 = 0.5 - x22 * x22 - y2 * y2;
    if (t22 >= 0) {
      const gi2 = permMod12[ii + 1 + perm[jj + 1]] * 3;
      t22 *= t22;
      n2 = t22 * t22 * (grad32[gi2] * x22 + grad32[gi2 + 1] * y2);
    }
    return 70 * (n0 + n1 + n2);
  }
  noise3D(x2, y, z) {
    const permMod12 = this.permMod12;
    const perm = this.perm;
    let n0, n1, n2, n3;
    const s = (x2 + y + z) * F32;
    const i = Math.floor(x2 + s);
    const j = Math.floor(y + s);
    const k = Math.floor(z + s);
    const t2 = (i + j + k) * G32;
    const X0 = i - t2;
    const Y0 = j - t2;
    const Z0 = k - t2;
    const x0 = x2 - X0;
    const y0 = y - Y0;
    const z0 = z - Z0;
    let i1, j1, k1;
    let i2, j2, k2;
    if (x0 >= y0) {
      if (y0 >= z0) {
        i1 = 1;
        j1 = 0;
        k1 = 0;
        i2 = 1;
        j2 = 1;
        k2 = 0;
      } else if (x0 >= z0) {
        i1 = 1;
        j1 = 0;
        k1 = 0;
        i2 = 1;
        j2 = 0;
        k2 = 1;
      } else {
        i1 = 0;
        j1 = 0;
        k1 = 1;
        i2 = 1;
        j2 = 0;
        k2 = 1;
      }
    } else {
      if (y0 < z0) {
        i1 = 0;
        j1 = 0;
        k1 = 1;
        i2 = 0;
        j2 = 1;
        k2 = 1;
      } else if (x0 < z0) {
        i1 = 0;
        j1 = 1;
        k1 = 0;
        i2 = 0;
        j2 = 1;
        k2 = 1;
      } else {
        i1 = 0;
        j1 = 1;
        k1 = 0;
        i2 = 1;
        j2 = 1;
        k2 = 0;
      }
    }
    const x1 = x0 - i1 + G32;
    const y1 = y0 - j1 + G32;
    const z1 = z0 - k1 + G32;
    const x22 = x0 - i2 + 2 * G32;
    const y2 = y0 - j2 + 2 * G32;
    const z2 = z0 - k2 + 2 * G32;
    const x3 = x0 - 1 + 3 * G32;
    const y3 = y0 - 1 + 3 * G32;
    const z3 = z0 - 1 + 3 * G32;
    const ii = i & 255;
    const jj = j & 255;
    const kk = k & 255;
    let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
    if (t0 < 0)
      n0 = 0;
    else {
      const gi0 = permMod12[ii + perm[jj + perm[kk]]] * 3;
      t0 *= t0;
      n0 = t0 * t0 * (grad32[gi0] * x0 + grad32[gi0 + 1] * y0 + grad32[gi0 + 2] * z0);
    }
    let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
    if (t1 < 0)
      n1 = 0;
    else {
      const gi1 = permMod12[ii + i1 + perm[jj + j1 + perm[kk + k1]]] * 3;
      t1 *= t1;
      n1 = t1 * t1 * (grad32[gi1] * x1 + grad32[gi1 + 1] * y1 + grad32[gi1 + 2] * z1);
    }
    let t22 = 0.6 - x22 * x22 - y2 * y2 - z2 * z2;
    if (t22 < 0)
      n2 = 0;
    else {
      const gi2 = permMod12[ii + i2 + perm[jj + j2 + perm[kk + k2]]] * 3;
      t22 *= t22;
      n2 = t22 * t22 * (grad32[gi2] * x22 + grad32[gi2 + 1] * y2 + grad32[gi2 + 2] * z2);
    }
    let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
    if (t3 < 0)
      n3 = 0;
    else {
      const gi3 = permMod12[ii + 1 + perm[jj + 1 + perm[kk + 1]]] * 3;
      t3 *= t3;
      n3 = t3 * t3 * (grad32[gi3] * x3 + grad32[gi3 + 1] * y3 + grad32[gi3 + 2] * z3);
    }
    return 32 * (n0 + n1 + n2 + n3);
  }
  noise4D(x2, y, z, w) {
    const perm = this.perm;
    let n0, n1, n2, n3, n4;
    const s = (x2 + y + z + w) * F42;
    const i = Math.floor(x2 + s);
    const j = Math.floor(y + s);
    const k = Math.floor(z + s);
    const l = Math.floor(w + s);
    const t2 = (i + j + k + l) * G42;
    const X0 = i - t2;
    const Y0 = j - t2;
    const Z0 = k - t2;
    const W0 = l - t2;
    const x0 = x2 - X0;
    const y0 = y - Y0;
    const z0 = z - Z0;
    const w0 = w - W0;
    let rankx = 0;
    let ranky = 0;
    let rankz = 0;
    let rankw = 0;
    if (x0 > y0)
      rankx++;
    else
      ranky++;
    if (x0 > z0)
      rankx++;
    else
      rankz++;
    if (x0 > w0)
      rankx++;
    else
      rankw++;
    if (y0 > z0)
      ranky++;
    else
      rankz++;
    if (y0 > w0)
      ranky++;
    else
      rankw++;
    if (z0 > w0)
      rankz++;
    else
      rankw++;
    const i1 = rankx >= 3 ? 1 : 0;
    const j1 = ranky >= 3 ? 1 : 0;
    const k1 = rankz >= 3 ? 1 : 0;
    const l1 = rankw >= 3 ? 1 : 0;
    const i2 = rankx >= 2 ? 1 : 0;
    const j2 = ranky >= 2 ? 1 : 0;
    const k2 = rankz >= 2 ? 1 : 0;
    const l2 = rankw >= 2 ? 1 : 0;
    const i3 = rankx >= 1 ? 1 : 0;
    const j3 = ranky >= 1 ? 1 : 0;
    const k3 = rankz >= 1 ? 1 : 0;
    const l3 = rankw >= 1 ? 1 : 0;
    const x1 = x0 - i1 + G42;
    const y1 = y0 - j1 + G42;
    const z1 = z0 - k1 + G42;
    const w1 = w0 - l1 + G42;
    const x22 = x0 - i2 + 2 * G42;
    const y2 = y0 - j2 + 2 * G42;
    const z2 = z0 - k2 + 2 * G42;
    const w2 = w0 - l2 + 2 * G42;
    const x3 = x0 - i3 + 3 * G42;
    const y3 = y0 - j3 + 3 * G42;
    const z3 = z0 - k3 + 3 * G42;
    const w3 = w0 - l3 + 3 * G42;
    const x4 = x0 - 1 + 4 * G42;
    const y4 = y0 - 1 + 4 * G42;
    const z4 = z0 - 1 + 4 * G42;
    const w4 = w0 - 1 + 4 * G42;
    const ii = i & 255;
    const jj = j & 255;
    const kk = k & 255;
    const ll = l & 255;
    let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
    if (t0 < 0)
      n0 = 0;
    else {
      const gi0 = perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32 * 4;
      t0 *= t0;
      n0 = t0 * t0 * (grad42[gi0] * x0 + grad42[gi0 + 1] * y0 + grad42[gi0 + 2] * z0 + grad42[gi0 + 3] * w0);
    }
    let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
    if (t1 < 0)
      n1 = 0;
    else {
      const gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32 * 4;
      t1 *= t1;
      n1 = t1 * t1 * (grad42[gi1] * x1 + grad42[gi1 + 1] * y1 + grad42[gi1 + 2] * z1 + grad42[gi1 + 3] * w1);
    }
    let t22 = 0.6 - x22 * x22 - y2 * y2 - z2 * z2 - w2 * w2;
    if (t22 < 0)
      n2 = 0;
    else {
      const gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32 * 4;
      t22 *= t22;
      n2 = t22 * t22 * (grad42[gi2] * x22 + grad42[gi2 + 1] * y2 + grad42[gi2 + 2] * z2 + grad42[gi2 + 3] * w2);
    }
    let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
    if (t3 < 0)
      n3 = 0;
    else {
      const gi3 = perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32 * 4;
      t3 *= t3;
      n3 = t3 * t3 * (grad42[gi3] * x3 + grad42[gi3 + 1] * y3 + grad42[gi3 + 2] * z3 + grad42[gi3 + 3] * w3);
    }
    let t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
    if (t4 < 0)
      n4 = 0;
    else {
      const gi4 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32 * 4;
      t4 *= t4;
      n4 = t4 * t4 * (grad42[gi4] * x4 + grad42[gi4 + 1] * y4 + grad42[gi4 + 2] * z4 + grad42[gi4 + 3] * w4);
    }
    return 27 * (n0 + n1 + n2 + n3 + n4);
  }
};
function buildPermutationTable2(random) {
  const p = new Uint8Array(256);
  for (let i = 0; i < 256; i++) {
    p[i] = i;
  }
  for (let i = 0; i < 255; i++) {
    const r = i + ~~(random() * (256 - i));
    const aux = p[i];
    p[i] = p[r];
    p[r] = aux;
  }
  return p;
}
function alea(seed) {
  let s0 = 0;
  let s1 = 0;
  let s2 = 0;
  let c2 = 1;
  const mash = masher();
  s0 = mash(" ");
  s1 = mash(" ");
  s2 = mash(" ");
  s0 -= mash(seed);
  if (s0 < 0) {
    s0 += 1;
  }
  s1 -= mash(seed);
  if (s1 < 0) {
    s1 += 1;
  }
  s2 -= mash(seed);
  if (s2 < 0) {
    s2 += 1;
  }
  return function() {
    const t2 = 2091639 * s0 + c2 * 23283064365386963e-26;
    s0 = s1;
    s1 = s2;
    return s2 = t2 - (c2 = t2 | 0);
  };
}
function masher() {
  let n2 = 4022871197;
  return function(data) {
    data = data.toString();
    for (let i = 0; i < data.length; i++) {
      n2 += data.charCodeAt(i);
      let h = 0.02519603282416938 * n2;
      n2 = h >>> 0;
      h -= n2;
      h *= n2;
      n2 = h >>> 0;
      h -= n2;
      n2 += h * 4294967296;
    }
    return (n2 >>> 0) * 23283064365386963e-26;
  };
}
var TurbulenceField = class {
  constructor(scale, octaves, velocityMultiplier, timeScale2) {
    this.scale = scale;
    this.octaves = octaves;
    this.velocityMultiplier = velocityMultiplier;
    this.timeScale = timeScale2;
    this.type = "TurbulenceField";
    this.generator = new SimplexNoise();
    this.timeOffset = new Vector33();
    this.temp = new Vector33();
    this.temp2 = new Vector33();
    this.timeOffset.x = Math.random() / this.scale.x * this.timeScale.x;
    this.timeOffset.y = Math.random() / this.scale.y * this.timeScale.y;
    this.timeOffset.z = Math.random() / this.scale.z * this.timeScale.z;
  }
  initialize(particle) {
  }
  update(particle, delta) {
    const x2 = particle.position.x / this.scale.x;
    const y = particle.position.y / this.scale.y;
    const z = particle.position.z / this.scale.z;
    this.temp.set(0, 0, 0);
    let lvl = 1;
    for (let i = 0; i < this.octaves; i++) {
      this.temp2.set(this.generator.noise4D(x2 * lvl, y * lvl, z * lvl, this.timeOffset.x * lvl) / lvl, this.generator.noise4D(x2 * lvl, y * lvl, z * lvl, this.timeOffset.y * lvl) / lvl, this.generator.noise4D(x2 * lvl, y * lvl, z * lvl, this.timeOffset.z * lvl) / lvl);
      this.temp.add(this.temp2);
      lvl *= 2;
    }
    this.temp.multiply(this.velocityMultiplier);
    particle.velocity.addScaledVector(this.temp, delta);
  }
  toJSON() {
    return {
      type: this.type,
      scale: [this.scale.x, this.scale.y, this.scale.z],
      octaves: this.octaves,
      velocityMultiplier: [this.velocityMultiplier.x, this.velocityMultiplier.y, this.velocityMultiplier.z],
      timeScale: [this.timeScale.x, this.timeScale.y, this.timeScale.z]
    };
  }
  frameUpdate(delta) {
    this.timeOffset.x += delta * this.timeScale.x;
    this.timeOffset.y += delta * this.timeScale.y;
    this.timeOffset.z += delta * this.timeScale.z;
  }
  static fromJSON(json) {
    return new TurbulenceField(new Vector33(json.scale[0], json.scale[1], json.scale[2]), json.octaves, new Vector33(json.velocityMultiplier[0], json.velocityMultiplier[1], json.velocityMultiplier[2]), new Vector33(json.timeScale[0], json.timeScale[1], json.timeScale[2]));
  }
  clone() {
    return new TurbulenceField(this.scale.clone(), this.octaves, this.velocityMultiplier.clone(), this.timeScale.clone());
  }
  reset() {
  }
};
function randomInt(a, b) {
  return Math.floor(Math.random() * (b - a)) + a;
}
var generators = [];
var tempV = new Vector33();
var tempQ = new Quaternion2();
var Noise = class {
  constructor(frequency, power, positionAmount = new ConstantValue(1), rotationAmount = new ConstantValue(0)) {
    this.frequency = frequency;
    this.power = power;
    this.positionAmount = positionAmount;
    this.rotationAmount = rotationAmount;
    this.type = "Noise";
    this.duration = 0;
    if (generators.length === 0) {
      for (let i = 0; i < 100; i++) {
        generators.push(new SimplexNoise());
      }
    }
  }
  initialize(particle) {
    particle.lastPosNoise = new Vector33();
    if (typeof particle.rotation === "number") {
      particle.lastRotNoise = 0;
    } else {
      particle.lastRotNoise = new Quaternion2();
    }
    particle.generatorIndex = [randomInt(0, 100), randomInt(0, 100), randomInt(0, 100), randomInt(0, 100)];
    this.positionAmount.startGen(particle.memory);
    this.rotationAmount.startGen(particle.memory);
    this.frequency.startGen(particle.memory);
    this.power.startGen(particle.memory);
  }
  update(particle, _) {
    let frequency = this.frequency.genValue(particle.memory, particle.age / particle.life);
    let power = this.power.genValue(particle.memory, particle.age / particle.life);
    let positionAmount = this.positionAmount.genValue(particle.memory, particle.age / particle.life);
    let rotationAmount = this.rotationAmount.genValue(particle.memory, particle.age / particle.life);
    if (positionAmount > 0 && particle.lastPosNoise !== void 0) {
      particle.position.sub(particle.lastPosNoise);
      tempV.set(generators[particle.generatorIndex[0]].noise2D(0, particle.age * frequency) * power * positionAmount, generators[particle.generatorIndex[1]].noise2D(0, particle.age * frequency) * power * positionAmount, generators[particle.generatorIndex[2]].noise2D(0, particle.age * frequency) * power * positionAmount);
      particle.position.add(tempV);
      particle.lastPosNoise.copy(tempV);
    }
    if (rotationAmount > 0 && particle.lastRotNoise !== void 0) {
      if (typeof particle.rotation === "number") {
        particle.rotation -= particle.lastRotNoise;
        particle.rotation += generators[particle.generatorIndex[3]].noise2D(0, particle.age * frequency) * Math.PI * power * rotationAmount;
      } else {
        particle.lastRotNoise.invert();
        particle.rotation.multiply(particle.lastRotNoise);
        tempQ.set(generators[particle.generatorIndex[0]].noise2D(0, particle.age * frequency) * power * rotationAmount, generators[particle.generatorIndex[1]].noise2D(0, particle.age * frequency) * power * rotationAmount, generators[particle.generatorIndex[2]].noise2D(0, particle.age * frequency) * power * rotationAmount, generators[particle.generatorIndex[3]].noise2D(0, particle.age * frequency) * power * rotationAmount).normalize();
        particle.rotation.multiply(tempQ);
        particle.lastRotNoise.copy(tempQ);
      }
    }
  }
  toJSON() {
    return {
      type: this.type,
      frequency: this.frequency.toJSON(),
      power: this.power.toJSON(),
      positionAmount: this.positionAmount.toJSON(),
      rotationAmount: this.rotationAmount.toJSON()
    };
  }
  frameUpdate(delta) {
    this.duration += delta;
  }
  static fromJSON(json) {
    return new Noise(ValueGeneratorFromJSON(json.frequency), ValueGeneratorFromJSON(json.power), ValueGeneratorFromJSON(json.positionAmount), ValueGeneratorFromJSON(json.rotationAmount));
  }
  clone() {
    return new Noise(this.frequency.clone(), this.power.clone(), this.positionAmount.clone(), this.rotationAmount.clone());
  }
  reset() {
  }
};
var TextureSequencer = class {
  constructor(scaleX = 0, scaleY = 0, position = new Vector33()) {
    this.scaleX = scaleX;
    this.scaleY = scaleY;
    this.position = position;
    this.locations = [];
  }
  transform(position, index) {
    position.x = this.locations[index % this.locations.length].x * this.scaleX + this.position.x;
    position.y = this.locations[index % this.locations.length].y * this.scaleY + this.position.y;
    position.z = this.position.z;
  }
  static fromJSON(json) {
    const textureSequencer = new TextureSequencer(json.scaleX, json.scaleY, new Vector33(json.position[0], json.position[1], json.position[2]));
    textureSequencer.locations = json.locations.map((loc) => new Vector22(loc.x, loc.y));
    return textureSequencer;
  }
  clone() {
    const textureSequencer = new TextureSequencer(this.scaleX, this.scaleY, this.position.clone());
    textureSequencer.locations = this.locations.map((loc) => loc.clone());
    return textureSequencer;
  }
  toJSON() {
    return {
      scaleX: this.scaleX,
      scaleY: this.scaleY,
      position: this.position,
      locations: this.locations.map((loc) => ({
        x: loc.x,
        y: loc.y
      }))
    };
  }
  fromImage(img, threshold) {
    const canvas = document.createElement("canvas");
    canvas.width = img.width;
    canvas.height = img.height;
    const ctx = canvas.getContext("2d");
    if (!ctx) {
      return;
    }
    ctx.drawImage(img, 0, 0);
    const data = ctx.getImageData(0, 0, canvas.width, canvas.height, { colorSpace: "srgb" });
    canvas.remove();
    this.locations.length = 0;
    for (let i = 0; i < data.height; i++) {
      for (let j = 0; j < data.width; j++) {
        if (data.data[(i * data.width + j) * 4 + 3] > threshold) {
          this.locations.push(new Vector22(j, data.height - i));
        }
      }
    }
  }
};
function SequencerFromJSON(json) {
  switch (json.type) {
    case "TextureSequencer":
      return TextureSequencer.fromJSON(json);
    default:
      return new TextureSequencer();
  }
}
var ApplySequences = class {
  constructor(delayBetweenParticles) {
    this.type = "ApplySequences";
    this.sequencers = [];
    this.time = 0;
    this.index = 0;
    this.pCount = 0;
    this.tempV = new Vector33();
    this.delay = delayBetweenParticles;
  }
  initialize(particle) {
    particle.id = this.pCount;
    particle.dst = new Vector33();
    particle.begin = new Vector33();
    particle.inMotion = false;
    this.pCount++;
  }
  reset() {
    this.time = 0;
    this.index = 0;
    this.pCount = 0;
  }
  update(particle, delta) {
    const sequencer = this.sequencers[this.index];
    const delay2 = particle.id * this.delay;
    if (this.time >= sequencer[0].a + delay2 && this.time <= sequencer[0].b + delay2) {
      if (!particle.inMotion) {
        particle.inMotion = true;
        particle.begin.copy(particle.position);
        sequencer[1].transform(particle.dst, particle.id);
      }
      particle.position.lerpVectors(particle.begin, particle.dst, ApplySequences.BEZIER.genValue((this.time - sequencer[0].a - delay2) / (sequencer[0].b - sequencer[0].a)));
    } else if (this.time > sequencer[0].b + delay2) {
      particle.inMotion = false;
    }
  }
  frameUpdate(delta) {
    while (this.index + 1 < this.sequencers.length && this.time >= this.sequencers[this.index + 1][0].a) {
      this.index++;
    }
    this.time += delta;
  }
  appendSequencer(range, sequencer) {
    this.sequencers.push([range, sequencer]);
  }
  toJSON() {
    return {
      type: this.type,
      delay: this.delay,
      sequencers: this.sequencers.map(([range, sequencer]) => ({
        range: range.toJSON(),
        sequencer: sequencer.toJSON()
      }))
    };
  }
  static fromJSON(json) {
    const seq = new ApplySequences(json.delay);
    json.sequencers.forEach((sequencerJson) => {
      seq.sequencers.push([
        ValueGeneratorFromJSON(sequencerJson.range),
        SequencerFromJSON(sequencerJson.sequencer)
      ]);
    });
    return seq;
  }
  clone() {
    const applySequences = new ApplySequences(this.delay);
    applySequences.sequencers = this.sequencers.map((seq) => [seq[0].clone(), seq[1].clone()]);
    return applySequences;
  }
};
ApplySequences.BEZIER = new Bezier(0, 0, 1, 1);
var ColorBySpeed = class {
  constructor(color2, speedRange) {
    this.color = color2;
    this.speedRange = speedRange;
    this.type = "ColorBySpeed";
  }
  initialize(particle) {
    this.color.startGen(particle.memory);
  }
  update(particle, delta) {
    const t2 = (particle.startSpeed - this.speedRange.a) / (this.speedRange.b - this.speedRange.a);
    this.color.genColor(particle.memory, particle.color, t2);
    particle.color.x *= particle.startColor.x;
    particle.color.y *= particle.startColor.y;
    particle.color.z *= particle.startColor.z;
    particle.color.w *= particle.startColor.w;
  }
  frameUpdate(delta) {
  }
  toJSON() {
    return {
      type: this.type,
      color: this.color.toJSON(),
      speedRange: this.speedRange.toJSON()
    };
  }
  static fromJSON(json) {
    return new ColorBySpeed(ColorGeneratorFromJSON(json.color), IntervalValue.fromJSON(json.speedRange));
  }
  clone() {
    return new ColorBySpeed(this.color.clone(), this.speedRange.clone());
  }
  reset() {
  }
};
var SizeBySpeed = class {
  initialize(particle) {
    this.size.startGen(particle.memory);
  }
  constructor(size, speedRange) {
    this.size = size;
    this.speedRange = speedRange;
    this.type = "SizeBySpeed";
  }
  update(particle) {
    const t2 = (particle.startSpeed - this.speedRange.a) / (this.speedRange.b - this.speedRange.a);
    if (this.size instanceof Vector3Function) {
      this.size.genValue(particle.memory, particle.size, t2).multiply(particle.startSize);
    } else {
      particle.size.copy(particle.startSize).multiplyScalar(this.size.genValue(particle.memory, t2));
    }
  }
  toJSON() {
    return {
      type: this.type,
      size: this.size.toJSON(),
      speedRange: this.speedRange.toJSON()
    };
  }
  static fromJSON(json) {
    return new SizeBySpeed(GeneratorFromJSON(json.size), IntervalValue.fromJSON(json.speedRange));
  }
  frameUpdate(delta) {
  }
  clone() {
    return new SizeBySpeed(this.size.clone(), this.speedRange.clone());
  }
  reset() {
  }
};
var RotationBySpeed = class {
  constructor(angularVelocity, speedRange) {
    this.angularVelocity = angularVelocity;
    this.speedRange = speedRange;
    this.type = "RotationBySpeed";
    this.tempQuat = new Quaternion2();
  }
  initialize(particle) {
    if (typeof particle.rotation === "number") {
      this.angularVelocity.startGen(particle.memory);
    }
  }
  update(particle, delta) {
    if (typeof particle.rotation === "number") {
      const t2 = (particle.startSpeed - this.speedRange.a) / (this.speedRange.b - this.speedRange.a);
      particle.rotation += delta * this.angularVelocity.genValue(particle.memory, t2);
    }
  }
  toJSON() {
    return {
      type: this.type,
      angularVelocity: this.angularVelocity.toJSON(),
      speedRange: this.speedRange.toJSON()
    };
  }
  static fromJSON(json) {
    return new RotationBySpeed(ValueGeneratorFromJSON(json.angularVelocity), IntervalValue.fromJSON(json.speedRange));
  }
  frameUpdate(delta) {
  }
  clone() {
    return new RotationBySpeed(this.angularVelocity.clone(), this.speedRange.clone());
  }
  reset() {
  }
};
var LimitSpeedOverLife = class {
  initialize(particle) {
    this.speed.startGen(particle.memory);
  }
  constructor(speed, dampen) {
    this.speed = speed;
    this.dampen = dampen;
    this.type = "LimitSpeedOverLife";
  }
  update(particle, delta) {
    let speed = particle.velocity.length();
    let limit = this.speed.genValue(particle.memory, particle.age / particle.life);
    if (speed > limit) {
      const percent = (speed - limit) / speed;
      particle.velocity.multiplyScalar(1 - percent * this.dampen * delta * 20);
    }
  }
  toJSON() {
    return {
      type: this.type,
      speed: this.speed.toJSON(),
      dampen: this.dampen
    };
  }
  static fromJSON(json) {
    return new LimitSpeedOverLife(ValueGeneratorFromJSON(json.speed), json.dampen);
  }
  frameUpdate(delta) {
  }
  clone() {
    return new LimitSpeedOverLife(this.speed.clone(), this.dampen);
  }
  reset() {
  }
};
var BehaviorTypes = {
  ApplyForce: {
    type: "ApplyForce",
    constructor: ApplyForce,
    params: [
      ["direction", ["vec3"]],
      ["magnitude", ["value"]]
    ],
    loadJSON: ApplyForce.fromJSON
  },
  Noise: {
    type: "Noise",
    constructor: Noise,
    params: [
      ["frequency", ["value"]],
      ["power", ["value"]],
      ["positionAmount", ["value"]],
      ["rotationAmount", ["value"]]
    ],
    loadJSON: Noise.fromJSON
  },
  TurbulenceField: {
    type: "TurbulenceField",
    constructor: TurbulenceField,
    params: [
      ["scale", ["vec3"]],
      ["octaves", ["number"]],
      ["velocityMultiplier", ["vec3"]],
      ["timeScale", ["vec3"]]
    ],
    loadJSON: TurbulenceField.fromJSON
  },
  GravityForce: {
    type: "GravityForce",
    constructor: GravityForce,
    params: [
      ["center", ["vec3"]],
      ["magnitude", ["number"]]
    ],
    loadJSON: GravityForce.fromJSON
  },
  ColorOverLife: {
    type: "ColorOverLife",
    constructor: ColorOverLife,
    params: [["color", ["colorFunc"]]],
    loadJSON: ColorOverLife.fromJSON
  },
  RotationOverLife: {
    type: "RotationOverLife",
    constructor: RotationOverLife,
    params: [["angularVelocity", ["value", "valueFunc"]]],
    loadJSON: RotationOverLife.fromJSON
  },
  Rotation3DOverLife: {
    type: "Rotation3DOverLife",
    constructor: Rotation3DOverLife,
    params: [["angularVelocity", ["rotationFunc"]]],
    loadJSON: Rotation3DOverLife.fromJSON
  },
  SizeOverLife: {
    type: "SizeOverLife",
    constructor: SizeOverLife,
    params: [["size", ["value", "valueFunc", "vec3Func"]]],
    loadJSON: SizeOverLife.fromJSON
  },
  ColorBySpeed: {
    type: "ColorBySpeed",
    constructor: ColorBySpeed,
    params: [
      ["color", ["colorFunc"]],
      ["speedRange", ["range"]]
    ],
    loadJSON: ColorBySpeed.fromJSON
  },
  RotationBySpeed: {
    type: "RotationBySpeed",
    constructor: RotationBySpeed,
    params: [
      ["angularVelocity", ["value", "valueFunc"]],
      ["speedRange", ["range"]]
    ],
    loadJSON: RotationBySpeed.fromJSON
  },
  SizeBySpeed: {
    type: "SizeBySpeed",
    constructor: SizeBySpeed,
    params: [
      ["size", ["value", "valueFunc", "vec3Func"]],
      ["speedRange", ["range"]]
    ],
    loadJSON: SizeBySpeed.fromJSON
  },
  SpeedOverLife: {
    type: "SpeedOverLife",
    constructor: SpeedOverLife,
    params: [["speed", ["value", "valueFunc"]]],
    loadJSON: SpeedOverLife.fromJSON
  },
  FrameOverLife: {
    type: "FrameOverLife",
    constructor: FrameOverLife,
    params: [["frame", ["value", "valueFunc"]]],
    loadJSON: FrameOverLife.fromJSON
  },
  ForceOverLife: {
    type: "ForceOverLife",
    constructor: ForceOverLife,
    params: [
      ["x", ["value", "valueFunc"]],
      ["y", ["value", "valueFunc"]],
      ["z", ["value", "valueFunc"]]
    ],
    loadJSON: ForceOverLife.fromJSON
  },
  OrbitOverLife: {
    type: "OrbitOverLife",
    constructor: OrbitOverLife,
    params: [
      ["orbitSpeed", ["value", "valueFunc"]],
      ["axis", ["vec3"]]
    ],
    loadJSON: OrbitOverLife.fromJSON
  },
  WidthOverLength: {
    type: "WidthOverLength",
    constructor: WidthOverLength,
    params: [["width", ["value", "valueFunc"]]],
    loadJSON: WidthOverLength.fromJSON
  },
  ChangeEmitDirection: {
    type: "ChangeEmitDirection",
    constructor: ChangeEmitDirection,
    params: [["angle", ["value"]]],
    loadJSON: ChangeEmitDirection.fromJSON
  },
  EmitSubParticleSystem: {
    type: "EmitSubParticleSystem",
    constructor: EmitSubParticleSystem,
    params: [
      ["particleSystem", ["self"]],
      ["useVelocityAsBasis", ["boolean"]],
      ["subParticleSystem", ["particleSystem"]],
      ["mode", ["number"]],
      ["emitProbability", ["number"]]
    ],
    loadJSON: EmitSubParticleSystem.fromJSON
  },
  LimitSpeedOverLife: {
    type: "LimitSpeedOverLife",
    constructor: LimitSpeedOverLife,
    params: [
      ["speed", ["value", "valueFunc"]],
      ["dampen", ["number"]]
    ],
    loadJSON: LimitSpeedOverLife.fromJSON
  }
};
function BehaviorFromJSON(json, particleSystem) {
  return BehaviorTypes[json.type].loadJSON(json, particleSystem);
}
var Plugins = [];
function loadPlugin(plugin) {
  const existing = Plugins.find((item) => item.id === plugin.id);
  if (!existing) {
    plugin.initialize();
    for (const emitterShape of plugin.emitterShapes) {
      if (!EmitterShapes[emitterShape.type]) {
        EmitterShapes[emitterShape.type] = emitterShape;
      }
    }
    for (const behavior of plugin.behaviors) {
      if (!BehaviorTypes[behavior.type]) {
        BehaviorTypes[behavior.type] = behavior;
      }
    }
  }
}

// node_modules/three.quarks/dist/three.quarks.esm.js
var soft_fragment = `
#ifdef SOFT_PARTICLES

    /* #ifdef LOGDEPTH
    float distSample = linearize_depth_log(sampleDepth, near, far);
    #else
    float distSample = ortho ? linearize_depth_ortho(sampleDepth, near, far) : linearize_depth(sampleDepth, near, far);
    #endif */

    vec2 p2 = projPosition.xy / projPosition.w;
    
    p2 = 0.5 * p2 + 0.5;

    float readDepth = texture2D(depthTexture, p2.xy).r;
    float viewDepth = linearize_depth(readDepth);

    float softParticlesFade = saturate(SOFT_INV_FADE_DISTANCE * ((viewDepth - SOFT_NEAR_FADE) - linearDepth));
    
    gl_FragColor *= softParticlesFade;

    //gl_FragColor = vec4(softParticlesFade , 0, 0, 1);
#endif
`;
var soft_pars_fragment = `
#ifdef SOFT_PARTICLES

    uniform sampler2D depthTexture;
    uniform vec4 projParams;
    uniform vec2 softParams;

    varying vec4 projPosition;
    varying float linearDepth;

    #define SOFT_NEAR_FADE softParams.x
    #define SOFT_INV_FADE_DISTANCE softParams.y

    #define zNear projParams.x
    #define zFar projParams.y

    float linearize_depth(float d)
    {
        return (zFar * zNear) / (zFar - d * (zFar - zNear));
    }

#endif
`;
var soft_pars_vertex = `
#ifdef SOFT_PARTICLES
    varying vec4 projPosition;
    varying float linearDepth;
#endif
`;
var soft_vertex = `
#ifdef SOFT_PARTICLES
    projPosition = gl_Position;
    linearDepth = -mvPosition.z;
#endif
`;
var tile_fragment = `
#ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv);
    #ifdef TILE_BLEND
        texelColor = mix( texelColor, texture2D( map, vUvNext ), vUvBlend );
    #endif
    diffuseColor *= texelColor;
#endif
`;
var tile_pars_fragment = `
#if defined( USE_UV ) || defined( USE_ANISOTROPY )

	varying vec2 vUv;
#ifdef TILE_BLEND
    varying vec2 vUvNext;
    varying float vUvBlend;
#endif

#endif
#ifdef USE_MAP

	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#ifdef TILE_BLEND
    varying vec2 vMapUvNext;
#endif

#endif
#ifdef USE_ALPHAMAP

	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;

#endif
#ifdef USE_LIGHTMAP

	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;

#endif
#ifdef USE_AOMAP

	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;

#endif
#ifdef USE_BUMPMAP

	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;

#endif
#ifdef USE_NORMALMAP

	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;

#endif
#ifdef USE_DISPLACEMENTMAP

	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;

#endif
#ifdef USE_EMISSIVEMAP

	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;

#endif
#ifdef USE_METALNESSMAP

	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;

#endif
#ifdef USE_ROUGHNESSMAP

	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;

#endif
#ifdef USE_ANISOTROPYMAP

	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;

#endif
#ifdef USE_CLEARCOATMAP

	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;

#endif
#ifdef USE_CLEARCOAT_NORMALMAP

	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;

#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP

	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;

#endif
#ifdef USE_SHEEN_COLORMAP

	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;

#endif
#ifdef USE_SHEEN_ROUGHNESSMAP

	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;

#endif
#ifdef USE_IRIDESCENCEMAP

	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;

#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP

	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;

#endif
#ifdef USE_SPECULARMAP

	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;

#endif
#ifdef USE_SPECULAR_COLORMAP

	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;

#endif
#ifdef USE_SPECULAR_INTENSITYMAP

	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;

#endif
#ifdef USE_TRANSMISSIONMAP

	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;

#endif
#ifdef USE_THICKNESSMAP

	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;

#endif
`;
var tile_pars_vertex = `
#ifdef UV_TILE
    attribute float uvTile;
    uniform vec2 tileCount;
    
    mat3 makeTileTransform(float uvTile) {
        float col = mod(uvTile, tileCount.x);
        float row = (tileCount.y - floor(uvTile / tileCount.x) - 1.0);
        
        return mat3(
          1.0 / tileCount.x, 0.0, 0.0,
          0.0, 1.0 / tileCount.y, 0.0, 
          col / tileCount.x, row / tileCount.y, 1.0);
    }
#else
    mat3 makeTileTransform(float uvTile) {
        return mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);
    }
#endif

#if defined( USE_UV ) || defined( USE_ANISOTROPY )

	varying vec2 vUv;
#ifdef TILE_BLEND
    varying vec2 vUvNext;
    varying float vUvBlend;
#endif

#endif
#ifdef USE_MAP

	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#ifdef TILE_BLEND
    varying vec2 vMapUvNext;
#endif

#endif
#ifdef USE_ALPHAMAP

	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;

#endif
#ifdef USE_LIGHTMAP

	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;

#endif
#ifdef USE_AOMAP

	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;

#endif
#ifdef USE_BUMPMAP

	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;

#endif
#ifdef USE_NORMALMAP

	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;

#endif
#ifdef USE_DISPLACEMENTMAP

	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;

#endif
#ifdef USE_EMISSIVEMAP

	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;

#endif
#ifdef USE_METALNESSMAP

	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;

#endif
#ifdef USE_ROUGHNESSMAP

	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;

#endif
#ifdef USE_ANISOTROPYMAP

	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;

#endif
#ifdef USE_CLEARCOATMAP

	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;

#endif
#ifdef USE_CLEARCOAT_NORMALMAP

	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;

#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP

	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;

#endif
#ifdef USE_SHEEN_COLORMAP

	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;

#endif
#ifdef USE_SHEEN_ROUGHNESSMAP

	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;

#endif
#ifdef USE_IRIDESCENCEMAP

	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;

#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP

	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;

#endif
#ifdef USE_SPECULARMAP

	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;

#endif
#ifdef USE_SPECULAR_COLORMAP

	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;

#endif
#ifdef USE_SPECULAR_INTENSITYMAP

	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;

#endif
#ifdef USE_TRANSMISSIONMAP

	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;

#endif
#ifdef USE_THICKNESSMAP

	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;

#endif
`;
var tile_vertex = `
#ifdef UV_TILE
    mat3 tileTransform = makeTileTransform(floor(uvTile));
    #ifdef TILE_BLEND
        mat3 nextTileTransform = makeTileTransform(ceil(uvTile));
        vUvBlend = fract(uvTile);
    #endif
#else
    mat3 tileTransform = makeTileTransform(0.0);
#endif

#if defined( USE_UV ) || defined( USE_ANISOTROPY )

vUv = (tileTransform *vec3( uv, 1 )).xy;
#if defined( TILE_BLEND ) && defined( UV_TILE )
    vUvNext = (nextTileTransform *vec3( uv, 1 )).xy;
#endif

#endif
#ifdef USE_MAP

vMapUv = ( tileTransform * (mapTransform * vec3( MAP_UV, 1 ) )).xy;
#if defined( TILE_BLEND ) && defined( UV_TILE )
    vMapUvNext = (nextTileTransform * (mapTransform * vec3( MAP_UV, 1 ))).xy;
#endif

#endif
#ifdef USE_ALPHAMAP

vAlphaMapUv = ( tileTransform * (alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) )).xy;
    
#endif
#ifdef USE_LIGHTMAP

vLightMapUv = ( tileTransform * (lightMapTransform * vec3( LIGHTMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_AOMAP

vAoMapUv = ( tileTransform * (aoMapTransform * vec3( AOMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_BUMPMAP

vBumpMapUv = ( tileTransform * (bumpMapTransform * vec3( BUMPMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_NORMALMAP

vNormalMapUv = ( tileTransform * (normalMapTransform * vec3( NORMALMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_DISPLACEMENTMAP

vDisplacementMapUv = ( tileTransform * (displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_EMISSIVEMAP

vEmissiveMapUv = ( tileTransform * (emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_METALNESSMAP

vMetalnessMapUv = ( tileTransform * (metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_ROUGHNESSMAP

vRoughnessMapUv = ( tileTransform * (roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_ANISOTROPYMAP

vAnisotropyMapUv = ( tileTransform * (anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_CLEARCOATMAP

vClearcoatMapUv = ( tileTransform * (clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_CLEARCOAT_NORMALMAP

vClearcoatNormalMapUv = ( tileTransform * (clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP

vClearcoatRoughnessMapUv = ( tileTransform * (clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_IRIDESCENCEMAP

vIridescenceMapUv = ( tileTransform * (iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP

vIridescenceThicknessMapUv = ( tileTransform * (iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_SHEEN_COLORMAP

vSheenColorMapUv = ( tileTransform * (sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_SHEEN_ROUGHNESSMAP

vSheenRoughnessMapUv = ( tileTransform * (sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_SPECULARMAP

vSpecularMapUv = ( tileTransform * (specularMapTransform * vec3( SPECULARMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_SPECULAR_COLORMAP

vSpecularColorMapUv = ( tileTransform * (specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_SPECULAR_INTENSITYMAP

vSpecularIntensityMapUv = ( tileTransform * (specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_TRANSMISSIONMAP

vTransmissionMapUv = ( tileTransform * transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_THICKNESSMAP

vThicknessMapUv = ( tileTransform * thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) )).xy;

#endif

`;
var ShaderChunk2 = ShaderChunk;
function registerShaderChunks() {
  ShaderChunk2["tile_pars_vertex"] = tile_pars_vertex;
  ShaderChunk2["tile_vertex"] = tile_vertex;
  ShaderChunk2["tile_pars_fragment"] = tile_pars_fragment;
  ShaderChunk2["tile_fragment"] = tile_fragment;
  ShaderChunk2["soft_pars_vertex"] = soft_pars_vertex;
  ShaderChunk2["soft_vertex"] = soft_vertex;
  ShaderChunk2["soft_pars_fragment"] = soft_pars_fragment;
  ShaderChunk2["soft_fragment"] = soft_fragment;
}
var ParticleEmitter = class extends Object3D {
  constructor(system) {
    super();
    this.type = "ParticleEmitter";
    this.system = system;
  }
  clone() {
    const system = this.system.clone();
    system.emitter.copy(this, true);
    return system.emitter;
  }
  dispose() {
  }
  extractFromCache(cache) {
    const values = [];
    for (const key in cache) {
      const data = cache[key];
      delete data.metadata;
      values.push(data);
    }
    return values;
  }
  toJSON(meta, options = {}) {
    const children = this.children;
    this.children = this.children.filter((child) => child.type !== "ParticleSystemPreview");
    const data = super.toJSON(meta);
    this.children = children;
    if (this.system !== null)
      data.object.ps = this.system.toJSON(meta, options);
    return data;
  }
};
var RenderMode2;
(function(RenderMode3) {
  RenderMode3[RenderMode3["BillBoard"] = 0] = "BillBoard";
  RenderMode3[RenderMode3["StretchedBillBoard"] = 1] = "StretchedBillBoard";
  RenderMode3[RenderMode3["Mesh"] = 2] = "Mesh";
  RenderMode3[RenderMode3["Trail"] = 3] = "Trail";
  RenderMode3[RenderMode3["HorizontalBillBoard"] = 4] = "HorizontalBillBoard";
  RenderMode3[RenderMode3["VerticalBillBoard"] = 5] = "VerticalBillBoard";
})(RenderMode2 || (RenderMode2 = {}));
var VFXBatch = class extends Mesh {
  constructor(settings) {
    super();
    this.type = "VFXBatch";
    this.maxParticles = 1e3;
    this.systems = /* @__PURE__ */ new Set();
    const layers = new Layers();
    layers.mask = settings.layers.mask;
    const newMat = settings.material.clone();
    newMat.defines = {};
    Object.assign(newMat.defines, settings.material.defines);
    this.settings = {
      instancingGeometry: settings.instancingGeometry,
      renderMode: settings.renderMode,
      renderOrder: settings.renderOrder,
      material: newMat,
      uTileCount: settings.uTileCount,
      vTileCount: settings.vTileCount,
      blendTiles: settings.blendTiles,
      softParticles: settings.softParticles,
      softNearFade: settings.softNearFade,
      softFarFade: settings.softFarFade,
      layers
    };
    this.frustumCulled = false;
    this.renderOrder = this.settings.renderOrder;
  }
  addSystem(system) {
    this.systems.add(system);
  }
  removeSystem(system) {
    this.systems.delete(system);
  }
  applyDepthTexture(depthTexture) {
    const uniform = this.material.uniforms["depthTexture"];
    if (uniform) {
      if (uniform.value !== depthTexture) {
        uniform.value = depthTexture;
        this.material.needsUpdate = true;
      }
    }
  }
};
var UP = new Vector33(0, 0, 1);
var tempQ2 = new Quaternion2();
var tempV2 = new Vector33();
var tempV22 = new Vector33();
new Vector33();
var PREWARM_FPS = 60;
var DEFAULT_GEOMETRY = new PlaneGeometry(1, 1, 1, 1);
var ParticleSystem = class {
  set time(time) {
    this.emissionState.time = time;
  }
  get time() {
    return this.emissionState.time;
  }
  get layers() {
    return this.rendererSettings.layers;
  }
  get texture() {
    return this.rendererSettings.material.map;
  }
  set texture(texture) {
    this.rendererSettings.material.map = texture;
    this.neededToUpdateRender = true;
  }
  get material() {
    return this.rendererSettings.material;
  }
  set material(material) {
    this.rendererSettings.material = material;
    this.neededToUpdateRender = true;
  }
  get uTileCount() {
    return this.rendererSettings.uTileCount;
  }
  set uTileCount(u2) {
    this.rendererSettings.uTileCount = u2;
    this.neededToUpdateRender = true;
  }
  get vTileCount() {
    return this.rendererSettings.vTileCount;
  }
  set vTileCount(v4) {
    this.rendererSettings.vTileCount = v4;
    this.neededToUpdateRender = true;
  }
  get blendTiles() {
    return this.rendererSettings.blendTiles;
  }
  set blendTiles(v4) {
    this.rendererSettings.blendTiles = v4;
    this.neededToUpdateRender = true;
  }
  get softParticles() {
    return this.rendererSettings.softParticles;
  }
  set softParticles(v4) {
    this.rendererSettings.softParticles = v4;
    this.neededToUpdateRender = true;
  }
  get softNearFade() {
    return this.rendererSettings.softNearFade;
  }
  set softNearFade(v4) {
    this.rendererSettings.softNearFade = v4;
    this.neededToUpdateRender = true;
  }
  get softFarFade() {
    return this.rendererSettings.softFarFade;
  }
  set softFarFade(v4) {
    this.rendererSettings.softFarFade = v4;
    this.neededToUpdateRender = true;
  }
  get instancingGeometry() {
    return this.rendererSettings.instancingGeometry;
  }
  set instancingGeometry(geometry) {
    this.restart();
    this.particles.length = 0;
    this.rendererSettings.instancingGeometry = geometry;
    this.neededToUpdateRender = true;
  }
  get renderMode() {
    return this.rendererSettings.renderMode;
  }
  set renderMode(renderMode) {
    if (this.rendererSettings.renderMode != RenderMode2.Trail && renderMode === RenderMode2.Trail || this.rendererSettings.renderMode == RenderMode2.Trail && renderMode !== RenderMode2.Trail) {
      this.restart();
      this.particles.length = 0;
    }
    if (this.rendererSettings.renderMode !== renderMode) {
      switch (renderMode) {
        case RenderMode2.Trail:
          this.rendererEmitterSettings = {
            startLength: new ConstantValue(30),
            followLocalOrigin: false
          };
          break;
        case RenderMode2.Mesh:
          this.rendererEmitterSettings = {
            geometry: new PlaneGeometry(1, 1)
          };
          this.startRotation = new AxisAngleGenerator(new Vector33(0, 1, 0), new ConstantValue(0));
          break;
        case RenderMode2.StretchedBillBoard:
          this.rendererEmitterSettings = { speedFactor: 0, lengthFactor: 2 };
          if (this.rendererSettings.renderMode === RenderMode2.Mesh) {
            this.startRotation = new ConstantValue(0);
          }
          break;
        case RenderMode2.BillBoard:
        case RenderMode2.VerticalBillBoard:
        case RenderMode2.HorizontalBillBoard:
          this.rendererEmitterSettings = {};
          if (this.rendererSettings.renderMode === RenderMode2.Mesh) {
            this.startRotation = new ConstantValue(0);
          }
          break;
      }
    }
    this.rendererSettings.renderMode = renderMode;
    this.neededToUpdateRender = true;
  }
  get renderOrder() {
    return this.rendererSettings.renderOrder;
  }
  set renderOrder(renderOrder) {
    this.rendererSettings.renderOrder = renderOrder;
    this.neededToUpdateRender = true;
  }
  get blending() {
    return this.rendererSettings.material.blending;
  }
  set blending(blending) {
    this.rendererSettings.material.blending = blending;
    this.neededToUpdateRender = true;
  }
  constructor(parameters) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p2, _q2, _r, _s, _t, _u, _v4, _w, _x2, _y2, _z2, _0, _1;
    this.temp = new Vector33();
    this.travelDistance = 0;
    this.normalMatrix = new Matrix32();
    this.memory = [];
    this.listeners = {};
    this.firstTimeUpdate = true;
    this.autoDestroy = parameters.autoDestroy === void 0 ? false : parameters.autoDestroy;
    this.duration = (_a2 = parameters.duration) !== null && _a2 !== void 0 ? _a2 : 1;
    this.looping = parameters.looping === void 0 ? true : parameters.looping;
    this.prewarm = parameters.prewarm === void 0 ? false : parameters.prewarm;
    this.startLife = (_b = parameters.startLife) !== null && _b !== void 0 ? _b : new ConstantValue(5);
    this.startSpeed = (_c = parameters.startSpeed) !== null && _c !== void 0 ? _c : new ConstantValue(0);
    this.startRotation = (_d = parameters.startRotation) !== null && _d !== void 0 ? _d : new ConstantValue(0);
    this.startSize = (_e = parameters.startSize) !== null && _e !== void 0 ? _e : new ConstantValue(1);
    this.startColor = (_f = parameters.startColor) !== null && _f !== void 0 ? _f : new ConstantColor(new Vector42(1, 1, 1, 1));
    this.emissionOverTime = (_g = parameters.emissionOverTime) !== null && _g !== void 0 ? _g : new ConstantValue(10);
    this.emissionOverDistance = (_h = parameters.emissionOverDistance) !== null && _h !== void 0 ? _h : new ConstantValue(0);
    this.emissionBursts = (_j = parameters.emissionBursts) !== null && _j !== void 0 ? _j : [];
    this.onlyUsedByOther = (_k = parameters.onlyUsedByOther) !== null && _k !== void 0 ? _k : false;
    this.emitterShape = (_l = parameters.shape) !== null && _l !== void 0 ? _l : new SphereEmitter();
    this.behaviors = (_m = parameters.behaviors) !== null && _m !== void 0 ? _m : new Array();
    this.worldSpace = (_o = parameters.worldSpace) !== null && _o !== void 0 ? _o : false;
    this.rendererEmitterSettings = (_p2 = parameters.rendererEmitterSettings) !== null && _p2 !== void 0 ? _p2 : {};
    if (parameters.renderMode === RenderMode2.StretchedBillBoard) {
      const stretchedBillboardSettings = this.rendererEmitterSettings;
      if (parameters.speedFactor !== void 0) {
        stretchedBillboardSettings.speedFactor = parameters.speedFactor;
      }
      stretchedBillboardSettings.speedFactor = (_q2 = stretchedBillboardSettings.speedFactor) !== null && _q2 !== void 0 ? _q2 : 0;
      stretchedBillboardSettings.lengthFactor = (_r = stretchedBillboardSettings.lengthFactor) !== null && _r !== void 0 ? _r : 0;
    }
    this.rendererSettings = {
      instancingGeometry: (_s = parameters.instancingGeometry) !== null && _s !== void 0 ? _s : DEFAULT_GEOMETRY,
      renderMode: (_t = parameters.renderMode) !== null && _t !== void 0 ? _t : RenderMode2.BillBoard,
      renderOrder: (_u = parameters.renderOrder) !== null && _u !== void 0 ? _u : 0,
      material: parameters.material,
      uTileCount: (_v4 = parameters.uTileCount) !== null && _v4 !== void 0 ? _v4 : 1,
      vTileCount: (_w = parameters.vTileCount) !== null && _w !== void 0 ? _w : 1,
      blendTiles: (_x2 = parameters.blendTiles) !== null && _x2 !== void 0 ? _x2 : false,
      softParticles: (_y2 = parameters.softParticles) !== null && _y2 !== void 0 ? _y2 : false,
      softNearFade: (_z2 = parameters.softNearFade) !== null && _z2 !== void 0 ? _z2 : 0,
      softFarFade: (_0 = parameters.softFarFade) !== null && _0 !== void 0 ? _0 : 0,
      layers: (_1 = parameters.layers) !== null && _1 !== void 0 ? _1 : new Layers()
    };
    this.neededToUpdateRender = true;
    this.particles = new Array();
    this.startTileIndex = parameters.startTileIndex || new ConstantValue(0);
    this.emitter = new ParticleEmitter(this);
    this.paused = false;
    this.particleNum = 0;
    this.emissionState = {
      isBursting: false,
      burstParticleIndex: 0,
      burstParticleCount: 0,
      burstIndex: 0,
      burstWaveIndex: 0,
      time: 0,
      waitEmiting: 0,
      travelDistance: 0
    };
    this.emissionBursts.forEach((burst) => burst.count.startGen(this.memory));
    this.emissionOverDistance.startGen(this.memory);
    this.emitEnded = false;
    this.markForDestroy = false;
    this.prewarmed = false;
  }
  pause() {
    this.paused = true;
  }
  play() {
    this.paused = false;
  }
  stop() {
    this.restart();
    this.pause();
  }
  spawn(count, emissionState, matrix) {
    tempQ2.setFromRotationMatrix(matrix);
    const translation = tempV2;
    const quaternion = tempQ2;
    const scale = tempV22;
    matrix.decompose(translation, quaternion, scale);
    for (let i = 0; i < count; i++) {
      emissionState.burstParticleIndex = i;
      this.particleNum++;
      while (this.particles.length < this.particleNum) {
        if (this.rendererSettings.renderMode === RenderMode2.Trail) {
          this.particles.push(new TrailParticle());
        } else {
          this.particles.push(new SpriteParticle());
        }
      }
      const particle = this.particles[this.particleNum - 1];
      particle.reset();
      particle.speedModifier = 1;
      this.startColor.startGen(particle.memory);
      this.startColor.genColor(particle.memory, particle.startColor, this.emissionState.time);
      particle.color.copy(particle.startColor);
      this.startSpeed.startGen(particle.memory);
      particle.startSpeed = this.startSpeed.genValue(particle.memory, emissionState.time / this.duration);
      this.startLife.startGen(particle.memory);
      particle.life = this.startLife.genValue(particle.memory, emissionState.time / this.duration);
      particle.age = 0;
      this.startSize.startGen(particle.memory);
      if (this.startSize.type === "vec3function") {
        this.startSize.genValue(particle.memory, particle.startSize, emissionState.time / this.duration);
      } else {
        const size = this.startSize.genValue(particle.memory, emissionState.time / this.duration);
        particle.startSize.set(size, size, size);
      }
      this.startTileIndex.startGen(particle.memory);
      particle.uvTile = this.startTileIndex.genValue(particle.memory);
      particle.size.copy(particle.startSize);
      if (this.rendererSettings.renderMode === RenderMode2.Mesh || this.rendererSettings.renderMode === RenderMode2.BillBoard || this.rendererSettings.renderMode === RenderMode2.VerticalBillBoard || this.rendererSettings.renderMode === RenderMode2.HorizontalBillBoard || this.rendererSettings.renderMode === RenderMode2.StretchedBillBoard) {
        const sprite = particle;
        this.startRotation.startGen(particle.memory);
        if (this.rendererSettings.renderMode === RenderMode2.Mesh) {
          if (!(sprite.rotation instanceof Quaternion2)) {
            sprite.rotation = new Quaternion2();
          }
          if (this.startRotation.type === "rotation") {
            this.startRotation.genValue(particle.memory, sprite.rotation, 1, emissionState.time / this.duration);
          } else {
            sprite.rotation.setFromAxisAngle(UP, this.startRotation.genValue(sprite.memory, emissionState.time / this.duration));
          }
        } else {
          if (this.startRotation.type === "rotation") {
            sprite.rotation = 0;
          } else {
            sprite.rotation = this.startRotation.genValue(sprite.memory, emissionState.time / this.duration);
          }
        }
      } else if (this.rendererSettings.renderMode === RenderMode2.Trail) {
        const trail = particle;
        this.rendererEmitterSettings.startLength.startGen(trail.memory);
        trail.length = this.rendererEmitterSettings.startLength.genValue(trail.memory, emissionState.time / this.duration);
      }
      this.emitterShape.initialize(particle, emissionState);
      if (this.rendererSettings.renderMode === RenderMode2.Trail && this.rendererEmitterSettings.followLocalOrigin) {
        const trail = particle;
        trail.localPosition = new Vector33().copy(trail.position);
      }
      if (this.worldSpace) {
        particle.position.applyMatrix4(matrix);
        particle.startSize.multiply(scale).abs();
        particle.size.copy(particle.startSize);
        particle.velocity.multiply(scale).applyMatrix3(this.normalMatrix);
        if (particle.rotation && particle.rotation instanceof Quaternion2) {
          particle.rotation.multiplyQuaternions(tempQ2, particle.rotation);
        }
      } else {
        if (this.onlyUsedByOther) {
          particle.parentMatrix = matrix;
        }
      }
      for (let j = 0; j < this.behaviors.length; j++) {
        this.behaviors[j].initialize(particle, this);
      }
    }
  }
  endEmit() {
    this.emitEnded = true;
    if (this.autoDestroy) {
      this.markForDestroy = true;
    }
    this.fire({ type: "emitEnd", particleSystem: this });
  }
  dispose() {
    if (this._renderer)
      this._renderer.deleteSystem(this);
    this.emitter.dispose();
    if (this.emitter.parent)
      this.emitter.parent.remove(this.emitter);
    this.fire({ type: "destroy", particleSystem: this });
  }
  restart() {
    this.memory.length = 0;
    this.paused = false;
    this.particleNum = 0;
    this.emissionState.isBursting = false;
    this.emissionState.burstIndex = 0;
    this.emissionState.burstWaveIndex = 0;
    this.emissionState.time = 0;
    this.emissionState.waitEmiting = 0;
    this.behaviors.forEach((behavior) => {
      behavior.reset();
    });
    this.emitEnded = false;
    this.markForDestroy = false;
    this.prewarmed = false;
    this.emissionBursts.forEach((burst) => burst.count.startGen(this.memory));
    this.emissionOverDistance.startGen(this.memory);
  }
  update(delta) {
    if (this.paused)
      return;
    let currentParent = this.emitter;
    while (currentParent.parent) {
      currentParent = currentParent.parent;
    }
    if (currentParent.type !== "Scene") {
      this.dispose();
      return;
    }
    if (this.firstTimeUpdate) {
      this.firstTimeUpdate = false;
      this.emitter.updateWorldMatrix(true, false);
    }
    if (this.emitEnded && this.particleNum === 0) {
      if (this.markForDestroy && this.emitter.parent)
        this.dispose();
      return;
    }
    if (this.looping && this.prewarm && !this.prewarmed) {
      this.prewarmed = true;
      for (let i = 0; i < this.duration * PREWARM_FPS; i++) {
        this.update(1 / PREWARM_FPS);
      }
    }
    if (delta > 0.1) {
      delta = 0.1;
    }
    if (this.neededToUpdateRender) {
      if (this._renderer)
        this._renderer.updateSystem(this);
      this.neededToUpdateRender = false;
    }
    if (!this.onlyUsedByOther) {
      this.emit(delta, this.emissionState, this.emitter.matrixWorld);
    }
    this.emitterShape.update(this, delta);
    for (let j = 0; j < this.behaviors.length; j++) {
      this.behaviors[j].frameUpdate(delta);
      for (let i = 0; i < this.particleNum; i++) {
        if (!this.particles[i].died) {
          this.behaviors[j].update(this.particles[i], delta);
        }
      }
    }
    for (let i = 0; i < this.particleNum; i++) {
      if (this.rendererEmitterSettings.followLocalOrigin && this.particles[i].localPosition) {
        this.particles[i].position.copy(this.particles[i].localPosition);
        if (this.particles[i].parentMatrix) {
          this.particles[i].position.applyMatrix4(this.particles[i].parentMatrix);
        } else {
          this.particles[i].position.applyMatrix4(this.emitter.matrixWorld);
        }
      } else {
        this.particles[i].position.addScaledVector(this.particles[i].velocity, delta * this.particles[i].speedModifier);
      }
      this.particles[i].age += delta;
    }
    if (this.rendererSettings.renderMode === RenderMode2.Trail) {
      for (let i = 0; i < this.particleNum; i++) {
        const particle = this.particles[i];
        particle.update();
      }
    }
    for (let i = 0; i < this.particleNum; i++) {
      const particle = this.particles[i];
      if (particle.died && (!(particle instanceof TrailParticle) || particle.previous.length === 0)) {
        this.particles[i] = this.particles[this.particleNum - 1];
        this.particles[this.particleNum - 1] = particle;
        this.particleNum--;
        i--;
        this.fire({ type: "particleDied", particleSystem: this, particle });
      }
    }
  }
  emit(delta, emissionState, emitterMatrix) {
    if (emissionState.time > this.duration) {
      if (this.looping) {
        emissionState.time -= this.duration;
        emissionState.burstIndex = 0;
        this.behaviors.forEach((behavior) => {
          behavior.reset();
        });
      } else {
        if (!this.emitEnded && !this.onlyUsedByOther) {
          this.endEmit();
        }
      }
    }
    this.normalMatrix.getNormalMatrix(emitterMatrix);
    const totalSpawn = Math.ceil(emissionState.waitEmiting);
    this.spawn(totalSpawn, emissionState, emitterMatrix);
    emissionState.waitEmiting -= totalSpawn;
    while (emissionState.burstIndex < this.emissionBursts.length && this.emissionBursts[emissionState.burstIndex].time <= emissionState.time) {
      if (Math.random() < this.emissionBursts[emissionState.burstIndex].probability) {
        const count = this.emissionBursts[emissionState.burstIndex].count.genValue(this.memory, this.time);
        emissionState.isBursting = true;
        emissionState.burstParticleCount = count;
        this.spawn(count, emissionState, emitterMatrix);
        emissionState.isBursting = false;
      }
      emissionState.burstIndex++;
    }
    if (!this.emitEnded) {
      emissionState.waitEmiting += delta * this.emissionOverTime.genValue(this.memory, emissionState.time / this.duration);
      if (emissionState.previousWorldPos != void 0) {
        this.temp.set(emitterMatrix.elements[12], emitterMatrix.elements[13], emitterMatrix.elements[14]);
        emissionState.travelDistance += emissionState.previousWorldPos.distanceTo(this.temp);
        const emitPerMeter = this.emissionOverDistance.genValue(this.memory, emissionState.time / this.duration);
        if (emissionState.travelDistance * emitPerMeter > 0) {
          const count = Math.floor(emissionState.travelDistance * emitPerMeter);
          emissionState.travelDistance -= count / emitPerMeter;
          emissionState.waitEmiting += count;
        }
      }
    }
    if (emissionState.previousWorldPos === void 0)
      emissionState.previousWorldPos = new Vector33();
    emissionState.previousWorldPos.set(emitterMatrix.elements[12], emitterMatrix.elements[13], emitterMatrix.elements[14]);
    emissionState.time += delta;
  }
  toJSON(meta, options = {}) {
    var _a2;
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (isRootObject) {
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {}
      };
    }
    meta.materials[this.rendererSettings.material.uuid] = this.rendererSettings.material.toJSON(meta);
    if (options.useUrlForImage) {
      if (((_a2 = this.texture) === null || _a2 === void 0 ? void 0 : _a2.source) !== void 0) {
        const image = this.texture.source;
        meta.images[image.uuid] = {
          uuid: image.uuid,
          url: this.texture.image.url
        };
      }
    }
    let rendererSettingsJSON;
    if (this.renderMode === RenderMode2.Trail) {
      rendererSettingsJSON = {
        startLength: this.rendererEmitterSettings.startLength.toJSON(),
        followLocalOrigin: this.rendererEmitterSettings.followLocalOrigin
      };
    } else if (this.renderMode === RenderMode2.Mesh) {
      rendererSettingsJSON = {};
    } else if (this.renderMode === RenderMode2.StretchedBillBoard) {
      rendererSettingsJSON = {
        speedFactor: this.rendererEmitterSettings.speedFactor,
        lengthFactor: this.rendererEmitterSettings.lengthFactor
      };
    } else {
      rendererSettingsJSON = {};
    }
    const geometry = this.rendererSettings.instancingGeometry;
    if (meta.geometries && !meta.geometries[geometry.uuid]) {
      meta.geometries[geometry.uuid] = geometry.toJSON();
    }
    return {
      version: "3.0",
      autoDestroy: this.autoDestroy,
      looping: this.looping,
      prewarm: this.prewarm,
      duration: this.duration,
      shape: this.emitterShape.toJSON(),
      startLife: this.startLife.toJSON(),
      startSpeed: this.startSpeed.toJSON(),
      startRotation: this.startRotation.toJSON(),
      startSize: this.startSize.toJSON(),
      startColor: this.startColor.toJSON(),
      emissionOverTime: this.emissionOverTime.toJSON(),
      emissionOverDistance: this.emissionOverDistance.toJSON(),
      emissionBursts: this.emissionBursts.map((burst) => ({
        time: burst.time,
        count: burst.count.toJSON(),
        probability: burst.probability,
        interval: burst.interval,
        cycle: burst.cycle
      })),
      onlyUsedByOther: this.onlyUsedByOther,
      instancingGeometry: this.rendererSettings.instancingGeometry.uuid,
      renderOrder: this.renderOrder,
      renderMode: this.renderMode,
      rendererEmitterSettings: rendererSettingsJSON,
      material: this.rendererSettings.material.uuid,
      layers: this.layers.mask,
      startTileIndex: this.startTileIndex.toJSON(),
      uTileCount: this.uTileCount,
      vTileCount: this.vTileCount,
      blendTiles: this.blendTiles,
      softParticles: this.rendererSettings.softParticles,
      softFarFade: this.rendererSettings.softFarFade,
      softNearFade: this.rendererSettings.softNearFade,
      behaviors: this.behaviors.map((behavior) => behavior.toJSON()),
      worldSpace: this.worldSpace
    };
  }
  static fromJSON(json, meta, dependencies) {
    var _a2, _b;
    const shape = EmitterFromJSON(json.shape, meta);
    let rendererEmitterSettings;
    if (json.renderMode === RenderMode2.Trail) {
      const trailSettings = json.rendererEmitterSettings;
      rendererEmitterSettings = {
        startLength: trailSettings.startLength != void 0 ? ValueGeneratorFromJSON(trailSettings.startLength) : new ConstantValue(30),
        followLocalOrigin: trailSettings.followLocalOrigin
      };
    } else if (json.renderMode === RenderMode2.Mesh) {
      rendererEmitterSettings = {};
    } else if (json.renderMode === RenderMode2.StretchedBillBoard) {
      rendererEmitterSettings = json.rendererEmitterSettings;
      if (json.speedFactor != void 0) {
        rendererEmitterSettings.speedFactor = json.speedFactor;
      }
    } else {
      rendererEmitterSettings = {};
    }
    const layers = new Layers();
    if (json.layers) {
      layers.mask = json.layers;
    }
    const ps = new ParticleSystem({
      autoDestroy: json.autoDestroy,
      looping: json.looping,
      prewarm: json.prewarm,
      duration: json.duration,
      shape,
      startLife: ValueGeneratorFromJSON(json.startLife),
      startSpeed: ValueGeneratorFromJSON(json.startSpeed),
      startRotation: GeneratorFromJSON(json.startRotation),
      startSize: GeneratorFromJSON(json.startSize),
      startColor: ColorGeneratorFromJSON(json.startColor),
      emissionOverTime: ValueGeneratorFromJSON(json.emissionOverTime),
      emissionOverDistance: ValueGeneratorFromJSON(json.emissionOverDistance),
      emissionBursts: (_a2 = json.emissionBursts) === null || _a2 === void 0 ? void 0 : _a2.map((burst) => {
        var _a3, _b2, _c;
        return {
          time: burst.time,
          count: typeof burst.count === "number" ? new ConstantValue(burst.count) : ValueGeneratorFromJSON(burst.count),
          probability: (_a3 = burst.probability) !== null && _a3 !== void 0 ? _a3 : 1,
          interval: (_b2 = burst.interval) !== null && _b2 !== void 0 ? _b2 : 0.1,
          cycle: (_c = burst.cycle) !== null && _c !== void 0 ? _c : 1
        };
      }),
      onlyUsedByOther: json.onlyUsedByOther,
      instancingGeometry: meta.geometries[json.instancingGeometry],
      renderMode: json.renderMode,
      rendererEmitterSettings,
      renderOrder: json.renderOrder,
      layers,
      material: json.material ? meta.materials[json.material] : json.texture ? new MeshBasicMaterial({
        map: meta.textures[json.texture],
        transparent: (_b = json.transparent) !== null && _b !== void 0 ? _b : true,
        blending: json.blending,
        side: DoubleSide
      }) : new MeshBasicMaterial({
        color: 16777215,
        transparent: true,
        blending: AdditiveBlending,
        side: DoubleSide
      }),
      startTileIndex: typeof json.startTileIndex === "number" ? new ConstantValue(json.startTileIndex) : ValueGeneratorFromJSON(json.startTileIndex),
      uTileCount: json.uTileCount,
      vTileCount: json.vTileCount,
      blendTiles: json.blendTiles,
      softParticles: json.softParticles,
      softFarFade: json.softFarFade,
      softNearFade: json.softNearFade,
      behaviors: [],
      worldSpace: json.worldSpace
    });
    ps.behaviors = json.behaviors.map((behaviorJson) => {
      const behavior = BehaviorFromJSON(behaviorJson, ps);
      if (behavior.type === "EmitSubParticleSystem") {
        dependencies[behaviorJson.subParticleSystem] = behavior;
      }
      return behavior;
    });
    return ps;
  }
  addBehavior(behavior) {
    this.behaviors.push(behavior);
  }
  getRendererSettings() {
    return this.rendererSettings;
  }
  addEventListener(event, callback) {
    if (!this.listeners[event])
      this.listeners[event] = [];
    this.listeners[event].push(callback);
  }
  removeAllEventListeners(event) {
    if (this.listeners[event])
      this.listeners[event] = [];
  }
  removeEventListener(event, callback) {
    if (this.listeners[event]) {
      const index = this.listeners[event].indexOf(callback);
      if (index !== -1) {
        this.listeners[event].splice(index, 1);
      }
    }
  }
  fire(event) {
    if (this.listeners[event.type]) {
      this.listeners[event.type].forEach((callback) => callback(event));
    }
  }
  clone() {
    const newEmissionBursts = [];
    for (const emissionBurst of this.emissionBursts) {
      const newEmissionBurst = {};
      Object.assign(newEmissionBurst, emissionBurst);
      newEmissionBursts.push(newEmissionBurst);
    }
    const newBehaviors = [];
    for (const behavior of this.behaviors) {
      newBehaviors.push(behavior.clone());
    }
    let rendererEmitterSettings;
    if (this.renderMode === RenderMode2.Trail) {
      rendererEmitterSettings = {
        startLength: this.rendererEmitterSettings.startLength.clone(),
        followLocalOrigin: this.rendererEmitterSettings.followLocalOrigin
      };
    } else if (this.renderMode === RenderMode2.StretchedBillBoard) {
      rendererEmitterSettings = {
        lengthFactor: this.rendererEmitterSettings.lengthFactor,
        speedFactor: this.rendererEmitterSettings.speedFactor
      };
    } else {
      rendererEmitterSettings = {};
    }
    const layers = new Layers();
    layers.mask = this.layers.mask;
    return new ParticleSystem({
      autoDestroy: this.autoDestroy,
      looping: this.looping,
      duration: this.duration,
      shape: this.emitterShape.clone(),
      startLife: this.startLife.clone(),
      startSpeed: this.startSpeed.clone(),
      startRotation: this.startRotation.clone(),
      startSize: this.startSize.clone(),
      startColor: this.startColor.clone(),
      emissionOverTime: this.emissionOverTime.clone(),
      emissionOverDistance: this.emissionOverDistance.clone(),
      emissionBursts: newEmissionBursts,
      onlyUsedByOther: this.onlyUsedByOther,
      instancingGeometry: this.rendererSettings.instancingGeometry,
      renderMode: this.renderMode,
      renderOrder: this.renderOrder,
      rendererEmitterSettings,
      material: this.rendererSettings.material,
      startTileIndex: this.startTileIndex,
      uTileCount: this.uTileCount,
      vTileCount: this.vTileCount,
      blendTiles: this.blendTiles,
      softParticles: this.softParticles,
      softFarFade: this.softFarFade,
      softNearFade: this.softNearFade,
      behaviors: newBehaviors,
      worldSpace: this.worldSpace,
      layers
    });
  }
};
var particle_frag = `

#include <common>
#include <color_pars_fragment>
#include <map_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
#include <alphatest_pars_fragment>

#include <tile_pars_fragment>
#include <soft_pars_fragment>

void main() {

    #include <clipping_planes_fragment>
    
    vec3 outgoingLight = vec3( 0.0 );
    vec4 diffuseColor = vColor;
    
    #include <logdepthbuf_fragment>
    
    #include <tile_fragment>
    #include <alphatest_fragment>

    outgoingLight = diffuseColor.rgb;
    
    #ifdef USE_COLOR_AS_ALPHA
    gl_FragColor = vec4( outgoingLight, diffuseColor.r );
    #else
    gl_FragColor = vec4( outgoingLight, diffuseColor.a );
    #endif
    
    #include <soft_fragment>
    #include <tonemapping_fragment>
}
`;
var particle_physics_frag = `
#define STANDARD

#ifdef PHYSICAL
#define IOR
#define USE_SPECULAR
#endif

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;

#ifdef IOR
uniform float ior;
#endif

#ifdef USE_SPECULAR
uniform float specularIntensity;
uniform vec3 specularColor;

#ifdef USE_SPECULAR_COLORMAP
uniform sampler2D specularColorMap;
#endif

#ifdef USE_SPECULAR_INTENSITYMAP
uniform sampler2D specularIntensityMap;
#endif
#endif

#ifdef USE_CLEARCOAT
uniform float clearcoat;
uniform float clearcoatRoughness;
#endif

#ifdef USE_DISPERSION
uniform float dispersion;
#endif

#ifdef USE_IRIDESCENCE
uniform float iridescence;
uniform float iridescenceIOR;
uniform float iridescenceThicknessMinimum;
uniform float iridescenceThicknessMaximum;
#endif

#ifdef USE_SHEEN
uniform vec3 sheenColor;
uniform float sheenRoughness;

#ifdef USE_SHEEN_COLORMAP
uniform sampler2D sheenColorMap;
#endif

#ifdef USE_SHEEN_ROUGHNESSMAP
uniform sampler2D sheenRoughnessMap;
#endif
#endif

#ifdef USE_ANISOTROPY
uniform vec2 anisotropyVector;

#ifdef USE_ANISOTROPYMAP
uniform sampler2D anisotropyMap;
#endif
#endif

varying vec3 vViewPosition;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

vec4 diffuseColor = vec4( diffuse, opacity );
#include <clipping_planes_fragment>

ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
vec3 totalEmissiveRadiance = emissive;

#include <logdepthbuf_fragment>
#include <map_fragment>
#include <color_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
#include <alphahash_fragment>
#include <roughnessmap_fragment>
#include <metalnessmap_fragment>
#include <normal_fragment_begin>
#include <normal_fragment_maps>
#include <clearcoat_normal_fragment_begin>
#include <clearcoat_normal_fragment_maps>
#include <emissivemap_fragment>

// accumulation
#include <lights_physical_fragment>
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>

// modulation
#include <aomap_fragment>

vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;

#include <transmission_fragment>

vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;

#ifdef USE_SHEEN

// Sheen energy compensation approximation calculation can be found at the end of
// https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing
float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );

outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;

#endif

#ifdef USE_CLEARCOAT

float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );

vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );

outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;

#endif

#include <opaque_fragment>
#include <tonemapping_fragment>
#include <colorspace_fragment>
#include <fog_fragment>
#include <premultiplied_alpha_fragment>
#include <dithering_fragment>
}`;
var particle_vert = `
#include <common>
#include <color_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#include <tile_pars_vertex>
#include <soft_pars_vertex>

attribute vec3 offset;
attribute float rotation;
attribute vec3 size;

void main() {
	
    vec2 alignedPosition = position.xy * size.xy;
    
    vec2 rotatedPosition;
    rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
    rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
#ifdef HORIZONTAL
    vec4 mvPosition = modelMatrix * vec4( offset, 1.0 );
    mvPosition.x += rotatedPosition.x;
    mvPosition.z -= rotatedPosition.y;
    mvPosition = viewMatrix * mvPosition;
#elif defined(VERTICAL)
    vec4 mvPosition = modelMatrix * vec4( offset, 1.0 );
    mvPosition.y += rotatedPosition.y;
    mvPosition = viewMatrix * mvPosition;
    mvPosition.x += rotatedPosition.x;
#else
    vec4 mvPosition = modelViewMatrix * vec4( offset, 1.0 );
    mvPosition.xy += rotatedPosition;
#endif

	vColor = color;

	gl_Position = projectionMatrix * mvPosition;

	#include <logdepthbuf_vertex>

	#include <clipping_planes_vertex>

	#include <tile_vertex>
	#include <soft_vertex>
}
`;
var local_particle_vert = `
#include <common>
#include <color_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#include <tile_pars_vertex>
#include <soft_pars_vertex>

attribute vec3 offset;
attribute vec4 rotation;
attribute vec3 size;
// attribute vec4 color;

void main() {

    float x2 = rotation.x + rotation.x, y2 = rotation.y + rotation.y, z2 = rotation.z + rotation.z;
    float xx = rotation.x * x2, xy = rotation.x * y2, xz = rotation.x * z2;
    float yy = rotation.y * y2, yz = rotation.y * z2, zz = rotation.z * z2;
    float wx = rotation.w * x2, wy = rotation.w * y2, wz = rotation.w * z2;
    float sx = size.x, sy = size.y, sz = size.z;
    
    mat4 matrix = mat4(( 1.0 - ( yy + zz ) ) * sx, ( xy + wz ) * sx, ( xz - wy ) * sx, 0.0,  // 1. column
                      ( xy - wz ) * sy, ( 1.0 - ( xx + zz ) ) * sy, ( yz + wx ) * sy, 0.0,  // 2. column
                      ( xz + wy ) * sz, ( yz - wx ) * sz, ( 1.0 - ( xx + yy ) ) * sz, 0.0,  // 3. column
                      offset.x, offset.y, offset.z, 1.0);
    
    vec4 mvPosition = modelViewMatrix * (matrix * vec4( position, 1.0 ));

	vColor = color;

	gl_Position = projectionMatrix * mvPosition;

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
    #include <tile_vertex>
    #include <soft_vertex>
}
`;
var local_particle_physics_vert = `
#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>

attribute vec3 offset;
attribute vec4 rotation;
attribute vec3 size;
#include <tile_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

    #include <tile_vertex>
    float x2 = rotation.x + rotation.x, y2 = rotation.y + rotation.y, z2 = rotation.z + rotation.z;
    float xx = rotation.x * x2, xy = rotation.x * y2, xz = rotation.x * z2;
    float yy = rotation.y * y2, yz = rotation.y * z2, zz = rotation.z * z2;
    float wx = rotation.w * x2, wy = rotation.w * y2, wz = rotation.w * z2;
    float sx = size.x, sy = size.y, sz = size.z;

    mat4 particleMatrix = mat4(( 1.0 - ( yy + zz ) ) * sx, ( xy + wz ) * sx, ( xz - wy ) * sx, 0.0,  // 1. column
                      ( xy - wz ) * sy, ( 1.0 - ( xx + zz ) ) * sy, ( yz + wx ) * sy, 0.0,  // 2. column
                      ( xz + wy ) * sz, ( yz - wx ) * sz, ( 1.0 - ( xx + yy ) ) * sz, 0.0,  // 3. column
                      offset.x, offset.y, offset.z, 1.0);

#include <color_vertex>
#include <morphinstance_vertex>
#include <morphcolor_vertex>
#include <batching_vertex>

#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>

	// replace defaultnormal_vertex
	vec3 transformedNormal = objectNormal;
    mat3 m = mat3( particleMatrix );
    transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
    transformedNormal = m * transformedNormal;
    transformedNormal = normalMatrix * transformedNormal;
    #ifdef FLIP_SIDED
        transformedNormal = - transformedNormal;
    #endif
    #ifdef USE_TANGENT
        vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
        #ifdef FLIP_SIDED
        transformedTangent = - transformedTangent;
        #endif
    #endif

	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>

	// replace include <project_vertex>
  vec4 mvPosition = vec4( transformed, 1.0 );
  mvPosition = modelViewMatrix * (particleMatrix * mvPosition);
	gl_Position = projectionMatrix * mvPosition;

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	
	vViewPosition = - mvPosition.xyz;
	
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
    vWorldPosition = worldPosition.xyz;
#endif
}
`;
var stretched_bb_particle_vert = `
#include <common>
#include <color_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#include <tile_pars_vertex>
#include <soft_pars_vertex>

attribute vec3 offset;
attribute float rotation;
attribute vec3 size;
attribute vec4 velocity;

uniform float speedFactor;

void main() {
    float lengthFactor = velocity.w;
    float avgSize = (size.x + size.y) * 0.5;
#ifdef USE_SKEW
    vec4 mvPosition = modelViewMatrix * vec4( offset, 1.0 );
    vec3 viewVelocity = normalMatrix * velocity.xyz;

    vec3 scaledPos = vec3(position.xy * size.xy, position.z);
    float vlength = length(viewVelocity);
    vec3 projVelocity =  dot(scaledPos, viewVelocity) * viewVelocity / vlength;
    mvPosition.xyz += scaledPos + projVelocity * (speedFactor / avgSize + lengthFactor / vlength);
#else
    vec4 mvPosition = modelViewMatrix * vec4( offset, 1.0 );
    vec3 viewVelocity = normalMatrix * velocity.xyz;
    float vlength = length(viewVelocity); 
    mvPosition.xyz += position.y * normalize(cross(mvPosition.xyz, viewVelocity)) * avgSize; // switch the cross to  match unity implementation
    mvPosition.xyz -= (position.x + 0.5) * viewVelocity * (1.0 + lengthFactor / vlength) * avgSize; // minus position.x to match unity implementation
#endif
	vColor = color;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <tile_vertex>
	#include <soft_vertex>
}
`;
function getMaterialUVChannelName(value) {
  if (value === 0)
    return "uv";
  return `uv${value}`;
}
var ParticleMeshStandardMaterial = class extends MeshStandardMaterial {
  constructor(parameters) {
    super(parameters);
  }
  onBeforeCompile(parameters, renderer) {
    super.onBeforeCompile(parameters, renderer);
    parameters.vertexShader = local_particle_physics_vert;
    parameters.fragmentShader = particle_physics_frag;
  }
};
var ParticleMeshPhysicsMaterial = class extends MeshPhysicalMaterial {
  constructor(parameters) {
    super(parameters);
  }
  onBeforeCompile(parameters, renderer) {
    super.onBeforeCompile(parameters, renderer);
    parameters.vertexShader = local_particle_physics_vert;
    parameters.fragmentShader = particle_physics_frag;
  }
};
new Vector33(0, 0, 1);
var SpriteBatch = class extends VFXBatch {
  constructor(settings) {
    super(settings);
    this.vector_ = new Vector33();
    this.vector2_ = new Vector33();
    this.vector3_ = new Vector33();
    this.quaternion_ = new Quaternion2();
    this.quaternion2_ = new Quaternion2();
    this.quaternion3_ = new Quaternion2();
    this.rotationMat_ = new Matrix32();
    this.rotationMat2_ = new Matrix32();
    this.maxParticles = 1e3;
    this.setupBuffers();
    this.rebuildMaterial();
  }
  buildExpandableBuffers() {
    this.offsetBuffer = new InstancedBufferAttribute2(new Float32Array(this.maxParticles * 3), 3);
    this.offsetBuffer.setUsage(DynamicDrawUsage);
    this.geometry.setAttribute("offset", this.offsetBuffer);
    this.colorBuffer = new InstancedBufferAttribute2(new Float32Array(this.maxParticles * 4), 4);
    this.colorBuffer.setUsage(DynamicDrawUsage);
    this.geometry.setAttribute("color", this.colorBuffer);
    if (this.settings.renderMode === RenderMode2.Mesh) {
      this.rotationBuffer = new InstancedBufferAttribute2(new Float32Array(this.maxParticles * 4), 4);
      this.rotationBuffer.setUsage(DynamicDrawUsage);
      this.geometry.setAttribute("rotation", this.rotationBuffer);
    } else if (this.settings.renderMode === RenderMode2.BillBoard || this.settings.renderMode === RenderMode2.HorizontalBillBoard || this.settings.renderMode === RenderMode2.VerticalBillBoard || this.settings.renderMode === RenderMode2.StretchedBillBoard) {
      this.rotationBuffer = new InstancedBufferAttribute2(new Float32Array(this.maxParticles), 1);
      this.rotationBuffer.setUsage(DynamicDrawUsage);
      this.geometry.setAttribute("rotation", this.rotationBuffer);
    }
    this.sizeBuffer = new InstancedBufferAttribute2(new Float32Array(this.maxParticles * 3), 3);
    this.sizeBuffer.setUsage(DynamicDrawUsage);
    this.geometry.setAttribute("size", this.sizeBuffer);
    this.uvTileBuffer = new InstancedBufferAttribute2(new Float32Array(this.maxParticles), 1);
    this.uvTileBuffer.setUsage(DynamicDrawUsage);
    this.geometry.setAttribute("uvTile", this.uvTileBuffer);
    if (this.settings.renderMode === RenderMode2.StretchedBillBoard) {
      this.velocityBuffer = new InstancedBufferAttribute2(new Float32Array(this.maxParticles * 4), 4);
      this.velocityBuffer.setUsage(DynamicDrawUsage);
      this.geometry.setAttribute("velocity", this.velocityBuffer);
    }
  }
  setupBuffers() {
    if (this.geometry)
      this.geometry.dispose();
    this.geometry = new InstancedBufferGeometry();
    this.geometry.setIndex(this.settings.instancingGeometry.getIndex());
    if (this.settings.instancingGeometry.hasAttribute("normal")) {
      this.geometry.setAttribute("normal", this.settings.instancingGeometry.getAttribute("normal"));
    }
    this.geometry.setAttribute("position", this.settings.instancingGeometry.getAttribute("position"));
    this.geometry.setAttribute("uv", this.settings.instancingGeometry.getAttribute("uv"));
    this.buildExpandableBuffers();
  }
  expandBuffers(target) {
    while (target >= this.maxParticles) {
      this.maxParticles *= 2;
    }
    this.setupBuffers();
  }
  rebuildMaterial() {
    this.layers.mask = this.settings.layers.mask;
    const uniforms = {};
    const defines = {};
    if (this.settings.material.type !== "MeshStandardMaterial" && this.settings.material.type !== "MeshPhysicalMaterial") {
      uniforms["map"] = new Uniform$1(this.settings.material.map);
    }
    if (this.settings.material.alphaTest) {
      defines["USE_ALPHATEST"] = "";
      uniforms["alphaTest"] = new Uniform$1(this.settings.material.alphaTest);
    }
    defines["USE_UV"] = "";
    const uTileCount = this.settings.uTileCount;
    const vTileCount = this.settings.vTileCount;
    if (uTileCount > 1 || vTileCount > 1) {
      defines["UV_TILE"] = "";
      uniforms["tileCount"] = new Uniform$1(new Vector22(uTileCount, vTileCount));
    }
    if (this.settings.material.defines && this.settings.material.defines["USE_COLOR_AS_ALPHA"] !== void 0) {
      defines["USE_COLOR_AS_ALPHA"] = "";
    }
    if (this.settings.material.normalMap) {
      defines["USE_NORMALMAP"] = "";
      defines["NORMALMAP_UV"] = getMaterialUVChannelName(this.settings.material.normalMap.channel);
      uniforms["normalMapTransform"] = new Uniform$1(new Matrix32().copy(this.settings.material.normalMap.matrix));
    }
    if (this.settings.material.map) {
      defines["USE_MAP"] = "";
      if (this.settings.blendTiles)
        defines["TILE_BLEND"] = "";
      defines["MAP_UV"] = getMaterialUVChannelName(this.settings.material.map.channel);
      uniforms["mapTransform"] = new Uniform$1(new Matrix32().copy(this.settings.material.map.matrix));
    }
    defines["USE_COLOR_ALPHA"] = "";
    let onBeforeRender2;
    if (this.settings.softParticles) {
      defines["SOFT_PARTICLES"] = "";
      const nearFade = this.settings.softNearFade;
      const invFadeDistance = 1 / (this.settings.softFarFade - this.settings.softNearFade);
      uniforms["softParams"] = new Uniform$1(new Vector22(nearFade, invFadeDistance));
      uniforms["depthTexture"] = new Uniform$1(null);
      const projParams = uniforms["projParams"] = new Uniform$1(new Vector42());
      onBeforeRender2 = (_renderer3, _scene, camera) => {
        projParams.value.set(camera.near, camera.far, 0, 0);
      };
    }
    let needLights = false;
    if (this.settings.renderMode === RenderMode2.BillBoard || this.settings.renderMode === RenderMode2.VerticalBillBoard || this.settings.renderMode === RenderMode2.HorizontalBillBoard || this.settings.renderMode === RenderMode2.Mesh) {
      let vertexShader2;
      let fragmentShader2;
      if (this.settings.renderMode === RenderMode2.Mesh) {
        if (this.settings.material.type === "MeshStandardMaterial" || this.settings.material.type === "MeshPhysicalMaterial") {
          defines["USE_COLOR"] = "";
          vertexShader2 = local_particle_physics_vert;
          fragmentShader2 = particle_physics_frag;
          needLights = true;
        } else {
          vertexShader2 = local_particle_vert;
          fragmentShader2 = particle_frag;
        }
      } else {
        vertexShader2 = particle_vert;
        fragmentShader2 = particle_frag;
      }
      if (this.settings.renderMode === RenderMode2.VerticalBillBoard) {
        defines["VERTICAL"] = "";
      } else if (this.settings.renderMode === RenderMode2.HorizontalBillBoard) {
        defines["HORIZONTAL"] = "";
      }
      let specialMats = false;
      if (this.settings.renderMode === RenderMode2.Mesh) {
        if (this.settings.material.type === "MeshStandardMaterial") {
          this.material = new ParticleMeshStandardMaterial({});
          this.material.copy(this.settings.material);
          this.material.uniforms = uniforms;
          this.material.defines = defines;
          specialMats = true;
        } else if (this.settings.material.type === "MeshPhysicalMaterial") {
          this.material = new ParticleMeshPhysicsMaterial({});
          this.material.copy(this.settings.material);
          this.material.uniforms = uniforms;
          this.material.defines = defines;
          specialMats = true;
        }
      }
      if (!specialMats) {
        this.material = new ShaderMaterial({
          uniforms,
          defines,
          vertexShader: vertexShader2,
          fragmentShader: fragmentShader2,
          transparent: this.settings.material.transparent,
          depthWrite: !this.settings.material.transparent,
          blending: this.settings.material.blending,
          blendDst: this.settings.material.blendDst,
          blendSrc: this.settings.material.blendSrc,
          blendEquation: this.settings.material.blendEquation,
          premultipliedAlpha: this.settings.material.premultipliedAlpha,
          side: this.settings.material.side,
          alphaTest: this.settings.material.alphaTest,
          depthTest: this.settings.material.depthTest,
          lights: needLights
        });
      }
    } else if (this.settings.renderMode === RenderMode2.StretchedBillBoard) {
      uniforms["speedFactor"] = new Uniform$1(1);
      this.material = new ShaderMaterial({
        uniforms,
        defines,
        vertexShader: stretched_bb_particle_vert,
        fragmentShader: particle_frag,
        transparent: this.settings.material.transparent,
        depthWrite: !this.settings.material.transparent,
        blending: this.settings.material.blending,
        blendDst: this.settings.material.blendDst,
        blendSrc: this.settings.material.blendSrc,
        blendEquation: this.settings.material.blendEquation,
        premultipliedAlpha: this.settings.material.premultipliedAlpha,
        side: this.settings.material.side,
        alphaTest: this.settings.material.alphaTest,
        depthTest: this.settings.material.depthTest
      });
    } else {
      throw new Error("render mode unavailable");
    }
    if (this.material && onBeforeRender2) {
      this.material.onBeforeRender = onBeforeRender2;
    }
  }
  update() {
    let index = 0;
    let particleCount = 0;
    this.systems.forEach((system) => {
      particleCount += system.particleNum;
    });
    if (particleCount > this.maxParticles) {
      this.expandBuffers(particleCount);
    }
    this.systems.forEach((system) => {
      if (system.emitter.updateMatrixWorld) {
        system.emitter.updateWorldMatrix(true, false);
        system.emitter.updateMatrixWorld(true);
      }
      const particles = system.particles;
      const particleNum = system.particleNum;
      const rotation = this.quaternion2_;
      const translation = this.vector2_;
      const scale = this.vector3_;
      system.emitter.matrixWorld.decompose(translation, rotation, scale);
      this.rotationMat_.setFromMatrix4(system.emitter.matrixWorld);
      for (let j = 0; j < particleNum; j++, index++) {
        const particle = particles[j];
        if (this.settings.renderMode === RenderMode2.Mesh) {
          let q;
          if (system.worldSpace) {
            q = particle.rotation;
          } else {
            let parentQ;
            if (particle.parentMatrix) {
              parentQ = this.quaternion3_.setFromRotationMatrix(particle.parentMatrix);
            } else {
              parentQ = rotation;
            }
            q = this.quaternion_;
            q.copy(parentQ).multiply(particle.rotation);
          }
          this.rotationBuffer.setXYZW(index, q.x, q.y, q.z, q.w);
        } else if (this.settings.renderMode === RenderMode2.StretchedBillBoard || this.settings.renderMode === RenderMode2.VerticalBillBoard || this.settings.renderMode === RenderMode2.HorizontalBillBoard || this.settings.renderMode === RenderMode2.BillBoard) {
          this.rotationBuffer.setX(index, particle.rotation);
        }
        let vec2;
        if (system.worldSpace) {
          vec2 = particle.position;
        } else {
          vec2 = this.vector_;
          if (particle.parentMatrix) {
            vec2.copy(particle.position).applyMatrix4(particle.parentMatrix);
          } else {
            vec2.copy(particle.position).applyMatrix4(system.emitter.matrixWorld);
          }
        }
        this.offsetBuffer.setXYZ(index, vec2.x, vec2.y, vec2.z);
        this.colorBuffer.setXYZW(index, particle.color.x, particle.color.y, particle.color.z, particle.color.w);
        if (system.worldSpace) {
          this.sizeBuffer.setXYZ(index, particle.size.x, particle.size.y, particle.size.z);
        } else {
          if (particle.parentMatrix) {
            this.sizeBuffer.setXYZ(index, particle.size.x, particle.size.y, particle.size.z);
          } else {
            this.sizeBuffer.setXYZ(index, particle.size.x * Math.abs(scale.x), particle.size.y * Math.abs(scale.y), particle.size.z * Math.abs(scale.z));
          }
        }
        this.uvTileBuffer.setX(index, particle.uvTile);
        if (this.settings.renderMode === RenderMode2.StretchedBillBoard && this.velocityBuffer) {
          let speedFactor = system.rendererEmitterSettings.speedFactor;
          if (speedFactor === 0)
            speedFactor = 1e-3;
          const lengthFactor = system.rendererEmitterSettings.lengthFactor;
          let vec3;
          if (system.worldSpace) {
            vec3 = particle.velocity;
          } else {
            vec3 = this.vector_;
            if (particle.parentMatrix) {
              this.rotationMat2_.setFromMatrix4(particle.parentMatrix);
              vec3.copy(particle.velocity).applyMatrix3(this.rotationMat2_);
            } else {
              vec3.copy(particle.velocity).applyMatrix3(this.rotationMat_);
            }
          }
          this.velocityBuffer.setXYZW(index, vec3.x * speedFactor, vec3.y * speedFactor, vec3.z * speedFactor, lengthFactor);
        }
      }
    });
    this.geometry.instanceCount = index;
    if (index > 0) {
      this.offsetBuffer.clearUpdateRanges();
      this.offsetBuffer.addUpdateRange(0, index * 3);
      this.offsetBuffer.needsUpdate = true;
      this.sizeBuffer.clearUpdateRanges();
      this.sizeBuffer.addUpdateRange(0, index * 3);
      this.sizeBuffer.needsUpdate = true;
      this.colorBuffer.clearUpdateRanges();
      this.colorBuffer.addUpdateRange(0, index * 4);
      this.colorBuffer.needsUpdate = true;
      this.uvTileBuffer.clearUpdateRanges();
      this.uvTileBuffer.addUpdateRange(0, index);
      this.uvTileBuffer.needsUpdate = true;
      if (this.settings.renderMode === RenderMode2.StretchedBillBoard && this.velocityBuffer) {
        this.velocityBuffer.clearUpdateRanges();
        this.velocityBuffer.addUpdateRange(0, index * 4);
        this.velocityBuffer.needsUpdate = true;
      }
      if (this.settings.renderMode === RenderMode2.Mesh) {
        this.rotationBuffer.clearUpdateRanges();
        this.rotationBuffer.addUpdateRange(0, index * 4);
        this.rotationBuffer.needsUpdate = true;
      } else if (this.settings.renderMode === RenderMode2.StretchedBillBoard || this.settings.renderMode === RenderMode2.HorizontalBillBoard || this.settings.renderMode === RenderMode2.VerticalBillBoard || this.settings.renderMode === RenderMode2.BillBoard) {
        this.rotationBuffer.clearUpdateRanges();
        this.rotationBuffer.addUpdateRange(0, index);
        this.rotationBuffer.needsUpdate = true;
      }
    }
  }
  dispose() {
    this.geometry.dispose();
  }
};
var trail_frag = `

#include <common>
#include <tile_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

uniform sampler2D alphaMap;
uniform float useAlphaMap;
uniform float visibility;
uniform float alphaTest;

varying vec4 vColor;
    
void main() {
    #include <clipping_planes_fragment>
    #include <logdepthbuf_fragment>

    vec4 diffuseColor = vColor;
    
    #ifdef USE_MAP
    #include <tile_fragment>
    #ifndef USE_COLOR_AS_ALPHA
    #endif
    #endif
    if( useAlphaMap == 1. ) diffuseColor.a *= texture2D( alphaMap, vUv).a;
    if( diffuseColor.a < alphaTest ) discard;
    gl_FragColor = diffuseColor;

    #include <fog_fragment>
    #include <tonemapping_fragment>
}`;
var trail_vert = `
#include <common>
#include <tile_pars_vertex>
#include <color_pars_vertex>
#include <clipping_planes_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <fog_pars_vertex>

attribute vec3 previous;
attribute vec3 next;
attribute float side;
attribute float width;

uniform vec2 resolution;
uniform float lineWidth;
uniform float sizeAttenuation;
    
vec2 fix(vec4 i, float aspect) {
    vec2 res = i.xy / i.w;
    res.x *= aspect;
    return res;
}
    
void main() {

    #include <tile_vertex>
    
    float aspect = resolution.x / resolution.y;

    vColor = color;

    mat4 m = projectionMatrix * modelViewMatrix;
    vec4 finalPosition = m * vec4( position, 1.0 );
    vec4 prevPos = m * vec4( previous, 1.0 );
    vec4 nextPos = m * vec4( next, 1.0 );

    vec2 currentP = fix( finalPosition, aspect );
    vec2 prevP = fix( prevPos, aspect );
    vec2 nextP = fix( nextPos, aspect );

    float w = lineWidth * width;

    vec2 dir;
    if( nextP == currentP ) dir = normalize( currentP - prevP );
    else if( prevP == currentP ) dir = normalize( nextP - currentP );
    else {
        vec2 dir1 = normalize( currentP - prevP );
        vec2 dir2 = normalize( nextP - currentP );
        dir = normalize( dir1 + dir2 );

        vec2 perp = vec2( -dir1.y, dir1.x );
        vec2 miter = vec2( -dir.y, dir.x );
        //w = clamp( w / dot( miter, perp ), 0., 4., * lineWidth * width );

    }

    //vec2 normal = ( cross( vec3( dir, 0. ) vec3( 0., 0., 1. ) ) ).xy;
    vec4 normal = vec4( -dir.y, dir.x, 0., 1. );
    normal.xy *= .5 * w;
    normal *= projectionMatrix;
    if( sizeAttenuation == 0. ) {
        normal.xy *= finalPosition.w;
        normal.xy /= ( vec4( resolution, 0., 1. ) * projectionMatrix ).xy;
    }

    finalPosition.xy += normal.xy * side;

    gl_Position = finalPosition;

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
    
	#include <fog_vertex>
}`;
new Vector33(0, 0, 1);
var TrailBatch = class extends VFXBatch {
  constructor(settings) {
    super(settings);
    this.vector_ = new Vector33();
    this.vector2_ = new Vector33();
    this.vector3_ = new Vector33();
    this.quaternion_ = new Quaternion2();
    this.maxParticles = 1e4;
    this.setupBuffers();
    this.rebuildMaterial();
  }
  setupBuffers() {
    if (this.geometry)
      this.geometry.dispose();
    this.geometry = new BufferGeometry();
    this.indexBuffer = new BufferAttribute2(new Uint32Array(this.maxParticles * 6), 1);
    this.indexBuffer.setUsage(DynamicDrawUsage);
    this.geometry.setIndex(this.indexBuffer);
    this.positionBuffer = new BufferAttribute2(new Float32Array(this.maxParticles * 6), 3);
    this.positionBuffer.setUsage(DynamicDrawUsage);
    this.geometry.setAttribute("position", this.positionBuffer);
    this.previousBuffer = new BufferAttribute2(new Float32Array(this.maxParticles * 6), 3);
    this.previousBuffer.setUsage(DynamicDrawUsage);
    this.geometry.setAttribute("previous", this.previousBuffer);
    this.nextBuffer = new BufferAttribute2(new Float32Array(this.maxParticles * 6), 3);
    this.nextBuffer.setUsage(DynamicDrawUsage);
    this.geometry.setAttribute("next", this.nextBuffer);
    this.widthBuffer = new BufferAttribute2(new Float32Array(this.maxParticles * 2), 1);
    this.widthBuffer.setUsage(DynamicDrawUsage);
    this.geometry.setAttribute("width", this.widthBuffer);
    this.sideBuffer = new BufferAttribute2(new Float32Array(this.maxParticles * 2), 1);
    this.sideBuffer.setUsage(DynamicDrawUsage);
    this.geometry.setAttribute("side", this.sideBuffer);
    this.uvBuffer = new BufferAttribute2(new Float32Array(this.maxParticles * 4), 2);
    this.uvBuffer.setUsage(DynamicDrawUsage);
    this.geometry.setAttribute("uv", this.uvBuffer);
    this.colorBuffer = new BufferAttribute2(new Float32Array(this.maxParticles * 8), 4);
    this.colorBuffer.setUsage(DynamicDrawUsage);
    this.geometry.setAttribute("color", this.colorBuffer);
  }
  expandBuffers(target) {
    while (target >= this.maxParticles) {
      this.maxParticles *= 2;
    }
    this.setupBuffers();
  }
  rebuildMaterial() {
    this.layers.mask = this.settings.layers.mask;
    const uniforms = {
      lineWidth: { value: 1 },
      map: { value: null },
      useMap: { value: 0 },
      alphaMap: { value: null },
      useAlphaMap: { value: 0 },
      resolution: { value: new Vector22(1, 1) },
      sizeAttenuation: { value: 1 },
      visibility: { value: 1 },
      alphaTest: { value: 0 }
    };
    const defines = {};
    defines["USE_UV"] = "";
    defines["USE_COLOR_ALPHA"] = "";
    if (this.settings.material.map) {
      defines["USE_MAP"] = "";
      defines["MAP_UV"] = getMaterialUVChannelName(this.settings.material.map.channel);
      uniforms["map"] = new Uniform$1(this.settings.material.map);
      uniforms["mapTransform"] = new Uniform$1(new Matrix32().copy(this.settings.material.map.matrix));
    }
    if (this.settings.material.defines && this.settings.material.defines["USE_COLOR_AS_ALPHA"] !== void 0) {
      defines["USE_COLOR_AS_ALPHA"] = "";
    }
    if (this.settings.renderMode === RenderMode2.Trail) {
      this.material = new ShaderMaterial({
        uniforms,
        defines,
        vertexShader: trail_vert,
        fragmentShader: trail_frag,
        transparent: this.settings.material.transparent,
        depthWrite: !this.settings.material.transparent,
        side: this.settings.material.side,
        blending: this.settings.material.blending || AdditiveBlending,
        blendDst: this.settings.material.blendDst,
        blendSrc: this.settings.material.blendSrc,
        blendEquation: this.settings.material.blendEquation,
        premultipliedAlpha: this.settings.material.premultipliedAlpha
      });
    } else {
      throw new Error("render mode unavailable");
    }
  }
  update() {
    let index = 0;
    let triangles = 0;
    let particleCount = 0;
    this.systems.forEach((system) => {
      for (let j = 0; j < system.particleNum; j++) {
        particleCount += system.particles[j].previous.length * 2;
      }
    });
    if (particleCount > this.maxParticles) {
      this.expandBuffers(particleCount);
    }
    this.systems.forEach((system) => {
      if (system.emitter.updateMatrixWorld) {
        system.emitter.updateWorldMatrix(true, false);
        system.emitter.updateMatrixWorld(true);
      }
      const rotation = this.quaternion_;
      const translation = this.vector2_;
      const scale = this.vector3_;
      system.emitter.matrixWorld.decompose(translation, rotation, scale);
      const particles = system.particles;
      const particleNum = system.particleNum;
      const uTileCount = this.settings.uTileCount;
      const vTileCount = this.settings.vTileCount;
      const tileWidth = 1 / uTileCount;
      const tileHeight = 1 / vTileCount;
      for (let j = 0; j < particleNum; j++) {
        const particle = particles[j];
        const col2 = particle.uvTile % vTileCount;
        const row = Math.floor(particle.uvTile / vTileCount + 1e-3);
        const iter = particle.previous.values();
        let curIter = iter.next();
        let previous = curIter.value;
        let current = previous;
        if (!curIter.done)
          curIter = iter.next();
        let next;
        if (curIter.value !== void 0) {
          next = curIter.value;
        } else {
          next = current;
        }
        for (let i = 0; i < particle.previous.length; i++, index += 2) {
          this.positionBuffer.setXYZ(index, current.position.x, current.position.y, current.position.z);
          this.positionBuffer.setXYZ(index + 1, current.position.x, current.position.y, current.position.z);
          if (system.worldSpace) {
            this.positionBuffer.setXYZ(index, current.position.x, current.position.y, current.position.z);
            this.positionBuffer.setXYZ(index + 1, current.position.x, current.position.y, current.position.z);
          } else {
            if (particle.parentMatrix) {
              this.vector_.copy(current.position).applyMatrix4(particle.parentMatrix);
            } else {
              this.vector_.copy(current.position).applyMatrix4(system.emitter.matrixWorld);
            }
            this.positionBuffer.setXYZ(index, this.vector_.x, this.vector_.y, this.vector_.z);
            this.positionBuffer.setXYZ(index + 1, this.vector_.x, this.vector_.y, this.vector_.z);
          }
          if (system.worldSpace) {
            this.previousBuffer.setXYZ(index, previous.position.x, previous.position.y, previous.position.z);
            this.previousBuffer.setXYZ(index + 1, previous.position.x, previous.position.y, previous.position.z);
          } else {
            if (particle.parentMatrix) {
              this.vector_.copy(previous.position).applyMatrix4(particle.parentMatrix);
            } else {
              this.vector_.copy(previous.position).applyMatrix4(system.emitter.matrixWorld);
            }
            this.previousBuffer.setXYZ(index, this.vector_.x, this.vector_.y, this.vector_.z);
            this.previousBuffer.setXYZ(index + 1, this.vector_.x, this.vector_.y, this.vector_.z);
          }
          if (system.worldSpace) {
            this.nextBuffer.setXYZ(index, next.position.x, next.position.y, next.position.z);
            this.nextBuffer.setXYZ(index + 1, next.position.x, next.position.y, next.position.z);
          } else {
            if (particle.parentMatrix) {
              this.vector_.copy(next.position).applyMatrix4(particle.parentMatrix);
            } else {
              this.vector_.copy(next.position).applyMatrix4(system.emitter.matrixWorld);
            }
            this.nextBuffer.setXYZ(index, this.vector_.x, this.vector_.y, this.vector_.z);
            this.nextBuffer.setXYZ(index + 1, this.vector_.x, this.vector_.y, this.vector_.z);
          }
          this.sideBuffer.setX(index, -1);
          this.sideBuffer.setX(index + 1, 1);
          if (system.worldSpace) {
            this.widthBuffer.setX(index, current.size);
            this.widthBuffer.setX(index + 1, current.size);
          } else {
            if (particle.parentMatrix) {
              this.widthBuffer.setX(index, current.size);
              this.widthBuffer.setX(index + 1, current.size);
            } else {
              const objectScale = (Math.abs(scale.x) + Math.abs(scale.y) + Math.abs(scale.z)) / 3;
              this.widthBuffer.setX(index, current.size * objectScale);
              this.widthBuffer.setX(index + 1, current.size * objectScale);
            }
          }
          this.uvBuffer.setXY(index, (i / particle.previous.length + col2) * tileWidth, (vTileCount - row - 1) * tileHeight);
          this.uvBuffer.setXY(index + 1, (i / particle.previous.length + col2) * tileWidth, (vTileCount - row) * tileHeight);
          this.colorBuffer.setXYZW(index, current.color.x, current.color.y, current.color.z, current.color.w);
          this.colorBuffer.setXYZW(index + 1, current.color.x, current.color.y, current.color.z, current.color.w);
          if (i + 1 < particle.previous.length) {
            this.indexBuffer.setX(triangles * 3, index);
            this.indexBuffer.setX(triangles * 3 + 1, index + 1);
            this.indexBuffer.setX(triangles * 3 + 2, index + 2);
            triangles++;
            this.indexBuffer.setX(triangles * 3, index + 2);
            this.indexBuffer.setX(triangles * 3 + 1, index + 1);
            this.indexBuffer.setX(triangles * 3 + 2, index + 3);
            triangles++;
          }
          previous = current;
          current = next;
          if (!curIter.done) {
            curIter = iter.next();
            if (curIter.value !== void 0) {
              next = curIter.value;
            }
          }
        }
      }
    });
    this.positionBuffer.clearUpdateRanges();
    this.positionBuffer.addUpdateRange(0, index * 3);
    this.positionBuffer.needsUpdate = true;
    this.previousBuffer.clearUpdateRanges();
    this.previousBuffer.addUpdateRange(0, index * 3);
    this.previousBuffer.needsUpdate = true;
    this.nextBuffer.clearUpdateRanges();
    this.nextBuffer.addUpdateRange(0, index * 3);
    this.nextBuffer.needsUpdate = true;
    this.sideBuffer.clearUpdateRanges();
    this.sideBuffer.addUpdateRange(0, index);
    this.sideBuffer.needsUpdate = true;
    this.widthBuffer.clearUpdateRanges();
    this.widthBuffer.addUpdateRange(0, index);
    this.widthBuffer.needsUpdate = true;
    this.uvBuffer.clearUpdateRanges();
    this.uvBuffer.addUpdateRange(0, index * 2);
    this.uvBuffer.needsUpdate = true;
    this.colorBuffer.clearUpdateRanges();
    this.colorBuffer.addUpdateRange(0, index * 4);
    this.colorBuffer.needsUpdate = true;
    this.indexBuffer.clearUpdateRanges();
    this.indexBuffer.addUpdateRange(0, triangles * 3);
    this.indexBuffer.needsUpdate = true;
    this.geometry.setDrawRange(0, triangles * 3);
  }
  dispose() {
    this.geometry.dispose();
  }
};
var MeshSurfaceEmitter = class {
  get geometry() {
    return this._geometry;
  }
  set geometry(geometry) {
    this._geometry = geometry;
    if (geometry === void 0) {
      return;
    }
    if (typeof geometry === "string") {
      return;
    }
    const tri = new Triangle();
    this._triangleIndexToArea.length = 0;
    let area2 = 0;
    if (!geometry.getIndex()) {
      return;
    }
    const array = geometry.getIndex().array;
    const triCount = array.length / 3;
    this._triangleIndexToArea.push(0);
    for (let i = 0; i < triCount; i++) {
      tri.setFromAttributeAndIndices(geometry.getAttribute("position"), array[i * 3], array[i * 3 + 1], array[i * 3 + 2]);
      area2 += tri.getArea();
      this._triangleIndexToArea.push(area2);
    }
    geometry.userData.triangleIndexToArea = this._triangleIndexToArea;
  }
  constructor(geometry) {
    this.type = "mesh_surface";
    this._triangleIndexToArea = [];
    this._tempA = new Vector32();
    this._tempB = new Vector32();
    this._tempC = new Vector32();
    if (!geometry) {
      return;
    }
    this.geometry = geometry;
  }
  initialize(p) {
    const geometry = this._geometry;
    if (!geometry || geometry.getIndex() === null) {
      p.position.set(0, 0, 0);
      p.velocity.set(0, 0, 1).multiplyScalar(p.startSpeed);
      return;
    }
    const triCount = this._triangleIndexToArea.length - 1;
    let left = 0, right = triCount;
    const target = Math.random() * this._triangleIndexToArea[triCount];
    while (left + 1 < right) {
      const mid = Math.floor((left + right) / 2);
      if (target < this._triangleIndexToArea[mid]) {
        right = mid;
      } else {
        left = mid;
      }
    }
    let u1 = Math.random();
    let u2 = Math.random();
    if (u1 + u2 > 1) {
      u1 = 1 - u1;
      u2 = 1 - u2;
    }
    const index1 = geometry.getIndex().array[left * 3];
    const index2 = geometry.getIndex().array[left * 3 + 1];
    const index3 = geometry.getIndex().array[left * 3 + 2];
    const positionBuffer = geometry.getAttribute("position");
    this._tempA.fromBufferAttribute(positionBuffer, index1);
    this._tempB.fromBufferAttribute(positionBuffer, index2);
    this._tempC.fromBufferAttribute(positionBuffer, index3);
    this._tempB.sub(this._tempA);
    this._tempC.sub(this._tempA);
    this._tempA.addScaledVector(this._tempB, u1).addScaledVector(this._tempC, u2);
    p.position.copy(this._tempA);
    this._tempA.copy(this._tempB).cross(this._tempC).normalize();
    p.velocity.copy(this._tempA).normalize().multiplyScalar(p.startSpeed);
  }
  toJSON() {
    return {
      type: "mesh_surface",
      mesh: this._geometry ? this._geometry.uuid : ""
    };
  }
  static fromJSON(json, meta) {
    return new MeshSurfaceEmitter(meta.geometries[json.geometry]);
  }
  clone() {
    return new MeshSurfaceEmitter(this._geometry);
  }
  update(system, delta) {
  }
};
loadPlugin({
  id: "three.quarks",
  initialize: () => {
  },
  emitterShapes: [{
    type: "mesh_surface",
    params: [["geometry", ["geometry"]]],
    constructor: MeshSurfaceEmitter,
    loadJSON: MeshSurfaceEmitter.fromJSON
  }],
  behaviors: []
});
var BatchedRenderer = class extends Object3D {
  constructor() {
    super();
    this.batches = [];
    this.systemToBatchIndex = /* @__PURE__ */ new Map();
    this.type = "BatchedRenderer";
    this.depthTexture = null;
  }
  static equals(a, b) {
    return a.material.side === b.material.side && a.material.blending === b.material.blending && a.material.blendSrc === b.material.blendSrc && a.material.blendDst === b.material.blendDst && a.material.blendEquation === b.material.blendEquation && a.material.premultipliedAlpha === b.material.premultipliedAlpha && a.material.transparent === b.material.transparent && a.material.depthTest === b.material.depthTest && a.material.type === b.material.type && a.material.alphaTest === b.material.alphaTest && a.material.map === b.material.map && a.renderMode === b.renderMode && a.blendTiles === b.blendTiles && a.softParticles === b.softParticles && a.softFarFade === b.softFarFade && a.softNearFade === b.softNearFade && a.uTileCount === b.uTileCount && a.vTileCount === b.vTileCount && a.instancingGeometry === b.instancingGeometry && a.renderOrder === b.renderOrder && a.layers.mask === b.layers.mask;
  }
  addSystem(system) {
    system._renderer = this;
    const settings = system.getRendererSettings();
    for (let i = 0; i < this.batches.length; i++) {
      if (BatchedRenderer.equals(this.batches[i].settings, settings)) {
        this.batches[i].addSystem(system);
        this.systemToBatchIndex.set(system, i);
        return;
      }
    }
    let batch;
    switch (settings.renderMode) {
      case RenderMode2.Trail:
        batch = new TrailBatch(settings);
        break;
      case RenderMode2.Mesh:
      case RenderMode2.BillBoard:
      case RenderMode2.VerticalBillBoard:
      case RenderMode2.HorizontalBillBoard:
      case RenderMode2.StretchedBillBoard:
        batch = new SpriteBatch(settings);
        break;
    }
    if (this.depthTexture) {
      batch.applyDepthTexture(this.depthTexture);
    }
    batch.addSystem(system);
    this.batches.push(batch);
    this.systemToBatchIndex.set(system, this.batches.length - 1);
    this.add(batch);
  }
  deleteSystem(system) {
    const batchIndex = this.systemToBatchIndex.get(system);
    if (batchIndex != void 0) {
      this.batches[batchIndex].removeSystem(system);
      this.systemToBatchIndex.delete(system);
    }
  }
  setDepthTexture(depthTexture) {
    this.depthTexture = depthTexture;
    for (const batch of this.batches) {
      batch.applyDepthTexture(depthTexture);
    }
  }
  updateSystem(system) {
    this.deleteSystem(system);
    this.addSystem(system);
  }
  update(delta) {
    this.systemToBatchIndex.forEach((value, ps) => {
      ps.update(delta);
    });
    for (let i = 0; i < this.batches.length; i++) {
      this.batches[i].update();
    }
  }
};
var BatchedParticleRenderer = BatchedRenderer;
registerShaderChunks();
console.log("%c Particle system powered by three.quarks. https://quarks.art/", "font-size: 14px; font-weight: bold;");

// node_modules/@needle-tools/engine/lib/engine-components/particlesystem/ParticleSystem.js
var __decorate71 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug98 = getParam("debugparticles");
var suppressProgressiveLoading2 = getParam("noprogressive");
var debugProgressiveLoading2 = getParam("debugprogressive");
var SubEmitterType;
(function(SubEmitterType2) {
  SubEmitterType2[SubEmitterType2["Birth"] = 0] = "Birth";
  SubEmitterType2[SubEmitterType2["Collision"] = 1] = "Collision";
  SubEmitterType2[SubEmitterType2["Death"] = 2] = "Death";
  SubEmitterType2[SubEmitterType2["Trigger"] = 3] = "Trigger";
  SubEmitterType2[SubEmitterType2["Manual"] = 4] = "Manual";
})(SubEmitterType || (SubEmitterType = {}));
var ParticleSystemRenderer = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "renderMode");
    __publicField(this, "particleMaterial");
    __publicField(this, "trailMaterial");
    // @serializable(Mesh)
    __publicField(this, "particleMesh");
    __publicField(this, "maxParticleSize");
    __publicField(this, "minParticleSize");
    __publicField(this, "velocityScale");
    __publicField(this, "cameraVelocityScale");
    __publicField(this, "lengthScale");
  }
  start() {
    if (this.maxParticleSize !== 0.5 && this.minParticleSize !== 0) {
      if (isDevEnvironment()) {
        const msg = `ParticleSystem "${this.name}" has non-default min/max particle size. This may not render correctly. Please set min size to 0 and the max size to 0.5 and use the "StartSize" setting instead`;
        console.warn(msg);
      }
    }
  }
  get transparent() {
    var _a2;
    const res = ((_a2 = this.particleMaterial) == null ? void 0 : _a2.transparent) ?? false;
    return res;
  }
  getMaterial(trailEnabled = false) {
    let material = trailEnabled === true && this.trailMaterial ? this.trailMaterial : this.particleMaterial;
    if (material) {
      if (trailEnabled) {
        if (material.side === FrontSide) {
          material = material.clone();
          material.side = BackSide;
          if (trailEnabled)
            this.trailMaterial = material;
          else
            this.particleMaterial = material;
        }
      }
    }
    if (material && !suppressProgressiveLoading2 && material["_didRequestTextureLOD"] === void 0) {
      material["_didRequestTextureLOD"] = 0;
      if (debugProgressiveLoading2) {
        console.log("Load material LOD", material.name);
      }
      NEEDLE_progressive.assignTextureLOD(material, 0);
    }
    return material;
  }
  getMesh(_renderMode) {
    let geo = null;
    if (!geo) {
      if (this.particleMesh instanceof Mesh) {
        geo = this.particleMesh.geometry;
      }
      if (geo === null) {
        geo = new PlaneGeometry(1, 1);
        const uv = geo.attributes.uv;
        for (let i = 0; i < uv.count; i++) {
          uv.setX(i, 1 - uv.getX(i));
        }
      }
    }
    const res = new Mesh(geo, this.getMaterial());
    return res;
  }
};
__decorate71([
  serializable()
], ParticleSystemRenderer.prototype, "renderMode", void 0);
__decorate71([
  serializable(Material)
], ParticleSystemRenderer.prototype, "particleMaterial", void 0);
__decorate71([
  serializable(Material)
], ParticleSystemRenderer.prototype, "trailMaterial", void 0);
__decorate71([
  serializable()
], ParticleSystemRenderer.prototype, "maxParticleSize", void 0);
__decorate71([
  serializable()
], ParticleSystemRenderer.prototype, "minParticleSize", void 0);
__decorate71([
  serializable()
], ParticleSystemRenderer.prototype, "velocityScale", void 0);
__decorate71([
  serializable()
], ParticleSystemRenderer.prototype, "cameraVelocityScale", void 0);
__decorate71([
  serializable()
], ParticleSystemRenderer.prototype, "lengthScale", void 0);
var MinMaxCurveFunction = class {
  constructor(curve, factor = 1) {
    __publicField(this, "_curve");
    __publicField(this, "_factor");
    __publicField(this, "type", "function");
    this._curve = curve;
    this._factor = factor;
  }
  startGen(_memory) {
  }
  genValue(_memory, t2) {
    return this._curve.evaluate(t2, Math.random()) * this._factor;
  }
  toJSON() {
    throw new Error("Method not implemented.");
  }
  clone() {
    throw new Error("Method not implemented.");
  }
};
var BaseValueGenerator = class {
  constructor(system) {
    __publicField(this, "type", "value");
    __publicField(this, "system");
    this.system = system;
  }
  toJSON() {
    throw new Error("Method not implemented.");
  }
  clone() {
    throw new Error("Method not implemented.");
  }
  startGen(_memory) {
  }
};
var TextureSheetStartFrameGenerator = class extends BaseValueGenerator {
  genValue() {
    return this.system.textureSheetAnimation.getStartIndex();
  }
};
var ParticleSystemEmissionOverTime = class extends BaseValueGenerator {
  constructor() {
    super(...arguments);
    __publicField(this, "_lastPosition", new Vector32());
    __publicField(this, "_lastDistance", 0);
  }
  update() {
    const currentPosition = getWorldPosition(this.system.gameObject);
    this._lastDistance = this._lastPosition.distanceTo(currentPosition);
    this._lastPosition.copy(currentPosition);
  }
  genValue() {
    if (!this.system.isPlaying)
      return 0;
    if (!this.system.emission.enabled)
      return 0;
    if (this.system.currentParticles >= this.system.maxParticles)
      return 0;
    let emission = this.system.emission.rateOverTime.evaluate(this.system.time / this.system.duration, Math.random());
    if (this.system.deltaTime > 0) {
      const distanceEmission = this.system.emission.rateOverDistance.evaluate(this.system.time / this.system.duration, Math.random());
      const meterPerSecond = this._lastDistance / this.system.deltaTime;
      let distanceEmissionValue = meterPerSecond * distanceEmission;
      if (!Number.isFinite(distanceEmissionValue))
        distanceEmissionValue = 0;
      emission += distanceEmissionValue;
    }
    const burst = this.system.emission.getBurst();
    if (burst > 0)
      emission += burst / this.system.deltaTime;
    const maxEmission = this.system.maxParticles - this.system.currentParticles;
    return Mathf.clamp(emission, 0, maxEmission / this.system.deltaTime);
  }
};
var ParticleSystemEmissionOverDistance = class extends BaseValueGenerator {
  genValue() {
    if (!this.system.isPlaying)
      return 0;
    return 0;
  }
};
var ParticleSystemBaseBehaviour = class {
  constructor(ps) {
    __publicField(this, "system");
    __publicField(this, "type");
    this.type = Object.getPrototypeOf(this).constructor.name || "ParticleSystemBaseBehaviour";
    if (ps)
      this.system = ps;
  }
  get context() {
    return this.system.context;
  }
  initialize(_particle) {
  }
  update(_particle, _delta2) {
  }
  frameUpdate(_delta2) {
  }
  toJSON() {
    throw new Error("Method not implemented.");
  }
  clone() {
    throw new Error("Method not implemented.");
  }
  reset() {
  }
};
var $startFrame = Symbol("startFrame");
var TextureSheetAnimationBehaviour = class extends ParticleSystemBaseBehaviour {
  constructor() {
    super(...arguments);
    __publicField(this, "type", "NeedleTextureSheet");
  }
  // initialize(_particle: Particle): void {
  //     _particle[$startFrame] = this.system.textureSheetAnimation.getStartIndex();
  // }
  update(particle, _delta2) {
    const sheet = this.system.textureSheetAnimation;
    if (sheet.enabled) {
      const t01 = particle.age / particle.life;
      const index = sheet.evaluate(t01);
      if (index !== void 0)
        particle.uvTile = index;
    }
  }
};
var $particleRotation = Symbol("particleRotation");
var RotationBehaviour = class extends ParticleSystemBaseBehaviour {
  constructor() {
    super(...arguments);
    __publicField(this, "type", "NeedleRotation");
  }
  initialize(particle) {
    particle[$particleRotation] = Math.random();
  }
  update(particle, delta) {
    if (particle.rotation === void 0)
      return;
    const t2 = particle.age / particle.life;
    if (typeof particle.rotation === "number") {
      if (this.system.rotationOverLifetime.enabled) {
        particle.rotation += this.system.rotationOverLifetime.evaluate(t2, particle[$particleRotation]) * delta;
      } else {
        if (this.system.renderer.renderMode === ParticleSystemRenderMode.Billboard)
          particle.rotation = Math.PI;
      }
      if (this.system.rotationBySpeed.enabled) {
        const speed = particle.velocity.length();
        particle.rotation += this.system.rotationBySpeed.evaluate(t2, speed) * delta;
      }
    } else {
    }
  }
};
var $sizeLerpFactor = Symbol("sizeLerpFactor");
var localScaleVec3 = new Vector32();
var SizeBehaviour = class extends ParticleSystemBaseBehaviour {
  constructor() {
    super(...arguments);
    __publicField(this, "type", "NeedleSize");
    __publicField(this, "_minSize", 0);
    __publicField(this, "_maxSize", 1);
  }
  initialize(particle) {
    particle[$sizeLerpFactor] = Math.random();
    this._minSize = this.system.renderer.minParticleSize;
    this._maxSize = this.system.renderer.maxParticleSize;
  }
  update(particle, _delta2) {
    const age01 = particle.age / particle.life;
    let size = 1;
    if (this.system.sizeOverLifetime.enabled)
      size *= this.system.sizeOverLifetime.evaluate(age01, void 0, particle[$sizeLerpFactor]).x;
    let scaleFactor = 1;
    if (this.system.renderer.renderMode !== ParticleSystemRenderMode.Mesh)
      scaleFactor = this.system.worldScale.x / this.system.cameraScale;
    const newSize = getTempVector(particle.startSize).multiplyScalar(size * scaleFactor);
    particle.size.set(newSize.x, newSize.y, newSize.z);
    if (this.system.localspace) {
      const scale = getLocalSimulationScale(this.system, localScaleVec3);
      particle.size.x *= scale.x;
      particle.size.y *= scale.y;
      particle.size.z *= scale.z;
    }
  }
};
var $particleLife = Symbol("particleLife");
var $trailLifetime = Symbol("trailLifetime");
var $trailStartLength = Symbol("trailStartLength");
var $trailWidthRandom = Symbol("trailWidthRandom");
var TrailBehaviour = class extends ParticleSystemBaseBehaviour {
  constructor() {
    super(...arguments);
    __publicField(this, "type", "NeedleTrail");
  }
  initialize(particle) {
    if (particle instanceof TrailParticle) {
      particle[$particleLife] = particle.life;
      if (this.system.trails.enabled && this.system.trails.dieWithParticles === false) {
        particle[$trailLifetime] = this.system.trails.lifetime.evaluate(Math.random(), Math.random());
        particle.life += particle[$trailLifetime];
      }
      particle[$trailStartLength] = particle.length;
      particle[$trailWidthRandom] = Math.random();
    }
  }
  update(particle) {
    var _a2;
    if (((_a2 = this.system.trails) == null ? void 0 : _a2.enabled) && particle instanceof TrailParticle) {
      const trailParticle = particle;
      const age01 = particle.age / particle[$particleLife];
      const iter = particle.previous.values();
      const length = particle.previous.length;
      for (let i = 0; i < length; i++) {
        const cur = iter.next();
        const state = cur.value;
        const pos01 = 1 - i / (length - 1);
        const size = particle.size;
        if (size.x <= 0 && !this.system.trails.sizeAffectsWidth) {
          const newSize = 20 * this.system.trails.widthOverTrail.evaluate(0.5, trailParticle[$trailWidthRandom]);
          size.x = newSize;
          size.y = newSize;
          size.z = newSize;
        }
        state.size = this.system.trails.getWidth(size.x, age01, pos01, trailParticle[$trailWidthRandom]);
        state.color.copy(particle.color);
        this.system.trails.getColor(state.color, age01, pos01);
      }
      if (particle.age > particle[$particleLife]) {
        particle.velocity.set(0, 0, 0);
        const t2 = (particle.age - particle[$particleLife]) / particle[$trailLifetime];
        trailParticle.length = Mathf.lerp(particle[$trailStartLength], 0, t2);
      }
    }
  }
};
var $startVelocity = Symbol("startVelocity");
var $gravityFactor = Symbol("gravityModifier");
var $gravitySpeed = Symbol("gravitySpeed");
var $velocityLerpFactor = Symbol("velocity lerp factor");
var temp3 = new Vector32();
var temp4 = new Quaternion();
var VelocityBehaviour = class extends ParticleSystemBaseBehaviour {
  constructor() {
    super(...arguments);
    __publicField(this, "type", "NeedleVelocity");
    __publicField(this, "_gravityDirection", new Vector32());
  }
  initialize(particle) {
    var _a2, _b;
    const simulationSpeed = this.system.main.simulationSpeed;
    particle.startSpeed = this.system.main.startSpeed.evaluate(Math.random(), Math.random());
    const dir = this.system.shape.getDirection(particle, particle.position);
    particle.velocity.x = dir.x * particle.startSpeed;
    particle.velocity.y = dir.y * particle.startSpeed;
    particle.velocity.z = dir.z * particle.startSpeed;
    if ((_a2 = this.system.inheritVelocity) == null ? void 0 : _a2.enabled) {
      this.system.inheritVelocity.applyInitial(particle.velocity);
    }
    if (!particle[$startVelocity])
      particle[$startVelocity] = particle.velocity.clone();
    else
      particle[$startVelocity].copy(particle.velocity);
    const gravityFactor = this.system.main.gravityModifier.evaluate(Math.random(), Math.random());
    particle[$gravityFactor] = gravityFactor * simulationSpeed;
    particle[$gravitySpeed] = gravityFactor * simulationSpeed * 0.5;
    particle[$velocityLerpFactor] = Math.random();
    (_b = this.system.velocityOverLifetime) == null ? void 0 : _b.init(particle);
    this._gravityDirection.set(0, -1, 0);
    if (this.system.main.simulationSpace === ParticleSystemSimulationSpace.Local)
      this._gravityDirection.applyQuaternion(this.system.worldQuaternionInverted).normalize();
  }
  update(particle, delta) {
    var _a2;
    const baseVelocity = particle[$startVelocity];
    const gravityFactor = particle[$gravityFactor];
    if (gravityFactor !== 0) {
      const factor = gravityFactor * particle[$gravitySpeed];
      temp3.copy(this._gravityDirection).multiplyScalar(factor);
      particle[$gravitySpeed] += delta * 0.05;
      baseVelocity.add(temp3);
    }
    particle.velocity.copy(baseVelocity);
    const t01 = particle.age / particle.life;
    if ((_a2 = this.system.inheritVelocity) == null ? void 0 : _a2.enabled) {
      this.system.inheritVelocity.applyCurrent(particle.velocity, t01, particle[$velocityLerpFactor]);
    }
    const noise = this.system.noise;
    if (noise.enabled) {
      noise.apply(0, particle.position, particle.velocity, delta, particle.age, particle.life);
    }
    const sizeBySpeed = this.system.sizeBySpeed;
    if (sizeBySpeed == null ? void 0 : sizeBySpeed.enabled) {
      particle.size = sizeBySpeed.evaluate(particle.velocity, t01, particle[$velocityLerpFactor], particle.size);
    }
    const colorBySpeed = this.system.colorBySpeed;
    if (colorBySpeed == null ? void 0 : colorBySpeed.enabled) {
      colorBySpeed.evaluate(particle.velocity, particle[$velocityLerpFactor], particle.color);
    }
    const velocity = this.system.velocityOverLifetime;
    if (velocity.enabled) {
      velocity.apply(particle, 0, particle.position, particle.velocity, delta, particle.age, particle.life);
    }
    const limitVelocityOverLifetime = this.system.limitVelocityOverLifetime;
    if (limitVelocityOverLifetime.enabled) {
      limitVelocityOverLifetime.apply(particle.position, baseVelocity, particle.velocity, particle.size, t01, delta, 1);
    }
    if (this.system.worldspace) {
      const ws = this.system.worldScale;
      particle.velocity.x *= ws.x;
      particle.velocity.y *= ws.y;
      particle.velocity.z *= ws.z;
    }
  }
};
var $colorLerpFactor = Symbol("colorLerpFactor");
var tempColor2 = new RGBAColor(1, 1, 1, 1);
var col = new RGBAColor(1, 1, 1, 1);
var ColorBehaviour = class extends ParticleSystemBaseBehaviour {
  constructor() {
    super(...arguments);
    __publicField(this, "type", "NeedleColor");
  }
  initialize(_particle) {
  }
  _init(particle) {
    const materialColor = this.system.renderer.particleMaterial;
    col.copy(this.system.main.startColor.evaluate(Math.random()));
    if (materialColor == null ? void 0 : materialColor.color) {
      tempColor2.copy(materialColor.color);
      col.multiply(tempColor2);
    }
    col.convertLinearToSRGB();
    particle.startColor.set(col.r, col.g, col.b, col.alpha);
    particle.color.copy(particle.startColor);
    particle[$colorLerpFactor] = Math.random();
  }
  update(particle, _delta2) {
    if (particle.age === 0)
      this._init(particle);
    if (this.system.colorOverLifetime.enabled) {
      const t2 = particle.age / particle.life;
      const col2 = this.system.colorOverLifetime.color.evaluate(t2, particle[$colorLerpFactor]);
      particle.color.set(col2.r, col2.g, col2.b, "alpha" in col2 ? col2.alpha : 1).multiply(particle.startColor);
    } else {
      particle.color.copy(particle.startColor);
    }
  }
};
var ParticleSystemInterface = class {
  constructor(system) {
    __publicField(this, "system");
    __publicField(this, "emission");
    __publicField(this, "autoDestroy");
    __publicField(this, "startLength");
    /** not used - burst is controled via emissionOverTime */
    __publicField(this, "emissionBursts");
    __publicField(this, "onlyUsedByOther");
    __publicField(this, "behaviors", []);
    __publicField(this, "rendererEmitterSettings", {
      startLength: new ConstantValue(220),
      followLocalOrigin: false
    });
    __publicField(this, "flatWhiteTexture");
    __publicField(this, "clonedTexture", { original: void 0, clone: void 0 });
    this.system = system;
    this.emission = new ParticleSystemEmissionOverTime(this.system);
  }
  get anim() {
    return this.system.textureSheetAnimation;
  }
  get prewarm() {
    return false;
  }
  // force disable three.quark prewarm, we have our own!
  get material() {
    return this.system.renderer.getMaterial(this.system.trails.enabled);
  }
  get layers() {
    return this.system.gameObject.layers;
  }
  update() {
    this.emission.update();
  }
  get looping() {
    return this.system.main.loop;
  }
  get duration() {
    return this.system.duration;
  }
  get shape() {
    return this.system.shape;
  }
  get startLife() {
    return new MinMaxCurveFunction(this.system.main.startLifetime);
  }
  get startSpeed() {
    return new MinMaxCurveFunction(this.system.main.startSpeed);
  }
  get startRotation() {
    return new MinMaxCurveFunction(this.system.main.startRotation);
  }
  get startSize() {
    return new MinMaxCurveFunction(this.system.main.startSize);
  }
  /** start length is for trails */
  get startColor() {
    return new ConstantColor(new Vector42(1, 1, 1, 1));
  }
  get emissionOverTime() {
    return this.emission;
  }
  /** this is not supported yet */
  get emissionOverDistance() {
    return new ParticleSystemEmissionOverDistance(this.system);
  }
  get instancingGeometry() {
    return this.system.renderer.getMesh(this.system.renderer.renderMode).geometry;
  }
  get renderMode() {
    if (this.system.trails["enabled"] === true) {
      return RenderMode2.Trail;
    }
    switch (this.system.renderer.renderMode) {
      case ParticleSystemRenderMode.Billboard:
        return RenderMode2.BillBoard;
      case ParticleSystemRenderMode.Stretch:
        return RenderMode2.StretchedBillBoard;
      case ParticleSystemRenderMode.HorizontalBillboard:
        return RenderMode2.HorizontalBillBoard;
      case ParticleSystemRenderMode.VerticalBillboard:
        return RenderMode2.VerticalBillBoard;
      case ParticleSystemRenderMode.Mesh:
        return RenderMode2.Mesh;
    }
    return RenderMode2.BillBoard;
  }
  get speedFactor() {
    var _a2;
    let factor = this.system.main.simulationSpeed;
    if (((_a2 = this.system.renderer) == null ? void 0 : _a2.renderMode) === ParticleSystemRenderMode.Stretch) {
      factor *= this.system.renderer.velocityScale ?? 1;
    }
    return factor;
  }
  get texture() {
    const mat = this.material;
    if (mat && mat["map"]) {
      const original = mat["map"];
      if (this.clonedTexture.original !== original || !this.clonedTexture.clone) {
        const tex = original.clone();
        tex.premultiplyAlpha = false;
        tex.colorSpace = LinearSRGBColorSpace;
        this.clonedTexture.original = original;
        this.clonedTexture.clone = tex;
      }
      return this.clonedTexture.clone;
    }
    if (!this.flatWhiteTexture)
      this.flatWhiteTexture = createFlatTexture(new RGBAColor(1, 1, 1, 1), 1);
    return this.flatWhiteTexture;
  }
  get startTileIndex() {
    return new TextureSheetStartFrameGenerator(this.system);
  }
  get uTileCount() {
    var _a2;
    return this.anim.enabled ? (_a2 = this.anim) == null ? void 0 : _a2.numTilesX : void 0;
  }
  get vTileCount() {
    var _a2;
    return this.anim.enabled ? (_a2 = this.anim) == null ? void 0 : _a2.numTilesY : void 0;
  }
  get renderOrder() {
    return 1;
  }
  get blending() {
    var _a2;
    return ((_a2 = this.system.renderer.particleMaterial) == null ? void 0 : _a2.blending) ?? NormalBlending;
  }
  get transparent() {
    return this.system.renderer.transparent;
  }
  get worldSpace() {
    return this.system.main.simulationSpace === ParticleSystemSimulationSpace.World;
  }
};
var ParticlesEmissionState = class {
  constructor() {
    __publicField(this, "burstParticleIndex", 0);
    __publicField(this, "burstParticleCount", 0);
    __publicField(this, "isBursting", false);
    __publicField(this, "travelDistance", 0);
    __publicField(this, "previousWorldPos");
    __publicField(this, "burstIndex", 0);
    __publicField(this, "burstWaveIndex", 0);
    __publicField(this, "time", 0);
    __publicField(this, "waitEmiting", 0);
  }
};
var ParticleSystem2 = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "_state");
    __publicField(this, "colorOverLifetime");
    __publicField(this, "main");
    __publicField(this, "emission");
    __publicField(this, "sizeOverLifetime");
    __publicField(this, "shape");
    __publicField(this, "noise");
    __publicField(this, "trails");
    __publicField(this, "velocityOverLifetime");
    __publicField(this, "limitVelocityOverLifetime");
    __publicField(this, "inheritVelocity");
    __publicField(this, "colorBySpeed");
    __publicField(this, "textureSheetAnimation");
    __publicField(this, "rotationOverLifetime");
    __publicField(this, "rotationBySpeed");
    __publicField(this, "sizeBySpeed");
    __publicField(this, "_cameraScale", 1);
    __publicField(this, "__worldQuaternion", new Quaternion());
    __publicField(this, "_worldQuaternionInverted", new Quaternion());
    __publicField(this, "_worldScale", new Vector32());
    __publicField(this, "_worldPositionFrame", -1);
    __publicField(this, "_worldPos", new Vector32());
    __publicField(this, "_renderer");
    __publicField(this, "_batchSystem");
    __publicField(this, "_particleSystem");
    __publicField(this, "_interface");
    // private _system!: System;
    // private _emitter: Emitter;
    // private _size!: SizeBehaviour;
    __publicField(this, "_container");
    __publicField(this, "_time", 0);
    __publicField(this, "_isPlaying", true);
    __publicField(this, "_isUsedAsSubsystem", false);
    __publicField(this, "_didPreWarm", false);
    __publicField(this, "_bursts");
    __publicField(this, "_subEmitterSystems");
    __publicField(this, "_lastBatchesCount", -1);
    __publicField(this, "lastMaterialVersion", -1);
  }
  play(includeChildren = false) {
    var _a2;
    if (includeChildren) {
      GameObject.foreachComponent(this.gameObject, (comp) => {
        if (comp instanceof ParticleSystem2 && comp !== this) {
          comp.play(false);
        }
      }, true);
    }
    this._isPlaying = true;
    if (this._particleSystem) {
      this._particleSystem["emissionState"].time = 0;
      this._particleSystem["emitEnded"] = false;
    }
    (_a2 = this.emission) == null ? void 0 : _a2.reset();
  }
  pause(includeChildren = true) {
    if (includeChildren) {
      GameObject.foreachComponent(this.gameObject, (comp) => {
        if (comp instanceof ParticleSystem2 && comp !== this) {
          comp.pause(false);
        }
      }, true);
    }
    this._isPlaying = false;
  }
  /** clear=true removes all emitted particles */
  stop(includeChildren = true, clear = false) {
    if (includeChildren) {
      GameObject.foreachComponent(this.gameObject, (comp) => {
        if (comp instanceof ParticleSystem2 && comp !== this) {
          comp.stop(false, clear);
        }
      }, true);
    }
    this._isPlaying = false;
    this._time = 0;
    if (clear)
      this.reset();
  }
  /** remove emitted particles and reset time */
  reset() {
    var _a2;
    this._time = 0;
    if (this._particleSystem) {
      this._particleSystem.particleNum = 0;
      this._particleSystem["emissionState"].time = 0;
      this._particleSystem["emitEnded"] = false;
      (_a2 = this.emission) == null ? void 0 : _a2.reset();
    }
  }
  emit(count) {
    if (this._particleSystem) {
      this.onUpdate();
      count = Math.min(count, this.maxParticles - this.currentParticles);
      if (!this._state)
        this._state = new ParticlesEmissionState();
      this._state.waitEmiting = count;
      this._state.time = 0;
      const emitEndedState = this._particleSystem["emitEnded"];
      this._particleSystem["emitEnded"] = false;
      this._particleSystem.emit(this.deltaTime, this._state, this._particleSystem.emitter.matrixWorld);
      this._particleSystem["emitEnded"] = emitEndedState;
    }
  }
  get playOnAwake() {
    return this.main.playOnAwake;
  }
  set playOnAwake(val) {
    this.main.playOnAwake = val;
  }
  get renderer() {
    return this._renderer;
  }
  get isPlaying() {
    return this._isPlaying;
  }
  get currentParticles() {
    var _a2;
    return ((_a2 = this._particleSystem) == null ? void 0 : _a2.particleNum) ?? 0;
  }
  get maxParticles() {
    return this.main.maxParticles;
  }
  get time() {
    return this._time;
  }
  get duration() {
    return this.main.duration;
  }
  get deltaTime() {
    return this.context.time.deltaTime * this.main.simulationSpeed;
  }
  get scale() {
    return this.gameObject.scale.x;
  }
  get cameraScale() {
    return this._cameraScale;
  }
  get container() {
    return this._container;
  }
  get worldspace() {
    return this.main.simulationSpace === ParticleSystemSimulationSpace.World;
  }
  get localspace() {
    return this.main.simulationSpace === ParticleSystemSimulationSpace.Local;
  }
  get worldQuaternion() {
    return this.__worldQuaternion;
  }
  get worldQuaternionInverted() {
    return this._worldQuaternionInverted;
  }
  get worldScale() {
    return this._worldScale;
  }
  get worldPos() {
    if (this._worldPositionFrame !== this.context.time.frame) {
      this._worldPositionFrame = this.context.time.frame;
      getWorldPosition(this.gameObject, this._worldPos);
    }
    return this._worldPos;
  }
  get matrixWorld() {
    return this._container.matrixWorld;
  }
  get isSubsystem() {
    return this._isUsedAsSubsystem;
  }
  /** Add a custom quarks behaviour to the particle system.
   * You can add a quarks.Behaviour type or derive from {@link ParticleSystemBaseBehaviour}
   * @link https://github.com/Alchemist0823/three.quarks
   * @example
   * ```typescript
   * class MyBehaviour extends ParticleSystemBaseBehaviour {
   *    initialize(particle: Particle) {
   *       // initialize the particle
   *   }
   *    update(particle: Particle, delta: number) {
   *        // do something with the particle
   *   }
   * }
   *
   * const system = gameObject.getComponent(ParticleSystem);
   * system.addBehaviour(new MyBehaviour());
   * ```
  */
  addBehaviour(particleSystemBehaviour) {
    if (!this._particleSystem) {
      return false;
    }
    if (particleSystemBehaviour instanceof ParticleSystemBaseBehaviour) {
      particleSystemBehaviour.system = this;
    }
    if (isDevEnvironment())
      console.log("add behaviour", particleSystemBehaviour);
    this._particleSystem.addBehavior(particleSystemBehaviour);
    return true;
  }
  /** Remove a custom quarks behaviour from the particle system. **/
  removeBehaviour(particleSystemBehaviour) {
    if (!this._particleSystem) {
      return false;
    }
    const behaviours = this._particleSystem.behaviors;
    const index = behaviours.indexOf(particleSystemBehaviour);
    if (index !== -1) {
      behaviours.splice(index, 1);
      return true;
    }
    return true;
  }
  /** Removes all behaviours from the particle system
   * **Note:** this will also remove the default behaviours like SizeBehaviour, ColorBehaviour etc.
   */
  removeAllBehaviours() {
    if (!this._particleSystem) {
      return false;
    }
    this._particleSystem.behaviors.length = 0;
    return true;
  }
  /** Get the underlying three.quarks particle system behaviours. This can be used to fully customize the behaviour of the particles. */
  get behaviours() {
    if (!this._particleSystem)
      return null;
    return this._particleSystem.behaviors;
  }
  /** Get access to the underlying quarks particle system if you need more control
   * @link https://github.com/Alchemist0823/three.quarks
   */
  get particleSystem() {
    return this._particleSystem ?? null;
  }
  /** called from deserialization */
  set bursts(arr) {
    for (let i = 0; i < arr.length; i++) {
      const burst = arr[i];
      if (burst instanceof ParticleBurst === false) {
        const instance = new ParticleBurst();
        assign(instance, burst);
        arr[i] = instance;
      }
    }
    this._bursts = arr;
  }
  /** called from deserialization */
  set subEmitterSystems(arr) {
    for (let i = 0; i < arr.length; i++) {
      const sub = arr[i];
      if (sub instanceof SubEmitterSystem === false) {
        const instance = new SubEmitterSystem();
        assign(instance, sub);
        arr[i] = instance;
      }
    }
    if (debug98 && arr.length > 0) {
      console.log("SubEmitters: ", arr, this);
    }
    this._subEmitterSystems = arr;
  }
  /** @internal */
  onAfterDeserialize(_) {
    if (this._subEmitterSystems && Array.isArray(this._subEmitterSystems)) {
      for (const sub of this._subEmitterSystems) {
        sub._deserialize(this.context, this.gameObject);
      }
    }
  }
  /** @internal */
  awake() {
    this._worldPositionFrame = -1;
    this._renderer = this.gameObject.getComponent(ParticleSystemRenderer);
    if (!this.main) {
      throw new Error("Not Supported: ParticleSystem needs a serialized MainModule. Creating new particle systems at runtime is currently not supported.");
    }
    this._container = new Object3D();
    this._container.matrixAutoUpdate = false;
    {
      this.context.scene.add(this._container);
    }
    this._batchSystem = new BatchedParticleRenderer();
    this._batchSystem.name = this.gameObject.name;
    this._container.add(this._batchSystem);
    this._interface = new ParticleSystemInterface(this);
    this._particleSystem = new ParticleSystem(this._interface);
    this._particleSystem.addBehavior(new SizeBehaviour(this));
    this._particleSystem.addBehavior(new ColorBehaviour(this));
    this._particleSystem.addBehavior(new TextureSheetAnimationBehaviour(this));
    this._particleSystem.addBehavior(new RotationBehaviour(this));
    this._particleSystem.addBehavior(new VelocityBehaviour(this));
    this._particleSystem.addBehavior(new TrailBehaviour(this));
    this._batchSystem.addSystem(this._particleSystem);
    const emitter = this._particleSystem.emitter;
    this.context.scene.add(emitter);
    if (this.inheritVelocity.system && this.inheritVelocity.system !== this) {
      this.inheritVelocity = this.inheritVelocity.clone();
    }
    this.inheritVelocity.awake(this);
    if (debug98) {
      console.log(this);
      this.gameObject.add(new AxesHelper(1));
    }
  }
  /** @internal */
  start() {
    this.addSubParticleSystems();
    this.updateLayers();
    if (this.renderer.particleMesh instanceof Mesh && this._interface.renderMode == RenderMode2.Mesh) {
      NEEDLE_progressive.assignMeshLOD(this.renderer.particleMesh, 0).then((geo) => {
        if (geo && this.particleSystem && this._interface.renderMode == RenderMode2.Mesh) {
          this.particleSystem.instancingGeometry = geo;
        }
      });
    }
  }
  /** @internal */
  onDestroy() {
    var _a2, _b, _c, _d;
    (_a2 = this._container) == null ? void 0 : _a2.removeFromParent();
    (_b = this._batchSystem) == null ? void 0 : _b.removeFromParent();
    (_c = this._particleSystem) == null ? void 0 : _c.emitter.removeFromParent();
    (_d = this._particleSystem) == null ? void 0 : _d.dispose();
  }
  /** @internal */
  onEnable() {
    if (!this.main)
      return;
    if (this.inheritVelocity)
      this.inheritVelocity.system = this;
    if (this._batchSystem)
      this._batchSystem.visible = true;
    if (this.playOnAwake)
      this.play();
    this._isPlaying = this.playOnAwake;
  }
  onDisable() {
    if (this._batchSystem)
      this._batchSystem.visible = false;
  }
  /** @internal */
  onBeforeRender() {
    var _a2;
    if (!this.main)
      return;
    if (this._didPreWarm === false && ((_a2 = this.main) == null ? void 0 : _a2.prewarm) === true) {
      this._didPreWarm = true;
      this.preWarm();
    }
    this.onUpdate();
    this.onSimulate(this.deltaTime);
  }
  preWarm() {
    var _a2;
    if (!((_a2 = this.emission) == null ? void 0 : _a2.enabled))
      return;
    const emission = this.emission.rateOverTime.getMax();
    if (emission <= 0)
      return;
    const dt = 1 / 60;
    const duration = this.main.duration;
    const lifetime = this.main.startLifetime.getMax();
    const maxDurationToPrewarm = 1e3;
    const timeToSimulate = Math.min(Math.max(duration, lifetime) / Math.max(0.01, this.main.simulationSpeed), maxDurationToPrewarm);
    const framesToSimulate = Math.ceil(timeToSimulate / dt);
    const startTime = Date.now();
    if (debug98)
      console.log(`Particles ${this.name} - Prewarm for ${framesToSimulate} frames (${timeToSimulate} sec). Duration: ${duration}, Lifetime: ${lifetime}`);
    for (let i = 0; i < framesToSimulate; i++) {
      if (this.currentParticles >= this.maxParticles)
        break;
      const timePassed = Date.now() - startTime;
      if (timePassed > 2e3) {
        console.warn(`Particles ${this.name} - Prewarm took too long. Aborting: ${timePassed}`);
        break;
      }
      this.onUpdate();
      this.onSimulate(dt);
    }
  }
  onSimulate(dt) {
    if (this._batchSystem) {
      let needsUpdate = this.context.time.frameCount % 60 === 0;
      if (this._lastBatchesCount !== this._batchSystem.batches.length) {
        this._lastBatchesCount = this._batchSystem.batches.length;
        needsUpdate = true;
      }
      if (needsUpdate) {
        this.updateLayers();
      }
      this._batchSystem.update(dt);
    }
    this._time += dt;
    if (this._time > this.duration)
      this._time = 0;
  }
  updateLayers() {
    if (this._batchSystem) {
      for (let i = 0; i < this._batchSystem.batches.length; i++) {
        const batch = this._batchSystem.batches[i];
        batch.layers.disableAll();
        const layer = this.layer;
        batch.layers.mask = 1 << layer;
      }
    }
  }
  onUpdate() {
    var _a2, _b;
    const mat = this.renderer.getMaterial(this.trails.enabled);
    if (mat && mat.version != this.lastMaterialVersion && this._particleSystem) {
      this.lastMaterialVersion = mat.version;
      this._particleSystem.texture = this._interface.texture;
    }
    if (this._bursts) {
      this.emission.bursts = this._bursts;
      delete this._bursts;
    }
    if (!this._isPlaying)
      return;
    const cam = this.context.mainCamera;
    if (cam) {
      const scale = getWorldScale(cam);
      this._cameraScale = scale.x;
    }
    const isLocalSpace = !this.worldspace;
    const source = this.gameObject;
    getWorldQuaternion(source, this.__worldQuaternion);
    this._worldQuaternionInverted.copy(this.__worldQuaternion).invert();
    getWorldScale(this.gameObject, this._worldScale);
    if (isLocalSpace && this._container && ((_a2 = this.gameObject) == null ? void 0 : _a2.parent)) {
      const scale = getLocalSimulationScale(this, temp3);
      this._container.matrix.makeScale(scale.x, scale.y, scale.z);
      this._container.matrix.makeRotationFromQuaternion(this.__worldQuaternion);
      this._container.matrix.setPosition(this.worldPos);
      this._container.matrix.scale(this.gameObject.scale);
    }
    this.emission.system = this;
    this._interface.update();
    this.shape.onUpdate(this, this.context, this.main.simulationSpace, this.gameObject);
    this.noise.update(this.context);
    (_b = this.inheritVelocity) == null ? void 0 : _b.update(this.context);
    this.velocityOverLifetime.update(this);
  }
  addSubParticleSystems() {
    var _a2;
    if (this._subEmitterSystems && this._particleSystem) {
      for (const sys of this._subEmitterSystems) {
        if (sys.particleSystem) {
          if (sys.particleSystem.__internalAwake)
            sys.particleSystem.__internalAwake();
          else if (isDevEnvironment())
            console.warn("SubParticleSystem serialization issue(?)", sys.particleSystem, sys);
        }
        const system = (_a2 = sys.particleSystem) == null ? void 0 : _a2._particleSystem;
        if (system) {
          sys.particleSystem._isUsedAsSubsystem = true;
          const sub = new ParticleSubEmitter(this, this._particleSystem, sys.particleSystem, system);
          sub.emitterType = sys.type;
          sub.emitterProbability = sys.emitProbability;
          this._particleSystem.addBehavior(sub);
        } else if (debug98)
          console.warn("Could not add SubParticleSystem", sys, this);
      }
    }
  }
};
__decorate71([
  serializable(ColorOverLifetimeModule)
], ParticleSystem2.prototype, "colorOverLifetime", void 0);
__decorate71([
  serializable(MainModule)
], ParticleSystem2.prototype, "main", void 0);
__decorate71([
  serializable(EmissionModule)
], ParticleSystem2.prototype, "emission", void 0);
__decorate71([
  serializable(SizeOverLifetimeModule)
], ParticleSystem2.prototype, "sizeOverLifetime", void 0);
__decorate71([
  serializable(ShapeModule)
], ParticleSystem2.prototype, "shape", void 0);
__decorate71([
  serializable(NoiseModule)
], ParticleSystem2.prototype, "noise", void 0);
__decorate71([
  serializable(TrailModule)
], ParticleSystem2.prototype, "trails", void 0);
__decorate71([
  serializable(VelocityOverLifetimeModule)
], ParticleSystem2.prototype, "velocityOverLifetime", void 0);
__decorate71([
  serializable(LimitVelocityOverLifetimeModule)
], ParticleSystem2.prototype, "limitVelocityOverLifetime", void 0);
__decorate71([
  serializable(InheritVelocityModule)
], ParticleSystem2.prototype, "inheritVelocity", void 0);
__decorate71([
  serializable(ColorBySpeedModule)
], ParticleSystem2.prototype, "colorBySpeed", void 0);
__decorate71([
  serializable(TextureSheetAnimationModule)
], ParticleSystem2.prototype, "textureSheetAnimation", void 0);
__decorate71([
  serializable(RotationOverLifetimeModule)
], ParticleSystem2.prototype, "rotationOverLifetime", void 0);
__decorate71([
  serializable(RotationBySpeedModule)
], ParticleSystem2.prototype, "rotationBySpeed", void 0);
__decorate71([
  serializable(SizeBySpeedModule)
], ParticleSystem2.prototype, "sizeBySpeed", void 0);
var SubEmitterSystem = class {
  constructor() {
    __publicField(this, "particleSystem");
    __publicField(this, "emitProbability", 1);
    __publicField(this, "properties");
    __publicField(this, "type");
  }
  _deserialize(_context, gameObject) {
    const ps = this.particleSystem;
    if (ps instanceof ParticleSystem2)
      return;
    let guid = "";
    if (ps && typeof ps["guid"] === "string") {
      guid = ps["guid"];
      this.particleSystem = GameObject.findByGuid(guid, gameObject);
    }
    if (debug98 && !(this.particleSystem instanceof ParticleSystem2)) {
      console.warn("Could not find particle system for sub emitter", guid, gameObject, this);
    }
  }
};
function getLocalSimulationScale(system, vec2) {
  vec2.set(1, 1, 1);
  if (system.gameObject.parent && system.localspace) {
    switch (system.main.scalingMode) {
      case ParticleSystemScalingMode.Local:
        vec2 = getWorldScale(system.gameObject.parent, vec2);
        vec2.x = 1 / vec2.x;
        vec2.y = 1 / vec2.y;
        vec2.z = 1 / vec2.z;
        break;
      default:
        if (!system["unsupported_scaling_mode"]) {
          system["unsupported_scaling_mode"] = true;
          const msg = "ParticleSystem scale mode " + ParticleSystemScalingMode[system.main.scalingMode] + " is not supported";
          if (isDevEnvironment())
            showBalloonWarning(msg);
          console.warn(msg, system.name, system);
        }
        vec2 = getWorldScale(system.gameObject, vec2);
        break;
    }
  }
  return vec2;
}

// node_modules/@needle-tools/engine/lib/engine-components/particlesystem/ParticleSystemSubEmitter.js
var VECTOR_ONE2 = new Vector32(1, 1, 1);
var VECTOR_Z2 = new Vector32(0, 0, 1);
var $emitterMatrix = Symbol("emitterMatrix");
var ParticleSubEmitter = class {
  constructor(system, particleSystem, subSystem, subParticleSystem) {
    __publicField(this, "system");
    __publicField(this, "particleSystem");
    __publicField(this, "subSystem");
    __publicField(this, "subParticleSystem");
    __publicField(this, "type", "NeedleParticleSubEmitter");
    __publicField(this, "emitterType");
    __publicField(this, "emitterProbability");
    //private matrix_ = new Matrix4();
    __publicField(this, "q_", new Quaternion());
    __publicField(this, "v_", new Vector32());
    __publicField(this, "v2_", new Vector32());
    __publicField(this, "_emitterMatrix", new Matrix42());
    __publicField(this, "_circularBuffer");
    this.system = system;
    this.particleSystem = particleSystem;
    this.subSystem = subSystem;
    this.subParticleSystem = subParticleSystem;
    if (this.subParticleSystem && this.subParticleSystem) {
      this.subParticleSystem.onlyUsedByOther = true;
    }
    const maxMatrices = 1e3;
    this._circularBuffer = new CircularBuffer(() => new Matrix42(), maxMatrices);
  }
  clone() {
    throw new Error("Method not implemented.");
  }
  initialize(particle) {
    particle.emissionState = {
      burstIndex: 0,
      burstWaveIndex: 0,
      time: 0,
      waitEmiting: 0
      // matrix: new Matrix4(),
    };
    this._emitterMatrix.copy(this.subSystem.matrixWorld).invert().premultiply(this.system.matrixWorld);
    this._emitterMatrix.setPosition(0, 0, 0);
    if (this.emitterType === SubEmitterType.Birth) {
      this.run(particle);
    }
  }
  update(particle, _delta2) {
    this.run(particle);
  }
  frameUpdate(_delta2) {
  }
  toJSON() {
  }
  reset() {
  }
  run(particle) {
    if (this.subSystem.currentParticles >= this.subSystem.main.maxParticles)
      return;
    if (!this.subParticleSystem || !particle.emissionState)
      return;
    if (this.emitterProbability && Math.random() > this.emitterProbability)
      return;
    const delta = this.system.deltaTime;
    if (this.emitterType === SubEmitterType.Death) {
      let lifeTime = particle.life;
      if (particle[$particleLife] !== void 0)
        lifeTime = particle[$particleLife];
      const willDie = particle.age + delta * 1.2 >= lifeTime;
      if (!willDie)
        return;
      const maxAmount = this.subSystem.main.maxParticles - this.subSystem.currentParticles;
      particle.emissionState.waitEmiting = maxAmount;
    }
    const m2 = new Matrix42();
    m2.set(1, 0, 0, particle.position.x, 0, 1, 0, particle.position.y, 0, 0, 1, particle.position.z, 0, 0, 0, 1);
    if (!this.particleSystem.worldSpace) {
      m2.multiplyMatrices(this._emitterMatrix, m2);
    }
    this.subParticleSystem.emit(delta, particle.emissionState, m2);
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/postprocessing/Effects/Pixelation.js
var __decorate72 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var PixelationEffect2 = class extends PostProcessingEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "granularity", new VolumeParameter(10));
  }
  get typeName() {
    return "PixelationEffect";
  }
  onCreateEffect() {
    const effect = new PixelationEffect();
    this.granularity.onValueChanged = (v4) => {
      effect.granularity = v4;
    };
    return effect;
  }
};
__decorate72([
  serializable(VolumeParameter)
], PixelationEffect2.prototype, "granularity", void 0);
registerCustomEffectType("PixelationEffect", PixelationEffect2);

// node_modules/@needle-tools/engine/lib/engine-components/PlayerColor.js
var PlayerColor = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "_didAssignPlayerColor", false);
    __publicField(this, "tryAssignColor", () => {
      const marker = GameObject.getComponentInParent(this.gameObject, PlayerState);
      if (marker && marker.owner) {
        this._didAssignPlayerColor = true;
        this.assignUserColor(marker.owner);
        return true;
      }
      const avatar = GameObject.getComponentInParent(this.gameObject, AvatarMarker);
      if (avatar == null ? void 0 : avatar.connectionId) {
        this._didAssignPlayerColor = true;
        this.assignUserColor(avatar.connectionId);
        return true;
      }
      return false;
    });
  }
  onEnable() {
    this.context.connection.beginListen(RoomEvents.JoinedRoom, this.tryAssignColor);
    if (!this._didAssignPlayerColor)
      this.startCoroutine(this.waitForConnection());
  }
  onDisable() {
    this.context.connection.stopListen(RoomEvents.JoinedRoom, this.tryAssignColor);
  }
  *waitForConnection() {
    while (!this.destroyed && this.activeAndEnabled) {
      yield WaitForSeconds(0.2);
      if (this.tryAssignColor())
        break;
    }
  }
  assignUserColor(id) {
    const hash = PlayerColor.hashCode(id);
    const color2 = PlayerColor.colorFromHashCode(hash);
    if (this.gameObject.type === "Mesh") {
      const mesh = this.gameObject;
      this.assignColor(color2, id, mesh);
    } else if (this.gameObject.children) {
      for (const ch of this.gameObject.children) {
        const obj = ch;
        if (obj.material && obj.material.color) {
          this.assignColor(color2, id, obj);
        }
      }
    }
  }
  assignColor(col2, id, mesh) {
    let mat = mesh.material;
    if (!mat)
      return;
    if (mat["_playerMaterial"] !== id) {
      mat = mat.clone();
      mat["_playerMaterial"] = id;
      mesh.material = mat;
    }
    mat["color"] = col2;
  }
  static hashCode(str) {
    var hash = 0, i, chr;
    if (str.length === 0)
      return hash;
    for (i = 0; i < str.length; i++) {
      chr = str.charCodeAt(i);
      hash = (hash << 5) - hash + chr;
      hash |= 0;
    }
    return hash;
  }
  static colorFromHashCode(hash) {
    const r = (hash & 16711680) >> 16;
    const g3 = (hash & 65280) >> 8;
    const b = hash & 255;
    return new Color(r / 255, g3 / 255, b / 255);
  }
};

// node_modules/three/examples/jsm/postprocessing/Pass.js
var _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
var FullscreenTriangleGeometry = class extends BufferGeometry {
  constructor() {
    super();
    this.setAttribute("position", new Float32BufferAttribute2([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
    this.setAttribute("uv", new Float32BufferAttribute2([0, 2, 0, 0, 2, 0], 2));
  }
};
var _geometry = new FullscreenTriangleGeometry();

// node_modules/n8ao/dist/N8AO.js
var $e4ca8dcb0218f846$var$_geometry = new BufferGeometry();
$e4ca8dcb0218f846$var$_geometry.setAttribute("position", new BufferAttribute2(new Float32Array([
  -1,
  -1,
  3,
  -1,
  -1,
  3
]), 2));
$e4ca8dcb0218f846$var$_geometry.setAttribute("uv", new BufferAttribute2(new Float32Array([
  0,
  0,
  2,
  0,
  0,
  2
]), 2));
$e4ca8dcb0218f846$var$_geometry.boundingSphere = new Sphere();
$e4ca8dcb0218f846$var$_geometry.computeBoundingSphere = function() {
};
var $e4ca8dcb0218f846$var$_camera = new OrthographicCamera();
var $e4ca8dcb0218f846$export$dcd670d73db751f5 = class {
  constructor(material) {
    this._mesh = new Mesh($e4ca8dcb0218f846$var$_geometry, material);
    this._mesh.frustumCulled = false;
  }
  render(renderer) {
    renderer.render(this._mesh, $e4ca8dcb0218f846$var$_camera);
  }
  get material() {
    return this._mesh.material;
  }
  set material(value) {
    this._mesh.material = value;
  }
  dispose() {
    this._mesh.material.dispose();
    this._mesh.geometry.dispose();
  }
};
var $1ed45968c1160c3c$export$c9b263b9a17dffd7 = {
  uniforms: {
    "sceneDiffuse": {
      value: null
    },
    "sceneDepth": {
      value: null
    },
    "sceneNormal": {
      value: null
    },
    "projMat": {
      value: new Matrix4()
    },
    "viewMat": {
      value: new Matrix4()
    },
    "projViewMat": {
      value: new Matrix4()
    },
    "projectionMatrixInv": {
      value: new Matrix4()
    },
    "viewMatrixInv": {
      value: new Matrix4()
    },
    "cameraPos": {
      value: new Vector32()
    },
    "resolution": {
      value: new Vector2()
    },
    "biasAdjustment": {
      value: new Vector2()
    },
    "time": {
      value: 0
    },
    "samples": {
      value: []
    },
    "bluenoise": {
      value: null
    },
    "distanceFalloff": {
      value: 1
    },
    "radius": {
      value: 5
    },
    "near": {
      value: 0.1
    },
    "far": {
      value: 1e3
    },
    "logDepth": {
      value: false
    },
    "ortho": {
      value: false
    },
    "screenSpaceRadius": {
      value: false
    },
    "frame": {
      value: 0
    }
  },
  depthWrite: false,
  depthTest: false,
  vertexShader: (
    /* glsl */
    `
varying vec2 vUv;
void main() {
  vUv = uv;
  gl_Position = vec4(position, 1);
}`
  ),
  fragmentShader: (
    /* glsl */
    `
    #define SAMPLES 16
    #define FSAMPLES 16.0
uniform sampler2D sceneDiffuse;
uniform highp sampler2D sceneNormal;
uniform highp sampler2D sceneDepth;
uniform mat4 projectionMatrixInv;
uniform mat4 viewMatrixInv;
uniform mat4 projMat;
uniform mat4 viewMat;
uniform mat4 projViewMat;
uniform vec3 cameraPos;
uniform vec2 resolution;
uniform vec2 biasAdjustment;
uniform float time;
uniform vec3[SAMPLES] samples;
uniform float radius;
uniform float distanceFalloff;
uniform float near;
uniform float far;
uniform float frame;
uniform bool logDepth;
uniform bool ortho;
uniform bool screenSpaceRadius;
uniform sampler2D bluenoise;
    varying vec2 vUv;
    highp float linearize_depth(highp float d, highp float zNear,highp float zFar)
    {
        return (zFar * zNear) / (zFar - d * (zFar - zNear));
    }
    highp float linearize_depth_ortho(highp float d, highp float nearZ, highp float farZ) {
      return nearZ + (farZ - nearZ) * d;
    }
    highp float linearize_depth_log(highp float d, highp float nearZ,highp float farZ) {
      float depth = pow(2.0, d * log2(farZ + 1.0)) - 1.0;
      float a = farZ / (farZ - nearZ);
      float b = farZ * nearZ / (nearZ - farZ);
      float linDepth = a + b / depth;
      /*return ortho ? linearize_depth_ortho(
        linDepth,
        nearZ,
        farZ
      ) :linearize_depth(linDepth, nearZ, farZ);*/
       #ifdef ORTHO

       return linearize_depth_ortho(d, nearZ, farZ);

        #else
        return linearize_depth(linDepth, nearZ, farZ);
        #endif
    }

    vec3 getWorldPosLog(vec3 posS) {
      vec2 uv = posS.xy;
      float z = posS.z;
      float nearZ =near;
      float farZ = far;
      float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;
      float a = farZ / (farZ - nearZ);
      float b = farZ * nearZ / (nearZ - farZ);
      float linDepth = a + b / depth;
      vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;
      vec4 wpos = projectionMatrixInv * clipVec;
      return wpos.xyz / wpos.w;
    }
    vec3 getWorldPos(float depth, vec2 coord) {
      #ifdef LOGDEPTH
        #ifndef ORTHO
          return getWorldPosLog(vec3(coord, depth));
        #endif
      #endif
      float z = depth * 2.0 - 1.0;
      vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);
      vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;
      // Perspective division
     vec4 worldSpacePosition = viewSpacePosition;
     worldSpacePosition.xyz /= worldSpacePosition.w;
      return worldSpacePosition.xyz;
  }

  vec3 computeNormal(vec3 worldPos, vec2 vUv) {
    ivec2 p = ivec2(vUv * resolution);
    float c0 = texelFetch(sceneDepth, p, 0).x;
    float l2 = texelFetch(sceneDepth, p - ivec2(2, 0), 0).x;
    float l1 = texelFetch(sceneDepth, p - ivec2(1, 0), 0).x;
    float r1 = texelFetch(sceneDepth, p + ivec2(1, 0), 0).x;
    float r2 = texelFetch(sceneDepth, p + ivec2(2, 0), 0).x;
    float b2 = texelFetch(sceneDepth, p - ivec2(0, 2), 0).x;
    float b1 = texelFetch(sceneDepth, p - ivec2(0, 1), 0).x;
    float t1 = texelFetch(sceneDepth, p + ivec2(0, 1), 0).x;
    float t2 = texelFetch(sceneDepth, p + ivec2(0, 2), 0).x;

    float dl = abs((2.0 * l1 - l2) - c0);
    float dr = abs((2.0 * r1 - r2) - c0);
    float db = abs((2.0 * b1 - b2) - c0);
    float dt = abs((2.0 * t1 - t2) - c0);

    vec3 ce = getWorldPos(c0, vUv).xyz;

    vec3 dpdx = (dl < dr) ? ce - getWorldPos(l1, (vUv - vec2(1.0 / resolution.x, 0.0))).xyz
                          : -ce + getWorldPos(r1, (vUv + vec2(1.0 / resolution.x, 0.0))).xyz;
    vec3 dpdy = (db < dt) ? ce - getWorldPos(b1, (vUv - vec2(0.0, 1.0 / resolution.y))).xyz
                          : -ce + getWorldPos(t1, (vUv + vec2(0.0, 1.0 / resolution.y))).xyz;

    return normalize(cross(dpdx, dpdy));
}

mat3 makeRotationZ(float theta) {
	float c = cos(theta);
	float s = sin(theta);
	return mat3(c, - s, 0,
			s,  c, 0,
			0,  0, 1);
  }

void main() {
      vec4 diffuse = texture2D(sceneDiffuse, vUv);
      float depth = texture2D(sceneDepth, vUv).x;
      if (depth == 1.0) {
        gl_FragColor = vec4(vec3(1.0), 1.0);
        return;
      }
      vec3 worldPos = getWorldPos(depth, vUv);
      #ifdef HALFRES
        vec3 normal = texture2D(sceneNormal, vUv).rgb;
      #else
        vec3 normal = computeNormal(worldPos, vUv);
      #endif
      vec4 noise = texture2D(bluenoise, gl_FragCoord.xy / 128.0);
      vec2 harmoniousNumbers = vec2(
        1.618033988749895,
        1.324717957244746
      );
      noise.rg += harmoniousNumbers * frame;
      noise.rg = fract(noise.rg);
        vec3 helperVec = vec3(0.0, 1.0, 0.0);
        if (dot(helperVec, normal) > 0.99) {
          helperVec = vec3(1.0, 0.0, 0.0);
        }
        vec3 tangent = normalize(cross(helperVec, normal));
        vec3 bitangent = cross(normal, tangent);
        mediump mat3 tbn = mat3(tangent, bitangent, normal) *  makeRotationZ( noise.r * 3.1415962 * 2.0) ;

      mediump float occluded = 0.0;
      mediump float totalWeight = 0.0;
      float radiusToUse = screenSpaceRadius ? distance(
        worldPos,
        getWorldPos(depth, vUv +
          vec2(radius, 0.0) / resolution)
      ) : radius;
      float distanceFalloffToUse =screenSpaceRadius ?
          radiusToUse * distanceFalloff
      : radiusToUse * distanceFalloff * 0.2;
      float bias = (min(
        0.1,
        distanceFalloffToUse * 0.1
      ) / near) * fwidth(distance(worldPos, cameraPos)) / radiusToUse;
      bias = biasAdjustment.x + biasAdjustment.y * bias;
      mediump float offsetMove = noise.g;
      mediump float offsetMoveInv = 1.0 / FSAMPLES;
      float farTimesNear = far * near;
      float farMinusNear = far - near;
      
      for(int i = 0; i < SAMPLES; i++) {
        mediump vec3 sampleDirection = tbn * samples[i];

        float moveAmt = fract(offsetMove);
        offsetMove += offsetMoveInv;
        vec3 samplePos = worldPos + radiusToUse * moveAmt * sampleDirection;
        vec4 offset = projMat * vec4(samplePos, 1.0);
        offset.xyz /= offset.w;
        offset.xyz = offset.xyz * 0.5 + 0.5;
        
        if (all(greaterThan(offset.xyz * (1.0 - offset.xyz), vec3(0.0)))) {
          float sampleDepth = textureLod(sceneDepth, offset.xy, 0.0).x;

          /*#ifdef LOGDEPTH
          float distSample = linearize_depth_log(sampleDepth, near, far);
      #else
          #ifdef ORTHO
              float distSample = near + farMinusNear * sampleDepth;
          #else
              float distSample = (farTimesNear) / (far - sampleDepth * farMinusNear);
          #endif
      #endif*/
      #ifdef ORTHO
          float distSample = near + sampleDepth * farMinusNear;
      #else
          #ifdef LOGDEPTH
              float distSample = linearize_depth_log(sampleDepth, near, far);
          #else
              float distSample = (farTimesNear) / (far - sampleDepth * farMinusNear);
          #endif
      #endif
      
      #ifdef ORTHO
          float distWorld = near + offset.z * farMinusNear;
      #else
          float distWorld = (farTimesNear) / (far - offset.z * farMinusNear);
      #endif
          
          mediump float rangeCheck = smoothstep(0.0, 1.0, distanceFalloffToUse / (abs(distSample - distWorld)));
          vec2 diff = gl_FragCoord.xy - floor(offset.xy * resolution);
          occluded += rangeCheck * float(distSample != distWorld) * float(sampleDepth != depth) * step(distSample + bias, distWorld) * step(
            1.0,
            dot(diff, diff)
          );
          
          totalWeight ++;
        }
      }
      float occ = clamp(1.0 - occluded / (totalWeight == 0.0 ? 1.0 : totalWeight), 0.0, 1.0);
      gl_FragColor = vec4(occ, 0.5 + 0.5 * normal);
}`
  )
};
var $12b21d24d1192a04$export$a815acccbd2c9a49 = {
  uniforms: {
    "sceneDiffuse": {
      value: null
    },
    "sceneDepth": {
      value: null
    },
    "tDiffuse": {
      value: null
    },
    "transparencyDWFalse": {
      value: null
    },
    "transparencyDWTrue": {
      value: null
    },
    "transparencyDWTrueDepth": {
      value: null
    },
    "transparencyAware": {
      value: false
    },
    "projMat": {
      value: new Matrix4()
    },
    "viewMat": {
      value: new Matrix4()
    },
    "projectionMatrixInv": {
      value: new Matrix4()
    },
    "viewMatrixInv": {
      value: new Matrix4()
    },
    "cameraPos": {
      value: new Vector32()
    },
    "resolution": {
      value: new Vector2()
    },
    "color": {
      value: new Vector32(0, 0, 0)
    },
    "blueNoise": {
      value: null
    },
    "downsampledDepth": {
      value: null
    },
    "time": {
      value: 0
    },
    "intensity": {
      value: 10
    },
    "renderMode": {
      value: 0
    },
    "gammaCorrection": {
      value: false
    },
    "logDepth": {
      value: false
    },
    "ortho": {
      value: false
    },
    "near": {
      value: 0.1
    },
    "far": {
      value: 1e3
    },
    "screenSpaceRadius": {
      value: false
    },
    "radius": {
      value: 0
    },
    "distanceFalloff": {
      value: 1
    },
    "fog": {
      value: false
    },
    "fogExp": {
      value: false
    },
    "fogDensity": {
      value: 0
    },
    "fogNear": {
      value: Infinity
    },
    "fogFar": {
      value: Infinity
    },
    "colorMultiply": {
      value: true
    },
    "aoTones": {
      value: 0
    }
  },
  depthWrite: false,
  depthTest: false,
  vertexShader: (
    /* glsl */
    `
		varying vec2 vUv;
		void main() {
			vUv = uv;
			gl_Position = vec4(position, 1);
		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform sampler2D sceneDiffuse;
    uniform highp sampler2D sceneDepth;
    uniform highp sampler2D downsampledDepth;
    uniform highp sampler2D transparencyDWFalse;
    uniform highp sampler2D transparencyDWTrue;
    uniform highp sampler2D transparencyDWTrueDepth;
    uniform sampler2D tDiffuse;
    uniform sampler2D blueNoise;
    uniform vec2 resolution;
    uniform vec3 color;
    uniform mat4 projectionMatrixInv;
    uniform mat4 viewMatrixInv;
    uniform float intensity;
    uniform float renderMode;
    uniform float near;
    uniform float far;
    uniform float aoTones;
    uniform bool gammaCorrection;
    uniform bool logDepth;
    uniform bool ortho;
    uniform bool screenSpaceRadius;
    uniform bool fog;
    uniform bool fogExp;
    uniform bool colorMultiply;
    uniform bool transparencyAware;
    uniform float fogDensity;
    uniform float fogNear;
    uniform float fogFar;
    uniform float radius;
    uniform float distanceFalloff;
    uniform vec3 cameraPos;
    varying vec2 vUv;
    highp float linearize_depth(highp float d, highp float zNear,highp float zFar)
    {
        return (zFar * zNear) / (zFar - d * (zFar - zNear));
    }
    highp float linearize_depth_ortho(highp float d, highp float nearZ, highp float farZ) {
      return nearZ + (farZ - nearZ) * d;
    }
    highp float linearize_depth_log(highp float d, highp float nearZ,highp float farZ) {
      float depth = pow(2.0, d * log2(farZ + 1.0)) - 1.0;
      float a = farZ / (farZ - nearZ);
      float b = farZ * nearZ / (nearZ - farZ);
      float linDepth = a + b / depth;
      return ortho ? linearize_depth_ortho(
        linDepth,
        nearZ,
        farZ
      ) :linearize_depth(linDepth, nearZ, farZ);
    }
    vec3 getWorldPosLog(vec3 posS) {
        vec2 uv = posS.xy;
        float z = posS.z;
        float nearZ =near;
        float farZ = far;
        float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;
        float a = farZ / (farZ - nearZ);
        float b = farZ * nearZ / (nearZ - farZ);
        float linDepth = a + b / depth;
        vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;
        vec4 wpos = projectionMatrixInv * clipVec;
        return wpos.xyz / wpos.w;
      }
      vec3 getWorldPos(float depth, vec2 coord) {
       // if (logDepth) {
        #ifdef LOGDEPTH
          #ifndef ORTHO
            return getWorldPosLog(vec3(coord, depth));
          #endif
        #endif
      //  }
        float z = depth * 2.0 - 1.0;
        vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);
        vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;
        // Perspective division
       vec4 worldSpacePosition = viewSpacePosition;
       worldSpacePosition.xyz /= worldSpacePosition.w;
        return worldSpacePosition.xyz;
    }
  
    vec3 computeNormal(vec3 worldPos, vec2 vUv) {
      ivec2 p = ivec2(vUv * resolution);
      float c0 = texelFetch(sceneDepth, p, 0).x;
      float l2 = texelFetch(sceneDepth, p - ivec2(2, 0), 0).x;
      float l1 = texelFetch(sceneDepth, p - ivec2(1, 0), 0).x;
      float r1 = texelFetch(sceneDepth, p + ivec2(1, 0), 0).x;
      float r2 = texelFetch(sceneDepth, p + ivec2(2, 0), 0).x;
      float b2 = texelFetch(sceneDepth, p - ivec2(0, 2), 0).x;
      float b1 = texelFetch(sceneDepth, p - ivec2(0, 1), 0).x;
      float t1 = texelFetch(sceneDepth, p + ivec2(0, 1), 0).x;
      float t2 = texelFetch(sceneDepth, p + ivec2(0, 2), 0).x;
  
      float dl = abs((2.0 * l1 - l2) - c0);
      float dr = abs((2.0 * r1 - r2) - c0);
      float db = abs((2.0 * b1 - b2) - c0);
      float dt = abs((2.0 * t1 - t2) - c0);
  
      vec3 ce = getWorldPos(c0, vUv).xyz;
  
      vec3 dpdx = (dl < dr) ? ce - getWorldPos(l1, (vUv - vec2(1.0 / resolution.x, 0.0))).xyz
                            : -ce + getWorldPos(r1, (vUv + vec2(1.0 / resolution.x, 0.0))).xyz;
      vec3 dpdy = (db < dt) ? ce - getWorldPos(b1, (vUv - vec2(0.0, 1.0 / resolution.y))).xyz
                            : -ce + getWorldPos(t1, (vUv + vec2(0.0, 1.0 / resolution.y))).xyz;
  
      return normalize(cross(dpdx, dpdy));
  }

    #include <common>
    #include <dithering_pars_fragment>
    void main() {
        //vec4 texel = texture2D(tDiffuse, vUv);//vec3(0.0);
        vec4 sceneTexel = texture2D(sceneDiffuse, vUv);
        float depth = texture2D(
            sceneDepth,
            vUv
        ).x;
        #ifdef HALFRES 
        vec4 texel;
        if (depth == 1.0) {
            texel = vec4(0.0, 0.0, 0.0, 1.0);
        } else {
        vec3 worldPos = getWorldPos(depth, vUv);
        vec3 normal = computeNormal(getWorldPos(depth, vUv), vUv);
       // vec4 texel = texture2D(tDiffuse, vUv);
       // Find closest depth;
       float totalWeight = 0.0;
       float radiusToUse = screenSpaceRadius ? distance(
        worldPos,
        getWorldPos(depth, vUv +
          vec2(radius, 0.0) / resolution)
      ) : radius;
      float distanceFalloffToUse =screenSpaceRadius ?
          radiusToUse * distanceFalloff
      : distanceFalloff;
        for(float x = -1.0; x <= 1.0; x++) {
            for(float y = -1.0; y <= 1.0; y++) {
                vec2 offset = vec2(x, y);
                ivec2 p = ivec2(
                    (vUv * resolution * 0.5) + offset
                );
                vec2 pUv = vec2(p) / (resolution * 0.5);
                float sampleDepth = texelFetch(downsampledDepth,p, 0).x;
                vec4 sampleInfo = texelFetch(tDiffuse, p, 0);
                vec3 normalSample = sampleInfo.gba * 2.0 - 1.0;
                vec3 worldPosSample = getWorldPos(sampleDepth, pUv);
                float tangentPlaneDist = abs(dot(worldPosSample - worldPos, normal));
                float rangeCheck = exp(-1.0 * tangentPlaneDist * (1.0 / distanceFalloffToUse)) * max(dot(normal, normalSample), 0.0);
                float weight = rangeCheck;
                totalWeight += weight;
                texel += sampleInfo * weight;
            }
        }
        if (totalWeight == 0.0) {
            texel = texture2D(tDiffuse, vUv);
        } else {
            texel /= totalWeight;
        }
    }
        #else
        vec4 texel = texture2D(tDiffuse, vUv);
        #endif

        #ifdef LOGDEPTH
        texel.r = clamp(texel.r, 0.0, 1.0);
        if (texel.r == 0.0) {
          texel.r = 1.0;
        }
        #endif
     
        float finalAo = pow(texel.r, intensity);
        if (aoTones > 0.0) {
            finalAo = ceil(finalAo * aoTones) / aoTones;
        }
        float fogFactor;
        float fogDepth = distance(
            cameraPos,
            getWorldPos(depth, vUv)
        );
        if (fog) {
            if (fogExp) {
                fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
            } else {
                fogFactor = smoothstep( fogNear, fogFar, fogDepth );
            }
        }
        if (transparencyAware) {
            float transparencyDWOff = texture2D(transparencyDWFalse, vUv).a;
            float transparencyDWOn = texture2D(transparencyDWTrue, vUv).a;
            float adjustmentFactorOff = transparencyDWOff;
            float adjustmentFactorOn = (1.0 - transparencyDWOn) * (
                texture2D(transparencyDWTrueDepth, vUv).r == texture2D(sceneDepth, vUv).r ? 1.0 : 0.0
            );
            float adjustmentFactor = max(adjustmentFactorOff, adjustmentFactorOn);
            finalAo = mix(finalAo, 1.0, adjustmentFactor);
        }
        finalAo = mix(finalAo, 1.0, fogFactor);
        vec3 aoApplied = color * mix(vec3(1.0), sceneTexel.rgb, float(colorMultiply));
        if (renderMode == 0.0) {
            gl_FragColor = vec4( mix(sceneTexel.rgb, aoApplied, 1.0 - finalAo), sceneTexel.a);
        } else if (renderMode == 1.0) {
            gl_FragColor = vec4( mix(vec3(1.0), aoApplied, 1.0 - finalAo), sceneTexel.a);
        } else if (renderMode == 2.0) {
            gl_FragColor = vec4( sceneTexel.rgb, sceneTexel.a);
        } else if (renderMode == 3.0) {
            if (vUv.x < 0.5) {
                gl_FragColor = vec4( sceneTexel.rgb, sceneTexel.a);
            } else if (abs(vUv.x - 0.5) < 1.0 / resolution.x) {
                gl_FragColor = vec4(1.0);
            } else {
                gl_FragColor = vec4( mix(sceneTexel.rgb, aoApplied, 1.0 - finalAo), sceneTexel.a);
            }
        } else if (renderMode == 4.0) {
            if (vUv.x < 0.5) {
                gl_FragColor = vec4( sceneTexel.rgb, sceneTexel.a);
            } else if (abs(vUv.x - 0.5) < 1.0 / resolution.x) {
                gl_FragColor = vec4(1.0);
            } else {
                gl_FragColor = vec4( mix(vec3(1.0), aoApplied, 1.0 - finalAo), sceneTexel.a);
            }
        }
        #include <dithering_fragment>
        if (gammaCorrection) {
            gl_FragColor = sRGBTransferOETF(gl_FragColor);
        }
    }
    `
  )
};
var $e52378cd0f5a973d$export$57856b59f317262e = {
  uniforms: {
    "sceneDiffuse": {
      value: null
    },
    "sceneDepth": {
      value: null
    },
    "tDiffuse": {
      value: null
    },
    "projMat": {
      value: new Matrix4()
    },
    "viewMat": {
      value: new Matrix4()
    },
    "projectionMatrixInv": {
      value: new Matrix4()
    },
    "viewMatrixInv": {
      value: new Matrix4()
    },
    "cameraPos": {
      value: new Vector32()
    },
    "resolution": {
      value: new Vector2()
    },
    "time": {
      value: 0
    },
    "r": {
      value: 5
    },
    "blueNoise": {
      value: null
    },
    "radius": {
      value: 12
    },
    "worldRadius": {
      value: 5
    },
    "index": {
      value: 0
    },
    "poissonDisk": {
      value: []
    },
    "distanceFalloff": {
      value: 1
    },
    "near": {
      value: 0.1
    },
    "far": {
      value: 1e3
    },
    "logDepth": {
      value: false
    },
    "screenSpaceRadius": {
      value: false
    }
  },
  depthWrite: false,
  depthTest: false,
  vertexShader: (
    /* glsl */
    `
		varying vec2 vUv;
		void main() {
			vUv = uv;
			gl_Position = vec4(position, 1.0);
		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform sampler2D sceneDiffuse;
    uniform highp sampler2D sceneDepth;
    uniform sampler2D tDiffuse;
    uniform sampler2D blueNoise;
    uniform mat4 projectionMatrixInv;
    uniform mat4 viewMatrixInv;
    uniform vec2 resolution;
    uniform float r;
    uniform float radius;
     uniform float worldRadius;
    uniform float index;
     uniform float near;
     uniform float far;
     uniform float distanceFalloff;
     uniform bool logDepth;
     uniform bool screenSpaceRadius;
    varying vec2 vUv;

    highp float linearize_depth(highp float d, highp float zNear,highp float zFar)
    {
        highp float z_n = 2.0 * d - 1.0;
        return 2.0 * zNear * zFar / (zFar + zNear - z_n * (zFar - zNear));
    }
    highp float linearize_depth_log(highp float d, highp float nearZ,highp float farZ) {
     float depth = pow(2.0, d * log2(farZ + 1.0)) - 1.0;
     float a = farZ / (farZ - nearZ);
     float b = farZ * nearZ / (nearZ - farZ);
     float linDepth = a + b / depth;
     return linearize_depth(linDepth, nearZ, farZ);
   }
   highp float linearize_depth_ortho(highp float d, highp float nearZ, highp float farZ) {
     return nearZ + (farZ - nearZ) * d;
   }
   vec3 getWorldPosLog(vec3 posS) {
     vec2 uv = posS.xy;
     float z = posS.z;
     float nearZ =near;
     float farZ = far;
     float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;
     float a = farZ / (farZ - nearZ);
     float b = farZ * nearZ / (nearZ - farZ);
     float linDepth = a + b / depth;
     vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;
     vec4 wpos = projectionMatrixInv * clipVec;
     return wpos.xyz / wpos.w;
   }
    vec3 getWorldPos(float depth, vec2 coord) {
     #ifdef LOGDEPTH
      #ifndef ORTHO
          return getWorldPosLog(vec3(coord, depth));
      #endif
     #endif
        
        float z = depth * 2.0 - 1.0;
        vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);
        vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;
        // Perspective division
       vec4 worldSpacePosition = viewSpacePosition;
       worldSpacePosition.xyz /= worldSpacePosition.w;
        return worldSpacePosition.xyz;
    }
    #include <common>
    #define NUM_SAMPLES 16
    uniform vec2 poissonDisk[NUM_SAMPLES];
    void main() {
        const float pi = 3.14159;
        vec2 texelSize = vec2(1.0 / resolution.x, 1.0 / resolution.y);
        vec2 uv = vUv;
        vec4 data = texture2D(tDiffuse, vUv);
        float occlusion = data.r;
        float baseOcc = data.r;
        vec3 normal = data.gba * 2.0 - 1.0;
        float count = 1.0;
        float d = texture2D(sceneDepth, vUv).x;
        if (d == 1.0) {
          gl_FragColor = data;
          return;
        }
        vec3 worldPos = getWorldPos(d, vUv);
        float size = radius;
        float angle;
        if (index == 0.0) {
             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).w * PI2;
        } else if (index == 1.0) {
             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).z * PI2;
        } else if (index == 2.0) {
             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).y * PI2;
        } else {
             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).x * PI2;
        }

        mat2 rotationMatrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
        float radiusToUse = screenSpaceRadius ? distance(
          worldPos,
          getWorldPos(d, vUv +
            vec2(worldRadius, 0.0) / resolution)
        ) : worldRadius;
        float distanceFalloffToUse =screenSpaceRadius ?
        radiusToUse * distanceFalloff
    : radiusToUse * distanceFalloff * 0.2;

        float invDistance = (1.0 / distanceFalloffToUse);
        for(int i = 0; i < NUM_SAMPLES; i++) {
            vec2 offset = (rotationMatrix * poissonDisk[i]) * texelSize * size;
            vec4 dataSample = texture2D(tDiffuse, uv + offset);
            float occSample = dataSample.r;
            vec3 normalSample = dataSample.gba * 2.0 - 1.0;
            float dSample = texture2D(sceneDepth, uv + offset).x;
            vec3 worldPosSample = getWorldPos(dSample, uv + offset);
            float tangentPlaneDist = abs(dot(worldPosSample - worldPos, normal));
            float rangeCheck = float(dSample != 1.0) * exp(-1.0 * tangentPlaneDist * invDistance ) * max(dot(normal, normalSample), 0.0);
            occlusion += occSample * rangeCheck;
            count += rangeCheck;
        }
        if (count > 0.0) {
          occlusion /= count;
        }
        #ifdef LOGDEPTH
          occlusion = clamp(occlusion, 0.0, 1.0);
          if (occlusion == 0.0) {
            occlusion = 1.0;
          }
        #endif
        gl_FragColor = vec4(occlusion, 0.5 + 0.5 * normal);
    }
    `
  )
};
var $26aca173e0984d99$export$1efdf491687cd442 = {
  uniforms: {
    "sceneDepth": {
      value: null
    },
    "resolution": {
      value: new Vector2()
    },
    "near": {
      value: 0.1
    },
    "far": {
      value: 1e3
    },
    "viewMatrixInv": {
      value: new Matrix4()
    },
    "projectionMatrixInv": {
      value: new Matrix4()
    },
    "logDepth": {
      value: false
    },
    "ortho": {
      value: false
    }
  },
  depthWrite: false,
  depthTest: false,
  vertexShader: (
    /* glsl */
    `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = vec4(position, 1);
    }`
  ),
  fragmentShader: (
    /* glsl */
    `
    uniform highp sampler2D sceneDepth;
    uniform vec2 resolution;
    uniform float near;
    uniform float far;
    uniform bool logDepth;
    uniform bool ortho;
    uniform mat4 viewMatrixInv;
    uniform mat4 projectionMatrixInv;
    varying vec2 vUv;
    layout(location = 1) out vec4 gNormal;
    vec3 getWorldPosLog(vec3 posS) {
        vec2 uv = posS.xy;
        float z = posS.z;
        float nearZ =near;
        float farZ = far;
        float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;
        float a = farZ / (farZ - nearZ);
        float b = farZ * nearZ / (nearZ - farZ);
        float linDepth = a + b / depth;
        vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;
        vec4 wpos = projectionMatrixInv * clipVec;
        return wpos.xyz / wpos.w;
      }
      vec3 getWorldPos(float depth, vec2 coord) {
        if (logDepth && !ortho) {
          return getWorldPosLog(vec3(coord, depth));
        }
        float z = depth * 2.0 - 1.0;
        vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);
        vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;
        // Perspective division
       vec4 worldSpacePosition = viewSpacePosition;
       worldSpacePosition.xyz /= worldSpacePosition.w;
        return worldSpacePosition.xyz;
    }
  
    vec3 computeNormal(vec3 worldPos, vec2 vUv) {
      ivec2 p = ivec2(vUv * resolution);
      float c0 = texelFetch(sceneDepth, p, 0).x;
      float l2 = texelFetch(sceneDepth, p - ivec2(2, 0), 0).x;
      float l1 = texelFetch(sceneDepth, p - ivec2(1, 0), 0).x;
      float r1 = texelFetch(sceneDepth, p + ivec2(1, 0), 0).x;
      float r2 = texelFetch(sceneDepth, p + ivec2(2, 0), 0).x;
      float b2 = texelFetch(sceneDepth, p - ivec2(0, 2), 0).x;
      float b1 = texelFetch(sceneDepth, p - ivec2(0, 1), 0).x;
      float t1 = texelFetch(sceneDepth, p + ivec2(0, 1), 0).x;
      float t2 = texelFetch(sceneDepth, p + ivec2(0, 2), 0).x;
  
      float dl = abs((2.0 * l1 - l2) - c0);
      float dr = abs((2.0 * r1 - r2) - c0);
      float db = abs((2.0 * b1 - b2) - c0);
      float dt = abs((2.0 * t1 - t2) - c0);
  
      vec3 ce = getWorldPos(c0, vUv).xyz;
  
      vec3 dpdx = (dl < dr) ? ce - getWorldPos(l1, (vUv - vec2(1.0 / resolution.x, 0.0))).xyz
                            : -ce + getWorldPos(r1, (vUv + vec2(1.0 / resolution.x, 0.0))).xyz;
      vec3 dpdy = (db < dt) ? ce - getWorldPos(b1, (vUv - vec2(0.0, 1.0 / resolution.y))).xyz
                            : -ce + getWorldPos(t1, (vUv + vec2(0.0, 1.0 / resolution.y))).xyz;
  
      return normalize(cross(dpdx, dpdy));
  }
    void main() {
        vec2 uv = vUv - vec2(0.5) / resolution;
        vec2 pixelSize = vec2(1.0) / resolution;
        highp vec2[4] uvSamples;
        uvSamples[0] = uv;
        uvSamples[1] = uv + vec2(pixelSize.x, 0.0);
        uvSamples[2] = uv + vec2(0.0, pixelSize.y);
        uvSamples[3] = uv + pixelSize;
        float depth00 = texture2D(sceneDepth, uvSamples[0]).r;
        float depth10 = texture2D(sceneDepth, uvSamples[1]).r;
        float depth01 = texture2D(sceneDepth, uvSamples[2]).r;
        float depth11 = texture2D(sceneDepth, uvSamples[3]).r;
        float minDepth = min(min(depth00, depth10), min(depth01, depth11));
        float maxDepth = max(max(depth00, depth10), max(depth01, depth11));
        float targetDepth = minDepth;
        // Checkerboard pattern to avoid artifacts
        if (mod(gl_FragCoord.x + gl_FragCoord.y, 2.0) > 0.5) { 
            targetDepth = maxDepth;
        }
        int chosenIndex = 0;
        float[4] samples;
        samples[0] = depth00;
        samples[1] = depth10;
        samples[2] = depth01;
        samples[3] = depth11;
        for(int i = 0; i < 4; ++i) {
            if (samples[i] == targetDepth) {
                chosenIndex = i;
                break;
            }
        }
        gl_FragColor = vec4(samples[chosenIndex], 0.0, 0.0, 1.0);
        gNormal = vec4(computeNormal(
            getWorldPos(samples[chosenIndex], uvSamples[chosenIndex]), uvSamples[chosenIndex]
        ), 0.0);
    }`
  )
};
var $06269ad78f3c5fdf$export$2e2bcd8739ae039 = `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`;
var $ff9437d9c7577f11$var$version = (() => parseInt(REVISION.replace(/\D+/g, "")))();
var $ff9437d9c7577f11$export$156f6a58f569aa09 = $ff9437d9c7577f11$var$version >= 162 ? class extends WebGLRenderTarget {
  constructor(width = 1, height = 1, count = 1, options = {}) {
    super(width, height, {
      ...options,
      count
    });
    this.isWebGLMultipleRenderTargets = true;
  }
  get texture() {
    return this.textures;
  }
} : class extends WebGLRenderTarget {
  constructor(width = 1, height = 1, count = 1, options = {}) {
    super(width, height, options);
    this.isWebGLMultipleRenderTargets = true;
    const texture = this.texture;
    this.texture = [];
    for (let i = 0; i < count; i++) {
      this.texture[i] = texture.clone();
      this.texture[i].isRenderTargetTexture = true;
    }
  }
  setSize(width, height, depth = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      for (let i = 0, il = this.texture.length; i < il; i++) {
        this.texture[i].image.width = width;
        this.texture[i].image.height = height;
        this.texture[i].image.depth = depth;
      }
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  }
  copy(source) {
    this.dispose();
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.scissor.copy(source.scissor);
    this.scissorTest = source.scissorTest;
    this.viewport.copy(source.viewport);
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    if (source.depthTexture !== null)
      this.depthTexture = source.depthTexture.clone();
    this.texture.length = 0;
    for (let i = 0, il = source.texture.length; i < il; i++) {
      this.texture[i] = source.texture[i].clone();
      this.texture[i].isRenderTargetTexture = true;
    }
    return this;
  }
};
var $87431ee93b037844$var$bluenoiseBits = Uint8Array.from(atob((0, $06269ad78f3c5fdf$export$2e2bcd8739ae039)), (c2) => c2.charCodeAt(0));
function $87431ee93b037844$var$checkTimerQuery(timerQuery, gl, pass) {
  const available = gl.getQueryParameter(timerQuery, gl.QUERY_RESULT_AVAILABLE);
  if (available) {
    const elapsedTimeInNs = gl.getQueryParameter(timerQuery, gl.QUERY_RESULT);
    const elapsedTimeInMs = elapsedTimeInNs / 1e6;
    pass.lastTime = pass.lastTime === 0 ? elapsedTimeInMs : pass.timeRollingAverage * pass.lastTime + (1 - pass.timeRollingAverage) * elapsedTimeInMs;
  } else
    setTimeout(() => {
      $87431ee93b037844$var$checkTimerQuery(timerQuery, gl, pass);
    }, 1);
}
var $87431ee93b037844$export$2489f9981ab0fa82 = class extends (0, Pass) {
  /**
   * 
   * @param {THREE.Scene} scene
   * @param {THREE.Camera} camera 
   * @param {number} width 
   * @param {number} height
   *  
   * @property {THREE.Scene} scene
   * @property {THREE.Camera} camera
   * @property {number} width
   * @property {number} height
   */
  constructor(scene, camera, width = 512, height = 512) {
    super();
    this.width = width;
    this.height = height;
    this.clear = true;
    this.camera = camera;
    this.scene = scene;
    this.autosetGamma = true;
    this.configuration = new Proxy({
      aoSamples: 16,
      aoRadius: 5,
      aoTones: 0,
      denoiseSamples: 8,
      denoiseRadius: 12,
      distanceFalloff: 1,
      intensity: 5,
      denoiseIterations: 2,
      renderMode: 0,
      biasOffset: 0,
      biasMultiplier: 0,
      color: new Color(0, 0, 0),
      gammaCorrection: true,
      logarithmicDepthBuffer: false,
      screenSpaceRadius: false,
      halfRes: false,
      depthAwareUpsampling: true,
      colorMultiply: true,
      transparencyAware: false,
      accumulate: false
    }, {
      set: (target, propName, value) => {
        const oldProp = target[propName];
        target[propName] = value;
        if (value.equals) {
          if (!value.equals(oldProp))
            this.firstFrame();
        } else if (oldProp !== value)
          this.firstFrame();
        if (propName === "aoSamples" && oldProp !== value)
          this.configureAOPass(this.configuration.logarithmicDepthBuffer, this.camera.isOrthographicCamera);
        if (propName === "denoiseSamples" && oldProp !== value)
          this.configureDenoisePass(this.configuration.logarithmicDepthBuffer, this.camera.isOrthographicCamera);
        if (propName === "halfRes" && oldProp !== value) {
          this.configureAOPass(this.configuration.logarithmicDepthBuffer, this.camera.isOrthographicCamera);
          this.configureHalfResTargets();
          this.configureEffectCompositer(this.configuration.logarithmicDepthBuffer, this.camera.isOrthographicCamera);
          this.setSize(this.width, this.height);
        }
        if (propName === "depthAwareUpsampling" && oldProp !== value)
          this.configureEffectCompositer(this.configuration.logarithmicDepthBuffer, this.camera.isOrthographicCamera);
        if (propName === "gammaCorrection")
          this.autosetGamma = false;
        if (propName === "transparencyAware" && oldProp !== value) {
          this.autoDetectTransparency = false;
          this.configureTransparencyTarget();
        }
        return true;
      }
    });
    this.samples = [];
    this.samplesDenoise = [];
    this.autoDetectTransparency = true;
    this.frames = 0;
    this.lastViewMatrix = new Matrix4();
    this.lastProjectionMatrix = new Matrix4();
    this.configureEffectCompositer(this.configuration.logarithmicDepthBuffer);
    this.configureSampleDependentPasses();
    this.configureHalfResTargets();
    this.detectTransparency();
    this.configureTransparencyTarget();
    this.copyQuad = new (0, $e4ca8dcb0218f846$export$dcd670d73db751f5)(new ShaderMaterial({
      uniforms: {
        tDiffuse: {
          value: null
        }
      },
      depthWrite: false,
      vertexShader: `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = vec4(position, 1);
            }
            `,
      fragmentShader: `
            uniform sampler2D tDiffuse;
            varying vec2 vUv;
            void main() {
                gl_FragColor = texture2D(tDiffuse, vUv);
            }
            `
    }));
    this.writeTargetInternal = new WebGLRenderTarget(this.width, this.height, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      depthBuffer: false,
      format: RGBAFormat
    });
    this.readTargetInternal = new WebGLRenderTarget(this.width, this.height, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      depthBuffer: false,
      format: RGBAFormat
    });
    this.outputTargetInternal = new WebGLRenderTarget(this.width, this.height, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      depthBuffer: false
    });
    this.accumulationRenderTarget = new WebGLRenderTarget(this.width, this.height, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      depthBuffer: false,
      format: RGBAFormat,
      type: HalfFloatType,
      stencilBuffer: false,
      depthBuffer: false,
      alpha: true
    });
    this.accumulationQuad = new (0, $e4ca8dcb0218f846$export$dcd670d73db751f5)(new ShaderMaterial({
      uniforms: {
        frame: {
          value: 0
        },
        tDiffuse: {
          value: null
        }
      },
      transparent: true,
      opacity: 1,
      vertexShader: `
             varying vec2 vUv;
             void main() {
                 vUv = uv;
                 gl_Position = vec4(position, 1);
             }`,
      fragmentShader: `
             uniform sampler2D tDiffuse;
             uniform float frame;
                varying vec2 vUv;
                void main() {
                    vec4 color = texture2D(tDiffuse, vUv);
                    gl_FragColor = vec4(color.rgb, 1.0 / (frame + 1.0));
                }
                `
    }));
    this.bluenoise = new DataTexture($87431ee93b037844$var$bluenoiseBits, 128, 128);
    this.bluenoise.colorSpace = NoColorSpace;
    this.bluenoise.wrapS = RepeatWrapping;
    this.bluenoise.wrapT = RepeatWrapping;
    this.bluenoise.minFilter = NearestFilter;
    this.bluenoise.magFilter = NearestFilter;
    this.bluenoise.needsUpdate = true;
    this.lastTime = 0;
    this.timeRollingAverage = 0.99;
    this.needsDepthTexture = true;
    this.needsSwap = true;
    this._r = new Vector2();
    this._c = new Color();
  }
  configureHalfResTargets() {
    this.firstFrame();
    if (this.configuration.halfRes) {
      this.depthDownsampleTarget = new (0, $ff9437d9c7577f11$export$156f6a58f569aa09)(this.width / 2, this.height / 2, 2);
      if (REVISION <= 161)
        this.depthDownsampleTarget.textures = this.depthDownsampleTarget.texture;
      this.depthDownsampleTarget.textures[0].format = RedFormat;
      this.depthDownsampleTarget.textures[0].type = FloatType;
      this.depthDownsampleTarget.textures[0].minFilter = NearestFilter;
      this.depthDownsampleTarget.textures[0].magFilter = NearestFilter;
      this.depthDownsampleTarget.textures[0].depthBuffer = false;
      this.depthDownsampleTarget.textures[1].format = RGBAFormat;
      this.depthDownsampleTarget.textures[1].type = HalfFloatType;
      this.depthDownsampleTarget.textures[1].minFilter = NearestFilter;
      this.depthDownsampleTarget.textures[1].magFilter = NearestFilter;
      this.depthDownsampleTarget.textures[1].depthBuffer = false;
      this.depthDownsampleQuad = new (0, $e4ca8dcb0218f846$export$dcd670d73db751f5)(new ShaderMaterial((0, $26aca173e0984d99$export$1efdf491687cd442)));
    } else {
      if (this.depthDownsampleTarget) {
        this.depthDownsampleTarget.dispose();
        this.depthDownsampleTarget = null;
      }
      if (this.depthDownsampleQuad) {
        this.depthDownsampleQuad.dispose();
        this.depthDownsampleQuad = null;
      }
    }
  }
  detectTransparency() {
    if (this.autoDetectTransparency) {
      let isTransparency = false;
      this.scene.traverse((obj) => {
        if (obj.material && obj.material.transparent)
          isTransparency = true;
      });
      if (isTransparency)
        this.configuration.transparencyAware = true;
    }
  }
  configureTransparencyTarget() {
    if (this.configuration.transparencyAware) {
      this.transparencyRenderTargetDWFalse = new WebGLRenderTarget(this.width, this.height, {
        minFilter: LinearFilter,
        magFilter: NearestFilter,
        type: HalfFloatType,
        format: RGBAFormat
      });
      this.transparencyRenderTargetDWTrue = new WebGLRenderTarget(this.width, this.height, {
        minFilter: LinearFilter,
        magFilter: NearestFilter,
        type: HalfFloatType,
        format: RGBAFormat
      });
      this.transparencyRenderTargetDWTrue.depthTexture = new DepthTexture(this.width, this.height, UnsignedIntType);
      this.depthCopyPass = new (0, $e4ca8dcb0218f846$export$dcd670d73db751f5)(new ShaderMaterial({
        uniforms: {
          depthTexture: {
            value: this.depthTexture
          }
        },
        vertexShader: (
          /* glsl */
          `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = vec4(position, 1);
            }`
        ),
        fragmentShader: (
          /* glsl */
          `
            uniform sampler2D depthTexture;
            varying vec2 vUv;
            void main() {
               gl_FragDepth = texture2D(depthTexture, vUv).r + 0.00001;
               gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
            }
            `
        )
      }));
    } else {
      if (this.transparencyRenderTargetDWFalse) {
        this.transparencyRenderTargetDWFalse.dispose();
        this.transparencyRenderTargetDWFalse = null;
      }
      if (this.transparencyRenderTargetDWTrue) {
        this.transparencyRenderTargetDWTrue.dispose();
        this.transparencyRenderTargetDWTrue = null;
      }
      if (this.depthCopyPass) {
        this.depthCopyPass.dispose();
        this.depthCopyPass = null;
      }
    }
  }
  renderTransparency(renderer) {
    const oldBackground = this.scene.background;
    const oldClearColor = renderer.getClearColor(new Color());
    const oldClearAlpha = renderer.getClearAlpha();
    const oldVisibility = /* @__PURE__ */ new Map();
    const oldAutoClearDepth = renderer.autoClearDepth;
    this.scene.traverse((obj) => {
      oldVisibility.set(obj, obj.visible);
    });
    this.scene.background = null;
    renderer.autoClearDepth = false;
    renderer.setClearColor(new Color(0, 0, 0), 0);
    this.depthCopyPass.material.uniforms.depthTexture.value = this.depthTexture;
    renderer.setRenderTarget(this.transparencyRenderTargetDWFalse);
    this.scene.traverse((obj) => {
      if (obj.material)
        obj.visible = oldVisibility.get(obj) && (obj.material.transparent && !obj.material.depthWrite && !obj.userData.treatAsOpaque || !!obj.userData.cannotReceiveAO);
    });
    renderer.clear(true, true, true);
    this.depthCopyPass.render(renderer);
    renderer.render(this.scene, this.camera);
    renderer.setRenderTarget(this.transparencyRenderTargetDWTrue);
    this.scene.traverse((obj) => {
      if (obj.material)
        obj.visible = oldVisibility.get(obj) && obj.material.transparent && obj.material.depthWrite && !obj.userData.treatAsOpaque;
    });
    renderer.clear(true, true, true);
    this.depthCopyPass.render(renderer);
    renderer.render(this.scene, this.camera);
    this.scene.traverse((obj) => {
      obj.visible = oldVisibility.get(obj);
    });
    renderer.setClearColor(oldClearColor, oldClearAlpha);
    this.scene.background = oldBackground;
    renderer.autoClearDepth = oldAutoClearDepth;
  }
  configureSampleDependentPasses() {
    this.configureAOPass(this.configuration.logarithmicDepthBuffer, this.camera.isOrthographicCamera);
    this.configureDenoisePass(this.configuration.logarithmicDepthBuffer, this.camera.isOrthographicCamera);
  }
  configureAOPass(logarithmicDepthBuffer = false, ortho = false) {
    this.firstFrame();
    this.samples = this.generateHemisphereSamples(this.configuration.aoSamples);
    const e = {
      ...(0, $1ed45968c1160c3c$export$c9b263b9a17dffd7)
    };
    e.fragmentShader = e.fragmentShader.replace("16", this.configuration.aoSamples).replace("16.0", this.configuration.aoSamples + ".0");
    if (logarithmicDepthBuffer)
      e.fragmentShader = "#define LOGDEPTH\n" + e.fragmentShader;
    if (ortho)
      e.fragmentShader = "#define ORTHO\n" + e.fragmentShader;
    if (this.configuration.halfRes)
      e.fragmentShader = "#define HALFRES\n" + e.fragmentShader;
    if (this.effectShaderQuad) {
      this.effectShaderQuad.material.dispose();
      this.effectShaderQuad.material = new ShaderMaterial(e);
    } else
      this.effectShaderQuad = new (0, $e4ca8dcb0218f846$export$dcd670d73db751f5)(new ShaderMaterial(e));
  }
  configureDenoisePass(logarithmicDepthBuffer = false, ortho = false) {
    this.firstFrame();
    this.samplesDenoise = this.generateDenoiseSamples(this.configuration.denoiseSamples, 11);
    const p = {
      ...(0, $e52378cd0f5a973d$export$57856b59f317262e)
    };
    p.fragmentShader = p.fragmentShader.replace("16", this.configuration.denoiseSamples);
    if (logarithmicDepthBuffer)
      p.fragmentShader = "#define LOGDEPTH\n" + p.fragmentShader;
    if (ortho)
      p.fragmentShader = "#define ORTHO\n" + p.fragmentShader;
    if (this.poissonBlurQuad) {
      this.poissonBlurQuad.material.dispose();
      this.poissonBlurQuad.material = new ShaderMaterial(p);
    } else
      this.poissonBlurQuad = new (0, $e4ca8dcb0218f846$export$dcd670d73db751f5)(new ShaderMaterial(p));
  }
  configureEffectCompositer(logarithmicDepthBuffer = false, ortho = false) {
    this.firstFrame();
    const e = {
      ...(0, $12b21d24d1192a04$export$a815acccbd2c9a49)
    };
    if (logarithmicDepthBuffer)
      e.fragmentShader = "#define LOGDEPTH\n" + e.fragmentShader;
    if (ortho)
      e.fragmentShader = "#define ORTHO\n" + e.fragmentShader;
    if (this.configuration.halfRes && this.configuration.depthAwareUpsampling)
      e.fragmentShader = "#define HALFRES\n" + e.fragmentShader;
    if (this.effectCompositerQuad) {
      this.effectCompositerQuad.material.dispose();
      this.effectCompositerQuad.material = new ShaderMaterial(e);
    } else
      this.effectCompositerQuad = new (0, $e4ca8dcb0218f846$export$dcd670d73db751f5)(new ShaderMaterial(e));
  }
  /**
       * 
       * @param {Number} n 
       * @returns {THREE.Vector3[]}
       */
  generateHemisphereSamples(n2) {
    const points = [];
    for (let k = 0; k < n2; k++) {
      const theta = 2.399963 * k;
      const r = Math.sqrt(k + 0.5) / Math.sqrt(n2);
      const x2 = r * Math.cos(theta);
      const y = r * Math.sin(theta);
      const z = Math.sqrt(1 - (x2 * x2 + y * y));
      points.push(new Vector32(x2, y, z));
    }
    return points;
  }
  /**
       * 
       * @param {number} numSamples 
       * @param {number} numRings 
       * @returns {THREE.Vector2[]}
       */
  generateDenoiseSamples(numSamples, numRings) {
    const angleStep = 2 * Math.PI * numRings / numSamples;
    const invNumSamples = 1 / numSamples;
    const radiusStep = invNumSamples;
    const samples = [];
    let radius = invNumSamples;
    let angle = 0;
    for (let i = 0; i < numSamples; i++) {
      samples.push(new Vector2(Math.cos(angle), Math.sin(angle)).multiplyScalar(Math.pow(radius, 0.75)));
      radius += radiusStep;
      angle += angleStep;
    }
    return samples;
  }
  setSize(width, height) {
    this.firstFrame();
    this.width = width;
    this.height = height;
    const c2 = this.configuration.halfRes ? 0.5 : 1;
    this.writeTargetInternal.setSize(width * c2, height * c2);
    this.readTargetInternal.setSize(width * c2, height * c2);
    this.accumulationRenderTarget.setSize(width * c2, height * c2);
    if (this.configuration.halfRes)
      this.depthDownsampleTarget.setSize(width * c2, height * c2);
    if (this.configuration.transparencyAware) {
      this.transparencyRenderTargetDWFalse.setSize(width, height);
      this.transparencyRenderTargetDWTrue.setSize(width, height);
    }
    this.outputTargetInternal.setSize(width, height);
  }
  setDepthTexture(depthTexture) {
    this.depthTexture = depthTexture;
  }
  firstFrame() {
    this.needsFrame = true;
  }
  render(renderer, inputBuffer, outputBuffer) {
    const xrEnabled = renderer.xr.enabled;
    renderer.xr.enabled = false;
    if (renderer.capabilities.logarithmicDepthBuffer !== this.configuration.logarithmicDepthBuffer) {
      this.configuration.logarithmicDepthBuffer = renderer.capabilities.logarithmicDepthBuffer;
      this.configureAOPass(this.configuration.logarithmicDepthBuffer, this.camera.isOrthographicCamera);
      this.configureDenoisePass(this.configuration.logarithmicDepthBuffer, this.camera.isOrthographicCamera);
      this.configureEffectCompositer(this.configuration.logarithmicDepthBuffer, this.camera.isOrthographicCamera);
    }
    this.detectTransparency();
    if (inputBuffer.texture.type !== this.outputTargetInternal.texture.type || inputBuffer.texture.format !== this.outputTargetInternal.texture.format) {
      this.outputTargetInternal.texture.type = inputBuffer.texture.type;
      this.outputTargetInternal.texture.format = inputBuffer.texture.format;
      this.outputTargetInternal.texture.needsUpdate = true;
    }
    this.camera.updateMatrixWorld();
    if (this.lastViewMatrix.equals(this.camera.matrixWorldInverse) && this.lastProjectionMatrix.equals(this.camera.projectionMatrix) && this.configuration.accumulate && !this.needsFrame)
      this.frame++;
    else {
      if (this.configuration.accumulate) {
        renderer.setRenderTarget(this.accumulationRenderTarget);
        renderer.clear(true, true, true);
      }
      this.frame = 0;
      this.needsFrame = false;
    }
    this.lastViewMatrix.copy(this.camera.matrixWorldInverse);
    this.lastProjectionMatrix.copy(this.camera.projectionMatrix);
    let gl;
    let ext;
    let timerQuery;
    if (this.debugMode) {
      gl = renderer.getContext();
      ext = gl.getExtension("EXT_disjoint_timer_query_webgl2");
      if (ext === null) {
        console.error("EXT_disjoint_timer_query_webgl2 not available, disabling debug mode.");
        this.debugMode = false;
      }
    }
    if (this.debugMode) {
      timerQuery = gl.createQuery();
      gl.beginQuery(ext.TIME_ELAPSED_EXT, timerQuery);
    }
    if (this.configuration.transparencyAware)
      this.renderTransparency(renderer);
    this._r.set(this.width, this.height);
    let trueRadius = this.configuration.aoRadius;
    if (this.configuration.halfRes && this.configuration.screenSpaceRadius)
      trueRadius *= 0.5;
    if (this.frame < 1024 / this.configuration.aoSamples) {
      if (this.configuration.halfRes) {
        renderer.setRenderTarget(this.depthDownsampleTarget);
        this.depthDownsampleQuad.material.uniforms.sceneDepth.value = this.depthTexture;
        this.depthDownsampleQuad.material.uniforms.resolution.value = this._r;
        this.depthDownsampleQuad.material.uniforms["near"].value = this.camera.near;
        this.depthDownsampleQuad.material.uniforms["far"].value = this.camera.far;
        this.depthDownsampleQuad.material.uniforms["projectionMatrixInv"].value = this.camera.projectionMatrixInverse;
        this.depthDownsampleQuad.material.uniforms["viewMatrixInv"].value = this.camera.matrixWorld;
        this.depthDownsampleQuad.material.uniforms["logDepth"].value = this.configuration.logarithmicDepthBuffer;
        this.depthDownsampleQuad.material.uniforms["ortho"].value = this.camera.isOrthographicCamera;
        this.depthDownsampleQuad.render(renderer);
      }
      this.effectShaderQuad.material.uniforms["sceneDiffuse"].value = inputBuffer.texture;
      this.effectShaderQuad.material.uniforms["sceneDepth"].value = this.configuration.halfRes ? this.depthDownsampleTarget.textures[0] : this.depthTexture;
      this.effectShaderQuad.material.uniforms["sceneNormal"].value = this.configuration.halfRes ? this.depthDownsampleTarget.textures[1] : null;
      this.effectShaderQuad.material.uniforms["projMat"].value = this.camera.projectionMatrix;
      this.effectShaderQuad.material.uniforms["viewMat"].value = this.camera.matrixWorldInverse;
      this.effectShaderQuad.material.uniforms["projViewMat"].value = this.camera.projectionMatrix.clone().multiply(this.camera.matrixWorldInverse.clone());
      this.effectShaderQuad.material.uniforms["projectionMatrixInv"].value = this.camera.projectionMatrixInverse;
      this.effectShaderQuad.material.uniforms["viewMatrixInv"].value = this.camera.matrixWorld;
      this.effectShaderQuad.material.uniforms["cameraPos"].value = this.camera.getWorldPosition(new Vector32());
      this.effectShaderQuad.material.uniforms["biasAdjustment"].value = new Vector2(this.configuration.biasOffset, this.configuration.biasMultiplier);
      this.effectShaderQuad.material.uniforms["resolution"].value = this.configuration.halfRes ? this._r.clone().multiplyScalar(0.5).floor() : this._r;
      this.effectShaderQuad.material.uniforms["time"].value = performance.now() / 1e3;
      this.effectShaderQuad.material.uniforms["samples"].value = this.samples;
      this.effectShaderQuad.material.uniforms["bluenoise"].value = this.bluenoise;
      this.effectShaderQuad.material.uniforms["radius"].value = trueRadius;
      this.effectShaderQuad.material.uniforms["distanceFalloff"].value = this.configuration.distanceFalloff;
      this.effectShaderQuad.material.uniforms["near"].value = this.camera.near;
      this.effectShaderQuad.material.uniforms["far"].value = this.camera.far;
      this.effectShaderQuad.material.uniforms["logDepth"].value = renderer.capabilities.logarithmicDepthBuffer;
      this.effectShaderQuad.material.uniforms["ortho"].value = this.camera.isOrthographicCamera;
      this.effectShaderQuad.material.uniforms["screenSpaceRadius"].value = this.configuration.screenSpaceRadius;
      this.effectShaderQuad.material.uniforms["frame"].value = this.frame;
      renderer.setRenderTarget(this.writeTargetInternal);
      this.effectShaderQuad.render(renderer);
      for (let i = 0; i < this.configuration.denoiseIterations; i++) {
        [this.writeTargetInternal, this.readTargetInternal] = [
          this.readTargetInternal,
          this.writeTargetInternal
        ];
        this.poissonBlurQuad.material.uniforms["tDiffuse"].value = this.readTargetInternal.texture;
        this.poissonBlurQuad.material.uniforms["sceneDepth"].value = this.configuration.halfRes ? this.depthDownsampleTarget.textures[0] : this.depthTexture;
        this.poissonBlurQuad.material.uniforms["projMat"].value = this.camera.projectionMatrix;
        this.poissonBlurQuad.material.uniforms["viewMat"].value = this.camera.matrixWorldInverse;
        this.poissonBlurQuad.material.uniforms["projectionMatrixInv"].value = this.camera.projectionMatrixInverse;
        this.poissonBlurQuad.material.uniforms["viewMatrixInv"].value = this.camera.matrixWorld;
        this.poissonBlurQuad.material.uniforms["cameraPos"].value = this.camera.getWorldPosition(new Vector32());
        this.poissonBlurQuad.material.uniforms["resolution"].value = this.configuration.halfRes ? this._r.clone().multiplyScalar(0.5).floor() : this._r;
        this.poissonBlurQuad.material.uniforms["time"].value = performance.now() / 1e3;
        this.poissonBlurQuad.material.uniforms["blueNoise"].value = this.bluenoise;
        this.poissonBlurQuad.material.uniforms["radius"].value = this.configuration.denoiseRadius * (this.configuration.halfRes ? 0.5 : 1);
        this.poissonBlurQuad.material.uniforms["worldRadius"].value = trueRadius;
        this.poissonBlurQuad.material.uniforms["distanceFalloff"].value = this.configuration.distanceFalloff;
        this.poissonBlurQuad.material.uniforms["index"].value = i;
        this.poissonBlurQuad.material.uniforms["poissonDisk"].value = this.samplesDenoise;
        this.poissonBlurQuad.material.uniforms["near"].value = this.camera.near;
        this.poissonBlurQuad.material.uniforms["far"].value = this.camera.far;
        this.poissonBlurQuad.material.uniforms["logDepth"].value = renderer.capabilities.logarithmicDepthBuffer;
        this.poissonBlurQuad.material.uniforms["screenSpaceRadius"].value = this.configuration.screenSpaceRadius;
        renderer.setRenderTarget(this.writeTargetInternal);
        this.poissonBlurQuad.render(renderer);
      }
      renderer.setRenderTarget(this.accumulationRenderTarget);
      const oldAutoClear = renderer.autoClear;
      renderer.autoClear = false;
      this.accumulationQuad.material.uniforms["tDiffuse"].value = this.writeTargetInternal.texture;
      this.accumulationQuad.material.uniforms["frame"].value = this.frame;
      this.accumulationQuad.render(renderer);
      renderer.autoClear = oldAutoClear;
    }
    if (this.configuration.transparencyAware) {
      this.effectCompositerQuad.material.uniforms["transparencyDWFalse"].value = this.transparencyRenderTargetDWFalse.texture;
      this.effectCompositerQuad.material.uniforms["transparencyDWTrue"].value = this.transparencyRenderTargetDWTrue.texture;
      this.effectCompositerQuad.material.uniforms["transparencyDWTrueDepth"].value = this.transparencyRenderTargetDWTrue.depthTexture;
      this.effectCompositerQuad.material.uniforms["transparencyAware"].value = true;
    }
    this.effectCompositerQuad.material.uniforms["sceneDiffuse"].value = inputBuffer.texture;
    this.effectCompositerQuad.material.uniforms["sceneDepth"].value = this.depthTexture;
    this.effectCompositerQuad.material.uniforms["aoTones"].value = this.configuration.aoTones;
    this.effectCompositerQuad.material.uniforms["near"].value = this.camera.near;
    this.effectCompositerQuad.material.uniforms["far"].value = this.camera.far;
    this.effectCompositerQuad.material.uniforms["projectionMatrixInv"].value = this.camera.projectionMatrixInverse;
    this.effectCompositerQuad.material.uniforms["viewMatrixInv"].value = this.camera.matrixWorld;
    this.effectCompositerQuad.material.uniforms["logDepth"].value = renderer.capabilities.logarithmicDepthBuffer;
    this.effectCompositerQuad.material.uniforms["ortho"].value = this.camera.isOrthographicCamera;
    this.effectCompositerQuad.material.uniforms["downsampledDepth"].value = this.configuration.halfRes ? this.depthDownsampleTarget.textures[0] : this.depthTexture;
    this.effectCompositerQuad.material.uniforms["resolution"].value = this._r;
    this.effectCompositerQuad.material.uniforms["blueNoise"].value = this.bluenoise;
    this.effectCompositerQuad.material.uniforms["intensity"].value = this.configuration.intensity;
    this.effectCompositerQuad.material.uniforms["renderMode"].value = this.configuration.renderMode;
    this.effectCompositerQuad.material.uniforms["screenSpaceRadius"].value = this.configuration.screenSpaceRadius;
    this.effectCompositerQuad.material.uniforms["radius"].value = trueRadius;
    this.effectCompositerQuad.material.uniforms["distanceFalloff"].value = this.configuration.distanceFalloff;
    this.effectCompositerQuad.material.uniforms["gammaCorrection"].value = this.autosetGamma ? this.renderToScreen : this.configuration.gammaCorrection;
    this.effectCompositerQuad.material.uniforms["tDiffuse"].value = this.accumulationRenderTarget.texture;
    this.effectCompositerQuad.material.uniforms["color"].value = this._c.copy(this.configuration.color).convertSRGBToLinear();
    this.effectCompositerQuad.material.uniforms["colorMultiply"].value = this.configuration.colorMultiply;
    this.effectCompositerQuad.material.uniforms["cameraPos"].value = this.camera.getWorldPosition(new Vector32());
    this.effectCompositerQuad.material.uniforms["fog"].value = !!this.scene.fog;
    if (this.scene.fog) {
      if (this.scene.fog.isFog) {
        this.effectCompositerQuad.material.uniforms["fogExp"].value = false;
        this.effectCompositerQuad.material.uniforms["fogNear"].value = this.scene.fog.near;
        this.effectCompositerQuad.material.uniforms["fogFar"].value = this.scene.fog.far;
      } else if (this.scene.fog.isFogExp2) {
        this.effectCompositerQuad.material.uniforms["fogExp"].value = true;
        this.effectCompositerQuad.material.uniforms["fogDensity"].value = this.scene.fog.density;
      } else
        console.error(`Unsupported fog type ${this.scene.fog.constructor.name} in SSAOPass.`);
    }
    renderer.setRenderTarget(
      /* this.renderToScreen ? null :
      outputBuffer*/
      this.outputTargetInternal
    );
    this.effectCompositerQuad.render(renderer);
    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
    this.copyQuad.material.uniforms["tDiffuse"].value = this.outputTargetInternal.texture;
    this.copyQuad.render(renderer);
    if (this.debugMode) {
      gl.endQuery(ext.TIME_ELAPSED_EXT);
      $87431ee93b037844$var$checkTimerQuery(timerQuery, gl, this);
    }
    renderer.xr.enabled = xrEnabled;
  }
  /**
       * Enables the debug mode of the AO, meaning the lastTime value will be updated.
       */
  enableDebugMode() {
    this.debugMode = true;
  }
  /**
       * Disables the debug mode of the AO, meaning the lastTime value will not be updated.
       */
  disableDebugMode() {
    this.debugMode = false;
  }
  /**
       * Sets the display mode of the AO
       * @param {"Combined" | "AO" | "No AO" | "Split" | "Split AO"} mode - The display mode. 
       */
  setDisplayMode(mode) {
    this.configuration.renderMode = [
      "Combined",
      "AO",
      "No AO",
      "Split",
      "Split AO"
    ].indexOf(mode);
  }
  /**
       * 
       * @param {"Performance" | "Low" | "Medium" | "High" | "Ultra"} mode 
       */
  setQualityMode(mode) {
    if (mode === "Performance") {
      this.configuration.aoSamples = 8;
      this.configuration.denoiseSamples = 4;
      this.configuration.denoiseRadius = 12;
    } else if (mode === "Low") {
      this.configuration.aoSamples = 16;
      this.configuration.denoiseSamples = 4;
      this.configuration.denoiseRadius = 12;
    } else if (mode === "Medium") {
      this.configuration.aoSamples = 16;
      this.configuration.denoiseSamples = 8;
      this.configuration.denoiseRadius = 12;
    } else if (mode === "High") {
      this.configuration.aoSamples = 64;
      this.configuration.denoiseSamples = 8;
      this.configuration.denoiseRadius = 6;
    } else if (mode === "Ultra") {
      this.configuration.aoSamples = 64;
      this.configuration.denoiseSamples = 16;
      this.configuration.denoiseRadius = 6;
    }
  }
};
var $05f6997e4b65da14$var$bluenoiseBits = Uint8Array.from(atob((0, $06269ad78f3c5fdf$export$2e2bcd8739ae039)), (c2) => c2.charCodeAt(0));

// node_modules/@needle-tools/engine/lib/engine-components/postprocessing/Effects/Sharpening.js
var __decorate73 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var SharpeningEffect = class extends PostProcessingEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "_effect");
  }
  get typeName() {
    return "Sharpening";
  }
  onCreateEffect() {
    return this.effect;
  }
  get effect() {
    this._effect ?? (this._effect = new _SharpeningEffect());
    return this._effect;
  }
  set amount(value) {
    this.effect.uniforms.get("amount").value = value;
  }
  get amount() {
    return this.effect.uniforms.get("amount").value;
  }
  set radius(value) {
    this.effect.uniforms.get("radius").value = value;
  }
  get radius() {
    return this.effect.uniforms.get("radius").value;
  }
};
__decorate73([
  serializable()
], SharpeningEffect.prototype, "amount", null);
__decorate73([
  serializable()
], SharpeningEffect.prototype, "radius", null);
var vert = `
  void mainSupport() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;
var frag = `
uniform sampler2D tDiffuse;
uniform float amount;
uniform float radius;

void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {
    float tx = 1.0 / resolution.x;
    float ty = 1.0 / resolution.y;
    vec2 texelSize = vec2(tx, ty);

    vec4 blurred = vec4(0.0);
    float total = 0.0;

    for (float x = -radius; x <= radius; x++) {
        for (float y = -radius; y <= radius; y++) {
            vec2 offset = vec2(x, y) * texelSize;
            vec4 diffuse = texture2D(tDiffuse, uv + offset);
            float weight = exp(-length(offset) * amount);
            blurred += diffuse * weight;
            total += weight;
        }
    }

    if (total > 0.0) {
        blurred /= total;
    }

    // Calculate the sharpened color using inputColor
    vec4 sharp = inputColor + clamp(inputColor - blurred, 0.0, 1.0) * amount;
    // Keep original alpha
    sharp.a = inputColor.a;

    // Ensure the sharp color does not go below 0 or above 1
    // This means: sharpening must happen AFTER tonemapping.
    sharp = clamp(sharp, 0.0, 1.0);

    outputColor = sharp;
}

`;
var _SharpeningEffect = class extends Effect {
  constructor() {
    super("Sharpening", frag, {
      vertexShader: vert,
      blendFunction: BlendFunction.NORMAL,
      uniforms: /* @__PURE__ */ new Map([
        ["amount", new Uniform$1(1)],
        ["radius", new Uniform$1(1)]
        // ["threshold", new Uniform(0)],
      ])
    });
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/postprocessing/PostProcessingHandler.js
var debug99 = getParam("debugpost");
var activeKey = Symbol("needle:postprocessing-handler");
var autoclearSetting = Symbol("needle:previous-autoclear-state");
var PostProcessingHandler = class {
  constructor(context) {
    __publicField(this, "_composer", null);
    __publicField(this, "_lastVolumeComponents");
    __publicField(this, "_effects", []);
    __publicField(this, "_isActive", false);
    __publicField(this, "context");
    this.context = context;
  }
  get isActive() {
    return this._isActive;
  }
  get composer() {
    return this._composer;
  }
  apply(components) {
    this._isActive = true;
    this.onApply(this.context, components);
  }
  unapply() {
    var _a2;
    if (debug99)
      console.log("Unapplying postprocessing effects");
    this._isActive = false;
    if (this._lastVolumeComponents) {
      for (const component of this._lastVolumeComponents) {
        component.unapply();
      }
      this._lastVolumeComponents.length = 0;
    }
    const context = this.context;
    const active = context[activeKey];
    if (active === this) {
      delete context[activeKey];
    }
    if (context.composer === this._composer) {
      (_a2 = context.composer) == null ? void 0 : _a2.dispose();
      context.composer = null;
    }
    if (typeof context.renderer[autoclearSetting] === "boolean") {
      context.renderer.autoClear = context.renderer[autoclearSetting];
    }
  }
  dispose() {
    this.unapply();
    for (const effect of this._effects) {
      effect.dispose();
    }
    this._effects.length = 0;
    this._composer = null;
  }
  onApply(context, components) {
    if (!components)
      return;
    context[activeKey] = this;
    if (debug99)
      console.log("Apply Postprocessing Effects", components);
    this._lastVolumeComponents = [...components];
    this._effects.length = 0;
    const ctx = {
      handler: this,
      components: this._lastVolumeComponents
    };
    for (let i = 0; i < this._lastVolumeComponents.length; i++) {
      const component = this._lastVolumeComponents[i];
      component.context = context;
      if (component.apply) {
        if (component.active) {
          if (!context.mainCameraComponent) {
            console.error("No camera in scene found or available yet - can not create postprocessing effects");
            return;
          }
          const res = component.apply(ctx);
          if (!res)
            continue;
          if (Array.isArray(res)) {
            this._effects.push(...res);
          } else
            this._effects.push(res);
        }
      } else {
        if (component.active)
          showBalloonWarning("Volume component is not a VolumeComponent: " + component["__type"]);
      }
    }
    if (this.context.renderer.toneMapping != NoToneMapping) {
      if (!this._effects.find((e) => e instanceof ToneMappingEffect)) {
        const tonemapping = new ToneMappingEffect();
        this._effects.push(tonemapping);
      }
    }
    this.applyEffects(context);
  }
  /** Build composer passes */
  applyEffects(context) {
    const effectsOrPasses = this._effects;
    if (effectsOrPasses.length <= 0)
      return;
    const camera = context.mainCameraComponent;
    const renderer = context.renderer;
    const scene = context.scene;
    const cam = camera.threeCamera;
    renderer[autoclearSetting] = renderer.autoClear;
    const maxSamples = renderer.capabilities.maxSamples;
    if (!this._composer) {
      this._composer = new EffectComposer(renderer, {
        frameBufferType: HalfFloatType,
        stencilBuffer: true,
        multisampling: Math.min(DeviceUtilities.isMobileDevice() ? 4 : 8, maxSamples)
      });
    }
    if (context.composer && context.composer !== this._composer) {
      console.warn("There's already an active EffectComposer in your scene: replacing it with a new one. This might cause unexpected behaviour. Make sure to only use one PostprocessingManager/Volume in your scene.");
    }
    context.composer = this._composer;
    const composer = context.composer;
    composer.setMainCamera(cam);
    composer.setRenderer(renderer);
    composer.setMainScene(scene);
    for (const prev of composer.passes)
      prev.dispose();
    composer.removeAllPasses();
    const screenpass = new RenderPass(scene, cam);
    screenpass.name = "Render To Screen";
    screenpass.mainScene = scene;
    composer.addPass(screenpass);
    const automaticEffectsOrdering = true;
    if (automaticEffectsOrdering) {
      try {
        this.orderEffects();
        const effects = [];
        for (const ef of effectsOrPasses) {
          if (ef instanceof Effect)
            effects.push(ef);
          else if (ef instanceof Pass) {
            const pass = new EffectPass(cam, ...effects);
            pass.mainScene = scene;
            pass.name = effects.map((e) => e.constructor.name).join(", ");
            pass.enabled = true;
            effects.length = 0;
            composer.addPass(ef);
          } else {
          }
        }
        if (effects.length > 0) {
          const pass = new EffectPass(cam, ...effects);
          pass.name = effects.map((e) => e.name).join(" ");
          pass.mainScene = scene;
          pass.enabled = true;
          composer.addPass(pass);
        }
      } catch (e) {
        console.error("Error while applying postprocessing effects", e);
        composer.removeAllPasses();
      }
    } else {
      for (const ef of effectsOrPasses) {
        if (ef instanceof Effect)
          composer.addPass(new EffectPass(cam, ef));
        else if (ef instanceof Pass)
          composer.addPass(ef);
        else
          composer.addPass(ef);
      }
    }
    if (debug99)
      console.log("PostProcessing Passes", effectsOrPasses, "->", composer.passes);
  }
  orderEffects() {
    var _a2;
    if (debug99)
      console.log("Before ordering effects", [...this._effects]);
    const effects = this._effects;
    effects.sort((a, b) => {
      const aidx = effectsOrder.findIndex((e) => a.constructor.name.endsWith(e.name));
      const bidx = effectsOrder.findIndex((e) => b.constructor.name.endsWith(e.name));
      if (aidx < 0) {
        if (debug99)
          console.warn("Unknown effect found: ", a.constructor.name);
        return -1;
      } else if (bidx < 0) {
        if (debug99)
          console.warn("Unknown effect found: ", b.constructor.name);
        return 1;
      }
      if (aidx < 0)
        return 1;
      if (bidx < 0)
        return -1;
      return aidx - bidx;
    });
    if (debug99)
      console.log("After ordering effects", [...this._effects]);
    for (let i = 0; i < effects.length; i++) {
      const effect = effects[i];
      if (((_a2 = effect == null ? void 0 : effect.configuration) == null ? void 0 : _a2.gammaCorrection) !== void 0) {
        const isLast = i === effects.length - 1;
        effect.configuration.gammaCorrection = isLast;
      }
    }
  }
};
var effectsOrder = [
  NormalPass,
  DepthDownsamplingPass,
  SMAAEffect,
  SSAOEffect,
  $87431ee93b037844$export$2489f9981ab0fa82,
  TiltShiftEffect,
  DepthOfFieldEffect,
  ChromaticAberrationEffect,
  BloomEffect,
  SelectiveBloomEffect,
  VignetteEffect,
  PixelationEffect,
  ToneMappingEffect,
  HueSaturationEffect,
  BrightnessContrastEffect,
  _SharpeningEffect
];

// node_modules/@needle-tools/engine/lib/engine/engine_element_extras.js
async function registerObservableAttribute(name) {
  const { NeedleEngineHTMLElement: NeedleEngineHTMLElement2 } = await import("./engine_element-VVBOQLYA.js");
  if (!NeedleEngineHTMLElement2.observedAttributes.includes(name))
    NeedleEngineHTMLElement2.observedAttributes.push(name);
}

// node_modules/@needle-tools/engine/lib/engine-components/Skybox.js
var __decorate74 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug100 = getParam("debugskybox");
registerObservableAttribute("skybox-image");
registerObservableAttribute("environment-image");
function createRemoteSkyboxComponent(context, url, skybox, environment, attribute) {
  const remote = new RemoteSkybox();
  remote.allowDrop = false;
  remote.allowNetworking = false;
  remote.background = skybox;
  remote.environment = environment;
  GameObject.addComponent(context.scene, remote);
  const urlChanged = (newValue) => {
    if (typeof newValue !== "string")
      return;
    if (debug100)
      console.log(attribute, "CHANGED TO", newValue);
    remote.setSkybox(newValue);
  };
  addAttributeChangeCallback(context.domElement, attribute, urlChanged);
  remote.addEventListener("destroy", () => {
    if (debug100)
      console.log("Destroyed attribute remote skybox", attribute);
    removeAttributeChangeCallback(context.domElement, attribute, urlChanged);
  });
  return remote.setSkybox(url);
}
ContextRegistry.addContextCreatedCallback((args) => {
  var _a2;
  const context = args.context;
  const skyboxImage = context.domElement.getAttribute("skybox-image") || context.domElement.getAttribute("background-image");
  const environmentImage = context.domElement.getAttribute("environment-image");
  const promises = new Array();
  if (skyboxImage) {
    if (debug100)
      console.log("Creating remote skybox to load " + skyboxImage);
    if (((_a2 = context.mainCameraComponent) == null ? void 0 : _a2.clearFlags) !== ClearFlags.Skybox)
      console.warn('"skybox-image"/"background-image" attribute has no effect: camera clearflags are not set to "Skybox"');
    const promise = createRemoteSkyboxComponent(context, skyboxImage, true, false, "skybox-image");
    promises.push(promise);
  }
  if (environmentImage) {
    if (debug100)
      console.log("Creating remote environment to load " + environmentImage);
    const promise = createRemoteSkyboxComponent(context, environmentImage, false, true, "environment-image");
    promises.push(promise);
  }
  if (promises.length > 0) {
    return PromiseAllWithErrors(promises);
  }
  return Promise.resolve();
});
function ensureGlobalCache() {
  if (!globalThis["NEEDLE_ENGINE_SKYBOX_TEXTURES"])
    globalThis["NEEDLE_ENGINE_SKYBOX_TEXTURES"] = new Array();
  return globalThis["NEEDLE_ENGINE_SKYBOX_TEXTURES"];
}
function tryGetPreviouslyLoadedTexture(src) {
  const cache = ensureGlobalCache();
  const found = cache.find((x2) => x2.src === src);
  if (found) {
    if (debug100)
      console.log("Skybox: Found previously loaded texture for " + src);
    return found.texture;
  }
  return null;
}
async function disposeCachedTexture(tex) {
  const texture = await tex;
  setDisposable(texture, true);
  disposeObjectResources(texture);
}
function registerLoadedTexture(src, texture) {
  const cache = ensureGlobalCache();
  while (cache.length > 5) {
    const entry = cache.shift();
    if (entry) {
      disposeCachedTexture(entry.texture);
    }
  }
  texture.then((t2) => {
    return setDisposable(t2, false);
  });
  cache.push({ src, texture });
}
var RemoteSkybox = class extends Component2 {
  constructor() {
    super(...arguments);
    /**
     * URL to a remote skybox. This value can also use a magic skybox name. Options are "quicklook", "quicklook-ar", "studio", "blurred-skybox".
     * @example
     * ```ts
     * skybox.url = "https://example.com/skybox.hdr";
     * ```
     */
    __publicField(this, "url");
    /**
     * When enabled a user can drop a link to a skybox image on the scene to set the skybox.
     * @default true
     */
    __publicField(this, "allowDrop", true);
    /**
     * When enabled the skybox will be set as the background of the scene.
     * @default true
     */
    __publicField(this, "background", true);
    /**
     * When enabled the skybox will be set as the environment of the scene (to be used as environment map for reflections and lighting)
     * @default true
     */
    __publicField(this, "environment", true);
    /**
     * When enabled dropped skybox urls (or assigned skybox urls) will be networked to other users in the same networked room.
     * @default true
     */
    __publicField(this, "allowNetworking", true);
    __publicField(this, "_loader");
    __publicField(this, "_prevUrl");
    __publicField(this, "_prevLoadedEnvironment");
    __publicField(this, "_prevEnvironment", null);
    __publicField(this, "_prevBackground", null);
    __publicField(this, "validTextureTypes", [".ktx2", ".hdr", ".exr", ".jpg", ".jpeg", ".png"]);
    __publicField(this, "onDragOverEvent", (e) => {
      if (!this.allowDrop)
        return;
      if (!e.dataTransfer)
        return;
      for (const type of e.dataTransfer.types) {
        if (type === "text/uri-list" || type === "Files") {
          e.preventDefault();
        }
      }
    });
    __publicField(this, "onDrop", (e) => {
      var _a2, _b, _c, _d;
      if (!this.allowDrop)
        return;
      if (!e.dataTransfer)
        return;
      for (const type of e.dataTransfer.types) {
        if (debug100)
          console.log(type);
        if (type === "text/uri-list") {
          const url = e.dataTransfer.getData(type);
          if (debug100)
            console.log(type, url);
          let name = (_b = (_a2 = new RegExp(/polyhaven.com\/asset_img\/.+?\/(?<name>.+)\.png/).exec(url)) == null ? void 0 : _a2.groups) == null ? void 0 : _b.name;
          if (!name) {
            name = (_d = (_c = new RegExp(/polyhaven\.com\/a\/(?<name>.+)/).exec(url)) == null ? void 0 : _c.groups) == null ? void 0 : _d.name;
          }
          if (debug100)
            console.log(name);
          if (name) {
            const skyboxurl = "https://dl.polyhaven.org/file/ph-assets/HDRIs/exr/1k/" + name + "_1k.exr";
            console.log(`[Remote Skybox] Setting skybox from url: ${skyboxurl}`);
            e.preventDefault();
            this.setSkybox(skyboxurl);
            break;
          } else if (this.isValidTextureType(url)) {
            console.log("[Remote Skybox] Setting skybox from url: " + url);
            e.preventDefault();
            this.setSkybox(url);
            break;
          } else {
            console.warn(`[RemoteSkybox] Unknown url ${url}. If you want to load a skybox from a url, make sure it is a valid image url. Url must end with${this.validTextureTypes.join(", ")}.`);
            const evt = new CustomEvent("dropped-unknown-url", {
              detail: {
                sender: this,
                event: e,
                url,
                apply: (url2) => {
                  e.preventDefault();
                  this.setSkybox(url2);
                }
              }
            });
            this.dispatchEvent(evt);
          }
        } else if (type == "Files") {
          const file = e.dataTransfer.files.item(0);
          if (debug100)
            console.log(type, file);
          if (!file)
            continue;
          if (!this.isValidTextureType(file.name)) {
            console.warn(`[RemoteSkybox]: File "${file.name}" is not supported. Supported files are ${this.validTextureTypes.join(", ")}`);
            return;
          }
          if (tryGetPreviouslyLoadedTexture(file.name) === null) {
            const blob = new Blob([file]);
            const url = URL.createObjectURL(blob);
            e.preventDefault();
            this.setSkybox(url, file.name);
          } else {
            e.preventDefault();
            this.setSkybox(file.name);
          }
          break;
        }
      }
    });
  }
  /** @internal */
  onEnable() {
    this.setSkybox(this.url);
    this.registerDropEvents();
  }
  /** @internal */
  onDisable() {
    var _a2;
    if (this.context.scene.environment === this._prevLoadedEnvironment) {
      this.context.scene.environment = this._prevEnvironment;
      if (!Camera2.backgroundShouldBeTransparent(this.context))
        this.context.scene.background = this._prevBackground;
      this._prevLoadedEnvironment = void 0;
    }
    this.unregisterDropEvents();
    (_a2 = this.context.mainCameraComponent) == null ? void 0 : _a2.applyClearFlags();
  }
  urlChangedSyncField() {
    if (this.allowNetworking && this.url) {
      if (this.isRemoteTexture(this.url)) {
        this.setSkybox(this.url);
      }
    }
  }
  /**
   * Set the skybox from a given url
   * @param url The url of the skybox image
   * @param name Define name of the file with extension if it isn't apart of the url
   * @returns Whether the skybox was successfully set
   */
  async setSkybox(url, name) {
    var _a2;
    if (!this.activeAndEnabled)
      return false;
    url = tryParseMagicSkyboxName(url, this.environment, this.background);
    if (!url)
      return false;
    name ?? (name = url);
    if (!this.isValidTextureType(name)) {
      console.warn("Potentially invalid skybox url", name, "on", this.name);
    }
    if (debug100)
      console.log("Set remote skybox url: " + url);
    if (this._prevUrl === url && this._prevLoadedEnvironment) {
      this.applySkybox();
      return true;
    } else {
      (_a2 = this._prevLoadedEnvironment) == null ? void 0 : _a2.dispose();
      this._prevLoadedEnvironment = void 0;
    }
    this._prevUrl = url;
    const envMap = await this.loadTexture(url, name);
    if (!envMap)
      return false;
    if (!this.enabled)
      return false;
    this.url = url;
    const nameIndex = url.lastIndexOf("/");
    envMap.name = url.substring(nameIndex >= 0 ? nameIndex + 1 : 0);
    if (this._loader instanceof TextureLoader) {
      envMap.colorSpace = SRGBColorSpace;
    }
    this._prevLoadedEnvironment = envMap;
    this.applySkybox();
    return true;
  }
  async loadTexture(url, name) {
    var _a2, _b, _c, _d, _e;
    if (!url)
      return Promise.resolve(null);
    name ?? (name = url);
    const cached = tryGetPreviouslyLoadedTexture(name);
    if (cached) {
      const res = await cached;
      if (((_b = (_a2 = res.source) == null ? void 0 : _a2.data) == null ? void 0 : _b.length) > 0 || ((_e = (_d = (_c = res.source) == null ? void 0 : _c.data) == null ? void 0 : _d.data) == null ? void 0 : _e.length))
        return res;
    }
    const isEXR = name.endsWith(".exr");
    const isHdr = name.endsWith(".hdr");
    const isKtx2 = name.endsWith(".ktx2");
    if (isEXR) {
      if (!(this._loader instanceof EXRLoader))
        this._loader = new EXRLoader();
    } else if (isHdr) {
      if (!(this._loader instanceof RGBELoader))
        this._loader = new RGBELoader();
    } else if (isKtx2) {
      if (!(this._loader instanceof KTX2Loader)) {
        const { ktx2Loader: ktx2Loader2 } = createLoaders(this.context.renderer);
        this._loader = ktx2Loader2;
      }
    } else {
      if (!(this._loader instanceof TextureLoader))
        this._loader = new TextureLoader();
    }
    if (debug100)
      console.log("Loading skybox: " + url);
    const loadingTask = this._loader.loadAsync(url);
    registerLoadedTexture(name, loadingTask);
    const envMap = await loadingTask;
    return envMap;
  }
  applySkybox() {
    var _a2;
    const envMap = this._prevLoadedEnvironment;
    if (!envMap)
      return;
    if (envMap instanceof CubeTexture || envMap instanceof CompressedCubeTexture) {
    } else {
      envMap.mapping = EquirectangularRefractionMapping;
      envMap.needsUpdate = true;
    }
    if (this.context.scene.background !== envMap)
      this._prevBackground = this.context.scene.background;
    if (this.context.scene.environment !== envMap)
      this._prevEnvironment = this.context.scene.environment;
    if (debug100)
      console.log("Set remote skybox", this.url, !Camera2.backgroundShouldBeTransparent(this.context));
    if (this.environment)
      this.context.scene.environment = envMap;
    if (this.background && !Camera2.backgroundShouldBeTransparent(this.context))
      this.context.scene.background = envMap;
    if (((_a2 = this.context.mainCameraComponent) == null ? void 0 : _a2.backgroundBlurriness) !== void 0)
      this.context.scene.backgroundBlurriness = this.context.mainCameraComponent.backgroundBlurriness;
  }
  isRemoteTexture(url) {
    return url.startsWith("http://") || url.startsWith("https://");
  }
  isValidTextureType(url) {
    for (const type of this.validTextureTypes) {
      if (url.endsWith(type))
        return true;
    }
    return false;
  }
  registerDropEvents() {
    this.unregisterDropEvents();
    this.context.domElement.addEventListener("dragover", this.onDragOverEvent);
    this.context.domElement.addEventListener("drop", this.onDrop);
  }
  unregisterDropEvents() {
    this.context.domElement.removeEventListener("dragover", this.onDragOverEvent);
    this.context.domElement.removeEventListener("drop", this.onDrop);
  }
};
__decorate74([
  syncField(RemoteSkybox.prototype.urlChangedSyncField),
  serializable(URL)
], RemoteSkybox.prototype, "url", void 0);
__decorate74([
  serializable()
], RemoteSkybox.prototype, "allowDrop", void 0);
__decorate74([
  serializable()
], RemoteSkybox.prototype, "background", void 0);
__decorate74([
  serializable()
], RemoteSkybox.prototype, "environment", void 0);
__decorate74([
  serializable()
], RemoteSkybox.prototype, "allowNetworking", void 0);
function tryParseMagicSkyboxName(str, environment, background) {
  const useLowRes = environment && !background;
  switch (str == null ? void 0 : str.toLowerCase()) {
    case "studio":
      if (useLowRes) {
        return "https://cdn.needle.tools/static/skybox/modelviewer-Neutral-small.hdr";
      } else
        return "https://cdn.needle.tools/static/skybox/modelviewer-Neutral.hdr";
    case "blurred-skybox":
      if (useLowRes) {
        return "https://cdn.needle.tools/static/skybox/blurred-skybox-small.exr";
      }
      return "https://cdn.needle.tools/static/skybox/blurred-skybox.exr";
    case "quicklook-ar":
      if (useLowRes) {
        return "https://cdn.needle.tools/static/skybox/QuickLook-ARMode-small.exr";
      }
      return "https://cdn.needle.tools/static/skybox/QuickLook-ARMode.exr";
    case "quicklook":
      if (useLowRes) {
        return "https://cdn.needle.tools/static/skybox/QuickLook-ObjectMode-small.exr";
      }
      return "https://cdn.needle.tools/static/skybox/QuickLook-ObjectMode.exr";
  }
  if (str === void 0)
    return null;
  return str;
}

// node_modules/@needle-tools/engine/lib/engine-components/SceneSwitcher.js
var __decorate75 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug101 = getParam("debugsceneswitcher");
var experimental_clearSceneOnLoad = getParam("sceneswitcher:clearscene");
var ENGINE_ELEMENT_SCENE_ATTRIBUTE_NAME = "scene";
registerObservableAttribute(ENGINE_ELEMENT_SCENE_ATTRIBUTE_NAME);
var couldNotLoadScenePromise = Promise.resolve(false);
var SceneSwitcher = class extends Component2 {
  constructor() {
    super(...arguments);
    /** When enabled the first scene will be loaded when the SceneSwitcher becomes active
     * @default true
    */
    __publicField(this, "autoLoadFirstScene", true);
    /**
     * The scenes that can be loaded by the SceneSwitcher.
     * @default []
     */
    __publicField(this, "scenes", []);
    /**
     * The scene that is displayed while a scene is loading.
     * @default undefined
     */
    __publicField(this, "loadingScene");
    /** the url parameter that is set/used to store the currently loaded scene in, set to "" to disable
     * @default "scene"
    */
    __publicField(this, "queryParameterName", "scene");
    /**
     * when enabled the scene name will be used as the query parameter (otherwise the scene index will be used)
     * Needs `queryParameterName` set
     * @default true
     */
    __publicField(this, "useSceneName", true);
    /**
     * When enabled the current scene index will be clamped to the scenes array bounds.
     * For example when the last scene is loaded and `clamp` is true then trying to load the `next()` scene will not change the scene.
     * When `clamp` is false and the last scene is loaded then the first scene will be loaded instead.
     * @default true
     */
    __publicField(this, "clamp", true);
    /** when enabled the new scene is pushed to the browser navigation history, only works with a valid query parameter set
     * @default true
    */
    __publicField(this, "useHistory", true);
    /** when enabled you can switch between scenes using keyboard left, right, A and D or number keys
     * @default true
    */
    __publicField(this, "useKeyboard", true);
    /** when enabled you can switch between scenes using swipe (mobile only)
     * @default true
    */
    __publicField(this, "useSwipe", true);
    /** when enabled will automatically apply the environment scene lights
     * @default true
    */
    __publicField(this, "useSceneLighting", true);
    /** When enabled will automatically apply the skybox from the loaded scene
     * @default true
     */
    __publicField(this, "useSceneBackground", true);
    /** how many scenes after the currently active scene should be preloaded
     * @default 1
    */
    __publicField(this, "preloadNext", 1);
    /** how many scenes before the currently active scene should be preloaded
     * @default 1
    */
    __publicField(this, "preloadPrevious", 1);
    /** how many scenes can be loaded in parallel
     * @default 2
    */
    __publicField(this, "preloadConcurrent", 2);
    /**
     * When enabled will create a button for the Needle menu to switch to the next or previous scene
     * @default false
     */
    __publicField(this, "createMenuButtons", false);
    /**
     * The sceneLoaded event is called when a scene/glTF is loaded and added to the scene
     */
    __publicField(this, "sceneLoaded", new EventList());
    __publicField(this, "_currentIndex", -1);
    __publicField(this, "_currentScene");
    __publicField(this, "_engineElementOverserver");
    __publicField(this, "_preloadScheduler");
    __publicField(this, "_menuButtons");
    __publicField(this, "onPopState", async (_state) => {
      if (!this.useHistory)
        return;
      const wasUsingHistory = this.useHistory;
      try {
        this.useHistory = false;
        let didResolve = false;
        if (this.queryParameterName)
          didResolve = await this.tryLoadFromQueryParam();
        if (!didResolve) {
          const state = _state == null ? void 0 : _state.state;
          if (state && state.startsWith(this.guid)) {
            const value = state.substr(this.guid.length + 2);
            if (debug101)
              console.log("PopState", value);
            await this.trySelectSceneFromValue(value);
          }
        }
      } finally {
        this.useHistory = wasUsingHistory;
      }
    });
    __publicField(this, "normalizedSwipeThresholdX", 0.1);
    __publicField(this, "_didSwipe", false);
    __publicField(this, "onInputPointerMove", (e) => {
      if (!this.useSwipe)
        return;
      if (!this._didSwipe && e.button === 0 && e.pointerType === "touch" && this.context.input.getPointerPressedCount() === 1) {
        const delta = this.context.input.getPointerPositionDelta(e.button);
        if (delta) {
          const normalizedX = delta.x / this.context.domWidth;
          if (normalizedX >= this.normalizedSwipeThresholdX) {
            this._didSwipe = true;
            this.selectPrev();
          } else if (normalizedX <= -this.normalizedSwipeThresholdX) {
            this._didSwipe = true;
            this.selectNext();
          }
        }
      }
    });
    __publicField(this, "onInputPointerUp", (e) => {
      if (e.button === 0) {
        this._didSwipe = false;
      }
    });
    __publicField(this, "onInputKeyDown", (e) => {
      if (!this.useKeyboard)
        return;
      if (!this.scenes)
        return;
      const key = e.key.toLowerCase();
      if (!key)
        return;
      const index = parseInt(key) - 1;
      if (index >= 0) {
        this.trySelectSceneFromValue(index);
        return;
      }
      switch (key) {
        case "arrowright":
        case "d":
          this.selectNext();
          break;
        case "arrowleft":
        case "a":
          this.selectPrev();
          break;
      }
    });
    // this is the scene that was requested last
    __publicField(this, "__lastSwitchScene");
    __publicField(this, "__lastSwitchScenePromise");
    __publicField(this, "_currentlyLoadingScene");
    __publicField(this, "_lastLoadingScene");
    __publicField(this, "_loadingScenePromise");
    __publicField(this, "_isCurrentlyLoading", false);
    __publicField(this, "_currentLoadingProgress");
  }
  /** The index of the currently loaded and active scene */
  get currentIndex() {
    return this._currentIndex;
  }
  /** Get the progress of the currently loading scene. This is undefined if no scene is loading
   * You can also subscribe to the loading event by adding an event listener to the scene switcher.
   * For example like this `sceneSwitcher.addEventListeneer("progress", (e) => {...})`
   */
  get currentLoadingProgress() {
    return this._currentLoadingProgress;
  }
  /** The currently loading scene. This is undefined if no scene is loading. */
  get currentlyLoadingScene() {
    return this._currentlyLoadingScene;
  }
  /**
   * The currently loaded scene. This is undefined if no scene is loaded.
   */
  get currentlyLoadedScene() {
    return this._currentScene;
  }
  /** @internal */
  awake() {
    if (this.scenes === void 0)
      this.scenes = [];
    for (const scene of this.scenes) {
      if (scene && !scene.hasUrl && scene.asset instanceof Object3D) {
        scene.asset.removeFromParent();
      }
    }
    if (debug101)
      console.log("SceneSwitcher", this);
  }
  /** @internal */
  async onEnable() {
    globalThis.addEventListener("popstate", this.onPopState);
    this.context.input.addEventListener(InputEvents.KeyDown, this.onInputKeyDown);
    this.context.input.addEventListener(InputEvents.PointerMove, this.onInputPointerMove);
    this.context.input.addEventListener(InputEvents.PointerUp, this.onInputPointerUp);
    if (!this._engineElementOverserver) {
      this._engineElementOverserver = new MutationObserver((mutations) => {
        for (const mut of mutations) {
          if (mut.type === "attributes" && mut.attributeName === ENGINE_ELEMENT_SCENE_ATTRIBUTE_NAME) {
            const value = this.context.domElement.getAttribute(ENGINE_ELEMENT_SCENE_ATTRIBUTE_NAME);
            if (value !== null) {
              this.trySelectSceneFromValue(value);
            }
          }
        }
      });
    }
    this._engineElementOverserver.observe(this.context.domElement, {
      attributes: true
    });
    if (!this._preloadScheduler)
      this._preloadScheduler = new PreLoadScheduler(this);
    this._preloadScheduler.maxLoadAhead = this.preloadNext;
    this._preloadScheduler.maxLoadBehind = this.preloadPrevious;
    this._preloadScheduler.maxConcurrent = this.preloadConcurrent;
    this._preloadScheduler.begin();
    if (this.autoLoadFirstScene && this._currentIndex === -1 && !await this.tryLoadFromQueryParam()) {
      const value = this.context.domElement.getAttribute(ENGINE_ELEMENT_SCENE_ATTRIBUTE_NAME);
      try {
        if (value === null || !await this.trySelectSceneFromValue(value)) {
          if (this._currentIndex === -1)
            this.select(0);
        }
      } finally {
      }
    }
    if (this.createMenuButtons) {
      this._menuButtons ?? (this._menuButtons = []);
      this._menuButtons.push(this.context.menu.appendChild({
        label: "Previous",
        icon: "arrow_back_ios",
        onClick: () => this.selectPrev(),
        priority: -1005,
        class: "row2"
      }));
      this._menuButtons.push(this.context.menu.appendChild({
        label: "Next",
        icon: "arrow_forward_ios",
        iconSide: "right",
        onClick: () => this.selectNext(),
        priority: -1e3,
        class: "row2"
      }));
    }
  }
  /** @internal */
  onDisable() {
    var _a2;
    globalThis.removeEventListener("popstate", this.onPopState);
    this.context.input.removeEventListener(InputEvents.KeyDown, this.onInputKeyDown);
    this.context.input.removeEventListener(InputEvents.PointerMove, this.onInputPointerMove);
    this.context.input.removeEventListener(InputEvents.PointerUp, this.onInputPointerUp);
    (_a2 = this._preloadScheduler) == null ? void 0 : _a2.stop();
    if (this._menuButtons) {
      for (const button of this._menuButtons) {
        button.remove();
      }
      this._menuButtons = void 0;
    }
  }
  /**
   * Add a scene to the SceneSwitcher.
   * If the scene is already added it will be added again.
   * @param urlOrAssetReference The url of the scene or an AssetReference to the scene
   * @returns The AssetReference of the scene that was added
   * @example
   * ```ts
   * // adding a scene:
   * sceneSwitcher.addScene("scene1.glb");
   * // add another scene and load it:
   * const scene2 = sceneSwitcher.addScene("scene2.glb");
   * sceneSwitcher.switchScene(scene2).then(res => { console.log("Scene loaded", res); });
   * ```
   */
  addScene(urlOrAssetReference) {
    if (typeof urlOrAssetReference === "string") {
      let assetReference = this.context.addressables.findAssetReference(urlOrAssetReference);
      if (!assetReference) {
        assetReference = new AssetReference(urlOrAssetReference);
        this.context.addressables.registerAssetReference(assetReference);
      }
      this.scenes.push(assetReference);
      return assetReference;
    }
    this.scenes.push(urlOrAssetReference);
    return urlOrAssetReference;
  }
  /**
   * Load the next scene in the scenes array ({@link this.currentIndex} + 1)
   * If the current scene is the last scene in the array and {@link this.clamp} is disabled then the first scene will be loaded.
   * @returns a promise that resolves to true if the scene was loaded successfully
   */
  selectNext() {
    return this.select(this._currentIndex + 1);
  }
  /**
   * Load the previous scene in the scenes array ({@link this.currentIndex} - 1)
   * If the current scene is the first scene in the array and {@link this.clamp} is disabled then the last scene will be loaded.
   * @returns a promise that resolves to true if the scene was loaded successfully
   */
  selectPrev() {
    return this.select(this._currentIndex - 1);
  }
  /**
   * Load a scene by its index in the scenes array.
   * @param index The index of the scene or a string that represents the scene uri (if the url is not known to the SceneSwitcher it will try to load the scene by its uri but it won't be added to the current scenes array. Use {@link addScene} to add a scene to the SceneSwitcher)
   * @returns a promise that resolves to true if the scene was loaded successfully
   */
  select(index) {
    var _a2, _b, _c;
    if (debug101)
      console.log("select", index);
    if (typeof index === "object") {
      console.warn('Switching to "' + index + '" might not work. Please either use an index or a AssetReference (not a scene reference)');
    }
    if (typeof index === "string") {
      const scene2 = (_a2 = this.scenes) == null ? void 0 : _a2.find((s) => s.url === index);
      if (!scene2) {
        const reference = AssetReference.getOrCreate(this.sourceId ?? "", index, this.context);
        return this.switchScene(reference);
      }
      if (scene2)
        index = (_b = this.scenes) == null ? void 0 : _b.indexOf(scene2);
      else
        return couldNotLoadScenePromise;
    }
    if (!((_c = this.scenes) == null ? void 0 : _c.length))
      return couldNotLoadScenePromise;
    if (index < 0) {
      if (this.clamp)
        return couldNotLoadScenePromise;
      index = this.scenes.length - 1;
    } else if (index >= this.scenes.length) {
      if (this.clamp)
        return couldNotLoadScenePromise;
      index = 0;
    }
    const scene = this.scenes[index];
    return this.switchScene(scene);
  }
  /**
   * Unload the currently loaded scene.
   */
  unload() {
    this.__lastSwitchScene = void 0;
    this.__lastSwitchScenePromise = void 0;
    return this.__unloadCurrentScene();
  }
  /**
   * Reload the last scene that was loaded
   * @returns a promise that resolves to true if the scene was loaded successfully
   */
  async reload() {
    if (this.__lastSwitchScene) {
      const scene = this.__lastSwitchScene;
      this.__lastSwitchScene = void 0;
      return this.switchScene(scene);
    }
    return false;
  }
  /**
   * Switch to a scene by its AssetReference.
   * If the scene is already loaded it will be unloaded and the new scene will be loaded.
   * If the scene is already loading it will wait for the scene to be loaded.
   * If the scene is already loaded and the same scene is requested again it will return the same promise that was returned the first time the scene was requested.
   * @param scene The AssetReference of the scene to switch to
   * @returns a promise that resolves to true if the scene was loaded successfully
   * @example
   * ```ts
   * const myAssetReference = new AssetReference("scene1.glb");
   * sceneSwitcher.switchScene(myAssetReference).then(res => { console.log("Scene loaded", res); });
   * ```
   */
  async switchScene(scene) {
    if (!(scene instanceof AssetReference)) {
      const type = typeof scene;
      if (type === "string") {
        return this.select(scene);
      } else if (type === "number") {
        return this.select(scene);
      } else {
        console.warn("SceneSwitcher: Can't switch to scene", scene, "of type", type);
        return false;
      }
    }
    if (scene.url === this.sourceId) {
      console.warn("SceneSwitcher: can't load own scene - prevent recursive loading", this.sourceId);
      return false;
    }
    if (this.__lastSwitchScene === scene && this.__lastSwitchScenePromise) {
      return this.__lastSwitchScenePromise;
    }
    this.__lastSwitchScene = scene;
    this.__lastSwitchScenePromise = this.__internalSwitchScene(scene);
    const res = await this.__lastSwitchScenePromise;
    return res;
  }
  async __unloadCurrentScene() {
    const current = this._currentScene;
    this._currentScene = void 0;
    if (current) {
      if (debug101)
        console.log("UNLOAD", current.url, "HasURL?: " + current.hasUrl);
      const sceneListener = this.tryGetSceneEventListener(current.asset);
      if (sceneListener == null ? void 0 : sceneListener.sceneClosing) {
        const res = sceneListener.sceneClosing();
        if (res instanceof Promise)
          await res;
      }
      if (current.hasUrl)
        current.unload();
      else if (current.asset instanceof Object3D) {
        current.asset.removeFromParent();
      }
    }
  }
  /** @internal */
  async __internalSwitchScene(scene) {
    var _a2, _b, _c, _d;
    await this.__unloadCurrentScene();
    const index = this._currentIndex = ((_a2 = this.scenes) == null ? void 0 : _a2.indexOf(scene)) ?? -1;
    try {
      this._currentlyLoadingScene = scene;
      this._currentLoadingProgress = new ProgressEvent("progress", { loaded: 0, total: 1 });
      const loadStartEvt = new CustomEvent("loadscene-start", { detail: { scene, switcher: this, index } });
      this.dispatchEvent(loadStartEvt);
      await this.onStartLoading();
      await scene.loadAssetAsync((_, prog) => {
        this._currentLoadingProgress = prog;
        this.dispatchEvent(prog);
      }).catch(console.error);
      await this.onEndLoading();
      const finishedEvt = new CustomEvent("loadscene-finished", { detail: { scene, switcher: this, index } });
      this.dispatchEvent(finishedEvt);
      this._currentLoadingProgress = void 0;
      this._currentlyLoadingScene = void 0;
      if (finishedEvt.defaultPrevented) {
        if (debug101)
          console.warn("Adding loaded scene prevented:", scene, finishedEvt);
        return false;
      }
      if (!scene.asset) {
        if (debug101)
          console.warn("Failed loading scene:", scene);
        return false;
      }
      if (this._currentIndex === index) {
        if (debug101)
          console.log("ADD", scene.url);
        this._currentScene = scene;
        if (experimental_clearSceneOnLoad) {
          const camera = ((_b = this.context.mainCameraComponent) == null ? void 0 : _b.gameObject) || this.context.mainCamera;
          camera == null ? void 0 : camera.removeFromParent();
          const self2 = this.gameObject.removeFromParent();
          destroy(this.context.scene, true, true);
          this.context.scene = new Scene();
          this.context.scene.add(self2);
          if (camera) {
            this.context.scene.add(camera);
          }
        }
        GameObject.add(scene.asset, this.gameObject);
        if (this.useSceneLighting)
          this.context.sceneLighting.enable(scene);
        if (this.useSceneBackground) {
          const skybox = this.context.lightmaps.tryGetSkybox(scene.url);
          if (skybox) {
            skybox.mapping = EquirectangularReflectionMapping;
            this.context.scene.background = skybox;
          } else if (debug101) {
            console.warn("SceneSwitcher: Can't find skybox for scene " + scene.url);
          }
        }
        if (this.useHistory && index >= 0) {
          let queryParameterValue = index.toString();
          if (this.useSceneName) {
            queryParameterValue = sceneUriToName(scene.url);
          }
          if ((_c = this.queryParameterName) == null ? void 0 : _c.length)
            setParamWithoutReload(this.queryParameterName, queryParameterValue, this.useHistory);
          else {
            const lastState = history.state;
            const stateName = this.guid + "::" + index;
            if (lastState !== stateName)
              history.pushState(stateName, "unused", location.href);
          }
        }
        const sceneListener = this.tryGetSceneEventListener(scene.asset);
        if (sceneListener == null ? void 0 : sceneListener.sceneOpened) {
          const res = sceneListener.sceneOpened(this);
          if (res instanceof Promise)
            await res;
        }
        const openedEvt = new CustomEvent("scene-opened", { detail: { scene, switcher: this, index } });
        this.dispatchEvent(openedEvt);
        (_d = this.sceneLoaded) == null ? void 0 : _d.invoke(this);
        return true;
      }
    } catch (err) {
      console.error(err);
    }
    return false;
  }
  preload(index) {
    if (index >= 0 && index < this.scenes.length) {
      const scene = this.scenes[index];
      if (scene instanceof AssetReference)
        return scene.preload();
    }
    return couldNotLoadScenePromise;
  }
  tryLoadFromQueryParam() {
    var _a2;
    if (!((_a2 = this.queryParameterName) == null ? void 0 : _a2.length))
      return couldNotLoadScenePromise;
    const value = getParam(this.queryParameterName);
    if (typeof value === "boolean")
      return couldNotLoadScenePromise;
    return this.trySelectSceneFromValue(value);
  }
  /** try to select a scene from a string or index */
  trySelectSceneFromValue(value) {
    if (typeof value === "string") {
      const index = parseInt(value);
      if (index >= 0 && index < this.scenes.length) {
        return this.select(index);
        ;
      } else {
        const lowerCaseValue = value.toLowerCase();
        for (let i = 0; i < this.scenes.length; i++) {
          const scene = this.scenes[i];
          if (!scene)
            continue;
          if (sceneUriToName(scene.url).toLowerCase().includes(lowerCaseValue)) {
            return this.select(i);
            ;
          }
        }
      }
    } else if (typeof value === "number") {
      if (value >= 0 && value < this.scenes.length) {
        return this.select(value);
        ;
      }
    }
    if (isLocalNetwork())
      console.warn('Can not find scene: "' + value + '"', this);
    return couldNotLoadScenePromise;
  }
  async onStartLoading() {
    var _a2, _b;
    this._isCurrentlyLoading = true;
    if (this.loadingScene) {
      if (this._lastLoadingScene !== this.loadingScene) {
        this._loadingScenePromise = void 0;
      }
      this._lastLoadingScene = this.loadingScene;
      if (!this._loadingScenePromise) {
        this._loadingScenePromise = (_a2 = this.loadingScene) == null ? void 0 : _a2.loadAssetAsync();
      }
      await this._loadingScenePromise;
      if (this._isCurrentlyLoading && ((_b = this.loadingScene) == null ? void 0 : _b.asset)) {
        if (debug101)
          console.log("Add loading scene", this.loadingScene.url, this.loadingScene.asset);
        const loadingScene = this.loadingScene.asset;
        GameObject.add(loadingScene, this.gameObject);
        const sceneListener = this.tryGetSceneEventListener(loadingScene);
        if (sceneListener == null ? void 0 : sceneListener.sceneOpened) {
          const res = sceneListener.sceneOpened(this);
          if (res instanceof Promise)
            await res;
        }
      }
    }
    if (this._isCurrentlyLoading) {
      const listener = this.tryGetSceneEventListener(this.gameObject);
      if (listener) {
        if (listener.sceneOpened) {
          const res = listener.sceneOpened(this);
          if (res instanceof Promise)
            await res;
        }
      }
    }
  }
  async onEndLoading() {
    var _a2;
    this._isCurrentlyLoading = false;
    if ((_a2 = this.loadingScene) == null ? void 0 : _a2.asset) {
      if (debug101)
        console.log("Remove loading scene", this.loadingScene.url);
      const obj = this.loadingScene.asset;
      const sceneListener = this.tryGetSceneEventListener(obj);
      if (typeof (sceneListener == null ? void 0 : sceneListener.sceneClosing) === "function") {
        const res = sceneListener.sceneClosing();
        if (res instanceof Promise)
          await res;
      }
      GameObject.remove(obj);
    }
    if (!this._isCurrentlyLoading) {
      const listener = this.tryGetSceneEventListener(this.gameObject);
      if (listener) {
        if (listener.sceneClosing) {
          const res = listener.sceneClosing();
          if (res instanceof Promise)
            await res;
        }
      }
    }
  }
  tryGetSceneEventListener(obj, level = 0) {
    if (!obj) {
      return null;
    }
    const sceneListener = GameObject.foreachComponent(obj, (c2) => {
      const i = c2;
      if (i.sceneClosing || i.sceneOpened)
        return i;
      else
        return void 0;
    });
    if (level === 0 && !sceneListener && obj.children.length) {
      for (const ch of obj.children) {
        const res = this.tryGetSceneEventListener(ch, level + 1);
        if (res)
          return res;
      }
    }
    if (!sceneListener)
      return null;
    return sceneListener;
  }
};
__decorate75([
  serializable()
], SceneSwitcher.prototype, "autoLoadFirstScene", void 0);
__decorate75([
  serializable(AssetReference)
], SceneSwitcher.prototype, "scenes", void 0);
__decorate75([
  serializable(AssetReference)
], SceneSwitcher.prototype, "loadingScene", void 0);
__decorate75([
  serializable()
], SceneSwitcher.prototype, "queryParameterName", void 0);
__decorate75([
  serializable()
], SceneSwitcher.prototype, "useSceneName", void 0);
__decorate75([
  serializable()
], SceneSwitcher.prototype, "clamp", void 0);
__decorate75([
  serializable()
], SceneSwitcher.prototype, "useHistory", void 0);
__decorate75([
  serializable()
], SceneSwitcher.prototype, "useKeyboard", void 0);
__decorate75([
  serializable()
], SceneSwitcher.prototype, "useSwipe", void 0);
__decorate75([
  serializable()
], SceneSwitcher.prototype, "useSceneLighting", void 0);
__decorate75([
  serializable()
], SceneSwitcher.prototype, "useSceneBackground", void 0);
__decorate75([
  serializable()
], SceneSwitcher.prototype, "preloadNext", void 0);
__decorate75([
  serializable()
], SceneSwitcher.prototype, "preloadPrevious", void 0);
__decorate75([
  serializable()
], SceneSwitcher.prototype, "preloadConcurrent", void 0);
__decorate75([
  serializable()
], SceneSwitcher.prototype, "createMenuButtons", void 0);
__decorate75([
  serializable(EventList)
], SceneSwitcher.prototype, "sceneLoaded", void 0);
function sceneUriToName(uri) {
  const name = uri.split("/").pop();
  const value = name == null ? void 0 : name.split(".").shift();
  if (value == null ? void 0 : value.length)
    return value;
  return uri;
}
var PreLoadScheduler = class {
  constructor(rooms, ahead = 1, behind = 1, maxConcurrent = 2) {
    __publicField(this, "maxLoadAhead");
    __publicField(this, "maxLoadBehind");
    __publicField(this, "maxConcurrent");
    __publicField(this, "_isRunning", false);
    __publicField(this, "_switcher");
    __publicField(this, "_loadTasks", []);
    __publicField(this, "_maxConcurrentLoads", 1);
    this._switcher = rooms;
    this.maxLoadAhead = ahead;
    this.maxLoadBehind = behind;
    this.maxConcurrent = maxConcurrent;
  }
  begin() {
    if (this._isRunning)
      return;
    if (debug101)
      console.log("Preload begin");
    this._isRunning = true;
    let lastRoom = -1;
    let searchDistance;
    let searchCall;
    const array = this._switcher.scenes;
    const interval = setInterval(() => {
      if (this.allLoaded()) {
        if (debug101)
          console.log("All scenes loaded");
        this.stop();
      }
      if (!this._isRunning) {
        clearInterval(interval);
        return;
      }
      if (this.canLoadNewScene() === false)
        return;
      if (lastRoom !== this._switcher.currentIndex) {
        lastRoom = this._switcher.currentIndex;
        searchCall = 0;
        searchDistance = 0;
      }
      const searchForward = searchCall % 2 === 0;
      if (searchForward)
        searchDistance += 1;
      searchCall += 1;
      const maxSearchDistance = searchForward ? this.maxLoadAhead : this.maxLoadBehind;
      if (searchDistance > maxSearchDistance)
        return;
      const roomIndex = searchForward ? lastRoom + searchDistance : lastRoom - searchDistance;
      if (roomIndex < 0)
        return;
      if (roomIndex < 0 || roomIndex >= array.length)
        return;
      const scene = array[roomIndex];
      new LoadTask(roomIndex, scene, this._loadTasks);
    }, 200);
  }
  stop() {
    this._isRunning = false;
  }
  canLoadNewScene() {
    return this._loadTasks.length < this._maxConcurrentLoads;
  }
  allLoaded() {
    if (this._switcher.scenes) {
      for (const scene of this._switcher.scenes) {
        if ((scene == null ? void 0 : scene.isLoaded()) === false)
          return false;
      }
    }
    return true;
  }
};
var LoadTask = class {
  constructor(index, asset, tasks) {
    __publicField(this, "index");
    __publicField(this, "asset");
    __publicField(this, "tasks");
    this.index = index;
    this.asset = asset;
    this.tasks = tasks;
    tasks.push(this);
    this.awaitLoading();
  }
  async awaitLoading() {
    if (this.asset && !this.asset.isLoaded()) {
      if (debug101)
        console.log("Preload start: " + this.asset.url, this.index);
      await this.asset.preload();
      if (debug101)
        console.log("Preload finished: " + this.asset.url, this.index);
    }
    const i = this.tasks.indexOf(this);
    if (i >= 0)
      this.tasks.splice(i, 1);
  }
};

// node_modules/@needle-tools/engine/lib/engine/engine_input_utils.js
function awaitInputAsync() {
  return new Promise((res, _) => {
    const callback = () => {
      if (fn2 == void 0)
        return;
      document.removeEventListener("pointerdown", fn2);
      document.removeEventListener("click", fn2);
      document.removeEventListener("dragstart", fn2);
      document.removeEventListener("touchstart", fn2);
      res();
    };
    const fn2 = callback;
    document.addEventListener("pointerdown", fn2);
    document.addEventListener("click", fn2);
    document.addEventListener("dragstart", fn2);
    document.addEventListener("touchstart", fn2);
  });
}
async function awaitInput(cb) {
  await awaitInputAsync();
  cb();
}

// node_modules/@needle-tools/engine/lib/engine-components/VideoPlayer.js
var __decorate76 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug102 = getParam("debugvideo");
var AspectMode;
(function(AspectMode2) {
  AspectMode2[AspectMode2["None"] = 0] = "None";
  AspectMode2[AspectMode2["AdjustHeight"] = 1] = "AdjustHeight";
  AspectMode2[AspectMode2["AdjustWidth"] = 2] = "AdjustWidth";
})(AspectMode || (AspectMode = {}));
var VideoSource;
(function(VideoSource2) {
  VideoSource2[VideoSource2["VideoClip"] = 0] = "VideoClip";
  VideoSource2[VideoSource2["Url"] = 1] = "Url";
})(VideoSource || (VideoSource = {}));
var VideoAudioOutputMode;
(function(VideoAudioOutputMode2) {
  VideoAudioOutputMode2[VideoAudioOutputMode2["None"] = 0] = "None";
  VideoAudioOutputMode2[VideoAudioOutputMode2["AudioSource"] = 1] = "AudioSource";
  VideoAudioOutputMode2[VideoAudioOutputMode2["Direct"] = 2] = "Direct";
  VideoAudioOutputMode2[VideoAudioOutputMode2["APIOnly"] = 3] = "APIOnly";
})(VideoAudioOutputMode || (VideoAudioOutputMode = {}));
var VideoRenderMode;
(function(VideoRenderMode2) {
  VideoRenderMode2[VideoRenderMode2["CameraFarPlane"] = 0] = "CameraFarPlane";
  VideoRenderMode2[VideoRenderMode2["CameraNearPlane"] = 1] = "CameraNearPlane";
  VideoRenderMode2[VideoRenderMode2["RenderTexture"] = 2] = "RenderTexture";
  VideoRenderMode2[VideoRenderMode2["MaterialOverride"] = 3] = "MaterialOverride";
})(VideoRenderMode || (VideoRenderMode = {}));
var VideoPlayer = class extends Component2 {
  /**
   * @internal
   */
  constructor() {
    super();
    /**
     * When true the video will start playing as soon as the component is enabled
     */
    __publicField(this, "playOnAwake", true);
    /**
     * The aspect mode to use for the video. If
     */
    __publicField(this, "aspectMode", AspectMode.None);
    __publicField(this, "clip", null);
    // set a default src, this should not be undefined
    __publicField(this, "source", VideoSource.Url);
    __publicField(this, "_url", null);
    __publicField(this, "renderMode");
    __publicField(this, "targetMaterialProperty");
    __publicField(this, "targetMaterialRenderer");
    __publicField(this, "targetTexture");
    __publicField(this, "time", 0);
    __publicField(this, "_playbackSpeed", 1);
    __publicField(this, "_isLooping", false);
    __publicField(this, "_muted", false);
    __publicField(this, "_audioOutputMode", VideoAudioOutputMode.Direct);
    /** Set this to false to pause video playback while the tab is not active
     * @default true
    */
    __publicField(this, "playInBackground", true);
    __publicField(this, "_crossOrigin", "anonymous");
    __publicField(this, "_videoElement", null);
    __publicField(this, "_videoTexture", null);
    __publicField(this, "_videoMaterial", null);
    __publicField(this, "_isPlaying", false);
    __publicField(this, "wasPlaying", false);
    __publicField(this, "visibilityChanged", (_) => {
      switch (document.visibilityState) {
        case "hidden":
          if (!this.playInBackground) {
            this.wasPlaying = this._isPlaying;
            this.pause();
          }
          break;
        case "visible":
          if (this.wasPlaying && !this._isPlaying)
            this.play();
          break;
      }
    });
    __publicField(this, "_receivedInput", false);
    __publicField(this, "_overlay", null);
    __publicField(this, "_targetObjects");
    __publicField(this, "_updateAspectRoutineId", -1);
    __publicField(this, "_hls");
    __publicField(this, "onHlsAvailable", () => {
      var _a2;
      if (debug102)
        console.log("HLS: available", this.clip);
      if (!this.shouldUseM3U || !this.url)
        return;
      if (!this._hls)
        this._hls = new Hls();
      this.videoElement.autoplay = true;
      this._hls.loadSource(this.url);
      this._hls.attachMedia(this.videoElement);
      (_a2 = this._videoElement) == null ? void 0 : _a2.play();
      if (debug102)
        console.log("HLS: loaded", this.clip);
    });
    awaitInput(() => {
      this._receivedInput = true;
      this.updateVideoElementSettings();
    });
    this._targetObjects = [];
    if (getParam("videoscreenspace")) {
      window.addEventListener("keydown", (evt) => {
        if (evt.key === "f") {
          this.screenspace = !this.screenspace;
        }
      });
    }
  }
  /**
   * The video clip url to play.
   */
  get url() {
    return this._url;
  }
  /**
   * The video clip to play.
   */
  set url(val) {
    const prev = this._url;
    const changed = prev !== val;
    if (this.__didAwake) {
      if (changed) {
        this.setClipURL(val ?? "");
      }
    } else
      this._url = val;
  }
  /**
   * Get the video playback speed. Increasing this value will speed up the video, decreasing it will slow it down.
   * @default 1
   */
  get playbackSpeed() {
    var _a2;
    return ((_a2 = this._videoElement) == null ? void 0 : _a2.playbackRate) ?? this._playbackSpeed;
  }
  /**
   * Set the video playback speed. Increasing this value will speed up the video, decreasing it will slow it down.
   */
  set playbackSpeed(val) {
    this._playbackSpeed = val;
    if (this._videoElement)
      this._videoElement.playbackRate = val;
  }
  get isLooping() {
    var _a2;
    return ((_a2 = this._videoElement) == null ? void 0 : _a2.loop) ?? this._isLooping;
  }
  set isLooping(val) {
    this._isLooping = val;
    if (this._videoElement)
      this._videoElement.loop = val;
  }
  /**
   * @returns the current time of the video in seconds
   */
  get currentTime() {
    var _a2;
    return ((_a2 = this._videoElement) == null ? void 0 : _a2.currentTime) ?? this.time;
  }
  /**
   * set the current time of the video in seconds
   */
  set currentTime(val) {
    if (this._videoElement) {
      this._videoElement.currentTime = val;
    } else
      this.time = val;
  }
  /**
   * @returns true if the video is currently playing
   */
  get isPlaying() {
    const video = this._videoElement;
    if (video) {
      if (video.currentTime > 0 && !video.paused && !video.ended && video.readyState > video.HAVE_CURRENT_DATA)
        return true;
      else if (video.srcObject) {
        const stream = video.srcObject;
        if (stream.active)
          return true;
      }
    }
    return false;
  }
  get crossOrigin() {
    var _a2;
    return ((_a2 = this._videoElement) == null ? void 0 : _a2.crossOrigin) ?? this._crossOrigin;
  }
  set crossOrigin(val) {
    this._crossOrigin = val;
    if (this._videoElement) {
      if (val !== null)
        this._videoElement.setAttribute("crossorigin", val);
      else
        this._videoElement.removeAttribute("crossorigin");
    }
  }
  /**
   * the material that is used to render the video
   */
  get videoMaterial() {
    if (!this._videoMaterial) {
      if (!this.create(false))
        return null;
    }
    return this._videoMaterial;
  }
  /**
   * the video texture that is used to render the video
   */
  get videoTexture() {
    if (!this._videoTexture) {
      if (!this.create(false))
        return null;
    }
    return this._videoTexture;
  }
  /**
   * the HTMLVideoElement that is used to play the video
   */
  get videoElement() {
    if (!this._videoElement) {
      if (!this.create(false))
        return null;
    }
    return this._videoElement;
  }
  /**
   * Request the browser to enter picture in picture mode
   * @link https://developer.mozilla.org/en-US/docs/Web/API/Picture-in-Picture_API
   * @returns the promise returned by the browser
   */
  requestPictureInPicture() {
    if (this._videoElement)
      return this._videoElement.requestPictureInPicture();
    return null;
  }
  /**
   * @returns true if the video is muted
   */
  get muted() {
    var _a2;
    return ((_a2 = this._videoElement) == null ? void 0 : _a2.muted) ?? this._muted;
  }
  /**
   * set the video to be muted
   */
  set muted(val) {
    this._muted = val;
    if (this._videoElement)
      this._videoElement.muted = val;
  }
  /**
   * The current video clip that is being played
   */
  get currentVideo() {
    return this.clip;
  }
  set audioOutputMode(mode) {
    if (mode !== this._audioOutputMode) {
      if (mode === VideoAudioOutputMode.AudioSource && isDevEnvironment())
        console.warn("VideoAudioOutputMode.AudioSource is not yet implemented");
      this._audioOutputMode = mode;
      this.updateVideoElementSettings();
    }
  }
  get audioOutputMode() {
    return this._audioOutputMode;
  }
  /** ensure's the video element has been created and will start loading the clip */
  preloadVideo() {
    if (debug102)
      console.log("Video Preload: " + this.name, this.clip);
    this.create(false);
  }
  /** @deprecated use `preloadVideo()` */
  preload() {
    this.preloadVideo();
  }
  /** Set a new video stream
   * starts to play automatically if the videoplayer hasnt been active before and playOnAwake is true */
  setVideo(video) {
    this.clip = video;
    this.source = VideoSource.VideoClip;
    if (!this._videoElement)
      this.create(this.playOnAwake);
    else {
      this._videoElement.srcObject = video;
      if (this._isPlaying)
        this.play();
      this.updateAspect();
    }
  }
  setClipURL(url) {
    if (this._url === url)
      return;
    this._url = url;
    this.source = VideoSource.Url;
    if (debug102)
      console.log("set url", url);
    if (!this._videoElement)
      this.create(this.playOnAwake);
    else {
      if (url.endsWith(".m3u8") || url.includes(".m3u")) {
        this.ensureM3UCanBePlayed();
      } else {
        this._videoElement.src = url;
        if (this._isPlaying) {
          this.stop();
          this.play();
        }
      }
    }
  }
  /** @internal */
  onEnable() {
    var _a2, _b;
    if (debug102)
      console.log("VideoPlayer.onEnable", VideoSource[this.source], this.clip, this.url, this);
    window.addEventListener("visibilitychange", this.visibilityChanged);
    if (this.playOnAwake === true) {
      this.create(true);
    } else {
      this.preloadVideo();
    }
    if (this.screenspace) {
      (_a2 = this._overlay) == null ? void 0 : _a2.start();
    } else
      (_b = this._overlay) == null ? void 0 : _b.stop();
  }
  /** @internal */
  onDisable() {
    var _a2;
    window.removeEventListener("visibilitychange", this.visibilityChanged);
    (_a2 = this._overlay) == null ? void 0 : _a2.stop();
    this.pause();
  }
  /** @internal */
  onDestroy() {
    var _a2;
    if (this._videoElement) {
      (_a2 = this.videoElement) == null ? void 0 : _a2.remove();
      this._videoElement = null;
    }
    if (this._videoTexture) {
      this._videoTexture.dispose();
      this._videoTexture = null;
    }
  }
  /** start playing the video source */
  play() {
    var _a2, _b;
    if (!this._videoElement)
      this.create(false);
    if (!this._videoElement) {
      if (debug102)
        console.warn("Can not play: no video element found", this);
      return;
    }
    if (this._isPlaying && !((_a2 = this._videoElement) == null ? void 0 : _a2.ended) && !((_b = this._videoElement) == null ? void 0 : _b.paused))
      return;
    this._isPlaying = true;
    if (!this._receivedInput)
      this._videoElement.muted = true;
    this.handleBeginPlaying(false);
    if (this.shouldUseM3U) {
      this.ensureM3UCanBePlayed();
      return;
    }
    if (debug102)
      console.log("Video Play()", this.clip, this._videoElement, this.time);
    this._videoElement.currentTime = this.time;
    this._videoElement.play().catch((err) => {
      var _a3;
      console.log(err);
      if (debug102)
        console.error("Error playing video", err, "CODE=" + err.code, (_a3 = this.videoElement) == null ? void 0 : _a3.src, this);
      setTimeout(() => {
        if (this._isPlaying && !this.destroyed && this.activeAndEnabled)
          this.play();
      }, 1e3);
    });
    if (debug102)
      console.log("play", this._videoElement, this.time);
  }
  /**
   * Stop the video playback. This will reset the video to the beginning
   */
  stop() {
    this._isPlaying = false;
    this.time = 0;
    if (!this._videoElement)
      return;
    this._videoElement.currentTime = 0;
    this._videoElement.pause();
    if (debug102)
      console.log("STOP", this);
  }
  /**
   * Pause the video playback
   */
  pause() {
    var _a2, _b;
    this.time = ((_a2 = this._videoElement) == null ? void 0 : _a2.currentTime) ?? 0;
    this._isPlaying = false;
    (_b = this._videoElement) == null ? void 0 : _b.pause();
    if (debug102)
      console.log("PAUSE", this, this.currentTime);
  }
  /** create the video element and assign the video source url or stream */
  create(playAutomatically) {
    let src;
    switch (this.source) {
      case VideoSource.VideoClip:
        src = this.clip;
        break;
      case VideoSource.Url:
        src = this.url;
        if (!(src == null ? void 0 : src.length) && typeof this.clip === "string")
          src = this.clip;
        break;
    }
    if (!src) {
      if (debug102)
        console.warn("No video source set", this);
      return false;
    }
    if (!this._videoElement) {
      if (debug102)
        console.warn("Create VideoElement", this);
      this._videoElement = this.createVideoElement();
      this.context.domElement.shadowRoot.prepend(this._videoElement);
      this.updateVideoElementStyles();
    }
    if (typeof src === "string") {
      if (debug102)
        console.log("Set Video src", src);
      this._videoElement.src = src;
    } else {
      if (debug102)
        console.log("Set Video srcObject", src);
      this._videoElement.srcObject = src;
    }
    if (!this._videoTexture)
      this._videoTexture = new VideoTexture(this._videoElement);
    this._videoTexture.flipY = false;
    this._videoTexture.colorSpace = SRGBColorSpace;
    if (playAutomatically)
      this.handleBeginPlaying(playAutomatically);
    if (debug102)
      console.log("Video: handle playing done...", src, playAutomatically);
    return true;
  }
  updateAspect() {
    if (this.aspectMode === AspectMode.None)
      return;
    this.startCoroutine(this.updateAspectImpl());
  }
  /**
   * If true the video will be rendered in screenspace mode and overlayed on top of the scene.
   * Alternatively you can also request the video to be played in PictureInPicture mode by calling `requestPictureInPicture()`
   */
  get screenspace() {
    var _a2;
    return ((_a2 = this._overlay) == null ? void 0 : _a2.enabled) ?? false;
  }
  set screenspace(val) {
    var _a2;
    if (val) {
      if (!this._videoTexture)
        return;
      if (!this._overlay)
        this._overlay = new VideoOverlay(this.context);
      this._overlay.add(this._videoTexture);
    } else
      (_a2 = this._overlay) == null ? void 0 : _a2.remove(this._videoTexture);
    if (this._overlay)
      this._overlay.enabled = val;
  }
  createVideoElement() {
    const video = document.createElement("video");
    if (this._crossOrigin)
      video.setAttribute("crossorigin", this._crossOrigin);
    if (debug102)
      console.log("created video element", video);
    return video;
  }
  handleBeginPlaying(playAutomatically) {
    var _a2, _b;
    if (!this.activeAndEnabled)
      return;
    if (!this._videoElement)
      return;
    this._targetObjects.length = 0;
    let target = this.gameObject;
    switch (this.renderMode) {
      case VideoRenderMode.MaterialOverride:
        target = (_a2 = this.targetMaterialRenderer) == null ? void 0 : _a2.gameObject;
        if (!target)
          target = (_b = GameObject.getComponent(this.gameObject, Renderer)) == null ? void 0 : _b.gameObject;
        break;
      case VideoRenderMode.RenderTexture:
        console.error("VideoPlayer renderTexture not implemented yet. Please use material override instead");
        return;
    }
    if (!target) {
      console.error("Missing target for video material renderer", this.name, VideoRenderMode[this.renderMode], this);
      return;
    }
    const mat = target["material"];
    if (mat) {
      this._targetObjects.push(target);
      if (mat !== this._videoMaterial) {
        this._videoMaterial = mat.clone();
        target["material"] = this._videoMaterial;
      }
      const fieldName = "map";
      const videoMaterial = this._videoMaterial;
      if (!this.targetMaterialProperty) {
        videoMaterial[fieldName] = this._videoTexture;
      } else {
        switch (this.targetMaterialProperty) {
          default:
            videoMaterial[fieldName] = this._videoTexture;
            break;
        }
      }
    } else {
      console.warn("Can not play video, no material found, this might be a multimaterial case which is not supported yet");
      return;
    }
    this.updateVideoElementSettings();
    this.updateVideoElementStyles();
    if (playAutomatically) {
      if (this.shouldUseM3U) {
        this.ensureM3UCanBePlayed();
      }
      this.play();
    }
  }
  updateVideoElementSettings() {
    if (!this._videoElement)
      return;
    this._videoElement.loop = this._isLooping;
    this._videoElement.currentTime = this.currentTime;
    this._videoElement.playbackRate = this._playbackSpeed;
    this._videoElement.playsInline = true;
    let muted = !this._receivedInput || this.audioOutputMode === VideoAudioOutputMode.None;
    if (!muted && this._muted)
      muted = true;
    this._videoElement.muted = muted;
    if (this.playOnAwake)
      this._videoElement.autoplay = true;
  }
  updateVideoElementStyles() {
    if (!this._videoElement)
      return;
    this._videoElement.style.userSelect = "none";
    this._videoElement.style.visibility = "hidden";
    this._videoElement.style.display = "none";
    this.updateAspect();
  }
  *updateAspectImpl() {
    const id = ++this._updateAspectRoutineId;
    const lastAspect = void 0;
    const stream = this.clip;
    while (id === this._updateAspectRoutineId && this.aspectMode !== AspectMode.None && this.clip && stream === this.clip && this._isPlaying) {
      if (!stream || typeof stream === "string") {
        return;
      }
      let aspect = void 0;
      for (const track of stream.getVideoTracks()) {
        const settings = track.getSettings();
        if (settings && settings.width && settings.height) {
          aspect = settings.width / settings.height;
          break;
        } else {
          aspect = this.context.renderer.domElement.clientWidth / this.context.renderer.domElement.clientHeight;
        }
      }
      if (aspect === void 0) {
        for (let i = 0; i < 10; i++)
          yield;
        if (!this.isPlaying)
          break;
        continue;
      }
      if (lastAspect === aspect) {
        yield;
        continue;
      }
      for (const obj of this._targetObjects) {
        let worldAspect = 1;
        if (obj.parent) {
          const parentScale = getWorldScale(obj.parent);
          worldAspect = parentScale.x / parentScale.y;
        }
        switch (this.aspectMode) {
          case AspectMode.AdjustHeight:
            obj.scale.y = 1 / aspect * obj.scale.x * worldAspect;
            break;
          case AspectMode.AdjustWidth:
            obj.scale.x = aspect * obj.scale.y * worldAspect;
            break;
        }
      }
      for (let i = 0; i < 3; i++)
        yield;
    }
  }
  get shouldUseM3U() {
    return this.url != void 0 && (this.url.endsWith(".m3u8") || this.url.endsWith(".m3u")) && this.source === VideoSource.Url;
  }
  ensureM3UCanBePlayed() {
    if (!this.shouldUseM3U)
      return;
    let hls_script = document.head.querySelector("script[data-hls_library]");
    if (!hls_script) {
      if (debug102)
        console.log("HLS: load script");
      hls_script = document.createElement("script");
      hls_script.dataset["hls_library"] = "hls.js";
      hls_script.src = "https://cdn.jsdelivr.net/npm/hls.js@1";
      hls_script.addEventListener("load", this.onHlsAvailable);
      document.head.append(hls_script);
    } else if (globalThis["Hls"]) {
      this.onHlsAvailable();
    } else {
      hls_script.addEventListener("load", this.onHlsAvailable);
    }
  }
};
__decorate76([
  serializable()
], VideoPlayer.prototype, "playOnAwake", void 0);
__decorate76([
  serializable()
], VideoPlayer.prototype, "aspectMode", void 0);
__decorate76([
  serializable(URL)
], VideoPlayer.prototype, "clip", void 0);
__decorate76([
  serializable()
], VideoPlayer.prototype, "source", void 0);
__decorate76([
  serializable(URL)
], VideoPlayer.prototype, "url", null);
__decorate76([
  serializable()
], VideoPlayer.prototype, "renderMode", void 0);
__decorate76([
  serializable()
], VideoPlayer.prototype, "targetMaterialProperty", void 0);
__decorate76([
  serializable(Renderer)
], VideoPlayer.prototype, "targetMaterialRenderer", void 0);
__decorate76([
  serializable(Texture)
], VideoPlayer.prototype, "targetTexture", void 0);
__decorate76([
  serializable()
], VideoPlayer.prototype, "time", void 0);
__decorate76([
  serializable()
], VideoPlayer.prototype, "playbackSpeed", null);
__decorate76([
  serializable()
], VideoPlayer.prototype, "isLooping", null);
__decorate76([
  serializable()
], VideoPlayer.prototype, "audioOutputMode", null);
var VideoOverlay = class {
  constructor(context) {
    __publicField(this, "context");
    __publicField(this, "_videos", []);
    __publicField(this, "_screenspaceModeQuad");
    __publicField(this, "_isInScreenspaceMode", false);
    __publicField(this, "_input");
    this.context = context;
    this._input = new VideoOverlayInput(this);
  }
  get enabled() {
    return this._isInScreenspaceMode;
  }
  set enabled(val) {
    if (val)
      this.start();
    else
      this.stop();
  }
  add(video) {
    if (this._videos.indexOf(video) === -1) {
      this._videos.push(video);
    }
  }
  remove(video) {
    if (!video)
      return;
    const index = this._videos.indexOf(video);
    if (index >= 0) {
      this._videos.splice(index, 1);
    }
  }
  start() {
    var _a2;
    if (this._isInScreenspaceMode)
      return;
    if (this._videos.length < 0)
      return;
    const texture = this._videos[this._videos.length - 1];
    if (!texture)
      return;
    this._isInScreenspaceMode = true;
    if (!this._screenspaceModeQuad) {
      this._screenspaceModeQuad = ObjectUtils.createPrimitive(PrimitiveType.Quad, {
        material: new ScreenspaceTexture(texture)
      });
      if (!this._screenspaceModeQuad)
        return;
      this._screenspaceModeQuad.geometry.scale(2, 2, 2);
    }
    const quad = this._screenspaceModeQuad;
    this.context.scene.add(quad);
    this.updateScreenspaceMaterialUniforms();
    const mat = quad.material;
    mat == null ? void 0 : mat.reset();
    (_a2 = this._input) == null ? void 0 : _a2.enable(mat);
  }
  stop() {
    var _a2;
    this._isInScreenspaceMode = false;
    if (this._screenspaceModeQuad) {
      (_a2 = this._input) == null ? void 0 : _a2.disable();
      this._screenspaceModeQuad.removeFromParent();
    }
  }
  updateScreenspaceMaterialUniforms() {
    var _a2;
    const mat = (_a2 = this._screenspaceModeQuad) == null ? void 0 : _a2.material;
    if (!mat)
      return;
    mat.screenAspect = this.context.domElement.clientWidth / this.context.domElement.clientHeight;
  }
};
var VideoOverlayInput = class {
  constructor(overlay) {
    __publicField(this, "_onResizeScreenFn");
    __publicField(this, "_onKeyUpFn");
    __publicField(this, "_onMouseWheelFn");
    __publicField(this, "context");
    __publicField(this, "overlay");
    __publicField(this, "_material");
    __publicField(this, "_isPinching", false);
    __publicField(this, "_lastPinch", 0);
    this.overlay = overlay;
    this.context = overlay.context;
  }
  enable(mat) {
    this._material = mat;
    window.addEventListener("resize", this._onResizeScreenFn = () => {
      this.overlay.updateScreenspaceMaterialUniforms();
    });
    window.addEventListener("keyup", this._onKeyUpFn = (args) => {
      if (args.key === "Escape")
        this.overlay.stop();
    });
    window.addEventListener("wheel", this._onMouseWheelFn = (args) => {
      if (this.overlay.enabled) {
        mat.zoom += args.deltaY * 5e-4;
        args.preventDefault();
      }
    }, { passive: false });
    const delta = new Vector2();
    window.addEventListener("mousemove", (args) => {
      if (this.overlay.enabled && this.context.input.getPointerPressed(0)) {
        const normalizedMovement = new Vector2(args.movementX, args.movementY);
        normalizedMovement.x /= this.context.domElement.clientWidth;
        normalizedMovement.y /= this.context.domElement.clientHeight;
        delta.set(normalizedMovement.x, normalizedMovement.y);
        delta.multiplyScalar(mat.zoom / -this.context.time.deltaTime * 0.01);
        mat.offset = mat.offset.add(delta);
      }
    });
    window.addEventListener("pointermove", (args) => {
      if (this.overlay.enabled && this.context.input.getPointerPressed(0)) {
        const count = this.context.input.getTouchesPressedCount();
        if (count === 1) {
          delta.set(args.movementX, args.movementY);
          delta.multiplyScalar(mat.zoom * -this.context.time.deltaTime * 0.05);
          mat.offset = mat.offset.add(delta);
        }
      }
    });
    let lastTouchStartTime = 0;
    window.addEventListener("touchstart", (e) => {
      if (e.touches.length < 2) {
        if (this.context.time.time - lastTouchStartTime < 0.3) {
          this.overlay.stop();
        }
        lastTouchStartTime = this.context.time.time;
        return;
      }
      this._isPinching = true;
      this._lastPinch = 0;
    });
    window.addEventListener("touchmove", (e) => {
      if (!this._isPinching || !this._material)
        return;
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      const dx = touch1.clientX - touch2.clientX;
      const dy = touch1.clientY - touch2.clientY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      if (this._lastPinch !== 0) {
        const delta2 = distance - this._lastPinch;
        this._material.zoom -= delta2 * 4e-3;
      }
      this._lastPinch = distance;
    });
    window.addEventListener("touchend", () => {
      this._isPinching = false;
    });
  }
  disable() {
    if (this._onResizeScreenFn) {
      window.removeEventListener("resize", this._onResizeScreenFn);
      this._onResizeScreenFn = void 0;
    }
    if (this._onKeyUpFn) {
      window.removeEventListener("keyup", this._onKeyUpFn);
      this._onKeyUpFn = void 0;
    }
    if (this._onMouseWheelFn) {
      window.removeEventListener("wheel", this._onMouseWheelFn);
      this._onMouseWheelFn = void 0;
    }
  }
};
var ScreenspaceTexture = class extends ShaderMaterial {
  // maxZoom : number = 10
  constructor(tex) {
    super();
    __publicField(this, "_offset", new Vector2());
    this.uniforms = {
      map: { value: tex },
      screenAspect: { value: 1 },
      offsetScale: { value: new Vector4(0, 0, 1, 1) }
    };
    this.vertexShader = `
        uniform sampler2D map;
        uniform float screenAspect;
        uniform vec4 offsetScale;
        varying vec2 vUv;

        void main() {

            gl_Position = vec4( position , 1.0 );
            vUv = uv;
            vUv.y = 1. - vUv.y;

            // fit into screen
            ivec2 res = textureSize(map, 0);
            float videoAspect = float(res.x) / float(res.y);
            float aspect = videoAspect / screenAspect;
            if(aspect >= 1.0) 
            {
                vUv.y = vUv.y * aspect;
                float offset = (1. - aspect) * .5;
                vUv.y = vUv.y + offset;
            }
            else
            {
                vUv.x = vUv.x / aspect;
                float offset = (1. - 1. / aspect) * .5;
                vUv.x = vUv.x + offset;
            }

            vUv.x -= .5;
            vUv.y -= .5;

            vUv.x *= offsetScale.z;
            vUv.y *= offsetScale.z;
            vUv.x += offsetScale.x;
            vUv.y += offsetScale.y;

            vUv.x += .5;
            vUv.y += .5;
        }

        `;
    this.fragmentShader = `
        uniform sampler2D map;
        varying vec2 vUv;
        void main() {
            if(vUv.x < 0. || vUv.x > 1. || vUv.y < 0. || vUv.y > 1.)
                gl_FragColor = vec4(0., 0., 0., 1.);
            else
            {
                vec4 texcolor = texture2D(map, vUv);
                texcolor = LinearTosRGB(texcolor);
                gl_FragColor = texcolor;
            }
        }
        `;
  }
  set screenAspect(val) {
    this.uniforms["screenAspect"].value = val;
    this.needsUpdate = true;
  }
  set offset(vec2) {
    const val = this.uniforms["offsetScale"].value;
    val.x = vec2.x;
    val.y = vec2.y;
    this.uniforms["offsetScale"].value = val;
    this.needsUpdate = true;
  }
  get offset() {
    const val = this.uniforms["offsetScale"].value;
    this._offset.set(val.x, val.y);
    return this._offset;
  }
  set zoom(val) {
    const zoom = this.uniforms["offsetScale"].value;
    if (val < 1e-3)
      val = 1e-3;
    zoom.z = val;
    this.needsUpdate = true;
  }
  get zoom() {
    return this.uniforms["offsetScale"].value.z;
  }
  reset() {
    this.offset = this.offset.set(0, 0);
    this.zoom = 1;
    this.needsUpdate = true;
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/ScreenCapture.js
var __decorate77 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug103 = getParam("debugscreensharing");
var ScreenCaptureDevice;
(function(ScreenCaptureDevice2) {
  ScreenCaptureDevice2[ScreenCaptureDevice2["Screen"] = 0] = "Screen";
  ScreenCaptureDevice2[ScreenCaptureDevice2["Camera"] = 1] = "Camera";
  ScreenCaptureDevice2[ScreenCaptureDevice2["Canvas"] = 2] = "Canvas";
  ScreenCaptureDevice2[ScreenCaptureDevice2["Microphone"] = 3] = "Microphone";
})(ScreenCaptureDevice || (ScreenCaptureDevice = {}));
var ScreenCaptureMode;
(function(ScreenCaptureMode2) {
  ScreenCaptureMode2[ScreenCaptureMode2["Idle"] = 0] = "Idle";
  ScreenCaptureMode2[ScreenCaptureMode2["Sending"] = 1] = "Sending";
  ScreenCaptureMode2[ScreenCaptureMode2["Receiving"] = 2] = "Receiving";
})(ScreenCaptureMode || (ScreenCaptureMode = {}));
var ScreenCapture = class extends Component2 {
  constructor() {
    super(...arguments);
    /**
     * When enabled the stream will start when the user clicks on the object this component is attached to
     * It is also possible to start the stream manually from your code by calling the {@link share} method
     * To modify what type of device is shared you can set the {@link device} property.
     * @default true
     */
    __publicField(this, "allowStartOnClick", true);
    /** When enabled the stream will start when this component becomes active (enabled in the scene) */
    __publicField(this, "autoConnect", false);
    __publicField(this, "_videoPlayer");
    __publicField(this, "_audioSource");
    /**
     * Which streaming device type should be used when starting to share (if {@link share} is called without a device option). Options are Screen, Camera, Microphone.
     * This is e.g. used if `allowStartOnClick` is enabled and the user clicks on the object.
     * @default Screen
     */
    __publicField(this, "device", "Screen");
    /**
     * If assigned the device the device will be selected by this id or label when starting to share.
     * Note: This is only supported for `Camera` devices
     */
    __publicField(this, "deviceName");
    /**
     * Filter which device should be chosen for sharing by id or label.
     * Assign a method to this property to manually filter the available devices.
     */
    __publicField(this, "deviceFilter");
    __publicField(this, "_net");
    __publicField(this, "_requestOpen", false);
    __publicField(this, "_currentStream", null);
    __publicField(this, "_currentMode", ScreenCaptureMode.Idle);
    __publicField(this, "onJoinedRoom", async () => {
      await delay(1e3);
      if (this.autoConnect && !this.isSending && !this.isReceiving && this.context.connection.isInRoom) {
        this.share();
      }
    });
    __publicField(this, "_activeShareRequest", null);
    __publicField(this, "onReceiveStream", (evt) => {
      var _a2;
      if (((_a2 = evt.stream) == null ? void 0 : _a2.active) !== true)
        return;
      this.setStream(evt.stream, ScreenCaptureMode.Receiving);
    });
    __publicField(this, "onCallEnded", (_evt) => {
      if (debug103)
        console.log("CALL ENDED", this.isReceiving, this == null ? void 0 : this.screenspace);
      if (this.isReceiving)
        this.screenspace = false;
    });
  }
  /** @internal */
  onPointerEnter() {
    if (this.context.connection.allowEditing == false)
      return;
    if (!this.allowStartOnClick)
      return;
    this.context.input.setCursorPointer();
  }
  /** @internal */
  onPointerExit() {
    if (this.context.connection.allowEditing == false)
      return;
    if (!this.allowStartOnClick)
      return;
    this.context.input.setCursorNormal();
  }
  /** @internal */
  onPointerClick(evt) {
    var _a2;
    if (this.context.connection.allowEditing == false)
      return;
    if (!this.allowStartOnClick)
      return;
    if (evt && evt.pointerId !== 0)
      return;
    if (this.isReceiving && ((_a2 = this.videoPlayer) == null ? void 0 : _a2.isPlaying)) {
      if (this.videoPlayer)
        this.videoPlayer.screenspace = !this.videoPlayer.screenspace;
      return;
    }
    if (this.isSending) {
      this.close();
      return;
    }
    this.share();
  }
  /**
   * If a VideoPlayer component is assigned to this property the video will be displayed on the VideoPlayer component.
   */
  set videoPlayer(val) {
    if (this._videoPlayer && (this.isSending || this.isReceiving)) {
      this._videoPlayer.stop();
    }
    this._videoPlayer = val;
    if (this._videoPlayer && this._currentStream && (this.isSending || this.isReceiving)) {
      this._videoPlayer.setVideo(this._currentStream);
    }
  }
  get videoPlayer() {
    return this._videoPlayer;
  }
  /**
   * When enabled the video will be displayed in the screenspace of the VideoPlayer component.
   */
  get screenspace() {
    var _a2;
    return ((_a2 = this.videoPlayer) == null ? void 0 : _a2.screenspace) ?? false;
  }
  set screenspace(v4) {
    if (this.videoPlayer)
      this.videoPlayer.screenspace = v4;
  }
  /**
   * the current stream that is being shared or received
   * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaStream
   */
  get currentScream() {
    return this._currentStream;
  }
  get currentMode() {
    return this._currentMode;
  }
  /**
   * @returns true if the component is currently sending a stream
   */
  get isSending() {
    var _a2;
    return ((_a2 = this._currentStream) == null ? void 0 : _a2.active) && this._currentMode === ScreenCaptureMode.Sending;
  }
  /**
   * @returns true if the component is currently receiving a stream
   */
  get isReceiving() {
    if (this._currentMode === ScreenCaptureMode.Receiving) {
      if (!this._currentStream || this._currentStream.active === false)
        return false;
      const tracks = this._currentStream.getTracks();
      for (const track of tracks) {
        if (track.readyState === "live")
          return true;
      }
    }
    return false;
  }
  get requiresVideoPlayer() {
    return this.device !== "Microphone";
  }
  /** @internal */
  awake() {
    if (typeof this.device === "number") {
      this.device = ScreenCaptureDevice[this.device];
    }
    if (debug103)
      console.log("Screensharing", this.name, this);
    AudioSource.registerWaitForAllowAudio(() => {
      if (this._videoPlayer && this._currentStream && this._currentMode === ScreenCaptureMode.Receiving) {
        this._videoPlayer.playInBackground = true;
        this._videoPlayer.setVideo(this._currentStream);
      }
    });
    this._net = new NetworkedStreams(this);
  }
  /** @internal */
  onEnable() {
    var _a2, _b, _c;
    (_a2 = this._net) == null ? void 0 : _a2.enable();
    (_b = this._net) == null ? void 0 : _b.addEventListener(NetworkedStreamEvents.StreamReceived, this.onReceiveStream);
    (_c = this._net) == null ? void 0 : _c.addEventListener(NetworkedStreamEvents.StreamEnded, this.onCallEnded);
    this.context.connection.beginListen(RoomEvents.JoinedRoom, this.onJoinedRoom);
    if (this.autoConnect) {
      delay(1e3).then(() => {
        if (this.enabled && this.autoConnect && !this.isReceiving && !this.isSending && this.context.connection.isInRoom)
          this.share();
        return 0;
      });
    }
  }
  /** @internal */
  onDisable() {
    var _a2, _b, _c;
    (_a2 = this._net) == null ? void 0 : _a2.removeEventListener(NetworkedStreamEvents.StreamReceived, this.onReceiveStream);
    (_b = this._net) == null ? void 0 : _b.removeEventListener(NetworkedStreamEvents.StreamEnded, this.onCallEnded);
    this.context.connection.stopListen(RoomEvents.JoinedRoom, this.onJoinedRoom);
    (_c = this._net) == null ? void 0 : _c.disable();
    this.close();
  }
  _ensureVideoPlayer() {
    const vp = new VideoPlayer();
    vp.aspectMode = AspectMode.AdjustWidth;
    GameObject.addComponent(this.gameObject, vp);
    this._videoPlayer = vp;
  }
  /** Call to begin screensharing */
  async share(opts) {
    if (this._activeShareRequest)
      return this._activeShareRequest;
    this._activeShareRequest = this.internalShare(opts);
    return this._activeShareRequest.then(() => {
      return this._activeShareRequest = null;
    });
  }
  async internalShare(opts) {
    if (this.context.connection.isInRoom === false) {
      console.warn("Can not start screensharing: requires network connection");
      if (isDevEnvironment())
        showBalloonWarning("Can not start screensharing: requires network connection. Add a SyncedRoom component or join a room first.");
      return;
    }
    if (opts == null ? void 0 : opts.device)
      this.device = opts.device;
    if (!this.videoPlayer && this.requiresVideoPlayer) {
      if (!this._videoPlayer) {
        this._videoPlayer = GameObject.getComponent(this.gameObject, VideoPlayer) ?? void 0;
      }
      if (!this.videoPlayer) {
        this._ensureVideoPlayer();
      }
      if (!this.videoPlayer) {
        console.warn("Can not share video without a videoPlayer assigned");
        return;
      }
    }
    this._requestOpen = true;
    try {
      const settings = (opts == null ? void 0 : opts.constraints) ?? {
        echoCancellation: true,
        autoGainControl: false
      };
      const displayMediaOptions = {
        video: settings,
        audio: settings
      };
      const videoOptions = displayMediaOptions.video;
      if (videoOptions !== void 0 && typeof videoOptions !== "boolean") {
        if (!videoOptions.width)
          videoOptions.width = { max: 1920 };
        if (!videoOptions.height)
          videoOptions.height = { max: 1920 };
        if (!videoOptions.aspectRatio)
          videoOptions.aspectRatio = { ideal: 1.7777777778 };
        if (!videoOptions.frameRate)
          videoOptions.frameRate = { ideal: 24 };
        if (!videoOptions.facingMode)
          videoOptions.facingMode = { ideal: "user" };
      }
      switch (this.device) {
        case "Camera":
          this.tryShareUserCamera(displayMediaOptions, opts);
          break;
        case "Screen":
          {
            if (!navigator.mediaDevices.getDisplayMedia) {
              console.error("No getDisplayMedia support");
              return;
            }
            const myVideo = await navigator.mediaDevices.getDisplayMedia(displayMediaOptions);
            if (this._requestOpen) {
              this.setStream(myVideo, ScreenCaptureMode.Sending);
            } else
              disposeStream(myVideo);
          }
          break;
        case "Canvas":
          const fps = 0;
          const stream = this.context.renderer.domElement.captureStream(fps);
          this.setStream(stream, ScreenCaptureMode.Sending);
          break;
        case "Microphone":
          {
            if (!navigator.mediaDevices.getUserMedia) {
              console.error("No getDisplayMedia support");
              return;
            }
            displayMediaOptions.video = false;
            const myStream = await navigator.mediaDevices.getUserMedia(displayMediaOptions);
            if (this._requestOpen) {
              this.setStream(myStream, ScreenCaptureMode.Sending);
            } else
              disposeStream(myStream);
          }
          break;
        default:
          console.error("Can not start screen sharing: Unknown device type", this.device);
      }
    } catch (err) {
      if (err.name === "NotAllowedError") {
        console.log("Selection cancelled");
        this._requestOpen = false;
        return;
      }
      console.error("Error opening video", err);
    }
  }
  close() {
    var _a2;
    this._requestOpen = false;
    if (this._currentStream) {
      if (debug103)
        console.warn("Close current stream / disposing resources, stream was active?", this._currentStream.active);
      (_a2 = this._net) == null ? void 0 : _a2.stopSendingStream(this._currentStream);
      disposeStream(this._currentStream);
      this._currentMode = ScreenCaptureMode.Idle;
      this._currentStream = null;
    }
  }
  setStream(stream, mode) {
    var _a2, _b, _c;
    if (stream === this._currentStream)
      return;
    this.close();
    if (!stream)
      return;
    this._currentStream = stream;
    this._requestOpen = true;
    this._currentMode = mode;
    const isVideoStream = this.device !== "Microphone";
    const isSending = mode === ScreenCaptureMode.Sending;
    if (isVideoStream) {
      if (!this._videoPlayer)
        this._ensureVideoPlayer();
      if (this._videoPlayer)
        this._videoPlayer.setVideo(stream);
      else
        console.error("No video player assigned for video stream");
    } else {
      if (!this._audioSource) {
        this._audioSource = new AudioSource();
        this._audioSource.spatialBlend = 0;
        this._audioSource.volume = 1;
        this.gameObject.addComponent(this._audioSource);
      }
      if (!isSending) {
        if (debug103)
          console.log("PLAY", stream.getAudioTracks());
        this._audioSource.volume = 1;
        (_a2 = this._audioSource) == null ? void 0 : _a2.play(stream);
      }
    }
    if (isSending) {
      (_b = this._net) == null ? void 0 : _b.startSendingStream(stream);
    }
    if (isSending) {
      if (this._videoPlayer)
        this._videoPlayer.muted = true;
      (_c = this._audioSource) == null ? void 0 : _c.stop();
    }
    for (const track of stream.getTracks()) {
      track.addEventListener("ended", () => {
        if (debug103)
          console.log("Track ended", track);
        this.close();
      });
      if (debug103) {
        if (track.kind === "video") {
          if (isSending)
            console.log("Video →", track.getSettings());
          else
            console.log("Video ←", track.getSettings());
        }
      }
    }
  }
  async tryShareUserCamera(constraints, options) {
    const devices = (await navigator.mediaDevices.enumerateDevices()).filter((d) => d.kind === "videoinput");
    if (debug103)
      console.log("Request camera. These are your kind:videoinput devices:\n", devices);
    let foundDevice = false;
    for (const dev of devices) {
      try {
        if (!this._requestOpen) {
          if (debug103)
            console.log("Camera selection cancelled");
          break;
        }
        if (dev.kind !== "videoinput") {
          if (debug103)
            console.log("Skipping non-video device", dev);
          continue;
        }
        const id = dev.deviceId;
        const hasOptionsFilter = (options == null ? void 0 : options.deviceId) != void 0 || (options == null ? void 0 : options.deviceFilter) != void 0;
        if (hasOptionsFilter) {
          if ((options == null ? void 0 : options.deviceId) !== void 0) {
            if (id !== options.deviceId) {
              if (debug103)
                console.log("Skipping device due to options.deviceId: " + dev.label + "; " + dev.deviceId);
              continue;
            }
          }
          if (options == null ? void 0 : options.deviceFilter) {
            const useDevice = options.deviceFilter(dev);
            if (useDevice === false) {
              if (debug103)
                console.log("Skipping device due to options.deviceFilter: " + dev.label + "; " + dev.deviceId);
              continue;
            }
          }
        } else if (this.deviceFilter) {
          const useDevice = this.deviceFilter(dev);
          if (useDevice === false) {
            if (debug103)
              console.log("Skipping device due to ScreenShare.deviceFilter: " + dev.label + "; " + dev.deviceId);
            continue;
          } else if (debug103)
            console.log("Selected device by filter", dev);
        } else if (this.deviceName) {
          const lowercaseLabel = dev.label.toLowerCase();
          const lowercaseName = this.deviceName.toLowerCase();
          const labelMatches = lowercaseLabel.includes(lowercaseName);
          const idMatches = dev.deviceId === this.deviceName;
          if (!labelMatches && !idMatches) {
            if (debug103)
              console.log("Skipping device due to ScreenShare.deviceName: " + dev.label + "; " + dev.deviceId);
            continue;
          } else if (debug103)
            console.log("Selected device by name", dev);
        }
        if (constraints.video !== false) {
          if (typeof constraints.video === "undefined" || typeof constraints.video === "boolean") {
            constraints.video = {};
          }
          constraints.video.deviceId = id;
        }
        foundDevice = true;
        const userMedia = await navigator.mediaDevices.getUserMedia(constraints).catch((err) => {
          console.error("Failed to get user media", err);
          return null;
        });
        if (userMedia === null) {
          continue;
        } else if (this._requestOpen) {
          this.setStream(userMedia, ScreenCaptureMode.Sending);
          if (debug103)
            console.log("Selected camera", dev);
        } else {
          disposeStream(userMedia);
          if (debug103)
            console.log("Camera selection cancelled");
        }
        break;
      } catch (err) {
        if (err.message === "Failed to allocate videosource" || err.message === "Could not start video source") {
          showBalloonWarning("Failed to start video: Try another camera (Code " + err.code + ")");
          console.warn(err);
          continue;
        } else {
          console.error("Failed to get user media", err.message, err.code, err);
        }
      }
    }
    if (!foundDevice && isDevEnvironment()) {
      showBalloonWarning("No camera found for sharing. Please connect a camera (see console for more information)");
      console.warn("No camera found for sharing. Please connect a camera", devices, this.deviceName, "Using deviceFilter? " + this.deviceFilter != void 0, "Using options? " + options != void 0, "Using deviceName? " + this.deviceName != void 0, "Using options.deviceId? " + (options == null ? void 0 : options.deviceId) != void 0, "Using options.deviceFilter? " + (options == null ? void 0 : options.deviceFilter) != void 0);
    }
  }
};
__decorate77([
  serializable()
], ScreenCapture.prototype, "allowStartOnClick", void 0);
__decorate77([
  serializable()
], ScreenCapture.prototype, "autoConnect", void 0);
__decorate77([
  serializable(VideoPlayer)
], ScreenCapture.prototype, "videoPlayer", null);
__decorate77([
  serializable()
], ScreenCapture.prototype, "device", void 0);
__decorate77([
  serializable()
], ScreenCapture.prototype, "deviceName", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/postprocessing/Effects/ScreenspaceAmbientOcclusion.js
var __decorate78 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var ScreenSpaceAmbientOcclusion = class extends PostProcessingEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "intensity", new VolumeParameter(2));
    __publicField(this, "falloff", new VolumeParameter(1));
    __publicField(this, "samples", new VolumeParameter(9));
    __publicField(this, "color", new VolumeParameter(new Color(0, 0, 0)));
    __publicField(this, "luminanceInfluence", new VolumeParameter(0.7));
    __publicField(this, "_ssao");
  }
  get typeName() {
    return "ScreenSpaceAmbientOcclusion";
  }
  onBeforeRender() {
    if (this._ssao && this.context.mainCamera instanceof PerspectiveCamera) {
      const fadeDistance = this.context.mainCamera.far - this.context.mainCamera.near;
      this._ssao.ssaoMaterial.worldDistanceFalloff = fadeDistance * 0.01;
      this._ssao.ssaoMaterial.worldDistanceThreshold = this.context.mainCamera.far;
    }
  }
  onCreateEffect() {
    const cam = this.context.mainCamera;
    const normalPass = new NormalPass(this.context.scene, cam);
    const depthDownsamplingPass = new DepthDownsamplingPass({
      normalBuffer: normalPass.texture,
      resolutionScale: 0.5
    });
    const ssao = this._ssao = new SSAOEffect(cam, normalPass.texture, {
      normalDepthBuffer: depthDownsamplingPass.texture,
      worldDistanceThreshold: 1,
      worldDistanceFalloff: 1,
      worldProximityThreshold: 0.1,
      worldProximityFalloff: 2,
      intensity: 1,
      blendFunction: BlendFunction.MULTIPLY,
      luminanceInfluence: 0.5
    });
    this.intensity.onValueChanged = (newValue) => {
      ssao.intensity = newValue;
    };
    this.falloff.onValueChanged = (newValue) => {
      ssao.ssaoMaterial.radius = newValue * 0.1;
    };
    this.samples.onValueChanged = (newValue) => {
      ssao.ssaoMaterial.samples = newValue;
    };
    this.color.onValueChanged = (newValue) => {
      if (!ssao.color)
        ssao.color = new Color();
      ssao.color.copy(newValue);
    };
    this.luminanceInfluence.onValueChanged = (newValue) => {
      ssao.luminanceInfluence = newValue;
    };
    const arr = new Array();
    arr.push(normalPass);
    arr.push(depthDownsamplingPass);
    arr.push(ssao);
    return arr;
  }
};
__decorate78([
  serializable(VolumeParameter)
], ScreenSpaceAmbientOcclusion.prototype, "intensity", void 0);
__decorate78([
  serializable(VolumeParameter)
], ScreenSpaceAmbientOcclusion.prototype, "falloff", void 0);
__decorate78([
  serializable(VolumeParameter)
], ScreenSpaceAmbientOcclusion.prototype, "samples", void 0);
__decorate78([
  serializable(VolumeParameter)
], ScreenSpaceAmbientOcclusion.prototype, "color", void 0);
__decorate78([
  serializable(VolumeParameter)
], ScreenSpaceAmbientOcclusion.prototype, "luminanceInfluence", void 0);
registerCustomEffectType("ScreenSpaceAmbientOcclusion", ScreenSpaceAmbientOcclusion);

// node_modules/@needle-tools/engine/lib/engine-components/postprocessing/Effects/ScreenspaceAmbientOcclusionN8.js
var __decorate79 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var ScreenSpaceAmbientOcclusionN8QualityMode;
(function(ScreenSpaceAmbientOcclusionN8QualityMode2) {
  ScreenSpaceAmbientOcclusionN8QualityMode2[ScreenSpaceAmbientOcclusionN8QualityMode2["Performance"] = 0] = "Performance";
  ScreenSpaceAmbientOcclusionN8QualityMode2[ScreenSpaceAmbientOcclusionN8QualityMode2["Low"] = 1] = "Low";
  ScreenSpaceAmbientOcclusionN8QualityMode2[ScreenSpaceAmbientOcclusionN8QualityMode2["Medium"] = 2] = "Medium";
  ScreenSpaceAmbientOcclusionN8QualityMode2[ScreenSpaceAmbientOcclusionN8QualityMode2["High"] = 3] = "High";
  ScreenSpaceAmbientOcclusionN8QualityMode2[ScreenSpaceAmbientOcclusionN8QualityMode2["Ultra"] = 4] = "Ultra";
})(ScreenSpaceAmbientOcclusionN8QualityMode || (ScreenSpaceAmbientOcclusionN8QualityMode = {}));
var ScreenSpaceAmbientOcclusionN8 = class extends PostProcessingEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "gammaCorrection", true);
    /** The most important parameter for your ambient occlusion effect.
     * Controls the radius/size of the ambient occlusion in world units.
     * Should be set to how far you want the occlusion to extend from a given object.
     * Set it too low, and AO becomes an edge detector.
     * Too high, and the AO becomes "soft" and might not highlight the details you want.
     * The radius should be one or two magnitudes less than scene scale:
     * if your scene is 10 units across, the radius should be between 0.1 and 1. If its 100, 1 to 10.
     * @default 1
     */
    __publicField(this, "aoRadius", new VolumeParameter(1));
    /** The second most important parameter for your ambient occlusion effect.
     * Controls how fast the ambient occlusion fades away with distance in proportion to its radius.
     * Defaults to 1, and behind-the-scenes, is a calculated as a ratio of your radius (0.2 * distanceFalloff is the size used for attenuation).
     * Decreasing it reduces "haloing" artifacts and improves the accuracy of your occlusion,
     * but making it too small makes the ambient occlusion disappear entirely.
     * @default 1
     */
    __publicField(this, "falloff", new VolumeParameter(1));
    /** A purely artistic control for the intensity of the AO - runs the ao through the function pow(ao, intensity),
     * which has the effect of darkening areas with more ambient occlusion.
     * Useful to make the effect more pronounced.
     * An intensity of 2 generally produces soft ambient occlusion that isn't too noticeable,
     * whereas one of 5 produces heavily prominent ambient occlusion.
     * @default 1
     */
    __publicField(this, "intensity", new VolumeParameter(1));
    /** The color of the ambient occlusion. By default, it is black, but it can be changed to any color
     * to offer a crude approximation of global illumination.
     * Recommended in scenes where bounced light has a uniform "color",
     * for instance a scene that is predominantly lit by a blue sky.
     * The color is expected to be in the sRGB color space, and is automatically converted to linear space for you.
     * Keep the color pretty dark for sensible results.
     * @default new Color(0, 0, 0)
     */
    __publicField(this, "color", new VolumeParameter(new Color(0, 0, 0)));
    /** If you want the AO to calculate the radius based on screen space, you can do so by setting configuration.screenSpaceRadius to true.
     * This is useful for scenes where the camera is moving across different scales a lot,
     * or for scenes where the camera is very close to the objects.
     * @default false
     */
    __publicField(this, "screenspaceRadius", false);
    /**
     * The quality of the ambient occlusion effect.
     * @default ScreenSpaceAmbientOcclusionN8QualityMode.Medium
     */
    __publicField(this, "quality", ScreenSpaceAmbientOcclusionN8QualityMode.Medium);
    __publicField(this, "_ssao");
  }
  get typeName() {
    return "ScreenSpaceAmbientOcclusionN8";
  }
  onValidate() {
    if (this._ssao) {
      this._ssao.setQualityMode(ScreenSpaceAmbientOcclusionN8QualityMode[this.quality]);
      this._ssao.configuration.gammaCorrection = this.gammaCorrection;
      this._ssao.configuration.screenSpaceRadius = this.screenspaceRadius;
    }
  }
  onCreateEffect() {
    const cam = this.context.mainCamera;
    const ssao = this._ssao = new $87431ee93b037844$export$2489f9981ab0fa82(this.context.scene, cam, this.context.domWidth, this.context.domHeight);
    const mode = ScreenSpaceAmbientOcclusionN8QualityMode[this.quality];
    ssao.setQualityMode(mode);
    ssao.configuration.gammaCorrection = this.gammaCorrection;
    ssao.configuration.screenSpaceRadius = this.screenspaceRadius;
    this.intensity.onValueChanged = (newValue) => {
      ssao.configuration.intensity = newValue;
    };
    this.falloff.onValueChanged = (newValue) => {
      ssao.configuration.distanceFalloff = newValue;
    };
    this.aoRadius.onValueChanged = (newValue) => {
      ssao.configuration.aoRadius = newValue;
    };
    this.color.onValueChanged = (newValue) => {
      if (!ssao.color)
        ssao.color = new Color();
      ssao.configuration.color.copy(newValue);
    };
    const arr = new Array();
    arr.push(ssao);
    return arr;
  }
};
__decorate79([
  validate2(),
  serializable()
], ScreenSpaceAmbientOcclusionN8.prototype, "gammaCorrection", void 0);
__decorate79([
  serializable(VolumeParameter)
], ScreenSpaceAmbientOcclusionN8.prototype, "aoRadius", void 0);
__decorate79([
  serializable(VolumeParameter)
], ScreenSpaceAmbientOcclusionN8.prototype, "falloff", void 0);
__decorate79([
  serializable(VolumeParameter)
], ScreenSpaceAmbientOcclusionN8.prototype, "intensity", void 0);
__decorate79([
  serializable(VolumeParameter)
], ScreenSpaceAmbientOcclusionN8.prototype, "color", void 0);
__decorate79([
  validate2(),
  serializable()
], ScreenSpaceAmbientOcclusionN8.prototype, "screenspaceRadius", void 0);
__decorate79([
  validate2(),
  serializable()
], ScreenSpaceAmbientOcclusionN8.prototype, "quality", void 0);
registerCustomEffectType("ScreenSpaceAmbientOcclusionN8", ScreenSpaceAmbientOcclusionN8);

// node_modules/@needle-tools/engine/lib/engine-components/ShadowCatcher.js
var __decorate80 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var ShadowMode;
(function(ShadowMode2) {
  ShadowMode2[ShadowMode2["ShadowMask"] = 0] = "ShadowMask";
  ShadowMode2[ShadowMode2["Additive"] = 1] = "Additive";
  ShadowMode2[ShadowMode2["Occluder"] = 2] = "Occluder";
})(ShadowMode || (ShadowMode = {}));
var ShadowCatcher = class extends Component2 {
  constructor() {
    super(...arguments);
    //@type Needle.Engine.ShadowCatcher.Mode
    __publicField(this, "mode", ShadowMode.ShadowMask);
    //@type UnityEngine.Color
    __publicField(this, "shadowColor", new RGBAColor(0, 0, 0, 1));
    __publicField(this, "targetMesh");
  }
  /** @internal */
  start() {
    if (!(this.gameObject instanceof Mesh)) {
      const quad = ObjectUtils.createPrimitive(PrimitiveType.Quad, {
        name: "ShadowCatcher",
        material: new MeshStandardMaterial({
          // HACK heuristic to get approx. the same colors out as with the current default ShadowCatcher material
          // not clear why this is needed; assumption is that the Renderer component does something we're not respecting here
          color: 10066329,
          roughness: 1,
          metalness: 0,
          transparent: true
        })
      });
      quad.receiveShadow = true;
      quad.geometry.rotateX(-Math.PI / 2);
      this.gameObject.add(quad);
      this.targetMesh = quad;
    } else if (this.gameObject instanceof Mesh && this.gameObject.material) {
      this.gameObject.material = this.gameObject.material.clone();
      this.targetMesh = this.gameObject;
      this.targetMesh.receiveShadow = true;
    }
    if (!this.targetMesh) {
      console.warn("ShadowCatcher: no mesh to apply shadow catching to. Groups are currently not supported.");
      return;
    }
    this.targetMesh.layers.set(2);
    switch (this.mode) {
      case ShadowMode.ShadowMask:
        this.applyShadowMaterial();
        break;
      case ShadowMode.Additive:
        this.applyLightBlendMaterial();
        break;
      case ShadowMode.Occluder:
        this.applyOccluderMaterial();
        break;
    }
  }
  // Custom blending, diffuse-only lighting blended onto the scene additively.
  // Works great for Point Lights and spot lights, 
  // doesn't work for directional lights (since they're lighting up everything else).
  // Works even better with an additional black-ish gradient to darken parts of the AR scene
  // so that lights become more visible on bright surfaces.
  applyLightBlendMaterial() {
    if (!this.targetMesh)
      return;
    const material = this.targetMesh.material;
    material.blending = AdditiveBlending;
    this.applyMaterialOptions(material);
    material.onBeforeCompile = (shader) => {
      shader.fragmentShader = shader.fragmentShader.replace("vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;", `vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
            // diffuse-only lighting with overdrive to somewhat compensate
            // for the loss of indirect lighting and to make it more visible.
            vec3 direct = (reflectedLight.directDiffuse + reflectedLight.directSpecular) * 6.6;
            float max = max(direct.r, max(direct.g, direct.b));
            
            // early out - we're simply returning direct lighting and some alpha based on it so it can 
            // be blended onto the scene.
            gl_FragColor = vec4(direct, max);
            return;
            `);
    };
    material.userData.isLightBlendMaterial = true;
  }
  // ShadowMaterial: only does a mask; shadowed areas are fully black.
  // doesn't take light attenuation into account.
  // works great for Directional Lights.
  applyShadowMaterial() {
    if (this.targetMesh) {
      if (this.targetMesh.material.type !== "ShadowMaterial") {
        const material = new ShadowMaterial();
        material.color = this.shadowColor;
        material.opacity = this.shadowColor.alpha;
        this.applyMaterialOptions(material);
        this.targetMesh.material = material;
        material.userData.isShadowCatcherMaterial = true;
      } else {
        const material = this.targetMesh.material;
        material.color = this.shadowColor;
        material.opacity = this.shadowColor.alpha;
        this.applyMaterialOptions(material);
        material.userData.isShadowCatcherMaterial = true;
      }
    }
  }
  applyOccluderMaterial() {
    if (this.targetMesh) {
      let material = this.targetMesh.material;
      if (!material) {
        const mat = new MeshBasicMaterial();
        this.targetMesh.material = mat;
        material = mat;
      }
      material.depthWrite = true;
      material.stencilWrite = true;
      material.colorWrite = false;
      this.gameObject.renderOrder = -100;
    }
  }
  applyMaterialOptions(material) {
    if (material) {
      material.depthWrite = false;
      material.stencilWrite = false;
    }
  }
};
__decorate80([
  serializable()
], ShadowCatcher.prototype, "mode", void 0);
__decorate80([
  serializable(RGBAColor)
], ShadowCatcher.prototype, "shadowColor", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/SmoothFollow.js
var __decorate81 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var _SmoothFollow = class extends Component2 {
  constructor() {
    super(...arguments);
    /**
     * The target to follow. If null, the GameObject will not move.
     */
    __publicField(this, "target", null);
    /**
     * The factor to smoothly follow the target's position.
     * The value is clamped between 0 and 1. If 0, the GameObject will not follow the target's position.
     */
    __publicField(this, "followFactor", 0.1);
    /**
     * The factor to smoothly follow the target's rotation.
     * The value is clamped between 0 and 1. If 0, the GameObject will not follow the target's rotation.
     */
    __publicField(this, "rotateFactor", 0.1);
    __publicField(this, "positionAxes", Axes.All);
    __publicField(this, "flipForward", false);
    __publicField(this, "_firstUpdate", true);
  }
  /**
   * Update the position and rotation of the GameObject to follow the target.
   */
  onBeforeRender() {
    this.updateNow(false);
  }
  updateNow(hard) {
    if (!this.target || this.target === this.gameObject)
      return;
    if (this.followFactor > 0) {
      const wp = getWorldPosition(this.target);
      const fpos = this._firstUpdate || hard ? 1 : Mathf.clamp01(this.context.time.deltaTime * this.followFactor);
      const currentPosition = this.worldPosition;
      if (this.positionAxes & Axes.X)
        currentPosition.x = Mathf.lerp(currentPosition.x, wp.x, fpos);
      if (this.positionAxes & Axes.Y)
        currentPosition.y = Mathf.lerp(currentPosition.y, wp.y, fpos);
      if (this.positionAxes & Axes.Z)
        currentPosition.z = Mathf.lerp(currentPosition.z, wp.z, fpos);
      this.worldPosition = currentPosition;
    }
    if (this.rotateFactor > 0) {
      const wr = getWorldQuaternion(this.target);
      if (this.flipForward) {
        wr.premultiply(_SmoothFollow._invertForward);
      }
      const frot = this._firstUpdate || hard ? 1 : Mathf.clamp01(this.context.time.deltaTime * this.rotateFactor);
      this.worldQuaternion = this.worldQuaternion.slerp(wr, frot);
    }
    this._firstUpdate = false;
  }
};
var SmoothFollow = _SmoothFollow;
__publicField(SmoothFollow, "_invertForward", new Quaternion().setFromAxisAngle(new Vector32(0, 1, 0), Math.PI));
__decorate81([
  serializable(Object3D)
], SmoothFollow.prototype, "target", void 0);
__decorate81([
  serializable()
], SmoothFollow.prototype, "followFactor", void 0);
__decorate81([
  serializable()
], SmoothFollow.prototype, "rotateFactor", void 0);
__decorate81([
  serializable()
], SmoothFollow.prototype, "positionAxes", void 0);

// node_modules/three/examples/jsm/interactive/HTMLMesh.js
var HTMLMesh = class extends Mesh {
  constructor(dom) {
    const texture = new HTMLTexture(dom);
    const geometry = new PlaneGeometry(texture.image.width * 1e-3, texture.image.height * 1e-3);
    const material = new MeshBasicMaterial({ map: texture, toneMapped: false, transparent: true });
    super(geometry, material);
    function onEvent(event) {
      material.map.dispatchDOMEvent(event);
    }
    this.addEventListener("mousedown", onEvent);
    this.addEventListener("mousemove", onEvent);
    this.addEventListener("mouseup", onEvent);
    this.addEventListener("click", onEvent);
    this.dispose = function() {
      geometry.dispose();
      material.dispose();
      material.map.dispose();
      canvases.delete(dom);
      this.removeEventListener("mousedown", onEvent);
      this.removeEventListener("mousemove", onEvent);
      this.removeEventListener("mouseup", onEvent);
      this.removeEventListener("click", onEvent);
    };
  }
};
var HTMLTexture = class extends CanvasTexture {
  constructor(dom) {
    super(html2canvas(dom));
    this.dom = dom;
    this.anisotropy = 16;
    this.colorSpace = SRGBColorSpace;
    this.minFilter = LinearFilter;
    this.magFilter = LinearFilter;
    const observer = new MutationObserver(() => {
      if (!this.scheduleUpdate) {
        this.scheduleUpdate = setTimeout(() => this.update(), 16);
      }
    });
    const config = { attributes: true, childList: true, subtree: true, characterData: true };
    observer.observe(dom, config);
    this.observer = observer;
  }
  dispatchDOMEvent(event) {
    if (event.data) {
      htmlevent(this.dom, event.type, event.data.x, event.data.y);
    }
  }
  update() {
    this.image = html2canvas(this.dom);
    this.needsUpdate = true;
    this.scheduleUpdate = null;
  }
  dispose() {
    if (this.observer) {
      this.observer.disconnect();
    }
    this.scheduleUpdate = clearTimeout(this.scheduleUpdate);
    super.dispose();
  }
};
var canvases = /* @__PURE__ */ new WeakMap();
function html2canvas(element) {
  const range = document.createRange();
  const color2 = new Color();
  function Clipper(context2) {
    const clips = [];
    let isClipping = false;
    function doClip() {
      if (isClipping) {
        isClipping = false;
        context2.restore();
      }
      if (clips.length === 0)
        return;
      let minX = -Infinity, minY = -Infinity;
      let maxX = Infinity, maxY = Infinity;
      for (let i = 0; i < clips.length; i++) {
        const clip = clips[i];
        minX = Math.max(minX, clip.x);
        minY = Math.max(minY, clip.y);
        maxX = Math.min(maxX, clip.x + clip.width);
        maxY = Math.min(maxY, clip.y + clip.height);
      }
      context2.save();
      context2.beginPath();
      context2.rect(minX, minY, maxX - minX, maxY - minY);
      context2.clip();
      isClipping = true;
    }
    return {
      add: function(clip) {
        clips.push(clip);
        doClip();
      },
      remove: function() {
        clips.pop();
        doClip();
      }
    };
  }
  function drawText(style, x2, y, string) {
    if (string !== "") {
      if (style.textTransform === "uppercase") {
        string = string.toUpperCase();
      }
      context.font = style.fontWeight + " " + style.fontSize + " " + style.fontFamily;
      context.textBaseline = "top";
      context.fillStyle = style.color;
      context.fillText(string, x2, y + parseFloat(style.fontSize) * 0.1);
    }
  }
  function buildRectPath(x2, y, w, h, r) {
    if (w < 2 * r)
      r = w / 2;
    if (h < 2 * r)
      r = h / 2;
    context.beginPath();
    context.moveTo(x2 + r, y);
    context.arcTo(x2 + w, y, x2 + w, y + h, r);
    context.arcTo(x2 + w, y + h, x2, y + h, r);
    context.arcTo(x2, y + h, x2, y, r);
    context.arcTo(x2, y, x2 + w, y, r);
    context.closePath();
  }
  function drawBorder(style, which, x2, y, width, height) {
    const borderWidth = style[which + "Width"];
    const borderStyle = style[which + "Style"];
    const borderColor = style[which + "Color"];
    if (borderWidth !== "0px" && borderStyle !== "none" && borderColor !== "transparent" && borderColor !== "rgba(0, 0, 0, 0)") {
      context.strokeStyle = borderColor;
      context.lineWidth = parseFloat(borderWidth);
      context.beginPath();
      context.moveTo(x2, y);
      context.lineTo(x2 + width, y + height);
      context.stroke();
    }
  }
  function drawElement(element2, style) {
    if (element2.nodeType === Node.COMMENT_NODE || element2.nodeName === "SCRIPT" || element2.style && element2.style.display === "none") {
      return;
    }
    let x2 = 0, y = 0, width = 0, height = 0;
    if (element2.nodeType === Node.TEXT_NODE) {
      range.selectNode(element2);
      const rect = range.getBoundingClientRect();
      x2 = rect.left - offset.left - 0.5;
      y = rect.top - offset.top - 0.5;
      width = rect.width;
      height = rect.height;
      drawText(style, x2, y, element2.nodeValue.trim());
    } else if (element2 instanceof HTMLCanvasElement) {
      const rect = element2.getBoundingClientRect();
      x2 = rect.left - offset.left - 0.5;
      y = rect.top - offset.top - 0.5;
      context.save();
      const dpr = window.devicePixelRatio;
      context.scale(1 / dpr, 1 / dpr);
      context.drawImage(element2, x2, y);
      context.restore();
    } else if (element2 instanceof HTMLImageElement) {
      const rect = element2.getBoundingClientRect();
      x2 = rect.left - offset.left - 0.5;
      y = rect.top - offset.top - 0.5;
      width = rect.width;
      height = rect.height;
      context.drawImage(element2, x2, y, width, height);
    } else {
      const rect = element2.getBoundingClientRect();
      x2 = rect.left - offset.left - 0.5;
      y = rect.top - offset.top - 0.5;
      width = rect.width;
      height = rect.height;
      style = window.getComputedStyle(element2);
      buildRectPath(x2, y, width, height, parseFloat(style.borderRadius));
      const backgroundColor = style.backgroundColor;
      if (backgroundColor !== "transparent" && backgroundColor !== "rgba(0, 0, 0, 0)") {
        context.fillStyle = backgroundColor;
        context.fill();
      }
      const borders = ["borderTop", "borderLeft", "borderBottom", "borderRight"];
      let match = true;
      let prevBorder = null;
      for (const border of borders) {
        if (prevBorder !== null) {
          match = style[border + "Width"] === style[prevBorder + "Width"] && style[border + "Color"] === style[prevBorder + "Color"] && style[border + "Style"] === style[prevBorder + "Style"];
        }
        if (match === false)
          break;
        prevBorder = border;
      }
      if (match === true) {
        const width2 = parseFloat(style.borderTopWidth);
        if (style.borderTopWidth !== "0px" && style.borderTopStyle !== "none" && style.borderTopColor !== "transparent" && style.borderTopColor !== "rgba(0, 0, 0, 0)") {
          context.strokeStyle = style.borderTopColor;
          context.lineWidth = width2;
          context.stroke();
        }
      } else {
        drawBorder(style, "borderTop", x2, y, width, 0);
        drawBorder(style, "borderLeft", x2, y, 0, height);
        drawBorder(style, "borderBottom", x2, y + height, width, 0);
        drawBorder(style, "borderRight", x2 + width, y, 0, height);
      }
      if (element2 instanceof HTMLInputElement) {
        let accentColor = style.accentColor;
        if (accentColor === void 0 || accentColor === "auto")
          accentColor = style.color;
        color2.set(accentColor);
        const luminance = Math.sqrt(0.299 * color2.r ** 2 + 0.587 * color2.g ** 2 + 0.114 * color2.b ** 2);
        const accentTextColor = luminance < 0.5 ? "white" : "#111111";
        if (element2.type === "radio") {
          buildRectPath(x2, y, width, height, height);
          context.fillStyle = "white";
          context.strokeStyle = accentColor;
          context.lineWidth = 1;
          context.fill();
          context.stroke();
          if (element2.checked) {
            buildRectPath(x2 + 2, y + 2, width - 4, height - 4, height);
            context.fillStyle = accentColor;
            context.strokeStyle = accentTextColor;
            context.lineWidth = 2;
            context.fill();
            context.stroke();
          }
        }
        if (element2.type === "checkbox") {
          buildRectPath(x2, y, width, height, 2);
          context.fillStyle = element2.checked ? accentColor : "white";
          context.strokeStyle = element2.checked ? accentTextColor : accentColor;
          context.lineWidth = 1;
          context.stroke();
          context.fill();
          if (element2.checked) {
            const currentTextAlign = context.textAlign;
            context.textAlign = "center";
            const properties = {
              color: accentTextColor,
              fontFamily: style.fontFamily,
              fontSize: height + "px",
              fontWeight: "bold"
            };
            drawText(properties, x2 + width / 2, y, "✔");
            context.textAlign = currentTextAlign;
          }
        }
        if (element2.type === "range") {
          const [min, max, value] = ["min", "max", "value"].map((property) => parseFloat(element2[property]));
          const position = (value - min) / (max - min) * (width - height);
          buildRectPath(x2, y + height / 4, width, height / 2, height / 4);
          context.fillStyle = accentTextColor;
          context.strokeStyle = accentColor;
          context.lineWidth = 1;
          context.fill();
          context.stroke();
          buildRectPath(x2, y + height / 4, position + height / 2, height / 2, height / 4);
          context.fillStyle = accentColor;
          context.fill();
          buildRectPath(x2 + position, y, height, height, height / 2);
          context.fillStyle = accentColor;
          context.fill();
        }
        if (element2.type === "color" || element2.type === "text" || element2.type === "number") {
          clipper.add({ x: x2, y, width, height });
          drawText(style, x2 + parseInt(style.paddingLeft), y + parseInt(style.paddingTop), element2.value);
          clipper.remove();
        }
      }
    }
    const isClipping = style.overflow === "auto" || style.overflow === "hidden";
    if (isClipping)
      clipper.add({ x: x2, y, width, height });
    for (let i = 0; i < element2.childNodes.length; i++) {
      drawElement(element2.childNodes[i], style);
    }
    if (isClipping)
      clipper.remove();
  }
  const offset = element.getBoundingClientRect();
  let canvas = canvases.get(element);
  if (canvas === void 0) {
    canvas = document.createElement("canvas");
    canvas.width = offset.width;
    canvas.height = offset.height;
    canvases.set(element, canvas);
  }
  const context = canvas.getContext(
    "2d"
    /*, { alpha: false }*/
  );
  const clipper = new Clipper(context);
  context.clearRect(0, 0, canvas.width, canvas.height);
  drawElement(element);
  return canvas;
}
function htmlevent(element, event, x2, y) {
  const mouseEventInit = {
    clientX: x2 * element.offsetWidth + element.offsetLeft,
    clientY: y * element.offsetHeight + element.offsetTop,
    view: element.ownerDocument.defaultView
  };
  window.dispatchEvent(new MouseEvent(event, mouseEventInit));
  const rect = element.getBoundingClientRect();
  x2 = x2 * rect.width + rect.left;
  y = y * rect.height + rect.top;
  function traverse2(element2) {
    if (element2.nodeType !== Node.TEXT_NODE && element2.nodeType !== Node.COMMENT_NODE) {
      const rect2 = element2.getBoundingClientRect();
      if (x2 > rect2.left && x2 < rect2.right && y > rect2.top && y < rect2.bottom) {
        element2.dispatchEvent(new MouseEvent(event, mouseEventInit));
        if (element2 instanceof HTMLInputElement && element2.type === "range" && (event === "mousedown" || event === "click")) {
          const [min, max] = ["min", "max"].map((property) => parseFloat(element2[property]));
          const width = rect2.width;
          const offsetX = x2 - rect2.x;
          const proportion = offsetX / width;
          element2.value = min + (max - min) * proportion;
          element2.dispatchEvent(new InputEvent("input", { bubbles: true }));
        }
      }
      for (let i = 0; i < element2.childNodes.length; i++) {
        traverse2(element2.childNodes[i]);
      }
    }
  }
  traverse2(element);
}

// node_modules/three/examples/jsm/interactive/InteractiveGroup.js
var _pointer = new Vector2();
var _event = { type: "", data: _pointer };
var _raycaster2 = new Raycaster();
var InteractiveGroup = class extends Group {
  listenToPointerEvents(renderer, camera) {
    const scope = this;
    const raycaster = new Raycaster();
    const element = renderer.domElement;
    function onPointerEvent(event) {
      event.stopPropagation();
      const rect = renderer.domElement.getBoundingClientRect();
      _pointer.x = (event.clientX - rect.left) / rect.width * 2 - 1;
      _pointer.y = -(event.clientY - rect.top) / rect.height * 2 + 1;
      raycaster.setFromCamera(_pointer, camera);
      const intersects = raycaster.intersectObjects(scope.children, false);
      if (intersects.length > 0) {
        const intersection = intersects[0];
        const object = intersection.object;
        const uv = intersection.uv;
        _event.type = event.type;
        _event.data.set(uv.x, 1 - uv.y);
        object.dispatchEvent(_event);
      }
    }
    element.addEventListener("pointerdown", onPointerEvent);
    element.addEventListener("pointerup", onPointerEvent);
    element.addEventListener("pointermove", onPointerEvent);
    element.addEventListener("mousedown", onPointerEvent);
    element.addEventListener("mouseup", onPointerEvent);
    element.addEventListener("mousemove", onPointerEvent);
    element.addEventListener("click", onPointerEvent);
  }
  listenToXRControllerEvents(controller) {
    const scope = this;
    const events = {
      "move": "mousemove",
      "select": "click",
      "selectstart": "mousedown",
      "selectend": "mouseup"
    };
    function onXRControllerEvent(event) {
      const controller2 = event.target;
      _raycaster2.setFromXRController(controller2);
      const intersections = _raycaster2.intersectObjects(scope.children, false);
      if (intersections.length > 0) {
        const intersection = intersections[0];
        const object = intersection.object;
        const uv = intersection.uv;
        _event.type = events[event.type];
        _event.data.set(uv.x, 1 - uv.y);
        object.dispatchEvent(_event);
      }
    }
    controller.addEventListener("move", onXRControllerEvent);
    controller.addEventListener("select", onXRControllerEvent);
    controller.addEventListener("selectstart", onXRControllerEvent);
    controller.addEventListener("selectend", onXRControllerEvent);
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/ui/SpatialHtml.js
var __decorate82 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var SpatialHtml = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "id", null);
    __publicField(this, "keepAspect", false);
    __publicField(this, "_object", null);
  }
  onEnable() {
    if (this._object) {
      this.gameObject.add(this._object);
      return;
    }
    if (!this.id || !this.context.mainCamera)
      return;
    const div = document.getElementById(this.id);
    if (!div) {
      console.warn('Could not find element with id "' + this.id + '"');
      return;
    }
    div.style.display = "block";
    div.style.visibility = "hidden";
    const group = new InteractiveGroup();
    group.listenToPointerEvents(this.context.renderer, this.context.mainCamera);
    this.gameObject.add(group);
    const mesh = new HTMLMesh(div);
    group.add(mesh);
    mesh.visible = false;
    const mat = mesh.material;
    mat.transparent = true;
    setTimeout(() => {
      mesh.visible = true;
      const rot = getWorldRotation(this.gameObject).clone();
      setWorldRotationXYZ(this.gameObject, 0, 0, 0);
      this.gameObject.updateMatrixWorld();
      const aabb = new Box3();
      aabb.setFromObject(group);
      this.setWorldRotation(rot.x, rot.y, rot.z);
      const width = aabb.max.x - aabb.min.x;
      const height = aabb.max.y - aabb.min.y;
      if (this.keepAspect) {
        const aspect = width / height;
        if (width > height) {
          mesh.scale.set(1 / width, 1 / height / aspect, 1);
        } else {
          mesh.scale.set(1 / width * aspect, 1 / height, 1);
        }
      } else {
        mesh.scale.set(1 / width, 1 / height, 1);
      }
      const factor = this.gameObject.scale;
      mesh.scale.multiply(factor);
    }, 1);
  }
  onDisable() {
    var _a2;
    (_a2 = this._object) == null ? void 0 : _a2.removeFromParent();
  }
};
__decorate82([
  serializable()
], SpatialHtml.prototype, "id", void 0);
__decorate82([
  serializable()
], SpatialHtml.prototype, "keepAspect", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/SpatialTrigger.js
var __decorate83 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug104 = getParam("debugspatialtrigger");
var layer1 = new Layers();
var layer2 = new Layers();
function testMask(mask1, mask2) {
  layer1.mask = mask1;
  layer2.mask = mask2;
  return layer1.test(layer2);
}
var SpatialTriggerReceiver = class extends Component2 {
  constructor() {
    super(...arguments);
    // currently Layers in unity but maybe this should be a string or plane number? Or should it be a bitmask to allow receivers use multiple triggers?
    __publicField(this, "triggerMask", 0);
    __publicField(this, "onEnter");
    __publicField(this, "onStay");
    __publicField(this, "onExit");
    __publicField(this, "currentIntersected", []);
    __publicField(this, "lastIntersected", []);
  }
  start() {
    if (debug104)
      console.log(this.name, this.triggerMask, this);
  }
  update() {
    this.currentIntersected.length = 0;
    for (const trigger of SpatialTrigger.triggers) {
      if (testMask(trigger.triggerMask, this.triggerMask)) {
        if (trigger.test(this.gameObject)) {
          this.currentIntersected.push(trigger);
        }
      }
    }
    for (let i = this.lastIntersected.length - 1; i >= 0; i--) {
      const last = this.lastIntersected[i];
      if (this.currentIntersected.indexOf(last) < 0) {
        this.onExitTrigger(last);
        this.lastIntersected.splice(i, 1);
      }
    }
    for (const cur of this.currentIntersected) {
      if (this.lastIntersected.indexOf(cur) < 0)
        this.onEnterTrigger(cur);
      this.onStayTrigger(cur);
    }
    this.lastIntersected.length = 0;
    this.lastIntersected.push(...this.currentIntersected);
  }
  onEnterTrigger(trigger) {
    var _a2;
    if (debug104)
      console.log("ENTER TRIGGER", this.name, trigger.name, this, trigger);
    trigger.raiseOnEnterEvent(this);
    (_a2 = this.onEnter) == null ? void 0 : _a2.invoke(this, trigger);
  }
  onExitTrigger(trigger) {
    var _a2;
    if (debug104)
      console.log("EXIT TRIGGER", this.name, trigger.name, this, trigger);
    trigger.raiseOnExitEvent(this);
    (_a2 = this.onExit) == null ? void 0 : _a2.invoke(this, trigger);
  }
  onStayTrigger(trigger) {
    var _a2;
    trigger.raiseOnStayEvent(this);
    (_a2 = this.onStay) == null ? void 0 : _a2.invoke(this, trigger);
  }
};
__decorate83([
  serializable()
], SpatialTriggerReceiver.prototype, "triggerMask", void 0);
__decorate83([
  serializable(EventList)
], SpatialTriggerReceiver.prototype, "onEnter", void 0);
__decorate83([
  serializable(EventList)
], SpatialTriggerReceiver.prototype, "onStay", void 0);
__decorate83([
  serializable(EventList)
], SpatialTriggerReceiver.prototype, "onExit", void 0);
var _SpatialTrigger = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "triggerMask");
    __publicField(this, "boxHelper");
  }
  start() {
    if (debug104)
      console.log(this.name, this.triggerMask, this);
  }
  onEnable() {
    var _a2;
    _SpatialTrigger.triggers.push(this);
    if (!this.boxHelper) {
      this.boxHelper = GameObject.addComponent(this.gameObject, BoxHelperComponent);
      (_a2 = this.boxHelper) == null ? void 0 : _a2.showHelper(null, debug104);
    }
  }
  onDisable() {
    _SpatialTrigger.triggers.splice(_SpatialTrigger.triggers.indexOf(this), 1);
  }
  test(obj) {
    if (!this.boxHelper)
      return false;
    return this.boxHelper.isInBox(obj) ?? false;
  }
  // private args: SpatialTriggerEventArgs = new SpatialTriggerEventArgs();
  raiseOnEnterEvent(rec) {
    GameObject.foreachComponent(this.gameObject, (c2) => {
      if (c2 === rec)
        return;
      if (c2 instanceof SpatialTriggerReceiver) {
        c2.onEnterTrigger(this);
      }
    }, false);
  }
  raiseOnStayEvent(rec) {
    GameObject.foreachComponent(this.gameObject, (c2) => {
      if (c2 === rec)
        return;
      if (c2 instanceof SpatialTriggerReceiver) {
        c2.onStayTrigger(this);
      }
    }, false);
  }
  raiseOnExitEvent(rec) {
    GameObject.foreachComponent(this.gameObject, (c2) => {
      if (c2 === rec)
        return;
      if (c2 instanceof SpatialTriggerReceiver) {
        c2.onExitTrigger(this);
      }
    }, false);
  }
};
var SpatialTrigger = _SpatialTrigger;
__publicField(SpatialTrigger, "triggers", []);
__decorate83([
  serializable()
], SpatialTrigger.prototype, "triggerMask", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/SpectatorCamera.js
var __decorate84 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var SpectatorMode;
(function(SpectatorMode2) {
  SpectatorMode2[SpectatorMode2["FirstPerson"] = 0] = "FirstPerson";
  SpectatorMode2[SpectatorMode2["ThirdPerson"] = 1] = "ThirdPerson";
})(SpectatorMode || (SpectatorMode = {}));
var debug105 = getParam("debugspectator");
var SpectatorCamera = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "cam", null);
    /** when enabled pressing F will send a request to all connected users to follow me, ESC to stop */
    __publicField(this, "useKeys", true);
    __publicField(this, "_mode", SpectatorMode.FirstPerson);
    // private currentViewport : Vector4 = new Vector4();
    // private currentScissor : Vector4 = new Vector4();
    // private currentScissorTest : boolean = false;
    __publicField(this, "orbit", null);
    __publicField(this, "_handler");
    __publicField(this, "eventSub_WebXRRequestStartEvent", null);
    __publicField(this, "eventSub_WebXRStartEvent", null);
    __publicField(this, "eventSub_WebXREndEvent", null);
    __publicField(this, "_debug");
    __publicField(this, "_networking");
  }
  get mode() {
    return this._mode;
  }
  set mode(val) {
    this._mode = val;
  }
  /** if this user is currently spectating someone else */
  get isSpectating() {
    var _a2;
    return ((_a2 = this._handler) == null ? void 0 : _a2.currentTarget) !== void 0;
  }
  isSpectatingUser(userId) {
    var _a2;
    return ((_a2 = this.target) == null ? void 0 : _a2.userId) === userId;
  }
  isFollowedBy(userId) {
    var _a2;
    return (_a2 = this.followers) == null ? void 0 : _a2.includes(userId);
  }
  /** list of other users that are following me */
  get followers() {
    return this._networking.followers;
  }
  stopSpectating() {
    if (this.context.isInXR) {
      this.followSelf();
      return;
    }
    this.target = void 0;
  }
  get localId() {
    return this.context.connection.connectionId ?? "local";
  }
  /** player view to follow */
  set target(target) {
    var _a2;
    if (this._handler) {
      const prev = (_a2 = this._handler.currentTarget) == null ? void 0 : _a2.userId;
      const self2 = this.context.players.getPlayerView(this.localId);
      if (target === void 0 || this.context.isInXR === false && (self2 == null ? void 0 : self2.currentObject) === target.currentObject) {
        if (this._handler.currentTarget !== void 0) {
          this._handler.disable();
          GameObject.setActive(this.gameObject, false);
          if (this.orbit)
            this.orbit.enabled = true;
          this._networking.onSpectatedObjectChanged(target, prev);
        }
      } else if (this._handler.currentTarget !== target) {
        this._handler.set(target);
        GameObject.setActive(this.gameObject, true);
        if (this.orbit)
          this.orbit.enabled = false;
        this._networking.onSpectatedObjectChanged(target, prev);
      }
    }
  }
  get target() {
    var _a2;
    return (_a2 = this._handler) == null ? void 0 : _a2.currentTarget;
  }
  requestAllFollowMe() {
    this._networking.onRequestFollowMe();
  }
  get isSpectatingSelf() {
    var _a2, _b;
    return this.isSpectating && ((_a2 = this.target) == null ? void 0 : _a2.currentObject) === ((_b = this.context.players.getPlayerView(this.localId)) == null ? void 0 : _b.currentObject);
  }
  awake() {
    this._debug = new SpectatorSelectionController(this.context, this);
    this._networking = new SpectatorCamNetworking(this.context, this);
    this._networking.awake();
    GameObject.setActive(this.gameObject, false);
    this.cam = GameObject.getComponent(this.gameObject, Camera2);
    if (!this.cam) {
      console.warn("SpectatorCamera: Spectator camera needs camera component on the same object.", this);
      return;
    }
    if (!this._handler && this.cam)
      this._handler = new SpectatorHandler(this.context, this.cam, this);
    this.orbit = GameObject.getComponent(this.context.mainCamera, OrbitControls2);
  }
  onDestroy() {
    var _a2, _b;
    this.stopSpectating();
    (_a2 = this._handler) == null ? void 0 : _a2.destroy();
    (_b = this._networking) == null ? void 0 : _b.destroy();
  }
  isSupportedPlatform() {
    const ua = window.navigator.userAgent;
    const standalone = /Windows|MacOS/.test(ua);
    const isHololens = /Windows NT/.test(ua) && /Edg/.test(ua) && !/Win64/.test(ua);
    return standalone && !isHololens;
  }
  onBeforeXR(_evt) {
    if (!this.isSupportedPlatform())
      return;
    GameObject.setActive(this.gameObject, true);
  }
  onEnterXR(_evt) {
    if (!this.isSupportedPlatform())
      return;
    if (debug105)
      console.log(this.context.mainCamera);
    if (this.context.mainCamera) {
      this.followSelf();
    }
  }
  onLeaveXR(_evt) {
    var _a2, _b;
    this.context.removeCamera(this.cam);
    GameObject.setActive(this.gameObject, false);
    if (this.orbit)
      this.orbit.enabled = true;
    (_a2 = this._handler) == null ? void 0 : _a2.set(void 0);
    (_b = this._handler) == null ? void 0 : _b.disable();
    if (this.isSpectatingSelf)
      this.stopSpectating();
  }
  followSelf() {
    this.target = this.context.players.getPlayerView(this.context.connection.connectionId);
    if (!this.target) {
      this.context.players.setPlayerView(this.localId, this.context.mainCamera, ViewDevice.Headset);
      this.target = this.context.players.getPlayerView(this.localId);
    }
    if (debug105)
      console.log("Follow self", this.target);
  }
  // TODO: only show Spectator cam for DesktopVR;
  // don't show for AR, don't show on Quest
  // TODO: properly align cameras on enter/exit VR, seems currently spectator cam breaks alignment
  onAfterRender() {
    var _a2, _b, _c;
    if (!this.cam)
      return;
    const renderer = this.context.renderer;
    const xrWasEnabled = renderer.xr.enabled;
    if (!renderer.xr.isPresenting && !((_a2 = this._handler) == null ? void 0 : _a2.currentTarget))
      return;
    (_b = this._handler) == null ? void 0 : _b.update(this._mode);
    const previousRenderTarget = renderer.getRenderTarget();
    let oldFramebuffer = null;
    const webglState = renderer.state;
    if (!previousRenderTarget) {
      if (!renderer.state.bindFramebuffer || !webglState.bindXRFramebuffer)
        return;
      oldFramebuffer = renderer["_framebuffer"];
      webglState.bindXRFramebuffer(null);
    }
    this.setAvatarFlagsBeforeRender();
    const mainCam = this.context.mainCameraComponent;
    if (mainCam) {
      const backgroundColor = mainCam.backgroundColor;
      if (backgroundColor)
        renderer.setClearColor(backgroundColor, backgroundColor.alpha);
      this.cam.backgroundColor = backgroundColor;
      this.cam.clearFlags = mainCam.clearFlags;
      this.cam.nearClipPlane = mainCam.nearClipPlane;
      this.cam.farClipPlane = mainCam.farClipPlane;
    } else
      renderer.setClearColor(new Color(1, 1, 1));
    renderer.setRenderTarget(null);
    renderer.xr.enabled = false;
    const cam = (_c = this.cam) == null ? void 0 : _c.threeCamera;
    this.context.updateAspect(cam);
    const wasPresenting = renderer.xr.isPresenting;
    renderer.xr.isPresenting = false;
    renderer.setSize(this.context.domWidth, this.context.domHeight);
    renderer.render(this.context.scene, cam);
    renderer.xr.isPresenting = wasPresenting;
    renderer.xr.enabled = xrWasEnabled;
    if (previousRenderTarget)
      renderer.setRenderTarget(previousRenderTarget);
    else if (webglState.bindXRFramebuffer)
      webglState.bindXRFramebuffer(oldFramebuffer);
    this.resetAvatarFlags();
  }
  setAvatarFlagsBeforeRender() {
    const isFirstPersonMode = this._mode === SpectatorMode.FirstPerson;
    for (const av of AvatarMarker.instances) {
      if (av.avatar && "isLocalAvatar" in av.avatar && "flags" in av.avatar) {
        let mask = XRStateFlag.All;
        if (this.isSpectatingSelf)
          mask = isFirstPersonMode && av.avatar.isLocalAvatar ? XRStateFlag.FirstPerson : XRStateFlag.ThirdPerson;
        const flags = av.avatar.flags;
        if (!flags)
          continue;
        for (const flag of flags) {
          flag.UpdateVisible(mask);
        }
      }
    }
  }
  resetAvatarFlags() {
    var _a2;
    for (const av of AvatarMarker.instances) {
      if (av.avatar && "flags" in av.avatar) {
        const flags = av.avatar.flags;
        if (!flags)
          continue;
        for (const flag of flags) {
          if ("isLocalAvatar" in av.avatar && ((_a2 = av.avatar) == null ? void 0 : _a2.isLocalAvatar)) {
            flag.UpdateVisible(XRStateFlag.FirstPerson);
          } else {
            flag.UpdateVisible(XRStateFlag.ThirdPerson);
          }
        }
      }
    }
  }
};
__decorate84([
  serializable()
], SpectatorCamera.prototype, "useKeys", void 0);
var SpectatorHandler = class {
  constructor(context, cam, spectator) {
    __publicField(this, "context");
    __publicField(this, "cam");
    __publicField(this, "spectator");
    __publicField(this, "follow");
    __publicField(this, "target");
    __publicField(this, "view");
    __publicField(this, "currentObject");
    this.context = context;
    this.cam = cam;
    this.spectator = spectator;
  }
  get currentTarget() {
    return this.view;
  }
  set(view) {
    const followObject = view == null ? void 0 : view.currentObject;
    if (!followObject) {
      this.spectator.stopSpectating();
      return;
    }
    if (followObject === this.currentObject)
      return;
    this.currentObject = followObject;
    this.view = view;
    if (!this.follow)
      this.follow = GameObject.addComponent(this.cam.gameObject, SmoothFollow);
    if (!this.target)
      this.target = new Object3D();
    followObject.add(this.target);
    this.follow.enabled = true;
    this.follow.target = this.target;
    if (debug105)
      console.log("FOLLOW", followObject);
    if (!this.context.isInXR) {
      this.context.setCurrentCamera(this.cam);
    } else
      this.context.removeCamera(this.cam);
  }
  disable() {
    if (debug105)
      console.log("STOP FOLLOW", this.currentObject);
    this.view = void 0;
    this.currentObject = void 0;
    this.context.removeCamera(this.cam);
    if (this.follow)
      this.follow.enabled = false;
  }
  destroy() {
    var _a2;
    (_a2 = this.target) == null ? void 0 : _a2.removeFromParent();
    if (this.follow)
      GameObject.destroy(this.follow);
  }
  update(mode) {
    var _a2, _b, _c, _d, _e, _f;
    if (((_a2 = this.currentTarget) == null ? void 0 : _a2.isConnected) === false || ((_b = this.currentTarget) == null ? void 0 : _b.removed) === true) {
      if (debug105)
        console.log("Target disconnected or timeout", this.currentTarget);
      this.spectator.stopSpectating();
      return;
    }
    if (this.currentTarget && ((_c = this.currentTarget) == null ? void 0 : _c.currentObject) !== this.currentObject) {
      if (debug105)
        console.log("Target changed", this.currentObject, "to", this.currentTarget.currentObject);
      this.set(this.currentTarget);
    }
    const perspectiveCamera = this.context.mainCamera;
    if (perspectiveCamera) {
      const cam = this.cam.threeCamera;
      if (cam.near !== perspectiveCamera.near || cam.far !== perspectiveCamera.far) {
        cam.near = perspectiveCamera.near;
        cam.far = perspectiveCamera.far;
        cam.updateProjectionMatrix();
      }
    }
    const target = (_d = this.follow) == null ? void 0 : _d.target;
    if (!target || !this.follow)
      return;
    switch (mode) {
      case SpectatorMode.FirstPerson:
        if (((_e = this.view) == null ? void 0 : _e.viewDevice) !== ViewDevice.Browser) {
          this.follow.followFactor = 5;
          this.follow.rotateFactor = 5;
        } else {
          this.follow.followFactor = 50;
          this.follow.rotateFactor = 50;
        }
        target.position.set(0, 0, 0);
        break;
      case SpectatorMode.ThirdPerson:
        this.follow.followFactor = 3;
        this.follow.rotateFactor = 2;
        target.position.set(0, 0.5, 1.5);
        break;
    }
    this.follow.flipForward = false;
    if (((_f = this.view) == null ? void 0 : _f.viewDevice) !== ViewDevice.Browser)
      target.quaternion.copy(_inverseYQuat);
    else
      target.quaternion.identity();
  }
};
var _inverseYQuat = new Quaternion().setFromAxisAngle(new Vector32(0, 1, 0), Math.PI);
var SpectatorSelectionController = class {
  constructor(context, spectator) {
    __publicField(this, "context");
    __publicField(this, "spectator");
    this.context = context;
    this.spectator = spectator;
    console.log("[Spectator Camera] Click other avatars or cameras to follow them. Press ESC to exit spectator mode.");
    this.context.domElement.addEventListener("keydown", (evt) => {
      if (!this.spectator.useKeys)
        return;
      const key = evt.key;
      if (key === "Escape") {
        this.spectator.stopSpectating();
      }
    });
    let downTime = 0;
    this.context.input.addEventListener(InputEvents.PointerDown, (_) => {
      downTime = this.context.time.time;
    });
    this.context.input.addEventListener(InputEvents.PointerUp, (_) => {
      const dt = this.context.time.time - downTime;
      if (dt > 1) {
        this.spectator.stopSpectating();
      } else if (this.context.input.getPointerClicked(0) && dt < 0.3)
        this.trySelectObject();
    });
  }
  trySelectObject() {
    const opts = new RaycastOptions();
    opts.setMask(16777215);
    const hits = this.context.physics.raycast(opts);
    if (debug105)
      console.log(...hits);
    if (hits == null ? void 0 : hits.length) {
      for (const hit of hits) {
        if (hit.distance < 0.2)
          continue;
        const obj = hit.object;
        const avatar = GameObject.getComponentInParent(obj, AvatarMarker);
        const id = avatar == null ? void 0 : avatar.connectionId;
        if (id) {
          const view = this.context.players.getPlayerView(id);
          this.spectator.target = view;
          if (debug105)
            console.log("spectate", id, avatar);
          break;
        }
      }
    }
  }
};
var SpectatorFollowerChangedEventModel = class {
  constructor(connectionId, userId, stoppedFollowing) {
    /** the user that is following */
    __publicField(this, "guid");
    __publicField(this, "dontSave", true);
    /** the user being followed */
    __publicField(this, "targetUserId");
    __publicField(this, "stoppedFollowing");
    this.guid = connectionId;
    this.targetUserId = userId;
    this.stoppedFollowing = stoppedFollowing;
  }
};
var SpectatorFollowEventModel = class {
  constructor(comp, userId) {
    __publicField(this, "guid");
    __publicField(this, "userId");
    this.guid = comp.guid;
    this.userId = userId;
  }
};
var SpectatorCamNetworking = class {
  constructor(context, spectator) {
    __publicField(this, "followers", []);
    __publicField(this, "context");
    __publicField(this, "spectator");
    __publicField(this, "_followerEventMethod");
    __publicField(this, "_requestFollowMethod");
    __publicField(this, "_joinedRoomMethod");
    __publicField(this, "_lastRequestFollowUser");
    __publicField(this, "_enforceFollowInterval");
    this.context = context;
    this.spectator = spectator;
    this._followerEventMethod = this.onFollowerEvent.bind(this);
    this._requestFollowMethod = this.onRequestFollowEvent.bind(this);
    this._joinedRoomMethod = this.onUserJoinedRoom.bind(this);
  }
  awake() {
    this.context.connection.beginListen("spectator-follower-changed", this._followerEventMethod);
    this.context.connection.beginListen("spectator-request-follow", this._requestFollowMethod);
    this.context.connection.beginListen(RoomEvents.JoinedRoom, this._joinedRoomMethod);
    this.context.domElement.addEventListener("keydown", (evt) => {
      if (!this.spectator.useKeys)
        return;
      if (evt.key === "f") {
        this.onRequestFollowMe();
      } else if (evt.key === "Escape") {
        this.onRequestFollowMe(true);
      }
    });
  }
  destroy() {
    this.context.connection.stopListen("spectator-follower-changed", this._followerEventMethod);
    this.context.connection.stopListen("spectator-request-follow", this._requestFollowMethod);
    this.context.connection.stopListen(RoomEvents.JoinedRoom, this._joinedRoomMethod);
  }
  onSpectatedObjectChanged(target, _prevId) {
    if (debug105)
      console.log(this.context.connection.connectionId, "onSpectatedObjectChanged", target, _prevId);
    if (this.context.connection.connectionId) {
      const stopped = (target == null ? void 0 : target.userId) === void 0;
      const userId = stopped ? _prevId : target == null ? void 0 : target.userId;
      const evt = new SpectatorFollowerChangedEventModel(this.context.connection.connectionId, userId, stopped);
      this.context.connection.send("spectator-follower-changed", evt);
    }
  }
  onRequestFollowMe(stop = false) {
    if (debug105)
      console.log("Request follow", this.context.connection.connectionId);
    if (this.context.connection.connectionId) {
      this.spectator.stopSpectating();
      const id = stop ? void 0 : this.context.connection.connectionId;
      const model = new SpectatorFollowEventModel(this.spectator, id);
      this.context.connection.send("spectator-request-follow", model);
    }
  }
  onUserJoinedRoom() {
    if (getParam("followme")) {
      this.onRequestFollowMe();
    }
  }
  onFollowerEvent(evt) {
    const userBeingFollowed = evt.targetUserId;
    const userThatIsFollowing = evt.guid;
    if (debug105)
      console.log(evt);
    if (userBeingFollowed === this.context.connection.connectionId) {
      if (evt.stoppedFollowing) {
        const index = this.followers.indexOf(userThatIsFollowing);
        if (index !== -1) {
          this.followers.splice(index, 1);
          this.removeDisconnectedFollowers();
          console.log(userThatIsFollowing, "unfollows you", this.followers.length);
        }
      } else {
        if (!this.followers.includes(userThatIsFollowing)) {
          this.followers.push(userThatIsFollowing);
          this.removeDisconnectedFollowers();
          console.log(userThatIsFollowing, "follows you", this.followers.length);
        }
      }
    }
  }
  removeDisconnectedFollowers() {
    for (let i = this.followers.length - 1; i >= 0; i--) {
      const id = this.followers[i];
      if (this.context.connection.userIsInRoom(id) === false) {
        this.followers.splice(i, 1);
      }
    }
  }
  onRequestFollowEvent(evt) {
    this._lastRequestFollowUser = evt;
    if (evt.userId === this.context.connection.connectionId) {
      this.spectator.stopSpectating();
    } else if (evt.userId === void 0) {
      this.spectator.stopSpectating();
    } else {
      const view = this.context.players.getPlayerView(evt.userId);
      if (view) {
        this.spectator.target = view;
      } else {
        if (debug105)
          console.warn("Could not find view", evt.userId);
        this.enforceFollow();
        return false;
      }
    }
    return true;
  }
  enforceFollow() {
    if (this._enforceFollowInterval)
      return;
    this._enforceFollowInterval = setInterval(() => {
      if (this._lastRequestFollowUser === void 0 || this._lastRequestFollowUser.userId && this.spectator.isFollowedBy(this._lastRequestFollowUser.userId)) {
        clearInterval(this._enforceFollowInterval);
        this._enforceFollowInterval = void 0;
      } else {
        if (debug105)
          console.log("REQUEST FOLLOW AGAIN", this._lastRequestFollowUser.userId);
        this.onRequestFollowEvent(this._lastRequestFollowUser);
      }
    }, 1e3);
  }
};

// node_modules/@needle-tools/engine/lib/engine-schemes/synced-camera-model.js
var SyncedCameraModel = class {
  constructor() {
    __publicField(this, "bb", null);
    __publicField(this, "bb_pos", 0);
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsSyncedCameraModel(bb, obj) {
    return (obj || new SyncedCameraModel()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsSyncedCameraModel(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new SyncedCameraModel()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  userId(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  guid(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  dontSave() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
  }
  pos(obj) {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? (obj || new Vec32()).__init(this.bb_pos + offset, this.bb) : null;
  }
  rot(obj) {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? (obj || new Vec32()).__init(this.bb_pos + offset, this.bb) : null;
  }
  static startSyncedCameraModel(builder3) {
    builder3.startObject(5);
  }
  static addUserId(builder3, userIdOffset) {
    builder3.addFieldOffset(0, userIdOffset, 0);
  }
  static addGuid(builder3, guidOffset) {
    builder3.addFieldOffset(1, guidOffset, 0);
  }
  static addDontSave(builder3, dontSave) {
    builder3.addFieldInt8(2, +dontSave, 0);
  }
  static addPos(builder3, posOffset) {
    builder3.addFieldStruct(3, posOffset, 0);
  }
  static addRot(builder3, rotOffset) {
    builder3.addFieldStruct(4, rotOffset, 0);
  }
  static endSyncedCameraModel(builder3) {
    const offset = builder3.endObject();
    return offset;
  }
  static finishSyncedCameraModelBuffer(builder3, offset) {
    builder3.finish(offset);
  }
  static finishSizePrefixedSyncedCameraModelBuffer(builder3, offset) {
    builder3.finish(offset, void 0, true);
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/SyncedCamera.js
var __decorate85 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var SyncedCameraModelIdentifier = "SCAM";
registerBinaryType(SyncedCameraModelIdentifier, SyncedCameraModel.getRootAsSyncedCameraModel);
var builder2 = new Builder();
var CameraModel = class {
  // dontSave: boolean = true;
  // pos: { x: number, y: number, z: number } = { x: 0, y: 0, z: 0 };
  // rot: { x: number, y: number, z: number } = { x: 0, y: 0, z: 0 };
  constructor(connectionId, guid) {
    __publicField(this, "userId");
    __publicField(this, "guid");
    this.guid = guid;
    this.userId = connectionId;
  }
  send(cam, con) {
    if (cam) {
      builder2.clear();
      const guid = builder2.createString(this.guid);
      const userId = builder2.createString(this.userId);
      SyncedCameraModel.startSyncedCameraModel(builder2);
      SyncedCameraModel.addGuid(builder2, guid);
      SyncedCameraModel.addUserId(builder2, userId);
      const p = getWorldPosition(cam);
      const r = getWorldRotation(cam);
      SyncedCameraModel.addPos(builder2, Vec32.createVec3(builder2, p.x, p.y, p.z));
      SyncedCameraModel.addRot(builder2, Vec32.createVec3(builder2, r.x, r.y, r.z));
      const offset = SyncedCameraModel.endSyncedCameraModel(builder2);
      builder2.finish(offset, SyncedCameraModelIdentifier);
      con.sendBinary(builder2.asUint8Array());
    }
  }
};
var _SyncedCamera = class extends Component2 {
  constructor() {
    super(...arguments);
    /**
     * The prefab to visually represent the remote cameras in the scene.
     */
    __publicField(this, "cameraPrefab", null);
    __publicField(this, "_lastWorldPosition");
    __publicField(this, "_lastWorldQuaternion");
    __publicField(this, "_model", null);
    __publicField(this, "_needsUpdate", true);
    __publicField(this, "_lastUpdateTime", 0);
    __publicField(this, "remoteCams", {});
    __publicField(this, "userToCamMap", {});
    __publicField(this, "_camTimeoutInSeconds", 10);
    __publicField(this, "_receiveCallback", null);
  }
  getCameraObject(userId) {
    const guid = this.userToCamMap[userId];
    if (!guid)
      return null;
    return this.remoteCams[guid].obj;
  }
  /** @internal */
  async awake() {
    this._lastWorldPosition = this.worldPosition.clone();
    this._lastWorldQuaternion = this.worldQuaternion.clone();
    if (this.cameraPrefab) {
      if ("uri" in this.cameraPrefab) {
        this.cameraPrefab = await this.cameraPrefab.instantiate(this.gameObject);
      }
      if (this.cameraPrefab && "isObject3D" in this.cameraPrefab) {
        this.cameraPrefab.visible = false;
      }
    }
  }
  /** @internal */
  onEnable() {
    this._receiveCallback = this.context.connection.beginListenBinary(SyncedCameraModelIdentifier, this.onReceivedRemoteCameraInfoBin.bind(this));
  }
  /** @internal */
  onDisable() {
    this.context.connection.stopListenBinary(SyncedCameraModelIdentifier, this._receiveCallback);
  }
  /** @internal */
  update() {
    for (const guid in this.remoteCams) {
      const cam2 = this.remoteCams[guid];
      const timeDiff = this.context.time.realtimeSinceStartup - cam2.lastUpdate;
      if (!cam2 || timeDiff > this._camTimeoutInSeconds) {
        if (isDevEnvironment())
          console.log("Remote cam timeout", guid);
        if (cam2 == null ? void 0 : cam2.obj) {
          GameObject.destroy(cam2.obj);
        }
        delete this.remoteCams[guid];
        if (cam2)
          delete this.userToCamMap[cam2.userId];
        _SyncedCamera.instances.push(cam2);
        this.context.players.removePlayerView(cam2.userId, ViewDevice.Browser);
        continue;
      }
    }
    if (this.context.isInXR)
      return;
    const cam = this.context.mainCamera;
    if (cam === null) {
      this.enabled = false;
      return;
    }
    if (!this.context.connection.isConnected || this.context.connection.connectionId === null)
      return;
    if (this._model === null) {
      this._model = new CameraModel(this.context.connection.connectionId, this.context.connection.connectionId + "_camera");
    }
    const wp = getWorldPosition(cam);
    const wq = getWorldQuaternion(cam);
    if (wp.distanceTo(this._lastWorldPosition) > 1e-3 || wq.angleTo(this._lastWorldQuaternion) > 0.01) {
      this._needsUpdate = true;
    }
    this._lastWorldPosition.copy(wp);
    this._lastWorldQuaternion.copy(wq);
    if (!this._needsUpdate || this.context.time.frameCount % 2 !== 0) {
      if (this.context.time.realtimeSinceStartup - this._lastUpdateTime > this._camTimeoutInSeconds * 0.5) {
      } else
        return;
    }
    this._lastUpdateTime = this.context.time.realtimeSinceStartup;
    this._needsUpdate = false;
    this._model.send(cam, this.context.connection);
    if (!this.context.isInXR)
      this.context.players.setPlayerView(this.context.connection.connectionId, cam, ViewDevice.Browser);
  }
  onReceivedRemoteCameraInfoBin(model) {
    const guid = model.guid();
    if (!guid)
      return;
    const userId = model.userId();
    if (!userId)
      return;
    if (!this.context.connection.userIsInRoom(userId))
      return;
    if (!this.cameraPrefab)
      return;
    let rc = this.remoteCams[guid];
    if (!rc) {
      if ("isObject3D" in this.cameraPrefab) {
        const opt = new InstantiateOptions();
        opt.context = this.context;
        const instance = GameObject.instantiate(this.cameraPrefab, opt);
        rc = this.remoteCams[guid] = { obj: instance, lastUpdate: this.context.time.realtimeSinceStartup, userId };
        rc.obj.visible = true;
        this.gameObject.add(instance);
        this.userToCamMap[userId] = guid;
        _SyncedCamera.instances.push(rc);
        const marker = GameObject.getOrAddComponent(instance, AvatarMarker);
        marker.connectionId = userId;
        marker.avatar = instance;
      } else {
        return;
      }
    }
    const obj = rc.obj;
    this.context.players.setPlayerView(userId, obj, ViewDevice.Browser);
    rc.lastUpdate = this.context.time.realtimeSinceStartup;
    InstancingUtil.markDirty(obj);
    const pos = model.pos();
    if (pos)
      setWorldPositionXYZ(obj, pos.x(), pos.y(), pos.z());
    const rot = model.rot();
    if (rot)
      setWorldRotationXYZ(obj, rot.x(), rot.y(), rot.z());
  }
};
var SyncedCamera = _SyncedCamera;
__publicField(SyncedCamera, "instances", []);
__decorate85([
  serializable([Object3D, AssetReference])
], SyncedCamera.prototype, "cameraPrefab", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/SyncedRoom.js
var __decorate86 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var viewParamName = "view";
var debug106 = getParam("debugsyncedroom");
var SyncedRoom = class extends Component2 {
  constructor() {
    super(...arguments);
    /**
     * The name of the room to join.
     * @default ""
     */
    __publicField(this, "roomName", "");
    /**
     * The URL parameter name to use for the room name. E.g. if set to "room" the URL will look like `?room=roomName`.
     * @default "room"
     */
    __publicField(this, "urlParameterName", "room");
    /**
     * If true, the room will be joined automatically when this component becomes active.
     * @default undefined which means it will join a random room if no roomName is set.
     */
    __publicField(this, "joinRandomRoom");
    /**
     * If true and no room parameter is found in the URL then no room will be joined.
     * @default false
     */
    __publicField(this, "requireRoomParameter", false);
    /**
     * If true, the room will be rejoined automatically when disconnected.
     * @default true
     */
    __publicField(this, "autoRejoin", true);
    /**
     * If true, a join/leave room button will be created in the menu.
     * @default true
     */
    __publicField(this, "createJoinButton", true);
    /**
     * If true, a join/leave room button for the view only URL will be created in the menu.
     * @default false
     */
    __publicField(this, "createViewOnlyButton", false);
    __publicField(this, "_lastJoinedRoom");
    __publicField(this, "_roomPrefix", "");
    __publicField(this, "_lastPingTime", 0);
    __publicField(this, "_lastRoomTime", -1);
    __publicField(this, "_userWantsToBeInARoom", false);
    __publicField(this, "_roomButton");
    __publicField(this, "_roomButtonIconJoin");
    __publicField(this, "_roomButtonIconLeave");
    __publicField(this, "updateRoomButtonState", () => {
      var _a2, _b;
      if (!this._roomButton)
        return;
      if (this.context.connection.isInRoom) {
        this._roomButton.title = "Leave the networked room";
        this._roomButton.textContent = "Leave Room";
        (_a2 = this._roomButtonIconJoin) == null ? void 0 : _a2.remove();
        this._roomButton.prepend(this._roomButtonIconLeave);
      } else {
        this._roomButton.title = "Create or join a networked room";
        this._roomButton.textContent = "Join Room";
        (_b = this._roomButtonIconLeave) == null ? void 0 : _b.remove();
        this._roomButton.prepend(this._roomButtonIconJoin);
      }
    });
    __publicField(this, "_viewOnlyButton");
    __publicField(this, "onCreateViewOnlyButton", () => {
      if (!this._viewOnlyButton) {
        const button = document.createElement("button");
        this._viewOnlyButton = button;
        button.classList.add("view-only-button");
        button.setAttribute("priority", "90");
        button.onclick = () => {
          var _a2;
          const viewUrl = this.getViewOnlyUrl();
          if (viewUrl == null ? void 0 : viewUrl.length) {
            if (navigator.canShare({ url: viewUrl })) {
              (_a2 = navigator.share({ url: viewUrl })) == null ? void 0 : _a2.catch((err) => {
                console.warn(err);
              });
            } else {
              navigator.clipboard.writeText(viewUrl);
              showBalloonMessage("View only URL copied to clipboard");
            }
          } else {
            showBalloonWarning("Could not create view only URL");
          }
        };
        button.title = "Copy the view only URL: A page accessed by the view only URL can not be modified by visiting users.";
        button.textContent = "Share View URL";
        button.prepend(getIconElement("visibility"));
      }
      this.context.menu.appendChild(this._viewOnlyButton);
    });
  }
  /**
   * Get current room name from the URL parameter or the view parameter.
   */
  get currentRoomName() {
    const view = getParam(viewParamName);
    if (view)
      return view;
    return getParam(this.urlParameterName);
  }
  /** The room prefix to use for the room name. E.g. if set to "room_" and the room name is "name" the final room name will be "room_name". */
  set roomPrefix(val) {
    this._roomPrefix = val;
  }
  get roomPrefix() {
    return this._roomPrefix;
  }
  /** @internal */
  awake() {
    var _a2;
    if (this.joinRandomRoom === void 0 && ((_a2 = this.roomName) == null ? void 0 : _a2.length) <= 0) {
      this.joinRandomRoom = true;
    }
    if (debug106)
      console.log(`SyncedRoom roomName:${this.roomName}, urlParamName:${this.urlParameterName}, joinRandomRoom:${this.joinRandomRoom}`);
  }
  /** @internal */
  onEnable() {
    const viewId = getParam(viewParamName);
    if (viewId && typeof viewId === "string" && viewId.length > 0) {
      console.log("Join as viewer");
      this.context.connection.joinRoom(viewId, true);
      return;
    }
    this.tryJoinRoom();
    if (this.createJoinButton) {
      const button = this.createRoomButton();
      this.context.menu.appendChild(button);
    }
    if (this.createViewOnlyButton) {
      this.onEnableViewOnlyButton();
    }
  }
  /** @internal */
  onDisable() {
    var _a2;
    (_a2 = this._roomButton) == null ? void 0 : _a2.remove();
    this.onDisableViewOnlyButton();
    if (this.roomName && this.roomName.length > 0)
      this.context.connection.leaveRoom(this.roomName);
  }
  /** @internal */
  onDestroy() {
    this.destroyRoomButton();
  }
  /** Will generate a random room name, set it as an URL parameter and attempt to join the room */
  tryJoinRandomRoom() {
    this.setRandomRoomUrlParameter();
    this.tryJoinRoom();
  }
  /** Try to join the currently set roomName */
  tryJoinRoom(call = 0) {
    var _a2;
    if (call === void 0)
      call = 0;
    let hasRoomParameter = false;
    if (((_a2 = this.urlParameterName) == null ? void 0 : _a2.length) > 0) {
      const val = getParam(this.urlParameterName);
      if (val && (typeof val === "string" || typeof val === "number")) {
        hasRoomParameter = true;
        const roomNameParam = sanitizeString(val.toString());
        this.roomName = roomNameParam;
      } else if (this.joinRandomRoom) {
        console.log("No room name found in url, generating random one");
        this.setRandomRoomUrlParameter();
        if (call < 1)
          return this.tryJoinRoom(call + 1);
      }
    } else {
      if (this.joinRandomRoom && (this.roomName === null || this.roomName === void 0 || this.roomName.length <= 0)) {
        this.roomName = this.generateRoomName();
      }
    }
    if (this.requireRoomParameter && !hasRoomParameter) {
      if (debug106 || isDevEnvironment())
        console.warn('[SyncedRoom] Missing required room parameter "' + this.urlParameterName + '" in url - will not connect.\nTo allow joining a room without a query parameter you can set "requireRoomParameter" to false.');
      return false;
    }
    if (!this.context.connection.isConnected) {
      this.context.connection.connect();
    }
    this._lastJoinedRoom = this.roomName;
    if (this._roomPrefix)
      this.roomName = this._roomPrefix + this.roomName;
    if (this.roomName.length <= 0) {
      console.warn('[SyncedRoom] Room name is not set so we can not join a networked room.\nPlease choose one of the following options to fix this:\nA) Set a room name in the SyncedRoom component\nB) Set a room name in the URL parameter "?' + this.urlParameterName + '=my_room"\nC) Set "joinRandomRoom" to true');
      return false;
    }
    if (debug106)
      console.log("Join " + this.roomName);
    this._userWantsToBeInARoom = true;
    this.context.connection.joinRoom(this.roomName);
    return true;
  }
  /** @internal */
  update() {
    if (this.context.connection.isConnected) {
      if (this.context.time.time - this._lastPingTime > 3) {
        this._lastPingTime = this.context.time.time;
        this.context.connection.sendPing();
      }
      if (this.context.connection.isInRoom) {
        this._lastRoomTime = this.context.time.time;
      }
    }
    if (this._lastRoomTime > 0 && this.context.time.time - this._lastRoomTime > 0.3) {
      this._lastRoomTime = -1;
      if (this.autoRejoin) {
        if (this._userWantsToBeInARoom) {
          console.log("Disconnected from networking backend - attempt reconnecting now");
          this.tryJoinRoom();
        }
      } else if (isDevEnvironment())
        console.warn("You are not connected to a room anymore (possibly because the tab was inactive for too long and the server kicked you?)");
    }
  }
  /**
   * Get the URL to view the current room in view only mode.
   */
  getViewOnlyUrl() {
    if (this.context.connection.isConnected && this.context.connection.currentRoomViewId) {
      const url = window.location.search;
      const urlParams = new URLSearchParams(url);
      if (urlParams.has(this.urlParameterName))
        urlParams.delete(this.urlParameterName);
      urlParams.set(viewParamName, this.context.connection.currentRoomViewId);
      return window.location.origin + window.location.pathname + "?" + urlParams.toString();
    }
    return null;
  }
  setRandomRoomUrlParameter() {
    const params = getUrlParams();
    const room = this.generateRoomName();
    if (getParam(this.urlParameterName)) {
      params.set(this.urlParameterName, room);
    } else
      params.append(this.urlParameterName, room);
    setState(room, params);
  }
  generateRoomName() {
    let roomName = "";
    for (let i = 0; i < 6; i++) {
      roomName += Math.floor(Math.random() * 10).toFixed(0);
    }
    return roomName;
  }
  createRoomButton() {
    if (this._roomButton) {
      return this._roomButton;
    }
    const button = document.createElement("button");
    this._roomButton = button;
    button.classList.add("create-room-button");
    button.setAttribute("priority", "90");
    button.onclick = () => {
      if (this.context.connection.isInRoom) {
        if (this.urlParameterName) {
          setParamWithoutReload(this.urlParameterName, null);
        }
        this.context.connection.leaveRoom();
        this._userWantsToBeInARoom = false;
      } else {
        if (this.urlParameterName) {
          const name = getParam(this.urlParameterName);
          if (!name || name === true) {
            if (this._lastJoinedRoom)
              setParamWithoutReload(this.urlParameterName, this._lastJoinedRoom);
            else
              this.setRandomRoomUrlParameter();
          }
          ;
        }
        this.tryJoinRoom();
      }
    };
    this._roomButtonIconJoin = getIconElement("group");
    this._roomButtonIconLeave = getIconElement("group_off");
    this.updateRoomButtonState();
    this.context.connection.beginListen(RoomEvents.JoinedRoom, this.updateRoomButtonState);
    this.context.connection.beginListen(RoomEvents.LeftRoom, this.updateRoomButtonState);
    return button;
  }
  destroyRoomButton() {
    this.context.connection.stopListen(RoomEvents.JoinedRoom, this.updateRoomButtonState);
    this.context.connection.stopListen(RoomEvents.LeftRoom, this.updateRoomButtonState);
  }
  onEnableViewOnlyButton() {
    if (this.context.connection.isConnected) {
      this.onCreateViewOnlyButton();
    } else {
      this.context.connection.stopListen(RoomEvents.JoinedRoom, this.onCreateViewOnlyButton);
      this.context.connection.beginListen(RoomEvents.JoinedRoom, this.onCreateViewOnlyButton);
    }
  }
  onDisableViewOnlyButton() {
    var _a2;
    this.context.connection.stopListen(RoomEvents.JoinedRoom, this.onCreateViewOnlyButton);
    (_a2 = this._viewOnlyButton) == null ? void 0 : _a2.remove();
  }
};
__decorate86([
  serializable()
], SyncedRoom.prototype, "roomName", void 0);
__decorate86([
  serializable()
], SyncedRoom.prototype, "urlParameterName", void 0);
__decorate86([
  serializable()
], SyncedRoom.prototype, "joinRandomRoom", void 0);
__decorate86([
  serializable()
], SyncedRoom.prototype, "requireRoomParameter", void 0);
__decorate86([
  serializable()
], SyncedRoom.prototype, "autoRejoin", void 0);
__decorate86([
  serializable()
], SyncedRoom.prototype, "createJoinButton", void 0);
__decorate86([
  serializable()
], SyncedRoom.prototype, "createViewOnlyButton", void 0);
__decorate86([
  serializable()
], SyncedRoom.prototype, "roomPrefix", null);

// node_modules/@needle-tools/engine/lib/engine/tests/test_utils.js
function detect_run_tests() {
  const count = getParam("testwindowcount") || 0;
  if (count && count > 0) {
    spawnWindows(count);
  }
}
function spawnWindows(count) {
  if (getParam("testwindow"))
    return null;
  const url = new URL(window.location.href);
  setOrAddParamsToUrl(url.searchParams, noVoip, 1);
  setOrAddParamsToUrl(url.searchParams, "testwindow", 1);
  const str = url.toString();
  const windows = [];
  window.onbeforeunload = () => {
    for (const w of windows)
      w.close();
  };
  const spacing = 0.05;
  const size = 128;
  let x2 = 0;
  let y = 0;
  for (let i = 0; i < count; i++) {
    if (x2 * size + size * 0.01 >= window.innerWidth) {
      y += 1;
      x2 = 0;
    }
    const px = x2 * (size * (1 + spacing)) + window.screenLeft;
    const py = y * (size * (1 + spacing)) + window.screenTop + 90 + 60 * y;
    x2 += 1;
    const testWindow = window.open(str, "test window " + i, `popup=yes width=${size} height=${size} top=${py} left=${px}`);
    if (!testWindow) {
      console.warn("Failed to open window");
      continue;
    }
    windows.push(testWindow);
    testWindow.onload = () => {
      testWindow.onbeforeunload = () => {
        for (let i2 = 0; i2 < windows.length; i2++) {
          const w = windows[i2];
          if (w === testWindow)
            continue;
          w.close();
        }
        windows.length = 0;
      };
    };
  }
  return windows;
}

// node_modules/@needle-tools/engine/lib/engine-components/TestRunner.js
var TestRunner = class extends Component2 {
  awake() {
    detect_run_tests();
  }
};
var TestSimulateUserData = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "transformsPerFrame", 10);
    __publicField(this, "interval", 0);
    __publicField(this, "useFlatbuffers", true);
    __publicField(this, "builder", null);
    __publicField(this, "models", null);
  }
  awake() {
    if (this.useFlatbuffers) {
      this.context.connection.beginListenBinary(SyncedTransformIdentifier, (_mod) => {
      });
    } else {
      this.models = [];
      for (let i = 0; i < this.transformsPerFrame; i++) {
        this.models.push(new TransformModel(this.context.connection.connectionId + "_simulatedTransform_" + i, this));
      }
    }
  }
  update() {
    if (!this.context.connection.isConnected)
      return;
    if (this.useFlatbuffers) {
      if (!this.context.connection.connectionId || this.context.time.frameCount % this.interval !== 0)
        return;
      if (this.builder === null)
        this.builder = new Builder(1024);
      const builder3 = this.builder;
      for (let i = 0; i < this.transformsPerFrame; i++) {
        builder3.clear();
        const buf = createTransformModel(this.context.connection.connectionId, this);
        this.context.connection.sendBinary(buf);
      }
    } else {
      if (this.models) {
        for (let i = 0; i < this.models.length; i++) {
          const mod = this.models[i];
          mod.dontSave = true;
          mod.update(this, null);
          this.context.connection.send("TestSimulateUserData-" + i, mod);
        }
      }
    }
  }
};
var TransformModel = class {
  constructor(guid, obj) {
    __publicField(this, "guid");
    __publicField(this, "fast", false);
    __publicField(this, "position");
    __publicField(this, "rotation");
    // scale : { x : number, y : number, z : number } | undefined = undefined;
    __publicField(this, "velocity");
    __publicField(this, "dontSave");
    this.guid = guid;
    this.position = { x: 0, y: 0, z: 0 };
    this.rotation = { x: 0, y: 0, z: 0, w: 0 };
    this.update(obj, null);
  }
  isValid() {
    return this.fast !== void 0 || this.position !== void 0 || this.rotation !== void 0 || this.velocity !== void 0;
  }
  update(beh, rb) {
    const world = beh.worldPosition;
    this.position.x = world.x;
    this.position.y = world.y;
    this.position.z = world.z;
    const rot = beh.worldQuaternion;
    this.rotation.x = rot.x;
    this.rotation.y = rot.y;
    this.rotation.z = rot.z;
    this.rotation.w = rot.w;
    this.fast = false;
    if (rb) {
      const vel = rb.getVelocity();
      if (this.velocity === void 0)
        this.velocity = { x: 0, y: 0, z: 0 };
      this.velocity.x = vel.x;
      this.velocity.y = vel.y;
      this.velocity.z = vel.z;
    }
  }
};
__publicField(TransformModel, "temp", new Vector32());

// node_modules/@needle-tools/engine/lib/engine-components/postprocessing/Effects/TiltShiftEffect.js
var __decorate87 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var TiltShiftEffect2 = class extends PostProcessingEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "offset", new VolumeParameter(0));
    __publicField(this, "rotation", new VolumeParameter(0));
    __publicField(this, "focusArea", new VolumeParameter(0.4));
    __publicField(this, "feather", new VolumeParameter(0.3));
    __publicField(this, "kernelSize", new VolumeParameter(KernelSize.MEDIUM));
    __publicField(this, "resolutionScale", new VolumeParameter(1 / window.devicePixelRatio));
  }
  get typeName() {
    return "TiltShiftEffect";
  }
  init() {
    this.offset.defaultValue = 0;
    this.rotation.defaultValue = 0;
    this.focusArea.defaultValue = 0.4;
    this.feather.defaultValue = 0.3;
    this.kernelSize.defaultValue = KernelSize.MEDIUM;
    this.resolutionScale.defaultValue = 1 / window.devicePixelRatio;
  }
  onCreateEffect() {
    const effect = new TiltShiftEffect({
      kernelSize: KernelSize.VERY_LARGE,
      offset: this.offset.value,
      rotation: this.rotation.value,
      focusArea: this.focusArea.value,
      feather: this.feather.value
    });
    this.offset.onValueChanged = (v4) => effect.offset = v4;
    this.rotation.onValueChanged = (v4) => effect.rotation = v4;
    this.focusArea.onValueChanged = (v4) => effect.focusArea = v4;
    this.feather.onValueChanged = (v4) => effect.feather = v4;
    this.kernelSize.onValueChanged = (v4) => effect.blurPass.kernelSize = v4;
    this.resolutionScale.onValueChanged = (v4) => effect.resolution.scale = v4 / window.devicePixelRatio;
    return effect;
  }
};
__decorate87([
  serializable(VolumeParameter)
], TiltShiftEffect2.prototype, "offset", void 0);
__decorate87([
  serializable(VolumeParameter)
], TiltShiftEffect2.prototype, "rotation", void 0);
__decorate87([
  serializable(VolumeParameter)
], TiltShiftEffect2.prototype, "focusArea", void 0);
__decorate87([
  serializable(VolumeParameter)
], TiltShiftEffect2.prototype, "feather", void 0);
__decorate87([
  serializable(VolumeParameter)
], TiltShiftEffect2.prototype, "kernelSize", void 0);
__decorate87([
  serializable(VolumeParameter)
], TiltShiftEffect2.prototype, "resolutionScale", void 0);
registerCustomEffectType("TiltShiftEffect", TiltShiftEffect2);

// node_modules/@needle-tools/engine/lib/engine-components/TransformGizmo.js
var __decorate88 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var TransformGizmo = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "isGizmo", false);
    __publicField(this, "translationSnap", 1);
    __publicField(this, "rotationSnapAngle", 15);
    __publicField(this, "scaleSnap", 0.25);
    __publicField(this, "control");
    __publicField(this, "orbit");
    __publicField(this, "onControlChangedEvent", (event) => {
      const orbit = this.orbit;
      if (orbit)
        orbit.enabled = !event.value;
      if (event.value) {
        const sync = GameObject.getComponentInParent(this.gameObject, SyncedTransform);
        if (sync) {
          sync.requestOwnership();
        }
      }
    });
    __publicField(this, "windowKeyDownListener", (event) => {
      if (!this.enabled)
        return;
      if (!this.control)
        return;
      switch (event.keyCode) {
        case 81:
          this.control.setSpace(this.control.space === "local" ? "world" : "local");
          break;
        case 16:
          this.enableSnapping();
          break;
        case 87:
          this.control.setMode("translate");
          break;
        case 69:
          this.control.setMode("rotate");
          break;
        case 82:
          this.control.setMode("scale");
          break;
        case 187:
        case 107:
          this.control.setSize(this.control.size + 0.1);
          break;
        case 189:
        case 109:
          this.control.setSize(Math.max(this.control.size - 0.1, 0.1));
          break;
        case 88:
          this.control.showX = !this.control.showX;
          break;
        case 89:
          this.control.showY = !this.control.showY;
          break;
        case 90:
          this.control.showZ = !this.control.showZ;
          break;
        case 32:
          this.control.enabled = !this.control.enabled;
          break;
      }
    });
    __publicField(this, "windowKeyUpListener", (event) => {
      if (!this.enabled)
        return;
      switch (event.keyCode) {
        case 16:
          this.disableSnapping();
          break;
      }
    });
  }
  /** @internal */
  onEnable() {
    var _a2;
    if (this.isGizmo && !showGizmos)
      return;
    if (!this.context.mainCamera)
      return;
    if (!this.control) {
      this.control = new TransformControls(this.context.mainCamera, this.context.renderer.domElement);
      this.control.enabled = true;
      this.control.getRaycaster().layers.set(2);
      this.control.size = 1;
      const obj = "_root" in this.control ? this.control._root : this.control;
      obj.traverse((x2) => {
        const mesh = x2;
        mesh.layers.set(2);
        if (mesh) {
          const gizmoMat = mesh.material;
          if (gizmoMat) {
            gizmoMat.opacity = 0.3;
          }
        }
      });
      this.orbit = GameObject.getComponentInParent(this.context.mainCamera, OrbitControls2) ?? void 0;
    }
    if (this.control) {
      const obj = this.control.getHelper();
      this.context.scene.add(obj);
      this.control.attach(this.gameObject);
      (_a2 = this.control) == null ? void 0 : _a2.addEventListener("dragging-changed", this.onControlChangedEvent);
      window.addEventListener("keydown", this.windowKeyDownListener);
      window.addEventListener("keyup", this.windowKeyUpListener);
    }
  }
  /** @internal */
  onDisable() {
    var _a2, _b, _c;
    (_b = (_a2 = this.control) == null ? void 0 : _a2.getHelper()) == null ? void 0 : _b.removeFromParent();
    (_c = this.control) == null ? void 0 : _c.removeEventListener("dragging-changed", this.onControlChangedEvent);
    window.removeEventListener("keydown", this.windowKeyDownListener);
    window.removeEventListener("keyup", this.windowKeyUpListener);
  }
  enableSnapping() {
    if (this.control) {
      this.control.setTranslationSnap(this.translationSnap);
      this.control.setRotationSnap(MathUtils.degToRad(this.rotationSnapAngle));
      this.control.setScaleSnap(this.scaleSnap);
    }
  }
  disableSnapping() {
    if (this.control) {
      this.control.setTranslationSnap(null);
      this.control.setRotationSnap(null);
      this.control.setScaleSnap(null);
    }
  }
};
__decorate88([
  serializable()
], TransformGizmo.prototype, "isGizmo", void 0);
__decorate88([
  serializable()
], TransformGizmo.prototype, "translationSnap", void 0);
__decorate88([
  serializable()
], TransformGizmo.prototype, "rotationSnapAngle", void 0);
__decorate88([
  serializable()
], TransformGizmo.prototype, "scaleSnap", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/postprocessing/Effects/Vignette.js
var __decorate89 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var Vignette = class extends PostProcessingEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "color", new VolumeParameter({ r: 0, g: 0, b: 0, a: 1 }));
    __publicField(this, "intensity", new VolumeParameter(0));
    __publicField(this, "center", new VolumeParameter({ x: 0.5, y: 0.5 }));
  }
  get typeName() {
    return "Vignette";
  }
  init() {
    this.color.defaultValue = { r: 0, g: 0, b: 0, a: 1 };
    this.intensity.defaultValue = 0;
    this.center.defaultValue = { x: 0.5, y: 0.5 };
  }
  onCreateEffect() {
    const vignette = new VignetteEffect();
    this.intensity.onValueChanged = (v4) => {
      vignette.offset = v4;
      this.updateDarkness(vignette);
    };
    this.color.onValueChanged = (_) => {
      this.updateDarkness(vignette);
    };
    return vignette;
  }
  updateDarkness(effect) {
    const val = this.intensity.value;
    effect.darkness = val;
  }
};
__decorate89([
  serializable(VolumeParameter)
], Vignette.prototype, "color", void 0);
__decorate89([
  serializable(VolumeParameter)
], Vignette.prototype, "intensity", void 0);
__decorate89([
  serializable(VolumeParameter)
], Vignette.prototype, "center", void 0);
registerCustomEffectType("Vignette", Vignette);

// node_modules/@needle-tools/engine/lib/engine-components/postprocessing/Volume.js
var __decorate90 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug107 = getParam("debugpost");
var Volume = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "sharedProfile");
    __publicField(this, "_postprocessing");
    __publicField(this, "_activeEffects", []);
    __publicField(this, "_effects", []);
    __publicField(this, "_lastApplyTime");
    __publicField(this, "_rapidApplyCount", 0);
    __publicField(this, "_isDirty", false);
    __publicField(this, "_modificationQueue");
    __publicField(this, "_recreateId", -1);
  }
  get isPostProcessingManager() {
    return true;
  }
  /** Currently active postprocessing effects */
  get effects() {
    return this._activeEffects;
  }
  /**
   * Add a post processing effect to the stack and schedules the effect stack to be re-created.
   */
  addEffect(effect) {
    let entry = effect;
    if (entry instanceof Effect) {
      entry = new EffectWrapper(entry);
    }
    if (this._effects.includes(entry))
      return effect;
    this._effects.push(entry);
    this._isDirty = true;
    return effect;
  }
  removeEffect(effect) {
    var _a2, _b, _c, _d;
    let index = -1;
    if (effect instanceof Effect) {
      index = this._effects.findIndex((e) => e instanceof EffectWrapper && e.effect === effect);
    } else
      index = this._effects.indexOf(effect);
    if (index !== -1) {
      this._effects.splice(index, 1);
      this._isDirty = true;
      return effect;
    } else if (effect instanceof PostProcessingEffect) {
      const si = (_b = (_a2 = this.sharedProfile) == null ? void 0 : _a2.components) == null ? void 0 : _b.indexOf(effect);
      if (si !== void 0 && si !== -1) {
        this._isDirty = true;
        (_d = (_c = this.sharedProfile) == null ? void 0 : _c.components) == null ? void 0 : _d.splice(si, 1);
      }
    }
    return effect;
  }
  /**
   * When dirty the post processing effects will be re-applied
   */
  markDirty() {
    this._isDirty = true;
  }
  /** @internal */
  awake() {
    var _a2;
    if (debug107) {
      console.log("PostprocessingManager Awake", this);
      console.log("Press P to toggle post processing");
      window.addEventListener("keydown", (e) => {
        if (e.key === "p") {
          this.enabled = !this.enabled;
          showBalloonMessage("Toggle PostProcessing " + this.name + ": Enabled=" + this.enabled);
          this.markDirty();
        }
      });
    }
    (_a2 = this.sharedProfile) == null ? void 0 : _a2.init();
  }
  onEnable() {
    this._isDirty = true;
  }
  /** @internal */
  onDisable() {
    var _a2;
    (_a2 = this._postprocessing) == null ? void 0 : _a2.unapply();
    this._isDirty = false;
  }
  /** @internal */
  onBeforeRender() {
    var _a2;
    if (!this.context.isInXR) {
      if (this.context.composer && this.context.composer instanceof EffectComposer === false) {
        if (debug107)
          console.warn("PostProcessing: The current composer is not an EffectComposer - this is not supported");
        return;
      }
      if (this.context.mainCamera) {
        if (this._isDirty) {
          this.apply();
        }
      }
      if (this.context.composer && ((_a2 = this._postprocessing) == null ? void 0 : _a2.composer) === this.context.composer) {
        if (this.context.renderer.getContext().isContextLost()) {
          this.context.renderer.forceContextRestore();
        }
        if (this.context.composer.getRenderer() !== this.context.renderer)
          this.context.composer.setRenderer(this.context.renderer);
        this.context.composer.setMainScene(this.context.scene);
        if (this.context.mainCamera) {
          const passes = this.context.composer.passes;
          for (const pass of passes) {
            if (pass.mainCamera && pass.mainCamera !== this.context.mainCamera) {
              this.context.composer.setMainCamera(this.context.mainCamera);
              break;
            }
          }
        }
      }
    }
  }
  /** @internal */
  onDestroy() {
    var _a2;
    (_a2 = this._postprocessing) == null ? void 0 : _a2.dispose();
  }
  apply() {
    var _a2;
    if (debug107)
      console.log("Apply PostProcessing " + this.name);
    if (isDevEnvironment()) {
      if (this._lastApplyTime !== void 0 && Date.now() - this._lastApplyTime < 100) {
        this._rapidApplyCount++;
        if (this._rapidApplyCount === 5)
          console.warn("Detected rapid post processing modifications - this might be a bug", this);
      }
      this._lastApplyTime = Date.now();
    }
    this._isDirty = false;
    this.unapply();
    this._activeEffects.length = 0;
    if ((_a2 = this.sharedProfile) == null ? void 0 : _a2.components) {
      const comps = this.sharedProfile.components;
      for (const effect of comps) {
        if (effect.active && !this._activeEffects.includes(effect))
          this._activeEffects.push(effect);
      }
    }
    for (const effect of this._effects) {
      if (effect.active && !this._activeEffects.includes(effect))
        this._activeEffects.push(effect);
    }
    if (debug107)
      console.log("Apply PostProcessing", this._activeEffects);
    if (this._activeEffects.length > 0) {
      if (!this._postprocessing)
        this._postprocessing = new PostProcessingHandler(this.context);
      this._postprocessing.apply(this._activeEffects);
      this._applyPostQueue();
    }
  }
  unapply() {
    var _a2;
    (_a2 = this._postprocessing) == null ? void 0 : _a2.unapply();
  }
  _applyPostQueue() {
    if (this._modificationQueue) {
      for (const entry of this._modificationQueue.values())
        this.onEditorModification(entry);
      this._modificationQueue.clear();
    }
  }
  /** called from needle editor sync package if its active */
  onEditorModification(modification) {
    var _a2, _b;
    if (modification.propertyName.startsWith("postprocessing.")) {
      if (!this._postprocessing) {
        if (!this._modificationQueue)
          this._modificationQueue = /* @__PURE__ */ new Map();
        this._modificationQueue.set(modification.propertyName, modification);
        return true;
      }
      if (!((_a2 = this._activeEffects) == null ? void 0 : _a2.length))
        return;
      const path = modification.propertyName.split(".");
      if (path.length === 3 || path.length === 4) {
        const componentName = path[1];
        const propertyName = path[2];
        for (const comp of this._activeEffects) {
          if (((_b = comp.typeName) == null ? void 0 : _b.toLowerCase()) === componentName.toLowerCase()) {
            if (propertyName === "active") {
              comp.active = modification.value;
              this.scheduleRecreate();
              return;
            }
            if (!effectVolumeProperties.has(componentName)) {
              const volumeParameterKeys = new Array();
              effectVolumeProperties.set(componentName, volumeParameterKeys);
              const keys = Object.keys(comp);
              for (const key of keys) {
                const prop = comp[key];
                if (prop instanceof VolumeParameter) {
                  volumeParameterKeys.push(key);
                }
              }
            }
            if (effectVolumeProperties.has(componentName)) {
              const paramName = propertyName.toLowerCase();
              const volumeParameterKeys = effectVolumeProperties.get(componentName);
              for (const key of volumeParameterKeys) {
                if (key.toLowerCase() === paramName) {
                  const prop = comp[key];
                  if (prop instanceof VolumeParameter) {
                    const isActiveStateChange = path.length === 4 && path[3] === "active";
                    if (isActiveStateChange) {
                      prop.overrideState = modification.value;
                      this.scheduleRecreate();
                    } else if (prop && prop.value !== void 0) {
                      prop.value = modification.value;
                    }
                  }
                  return;
                }
              }
            }
            console.warn("Unknown modification", propertyName);
            return;
          }
        }
      }
      return true;
    }
    return false;
  }
  scheduleRecreate() {
    const id = ++this._recreateId;
    setTimeout(() => {
      if (id !== this._recreateId)
        return;
      this.onDisable();
      this.onEnable();
    }, 200);
  }
};
__decorate90([
  serializeable(VolumeProfile)
], Volume.prototype, "sharedProfile", void 0);
var effectVolumeProperties = /* @__PURE__ */ new Map();
setPostprocessingManagerType(Volume);

// node_modules/@needle-tools/engine/lib/engine/engine_utils_screenshot.xr.js
function updateTextureFromXRFrame(renderer, target) {
  const xrframe = renderer.xr.getFrame();
  if (!xrframe) {
    console.warn("No XRFrame available");
    return false;
  }
  const enabledFeatures = xrframe.session.enabledFeatures;
  if (enabledFeatures && !enabledFeatures.some((x2) => x2 === "camera-access")) {
    console.error(`No camera feed available - please request the 'camera-access' feature before starting WebXR or add the ARCameraBackground component to your scene.

Example to request camera-access in global scope:
NeedleXRSession.onSessionRequestStart(evt => {
    evt.init.optionalFeatures = evt.init.optionalFeatures || [];
    evt.init.optionalFeatures.push('camera-access');
});
`);
    if (isDevEnvironment()) {
      showBalloonError("No camera feed available - please request the 'camera-access' feature before starting WebXR or add the ARCameraBackground component to your scene");
    }
    return false;
  }
  const pose = xrframe.getViewerPose(renderer.xr.getReferenceSpace());
  if (pose) {
    for (const view of pose.views) {
      if ("camera" in view && view.camera) {
        let binding = renderer.xr.getBinding();
        if (!binding)
          binding = new XRWebGLBinding(xrframe.session, renderer.getContext());
        if (binding) {
          let glImage = null;
          if ("getCameraImage" in binding) {
            ensureTextureIsInitialized(renderer, target);
            const texProps = renderer.properties.get(target);
            if (texProps) {
              glImage = binding.getCameraImage(view.camera);
              texProps.__webglTexture = glImage;
              return true;
            } else {
              console.warn("No texture properties found for target texture");
            }
          }
        } else {
          console.error(view.camera, renderer.xr);
        }
      } else {
        console.error("NO CAMERA IN VIEW");
      }
    }
  } else {
    console.error(renderer.xr.getReferenceSpace(), xrframe);
  }
  return false;
}
var initcache = /* @__PURE__ */ new WeakMap();
function ensureTextureIsInitialized(renderer, texture) {
  const inits = initcache.get(texture) || /* @__PURE__ */ new WeakSet();
  if (inits.has(renderer)) {
    return;
  }
  inits.add(renderer);
  initcache.set(texture, inits);
  console.debug("Initialize texture for camera feed");
  const material = new MeshBasicMaterial();
  const geometry = new PlaneGeometry();
  const scene = new Scene();
  scene.add(new Mesh(geometry, material));
  const camera = new PerspectiveCamera();
  material.map = texture;
  renderer.render(scene, camera);
}

// node_modules/@needle-tools/engine/lib/engine/engine_utils_screenshot.js
function screenshot(context, width, height, mimeType = "image/webp", camera) {
  return screenshot2({ context, width, height, mimeType, camera });
}
function screenshot2(opts) {
  var _a2, _b;
  if (!opts)
    opts = {};
  const { transparent = false } = opts;
  let { mimeType, context, width, height, camera } = opts;
  if (!context) {
    context = ContextRegistry.Current;
    if (!context) {
      console.error("Can not save screenshot: No needle-engine context found or provided.");
      return null;
    }
  }
  if (!camera) {
    camera = context.mainCamera;
    if (!camera) {
      console.error("No camera found");
      return null;
    }
  }
  const renderer = context.renderer;
  const isXRScreenshot = renderer.xr.enabled;
  if (isXRScreenshot && context.currentFrameEvent != FrameEvent.EarlyUpdate) {
    console.warn("Screenshot: defer to access XR frame");
    const ret = new Promise((resolve2) => {
      registerFrameEventCallback((_) => {
        const screenshotResult = screenshot2(opts);
        resolve2(screenshotResult);
      }, FrameEvent.EarlyUpdate, { once: true });
    });
    return ret;
  }
  const domElement = renderer.domElement;
  const prevWidth = domElement.width;
  const prevHeight = domElement.height;
  if (!width)
    width = prevWidth;
  if (!height)
    height = prevHeight;
  const renderWidth = width;
  const renderHeight = height;
  const zoomLevel = window.devicePixelRatio || 1;
  width /= zoomLevel;
  height /= zoomLevel;
  const xrframe = renderer.xr.isPresenting && renderer.xr.getFrame();
  const previousXRState = renderer.xr.enabled;
  renderer.xr.enabled = false;
  renderer.xr.isPresenting = false;
  domElement.style.width = `${width}px`;
  domElement.style.height = `${height}px`;
  const prevRenderTarget = renderer.getRenderTarget();
  const previousClearColor = renderer.getClearColor(new Color());
  const previousClearAlpha = renderer.getClearAlpha();
  const previousBackground = context.scene.background;
  const previousAspect = "aspect" in camera ? camera.aspect : null;
  try {
    const callRenderEvents = opts.render_events !== false;
    const renderers = new Array();
    if (callRenderEvents) {
      getComponentsInChildren(context.scene, Renderer, renderers);
      renderers.forEach((r) => {
        var _a3;
        r == null ? void 0 : r.onBeforeRender();
        if (r.isInstancingActive && r.instances) {
          for (let i = 0; i < ((_a3 = r.instances) == null ? void 0 : _a3.length); i++) {
            const handle = r.instances[i];
            setCustomVisibility(handle.object, true);
          }
        }
      });
    }
    if (transparent) {
      context.scene.background = null;
      renderer.setClearColor(0, 0);
    }
    if (opts.background) {
      context.scene.background = null;
      renderer.setClearColor(opts.background);
      if (opts.background instanceof RGBAColor) {
        renderer.setClearAlpha(opts.background.a);
      }
    }
    if (transparent) {
      renderer.setClearAlpha(0);
    }
    renderer.setSize(width, height, false);
    if ("cam" in camera) {
      camera = camera.threeCamera;
    }
    if (camera instanceof PerspectiveCamera) {
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    }
    const textureOutput = "type" in opts && opts.type === "texture";
    let targetTexture = null;
    if (textureOutput) {
      targetTexture = new WebGLRenderTarget(width, height, {
        wrapS: MirroredRepeatWrapping,
        wrapT: MirroredRepeatWrapping,
        format: 1023
      });
      renderer.setRenderTarget(targetTexture);
    }
    let outputCanvas = domElement;
    if (isXRScreenshot) {
      if (targetTexture) {
        console.error('Taking XR screenshots with { type: "texture" } is currently not supported.');
      }
      outputCanvas = InternalScreenshotUtils.compositeWithCameraImage({
        width: renderWidth,
        height: renderHeight,
        scene: context.scene,
        camera,
        renderer
      });
    } else {
      context.renderNow(camera || null);
    }
    if (camera instanceof PerspectiveCamera && previousAspect != null) {
      camera.aspect = previousAspect;
      camera.updateProjectionMatrix();
    }
    if (callRenderEvents)
      renderers.forEach((r) => r.onAfterRender());
    if (!mimeType) {
      if ("download_filename" in opts && opts.download_filename) {
        const ext = (_a2 = opts.download_filename.split(".").pop()) == null ? void 0 : _a2.toLowerCase();
        switch (ext) {
          case "png":
            mimeType = "image/png";
            break;
          case "jpg":
          case "jpeg":
            mimeType = "image/jpeg";
            break;
          case "webp":
            mimeType = "image/webp";
            break;
        }
      }
    }
    if (transparent && opts.trim === true) {
      const trimmed = trimCanvas(outputCanvas);
      if (trimmed)
        outputCanvas = trimmed;
    }
    if ("type" in opts) {
      if (opts.type === "texture") {
        if (!targetTexture) {
          console.error("No target texture found");
          return null;
        }
        if (opts.target) {
          opts.target.image = targetTexture == null ? void 0 : targetTexture.texture.image;
          opts.target.needsUpdate = true;
        }
        targetTexture.texture.offset.set(0, -1);
        targetTexture.texture.needsUpdate = true;
        return targetTexture.texture;
      } else if (opts.type === "blob") {
        const promise = new Promise((resolve2, _) => {
          outputCanvas.toBlob((blob) => {
            resolve2(blob);
          }, mimeType);
        });
        return promise;
      } else if (opts.type === "share") {
        const promise = new Promise((resolve2, _) => {
          outputCanvas.toBlob((blob) => {
            if (blob && "share" in navigator) {
              let mimetype = "file_type" in opts ? opts.file_type || mimeType : mimeType;
              if (!mimeType) {
                mimetype = "image/png";
              }
              const ext = (mimetype == null ? void 0 : mimetype.split("/")[1]) || "png";
              const file = new File([blob], "filename" in opts ? opts.filename || `screenshot.${ext}` : `screenshot.${ext}`, { type: mimetype });
              return navigator.share({
                title: "title" in opts ? opts.title : void 0,
                text: "text" in opts ? opts.text : void 0,
                url: "url" in opts ? opts.url : void 0,
                files: [file]
              }).catch((err) => {
                console.warn("User cancelled share", err.message);
              }).finally(() => {
                resolve2({ blob, shared: true });
              });
            }
            return {
              blob,
              shared: false
            };
          }, mimeType);
        });
        return promise;
      }
    }
    const dataUrl = outputCanvas.toDataURL(mimeType);
    if ("download_filename" in opts && opts.download_filename) {
      let download_name = opts.download_filename;
      const ext = (_b = download_name.split(".").pop()) == null ? void 0 : _b.toLowerCase();
      download_name = `${download_name}-${Date.now()}.${ext}`;
      saveImage(dataUrl, download_name);
    }
    return dataUrl;
  } finally {
    renderer.setRenderTarget(prevRenderTarget);
    context.scene.background = previousBackground;
    renderer.setSize(prevWidth, prevHeight, false);
    renderer.setClearColor(previousClearColor, previousClearAlpha);
    if (previousAspect != null && camera instanceof PerspectiveCamera) {
      camera.aspect = previousAspect;
      camera.updateProjectionMatrix();
    }
    renderer.xr.enabled = previousXRState;
    renderer.xr.isPresenting = isXRScreenshot;
    if (!isXRScreenshot)
      context.updateSize(true);
  }
  return null;
}
function trimCanvas(originalCanvas) {
  if (!("document" in globalThis))
    return null;
  const canvas = document.createElement("canvas");
  canvas.width = originalCanvas.width;
  canvas.height = originalCanvas.height;
  const ctx = canvas.getContext("2d");
  if (!ctx)
    return null;
  ctx.drawImage(originalCanvas, 0, 0);
  const width = canvas.width;
  const height = canvas.height;
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  let top = height, left = width, bottom = 0, right = 0;
  for (let y = 0; y < height; y++) {
    for (let x2 = 0; x2 < width; x2++) {
      const index = (y * width + x2) * 4;
      const alpha = data[index + 3];
      if (alpha !== 0) {
        if (x2 < left)
          left = x2;
        if (x2 > right)
          right = x2;
        if (y < top)
          top = y;
        if (y > bottom)
          bottom = y;
      }
    }
  }
  const trimmedWidth = right - left + 1;
  const trimmedHeight = bottom - top + 1;
  const trimmedCanvas = document.createElement("canvas");
  const trimmedCtx = trimmedCanvas.getContext("2d");
  if (!trimmedCtx)
    return null;
  trimmedCanvas.width = trimmedWidth;
  trimmedCanvas.height = trimmedHeight;
  trimmedCtx.drawImage(canvas, left, top, trimmedWidth, trimmedHeight, 0, 0, trimmedWidth, trimmedHeight);
  return trimmedCanvas;
}
var saveImageElement = null;
function saveImage(dataUrl, filename) {
  if (!dataUrl) {
    return;
  }
  if (!dataUrl.startsWith("data:image")) {
    console.error("Can not save image: Data url is not an image", dataUrl);
    return;
  }
  if (!saveImageElement) {
    saveImageElement = document.createElement("a");
  }
  saveImageElement.href = dataUrl;
  saveImageElement.download = filename;
  saveImageElement.click();
}
var InternalScreenshotUtils;
(function(InternalScreenshotUtils2) {
  let backgroundPlane = null;
  let otherPlaneMesh = null;
  let rtTexture = null;
  let threeTexture = null;
  let customCanvas = null;
  function compositeWithCameraImage(args) {
    const { renderer, width, height } = args;
    const prevXREnabled = renderer.xr.enabled;
    const prevRT = renderer.getRenderTarget();
    const prevAutoClear = renderer.autoClear;
    const expectedWidth = width;
    const expectedHeight = height;
    const aspect = width / height;
    if (!rtTexture || rtTexture.width !== expectedWidth || rtTexture.height !== expectedHeight) {
      rtTexture ?? (rtTexture = new WebGLRenderTarget(expectedWidth, expectedHeight, { colorSpace: SRGBColorSpace }));
      rtTexture.width = expectedWidth;
      rtTexture.height = expectedHeight;
      rtTexture.samples = 4;
      rtTexture.texture.repeat.y = -1;
      rtTexture.texture.offset.y = 1;
    }
    if (!customCanvas || customCanvas.width !== expectedWidth || customCanvas.height !== expectedHeight) {
      customCanvas = document.createElement("canvas");
      customCanvas.width = expectedWidth;
      customCanvas.height = expectedHeight;
      customCanvas.style.position = "fixed";
      customCanvas.style.top = "0px";
      customCanvas.style.right = "0px";
      customCanvas.style.width = "300px";
      customCanvas.style.height = `${300 / aspect}px`;
      customCanvas.style.zIndex = "1000";
      customCanvas.style.pointerEvents = "none";
      customCanvas.style.opacity = "1.0";
      customCanvas.style.willChange = "contents";
    }
    if (!backgroundPlane) {
      backgroundPlane = makeFullscreenPlane({
        defines: {
          DECODE_VIDEO_TEXTURE: true
        }
      });
    }
    if (!otherPlaneMesh) {
      otherPlaneMesh = makeFullscreenPlane();
    }
    if (!threeTexture) {
      threeTexture = new Texture();
    }
    const manager = renderer.xr;
    manager.updateCamera(args.camera);
    renderer.xr.enabled = false;
    renderer.autoClear = false;
    renderer.clear();
    renderer.setSize(expectedWidth, expectedHeight);
    renderer.setRenderTarget(rtTexture);
    if (!updateTextureFromXRFrame(args.renderer, threeTexture)) {
      console.error("Could not update texture from XR frame");
    }
    const camBg = GameObject.findObjectOfType(WebARCameraBackground);
    if (camBg) {
      camBg.setTexture(threeTexture);
    } else {
      backgroundPlane.setTexture(threeTexture);
      renderer.render(backgroundPlane, args.camera);
    }
    renderer.clearDepth();
    renderer.setSize(expectedWidth, expectedHeight);
    renderer.render(args.scene, args.camera);
    renderer.setRenderTarget(null);
    otherPlaneMesh.setTexture(rtTexture.texture);
    renderer.render(otherPlaneMesh, args.camera);
    const _context = customCanvas.getContext("2d", { alpha: false });
    _context.drawImage(renderer.domElement, 0, 0, customCanvas.width, customCanvas.height);
    renderer.setRenderTarget(prevRT);
    renderer.xr.enabled = prevXREnabled;
    renderer.autoClear = prevAutoClear;
    return customCanvas;
  }
  InternalScreenshotUtils2.compositeWithCameraImage = compositeWithCameraImage;
  const backgroundFragment2 = (
    /* glsl */
    `
uniform sampler2D t2D;
varying vec2 vUv;

void main() {

    vec4 texColor = texture2D( t2D, vUv );

    #ifdef DECODE_VIDEO_TEXTURE

        // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)
        texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );

    #endif

    gl_FragColor = texColor;
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
}
`
  );
  function makeFullscreenPlane(options) {
    const planeMaterial = (options == null ? void 0 : options.material) || new ShaderMaterial({
      name: "BackgroundMaterial",
      uniforms: UniformsUtils.clone(ShaderLib.background.uniforms),
      vertexShader: ShaderLib.background.vertexShader,
      fragmentShader: backgroundFragment2,
      defines: options == null ? void 0 : options.defines,
      side: FrontSide,
      depthTest: false,
      depthWrite: false,
      fog: false
    });
    Object.defineProperty(planeMaterial, "map", {
      get: function() {
        return this.threeTexture;
      }
    });
    const planeMesh = new Mesh(new PlaneGeometry(2, 2), planeMaterial);
    planeMesh.geometry.deleteAttribute("normal");
    planeMesh.renderOrder = -1e6;
    planeMesh.setTexture = function(texture) {
      planeMaterial.uniforms.t2D.value = texture;
    };
    return planeMesh;
  }
  InternalScreenshotUtils2.makeFullscreenPlane = makeFullscreenPlane;
})(InternalScreenshotUtils || (InternalScreenshotUtils = {}));

// node_modules/@needle-tools/engine/lib/engine-components/webxr/WebARCameraBackground.js
var __decorate91 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug108 = getParam("debugarcamera");
var WebARCameraBackground = class extends Component2 {
  constructor() {
    super(...arguments);
    /**
     * The tint color of the camera feed
     */
    __publicField(this, "backgroundTint", new RGBAColor(1, 1, 1, 1));
    __publicField(this, "backgroundPlane");
    __publicField(this, "threeTexture");
    __publicField(this, "forceTextureInitialization", function() {
      const material = new MeshBasicMaterial();
      const geometry = new PlaneGeometry();
      const scene = new Scene();
      scene.add(new Mesh(geometry, material));
      const camera = new PerspectiveCamera();
      return function forceTextureInitialization(renderer, texture) {
        material.map = texture;
        renderer.render(scene, camera);
        if (debug108)
          console.warn("Force texture initialization");
      };
    }());
    /** @internal */
    __publicField(this, "preRender", () => {
      if (!this || !this.gameObject)
        return;
      const xr = this.context.renderer.xr;
      const frame = xr.getFrame();
      if (frame) {
        if (!this.threeTexture && this.context.renderer) {
          this.threeTexture = new Texture();
          this.forceTextureInitialization(this.context.renderer, this.threeTexture);
        }
        if (this.backgroundPlane === void 0) {
          const tint = this.backgroundTint;
          this.backgroundPlane = InternalScreenshotUtils.makeFullscreenPlane({
            material: new ShaderMaterial({
              name: "BackgroundMaterial",
              uniforms: {
                ...UniformsUtils.clone(ShaderLib.background.uniforms),
                tint: { value: new Vector4(tint.r, tint.g, tint.b, tint.a) }
              },
              vertexShader: ShaderLib.background.vertexShader,
              fragmentShader: backgroundFragment,
              side: DoubleSide,
              depthTest: false,
              depthWrite: false,
              fog: false
            })
          });
        }
        if (this.backgroundPlane.parent !== this.scene)
          this.scene.add(this.backgroundPlane);
        if (this.backgroundPlane.material instanceof ShaderMaterial)
          this.backgroundPlane.material.uniforms.tint.value.set(this.backgroundTint.r, this.backgroundTint.g, this.backgroundTint.b, this.backgroundTint.a);
        this.updateFromFrame();
      }
    });
  }
  /** @internal */
  onBeforeXR(_mode, args) {
    if (_mode === "immersive-ar") {
      args.optionalFeatures = args.optionalFeatures || [];
      args.optionalFeatures.push("camera-access");
      if (debug108)
        console.warn("Requesting camera-access");
    }
  }
  /** @internal */
  onEnterXR(_args) {
    if (_args.xr.mode === "immersive-ar") {
      if (this.backgroundPlane) {
        this.context.scene.add(this.backgroundPlane);
        this.backgroundPlane.visible = false;
      }
      if (this.backgroundPlane)
        this.context.scene.add(this.backgroundPlane);
      this.context.pre_render_callbacks.push(this.preRender);
    }
  }
  /** @internal */
  onLeaveXR(_args) {
    if (this.backgroundPlane)
      this.backgroundPlane.removeFromParent();
    const i = this.context.pre_render_callbacks.indexOf(this.preRender);
    if (i >= 0)
      this.context.pre_render_callbacks.splice(i, 1);
  }
  get background() {
    return this.backgroundPlane;
  }
  /** @internal */
  onBeforeRender(_frame2) {
    this.updateFromFrame();
  }
  updateFromFrame() {
    var _a2;
    if (!this.threeTexture)
      return;
    if (((_a2 = this.context.xr) == null ? void 0 : _a2.mode) === "immersive-ar") {
      updateTextureFromXRFrame(this.context.renderer, this.threeTexture);
      this.setTexture(this.threeTexture);
    }
  }
  setTexture(texture) {
    if (!this.backgroundPlane)
      return;
    this.threeTexture = texture;
    this.backgroundPlane.setTexture(this.threeTexture);
    this.backgroundPlane.visible = true;
  }
};
__decorate91([
  serializable(RGBAColor)
], WebARCameraBackground.prototype, "backgroundTint", void 0);
var backgroundFragment = (
  /* glsl */
  `
uniform sampler2D t2D;
uniform vec4 tint;

varying vec2 vUv;

void main() {

    vec4 texColor = texture2D( t2D, vUv );
    texColor.w = 1.0;

    // inline sRGB decode
    texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );

    gl_FragColor = texColor * tint;

    #include <tonemapping_fragment>
    #include <colorspace_fragment>
}
`
);

// node_modules/@needle-tools/engine/lib/engine-components/webxr/WebXRImageTracking.js
var __decorate92 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug109 = getParam("debugimagetracking");
var _WebXRTrackedImage = class {
  constructor(context, trackedImage, bitmap, measuredSize, state, pose) {
    __publicField(this, "measuredSize");
    __publicField(this, "state");
    __publicField(this, "_position");
    __publicField(this, "_rotation");
    __publicField(this, "_trackingComponent");
    __publicField(this, "_trackedImage");
    __publicField(this, "_bitmap");
    __publicField(this, "_pose");
    this._trackingComponent = context;
    ;
    this._trackedImage = trackedImage;
    this._bitmap = bitmap;
    this.measuredSize = measuredSize;
    this.state = state;
    this._pose = pose;
  }
  get url() {
    return this._trackedImage.image ?? "";
  }
  get widthInMeters() {
    return this._trackedImage.widthInMeters ?? void 0;
  }
  get bitmap() {
    return this._bitmap;
  }
  get model() {
    return this._trackedImage;
  }
  /** Copy the image position to a vector */
  getPosition(vec2) {
    this.ensureTransformData();
    vec2.copy(this._position);
    return vec2;
  }
  /** Copy the image rotation to a quaternion */
  getQuaternion(quat) {
    this.ensureTransformData();
    quat.copy(this._rotation);
    return quat;
  }
  applyToObject(object, t01 = void 0) {
    this.ensureTransformData();
    const changeAmount = object.position.distanceToSquared(this._position) / 0.05 + object.quaternion.angleTo(this._rotation) / 0.05;
    if (t01)
      t01 *= Math.max(1, changeAmount);
    if (t01 === void 0 || t01 >= 1) {
      object.position.copy(this._position);
      object.quaternion.copy(this._rotation);
    } else {
      t01 = Math.max(0, Math.min(1, t01));
      object.position.lerp(this._position, t01);
      object.quaternion.slerp(this._rotation, t01);
    }
  }
  ensureTransformData() {
    if (!this._position) {
      this._position = _WebXRTrackedImage._positionBuffer.get();
      this._rotation = _WebXRTrackedImage._rotationBuffer.get();
      const t2 = this._pose.transform;
      const converted = NeedleXRSession.active.convertSpace(t2);
      this._position.copy(converted == null ? void 0 : converted.position);
      this._rotation.copy(converted == null ? void 0 : converted.quaternion);
    }
  }
};
var WebXRTrackedImage = _WebXRTrackedImage;
__publicField(WebXRTrackedImage, "_positionBuffer", new CircularBuffer(() => new Vector32(), 20));
__publicField(WebXRTrackedImage, "_rotationBuffer", new CircularBuffer(() => new Quaternion(), 20));
var WebXRImageTrackingModel = class {
  constructor() {
    /**
     * Tracked image marker url. Make sure the image has good contrast and unique features to improve the tracking quality.
     */
    __publicField(this, "image");
    /** Make sure this matches your physical marker size! Otherwise the tracked object will \"swim\" above or below the marker.
     * @default 0.25 which is equivalent to 25cm
    */
    __publicField(this, "widthInMeters", 0.25);
    /**
     * The object moved around by the image. Make sure the size matches WidthInMeters.
     */
    __publicField(this, "object");
    /**
     * If true, a new instance of the referenced object will be created for each tracked image. Enable this if you're re-using objects for multiple markers.
     */
    __publicField(this, "createObjectInstance", false);
    /** Use this for static images (e.g. markers on the floor). Only the first few frames of new poses will be applied to the model. This will result in more stable tracking.
     * @default false
    */
    __publicField(this, "imageDoesNotMove", false);
    /**
     * Enable to hide the tracked object when the image is not tracked anymore. When disabled the tracked object will stay at the position it was last tracked at.
     * @default true
     */
    __publicField(this, "hideWhenTrackingIsLost", true);
  }
};
__decorate92([
  serializable(URL)
], WebXRImageTrackingModel.prototype, "image", void 0);
__decorate92([
  serializable()
], WebXRImageTrackingModel.prototype, "widthInMeters", void 0);
__decorate92([
  serializable(AssetReference)
], WebXRImageTrackingModel.prototype, "object", void 0);
__decorate92([
  serializable()
], WebXRImageTrackingModel.prototype, "createObjectInstance", void 0);
__decorate92([
  serializable()
], WebXRImageTrackingModel.prototype, "imageDoesNotMove", void 0);
__decorate92([
  serializable()
], WebXRImageTrackingModel.prototype, "hideWhenTrackingIsLost", void 0);
var ImageTrackingExtension = class {
  constructor(filename, imageData, widthInMeters) {
    __publicField(this, "filename");
    __publicField(this, "widthInMeters");
    __publicField(this, "imageData");
    this.filename = filename;
    this.imageData = imageData;
    this.widthInMeters = widthInMeters;
  }
  get extensionName() {
    return "image-tracking";
  }
  onAfterHierarchy(_context, writer) {
    writer.beginBlock(`def Preliminary_ReferenceImage "AnchoringReferenceImage"`);
    writer.appendLine(`uniform asset image = @image_tracking/` + this.filename + `@`);
    writer.appendLine(`uniform double physicalWidth = ` + (this.widthInMeters * 100).toFixed(8));
    writer.closeBlock();
  }
  onBeforeBuildDocument(_context) {
    const imageTracking = GameObject.findObjectOfType(WebXRImageTracking);
    if (!imageTracking || !imageTracking.trackedImages)
      return;
    if (imageTracking.trackedImages.length > 1) {
      if (isDevEnvironment())
        showBalloonWarning("USDZ: Only one tracked image is supported.");
      console.warn("USDZ: Only one tracked image is supported.");
    }
  }
  onAfterSerialize(context) {
    context.files["image_tracking/" + this.filename] = this.imageData;
  }
  onExportObject(object, model, _context) {
    var _a2;
    const imageTracking = GameObject.findObjectOfType(WebXRImageTracking);
    if (!imageTracking || !imageTracking.trackedImages)
      return;
    for (const trackedImage of imageTracking.trackedImages) {
      if (((_a2 = trackedImage.object) == null ? void 0 : _a2.asset) === object) {
        const exporter = GameObject.findObjectOfType(USDZExporter2);
        if (!exporter)
          continue;
        const { scale, target } = exporter.getARScaleAndTarget();
        let parent = object;
        const relativeMatrix = new Matrix4();
        if (object !== target) {
          while (parent.parent && parent.parent !== target) {
            parent = parent.parent;
            relativeMatrix.premultiply(parent.matrix);
          }
        }
        const mat = relativeMatrix.clone().invert();
        model.setMatrix(mat.scale(new Vector32(scale, scale, scale)));
        break;
      }
    }
  }
};
var _WebXRImageTracking = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "trackedImages");
    /** Applies smoothing based on detected jitter to the tracked image. */
    __publicField(this, "smooth", true);
    __publicField(this, "trackedImageIndexMap", /* @__PURE__ */ new Map());
    __publicField(this, "imageToObjectMap", /* @__PURE__ */ new Map());
    __publicField(this, "currentImages", []);
    __publicField(this, "onImageTrackingUpdate", (images) => {
      const xr = NeedleXRSession.active;
      if (!xr)
        return;
      for (const image of images) {
        const model = image.model;
        const isTracked = image.state === "tracked";
        if (!model.object)
          continue;
        let trackedData = this.imageToObjectMap.get(model);
        if (trackedData === void 0) {
          trackedData = { object: null, frames: 0, lastTrackingTime: Date.now() };
          this.imageToObjectMap.set(model, trackedData);
          model.object.loadAssetAsync().then((asset) => {
            if (model.createObjectInstance && asset) {
              asset = GameObject.instantiate(asset);
            }
            if (asset) {
              trackedData.object = asset;
              for (const rend of asset.getComponentsInChildren(Renderer)) {
                rend.setInstancingEnabled(false);
              }
              if (xr.rig) {
                xr.rig.gameObject.add(asset);
                image.applyToObject(asset);
                if (!asset.activeSelf)
                  GameObject.setActive(asset, true);
              } else {
                console.warn("XRImageTracking: missing XRRig");
              }
            }
          });
        } else {
          trackedData.frames++;
          if (isTracked)
            trackedData.lastTrackingTime = Date.now();
          if (model.imageDoesNotMove && trackedData.frames > 10)
            continue;
          if (!trackedData.object)
            continue;
          if (xr.rig) {
            xr.rig.gameObject.add(trackedData.object);
            image.applyToObject(trackedData.object, this.smooth ? this.context.time.deltaTimeUnscaled * 3 : void 0);
            if (!trackedData.object.activeSelf) {
              GameObject.setActive(trackedData.object, true);
            }
          }
        }
      }
    });
  }
  awake() {
    if (debug109)
      console.log(this);
    if (!this.trackedImages)
      return;
    for (const trackedImage of this.trackedImages) {
      if (trackedImage.image) {
        if (_WebXRImageTracking._imageElements.has(trackedImage.image)) {
        } else {
          const url = trackedImage.image;
          _WebXRImageTracking._imageElements.set(url, null);
          const imageElement = document.createElement("img");
          imageElement.src = url;
          imageElement.addEventListener("load", async () => {
            const img = await createImageBitmap(imageElement);
            _WebXRImageTracking._imageElements.set(url, img);
            const canvas = await imageToCanvas(img);
            if (canvas) {
              const blob = await canvas.convertToBlob({ type: "image/png" });
              const arrayBuffer = await blob.arrayBuffer();
              const exporter = GameObject.findObjectOfType(USDZExporter2);
              if (exporter && this.trackedImages) {
                exporter.extensions.push(new ImageTrackingExtension("marker.png", new Uint8Array(arrayBuffer), this.trackedImages[0].widthInMeters));
                exporter.anchoringType = "image";
              }
            }
          });
        }
      }
    }
  }
  onBeforeXR(_mode, args) {
    var _a2;
    if (this.trackedImages) {
      args.optionalFeatures = args.optionalFeatures || [];
      if (!args.optionalFeatures.includes("image-tracking"))
        args.optionalFeatures.push("image-tracking");
      args.trackedImages = [];
      for (const trackedImage of this.trackedImages) {
        if (((_a2 = trackedImage.image) == null ? void 0 : _a2.length) && trackedImage.widthInMeters > 0) {
          const bitmap = _WebXRImageTracking._imageElements.get(trackedImage.image);
          if (bitmap) {
            this.trackedImageIndexMap.set(args.trackedImages.length, trackedImage);
            args.trackedImages.push({
              image: bitmap,
              widthInMeters: trackedImage.widthInMeters
            });
          }
        }
      }
    }
  }
  onEnterXR(_args) {
    var _a2;
    if (this.trackedImages) {
      for (const trackedImage of this.trackedImages) {
        if ((_a2 = trackedImage.object) == null ? void 0 : _a2.asset) {
          const obj = trackedImage.object.asset;
          if (!obj.userData)
            obj.userData = {};
          const state = {
            visible: obj.visible,
            parent: obj.parent,
            matrix: obj.matrix.clone()
          };
          obj.userData["image-tracking"] = state;
        }
      }
    }
    for (const trackedData of this.imageToObjectMap.values()) {
      trackedData.frames = 0;
    }
  }
  onLeaveXR(_args) {
    var _a2, _b;
    if (this.trackedImages) {
      for (const trackedImage of this.trackedImages) {
        if ((_a2 = trackedImage.object) == null ? void 0 : _a2.asset) {
          const obj = trackedImage.object.asset;
          if (obj.userData) {
            const state = obj.userData["image-tracking"];
            if (state) {
              obj.visible = state.visible;
              (_b = state.parent) == null ? void 0 : _b.add(obj);
              obj.matrix.copy(state.matrix);
              obj.matrix.decompose(obj.position, obj.quaternion, obj.scale);
            }
            delete obj.userData["image-tracking"];
          }
        }
      }
    }
  }
  onUpdateXR(args) {
    var _a2;
    this.currentImages.length = 0;
    const frame = args.xr.frame;
    if (!frame)
      return;
    if (!("getImageTrackingResults" in frame)) {
      const warning = `Image tracking is currently not supported on this device. On Chrome for Android, you can enable the <a target="_blank" href="#" onclick="() => console.log('I')">chrome://flags/#webxr-incubations</a> flag.`;
      if (!this["didPrintWarning"]) {
        this["didPrintWarning"] = true;
        console.log(warning);
      }
      showBalloonWarning(warning);
      return;
    } else if (((_a2 = args.xr.session.enabledFeatures) == null ? void 0 : _a2.includes("image-tracking")) === false) {
      return;
    } else if (frame.session && typeof frame.getImageTrackingResults === "function") {
      const results = frame.getImageTrackingResults();
      if (results.length > 0) {
        const space = this.context.renderer.xr.getReferenceSpace();
        if (space) {
          for (const result of results) {
            const state = result.trackingState;
            const imageIndex = result.index;
            const trackedImage = this.trackedImageIndexMap.get(imageIndex);
            if (trackedImage) {
              const pose = frame.getPose(result.imageSpace, space);
              const imageData = new WebXRTrackedImage(this, trackedImage, result.image, result.measuredSize, state, pose);
              this.currentImages.push(imageData);
            } else {
              if (debug109) {
                console.warn("No tracked image for index", imageIndex);
              }
            }
          }
          if (this.currentImages.length > 0) {
            try {
              this.dispatchEvent(new CustomEvent("image-tracking", { detail: this.currentImages }));
              this.onImageTrackingUpdate(this.currentImages);
            } catch (e) {
              console.error(e);
            }
          }
        }
      }
    }
    const hysteresis = 1e3;
    for (const [key, value] of this.imageToObjectMap) {
      if (!value.object || !key)
        continue;
      if (key.hideWhenTrackingIsLost === false)
        continue;
      let found = false;
      for (const trackedImage of this.currentImages) {
        if (trackedImage.model === key) {
          const timeSinceLastTracking = Date.now() - value.lastTrackingTime;
          if (key.imageDoesNotMove || trackedImage.state === "tracked" || timeSinceLastTracking <= hysteresis) {
            found = true;
            break;
          }
        }
      }
      if (!found) {
        GameObject.setActive(value.object, false);
      }
    }
  }
};
var WebXRImageTracking = _WebXRImageTracking;
__publicField(WebXRImageTracking, "_imageElements", /* @__PURE__ */ new Map());
__decorate92([
  serializable(WebXRImageTrackingModel)
], WebXRImageTracking.prototype, "trackedImages", void 0);

// node_modules/three/examples/jsm/helpers/VertexNormalsHelper.js
var _v13 = new Vector32();
var _v22 = new Vector32();
var _normalMatrix = new Matrix3();
var VertexNormalsHelper = class extends LineSegments {
  constructor(object, size = 1, color2 = 16711680) {
    const geometry = new BufferGeometry();
    const nNormals = object.geometry.attributes.normal.count;
    const positions = new Float32BufferAttribute2(nNormals * 2 * 3, 3);
    geometry.setAttribute("position", positions);
    super(geometry, new LineBasicMaterial({ color: color2, toneMapped: false }));
    this.object = object;
    this.size = size;
    this.type = "VertexNormalsHelper";
    this.matrixAutoUpdate = false;
    this.update();
  }
  update() {
    this.object.updateMatrixWorld(true);
    _normalMatrix.getNormalMatrix(this.object.matrixWorld);
    const matrixWorld = this.object.matrixWorld;
    const position = this.geometry.attributes.position;
    const objGeometry = this.object.geometry;
    if (objGeometry) {
      const objPos = objGeometry.attributes.position;
      const objNorm = objGeometry.attributes.normal;
      let idx = 0;
      for (let j = 0, jl = objPos.count; j < jl; j++) {
        _v13.fromBufferAttribute(objPos, j).applyMatrix4(matrixWorld);
        _v22.fromBufferAttribute(objNorm, j);
        _v22.applyMatrix3(_normalMatrix).normalize().multiplyScalar(this.size).add(_v13);
        position.setXYZ(idx, _v13.x, _v13.y, _v13.z);
        idx = idx + 1;
        position.setXYZ(idx, _v22.x, _v22.y, _v22.z);
        idx = idx + 1;
      }
    }
    position.needsUpdate = true;
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/webxr/WebXRPlaneTracking.js
var __decorate93 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug110 = getParam("debugplanetracking");
var WebXRPlaneTracking = class extends Component2 {
  constructor() {
    super(...arguments);
    /**
     * Optional: if assigned it will be instantiated per tracked plane/tracked mesh.
     * If not assigned a simple mesh will be used. Use `occluder` to create occlusion meshes that don't render color but only depth.
     */
    __publicField(this, "dataTemplate");
    /**
     * If true an occluder material will be applied to the tracked planes/meshes.
     * Note: this will only be applied if dataTemplate is not assigned
     */
    __publicField(this, "occluder", true);
    /**
     * If true the system will try to initiate room capture if no planes are detected.
     */
    __publicField(this, "initiateRoomCaptureIfNoData", true);
    /**
     * If true plane tracking will be enabled
     */
    __publicField(this, "usePlaneData", true);
    /**
     * If true mesh tracking will be enabled
     */
    __publicField(this, "useMeshData", true);
    /** when enabled mesh or plane tracking will also be used in VR */
    __publicField(this, "runInVR", true);
    __publicField(this, "bounds", new Box3());
    __publicField(this, "center", new Vector32());
    __publicField(this, "labelOffset", new Vector32());
    __publicField(this, "_dataId", 1);
    __publicField(this, "_allPlanes", /* @__PURE__ */ new Map());
    __publicField(this, "_allMeshes", /* @__PURE__ */ new Map());
    __publicField(this, "firstTimeNoPlanesDetected", -100);
    __publicField(this, "makeOccluder", (mesh, m2, force = false) => {
      if (!m2)
        return;
      if (m2 instanceof Array) {
        for (const m0 of m2)
          this.makeOccluder(mesh, m0, force);
        return;
      }
      if (!force && !m2.name.toLowerCase().includes("occlu"))
        return;
      m2.colorWrite = false;
      m2.depthTest = true;
      m2.depthWrite = true;
      m2.transparent = false;
      m2.polygonOffset = true;
      m2.polygonOffsetFactor = 1;
      m2.polygonOffsetUnits = 0.1;
      mesh.renderOrder = -1e3;
    });
    __publicField(this, "_flipForwardMatrix", new Matrix4().makeRotationY(Math.PI));
    // we cache vertices-to-geometry, because it looks like when we get an update sometimes the geometry stays the same.
    // so we don't want to re-create the geometry every time.
    __publicField(this, "_verticesCache", /* @__PURE__ */ new Map());
  }
  /**
   * Returns all tracked planes
   */
  get trackedPlanes() {
    return this._allPlanes.values();
  }
  get trackedMeshes() {
    return this._allMeshes.values();
  }
  /** @internal */
  onBeforeXR(_mode, args) {
    if (_mode === "immersive-vr" && !this.runInVR)
      return;
    args.optionalFeatures = args.optionalFeatures || [];
    if (this.usePlaneData && !args.optionalFeatures.includes("plane-detection"))
      args.optionalFeatures.push("plane-detection");
    if (this.useMeshData && !args.optionalFeatures.includes("mesh-detection"))
      args.optionalFeatures.push("mesh-detection");
  }
  /** @internal */
  onEnterXR(_evt) {
    for (const data of this._allPlanes.keys()) {
      this.removeData(data, this._allPlanes);
    }
    for (const data of this._allMeshes.keys()) {
      this.removeData(data, this._allMeshes);
    }
  }
  onLeaveXR(_args) {
    for (const data of this._allPlanes.keys()) {
      this.removeData(data, this._allPlanes);
    }
    for (const data of this._allMeshes.keys()) {
      this.removeData(data, this._allMeshes);
    }
  }
  /** @internal */
  onUpdateXR(args) {
    if (!this.runInVR && args.xr.isVR)
      return;
    const rig = args.xr.rig;
    if (!rig) {
      console.warn("No XR rig found, cannot parent tracked planes to it");
      return;
    }
    const frame = args.xr.frame;
    const renderer = this.context.renderer;
    const referenceSpace = renderer.xr.getReferenceSpace();
    if (!referenceSpace)
      return;
    const planes = frame.detectedPlanes;
    const meshes = frame.detectedMeshes;
    const hasAnyPlanes = planes !== void 0 && planes.size > 0;
    const hasAnyMeshes = meshes !== void 0 && meshes.size > 0;
    if (this.initiateRoomCaptureIfNoData) {
      if (!hasAnyPlanes && !hasAnyMeshes && this.firstTimeNoPlanesDetected < -10)
        this.firstTimeNoPlanesDetected = Date.now();
      if (hasAnyPlanes || hasAnyMeshes)
        this.firstTimeNoPlanesDetected = -1;
      if (this.firstTimeNoPlanesDetected > 0 && Date.now() - this.firstTimeNoPlanesDetected > 2500) {
        if ("initiateRoomCapture" in frame.session) {
          frame.session.initiateRoomCapture();
          this.firstTimeNoPlanesDetected = -1;
        }
      }
    }
    if (planes !== void 0)
      this.processFrameData(args.xr, rig.gameObject, frame, planes, this._allPlanes);
    if (meshes !== void 0)
      this.processFrameData(args.xr, rig.gameObject, frame, meshes, this._allMeshes);
    if (debug110) {
      const camPos = this.context.mainCameraComponent.gameObject.worldPosition;
      for (const plane of this._allPlanes.values()) {
        if (!plane.mesh || !plane.mesh.visible)
          continue;
        this.bounds.makeEmpty();
        plane.mesh.traverse((x2) => {
          if (!(x2 instanceof Mesh))
            return;
          this.bounds.expandByObject(x2);
        });
        this.bounds.getCenter(this.center);
        this.labelOffset.copy(camPos).sub(this.center).normalize().multiplyScalar(0.1);
        Gizmos.DrawLabel(this.center.add(this.labelOffset), (plane.xrData.semanticLabel || "plane").toUpperCase() + "\n" + plane.xrData.lastChangedTime.toFixed(2), 0.02);
      }
    }
  }
  removeData(data, _all) {
    const dataContext = _all.get(data);
    if (!dataContext)
      return;
    _all.delete(data);
    if (debug110)
      console.log("Plane no longer tracked, id=" + dataContext.id);
    if (dataContext.mesh) {
      dataContext.mesh.removeFromParent();
      dataContext.mesh.traverse((x2) => {
        const nc = x2.userData["normalsHelper"];
        if (nc) {
          nc.dispose();
          nc.removeFromParent();
        } else if (debug110) {
          console.warn("No normals helper found for mesh", dataContext.mesh);
        }
      });
      destroy(dataContext.mesh, true, true);
    }
    const evt = new CustomEvent("plane-tracking", {
      detail: {
        type: "plane-removed",
        context: dataContext
      }
    });
    this.dispatchEvent(evt);
  }
  processFrameData(_xr, rig, frame, detected, _all) {
    const renderer = this.context.renderer;
    const referenceSpace = renderer.xr.getReferenceSpace();
    if (!referenceSpace)
      return;
    for (const data of _all.keys()) {
      if (!detected.has(data)) {
        this.removeData(data, _all);
      }
    }
    for (const data of detected) {
      const space = "planeSpace" in data ? data.planeSpace : "meshSpace" in data ? data.meshSpace : void 0;
      if (!space)
        continue;
      const planePose = frame.getPose(space, referenceSpace);
      let planeMesh;
      if (_all.has(data)) {
        const planeContext = _all.get(data);
        planeMesh = planeContext.mesh;
        if (planeContext.timestamp < data.lastChangedTime) {
          planeContext.timestamp = data.lastChangedTime;
          if (planeContext.mesh) {
            const geometry = this.createGeometry(data);
            if (planeContext.mesh instanceof Mesh) {
              planeContext.mesh.geometry.dispose();
              planeContext.mesh.geometry = geometry;
              this.makeOccluder(planeContext.mesh, planeContext.mesh.material);
            } else if (planeContext.mesh instanceof Group) {
              for (const ch of planeContext.mesh.children) {
                if (ch instanceof Mesh) {
                  ch.geometry.dispose();
                  ch.geometry = geometry;
                  this.makeOccluder(ch, ch.material);
                }
              }
            }
            if (planeContext.collider) {
              const mesh = planeContext.mesh;
              planeContext.collider.sharedMesh = mesh;
              planeContext.collider.convex = this.checkIfContextShouldBeConvex(mesh, planeContext.xrData);
              planeContext.collider.onDisable();
              planeContext.collider.onEnable();
            }
            if (debug110) {
              console.log("Plane updated, id=" + planeContext.id, planeContext);
              planeContext.mesh.traverse((x2) => {
                if (!(x2 instanceof Mesh))
                  return;
                const nh = x2.userData["normalsHelper"];
                if (!nh)
                  return;
                nh.update();
              });
            }
          }
          const evt = new CustomEvent("plane-tracking", {
            detail: {
              type: "plane-updated",
              context: planeContext
            }
          });
          this.dispatchEvent(evt);
        }
      } else {
        if (!this.dataTemplate) {
          const mesh = new Mesh();
          if (debug110)
            mesh.material = new MeshNormalMaterial();
          else if (this.occluder) {
            mesh.material = new MeshBasicMaterial();
            this.makeOccluder(mesh, mesh.material, true);
          } else {
            mesh.material = new MeshBasicMaterial({ wireframe: true, opacity: 0.5, transparent: true, color: 3355443 });
          }
          this.dataTemplate = new AssetReference("", "", mesh);
        }
        if (!this.dataTemplate.asset) {
          this.dataTemplate.loadAssetAsync();
        } else {
          const newPlane = GameObject.instantiate(this.dataTemplate.asset);
          newPlane.name = "xr-tracked-plane";
          planeMesh = newPlane;
          setVisibleInCustomShadowRendering(newPlane, false);
          if (newPlane instanceof Mesh) {
            disposeObjectResources(newPlane.geometry);
            newPlane.geometry = this.createGeometry(data);
            this.makeOccluder(newPlane, newPlane.material, this.occluder);
          } else if (newPlane instanceof Group) {
            for (const ch of newPlane.children) {
              if (ch instanceof Mesh) {
                disposeObjectResources(ch.geometry);
                ch.geometry = this.createGeometry(data);
                this.makeOccluder(ch, ch.material, this.occluder);
              }
            }
          }
          const mc = newPlane.getComponent(MeshCollider);
          if (mc) {
            const mesh = newPlane;
            mc.sharedMesh = mesh;
            mc.convex = this.checkIfContextShouldBeConvex(mesh, data);
            mc.onDisable();
            mc.onEnable();
          }
          newPlane.matrixAutoUpdate = false;
          newPlane.matrixWorldNeedsUpdate = true;
          rig.add(newPlane);
          const planeContext = {
            id: this._dataId++,
            xrData: data,
            timestamp: data.lastChangedTime,
            mesh: newPlane,
            collider: mc
          };
          _all.set(data, planeContext);
          if (debug110) {
            console.log("New plane detected, id=" + planeContext.id, planeContext, { hasCollider: !!mc, isGroup: newPlane instanceof Group });
          }
          try {
            const evt = new CustomEvent("plane-tracking", {
              detail: {
                type: "plane-added",
                context: planeContext
              }
            });
            this.dispatchEvent(evt);
          } catch (e) {
            console.error(e);
          }
        }
      }
      if (planeMesh) {
        if (planePose) {
          planeMesh.visible = true;
          planeMesh.matrix.fromArray(planePose.transform.matrix);
          planeMesh.matrix.premultiply(this._flipForwardMatrix);
        } else {
          planeMesh.visible = false;
        }
        if (debug110) {
          planeMesh.traverse((x2) => {
            if (!(x2 instanceof Mesh))
              return;
            if (x2.userData["normalsHelper"]) {
              const helper2 = x2.userData["normalsHelper"];
              helper2.update();
            } else {
              const normalsHelper = new VertexNormalsHelper(x2, 0.05, 255);
              normalsHelper.layers.disableAll();
              normalsHelper.layers.set(2);
              this.context.scene.add(normalsHelper);
              x2.userData["normalsHelper"] = normalsHelper;
            }
          });
        }
      }
    }
    ;
  }
  // heuristic to determine if a collider should be convex or not - 
  // the "global mesh" should be non-convex, other meshes should be
  checkIfContextShouldBeConvex(mesh, xrData) {
    if (!mesh)
      return true;
    if (mesh) {
      const bbox = new Box3();
      bbox.expandByObject(mesh);
      const size = new Vector32();
      bbox.getSize(size);
      let isConvex = true;
      if (size.x > 2 && size.y > 2 && size.z > 1.5)
        isConvex = false;
      if (isConvex && "semanticLabel" in xrData && xrData.semanticLabel === "wall")
        isConvex = true;
      return isConvex;
    }
    return true;
  }
  createGeometry(data) {
    if ("polygon" in data) {
      return this.createPlaneGeometry(data.polygon);
    } else if ("vertices" in data && "indices" in data) {
      return this.createMeshGeometry(data.vertices, data.indices);
    }
    return new BufferGeometry();
  }
  createMeshGeometry(vertices, indices) {
    const key = vertices.toString() + "_" + indices.toString();
    if (this._verticesCache.has(key)) {
      return this._verticesCache.get(key);
    }
    const geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute2(indices, 1));
    geometry.setAttribute("position", new BufferAttribute2(vertices, 3));
    const uvs = Array();
    for (let i = 0; i < vertices.length; i += 3) {
      uvs.push(vertices[i], vertices[i + 2]);
    }
    geometry.setAttribute("uv", new BufferAttribute2(vertices, 3));
    geometry.computeVertexNormals();
    this._verticesCache.set(key, geometry);
    return geometry;
  }
  createPlaneGeometry(polygon) {
    const geometry = new BufferGeometry();
    const vertices = [];
    const uvs = [];
    polygon.forEach((point) => {
      vertices.push(point.x, point.y, point.z);
      uvs.push(point.x, point.z);
    });
    const a = new Vector32(vertices[0], vertices[1], vertices[2]);
    const b = new Vector32(vertices[3], vertices[4], vertices[5]);
    const c2 = new Vector32(vertices[6], vertices[7], vertices[8]);
    const ab2 = new Vector32();
    const ac = new Vector32();
    ab2.subVectors(b, a);
    ac.subVectors(c2, a);
    ab2.cross(ac);
    ab2.normalize();
    const normals = [];
    for (let i = 0; i < vertices.length / 3; i++) {
      normals.push(ab2.x, ab2.y, ab2.z);
    }
    const indices = [];
    for (let i = 2; i < polygon.length; ++i) {
      indices.push(0, i - 1, i);
    }
    geometry.setAttribute("position", new BufferAttribute2(new Float32Array(vertices), 3));
    geometry.setAttribute("uv", new BufferAttribute2(new Float32Array(uvs), 2));
    geometry.setAttribute("normal", new BufferAttribute2(new Float32Array(normals), 3));
    geometry.setIndex(indices);
    geometry.computeBoundingBox();
    geometry.computeBoundingSphere();
    return geometry;
  }
};
__decorate93([
  serializable(AssetReference)
], WebXRPlaneTracking.prototype, "dataTemplate", void 0);
__decorate93([
  serializable()
], WebXRPlaneTracking.prototype, "occluder", void 0);
__decorate93([
  serializable()
], WebXRPlaneTracking.prototype, "initiateRoomCaptureIfNoData", void 0);
__decorate93([
  serializable()
], WebXRPlaneTracking.prototype, "usePlaneData", void 0);
__decorate93([
  serializable()
], WebXRPlaneTracking.prototype, "useMeshData", void 0);
__decorate93([
  serializable()
], WebXRPlaneTracking.prototype, "runInVR", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/webxr/controllers/XRControllerFollow.js
var __decorate94 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var XRControllerFollow = class extends Component2 {
  constructor() {
    super(...arguments);
    /** Should this object follow a right hand/controller or left hand/controller.
     * When a number is provided, the controller with that index is followed.
     * @default "none"
     **/
    __publicField(this, "side", "none");
    /** should it follow controllers (the physics controller)
     * @default true
    */
    __publicField(this, "controller", true);
    /** should it follow hands (when using hand tracking in WebXR)
     * @default false
    */
    __publicField(this, "hands", false);
    /** Disable if you don't want this script to modify the object's visibility
     * If enabled the object will be hidden when the configured controller or hand is not available
     * If disabled this script will not modify the object's visibility
     * @default true
     */
    __publicField(this, "controlVisibility", true);
    /** when true it will use the grip space, otherwise the ray space
     * @default false
    */
    __publicField(this, "useGripSpace", false);
    /** when enabled the position, rotation and scale of this object will be set to the position it was at when it entered the XR session
     * @default true
    */
    __publicField(this, "resetTransformAfterXRSession", true);
    __publicField(this, "_startPosition", new Vector32());
    __publicField(this, "_startRotation", new Quaternion());
    __publicField(this, "_startScale", new Vector32());
  }
  // override active and enabled here so that we always receive xr update events
  get activeAndEnabled() {
    return true;
  }
  /** @internal */
  onEnterXR(_args) {
    this._startPosition.copy(this.gameObject.position);
    this._startRotation.copy(this.gameObject.quaternion);
    this._startScale.copy(this.gameObject.scale);
  }
  /** @internal */
  onUpdateXR(args) {
    const ctrl = args.xr.getController(this.side);
    if (ctrl) {
      if (ctrl.hand && !this.hands) {
        if (this.controlVisibility)
          this.gameObject.visible = false;
        return;
      } else if (!this.controller) {
        if (this.controlVisibility)
          this.gameObject.visible = false;
        return;
      }
      if (this.controlVisibility)
        this.gameObject.visible = true;
      if (this.useGripSpace || ctrl.targetRayMode === "transient-pointer") {
        this.gameObject.worldPosition = ctrl.gripWorldPosition;
        this.gameObject.worldQuaternion = ctrl.gripWorldQuaternion;
        this.gameObject.worldScale = getTempVector(ctrl.xr.rigScale, ctrl.xr.rigScale, ctrl.xr.rigScale).multiply(this._startScale);
      } else {
        this.gameObject.worldPosition = ctrl.rayWorldPosition;
        this.gameObject.worldQuaternion = ctrl.rayWorldQuaternion;
        this.gameObject.worldScale = getTempVector(ctrl.xr.rigScale, ctrl.xr.rigScale, ctrl.xr.rigScale).multiply(this._startScale);
      }
    }
  }
  /** @internal */
  onLeaveXR(_args) {
    if (this.resetTransformAfterXRSession) {
      this.gameObject.position.copy(this._startPosition);
      this.gameObject.quaternion.copy(this._startRotation);
      this.gameObject.scale.copy(this._startScale);
    }
  }
};
__decorate94([
  serializable()
], XRControllerFollow.prototype, "side", void 0);
__decorate94([
  serializable()
], XRControllerFollow.prototype, "controller", void 0);
__decorate94([
  serializable()
], XRControllerFollow.prototype, "hands", void 0);
__decorate94([
  serializable()
], XRControllerFollow.prototype, "controlVisibility", void 0);
__decorate94([
  serializable()
], XRControllerFollow.prototype, "useGripSpace", void 0);
__decorate94([
  serializable()
], XRControllerFollow.prototype, "resetTransformAfterXRSession", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/webxr/WebXRRig.js
var __decorate95 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var debug111 = getParam("debugwebxr");
var XRRig = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 0);
    __publicField(this, "_startScale");
  }
  get isActive() {
    return this.activeAndEnabled && this.gameObject.visible;
  }
  /** Sets this rig to be the active XR rig (needs to be called during an active XR session) */
  setAsActiveXRRig() {
    var _a2;
    (_a2 = NeedleXRSession.active) == null ? void 0 : _a2.setRigActive(this);
  }
  awake() {
    if (debug111) {
      const gizmoObj = new Object3D();
      gizmoObj.position.y += 0.5;
      this.gameObject.add(gizmoObj);
      const box2 = gizmoObj.addNewComponent(BoxGizmo);
      if (box2)
        box2.isGizmo = false;
      const axes = new AxesHelper(0.5);
      this.gameObject.add(axes);
    }
  }
  isXRRig() {
    return true;
  }
  supportsXR(_mode) {
    return true;
  }
  onEnterXR(args) {
    this._startScale = this.gameObject.scale.clone();
    args.xr.addRig(this);
    if (debug111)
      console.log("WebXR: add Rig", this.name, this.priority);
  }
  onLeaveXR(args) {
    args.xr.removeRig(this);
    if (this._startScale && this.gameObject)
      this.gameObject.scale.copy(this._startScale);
  }
};
__decorate95([
  serializable()
], XRRig.prototype, "priority", void 0);

// node_modules/@needle-tools/engine/lib/engine-components/codegen/components.js
var __Ignore = class {
};

// node_modules/@needle-tools/engine/lib/engine-components-experimental/Presentation.js
var PresentationMode = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "toggleKey", "KeyP");
  }
  update() {
    if (this.context.input.isKeyDown(this.toggleKey)) {
      this.context.domElement.classList.toggle("presentation-mode");
    }
  }
};

// node_modules/@needle-tools/engine/lib/engine/codegen/register_types.js
TypeStore.add("__Ignore", __Ignore);
TypeStore.add("ActionBuilder", ActionBuilder);
TypeStore.add("ActionCollection", ActionCollection);
TypeStore.add("ActionModel", ActionModel);
TypeStore.add("AlignmentConstraint", AlignmentConstraint);
TypeStore.add("Animation", Animation);
TypeStore.add("AnimationCurve", AnimationCurve);
TypeStore.add("AnimationExtension", AnimationExtension);
TypeStore.add("AnimationTrackHandler", AnimationTrackHandler);
TypeStore.add("Animator", Animator);
TypeStore.add("AnimatorController", AnimatorController);
TypeStore.add("Antialiasing", Antialiasing);
TypeStore.add("AudioExtension", AudioExtension);
TypeStore.add("AudioListener", AudioListener2);
TypeStore.add("AudioSource", AudioSource);
TypeStore.add("AudioTrackHandler", AudioTrackHandler);
TypeStore.add("Avatar", Avatar);
TypeStore.add("Avatar_Brain_LookAt", Avatar_Brain_LookAt);
TypeStore.add("Avatar_MouthShapes", Avatar_MouthShapes);
TypeStore.add("Avatar_MustacheShake", Avatar_MustacheShake);
TypeStore.add("Avatar_POI", Avatar_POI);
TypeStore.add("AvatarBlink_Simple", AvatarBlink_Simple);
TypeStore.add("AvatarEyeLook_Rotation", AvatarEyeLook_Rotation);
TypeStore.add("AvatarLoader", AvatarLoader);
TypeStore.add("AvatarMarker", AvatarMarker);
TypeStore.add("AvatarModel", AvatarModel);
TypeStore.add("AxesHelper", AxesHelper2);
TypeStore.add("BaseUIComponent", BaseUIComponent);
TypeStore.add("BasicIKConstraint", BasicIKConstraint);
TypeStore.add("BehaviorExtension", BehaviorExtension);
TypeStore.add("BehaviorModel", BehaviorModel);
TypeStore.add("BloomEffect", BloomEffect2);
TypeStore.add("BoxCollider", BoxCollider);
TypeStore.add("BoxGizmo", BoxGizmo);
TypeStore.add("BoxHelperComponent", BoxHelperComponent);
TypeStore.add("Button", Button);
TypeStore.add("CallInfo", CallInfo);
TypeStore.add("Camera", Camera2);
TypeStore.add("CameraTargetReachedEvent", CameraTargetReachedEvent);
TypeStore.add("Canvas", Canvas);
TypeStore.add("CanvasGroup", CanvasGroup);
TypeStore.add("CapsuleCollider", CapsuleCollider);
TypeStore.add("ChangeMaterialOnClick", ChangeMaterialOnClick);
TypeStore.add("ChangeTransformOnClick", ChangeTransformOnClick);
TypeStore.add("CharacterController", CharacterController);
TypeStore.add("CharacterControllerInput", CharacterControllerInput);
TypeStore.add("ChromaticAberration", ChromaticAberration);
TypeStore.add("Collider", Collider);
TypeStore.add("ColorAdjustments", ColorAdjustments);
TypeStore.add("ColorBySpeedModule", ColorBySpeedModule);
TypeStore.add("ColorOverLifetimeModule", ColorOverLifetimeModule);
TypeStore.add("ContactShadows", ContactShadows);
TypeStore.add("ControlTrackHandler", ControlTrackHandler);
TypeStore.add("CustomBranding", CustomBranding);
TypeStore.add("Deletable", Deletable);
TypeStore.add("DeleteBox", DeleteBox);
TypeStore.add("DepthOfField", DepthOfField);
TypeStore.add("DeviceFlag", DeviceFlag);
TypeStore.add("DocumentExtension", DocumentExtension);
TypeStore.add("DragControls", DragControls);
TypeStore.add("DropListener", DropListener);
TypeStore.add("DropListenerAddedEvent", DropListenerAddedEvent);
TypeStore.add("Duplicatable", Duplicatable);
TypeStore.add("EffectWrapper", EffectWrapper);
TypeStore.add("EmissionModule", EmissionModule);
TypeStore.add("EmphasizeOnClick", EmphasizeOnClick);
TypeStore.add("EventList", EventList);
TypeStore.add("EventListEvent", EventListEvent);
TypeStore.add("EventSystem", EventSystem);
TypeStore.add("EventTrigger", EventTrigger);
TypeStore.add("FieldWithDefault", FieldWithDefault);
TypeStore.add("FixedJoint", FixedJoint);
TypeStore.add("FlyControls", FlyControls2);
TypeStore.add("Fog", Fog2);
TypeStore.add("GltfExport", GltfExport);
TypeStore.add("GltfExportBox", GltfExportBox);
TypeStore.add("Gradient", Gradient);
TypeStore.add("Graphic", Graphic);
TypeStore.add("GraphicRaycaster", GraphicRaycaster);
TypeStore.add("GridHelper", GridHelper2);
TypeStore.add("GridLayoutGroup", GridLayoutGroup);
TypeStore.add("GroundProjectedEnv", GroundProjectedEnv);
TypeStore.add("GroupActionModel", GroupActionModel);
TypeStore.add("HideOnStart", HideOnStart);
TypeStore.add("HingeJoint", HingeJoint);
TypeStore.add("HorizontalLayoutGroup", HorizontalLayoutGroup);
TypeStore.add("Image", Image2);
TypeStore.add("InheritVelocityModule", InheritVelocityModule);
TypeStore.add("InputField", InputField);
TypeStore.add("InstanceHandle", InstanceHandle);
TypeStore.add("InstancingHandler", InstancingHandler);
TypeStore.add("Interactable", Interactable);
TypeStore.add("Keyframe", Keyframe);
TypeStore.add("Light", Light);
TypeStore.add("LimitVelocityOverLifetimeModule", LimitVelocityOverLifetimeModule);
TypeStore.add("LODGroup", LODGroup);
TypeStore.add("LODModel", LODModel);
TypeStore.add("LogStats", LogStats);
TypeStore.add("LookAt", LookAt);
TypeStore.add("LookAtConstraint", LookAtConstraint);
TypeStore.add("MainModule", MainModule);
TypeStore.add("MaskableGraphic", MaskableGraphic);
TypeStore.add("MeshCollider", MeshCollider);
TypeStore.add("MeshRenderer", MeshRenderer);
TypeStore.add("MinMaxCurve", MinMaxCurve);
TypeStore.add("MinMaxGradient", MinMaxGradient);
TypeStore.add("NeedleMenu", NeedleMenu2);
TypeStore.add("NestedGltf", NestedGltf);
TypeStore.add("Networking", Networking);
TypeStore.add("NoiseModule", NoiseModule);
TypeStore.add("ObjectRaycaster", ObjectRaycaster);
TypeStore.add("OffsetConstraint", OffsetConstraint);
TypeStore.add("OpenURL", OpenURL);
TypeStore.add("OrbitControls", OrbitControls2);
TypeStore.add("Outline", Outline);
TypeStore.add("Padding", Padding);
TypeStore.add("ParticleBurst", ParticleBurst);
TypeStore.add("ParticleSubEmitter", ParticleSubEmitter);
TypeStore.add("ParticleSystem", ParticleSystem2);
TypeStore.add("ParticleSystemRenderer", ParticleSystemRenderer);
TypeStore.add("PhysicsExtension", PhysicsExtension);
TypeStore.add("PixelationEffect", PixelationEffect2);
TypeStore.add("PlayableDirector", PlayableDirector);
TypeStore.add("PlayAnimationOnClick", PlayAnimationOnClick);
TypeStore.add("PlayAudioOnClick", PlayAudioOnClick);
TypeStore.add("PlayerColor", PlayerColor);
TypeStore.add("PlayerState", PlayerState);
TypeStore.add("PlayerSync", PlayerSync);
TypeStore.add("PointerEventData", PointerEventData);
TypeStore.add("PostProcessingHandler", PostProcessingHandler);
TypeStore.add("PreliminaryAction", PreliminaryAction);
TypeStore.add("PreliminaryTrigger", PreliminaryTrigger);
TypeStore.add("PresentationMode", PresentationMode);
TypeStore.add("RawImage", RawImage);
TypeStore.add("Rect", Rect);
TypeStore.add("RectTransform", RectTransform);
TypeStore.add("ReflectionProbe", ReflectionProbe);
TypeStore.add("RegisteredAnimationInfo", RegisteredAnimationInfo);
TypeStore.add("RemoteSkybox", RemoteSkybox);
TypeStore.add("Renderer", Renderer);
TypeStore.add("RendererLightmap", RendererLightmap);
TypeStore.add("Rigidbody", Rigidbody);
TypeStore.add("RotationBySpeedModule", RotationBySpeedModule);
TypeStore.add("RotationOverLifetimeModule", RotationOverLifetimeModule);
TypeStore.add("SceneSwitcher", SceneSwitcher);
TypeStore.add("ScreenCapture", ScreenCapture);
TypeStore.add("ScreenSpaceAmbientOcclusion", ScreenSpaceAmbientOcclusion);
TypeStore.add("ScreenSpaceAmbientOcclusionN8", ScreenSpaceAmbientOcclusionN8);
TypeStore.add("SetActiveOnClick", SetActiveOnClick);
TypeStore.add("ShadowCatcher", ShadowCatcher);
TypeStore.add("ShapeModule", ShapeModule);
TypeStore.add("SharpeningEffect", SharpeningEffect);
TypeStore.add("SignalAsset", SignalAsset);
TypeStore.add("SignalReceiver", SignalReceiver);
TypeStore.add("SignalReceiverEvent", SignalReceiverEvent);
TypeStore.add("SignalTrackHandler", SignalTrackHandler);
TypeStore.add("Size", Size);
TypeStore.add("SizeBySpeedModule", SizeBySpeedModule);
TypeStore.add("SizeOverLifetimeModule", SizeOverLifetimeModule);
TypeStore.add("SkinnedMeshRenderer", SkinnedMeshRenderer);
TypeStore.add("SmoothFollow", SmoothFollow);
TypeStore.add("SpatialGrabRaycaster", SpatialGrabRaycaster);
TypeStore.add("SpatialHtml", SpatialHtml);
TypeStore.add("SpatialTrigger", SpatialTrigger);
TypeStore.add("SpatialTriggerReceiver", SpatialTriggerReceiver);
TypeStore.add("SpectatorCamera", SpectatorCamera);
TypeStore.add("SphereCollider", SphereCollider);
TypeStore.add("Sprite", Sprite3);
TypeStore.add("SpriteData", SpriteData);
TypeStore.add("SpriteRenderer", SpriteRenderer);
TypeStore.add("SpriteSheet", SpriteSheet);
TypeStore.add("SubEmitterSystem", SubEmitterSystem);
TypeStore.add("SyncedCamera", SyncedCamera);
TypeStore.add("SyncedRoom", SyncedRoom);
TypeStore.add("SyncedTransform", SyncedTransform);
TypeStore.add("TapGestureTrigger", TapGestureTrigger);
TypeStore.add("TeleportTarget", TeleportTarget);
TypeStore.add("TestRunner", TestRunner);
TypeStore.add("TestSimulateUserData", TestSimulateUserData);
TypeStore.add("Text", Text);
TypeStore.add("TextBuilder", TextBuilder);
TypeStore.add("TextExtension", TextExtension);
TypeStore.add("TextureSheetAnimationModule", TextureSheetAnimationModule);
TypeStore.add("TiltShiftEffect", TiltShiftEffect2);
TypeStore.add("ToneMappingEffect", ToneMappingEffect2);
TypeStore.add("TrailModule", TrailModule);
TypeStore.add("TransformData", TransformData);
TypeStore.add("TransformGizmo", TransformGizmo);
TypeStore.add("TriggerBuilder", TriggerBuilder);
TypeStore.add("TriggerModel", TriggerModel);
TypeStore.add("UIRaycastUtils", UIRaycastUtils);
TypeStore.add("UIRootComponent", UIRootComponent);
TypeStore.add("UsageMarker", UsageMarker);
TypeStore.add("USDZExporter", USDZExporter2);
TypeStore.add("USDZText", USDZText);
TypeStore.add("USDZUIExtension", USDZUIExtension);
TypeStore.add("VariantAction", VariantAction);
TypeStore.add("VelocityOverLifetimeModule", VelocityOverLifetimeModule);
TypeStore.add("VerticalLayoutGroup", VerticalLayoutGroup);
TypeStore.add("VideoPlayer", VideoPlayer);
TypeStore.add("Vignette", Vignette);
TypeStore.add("VisibilityAction", VisibilityAction);
TypeStore.add("Voip", Voip);
TypeStore.add("Volume", Volume);
TypeStore.add("VolumeParameter", VolumeParameter);
TypeStore.add("VolumeProfile", VolumeProfile);
TypeStore.add("WebARCameraBackground", WebARCameraBackground);
TypeStore.add("WebARSessionRoot", WebARSessionRoot);
TypeStore.add("WebXR", WebXR);
TypeStore.add("WebXRImageTracking", WebXRImageTracking);
TypeStore.add("WebXRImageTrackingModel", WebXRImageTrackingModel);
TypeStore.add("WebXRPlaneTracking", WebXRPlaneTracking);
TypeStore.add("WebXRTrackedImage", WebXRTrackedImage);
TypeStore.add("XRControllerFollow", XRControllerFollow);
TypeStore.add("XRControllerModel", XRControllerModel2);
TypeStore.add("XRControllerMovement", XRControllerMovement);
TypeStore.add("XRFlag", XRFlag);
TypeStore.add("XRRig", XRRig);
TypeStore.add("XRState", XRState);

// node_modules/@needle-tools/engine/lib/engine/engine_gltf_builtin_components.js
var debug112 = debugExtension;
var debugTypeStore = getParam("debugtypestore");
if (debugTypeStore)
  console.log(TypeStore);
function writeBuiltinComponentData(comp, context) {
  const serializable2 = comp;
  const data = serializeObject(serializable2, context);
  if (data !== void 0)
    return data;
  return null;
}
var typeImplementationInformation = new ImplementationInformation();
var $context_deserialize_queue = Symbol("deserialize-queue");
async function createBuiltinComponents(context, gltfId, gltf, seed = null, extension) {
  if (!gltf) {
    console.debug("Can not create component instances: gltf is null");
    return;
  }
  const lateResolve = [];
  let idProvider2 = seed;
  if (typeof idProvider2 === "number") {
    idProvider2 = new InstantiateIdProvider(seed);
  }
  const idEnd = gltfId.indexOf("?");
  gltfId = idEnd === -1 ? gltfId : gltfId.substring(0, idEnd);
  const serializationContext = new SerializationContext(gltf.scene);
  serializationContext.gltfId = gltfId;
  serializationContext.context = context;
  serializationContext.gltf = gltf;
  serializationContext.nodeToObject = extension == null ? void 0 : extension.nodeToObjectMap;
  serializationContext.implementationInformation = typeImplementationInformation;
  let deserializeQueue = context[$context_deserialize_queue];
  if (!deserializeQueue)
    deserializeQueue = context[$context_deserialize_queue] = [];
  if (gltf.scenes) {
    for (const scene of gltf.scenes) {
      await onCreateBuiltinComponents(serializationContext, scene, deserializeQueue, lateResolve);
    }
  }
  if (gltf.children) {
    for (const ch of gltf.children) {
      await onCreateBuiltinComponents(serializationContext, ch, deserializeQueue, lateResolve);
    }
  }
  context.new_scripts_pre_setup_callbacks.push(() => {
    const queue = context[$context_deserialize_queue];
    if (queue) {
      for (const des of queue) {
        handleDeserialization(des, serializationContext);
      }
      queue.length = 0;
    }
    if (idProvider2) {
      const guidsMap = {};
      const resolveGuids = [];
      recursiveCreateGuids(gltf, idProvider2, guidsMap, resolveGuids);
      for (const scene of gltf.scenes)
        recursiveCreateGuids(scene, idProvider2, guidsMap, resolveGuids);
      for (const res of resolveGuids) {
        res.resolveGuids(guidsMap);
      }
    }
  });
}
var originalComponentNameKey = Symbol("original-component-name");
var idProviderCache = /* @__PURE__ */ new Map();
function recursiveCreateGuids(obj, idProvider2, guidsMap, resolveGuids) {
  if (idProvider2 === null)
    return;
  if (!obj)
    return;
  const prev = obj.guid;
  const idProviderKey = obj.guid;
  if (idProviderKey == null ? void 0 : idProviderKey.length) {
    if (!idProviderCache.has(idProviderKey)) {
      if (debug112)
        console.log('Creating InstanceIdProvider with key "' + idProviderKey + '" for object ' + obj.name);
      idProviderCache.set(idProviderKey, new InstantiateIdProvider(idProviderKey));
    }
  }
  const objectIdProvider = idProviderKey && idProviderCache.get(idProviderKey) || idProvider2;
  obj.guid = objectIdProvider.generateUUID();
  if (prev && prev !== "invalid")
    guidsMap[prev] = obj.guid;
  if (obj && obj.userData && obj.userData.components) {
    for (const comp of obj.userData.components) {
      if (comp === null)
        continue;
      const idProviderKey2 = comp.guid;
      if (idProviderKey2) {
        if (!idProviderCache.has(idProviderKey2)) {
          if (debug112)
            console.log('Creating InstanceIdProvider with key "' + idProviderKey2 + '" for component ' + comp[originalComponentNameKey]);
          idProviderCache.set(idProviderKey2, new InstantiateIdProvider(idProviderKey2));
        }
      } else if (debug112)
        console.warn("Can not create IdProvider: component " + comp[originalComponentNameKey] + " has no guid", comp.guid);
      const componentIdProvider = idProviderCache.get(idProviderKey2) || idProvider2;
      const prev2 = comp.guid;
      comp.guid = componentIdProvider.generateUUID();
      if (prev2 && prev2 !== "invalid")
        guidsMap[prev2] = comp.guid;
      if (comp.resolveGuids)
        resolveGuids.push(comp);
    }
  }
  if (obj.children) {
    for (const child of obj.children) {
      recursiveCreateGuids(child, idProvider2, guidsMap, resolveGuids);
    }
  }
}
var unknownComponentsBuffer = [];
async function onCreateBuiltinComponents(context, obj, deserialize, lateResolve) {
  if (!obj)
    return;
  const data = obj.userData;
  if (data) {
    const components = data.builtin_components;
    if (components && components.length > 0) {
      for (const compData of components) {
        try {
          if (compData === null)
            continue;
          const type = TypeStore.get(compData.name);
          if (type !== void 0 && type !== null) {
            const instance = new type();
            instance.sourceId = context.gltfId;
            assign(instance, compData, context.implementationInformation);
            instance.context = context.context;
            if ("guid" in compData)
              instance[editorGuidKeyName] = compData.guid;
            instance[originalComponentNameKey] = compData.name;
            const callAwake = false;
            addNewComponent(obj, instance, callAwake);
            deserialize.push({ instance, compData, obj });
            if (instance.isCamera && context.context) {
              if (context.context.mainCamera === null && instance.tag === "MainCamera")
                context.context.setCurrentCamera(instance);
            }
          } else {
            if (debug112)
              console.debug("unknown component: " + compData.name);
            if (!unknownComponentsBuffer.includes(compData.name))
              unknownComponentsBuffer.push(compData.name);
          }
        } catch (err) {
          console.error(compData.name + " - " + err.message, err);
        }
      }
    }
    if (unknownComponentsBuffer.length > 0) {
      const unknown = unknownComponentsBuffer.join(", ");
      console.warn("unknown components: " + unknown);
      unknownComponentsBuffer.length = 0;
      if (isLocalNetwork())
        showBalloonMessage(`<strong>Unknown components in scene</strong>:

${unknown}

This could mean you forgot to add a npmdef to your ExportInfo
<a href="https://engine.needle.tools/docs/project_structure.html#creating-and-installing-a-npmdef" target="_blank">documentation</a>`, LogType.Warn);
    }
  }
  if (obj.children) {
    for (const ch of obj.children) {
      await onCreateBuiltinComponents(context, ch, deserialize, lateResolve);
    }
  }
}
function handleDeserialization(data, context) {
  const { instance, compData, obj } = data;
  context.object = obj;
  context.target = instance;
  let deserialized = true;
  deserialized = deserializeObject(instance, compData, context) === true;
  if (debug112)
    console.debug("add " + compData.name, compData, instance);
}

// node_modules/@needle-tools/engine/lib/engine/engine_utils_format.js
var debug113 = getParam("debugfileformat");
async function tryDetermineFileTypeFromURL(url, useExtension = true) {
  var _a2;
  if (useExtension) {
    const _url = url;
    const urlobj = new URL(_url, globalThis.location.origin);
    let ext = null;
    const query = urlobj.searchParams.get("filetype");
    if (query)
      ext = query.toUpperCase();
    if (!(ext == null ? void 0 : ext.length)) {
      ext = (_a2 = urlobj.pathname.split(".").pop()) == null ? void 0 : _a2.toUpperCase();
    }
    if (debug113)
      console.debug("Use file extension to determine type: " + ext);
    switch (ext) {
      case "GLTF":
        return "gltf";
      case "VRM":
        return "vrm";
      case "GLB":
        return "glb";
      case "FBX":
        return "fbx";
      case "USD":
        return "usd";
      case "USDA":
        return "usda";
      case "USDZ":
        return "usdz";
      case "OBJ":
        return "obj";
    }
  }
  const header = await fetch(url, {
    method: "GET",
    headers: {
      "range": "bytes=0-32"
    }
  }).catch((_) => {
    return null;
  });
  if (header == null ? void 0 : header.ok) {
    const data = await header.arrayBuffer();
    const res = tryDetermineFileTypeFromBinary(data, header);
    if (debug113)
      console.log("Determined file type from header: " + res);
    return res;
  }
  return "unknown";
}
function tryDetermineFileTypeFromBinary(data, response) {
  if (data.byteLength < 4) {
    return "unknown";
  }
  const bytes = new Uint8Array(data);
  if (debug113) {
    console.warn("Trying to determine file type from binary data\n", '"' + new TextDecoder().decode(data) + '"\n', bytes);
  }
  if (bytes[0] == 103 && bytes[1] == 108 && bytes[2] == 84 && bytes[3] == 70) {
    console.debug("GLTF detected");
    return "glb";
  }
  if (bytes[0] == 80 && bytes[1] == 75 && bytes[2] == 3 && bytes[3] == 4) {
    console.debug("USDZ detected");
    return "usdz";
  }
  if (bytes[0] == 80 && bytes[1] == 88 && bytes[2] == 82 && bytes[3] == 45 && bytes[4] == 85 && bytes[5] == 83 && bytes[6] == 68 && bytes[7] == 67) {
    console.debug("Binary USD detected");
    return "usd";
  } else if (bytes[0] == 35 && bytes[1] == 117 && bytes[2] == 115 && bytes[3] == 100 && bytes[4] == 97) {
    console.debug("ASCII USD detected");
    return "usda";
  }
  if (bytes[0] == 75 && bytes[1] == 97 && bytes[2] == 121 && bytes[3] == 100 && bytes[4] == 97 && bytes[5] == 114 && bytes[6] == 97 && bytes[7] == 32) {
    console.debug("Binary FBX detected");
    return "fbx";
  } else if (bytes[0] == 59 && bytes[1] == 32 && bytes[2] == 70 && bytes[3] == 66 && bytes[4] == 88 && bytes[5] == 32) {
    console.debug("ASCII FBX detected");
    return "fbx";
  } else if (bytes[0] == 35 && bytes[1] == 32 && bytes[2] == 66 && bytes[3] == 108 && bytes[4] == 101 && bytes[5] == 110 && bytes[6] == 100 && bytes[7] == 101 && bytes[8] == 114 && bytes[9] == 32) {
    console.debug("OBJ detected");
    return "obj";
  } else if (bytes[0] == 35 && bytes[1] == 32 && bytes[2] == 65 && bytes[3] == 108 && bytes[4] == 105 && bytes[5] == 97 && bytes[6] == 115 && bytes[7] == 32 && bytes[8] == 79 && bytes[9] == 66 && bytes[10] == 74) {
    console.debug("OBJ detected");
    return "obj";
  } else if (response.headers.has("content-type")) {
    const content_type = response.headers.get("content-type");
    console.debug("Content-Type: " + content_type);
    switch (content_type) {
      case "model/gltf+json":
        return "gltf";
      case "model/gltf-binary":
        return "glb";
      case "model/vrm":
        return "vrm";
      case "model/vnd.usdz+zip":
        return "usdz";
      case "model/vnd.usd+zip":
        return "usd";
      case "model/vnd.usda+zip":
        return "usda";
      case "model/fbx":
        return "fbx";
      case "model/obj":
        return "obj";
      case "text/plain":
        break;
    }
  }
  if (bytes[0] == 118 && bytes[1] == 32 || bytes[0] == 102 && bytes[1] == 32) {
    console.debug("OBJ detected (the file has no header and starts with vertex or face)");
    return "obj";
  } else if (bytes[0] == 35 && bytes[1] == 32 && bytes[2] == 70 && bytes[3] == 105 && bytes[4] == 108 && bytes[5] == 101 && bytes[6] == 32 && bytes[7] == 101 && bytes[8] == 120 && bytes[9] == 112 && bytes[10] == 111 && bytes[11] == 114 && bytes[12] == 116 && bytes[13] == 101 && bytes[14] == 100 && bytes[15] == 32 && bytes[16] == 98 && bytes[17] == 121 && bytes[18] == 32 && bytes[19] == 90 && bytes[20] == 66 && bytes[21] == 114 && bytes[22] == 117 && bytes[23] == 115 && bytes[24] == 104) {
    console.debug("OBJ detected (exported by ZBrush)");
    return "obj";
  } else if (bytes[0] == 109 && bytes[1] == 116 && bytes[2] == 108 && bytes[3] == 108 && bytes[4] == 105 && bytes[5] == 98) {
    console.debug("OBJ detected (mtllib)");
    return "obj";
  }
  if (isDevEnvironment() || debug113) {
    const text = new TextDecoder().decode(data.slice(0, 16));
    console.debug('Could not determine file type from binary data: "' + text + '..."', bytes);
  } else {
    console.debug("Could not determine file type from binary data", bytes);
  }
  return "unknown";
}

// node_modules/@needle-tools/engine/lib/engine/engine_scenetools.js
var NeedleLoader = class {
  createBuiltinComponents(context, gltfId, gltf, seed, extension) {
    return createBuiltinComponents(context, gltfId, gltf, seed, extension);
  }
  writeBuiltinComponentData(comp, context) {
    return writeBuiltinComponentData(comp, context);
  }
  parseSync(context, data, path, seed) {
    return parseSync(context, data, path, seed);
  }
  loadSync(context, url, sourceId, seed, prog) {
    return loadSync(context, url, sourceId, seed, prog);
  }
};
registerLoader(NeedleLoader);
var printGltf = getParam("printGltf") || getParam("printgltf");
var downloadGltf = getParam("downloadgltf");
var debugFileTypes = getParam("debugfileformat");
var GltfLoadEventType;
(function(GltfLoadEventType2) {
  GltfLoadEventType2[GltfLoadEventType2["BeforeLoad"] = 0] = "BeforeLoad";
  GltfLoadEventType2[GltfLoadEventType2["AfterLoaded"] = 1] = "AfterLoaded";
  GltfLoadEventType2[GltfLoadEventType2["FinishedSetup"] = 10] = "FinishedSetup";
})(GltfLoadEventType || (GltfLoadEventType = {}));
var GltfLoadEvent = class {
  constructor(context, path, loader2, gltf) {
    __publicField(this, "context");
    __publicField(this, "loader");
    __publicField(this, "path");
    __publicField(this, "gltf");
    this.context = context;
    this.path = path;
    this.loader = loader2;
    this.gltf = gltf;
  }
};
var eventListeners = {};
function addGltfLoadEventListener(type, listener) {
  eventListeners[type] = eventListeners[type] || [];
  eventListeners[type].push(listener);
}
function removeGltfLoadEventListener(type, listener) {
  if (eventListeners[type]) {
    const index = eventListeners[type].indexOf(listener);
    if (index >= 0) {
      eventListeners[type].splice(index, 1);
    }
  }
}
function invokeEvents(type, event) {
  if (eventListeners[type]) {
    for (const listener of eventListeners[type]) {
      listener(event);
    }
  }
}
async function handleLoadedGltf(context, gltfId, gltf, seed, componentsExtension) {
  if (printGltf)
    console.warn("glTF", gltfId, gltf);
  if (gltfId.includes("?")) {
    gltfId = gltfId.split("?")[0];
  }
  await getLoader().createBuiltinComponents(context, gltfId, gltf, seed, componentsExtension);
}
async function createLoader(url, context) {
  const type = await tryDetermineFileTypeFromURL(url) || "unknown";
  if (debugFileTypes)
    console.debug("Determined file type: " + type + " for url", url);
  switch (type) {
    case "unknown": {
      console.warn("Unknown file type. Assuming glTF:", url);
      const loader2 = new GLTFLoader();
      await registerExtensions(loader2, context, url);
      return loader2;
    }
    case "fbx":
      return new FBXLoader();
    case "obj":
      return new OBJLoader();
    case "usd":
    case "usda":
    case "usdz":
      console.warn(type.toUpperCase() + " files are not supported.");
      return null;
    default:
      console.warn("Unknown file type:", type);
    case "gltf":
    case "glb":
    case "vrm": {
      const loader2 = new GLTFLoader();
      await registerExtensions(loader2, context, url);
      return loader2;
    }
  }
}
async function parseSync(context, data, path, seed) {
  if (typeof path !== "string") {
    console.warn("Parse gltf binary without path, this might lead to errors in resolving extensions. Please provide the source path of the gltf/glb file", path, typeof path);
    path = "";
  }
  if (printGltf)
    console.log("Parse glTF", path);
  const loader2 = await createLoader(path, context);
  if (!loader2) {
    return void 0;
  }
  if (loader2 instanceof OBJLoader) {
    if (typeof data !== "string") {
      data = new TextDecoder().decode(data);
    }
    const res = loader2.parse(data);
    return {
      animations: res.animations,
      scene: res,
      scenes: [res]
    };
  }
  const isNotGLTF = !(loader2 instanceof GLTFLoader);
  if (isNotGLTF) {
    const res = loader2.parse(data, path);
    postprocessLoadedFile(loader2, res);
    return {
      animations: res.animations,
      scene: res,
      scenes: [res]
    };
  }
  const componentsExtension = registerComponentExtension(loader2);
  return new Promise((resolve2, reject) => {
    try {
      let gltfLoaderPath = path.split("?")[0].trimEnd();
      if (gltfLoaderPath.endsWith(".glb") || gltfLoaderPath.endsWith(".gltf")) {
        const parts = gltfLoaderPath.split("/");
        parts.pop();
        gltfLoaderPath = parts.join("/");
        if (!gltfLoaderPath.endsWith("/"))
          gltfLoaderPath += "/";
      }
      loader2.resourcePath = gltfLoaderPath;
      addDracoAndKTX2Loaders2(loader2, context);
      invokeEvents(GltfLoadEventType.BeforeLoad, new GltfLoadEvent(context, path, loader2));
      const camera = context.mainCamera;
      loader2.parse(data, "", async (res) => {
        invokeAfterImportPluginHooks(path, res, context);
        invokeEvents(GltfLoadEventType.AfterLoaded, new GltfLoadEvent(context, path, loader2, res));
        await handleLoadedGltf(context, path, res, seed, componentsExtension);
        await compileAsync(res.scene, context, camera);
        invokeEvents(GltfLoadEventType.FinishedSetup, new GltfLoadEvent(context, path, loader2, res));
        resolve2(res);
        if (downloadGltf) {
          _downloadGltf(data);
        }
      }, (err) => {
        console.error('Loading asset at "' + path + '" failed\n', err);
        resolve2(void 0);
      });
    } catch (err) {
      console.error(err);
      reject(err);
    }
  });
}
async function loadSync(context, url, sourceId, seed, prog) {
  checkIfUserAttemptedToLoadALocalFile(url);
  const loader2 = await createLoader(url, context);
  if (!loader2) {
    return void 0;
  }
  if (!(loader2 instanceof GLTFLoader)) {
    const res = await loader2.loadAsync(url, prog);
    postprocessLoadedFile(loader2, res);
    return {
      animations: res.animations,
      scene: res,
      scenes: [res]
    };
  }
  const componentsExtension = registerComponentExtension(loader2);
  return new Promise((resolve2, reject) => {
    try {
      addDracoAndKTX2Loaders2(loader2, context);
      invokeEvents(GltfLoadEventType.BeforeLoad, new GltfLoadEvent(context, url, loader2));
      const camera = context.mainCamera;
      loader2.load(url, async (res) => {
        invokeAfterImportPluginHooks(url, res, context);
        invokeEvents(GltfLoadEventType.AfterLoaded, new GltfLoadEvent(context, url, loader2, res));
        await handleLoadedGltf(context, sourceId, res, seed, componentsExtension);
        await compileAsync(res.scene, context, camera);
        invokeEvents(GltfLoadEventType.FinishedSetup, new GltfLoadEvent(context, url, loader2, res));
        resolve2(res);
        if (downloadGltf) {
          _downloadGltf(url);
        }
      }, (evt) => {
        prog == null ? void 0 : prog.call(loader2, evt);
      }, (err) => {
        console.error('Loading asset at "' + url + '" failed\n', err);
        resolve2(void 0);
      });
    } catch (err) {
      console.error(err);
      reject(err);
    }
  });
}
async function compileAsync(scene, context, camera) {
  if (!camera)
    camera = context.mainCamera;
  try {
    if (camera) {
      await context.renderer.compileAsync(scene, camera, context.scene).catch((err) => {
        console.warn(err.message);
      });
    } else
      registerPrewarmObject(scene, context);
  } catch (err) {
    console.warn((err == null ? void 0 : err.message) || err);
  }
}
function checkIfUserAttemptedToLoadALocalFile(url) {
  const fullurl = new URL(url, window.location.href).href;
  if (fullurl.startsWith("file://")) {
    const msg = 'Hi - it looks like you are trying to load a local file which will not work. You need to use a webserver to serve your files.\nPlease refer to the documentation on <a href="https://fwd.needle.tools/needle-engine/docs/local-server">https://docs.needle.tools</a> or ask for help in our <a href="https://discord.needle.tools">discord community</a>';
    showBalloonMessage(msg);
    console.warn(msg);
  }
}
function _downloadGltf(data) {
  if (typeof data === "string") {
    const a = document.createElement("a");
    a.href = data;
    a.download = data.split("/").pop();
    a.click();
  } else {
    const blob = new Blob([data], { type: "application/octet-stream" });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "download.glb";
    a.click();
  }
}
function postprocessLoadedFile(loader2, result) {
  if (result == null ? void 0 : result.isObject3D) {
    const obj = result;
    if (loader2 instanceof FBXLoader || loader2 instanceof OBJLoader) {
      obj.traverse((child) => {
        const mesh = child;
        if (mesh == null ? void 0 : mesh.isMesh) {
          postprocessFBXMaterials(mesh, mesh.material);
        }
      });
    }
  }
}

// node_modules/@needle-tools/engine/lib/engine/engine_element.js
registerLoader(NeedleLoader);
var debug114 = getParam("debugwebcomponent");
var htmlTagName = "needle-engine";
var vrContainerClassName = "vr";
var desktopContainerClassname = "desktop";
var knownClasses = [arContainerClassName, vrContainerClassName, desktopContainerClassname];
var arSessionActiveClassName = "ar-session-active";
var desktopSessionActiveClassName = "desktop-session-active";
var observedAttributes = [
  "public-key",
  "version",
  "hash",
  "src",
  "camera-controls",
  "loadstart",
  "progress",
  "loadfinished",
  "dracoDecoderPath",
  "dracoDecoderType",
  "ktx2DecoderPath",
  "tone-mapping",
  "tone-mapping-exposure",
  "background-blurriness",
  "background-color"
];
var NeedleEngineHTMLElement = class extends HTMLElement {
  constructor() {
    super();
    __publicField(this, "_context");
    __publicField(this, "_overlay_ar");
    __publicField(this, "_loadingProgress01", 0);
    __publicField(this, "_loadingView");
    __publicField(this, "_previousSrc", null);
    /** set to true after <needle-engine> did load completely at least once. Set to false when <needle-engine> is removed from the document */
    __publicField(this, "_didFullyLoad", false);
    __publicField(this, "_loadId", 0);
    __publicField(this, "_abortController", null);
    __publicField(this, "_lastSourceFiles", null);
    __publicField(this, "_createContextPromise", null);
    __publicField(this, "onXRSessionStarted", () => {
      var _a2;
      const xrSessionMode = this.context.xrSessionMode;
      if (xrSessionMode === "immersive-ar")
        this.onEnterAR(this.context.xrSession);
      else if (xrSessionMode === "immersive-vr")
        this.onEnterVR(this.context.xrSession);
      (_a2 = this.context.xrSession) == null ? void 0 : _a2.addEventListener("end", () => {
        this.dispatchEvent(new CustomEvent("xr-session-ended", { detail: { session: this.context.xrSession, context: this._context, sessionMode: xrSessionMode } }));
        if (xrSessionMode === "immersive-ar")
          this.onExitAR(this.context.xrSession);
        else if (xrSessionMode === "immersive-vr")
          this.onExitVR(this.context.xrSession);
      });
    });
    /** called by the context when the first frame has been rendered */
    __publicField(this, "onReady", () => {
      var _a2;
      return (_a2 = this._loadingView) == null ? void 0 : _a2.onLoadingFinished();
    });
    __publicField(this, "onError", () => {
      var _a2;
      return (_a2 = this._loadingView) == null ? void 0 : _a2.setMessage("Loading failed!");
    });
    __publicField(this, "_previouslyRegisteredMap", /* @__PURE__ */ new Map());
    this._overlay_ar = new AROverlayHandler();
    this.addEventListener("ready", this.onReady);
    ensureFonts();
    this.attachShadow({ mode: "open" });
    const template = document.createElement("template");
    template.innerHTML = `<style>
    @import url('https://fonts.googleapis.com/css2?family=Roboto+Flex:opsz,wght@8..144,100..1000&display=swap');

    :host {
        position: absolute;
        display: block;
        width: max(600px, 100%);
        height: max(300px, 100%);
        touch-action: none;

        -webkit-tap-highlight-color: transparent;
    }

    @media (max-width: 600px) {
        :host {
            width: 100%;
        }
    }
    @media (max-height: 300px) {
        :host {
            height: 100%;
        }
    }

    :host > div.canvas-wrapper {
        width: 100%;
        height: 100%;
    }

    :host canvas {   
        position: absolute;
        user-select: none;
        -webkit-user-select: none;

        /** allow touch panning but no pinch zoom **/
        /** but this doesnt work yet: 
         * touch-action: pan-x, pan-y;
         **/
        
        -webkit-touch-callout: none;
        -webkit-user-drag: none;
        -webkit-user-modify: none;
    }
    :host .content {
        position: absolute;
        top: 0;
        width: 100%;
        height: 100%;
        visibility: visible;
        z-index: 500; /* < must be less than the webxr buttons element */
        pointer-events: none;
    }
    :host .overlay-content {
        position: absolute;
        user-select: auto;
        pointer-events: all;
    }
    :host slot[name="quit-ar"]:hover {
        cursor: pointer;
    }
    :host .quit-ar-button {
        position: absolute;
        // top: env(titlebar-area-y); /** this doesnt work **/
        top: 60px; /** camera access needs a bit more space **/
        right: 20px;
        z-index: 9999;
    }
</style>
<div class="canvas-wrapper"> <!-- this wrapper is necessary for WebXR https://github.com/meta-quest/immersive-web-emulator/issues/55 -->
    <canvas></canvas>
</div>
<div class="content">
    <slot class="overlay-content"></slot>
</div>
`;
    if (this.shadowRoot)
      this.shadowRoot.appendChild(template.content.cloneNode(true));
    this._context = new Context({ domElement: this });
    this.addEventListener("error", this.onError);
  }
  static get observedAttributes() {
    return observedAttributes;
  }
  get loadingProgress01() {
    return this._loadingProgress01;
  }
  get loadingFinished() {
    return this.loadingProgress01 > 0.999;
  }
  /**
   * If set to false the camera controls are disabled. Default is true.
   * @type {boolean | null}
   * @memberof NeedleEngineAttributes
   * @example
   * <needle-engine camera-controls="false"></needle-engine>
   * @example
   * <needle-engine camera-controls="true"></needle-engine>
   * @example
   * <needle-engine camera-controls></needle-engine>
   * @example
   * <needle-engine></needle-engine>
   * @returns {boolean | null} if the attribute is not set it returns null
   */
  get cameraControls() {
    const attr = this.getAttribute("camera-controls");
    if (attr == null)
      return null;
    if (attr === null || attr === "False" || attr === "false" || attr === "0" || attr === "none")
      return false;
    return true;
  }
  /**
   * Get the current context for this web component instance. The context is created when the src attribute is set and the loading has finished.
   * The context is disposed when the needle engine is removed from the document (you can prevent this by setting the keep-alive attribute to true).
   * @returns {Promise<Context>} a promise that resolves to the context when the loading has finished
   */
  getContext() {
    return new Promise((res, _rej) => {
      if (this._context && this.loadingFinished) {
        res(this._context);
      } else {
        const cb = () => {
          this.removeEventListener("loadfinished", cb);
          if (this._context && this.loadingFinished) {
            res(this._context);
          }
        };
        this.addEventListener("loadfinished", cb);
      }
    });
  }
  /**
   * Get the context that is created when the src attribute is set and the loading has finished.
   */
  get context() {
    return this._context;
  }
  /**
   * @internal
   */
  async connectedCallback() {
    if (debug114) {
      console.log("<needle-engine> connected");
    }
    this.setPublicKey();
    this.setVersion();
    this.addEventListener("xr-session-started", this.onXRSessionStarted);
    this.onSetupDesktop();
    if (!this.getAttribute("src")) {
      const global2 = globalThis["needle:codegen_files"];
      if (debug114)
        console.log('src is null, trying to load from globalThis["needle:codegen_files"]', global2);
      if (global2) {
        if (debug114)
          console.log('globalThis["needle:codegen_files"]', global2);
        this.setAttribute("src", global2);
      }
    }
    if (debug114)
      console.log("src", this.getAttribute("src"));
    const loadId = this._loadId;
    setTimeout(() => {
      if (this.isConnected === false)
        return;
      if (loadId !== this._loadId)
        return;
      this.onLoad();
    }, 1);
  }
  /**
   * @internal
   */
  disconnectedCallback() {
    var _a2;
    this.removeEventListener("xr-session-started", this.onXRSessionStarted);
    this._didFullyLoad = false;
    const keepAlive = this.getAttribute("keep-alive");
    const dispose = keepAlive == void 0 || (keepAlive == null ? void 0 : keepAlive.length) > 0 && keepAlive !== "true" && keepAlive !== "1";
    if (debug114)
      console.warn('<needle-engine> disconnected, keep-alive: "' + keepAlive + '"', typeof keepAlive, "Dispose=", dispose);
    if (dispose) {
      if (debug114)
        console.warn("<needle-engine> dispose");
      (_a2 = this._context) == null ? void 0 : _a2.dispose();
      this._context = null;
      this._lastSourceFiles = null;
      this._loadId += 1;
    } else {
      if (debug114)
        console.warn("<needle-engine> is not disposed because keep-alive is set");
    }
  }
  /**
   * @internal
   */
  attributeChangedCallback(name, oldValue, newValue) {
    if (debug114)
      console.log("attributeChangedCallback", name, oldValue, newValue);
    switch (name) {
      case "src":
        if (debug114)
          console.warn('<needle-engine src>\nchanged from "', oldValue, '" to "', newValue, '"');
        this.onLoad();
        break;
      case "hash":
        if (this._context) {
          this._context.hash = newValue;
        }
        break;
      case "loadstart":
      case "progress":
      case "loadfinished":
        if (typeof newValue === "string" && newValue.length > 0) {
          if (debug114)
            console.log(name + " attribute changed", newValue);
          this.registerEventFromAttribute(name, newValue);
        }
        break;
      case "dracoDecoderPath":
        if (debug114)
          console.log("dracoDecoderPath", newValue);
        setDracoDecoderPath(newValue);
        break;
      case "dracoDecoderType":
        if (newValue === "wasm" || newValue === "js") {
          if (debug114)
            console.log("dracoDecoderType", newValue);
          setDracoDecoderType(newValue);
        } else
          console.error("Invalid dracoDecoderType", newValue, "expected js or wasm");
        break;
      case "ktx2DecoderPath":
        if (debug114)
          console.log("ktx2DecoderPath", newValue);
        setKtx2TranscoderPath(newValue);
        break;
      case "tone-mapping": {
        this.applyAttributes();
        break;
      }
      case "tone-mapping-exposure": {
        this.applyAttributes();
        break;
      }
      case "background-blurriness": {
        const value = parseFloat(newValue);
        if (value != void 0 && this._context) {
          this._context.scene.backgroundBlurriness = value;
        }
        break;
      }
      case "background-color": {
        this.applyAttributes();
        break;
      }
      case "public-key": {
        if (newValue != PUBLIC_KEY)
          this.setPublicKey();
        break;
      }
      case "version": {
        if (newValue != VERSION)
          this.setVersion();
        break;
      }
    }
  }
  async onLoad() {
    var _a2, _b;
    if (!this.isConnected)
      return;
    if (!this._context) {
      if (debug114)
        console.warn("Create new context");
      this._context = new Context({ domElement: this });
    }
    if (!this._context) {
      console.error("Needle Engine: Context not initialized");
      return;
    }
    const filesToLoad = this.getSourceFiles();
    if (!this.checkIfSourceHasChanged(filesToLoad, this._lastSourceFiles)) {
      return;
    }
    if (this._abortController) {
      if (debug114)
        console.warn("Abort previous loading process");
      this._abortController.abort();
      this._abortController = null;
    }
    this._lastSourceFiles = filesToLoad;
    const loadId = ++this._loadId;
    if (filesToLoad === null || filesToLoad === void 0 || filesToLoad.length <= 0) {
      if (debug114)
        console.warn("Clear scene", filesToLoad);
      this._context.clear();
      if (loadId !== this._loadId)
        return;
    }
    const alias = this.getAttribute("alias");
    this.classList.add("loading");
    const allowOverridingDefaultLoading = hasCommercialLicense();
    this.ensureLoadStartIsRegistered();
    let useDefaultLoading = this.dispatchEvent(new CustomEvent("loadstart", {
      detail: {
        context: this._context,
        alias
      },
      cancelable: true
    }));
    if (allowOverridingDefaultLoading) {
      const hideOverlay = this.getAttribute("hide-loading-overlay");
      if (hideOverlay !== null && hideOverlay !== void 0 && hideOverlay !== "0") {
        useDefaultLoading = false;
      }
    }
    if (useDefaultLoading === false && !allowOverridingDefaultLoading) {
      if (!isDevEnvironment())
        useDefaultLoading = true;
      console.warn("Needle Engine: You need a commercial license to override the default loading view. Visit https://needle.tools/pricing");
      if (isDevEnvironment())
        showBalloonWarning('You need a <a target="_blank" href="https://needle.tools/pricing">commercial license</a> to override the default loading view. This will not work in production.');
    }
    if (!this._loadingView && useDefaultLoading)
      this._loadingView = new EngineLoadingView(this);
    if (useDefaultLoading) {
      if (this._didFullyLoad !== true)
        (_a2 = this._loadingView) == null ? void 0 : _a2.onLoadingBegin("begin load");
      else {
        setTimeout(() => {
          if (this._loadingView && this._loadingProgress01 < 0.3 && this._loadId === loadId)
            this._loadingView.onLoadingBegin("begin load");
        }, 300);
      }
    }
    if (debug114)
      console.warn("--------------\nNeedle Engine: Begin loading " + loadId + "\n", filesToLoad);
    this.onBeforeBeginLoading();
    const loadedFiles = [];
    const progressEventDetail = {
      context: this._context,
      name: "",
      progress: {},
      index: 0,
      count: filesToLoad.length,
      totalProgress01: this._loadingProgress01
    };
    const progressEvent = new CustomEvent("progress", { detail: progressEventDetail });
    const displayNames = new Array();
    const controller = new AbortController();
    this._abortController = controller;
    const args = {
      files: filesToLoad,
      abortSignal: controller.signal,
      onLoadingProgress: (evt) => {
        var _a3;
        if (controller.signal.aborted)
          return;
        const index = evt.index;
        if (!displayNames[index] && evt.name) {
          displayNames[index] = getDisplayName(evt.name);
        }
        evt.name = displayNames[index];
        if (useDefaultLoading)
          (_a3 = this._loadingView) == null ? void 0 : _a3.onLoadingUpdate(evt);
        progressEventDetail.name = evt.name;
        progressEventDetail.progress = evt.progress;
        this._loadingProgress01 = calculateProgress01(evt);
        progressEventDetail.totalProgress01 = this._loadingProgress01;
        this.dispatchEvent(progressEvent);
      },
      onLoadingFinished: (_index, file, glTF) => {
        if (controller.signal.aborted)
          return;
        if (glTF) {
          loadedFiles.push({
            src: file,
            file: glTF
          });
        }
      }
    };
    const currentHash = this.getAttribute("hash");
    if (currentHash !== null && currentHash !== void 0)
      this._context.hash = currentHash;
    this._context.alias = alias;
    this._createContextPromise = this._context.create(args);
    const success = await this._createContextPromise;
    this.applyAttributes();
    if (debug114)
      console.warn("--------------\nNeedle Engine: finished loading " + loadId + "\n", filesToLoad, `Aborted? ${controller.signal.aborted}`);
    if (controller.signal.aborted) {
      console.log("Loading finished but aborted...");
      return;
    }
    if (this._loadId !== loadId) {
      console.log("Load id changed during loading process");
      return;
    }
    this._loadingProgress01 = 1;
    if (useDefaultLoading && success) {
      (_b = this._loadingView) == null ? void 0 : _b.onLoadingUpdate(1, "creating scene");
    }
    this._didFullyLoad = true;
    this.classList.remove("loading");
    this.classList.add("loading-finished");
    this.dispatchEvent(new CustomEvent("loadfinished", {
      detail: {
        context: this._context,
        src: alias,
        loadedFiles
      }
    }));
  }
  applyAttributes() {
    if (this._context.renderer) {
      const attribute = this.getAttribute("tonemapping") || this.getAttribute("tone-mapping");
      switch (attribute == null ? void 0 : attribute.toLowerCase()) {
        case "none":
          this._context.renderer.toneMapping = NoToneMapping;
          break;
        case "linear":
          this._context.renderer.toneMapping = LinearToneMapping;
          break;
        case "neutral":
          this._context.renderer.toneMapping = NeutralToneMapping;
          break;
        case "agx":
          this._context.renderer.toneMapping = AgXToneMapping;
          break;
        default:
          if (attribute !== null && attribute !== void 0) {
            console.warn("Invalid tone-mapping attribute: " + attribute);
          }
      }
      const exposure = this.getAttribute("tone-mapping-exposure");
      if (exposure !== null && exposure !== void 0) {
        const value = parseFloat(exposure);
        if (!isNaN(value))
          this._context.renderer.toneMappingExposure = value;
      }
    }
    const backgroundBlurriness = this.getAttribute("background-blurriness");
    if (backgroundBlurriness !== null && backgroundBlurriness !== void 0) {
      const value = parseFloat(backgroundBlurriness);
      if (value !== void 0 && this._context) {
        this._context.scene.backgroundBlurriness = value;
      }
    }
    const backgroundColor = this.getAttribute("background-color");
    if (this._context) {
      if (typeof backgroundColor === "string" && backgroundColor.length > 0) {
        const currentBackground = this._context.scene.background;
        if (currentBackground instanceof Color) {
          currentBackground.set(backgroundColor);
        } else {
          this._context.scene.background = new Color(backgroundColor);
        }
      }
    }
  }
  internalSetLoadingMessage(str) {
    var _a2;
    (_a2 = this._loadingView) == null ? void 0 : _a2.setMessage(str);
  }
  getSourceFiles() {
    const src = this.getAttribute("src");
    if (!src)
      return [];
    let filesToLoad;
    if (Array.isArray(src)) {
      filesToLoad = src;
    } else if (src.startsWith("[") && src.endsWith("]")) {
      filesToLoad = JSON.parse(src);
    } else if (src.includes(",")) {
      filesToLoad = src.split(",");
    } else
      filesToLoad = [src];
    for (let i = filesToLoad.length - 1; i >= 0; i--) {
      const file = filesToLoad[i];
      if (file === "null" || file === "undefined" || (file == null ? void 0 : file.length) <= 0)
        filesToLoad.splice(i, 1);
    }
    return filesToLoad;
  }
  checkIfSourceHasChanged(current, previous) {
    if ((current == null ? void 0 : current.length) !== (previous == null ? void 0 : previous.length))
      return true;
    if (current == null && previous !== null)
      return true;
    if (current !== null && previous == null)
      return true;
    if (current !== null && previous !== null) {
      for (let i = 0; i < (current == null ? void 0 : current.length); i++) {
        if (current[i] !== previous[i])
          return true;
      }
    }
    return false;
  }
  ensureLoadStartIsRegistered() {
    const attributeValue = this.getAttribute("loadstart");
    if (attributeValue)
      this.registerEventFromAttribute("loadstart", attributeValue);
  }
  registerEventFromAttribute(eventName, code) {
    const prev = this._previouslyRegisteredMap.get(eventName);
    if (prev) {
      this._previouslyRegisteredMap.delete(eventName);
      this.removeEventListener(eventName, prev);
    }
    if (typeof code === "string" && code.length > 0) {
      try {
        const fn2 = (0, eval)(code);
        if (typeof fn2 === "function") {
          this._previouslyRegisteredMap.set(eventName, fn2);
          this.addEventListener(eventName, (evt) => fn2 == null ? void 0 : fn2.call(globalThis, this._context, evt));
        }
      } catch (err) {
        console.error("Error registering event " + eventName + '="' + code + '" failed with the following error:\n', err);
      }
    }
  }
  setPublicKey() {
    if (PUBLIC_KEY && PUBLIC_KEY.length > 0)
      this.setAttribute("public-key", PUBLIC_KEY);
  }
  setVersion() {
    if (VERSION && VERSION.length > 0) {
      this.setAttribute("version", VERSION);
    }
  }
  /**
   * @internal
   */
  getAROverlayContainer() {
    return this._overlay_ar.createOverlayContainer(this);
  }
  /**
   * @internal
   */
  getVROverlayContainer() {
    for (let i = 0; i < this.children.length; i++) {
      const ch = this.children[i];
      if (ch.classList.contains("vr"))
        return ch;
    }
    return null;
  }
  /**
   * @internal
   */
  onEnterAR(session) {
    var _a2;
    this.onSetupAR();
    const overlayContainer = this.getAROverlayContainer();
    this._overlay_ar.onBegin(this._context, overlayContainer, session);
    this.dispatchEvent(new CustomEvent("enter-ar", { detail: { session, context: this._context, htmlContainer: (_a2 = this._overlay_ar) == null ? void 0 : _a2.ARContainer } }));
  }
  /**
   * @internal
   */
  onExitAR(session) {
    var _a2;
    this._overlay_ar.onEnd(this._context);
    this.onSetupDesktop();
    this.dispatchEvent(new CustomEvent("exit-ar", { detail: { session, context: this._context, htmlContainer: (_a2 = this._overlay_ar) == null ? void 0 : _a2.ARContainer } }));
  }
  /**
   * @internal
   */
  onEnterVR(session) {
    this.onSetupVR();
    this.dispatchEvent(new CustomEvent("enter-vr", { detail: { session, context: this._context } }));
  }
  /**
   * @internal
   */
  onExitVR(session) {
    this.onSetupDesktop();
    this.dispatchEvent(new CustomEvent("exit-vr", { detail: { session, context: this._context } }));
  }
  onSetupAR() {
    this.classList.add(arSessionActiveClassName);
    this.classList.remove(desktopSessionActiveClassName);
    const arContainer = this.getAROverlayContainer();
    if (debug114)
      console.warn("onSetupAR:", arContainer);
    if (arContainer) {
      arContainer.classList.add(arSessionActiveClassName);
      arContainer.classList.remove(desktopSessionActiveClassName);
    }
    this.foreachHtmlElement((ch) => this.setupElementsForMode(ch, arContainerClassName));
  }
  onSetupVR() {
    this.classList.remove(arSessionActiveClassName);
    this.classList.remove(desktopSessionActiveClassName);
    this.foreachHtmlElement((ch) => this.setupElementsForMode(ch, vrContainerClassName));
  }
  onSetupDesktop() {
    this.classList.remove(arSessionActiveClassName);
    this.classList.add(desktopSessionActiveClassName);
    const arContainer = this.getAROverlayContainer();
    if (arContainer) {
      arContainer.classList.remove(arSessionActiveClassName);
      arContainer.classList.add(desktopSessionActiveClassName);
    }
    this.foreachHtmlElement((ch) => this.setupElementsForMode(ch, desktopContainerClassname));
  }
  setupElementsForMode(el, currentSessionType, _session = null) {
    var _a2, _b;
    if (el === ((_b = (_a2 = this._context) == null ? void 0 : _a2.renderer) == null ? void 0 : _b.domElement))
      return;
    if (el.id === "VRButton" || el.id === "ARButton")
      return;
    const classList = el.classList;
    if (classList.contains(currentSessionType)) {
      el.style.visibility = "visible";
      if (el.style.display === "none")
        el.style.display = "block";
    } else {
      for (const known of knownClasses) {
        if (el.classList.contains(known)) {
          el.style.visibility = "hidden";
          el.style.display = "none";
        }
      }
    }
  }
  foreachHtmlElement(cb) {
    for (let i = 0; i < this.children.length; i++) {
      const ch = this.children[i];
      if (ch.style)
        cb(ch);
    }
  }
  onBeforeBeginLoading() {
    const customDracoDecoderPath = this.getAttribute("dracoDecoderPath");
    if (customDracoDecoderPath) {
      if (debug114)
        console.log("using custom draco decoder path", customDracoDecoderPath);
      setDracoDecoderPath(customDracoDecoderPath);
    }
    const customDracoDecoderType = this.getAttribute("dracoDecoderType");
    if (customDracoDecoderType) {
      if (debug114)
        console.log("using custom draco decoder type", customDracoDecoderType);
      setDracoDecoderType(customDracoDecoderType);
    }
    const customKtx2DecoderPath = this.getAttribute("ktx2DecoderPath");
    if (customKtx2DecoderPath) {
      if (debug114)
        console.log("using custom ktx2 decoder path", customKtx2DecoderPath);
      setKtx2TranscoderPath(customKtx2DecoderPath);
    }
  }
};
if (typeof window !== "undefined" && !window.customElements.get(htmlTagName))
  window.customElements.define(htmlTagName, NeedleEngineHTMLElement);
function getDisplayName(str) {
  if (str.startsWith("blob:")) {
    return "blob";
  }
  const parts = str.split("/");
  let name = parts[parts.length - 1];
  const paramsIndex = name.indexOf("?");
  if (paramsIndex > 0)
    name = name.substring(0, paramsIndex);
  const equalSign = name.indexOf("=");
  if (equalSign > 0)
    name = name.substring(equalSign);
  const extension = name.split(".").pop();
  const extensions = ["glb", "gltf", "usdz", "usd", "fbx", "obj", "mtl"];
  const matchedIndex = !extension ? -1 : extensions.indexOf(extension.toLowerCase());
  if (extension && matchedIndex >= 0) {
    name = name.substring(0, name.length - extension.length - 1);
  }
  name = decodeURIComponent(name);
  if (name.length > 3) {
    let displayName = "";
    let lastCharacterWasSpace = false;
    const ignoredCharacters = ["(", ")", "[", "]", "{", "}", ":", ";", ",", ".", "!", "?"];
    for (let i = 0; i < name.length; i++) {
      let c2 = name[i];
      if (c2 === "_" || c2 === "-")
        c2 = " ";
      if (c2 === " " && displayName.length <= 0)
        continue;
      const isIgnored = ignoredCharacters.includes(c2);
      if (isIgnored)
        continue;
      const isFirstCharacter = displayName.length === 0;
      if (isFirstCharacter) {
        c2 = c2.toUpperCase();
      }
      if (lastCharacterWasSpace && c2 === " ") {
        continue;
      }
      if (lastCharacterWasSpace) {
        c2 = c2.toUpperCase();
      }
      lastCharacterWasSpace = false;
      displayName += c2;
      if (c2 === " ") {
        lastCharacterWasSpace = true;
      }
    }
    if (isDevEnvironment() && name !== displayName)
      console.debug('Generated display name: "' + name + '" → "' + displayName + '"');
    return displayName.trim();
  }
  if (isDevEnvironment())
    console.debug("Loading: use default name", name);
  return name;
}

export {
  getLoader,
  registerLoader,
  isLocalNetwork,
  isHostedOnGlitch,
  ContextEvent,
  ContextRegistry,
  nameofFactory,
  nameof,
  isDebugMode,
  CircularBuffer,
  getUrlParams,
  getParam,
  setParam,
  setParamWithoutReload,
  setOrAddParamsToUrl,
  pushState,
  setState,
  makeId,
  randomNumber,
  makeIdFromRandomWords,
  sanitizeString,
  tryFindObject,
  deepClone,
  delay,
  delayForFrames,
  relativePathPrefix,
  getPath,
  resolveUrl,
  Watch,
  watchWrite,
  unwatchWrite,
  DeviceUtilities,
  isDesktop,
  isMobileDevice,
  isIPad,
  isiPad,
  isAndroidDevice,
  isMozillaXR,
  isMacOS,
  isiOS,
  isSafari,
  isQuest,
  microphonePermissionsGranted,
  getIpCloudflare,
  getIp,
  getIpAndLocation,
  addAttributeChangeCallback,
  removeAttributeChangeCallback,
  PromiseErrorResult,
  PromiseAllWithErrors,
  generateQRCode,
  LogType,
  setAllowBalloonMessages,
  setAllowOverlayMessages,
  addLog,
  clearMessages,
  Mathf,
  OneEuroFilter,
  OneEuroFilterXYZ,
  getCameraController,
  setCameraController,
  useForAutoFit,
  setAutoFitEnabled,
  slerp,
  lookAtInverse,
  lookAtObject,
  getTempVector,
  getTempColor,
  getTempQuaternion,
  getWorldPosition,
  setWorldPosition,
  setWorldPositionXYZ,
  getWorldQuaternion,
  setWorldQuaternion,
  setWorldQuaternionXYZW,
  getWorldScale,
  setWorldScale,
  forward,
  getWorldDirection,
  getWorldEuler,
  setWorldEuler,
  getWorldRotation,
  setWorldRotation,
  setWorldRotationXYZ,
  logHierarchy,
  getParentHierarchyPath,
  isAnimationAction,
  Graphics,
  copyTexture,
  textureToCanvas,
  setVisibleInCustomShadowRendering,
  getVisibleInCustomShadowRendering,
  getBoundingBox,
  fitObjectIntoVolume,
  placeOnSurface,
  postprocessFBXMaterials,
  enableSpatialConsole,
  showBalloonMessage,
  showBalloonWarning,
  showBalloonError,
  isDevEnvironment,
  setDevEnvironment,
  showDebugConsole,
  hideDebugConsole,
  VERSION,
  GENERATOR,
  BUILD_TIME,
  PUBLIC_KEY,
  activeInHierarchyFieldName,
  builtinComponentKeyName,
  editorGuidKeyName,
  addPatch,
  removePatch,
  NeedlePatchesKey,
  mergeVertices,
  NEEDLE_progressive,
  onXRSessionStart,
  offXRSessionStart,
  onXRSessionEnd,
  offXRSessionEnd,
  invokeXRSessionStart,
  invokeXRSessionEnd,
  PointerType,
  InputEvents,
  NEPointerEvent,
  NEKeyboardEvent,
  KeyEventArgs,
  InputEventQueue,
  Input,
  NeedleXRController,
  binaryIdentifierCasts,
  registerBinaryType,
  tryCastBinary,
  tryGetGuid,
  getPeerOptions,
  setPeerOptions,
  getPeerjsInstance,
  PeerNetworking,
  SendQueue,
  debugNet,
  debugOwner,
  ConnectionEvents,
  RoomEvents,
  JoinedRoomResponse,
  LeftRoomResponse,
  UserJoinedOrLeftRoomModel,
  OwnershipEvent,
  OwnershipModel,
  NetworkConnection,
  NeedleXRSync,
  PrimitiveType,
  ObjectUtils,
  NeedleXRSession,
  NeedleXRUtils,
  Gizmos,
  RaycastOptions,
  SphereIntersection,
  Physics,
  AssetDatabase,
  setResourceTrackingEnabled,
  isResourceTrackingEnabled,
  setDisposable,
  isDisposed,
  disposeObjectResources,
  __internalNotifyObjectDestroyed,
  findResourceUsers,
  getResourceUserCount,
  ComponentLifecycleEvents,
  InstancingUtil,
  addScriptToArrays,
  removeScriptFromContext,
  InstantiateIdProvider,
  InstantiateEvent,
  syncDestroy,
  sendDestroyed,
  beginListenDestroy,
  HostData,
  NewInstanceModel,
  syncInstantiate,
  generateSeed,
  beginListenInstantiate,
  registerPrefabProvider,
  TypeStore,
  registerType,
  compareAssociation,
  SerializationContext,
  serializeObject,
  deserializeObject,
  applyPrototypeExtensions,
  registerPrototypeExtensions,
  removeComponent,
  getOrAddComponent,
  addNewComponent,
  addComponent,
  destroyComponentInstance,
  getComponent,
  getComponents,
  getComponentInChildren,
  getComponentsInChildren,
  getComponentInParent,
  getComponentsInParent,
  findObjectOfType,
  findObjectsOfType,
  apply,
  RGBAColor,
  HideFlags,
  InstantiateOptions,
  isActiveSelf,
  setActive,
  isActiveInHierarchy,
  markAsInstancedRendered,
  isUsingInstancing,
  findByGuid,
  isDestroyed,
  setDestroyed,
  setDontDestroy,
  destroy,
  foreachComponent,
  foreachComponentEnumerator,
  instantiate,
  BlobStorage,
  Addressables,
  AssetReference,
  ImageReference,
  ImageReferenceSerializer,
  FileReference,
  FileReferenceSerializer,
  AnimationUtils,
  ApplicationEvents,
  Application,
  WaitForSeconds,
  WaitForFrames,
  WaitForPromise,
  ViewDevice,
  PlayerView,
  PlayerViewManager,
  createFlatTexture,
  AmbientMode,
  DefaultReflectionMode,
  RendererData,
  LightData,
  Time,
  getIconElement,
  isIconElement,
  getIconTexture,
  ButtonsFactory,
  loadFont2 as loadFont,
  iconFontUrl,
  build_scene_functions,
  ContextArgs,
  FrameEvent,
  registerComponent,
  Context,
  hasProLicense,
  hasIndieLicense,
  hasCommercialLicense,
  LoadingElementOptions,
  calculateProgress01,
  EngineLoadingView,
  getFormattedDate,
  Progress,
  makeNameSafe,
  USDObject,
  USDDocument,
  USDWriter,
  USDZExporter,
  imageToCanvas,
  BehaviorModel,
  TriggerModel,
  TriggerBuilder,
  GroupActionModel,
  ActionModel,
  ActionBuilder,
  VariantAction,
  ActionCollection,
  serializeable,
  serializable,
  GameObject,
  Component2 as Component,
  Component_exports,
  AlignmentConstraint,
  Animation,
  Keyframe,
  AnimationCurve,
  StateMachineBehaviour,
  AnimatorStateInfo,
  createMotion,
  AnimatorConditionMode,
  AnimatorControllerParameterType,
  AnimatorController,
  Animator,
  RegisteredAnimationInfo,
  TransformData,
  AnimationExtension,
  RenderTexture,
  OrbitControls,
  GroundProjectedEnv,
  LookAtConstraint,
  onInitialized,
  onClear,
  onDestroy,
  onStart,
  onUpdate,
  onBeforeRender,
  onAfterRender,
  PhysicsMaterialCombine,
  CollisionDetectionMode,
  RigidbodyConstraints,
  Axes,
  validate2 as validate,
  prefix,
  Rigidbody,
  SyncedTransform,
  BaseUIComponent,
  UIRootComponent,
  PointerEventData,
  hasPointerEventComponent,
  CallInfo,
  EventListEvent,
  EventList,
  colorSerializer,
  euler,
  objectSerializer,
  componentSerializer,
  eventListSerializer,
  RenderTextureSerializer,
  UriSerializer,
  ObjectRaycaster,
  GraphicRaycaster,
  SpatialGrabRaycaster,
  UIRaycastUtils,
  EventSystem,
  CameraTargetReachedEvent,
  OrbitControls2,
  ClearFlags,
  Camera2 as Camera,
  AudioListener2 as AudioListener,
  AudioSource,
  SignalAsset,
  SignalReceiverEvent,
  SignalReceiver,
  TrackType,
  ClipExtrapolation,
  MarkerType,
  PlayableDirector,
  TrackHandler,
  AnimationTrackHandler,
  AudioTrackHandler,
  SignalTrackHandler,
  ControlTrackHandler,
  VolumeParameter,
  PostProcessingEffect,
  registerCustomEffectType,
  VolumeProfile,
  Antialiasing,
  AudioExtension,
  syncField,
  PlayerSync,
  PlayerStateEvent,
  PlayerState,
  AvatarMarker,
  XRStateFlag,
  XRState,
  XRFlag,
  Avatar,
  Avatar_POI,
  Avatar_Brain_LookAt,
  isComponent,
  $physicsKey,
  ContactPoint,
  Collision,
  SphereOverlapResult,
  NetworkedStreamEvents,
  StreamEndedEvent,
  StreamReceivedEvent,
  CallDirection,
  PeerHandle,
  NetworkedStreams,
  disposeStream,
  Voip,
  Avatar_MouthShapes,
  Avatar_MustacheShake,
  AvatarBlink_Simple,
  AvatarEyeLook_Rotation,
  AvatarModel,
  AvatarLoader,
  AxesHelper2 as AxesHelper,
  BasicIKConstraint,
  BehaviorExtension,
  BloomEffect2 as BloomEffect,
  Collider,
  SphereCollider,
  BoxCollider,
  MeshCollider,
  CapsuleCollider,
  BoxGizmo,
  BoxHelperComponent,
  Outline,
  Size,
  Rect,
  RectTransform,
  Graphic,
  MaskableGraphic,
  Image2 as Image,
  RawImage,
  Button,
  Padding,
  VerticalLayoutGroup,
  HorizontalLayoutGroup,
  GridLayoutGroup,
  Canvas,
  CanvasGroup,
  ChangeTransformOnClick,
  ChangeMaterialOnClick,
  SetActiveOnClick,
  HideOnStart,
  EmphasizeOnClick,
  PlayAudioOnClick,
  PlayAnimationOnClick,
  PreliminaryAction,
  PreliminaryTrigger,
  VisibilityAction,
  TapGestureTrigger,
  CharacterController,
  CharacterControllerInput,
  ChromaticAberration,
  ToneMappingEffect2 as ToneMappingEffect,
  ColorAdjustments,
  ReflectionProbe,
  SceneLightSettings,
  CustomShader,
  addCustomExtensionPlugin,
  removeCustomImportExtensionType,
  registerComponentExtension,
  registerExtensions,
  registerExportExtensions,
  invokeAfterImportPluginHooks,
  InstancingHandler,
  InstanceHandle,
  RendererLightmap,
  FieldWithDefault,
  Renderer,
  MeshRenderer,
  SkinnedMeshRenderer,
  Gradient,
  ParticleSystemShapeType,
  MinMaxCurve,
  MinMaxGradient,
  MainModule,
  ParticleBurst,
  EmissionModule,
  ColorOverLifetimeModule,
  SizeOverLifetimeModule,
  ShapeModule,
  NoiseModule,
  TrailModule,
  VelocityOverLifetimeModule,
  TextureSheetAnimationModule,
  RotationOverLifetimeModule,
  RotationBySpeedModule,
  LimitVelocityOverLifetimeModule,
  InheritVelocityModule,
  SizeBySpeedModule,
  ColorBySpeedModule,
  ContactShadows,
  WebXRButtonFactory,
  Sprite3 as Sprite,
  SpriteSheet,
  SpriteData,
  SpriteRenderer,
  WebARSessionRoot,
  NeedleMenu2 as NeedleMenu,
  XRControllerModel2 as XRControllerModel,
  TeleportTarget,
  XRControllerMovement,
  WebXR,
  PhysicsExtension,
  Text,
  USDZText,
  TextBuilder,
  TextExtension,
  USDZUIExtension,
  CustomBranding,
  USDZExporter2,
  UsageMarker,
  Interactable,
  DeleteBox,
  Deletable,
  DepthOfField,
  DeviceFlag,
  DocumentExtension,
  DragMode,
  DragControls,
  File_Event,
  FileSpawnModel,
  PreviewHelper,
  DropListenerAddedEvent,
  DropListener,
  Duplicatable,
  EffectWrapper,
  EventTrigger,
  FixedJoint,
  HingeJoint,
  FlyControls2 as FlyControls,
  Fog2 as Fog,
  GLTFExporter,
  GLTFMeshGPUInstancingExtension,
  GltfExportBox,
  GltfExport,
  GridHelper2 as GridHelper,
  InputField,
  Light,
  LODModel,
  LODGroup,
  LogStats,
  LookAt,
  NestedGltf,
  Networking,
  OffsetConstraint,
  OpenURL,
  ParticleSystemRenderer,
  ParticleSystemBaseBehaviour,
  ParticleSystem2 as ParticleSystem,
  SubEmitterSystem,
  ParticleSubEmitter,
  PixelationEffect2 as PixelationEffect,
  PlayerColor,
  SharpeningEffect,
  PostProcessingHandler,
  effectsOrder,
  RemoteSkybox,
  SceneSwitcher,
  VideoPlayer,
  ScreenCapture,
  ScreenSpaceAmbientOcclusion,
  ScreenSpaceAmbientOcclusionN8,
  ShadowCatcher,
  SmoothFollow,
  SpatialHtml,
  SpatialTriggerReceiver,
  SpatialTrigger,
  SpectatorCamera,
  SyncedCamera,
  SyncedRoom,
  TestRunner,
  TestSimulateUserData,
  TiltShiftEffect2 as TiltShiftEffect,
  TransformGizmo,
  Vignette,
  Volume,
  screenshot,
  screenshot2,
  saveImage,
  InternalScreenshotUtils,
  WebARCameraBackground,
  WebXRTrackedImage,
  WebXRImageTrackingModel,
  WebXRImageTracking,
  WebXRPlaneTracking,
  XRControllerFollow,
  XRRig,
  __Ignore,
  components_exports,
  tryDetermineFileTypeFromURL,
  tryDetermineFileTypeFromBinary,
  NeedleLoader,
  GltfLoadEventType,
  GltfLoadEvent,
  addGltfLoadEventListener,
  removeGltfLoadEventListener,
  createLoader,
  parseSync,
  loadSync,
  NeedleEngineHTMLElement
};
/*! Bundled license information:

is-buffer/index.js:
  (*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

postprocessing/build/index.js:
  (**
   * postprocessing v6.36.6 build Tue Dec 31 2024
   * https://github.com/pmndrs/postprocessing
   * Copyright 2015-2024 Raoul van Rüschen
   * @license Zlib
   *)
*/
//# sourceMappingURL=chunk-CZCIBHHP.js.map
