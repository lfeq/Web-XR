{
  "version": 3,
  "sources": ["../../websocket-ts/src/backoff/constantbackoff.ts", "../../websocket-ts/src/backoff/exponentialbackoff.ts", "../../websocket-ts/src/backoff/linearbackoff.ts", "../../websocket-ts/src/queue/array_queue.ts", "../../websocket-ts/src/queue/ring_queue.ts", "../../websocket-ts/src/websocket_event.ts", "../../websocket-ts/src/websocket.ts", "../../websocket-ts/src/websocket_builder.ts"],
  "sourcesContent": ["import { Backoff } from \"./backoff\";\n\n/**\n * ConstantBackoff always returns the same backoff-time.\n */\nexport class ConstantBackoff implements Backoff {\n  private readonly backoff: number;\n  private _retries: number = 0;\n\n  /**\n   * Creates a new ConstantBackoff.\n   * @param backoff the backoff-time to return\n   */\n  constructor(backoff: number) {\n    if (!Number.isInteger(backoff) || backoff < 0) {\n      throw new Error(\"Backoff must be a positive integer\");\n    }\n\n    this.backoff = backoff;\n  }\n\n  get retries(): number {\n    return this._retries;\n  }\n\n  get current(): number {\n    return this.backoff;\n  }\n\n  next(): number {\n    this._retries++;\n    return this.backoff;\n  }\n\n  reset(): void {\n    this._retries = 0;\n  }\n}\n", "import { Backoff } from \"./backoff\";\n\n/**\n * ExponentialBackoff increases the backoff-time exponentially.\n * An optional maximum can be provided as an upper bound to the\n * exponent and thus to the returned backoff.\n *\n * The series can be described as ('i' is the current step/retry):\n *    backoff = base * 2^i                | without bound\n *    backoff = base * 2^min(i, expMax)   | with bound\n *\n * Example:\n *\n * 1) Without bound:\n *   base = 1000, expMax = undefined\n *   backoff = 1000 * 2^0 = 1000 // first retry\n *   backoff = 1000 * 2^1 = 2000 // second retry\n *   backoff = 1000 * 2^2 = 4000 // ...doubles with every retry\n *   backoff = 1000 * 2^3 = 8000\n *   backoff = 1000 * 2^4 = 16000\n *   ... // and so on\n *\n * 2) With bound:\n *  base = 1000, expMax = 3\n *  backoff = 1000 * 2^0 = 1000 // first retry\n *  backoff = 1000 * 2^1 = 2000 // second retry\n *  backoff = 1000 * 2^2 = 4000 // third retry\n *  backoff = 1000 * 2^3 = 8000 // maximum reached, don't increase further\n *  backoff = 1000 * 2^3 = 8000\n *  backoff = 1000 * 2^3 = 8000\n *  ... // and so on\n */\nexport class ExponentialBackoff implements Backoff {\n  private readonly base: number;\n  private readonly expMax?: number;\n  private i: number;\n  private _retries: number = 0;\n\n  /**\n   * Creates a new ExponentialBackoff.\n   * @param base the base of the exponentiation\n   * @param expMax the maximum exponent, no bound if undefined\n   */\n  constructor(base: number, expMax?: number) {\n    if (!Number.isInteger(base) || base < 0) {\n      throw new Error(\"Base must be a positive integer or zero\");\n    }\n    if (expMax !== undefined && (!Number.isInteger(expMax) || expMax < 0)) {\n      throw new Error(\"ExpMax must be a undefined, a positive integer or zero\");\n    }\n\n    this.base = base;\n    this.expMax = expMax;\n    this.i = 0;\n  }\n\n  get retries() {\n    return this._retries;\n  }\n\n  get current(): number {\n    return this.base * Math.pow(2, this.i);\n  }\n\n  next(): number {\n    this._retries++;\n    this.i =\n      this.expMax === undefined\n        ? this.i + 1\n        : Math.min(this.i + 1, this.expMax);\n    return this.current;\n  }\n\n  reset(): void {\n    this._retries = 0;\n    this.i = 0;\n  }\n}\n", "import { Backoff } from \"./backoff\";\n\n/**\n * LinearBackoff returns a backoff-time that is incremented by a fixed amount\n * with every step/retry. An optional maximum can be provided as an upper bound\n * to the returned backoff.\n *\n * The series can be described as ('i' is the current step/retry):\n *   backoff = initial + increment * i                | without bound\n *   backoff = initial + increment * min(i, max)      | with bound\n *\n * Example:\n *\n * 1) Without bound:\n *  initial = 1000, increment = 1000\n *  backoff = 1000 + 1000 * 0 = 1000 // first retry\n *  backoff = 1000 + 1000 * 1 = 2000 // second retry\n *  backoff = 1000 + 1000 * 2 = 3000 // ...increases by 'increment' with every retry\n *  backoff = 1000 + 1000 * 3 = 4000\n *  backoff = 1000 + 1000 * 4 = 5000\n *  ... // and so on\n *\n *  2) With bound:\n *  initial = 1000, increment = 1000, max = 5000\n *  backoff = 1000 + 1000 * 0 = 1000 // first retry\n *  backoff = 1000 + 1000 * 1 = 2000 // second retry\n *  backoff = 1000 + 1000 * 2 = 3000 // third retry\n *  backoff = 1000 + 1000 * 3 = 4000 // fourth retry\n *  backoff = 1000 + 1000 * 4 = 5000 // maximum reached, don't increase further\n *  backoff = 1000 + 1000 * 4 = 5000\n *  backoff = 1000 + 1000 * 4 = 5000\n *  ... // and so on\n */\nexport class LinearBackoff implements Backoff {\n  private readonly initial: number;\n  private readonly increment: number;\n  private readonly max?: number;\n  private i: number = 0;\n  private _retries: number = 0;\n\n  /**\n   * Creates a new LinearBackoff.\n   * @param initial the initial backoff-time in milliseconds\n   * @param increment the amount to increment the backoff-time with every step (in milliseconds)\n   * @param max the maximum backoff-time (in milliseconds), no bound if undefined\n   */\n  constructor(initial: number, increment: number, max?: number) {\n    if (initial < 0) {\n      throw new Error(\"Initial must be a positive number or zero\");\n    }\n    if (increment < 0) {\n      throw new Error(\"Increment must be a positive number or zero\");\n    }\n    if (max !== undefined && max < 0) {\n      throw new Error(\"Max must be undefined, a positive number or zero\");\n    }\n    if (max !== undefined && max < initial) {\n      throw new Error(\n        \"Max must be undefined or greater than or equal to initial\",\n      );\n    }\n\n    this.initial = initial;\n    this.increment = increment;\n    this.max = max;\n  }\n\n  get retries() {\n    return this._retries;\n  }\n\n  get current(): number {\n    return this.max === undefined\n      ? this.initial + this.increment * this.i\n      : Math.min(this.initial + this.increment * this.i, this.max);\n  }\n\n  next(): number {\n    this._retries++;\n    this.i++;\n    return this.current;\n  }\n\n  reset(): void {\n    this._retries = 0;\n    this.i = 0;\n  }\n}\n", "import { Queue } from \"./queue\";\n\n/**\n * An array queue is a queue that has an unbounded capacity. Reading from an array queue\n * will return the oldest element and effectively remove it from the queue.\n */\nexport class ArrayQueue<E> implements Queue<E> {\n  private readonly elements: E[];\n\n  constructor() {\n    this.elements = [];\n  }\n\n  add(element: E): void {\n    this.elements.push(element);\n  }\n\n  clear() {\n    this.elements.length = 0;\n  }\n\n  forEach(fn: (element: E) => unknown) {\n    this.elements.forEach(fn);\n  }\n\n  length(): number {\n    return this.elements.length;\n  }\n\n  isEmpty(): boolean {\n    return this.elements.length === 0;\n  }\n\n  peek(): E | undefined {\n    return this.elements[0];\n  }\n\n  read(): E | undefined {\n    return this.elements.shift();\n  }\n}\n", "import { Queue } from \"./queue\";\n\n/**\n * A ring queue is a queue that has a fixed capacity. When the queue is full, the oldest element is\n * removed to make room for the new element. Reading from a ring queue will return the oldest\n * element and effectively remove it from the queue.\n */\nexport class RingQueue<E> implements Queue<E> {\n  private readonly elements: E[];\n  private head: number; // index of the next position to write to\n  private tail: number; // index of the next position to read from\n\n  constructor(capacity: number) {\n    if (!Number.isInteger(capacity) || capacity <= 0) {\n      throw new Error(\"Capacity must be a positive integer\");\n    }\n\n    this.elements = new Array<E>(capacity + 1); // +1 to distinguish between full and empty\n    this.head = 0;\n    this.tail = 0;\n  }\n\n  add(element: E): void {\n    this.elements[this.head] = element;\n    this.head = (this.head + 1) % this.elements.length;\n    if (this.head === this.tail) {\n      this.tail = (this.tail + 1) % this.elements.length;\n    }\n  }\n\n  clear() {\n    this.head = 0;\n    this.tail = 0;\n  }\n\n  forEach(fn: (element: E) => unknown) {\n    for (\n      let i = this.tail;\n      i !== this.head;\n      i = (i + 1) % this.elements.length\n    ) {\n      fn(this.elements[i]);\n    }\n  }\n\n  length(): number {\n    return this.tail === this.head\n      ? 0\n      : this.tail < this.head\n      ? this.head - this.tail\n      : this.elements.length - this.tail + this.head;\n  }\n\n  isEmpty(): boolean {\n    return this.head === this.tail;\n  }\n\n  peek(): E | undefined {\n    return this.isEmpty() ? undefined : this.elements[this.tail];\n  }\n\n  read(): E | undefined {\n    const e = this.peek();\n    if (e !== undefined) {\n      this.tail = (this.tail + 1) % this.elements.length;\n    }\n    return e;\n  }\n}\n", "import { Websocket } from \"./websocket\";\n\n/**\n * Events that can be fired by the websocket.\n */\nexport enum WebsocketEvent {\n  /** Fired when the connection is opened. */\n  open = \"open\",\n\n  /** Fired when the connection is closed. */\n  close = \"close\",\n\n  /** Fired when the connection has been closed because of an error, such as when some data couldn't be sent. */\n  error = \"error\",\n\n  /** Fired when a message is received. */\n  message = \"message\",\n\n  /** Fired when the websocket tries to reconnect after a connection loss. */\n  retry = \"retry\",\n\n  /** Fired when the websocket successfully reconnects after a connection loss. */\n  reconnect = \"reconnect\",\n}\n\n/***\n * Details/properties of a retry-event.\n */\nexport type RetryEventDetail = {\n  /** Number of retries that have been made since the connection was lost. */\n  readonly retries: number;\n\n  /** Time (ms) waited since the last connection-retry. */\n  readonly backoff: number;\n\n  /** Timestamp of when the connection was lost or undefined if the connection has never been established. */\n  readonly lastConnection: Date | undefined;\n};\n\n/**\n * Properties of a reconnect-event.\n */\nexport type ReconnectEventDetail = Omit<RetryEventDetail, \"backoff\">;\n\n/**\n * Maps websocket events to their corresponding event.\n */\nexport type WebsocketEventMap = {\n  [WebsocketEvent.open]: Event;\n  [WebsocketEvent.close]: CloseEvent;\n  [WebsocketEvent.error]: Event;\n  [WebsocketEvent.message]: MessageEvent;\n  [WebsocketEvent.retry]: CustomEvent<RetryEventDetail>;\n  [WebsocketEvent.reconnect]: CustomEvent<ReconnectEventDetail>;\n};\n\n/**\n * Listener for websocket events.\n * */\nexport type WebsocketEventListener<K extends WebsocketEvent> = (\n  instance: Websocket,\n  ev: WebsocketEventMap[K],\n) => unknown;\n\nexport type WebsocketEventListenerParams<K extends WebsocketEvent> = Parameters<\n  WebsocketEventListener<K>\n>;\n\n/**\n * Options for websocket events.\n */\nexport type WebsocketEventListenerOptions = EventListenerOptions &\n  AddEventListenerOptions;\n\n/**\n * Listener for websocket events with options.\n */\nexport type WebsocketEventListenerWithOptions<K extends WebsocketEvent> = {\n  readonly listener: WebsocketEventListener<K>;\n  readonly options?: WebsocketEventListenerOptions;\n};\n\n/**\n * Maps websocket events to their corresponding event-listeners.\n */\nexport type WebsocketEventListeners = {\n  [K in WebsocketEvent]: WebsocketEventListenerWithOptions<K>[];\n};\n", "import { Backoff } from \"./backoff/backoff\";\nimport { WebsocketBuffer } from \"./websocket_buffer\";\nimport {\n  ReconnectEventDetail,\n  RetryEventDetail,\n  WebsocketEvent,\n  WebsocketEventListener,\n  WebsocketEventListenerOptions,\n  WebsocketEventListeners,\n  WebsocketEventListenerWithOptions,\n  WebsocketEventMap,\n} from \"./websocket_event\";\nimport { WebsocketOptions } from \"./websocket_options\";\n\n/**\n * A websocket wrapper that can be configured to reconnect automatically and buffer messages when the websocket is not connected.\n */\nexport class Websocket {\n  private readonly _url: string; // the url to connect to\n  private readonly _protocols?: string | string[]; // the protocols to use\n\n  private _closedByUser: boolean = false; // whether the websocket was closed by the user\n  private _lastConnection?: Date; // timestamp of the last connection\n  private _underlyingWebsocket: WebSocket; // the underlying websocket, e.g. native browser websocket\n  private retryTimeout?: ReturnType<typeof globalThis.setTimeout>; // timeout for the next retry, if any\n\n  private _options: WebsocketOptions &\n    Required<Pick<WebsocketOptions, \"listeners\" | \"retry\">>; // options/config for the websocket\n\n  /**\n   * Creates a new websocket.\n   *\n   * @param url to connect to.\n   * @param protocols optional protocols to use.\n   * @param options optional options to use.\n   */\n  constructor(\n    url: string,\n    protocols?: string | string[],\n    options?: WebsocketOptions,\n  ) {\n    this._url = url;\n    this._protocols = protocols;\n\n    // make a copy of the options to prevent the user from changing them\n    this._options = {\n      buffer: options?.buffer,\n      retry: {\n        maxRetries: options?.retry?.maxRetries,\n        instantReconnect: options?.retry?.instantReconnect,\n        backoff: options?.retry?.backoff,\n      },\n      listeners: {\n        open: [...(options?.listeners?.open ?? [])],\n        close: [...(options?.listeners?.close ?? [])],\n        error: [...(options?.listeners?.error ?? [])],\n        message: [...(options?.listeners?.message ?? [])],\n        retry: [...(options?.listeners?.retry ?? [])],\n        reconnect: [...(options?.listeners?.reconnect ?? [])],\n      },\n    };\n\n    this._underlyingWebsocket = this.tryConnect();\n  }\n\n  /**\n   * Getter for the url.\n   *\n   * @return the url.\n   */\n  get url(): string {\n    return this._url;\n  }\n\n  /**\n   * Getter for the protocols.\n   *\n   * @return the protocols, or undefined if none were provided.\n   */\n  get protocols(): string | string[] | undefined {\n    return this._protocols;\n  }\n\n  /**\n   * Getter for the buffer.\n   *\n   * @return the buffer, or undefined if none was provided.\n   */\n  get buffer(): WebsocketBuffer | undefined {\n    return this._options.buffer;\n  }\n\n  /**\n   * Getter for the maxRetries.\n   *\n   * @return the maxRetries, or undefined if none was provided (no limit).\n   */\n  get maxRetries(): number | undefined {\n    return this._options.retry.maxRetries;\n  }\n\n  /**\n   * Getter for the instantReconnect.\n   *\n   * @return the instantReconnect, or undefined if none was provided.\n   */\n  get instantReconnect(): boolean | undefined {\n    return this._options.retry.instantReconnect;\n  }\n\n  /**\n   * Getter for the backoff.\n   *\n   * @return the backoff, or undefined if none was provided.\n   */\n  get backoff(): Backoff | undefined {\n    return this._options.retry.backoff;\n  }\n\n  /**\n   * Whether the websocket was closed by the user. A websocket is closed by the user if the close().\n   *\n   * @return true if the websocket was closed by the user, false otherwise.\n   */\n  get closedByUser(): boolean {\n    return this._closedByUser;\n  }\n\n  /**\n   * Getter for the last 'open' event, e.g. the last time the websocket was connected.\n   *\n   * @return the last 'open' event, or undefined if the websocket was never connected.\n   */\n  get lastConnection(): Date | undefined {\n    return this._lastConnection;\n  }\n\n  /**\n   * Getter for the underlying websocket. This can be used to access the browser's native websocket directly.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n   * @return the underlying websocket.\n   */\n  get underlyingWebsocket(): WebSocket {\n    return this._underlyingWebsocket;\n  }\n\n  /**\n   * Getter for the readyState of the underlying websocket.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/readyState\n   * @return the readyState of the underlying websocket.\n   */\n  get readyState(): number {\n    return this._underlyingWebsocket.readyState;\n  }\n\n  /**\n   * Getter for the bufferedAmount of the underlying websocket.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/bufferedAmount\n   * @return the bufferedAmount of the underlying websocket.\n   */\n  get bufferedAmount(): number {\n    return this._underlyingWebsocket.bufferedAmount;\n  }\n\n  /**\n   * Getter for the extensions of the underlying websocket.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/extensions\n   * @return the extensions of the underlying websocket.\n   */\n  get extensions(): string {\n    return this._underlyingWebsocket.extensions;\n  }\n\n  /**\n   * Getter for the binaryType of the underlying websocket.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/binaryType\n   * @return the binaryType of the underlying websocket.\n   */\n  get binaryType(): BinaryType {\n    return this._underlyingWebsocket.binaryType;\n  }\n\n  /**\n   * Setter for the binaryType of the underlying websocket.\n   *\n   * @param value to set, 'blob' or 'arraybuffer'.\n   */\n  set binaryType(value: BinaryType) {\n    this._underlyingWebsocket.binaryType = value;\n  }\n\n  /**\n   * Sends data over the websocket.\n   *\n   * If the websocket is not connected and a buffer was provided on creation, the data will be added to the buffer.\n   * If no buffer was provided or the websocket was closed by the user, the data will be dropped.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n   * @param data to send.\n   */\n  public send(data: string | ArrayBufferLike | Blob | ArrayBufferView): void {\n    if (this.closedByUser) return; // no-op if closed by user\n\n    if (\n      this._underlyingWebsocket.readyState === this._underlyingWebsocket.OPEN\n    ) {\n      this._underlyingWebsocket.send(data); // websocket is connected, send data\n    } else if (this.buffer !== undefined) {\n      this.buffer.add(data); // websocket is not connected, add data to buffer\n    }\n  }\n\n  /**\n   * Close the websocket. No connection-retry will be attempted after this.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close\n   * @param code optional close code.\n   * @param reason optional close reason.\n   */\n  public close(code?: number, reason?: string): void {\n    this.cancelScheduledConnectionRetry(); // cancel any scheduled retries\n    this._closedByUser = true; // mark websocket as closed by user\n    this._underlyingWebsocket.close(code, reason); // close underlying websocket with provided code and reason\n  }\n\n  /**\n   * Adds an event listener for the given event-type.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\n   * @param type of the event to add the listener for.\n   * @param listener to add.\n   * @param options to use when adding the listener.\n   */\n  public addEventListener<K extends WebsocketEvent>(\n    type: K,\n    listener: WebsocketEventListener<K>,\n    options?: WebsocketEventListenerOptions,\n  ): void {\n    this._options.listeners[type].push({ listener, options }); // add listener to list of listeners\n  }\n\n  /**\n   * Removes one or more event listener for the given event-type that match the given listener and options.\n   *\n   * @param type of the event to remove the listener for.\n   * @param listener to remove.\n   * @param options that were used when the listener was added.\n   */\n  public removeEventListener<K extends WebsocketEvent>(\n    type: K,\n    listener: WebsocketEventListener<K>,\n    options?: WebsocketEventListenerOptions,\n  ): void {\n    const isListenerNotToBeRemoved = (\n      l: WebsocketEventListenerWithOptions<K>,\n    ) => l.listener !== listener || l.options !== options;\n\n    (this._options.listeners[type] as WebsocketEventListenerWithOptions<K>[]) =\n      this._options.listeners[type].filter(isListenerNotToBeRemoved); // only keep listeners that are not to be removed\n  }\n\n  /**\n   * Creates a new browser-native websocket and connects it to the given URL with the given protocols\n   * and adds all event listeners to the browser-native websocket.\n   *\n   * @return the created browser-native websocket which is also stored in the '_underlyingWebsocket' property.\n   */\n  private tryConnect(): WebSocket {\n    this._underlyingWebsocket = new WebSocket(this.url, this.protocols); // create new browser-native websocket and add all event listeners\n    this._underlyingWebsocket.addEventListener(\n      WebsocketEvent.open,\n      this.handleOpenEvent,\n    );\n    this._underlyingWebsocket.addEventListener(\n      WebsocketEvent.close,\n      this.handleCloseEvent,\n    );\n    this._underlyingWebsocket.addEventListener(\n      WebsocketEvent.error,\n      this.handleErrorEvent,\n    );\n    this._underlyingWebsocket.addEventListener(\n      WebsocketEvent.message,\n      this.handleMessageEvent,\n    );\n\n    return this._underlyingWebsocket;\n  }\n\n  /**\n   * Removes all event listeners from the browser-native websocket and closes it.\n   */\n  private clearWebsocket() {\n    this._underlyingWebsocket.removeEventListener(\n      WebsocketEvent.open,\n      this.handleOpenEvent,\n    );\n    this._underlyingWebsocket.removeEventListener(\n      WebsocketEvent.close,\n      this.handleCloseEvent,\n    );\n    this._underlyingWebsocket.removeEventListener(\n      WebsocketEvent.error,\n      this.handleErrorEvent,\n    );\n    this._underlyingWebsocket.removeEventListener(\n      WebsocketEvent.message,\n      this.handleMessageEvent,\n    );\n    this._underlyingWebsocket.close();\n  }\n\n  /**\n   * Handles the 'open' event of the browser-native websocket.\n   * @param event to handle.\n   */\n  private handleOpenEvent = (event: Event) =>\n    this.handleEvent(WebsocketEvent.open, event);\n\n  /**\n   * Handles the 'error' event of the browser-native websocket.\n   * @param event to handle.\n   */\n  private handleErrorEvent = (event: Event) =>\n    this.handleEvent(WebsocketEvent.error, event);\n\n  /**\n   * Handles the 'close' event of the browser-native websocket.\n   * @param event to handle.\n   */\n  private handleCloseEvent = (event: CloseEvent) =>\n    this.handleEvent(WebsocketEvent.close, event);\n\n  /**\n   * Handles the 'message' event of the browser-native websocket.\n   * @param event to handle.\n   */\n  private handleMessageEvent = (event: MessageEvent) =>\n    this.handleEvent(WebsocketEvent.message, event);\n\n  /**\n   * Dispatch an event to all listeners of the given event-type.\n   *\n   * @param type of the event to dispatch.\n   * @param event to dispatch.\n   */\n  private dispatchEvent<K extends WebsocketEvent>(\n    type: K,\n    event: WebsocketEventMap[K],\n  ) {\n    const eventListeners: WebsocketEventListeners[K] =\n      this._options.listeners[type];\n    const newEventListeners: WebsocketEventListeners[K] = [];\n\n    eventListeners.forEach(({ listener, options }) => {\n      listener(this, event); // invoke listener with event\n\n      if (\n        options === undefined ||\n        options.once === undefined ||\n        !options.once\n      ) {\n        newEventListeners.push({ listener, options }); // only keep listener if it isn't a once-listener\n      }\n    });\n\n    this._options.listeners[type] = newEventListeners; // replace old listeners with new listeners that don't include once-listeners\n  }\n\n  /**\n   * Handles the given event by dispatching it to all listeners of the given event-type.\n   *\n   * @param type of the event to handle.\n   * @param event to handle.\n   */\n  private handleEvent<K extends WebsocketEvent>(\n    type: K,\n    event: WebsocketEventMap[K],\n  ) {\n    switch (type) {\n      case WebsocketEvent.close:\n        this.dispatchEvent(type, event);\n        this.scheduleConnectionRetryIfNeeded(); // schedule a new connection retry if the websocket was closed by the server\n        break;\n\n      case WebsocketEvent.open:\n        if (this.backoff !== undefined && this._lastConnection !== undefined) {\n          // websocket was reconnected, dispatch reconnect event and reset backoff\n          const detail: ReconnectEventDetail = {\n            retries: this.backoff.retries,\n            lastConnection: new Date(this._lastConnection),\n          };\n          const event: CustomEvent<ReconnectEventDetail> =\n            new CustomEvent<ReconnectEventDetail>(WebsocketEvent.reconnect, {\n              detail,\n            });\n          this.dispatchEvent(WebsocketEvent.reconnect, event);\n          this.backoff.reset();\n        }\n        this._lastConnection = new Date();\n        this.dispatchEvent(type, event); // dispatch open event and send buffered data\n        this.sendBufferedData();\n        break;\n\n      case WebsocketEvent.retry:\n        this.dispatchEvent(type, event); // dispatch retry event and try to connect\n        this.clearWebsocket(); // clear the old websocket\n        this.tryConnect();\n        break;\n\n      default:\n        this.dispatchEvent(type, event); // dispatch event to all listeners of the given event-type\n        break;\n    }\n  }\n\n  /**\n   * Sends buffered data if there is a buffer defined.\n   */\n  private sendBufferedData() {\n    if (this.buffer === undefined) {\n      return; // no buffer defined, nothing to send\n    }\n\n    for (\n      let ele = this.buffer.read();\n      ele !== undefined;\n      ele = this.buffer.read()\n    ) {\n      this.send(ele); // send buffered data\n    }\n  }\n\n  /**\n   * Schedules a connection-retry if there is a backoff defined and the websocket was not closed by the user.\n   */\n  private scheduleConnectionRetryIfNeeded() {\n    if (this.closedByUser) {\n      return; // user closed the websocket, no retry\n    }\n    if (this.backoff === undefined) {\n      return; // no backoff defined, no retry\n    }\n\n    // handler dispatches the retry event to all listeners of the retry event-type\n    const handleRetryEvent = (detail: RetryEventDetail) => {\n      const event: CustomEvent<RetryEventDetail> = new CustomEvent(\n        WebsocketEvent.retry,\n        { detail },\n      );\n      this.handleEvent(WebsocketEvent.retry, event);\n    };\n\n    // create retry event detail, depending on the 'instantReconnect' option\n    const retryEventDetail: RetryEventDetail = {\n      backoff:\n        this._options.retry.instantReconnect === true ? 0 : this.backoff.next(),\n      retries:\n        this._options.retry.instantReconnect === true\n          ? 0\n          : this.backoff.retries,\n      lastConnection: this._lastConnection,\n    };\n\n    // schedule a new connection-retry if the maximum number of retries is not reached yet\n    if (\n      this._options.retry.maxRetries === undefined ||\n      retryEventDetail.retries <= this._options.retry.maxRetries\n    ) {\n      this.retryTimeout = globalThis.setTimeout(\n        () => handleRetryEvent(retryEventDetail),\n        retryEventDetail.backoff,\n      );\n    }\n  }\n\n  /**\n   * Cancels the scheduled connection-retry, if there is one.\n   */\n  private cancelScheduledConnectionRetry() {\n    globalThis.clearTimeout(this.retryTimeout);\n  }\n}\n", "import { Backoff } from \"./backoff/backoff\";\nimport {\n  WebsocketEvent,\n  WebsocketEventListener,\n  WebsocketEventListenerOptions,\n} from \"./websocket_event\";\nimport { Websocket } from \"./websocket\";\nimport { WebsocketBuffer } from \"./websocket_buffer\";\nimport { WebsocketOptions } from \"./websocket_options\";\n\n/**\n * Builder for websockets.\n */\nexport class WebsocketBuilder {\n  private readonly _url: string;\n\n  private _protocols?: string | string[];\n  private _options?: WebsocketOptions;\n\n  /**\n   * Creates a new WebsocketBuilder.\n   *\n   * @param url the url to connect to\n   */\n  constructor(url: string) {\n    this._url = url;\n  }\n\n  /**\n   * Getter for the url.\n   *\n   * @returns the url\n   */\n  get url(): string {\n    return this._url;\n  }\n\n  /**\n   * Adds protocols to the websocket. Subsequent calls to this method will override the previously set protocols.\n   *\n   * @param protocols the protocols to add\n   */\n  public withProtocols(\n    protocols: string | string[] | undefined,\n  ): WebsocketBuilder {\n    this._protocols = protocols;\n    return this;\n  }\n\n  /**\n   * Getter for the protocols.\n   *\n   * @returns the protocols, undefined if no protocols have been set\n   */\n  get protocols(): string | string[] | undefined {\n    return this._protocols;\n  }\n\n  /**\n   * Sets the maximum number of retries before giving up. No limit if undefined.\n   *\n   * @param maxRetries the maximum number of retries before giving up\n   */\n  public withMaxRetries(maxRetries: number | undefined): WebsocketBuilder {\n    this._options = {\n      ...this._options,\n      retry: { ...this._options?.retry, maxRetries },\n    };\n    return this;\n  }\n\n  /**\n   * Getter for the maximum number of retries before giving up.\n   *\n   * @returns the maximum number of retries before giving up, undefined if no maximum has been set\n   */\n  get maxRetries(): number | undefined {\n    return this._options?.retry?.maxRetries;\n  }\n\n  /**\n   * Sets wether to reconnect immediately after a connection has been lost, ignoring the backoff strategy for the first retry.\n   *\n   * @param instantReconnect wether to reconnect immediately after a connection has been lost\n   */\n  public withInstantReconnect(\n    instantReconnect: boolean | undefined,\n  ): WebsocketBuilder {\n    this._options = {\n      ...this._options,\n      retry: { ...this._options?.retry, instantReconnect },\n    };\n    return this;\n  }\n\n  /**\n   * Getter for wether to reconnect immediately after a connection has been lost, ignoring the backoff strategy for the first retry.\n   *\n   * @returns wether to reconnect immediately after a connection has been lost, undefined if no value has been set\n   */\n  get instantReconnect(): boolean | undefined {\n    return this._options?.retry?.instantReconnect;\n  }\n\n  /**\n   * Adds a backoff to the websocket. Subsequent calls to this method will override the previously set backoff.\n   *\n   * @param backoff the backoff to add\n   */\n  public withBackoff(backoff: Backoff | undefined): WebsocketBuilder {\n    this._options = {\n      ...this._options,\n      retry: { ...this._options?.retry, backoff },\n    };\n    return this;\n  }\n\n  /**\n   * Getter for the backoff.\n   *\n   * @returns the backoff, undefined if no backoff has been set\n   */\n  get backoff(): Backoff | undefined {\n    return this._options?.retry?.backoff;\n  }\n\n  /**\n   * Adds a buffer to the websocket. Subsequent calls to this method will override the previously set buffer.\n   *\n   * @param buffer the buffer to add\n   */\n  public withBuffer(buffer: WebsocketBuffer | undefined): WebsocketBuilder {\n    this._options = { ...this._options, buffer };\n    return this;\n  }\n\n  /**\n   * Getter for the buffer.\n   *\n   * @returns the buffer, undefined if no buffer has been set\n   */\n  get buffer(): WebsocketBuffer | undefined {\n    return this._options?.buffer;\n  }\n\n  /**\n   * Adds an 'open' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be\n   * called in the order they were added.\n   *\n   * @param listener the listener to add\n   * @param options the listener options\n   */\n  public onOpen(\n    listener: WebsocketEventListener<WebsocketEvent.open>,\n    options?: WebsocketEventListenerOptions,\n  ): WebsocketBuilder {\n    this.addListener(WebsocketEvent.open, listener, options);\n    return this;\n  }\n\n  /**\n   * Adds an 'close' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be\n   * called in the order they were added.\n   *\n   * @param listener the listener to add\n   * @param options the listener options\n   */\n  public onClose(\n    listener: WebsocketEventListener<WebsocketEvent.close>,\n    options?: WebsocketEventListenerOptions,\n  ): WebsocketBuilder {\n    this.addListener(WebsocketEvent.close, listener, options);\n    return this;\n  }\n\n  /**\n   * Adds an 'error' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be\n   * called in the order they were added.\n   *\n   * @param listener the listener to add\n   * @param options the listener options\n   */\n  public onError(\n    listener: WebsocketEventListener<WebsocketEvent.error>,\n    options?: WebsocketEventListenerOptions,\n  ): WebsocketBuilder {\n    this.addListener(WebsocketEvent.error, listener, options);\n    return this;\n  }\n\n  /**\n   * Adds an 'message' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be\n   * called in the order they were added.\n   *\n   * @param listener the listener to add\n   * @param options the listener options\n   */\n  public onMessage(\n    listener: WebsocketEventListener<WebsocketEvent.message>,\n    options?: WebsocketEventListenerOptions,\n  ): WebsocketBuilder {\n    this.addListener(WebsocketEvent.message, listener, options);\n    return this;\n  }\n\n  /**\n   * Adds an 'retry' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be\n   * called in the order they were added.\n   *\n   * @param listener the listener to add\n   * @param options the listener options\n   */\n  public onRetry(\n    listener: WebsocketEventListener<WebsocketEvent.retry>,\n    options?: WebsocketEventListenerOptions,\n  ): WebsocketBuilder {\n    this.addListener(WebsocketEvent.retry, listener, options);\n    return this;\n  }\n\n  /**\n   * Adds an 'reconnect' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be\n   * called in the order they were added.\n   *\n   * @param listener the listener to add\n   * @param options the listener options\n   */\n  public onReconnect(\n    listener: WebsocketEventListener<WebsocketEvent.reconnect>,\n    options?: WebsocketEventListenerOptions,\n  ): WebsocketBuilder {\n    this.addListener(WebsocketEvent.reconnect, listener, options);\n    return this;\n  }\n\n  /**\n   * Builds the websocket.\n   *\n   * @return a new websocket, with the set options\n   */\n  public build(): Websocket {\n    return new Websocket(this._url, this._protocols, this._options); // instantiate the websocket with the set options\n  }\n\n  /**\n   * Adds an event listener to the options.\n   *\n   * @param event the event to add the listener to\n   * @param listener the listener to add\n   * @param options the listener options\n   */\n  private addListener<K extends WebsocketEvent>(\n    event: WebsocketEvent,\n    listener: WebsocketEventListener<K>,\n    options?: WebsocketEventListenerOptions,\n  ): WebsocketBuilder {\n    this._options = {\n      ...this._options,\n      listeners: {\n        open: this._options?.listeners?.open ?? [],\n        close: this._options?.listeners?.close ?? [],\n        error: this._options?.listeners?.error ?? [],\n        message: this._options?.listeners?.message ?? [],\n        retry: this._options?.listeners?.retry ?? [],\n        reconnect: this._options?.listeners?.reconnect ?? [],\n        [event]: [\n          ...(this._options?.listeners?.[event] ?? []),\n          { listener, options },\n        ],\n      },\n    };\n    return this;\n  }\n}\n"],
  "mappings": "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",
  "names": ["WebsocketEvent", "event"]
}
