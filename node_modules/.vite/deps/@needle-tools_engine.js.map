{
  "version": 3,
  "sources": ["../../@needle-tools/engine/src/engine/engine_audio.ts", "../../@needle-tools/engine/src/engine/engine_hot_reload.ts", "../../@needle-tools/engine/src/engine/engine_physics_rapier.ts", "../../@needle-tools/engine/src/engine/engine_test_utils.ts", "../../@needle-tools/engine/src/engine/export/state.ts", "../../@needle-tools/engine/src/engine/export/gltf/Writers.ts", "../../@needle-tools/engine/src/engine/export/gltf/index.ts", "../../@needle-tools/engine/src/engine/webcomponents/needle-button.ts", "../../@needle-tools/engine/src/engine-components/CameraUtils.ts", "../../@needle-tools/engine/src/engine-components/AnimationUtilsAutoplay.ts", "../../@needle-tools/engine/src/needle-engine.ts"],
  "sourcesContent": ["import { AudioContext } from \"three\";\r\n\r\nimport { Application } from \"./engine_application.js\";\r\n\r\n/** \r\n * @internal \r\n * Ensure the audio context is resumed if it gets suspended or interrupted */\r\nexport function ensureAudioContextIsResumed() {\r\n    Application.registerWaitForInteraction(() => {\r\n        // this is a fix for https://github.com/mrdoob/three.js/issues/27779 & https://linear.app/needle/issue/NE-4257\r\n        const ctx = AudioContext.getContext();\r\n        ctx.addEventListener(\"statechange\", () => {\r\n            setTimeout(() => {\r\n                // on iOS the audiocontext can be interrupted: https://developer.mozilla.org/en-US/docs/Web/API/BaseAudioContext/state#resuming_interrupted_play_states_in_ios_safari\r\n                const state = ctx.state as AudioContextState | \"interrupted\";\r\n                if (state === \"suspended\" || state === \"interrupted\") {\r\n                    ctx.resume()\r\n                        .then(() => { console.log(\"AudioContext resumed successfully\"); })\r\n                        .catch((e) => { console.log(\"Failed to resume AudioContext: \" + e); });\r\n                }\r\n            }, 500);\r\n        });\r\n    });\r\n}\r\nsetTimeout(ensureAudioContextIsResumed, 1000);", "import { addLog, LogType } from \"./debug/debug_overlay.js\";\r\nimport { addScriptToArrays, removeScriptFromContext } from \"./engine_mainloop_utils.js\"\r\nimport type { IComponent } from \"./engine_types.js\";\r\nimport { TypeStore } from \"./engine_typestore.js\";\r\nimport { getParam } from \"./engine_utils.js\";\r\n\r\nconst debug = getParam(\"debughotreload\");\r\n\r\ndeclare type BeforeUpdateArgs = {\r\n    type: string,\r\n    updates: Array<{ path: string, timestamp: number, acceptedPath: string, explicitImportRequired: boolean, type: string }>,\r\n}\r\n\r\n//@ts-ignore\r\nif (import.meta.hot) {\r\n    //@ts-ignore\r\n    import.meta.hot.on('vite:beforeUpdate', (cb: BeforeUpdateArgs) => {\r\n        if (debug) console.log(cb);\r\n        for (const update of cb.updates) {\r\n            console.log(\"[Needle Engine] Hot reloading \" + update.path);\r\n        }\r\n    });\r\n}\r\n\r\n\r\nlet isApplyingChanges = false;\r\n\r\nconst instances: Map<string, object[]> = new Map();\r\n\r\n/** @internal true during hot reload, can be used to modify behaviour in onEnable and onDisable */\r\nexport function isHotReloading() {\r\n    return isApplyingChanges;\r\n}\r\n\r\n/** @internal */\r\nexport function registerHotReloadType(instance: object) {\r\n    if (isApplyingChanges) return;\r\n    const type = instance.constructor;\r\n    const name = type.name;\r\n    if (!instances.has(name)) {\r\n        instances.set(name, [instance]);\r\n    }\r\n    else {\r\n        instances.get(name)?.push(instance);\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport function unregisterHotReloadType(instance: object) {\r\n    if (isApplyingChanges) return;\r\n    const type = instance.constructor;\r\n    const name = type.name;\r\n    const instancesOfType = instances.get(name);\r\n    if (!instancesOfType) return;\r\n    const idx = instancesOfType.indexOf(instance);\r\n    if (idx === -1) return;\r\n    instancesOfType.splice(idx, 1);\r\n}\r\n\r\n\r\nlet didRegisterUnhandledExceptionListener = false;\r\nfunction reloadPageOnHotReloadError() {\r\n    if (debug) return;\r\n    if (didRegisterUnhandledExceptionListener) return;\r\n    didRegisterUnhandledExceptionListener = true;\r\n\r\n    const error = console.error;\r\n    console.error = (...args: any[]) => {\r\n        if (args.length) {\r\n            const arg: string = args[0];\r\n            // When making changes in e.g. the engine package and then making changes in project scripts again that import the engine package: hot reload fails and reports redefinitions of types, we just reload the page in those cases for now\r\n            // editing a script in one package seems to work for now so it should be good enough for a start\r\n            if (typeof arg === \"string\" && arg.includes(\"[hmr] Failed to reload \")) {\r\n                console.log(\"[Needle Engine] Hot reloading failed\")\r\n                window.location.reload();\r\n                return;\r\n            }\r\n\r\n        }\r\n        error.apply(console, args);\r\n    };\r\n}\r\n\r\n\r\nexport function applyHMRChanges(newModule): boolean {\r\n\r\n    if (debug)\r\n        console.log(\"[HMR] Apply changes\", newModule, Object.keys(newModule));\r\n\r\n    reloadPageOnHotReloadError();\r\n\r\n    // console.dir(newModule);\r\n\r\n    for (const key of Object.keys(newModule)) {\r\n        try {\r\n            isApplyingChanges = true;\r\n\r\n            const typeToUpdate = TypeStore.get(key);\r\n            if (!typeToUpdate) {\r\n                if(debug) console.log(\"[HMR] Type not found: \" + key)\r\n                continue;\r\n            }\r\n            const newType = newModule[key];\r\n            const instancesOfType = instances.get(newType.name);\r\n\r\n            let hotReloadMessage = \"[Needle Engine] Updating type: \" + key;\r\n            const typesCount = instancesOfType?.length ?? -1;\r\n            if (typesCount > 0) hotReloadMessage += \" x\" + typesCount;\r\n            else hotReloadMessage += \" - no instances\";\r\n            console.log(hotReloadMessage);\r\n\r\n            // Update prototype (methods and properties)\r\n            const previousMethods = Object.getOwnPropertyNames(typeToUpdate.prototype);\r\n            const methodsAndProperties = Object.getOwnPropertyDescriptors(newType.prototype);\r\n            for (const typeKey in methodsAndProperties) {\r\n                const desc = methodsAndProperties[typeKey];\r\n                if (!desc.writable) continue;\r\n                typeToUpdate.prototype[typeKey] = newModule[key].prototype[typeKey];\r\n            }\r\n            // Remove methods that are no longer present\r\n            for (const typeKey of previousMethods) {\r\n                if (!methodsAndProperties[typeKey]) {\r\n                    delete typeToUpdate.prototype[typeKey];\r\n                }\r\n            }\r\n\r\n            // Update fields (we only add new fields if they are undefined)\r\n            // we create a instance to get access to the fields\r\n            if (instancesOfType) {\r\n                const newTypeInstance = new newType();\r\n                const keys = Object.getOwnPropertyDescriptors(newTypeInstance);\r\n                for (const inst of instancesOfType) {\r\n                    const componentInstance = inst as unknown as IComponent;\r\n                    const isComponent = componentInstance.isComponent === true;\r\n                    const active = isComponent ? componentInstance.activeAndEnabled : true;\r\n                    const context = isComponent ? componentInstance.context : undefined;\r\n                    try {\r\n                        if (isComponent && context) {\r\n                            removeScriptFromContext(componentInstance, context);\r\n                        }\r\n                        if (isComponent && active) {\r\n                            componentInstance.enabled = false;\r\n                        }\r\n\r\n                        if (inst[\"onBeforeHotReloadFields\"]) {\r\n                            const res = inst[\"onBeforeHotReloadFields\"]();\r\n                            if (res === false) continue;\r\n                        }\r\n                        for (const key in keys) {\r\n                            const desc = keys[key];\r\n                            if (!desc.writable) continue;\r\n                            if (inst[key] === undefined) {\r\n                                inst[key] = newTypeInstance[key];\r\n                            }\r\n                            // if its a function but not on the prototype\r\n                            // then its a bound method that needs to be rebound\r\n                            else if (typeof inst[key] === \"function\" && !inst[key].prototype) {\r\n                                const boundMethod = inst[key];\r\n                                // try to get the target method name\r\n                                const targetMethodName = boundMethod.name;\r\n                                const prefix = \"bound \"; // < magic prefix\r\n                                if (targetMethodName === prefix) continue;\r\n                                const name = boundMethod.name.substring(prefix.length);\r\n                                // if the target method name still exists on the new prototype\r\n                                // we want to rebind it and assign it to the field\r\n                                // Beware that this will not work if the method is added to some event listener etc\r\n                                const newTarget = newType.prototype[name];\r\n                                if (newTarget)\r\n                                    inst[key] = newTarget.bind(inst);\r\n                            }\r\n                        }\r\n                        if (inst[\"onAfterHotReloadFields\"]) inst[\"onAfterHotReloadFields\"]();\r\n                    }\r\n                    finally {\r\n                        if (isComponent && context) {\r\n                            addScriptToArrays(componentInstance, context);\r\n                        }\r\n                        if (isComponent && active) {\r\n                            componentInstance.enabled = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        catch (err) {\r\n            if (debug) console.error(err);\r\n            // we only want to invalidate changes if we debug hot reload\r\n            else return false;\r\n        }\r\n        finally {\r\n            isApplyingChanges = false;\r\n            addLog(LogType.Log, \"Script changes applied (HMR)\")\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n", "import { ActiveCollisionTypes, ActiveEvents, Ball, CoefficientCombineRule, Collider, ColliderDesc, Cuboid, EventQueue, JointData, QueryFilterFlags, Ray, RigidBody, RigidBodyDesc, RigidBodyType, ShapeType, TriMeshFlags, World } from '@dimforge/rapier3d-compat';\r\nimport { BufferAttribute, BufferGeometry, InstancedInterleavedBuffer, InterleavedBuffer, InterleavedBufferAttribute, LineBasicMaterial, LineSegments, Matrix4, Mesh, Object3D, Quaternion, Vector3 } from 'three'\r\nimport * as BufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils.js'\r\n\r\nimport { CollisionDetectionMode, PhysicsMaterialCombine } from '../engine/engine_physics.types.js';\r\nimport { isDevEnvironment } from './debug/index.js';\r\nimport { ContextEvent, ContextRegistry } from './engine_context_registry.js';\r\nimport { foreachComponent } from './engine_gameobject.js';\r\nimport { Gizmos } from './engine_gizmos.js';\r\nimport { Mathf } from './engine_math.js';\r\nimport { getWorldPosition, getWorldQuaternion, getWorldScale, setWorldPositionXYZ, setWorldQuaternionXYZW } from \"./engine_three_utils.js\"\r\nimport type {\r\n    IBoxCollider,\r\n    ICollider,\r\n    IComponent,\r\n    IContext,\r\n    IGameObject,\r\n    IPhysicsEngine,\r\n    IRigidbody,\r\n    ISphereCollider,\r\n    Vec2,\r\n    Vec3,\r\n} from './engine_types.js';\r\nimport { Collision, ContactPoint } from './engine_types.js';\r\nimport { SphereOverlapResult } from './engine_types.js';\r\nimport { CircularBuffer, getParam } from \"./engine_utils.js\"\r\n\r\nconst debugPhysics = getParam(\"debugphysics\");\r\nconst debugColliderPlacement = getParam(\"debugcolliderplacement\");\r\nconst debugCollisions = getParam(\"debugcollisions\");\r\nconst showColliders = getParam(\"showcolliders\");\r\nconst showPhysicsRaycasts = getParam(\"debugraycasts\");\r\n\r\n\r\n/** on physics body and references the needle component */\r\nconst $componentKey = Symbol(\"needle component\");\r\n/** on needle component and references physics body */\r\nconst $bodyKey = Symbol(\"physics body\");\r\nconst $colliderRigidbody = Symbol(\"rigidbody\");\r\n\r\n\r\nlet RAPIER: undefined | any = undefined;\r\ndeclare const NEEDLE_USE_RAPIER: boolean;\r\nglobalThis[\"NEEDLE_USE_RAPIER\"] = globalThis[\"NEEDLE_USE_RAPIER\"] !== undefined ? globalThis[\"NEEDLE_USE_RAPIER\"] : true;\r\nif (debugPhysics)\r\n    console.log(\"Use Rapier\", NEEDLE_USE_RAPIER, globalThis[\"NEEDLE_USE_RAPIER\"])\r\n\r\nif (NEEDLE_USE_RAPIER) {\r\n    ContextRegistry.registerCallback(ContextEvent.ContextCreationStart, evt => {\r\n        if (debugPhysics)\r\n            console.log(\"Register rapier physics backend\")\r\n        evt.context.physics.engine = new RapierPhysics();\r\n        // We want the physics engine to be initialized on start so when components start to enable and modify values they don't have delays\r\n        // TODO: should the promise be returned here to make the engine creation wait?\r\n        if (NEEDLE_USE_RAPIER) {\r\n            evt.context.physics.engine.initialize(evt.context);\r\n        }\r\n    });\r\n}\r\n\r\n\r\ndeclare type PhysicsBody = {\r\n    translation(): { x: number, y: number, z: number }\r\n    rotation(): { x: number, y: number, z: number, w: number }\r\n}\r\n\r\nexport class RapierPhysics implements IPhysicsEngine {\r\n\r\n    debugRenderColliders: boolean = false;\r\n    debugRenderRaycasts: boolean = false;\r\n\r\n    removeBody(obj: IComponent) {\r\n        if (!obj) return;\r\n        this.validate();\r\n        const body = obj[$bodyKey];\r\n        obj[$bodyKey] = null;\r\n        if (body && this.world) {\r\n            const index = this.objects.findIndex(o => o === obj);\r\n            if (index >= 0) {\r\n                const rapierBody = this.bodies[index];\r\n                // Remove references\r\n                this.bodies.splice(index, 1);\r\n                this.objects.splice(index, 1);\r\n\r\n\r\n                // Remove the collider from the physics world\r\n                if (rapierBody instanceof Collider) {\r\n                    const rapierCollider = rapierBody as Collider;\r\n                    this.world?.removeCollider(rapierCollider, true);\r\n\r\n                    // also remove the rigidbody if it doesnt have colliders anymore\r\n                    const rapierRigidbody: RigidBody | null = rapierCollider.parent();\r\n                    if (rapierRigidbody && rapierRigidbody.numColliders() <= 0) {\r\n                        const rigidbody = rapierRigidbody[$componentKey] as IRigidbody;\r\n                        if (rigidbody) {\r\n                            // If the collider was attached to a rigidbody and this rigidbody now has no colliders anymore we should ignore it - because the Rigidbody component will delete itself\r\n                        }\r\n                        else {\r\n                            // But if there is no explicit rigidbody needle component then the colliders did create it implictly and thus we need to remove it here:\r\n                            this.world?.removeRigidBody(rapierRigidbody);\r\n                        }\r\n                    }\r\n                }\r\n                // Remove the rigidbody from the physics world\r\n                else if (rapierBody instanceof RigidBody) {\r\n                    if (rapierBody.numColliders() <= 0) {\r\n                        this.world?.removeRigidBody(rapierBody);\r\n                    }\r\n                    else {\r\n                        if (isDevEnvironment()) {\r\n                            if (!rapierBody[\"did_log_removing\"]) {\r\n                                setTimeout(() => {\r\n                                    if (rapierBody.numColliders() > 0) {\r\n                                        rapierBody[\"did_log_removing\"] = true;\r\n                                        console.warn(\"RapierPhysics: removing rigidbody with colliders from the physics world is not possible right now, please remove the colliders first\");\r\n                                    }\r\n                                }, 1);\r\n\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    updateBody(comp: ICollider | IRigidbody, translation: boolean, rotation: boolean) {\r\n        this.validate();\r\n        if (!this.enabled) return;\r\n        if (comp.destroyed || !comp.gameObject) return;\r\n        if (!translation && !rotation) return;\r\n\r\n        if ((comp as ICollider).isCollider === true) {\r\n            // const collider = comp as ICollider;\r\n            console.warn(\"TODO: implement updating collider position\");\r\n        }\r\n        else {\r\n            const rigidbody = comp as IRigidbody;\r\n            const body = rigidbody[$bodyKey];\r\n            if (body) {\r\n                this.syncPhysicsBody(rigidbody.gameObject, body, translation, rotation);\r\n            }\r\n        }\r\n    }\r\n\r\n    updateProperties(obj: IRigidbody | ICollider) {\r\n        this.validate();\r\n\r\n        if ((obj as ICollider).isCollider) {\r\n            const col = obj as ICollider;\r\n            const body = col[$bodyKey];\r\n            if (body) {\r\n                this.internalUpdateColliderProperties(col, body);\r\n                if (col.sharedMaterial)\r\n                    this.updatePhysicsMaterial(col);\r\n            }\r\n        }\r\n        else {\r\n            const rb = obj as IRigidbody;\r\n            const physicsBody = this.internal_getRigidbody(rb);\r\n            if (physicsBody) {\r\n                this.internalUpdateRigidbodyProperties(rb, physicsBody);\r\n            }\r\n        }\r\n    }\r\n    addForce(rigidbody: IRigidbody, force: Vec3, wakeup: boolean) {\r\n        this.validate();\r\n        const body = this.internal_getRigidbody(rigidbody);\r\n        if (body) body.addForce(force, wakeup)\r\n        else console.warn(\"Rigidbody doesn't exist: can not apply force (does your object with the Rigidbody have a collider?)\");\r\n    }\r\n    addImpulse(rigidbody: IRigidbody, force: Vec3, wakeup: boolean) {\r\n        this.validate();\r\n        const body = this.internal_getRigidbody(rigidbody);\r\n        if (body) body.applyImpulse(force, wakeup);\r\n        else console.warn(\"Rigidbody doesn't exist: can not apply impulse (does your object with the Rigidbody have a collider?)\");\r\n    }\r\n    getLinearVelocity(comp: IRigidbody | ICollider): Vec3 | null {\r\n        this.validate();\r\n        const body = this.internal_getRigidbody(comp);\r\n        if (body) {\r\n            const vel = body.linvel();\r\n            return vel;\r\n        }\r\n        // else console.warn(\"Rigidbody doesn't exist: can not get linear velocity (does your object with the Rigidbody have a collider?)\");\r\n        return null;\r\n    }\r\n    getAngularVelocity(rb: IRigidbody): Vec3 | null {\r\n        this.validate();\r\n        const body = this.internal_getRigidbody(rb);\r\n        if (body) {\r\n            const vel = body.angvel();\r\n            return vel;\r\n        }\r\n        // else console.warn(\"Rigidbody doesn't exist: can not get angular velocity (does your object with the Rigidbody have a collider?)\");\r\n        return null;\r\n    }\r\n    resetForces(rb: IRigidbody, wakeup: boolean) {\r\n        this.validate();\r\n        const body = this.internal_getRigidbody(rb);\r\n        body?.resetForces(wakeup);\r\n    }\r\n    resetTorques(rb: IRigidbody, wakeup: boolean) {\r\n        this.validate();\r\n        const body = this.internal_getRigidbody(rb);\r\n        body?.resetTorques(wakeup);\r\n    }\r\n    applyImpulse(rb: IRigidbody, vec: Vec3, wakeup: boolean) {\r\n        this.validate();\r\n        const body = this.internal_getRigidbody(rb);\r\n        if (body) body.applyImpulse(vec, wakeup);\r\n        else console.warn(\"Rigidbody doesn't exist: can not apply impulse (does your object with the Rigidbody have a collider?)\");\r\n    }\r\n\r\n    wakeup(rb: IRigidbody) {\r\n        this.validate();\r\n        const body = this.internal_getRigidbody(rb);\r\n        if (body) body.wakeUp();\r\n        else console.warn(\"Rigidbody doesn't exist: can not wake up (does your object with the Rigidbody have a collider?)\");\r\n    }\r\n    isSleeping(rb: IRigidbody) {\r\n        this.validate();\r\n        const body = this.internal_getRigidbody(rb);\r\n        return body?.isSleeping();\r\n    }\r\n    setAngularVelocity(rb: IRigidbody, vec: Vec3, wakeup: boolean) {\r\n        this.validate();\r\n        const body = this.internal_getRigidbody(rb);\r\n        if (body) body.setAngvel(vec, wakeup);\r\n        else console.warn(\"Rigidbody doesn't exist: can not set angular velocity (does your object with the Rigidbody have a collider?)\");\r\n    }\r\n    setLinearVelocity(rb: IRigidbody, vec: Vec3, wakeup: boolean) {\r\n        this.validate();\r\n        const body = this.internal_getRigidbody(rb);\r\n        if (body) body.setLinvel(vec, wakeup);\r\n        else console.warn(\"Rigidbody doesn't exist: can not set linear velocity (does your object with the Rigidbody have a collider?)\");\r\n    }\r\n\r\n    private context?: IContext;\r\n    private _initializePromise?: Promise<boolean>;\r\n    private _isInitialized: boolean = false;\r\n\r\n    async initialize(context: IContext) {\r\n        this.context = context;\r\n        if (!this._initializePromise)\r\n            this._initializePromise = this.internalInitialization();\r\n        return this._initializePromise;\r\n    }\r\n\r\n    private async internalInitialization() {\r\n        if (debugPhysics) console.log(\"Initialize rapier physics engine\");\r\n        // NEEDLE_PHYSICS_INIT_START\r\n        // use .env file with VITE_NEEDLE_USE_RAPIER=false to treeshake rapier\r\n        // @ts-ignore\r\n        if (\"env\" in import.meta && import.meta.env.VITE_NEEDLE_USE_RAPIER === \"false\") {\r\n            if (debugPhysics) console.log(\"Rapier disabled\");\r\n            return false;\r\n        }\r\n        // Can be transformed during build time to disable rapier\r\n        if (!NEEDLE_USE_RAPIER) return false;\r\n        if (this._hasCreatedWorld) {\r\n            console.error(\"Invalid call to create physics world: world is already created\");\r\n            return true;\r\n        }\r\n        this._hasCreatedWorld = true;\r\n        if (RAPIER === undefined) {\r\n            if (debugPhysics) console.log(\"Import Rapier\");\r\n            const _rapier = await import(\"@dimforge/rapier3d-compat\");\r\n            if (debugPhysics) console.log(\"Init Rapier\");\r\n            await _rapier.init();\r\n            // only assign after all loads are done to avoid a race condition \r\n            // where RAPIER is already set and then used while actually still waiting for initialization.\r\n            RAPIER = _rapier;\r\n        }\r\n        if (debugPhysics) console.log(\"Physics engine initialized, creating world...\");\r\n        this._world = new World(this._gravity);\r\n        this.enabled = true;\r\n        this._isInitialized = true;\r\n        if (debugPhysics) console.log(\"Physics world created\");\r\n        return true;\r\n        // NEEDLE_PHYSICS_INIT_END\r\n    }\r\n\r\n    /** Check is the physics engine has been initialized and the call can be made */\r\n    private validate() {\r\n        if (!this._isInitialized) {\r\n            if (debugPhysics) {\r\n                this[\"_lastWarnTime\"] = this[\"_lastWarnTime\"] ?? 0;\r\n                if (Date.now() - this[\"_lastWarnTime\"] > 1000) {\r\n                    this[\"_lastWarnTime\"] = Date.now();\r\n                    console.warn(\"Physics engine is not initialized\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    private rapierRay = new Ray({ x: 0, y: 0, z: 0 }, { x: 0, y: 0, z: 1 });\r\n    private raycastVectorsBuffer = new CircularBuffer(() => new Vector3(), 10);\r\n    public raycast(origin?: Vec2 | Vec3, direction?: Vec3, options?: {\r\n        maxDistance?: number,\r\n        /** True if you want to also hit objects when the raycast starts from inside a collider */\r\n        solid?: boolean,\r\n        queryFilterFlags?: QueryFilterFlags,\r\n        filterGroups?: number,\r\n        /** Return false to ignore this collider */\r\n        filterPredicate?: (c: ICollider) => boolean,\r\n        /** When enabled the hit object's layer will be tested. If layer 2 is enabled the object will be ignored (Layer 2 == IgnoreRaycast) \r\n         * If not set the raycast will ignore objects in the IgnoreRaycast layer (default: true)\r\n         * @default undefined \r\n        */\r\n        useIgnoreRaycastLayer?: boolean\r\n    })\r\n        : null | { point: Vector3, collider: ICollider } {\r\n\r\n        let maxDistance = options?.maxDistance;\r\n        let solid = options?.solid;\r\n\r\n        if (maxDistance === undefined) maxDistance = Infinity;\r\n        if (solid === undefined) solid = true;\r\n\r\n        const ray = this.getPhysicsRay(this.rapierRay, origin, direction);\r\n        if (!ray) return null;\r\n\r\n        if (this.debugRenderRaycasts || showPhysicsRaycasts) Gizmos.DrawRay(ray.origin, ray.dir, 0x0000ff, 1);\r\n\r\n        const hit = this.world?.castRay(ray, maxDistance, solid, options?.queryFilterFlags, options?.filterGroups, undefined, undefined, (c) => {\r\n            const component = c[$componentKey];\r\n            if (options?.filterPredicate) return options.filterPredicate(component);\r\n            if (options?.useIgnoreRaycastLayer !== false) {\r\n                // ignore objects in the IgnoreRaycast=2 layer\r\n                return !component?.gameObject.layers.isEnabled(2);\r\n            }\r\n            return true;\r\n        });\r\n        if (hit) {\r\n            const point = ray.pointAt(hit.timeOfImpact);\r\n            const vec = this.raycastVectorsBuffer.get();\r\n            vec.set(point.x, point.y, point.z);\r\n            return { point: vec, collider: hit.collider[$componentKey] };\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    public raycastAndGetNormal(origin?: Vec2 | Vec3, direction?: Vec3, options?: {\r\n        maxDistance?: number,\r\n        /** True if you want to also hit objects when the raycast starts from inside a collider */\r\n        solid?: boolean,\r\n        queryFilterFlags?: QueryFilterFlags,\r\n        filterGroups?: number,\r\n        /** Return false to ignore this collider */\r\n        filterPredicate?: (c: ICollider) => boolean,\r\n        /** When enabled the hit object's layer will be tested. If layer 2 is enabled the object will be ignored (Layer 2 == IgnoreRaycast) \r\n         * If not set the raycast will ignore objects in the IgnoreRaycast layer (default: true)\r\n         * @default undefined \r\n        */\r\n        useIgnoreRaycastLayer?: boolean\r\n    })\r\n        : null | { point: Vector3, normal: Vector3, collider: ICollider } {\r\n\r\n        let maxDistance = options?.maxDistance;\r\n        let solid = options?.solid;\r\n\r\n        if (maxDistance === undefined) maxDistance = Infinity;\r\n        if (solid === undefined) solid = true;\r\n\r\n        const ray = this.getPhysicsRay(this.rapierRay, origin, direction);\r\n        if (!ray) return null;\r\n\r\n        if (this.debugRenderRaycasts || showPhysicsRaycasts) Gizmos.DrawRay(ray.origin, ray.dir, 0x0000ff, 1);\r\n\r\n        const hit = this.world?.castRayAndGetNormal(ray, maxDistance, solid, options?.queryFilterFlags, options?.filterGroups, undefined, undefined, (c) => {\r\n            const component = c[$componentKey];\r\n            if (options?.filterPredicate) return options.filterPredicate(component);\r\n            if (options?.useIgnoreRaycastLayer !== false) {\r\n                // ignore objects in the IgnoreRaycast=2 layer\r\n                return !component?.gameObject.layers.isEnabled(2);\r\n            }\r\n            return true;\r\n        });\r\n        if (hit) {\r\n            const point = ray.pointAt(hit.timeOfImpact);\r\n            const normal = hit.normal;\r\n            const vec = this.raycastVectorsBuffer.get();\r\n            const nor = this.raycastVectorsBuffer.get();\r\n            vec.set(point.x, point.y, point.z);\r\n            nor.set(normal.x, normal.y, normal.z);\r\n            return { point: vec, normal: nor, collider: hit.collider[$componentKey] };\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private getPhysicsRay(ray: Ray, origin?: Vec2 | Vec3, direction?: Vec3): Ray | null {\r\n        const cam = this.context?.mainCamera;\r\n        if (origin === undefined) {\r\n            const pos = this.context?.input.getPointerPosition(0);\r\n            if (pos) origin = pos;\r\n            else return null;\r\n        }\r\n        // if we get origin in 2d space we need to project it to 3d space\r\n        if (origin[\"z\"] === undefined) {\r\n            if (!cam) {\r\n                console.error(\"Can not perform raycast from 2d point - no main camera found\");\r\n                return null;\r\n            }\r\n            const vec3 = this.raycastVectorsBuffer.get();\r\n            vec3.x = origin.x;\r\n            vec3.y = origin.y;\r\n            vec3.z = 0;\r\n            // if the origin is in screen space we need to convert it to raycaster space\r\n            if (vec3.x > 1 || vec3.y > 1 || vec3.y < -1 || vec3.x < -1) {\r\n                if (debugPhysics) console.warn(\"Converting screenspace to raycast space\", vec3)\r\n                this.context?.input.convertScreenspaceToRaycastSpace(vec3);\r\n            }\r\n            vec3.unproject(cam);\r\n            origin = vec3;\r\n        }\r\n\r\n        const o = origin as Vec3;\r\n\r\n        ray.origin.x = o.x;\r\n        ray.origin.y = o.y;\r\n        ray.origin.z = o.z;\r\n        const vec = this.raycastVectorsBuffer.get();\r\n        if (direction)\r\n            vec.set(direction.x, direction.y, direction.z);\r\n        else {\r\n            if (!cam) {\r\n                console.error(\"Can not perform raycast - no camera found\");\r\n                return null;\r\n            }\r\n            vec.set(ray.origin.x, ray.origin.y, ray.origin.z);\r\n            const camPosition = getWorldPosition(cam);\r\n            vec.sub(camPosition);\r\n        }\r\n        // we need to normalize the ray because our input is a max travel length and the direction may be not normalized\r\n        vec.normalize();\r\n        ray.dir.x = vec.x;\r\n        ray.dir.y = vec.y;\r\n        ray.dir.z = vec.z;\r\n        // Gizmos.DrawRay(ray.origin, ray.dir, 0xff0000, Infinity);\r\n        return ray;\r\n    }\r\n\r\n\r\n    private rapierSphere: Ball | null = null;\r\n    private rapierColliderArray: Array<SphereOverlapResult> = [];\r\n    private readonly rapierIdentityRotation = { x: 0, y: 0, z: 0, w: 1 };\r\n    private readonly rapierForwardVector = { x: 0, y: 0, z: 1 };\r\n    /** Precice sphere overlap detection using rapier against colliders\r\n     * @param point center of the sphere in worldspace\r\n     * @param radius radius of the sphere\r\n     * @returns array of colliders that overlap with the sphere. Note: they currently only contain the collider and the gameobject\r\n     */\r\n    public sphereOverlap(point: Vector3, radius: number): Array<SphereOverlapResult> {\r\n        this.rapierColliderArray.length = 0;\r\n        if (!this.world) return this.rapierColliderArray;\r\n        if (!this.rapierSphere)\r\n            this.rapierSphere = new Ball(radius);\r\n        this.rapierSphere.radius = radius;\r\n\r\n        if (this.debugRenderRaycasts || showPhysicsRaycasts) Gizmos.DrawWireSphere(point, radius, 0x3344ff, 1);\r\n        this.world.intersectionsWithShape(point,\r\n            this.rapierIdentityRotation,\r\n            this.rapierSphere,\r\n            col => {\r\n                const collider = col[$componentKey] as ICollider\r\n                // if (collider.gameObject.layers.isEnabled(2)) return true;\r\n                const intersection = new SphereOverlapResult(collider.gameObject, collider);\r\n                this.rapierColliderArray.push(intersection);\r\n                return true; // Return `false` instead if we want to stop searching for other colliders that contain this point.\r\n            },\r\n            // TODO: it seems as QueryFilterFlags.EXCLUDE_SENSORS also excludes DYNAMIC Rigidbodies (only if they're set to kinematic)\r\n            undefined, // QueryFilterFlags.EXCLUDE_SENSORS, \r\n            undefined, undefined, undefined,\r\n            col => {\r\n                // we don't want to raycast against triggers (see comment about Exclude Sensors above)\r\n                if (col.isSensor()) return false;\r\n                const collider = col[$componentKey] as ICollider\r\n                return collider.gameObject.layers.isEnabled(2) == false\r\n            }\r\n        );\r\n        return this.rapierColliderArray;\r\n\r\n\r\n        // TODO: this only returns one hit\r\n        // let filterGroups = 0xffffffff;\r\n        // filterGroups &= ~(1 << 2);\r\n        // const hit: ShapeColliderTOI | null = this.world.castShape(point,\r\n        //     this.rapierIdentityRotation,\r\n        //     this.rapierForwardVector,\r\n        //     this.rapierSphere,\r\n        //     0,\r\n        //     QueryFilterFlags.EXCLUDE_SENSORS,\r\n        //     // filterGroups,\r\n        // );\r\n        // // console.log(hit);\r\n        // if (hit) {\r\n        //     const collider = hit.collider[$componentKey] as ICollider\r\n        //     const intersection = new SphereOverlapResult(collider.gameObject);\r\n        //     this.rapierColliderArray.push(intersection);\r\n        //     // const localpt = hit.witness2;\r\n        //     // // const normal = hit.normal2;\r\n        //     // const hitPoint = new Vector3(localpt.x, localpt.y, localpt.z);\r\n        //     // // collider.gameObject.localToWorld(hitPoint);\r\n        //     // // const normalPt = new Vector3(normal.x, normal.y, normal.z);\r\n        //     // // const mat = new Matrix4().setPosition(point).scale(new Vector3(radius, radius, radius));\r\n        //     // // hitPoint.applyMatrix4(mat);\r\n        //     // console.log(hit.witness2)\r\n        //     // // hitPoint.add(point);\r\n        //     // const dist = hitPoint.distanceTo(point);\r\n        // }\r\n\r\n        // return this.rapierColliderArray;\r\n    }\r\n\r\n\r\n\r\n\r\n    // physics simulation\r\n\r\n    enabled: boolean = false;\r\n    /** Get access to the rapier world */\r\n    public get world(): World | undefined { return this._world };\r\n\r\n    private _tempPosition: Vector3 = new Vector3();\r\n    private _tempQuaternion: Quaternion = new Quaternion();\r\n    private _tempScale: Vector3 = new Vector3();\r\n    private _tempMatrix: Matrix4 = new Matrix4();\r\n\r\n    private static _didLoadPhysicsEngine: boolean = false;\r\n\r\n    private _isUpdatingPhysicsWorld: boolean = false;\r\n    get isUpdating(): boolean { return this._isUpdatingPhysicsWorld; }\r\n\r\n\r\n    private _world?: World;\r\n    private _hasCreatedWorld: boolean = false;\r\n    private eventQueue?: EventQueue;\r\n    private collisionHandler?: PhysicsCollisionHandler;\r\n\r\n\r\n    private objects: IComponent[] = [];\r\n    private bodies: PhysicsBody[] = [];\r\n\r\n    private _meshCache: Map<string, Float32Array> = new Map<string, Float32Array>();\r\n\r\n    private _gravity = { x: 0.0, y: -9.81, z: 0.0 };\r\n\r\n    get gravity() {\r\n        return this.world?.gravity ?? this._gravity;\r\n    }\r\n\r\n    set gravity(value: Vec3) {\r\n        if (this.world) {\r\n            this.world.gravity = value;\r\n        }\r\n        else {\r\n            this._gravity = value;\r\n        }\r\n    }\r\n\r\n    clearCaches() {\r\n        this._meshCache.clear();\r\n        if (this.eventQueue?.raw)\r\n            this.eventQueue?.free();\r\n        if (this.world?.bodies)\r\n            this.world?.free();\r\n    }\r\n\r\n    async addBoxCollider(collider: ICollider, size: Vector3) {\r\n        if (!this._isInitialized)\r\n            await this.initialize(collider.context);\r\n        if (!collider.activeAndEnabled) return;\r\n\r\n        if (!this.enabled) {\r\n            if (debugPhysics) console.warn(\"Physics are disabled\");\r\n            return;\r\n        }\r\n        const obj = collider.gameObject;\r\n        const scale = getWorldScale(obj, this._tempPosition).multiply(size);\r\n        scale.multiplyScalar(0.5);\r\n\r\n        // prevent negative scale\r\n        if (scale.x < 0)\r\n            scale.x = Math.abs(scale.x);\r\n        if (scale.y < 0)\r\n            scale.y = Math.abs(scale.y);\r\n        if (scale.z < 0)\r\n            scale.z = Math.abs(scale.z);\r\n\r\n        // prevent zero scale - seems normals are flipped otherwise\r\n        if (scale.x == 0) scale.x = 0.0000001;\r\n        if (scale.y == 0) scale.y = 0.0000001;\r\n        if (scale.z == 0) scale.z = 0.0000001;\r\n\r\n        const desc = ColliderDesc.cuboid(scale.x, scale.y, scale.z);\r\n        // const objectLayerMask = collider.gameObject.layers.mask;\r\n        // const mask = objectLayerMask & ~2;\r\n        // TODO: https://rapier.rs/docs/user_guides/javascript/colliders/#collision-groups-and-solver-groups\r\n        // desc.setCollisionGroups(objectLayerMask);\r\n        this.createCollider(collider, desc);\r\n    }\r\n\r\n    async addSphereCollider(collider: ICollider) {\r\n        if (!this._isInitialized)\r\n            await this.initialize(collider.context);\r\n        if (!collider.activeAndEnabled) return;\r\n        if (!this.enabled) {\r\n            if (debugPhysics) console.warn(\"Physics are disabled\");\r\n            return;\r\n        }\r\n        const desc = ColliderDesc.ball(.5);\r\n        this.createCollider(collider, desc);\r\n        this.updateProperties(collider);\r\n    }\r\n\r\n    async addCapsuleCollider(collider: ICollider, height: number, radius: number) {\r\n        if (!this._isInitialized)\r\n            await this.initialize(collider.context);\r\n        if (!collider.activeAndEnabled) return;\r\n        if (!this.enabled) {\r\n            if (debugPhysics) console.warn(\"Physics are disabled\");\r\n            return;\r\n        }\r\n        const obj = collider.gameObject;\r\n        const scale = getWorldScale(obj, this._tempPosition);\r\n        // Prevent negative scales\r\n        scale.x = Math.abs(scale.x);\r\n        scale.y = Math.abs(scale.y);\r\n        const finalRadius = radius * scale.x;\r\n        // half height = distance between capsule origin and top sphere origin (not the top end of the capsule)\r\n        height = Math.max(height, finalRadius * 2);\r\n        const hh = Mathf.clamp((height * .5 * scale.y) - (radius * scale.x), 0, Number.MAX_SAFE_INTEGER);\r\n        const desc = ColliderDesc.capsule(hh, finalRadius);\r\n        this.createCollider(collider, desc);\r\n    }\r\n\r\n    async addMeshCollider(collider: ICollider, mesh: Mesh, convex: boolean, scale: Vector3) {\r\n        if (!this._isInitialized)\r\n            await this.initialize(collider.context);\r\n        if (!collider.activeAndEnabled) return;\r\n        if (!this.enabled) {\r\n            if (debugPhysics) console.warn(\"Physics are disabled\");\r\n            return;\r\n        }\r\n        let geo = mesh.geometry;\r\n        if (!geo) {\r\n            if (debugPhysics) console.warn(\"Missing mesh geometry\", mesh.name);\r\n            return;\r\n        }\r\n\r\n        // check if mesh is indexed, if not generate indices\r\n        if (!geo.index?.array?.length) {\r\n            console.warn(`Your MeshCollider is missing vertices or indices in the assined mesh \\\"${mesh.name}\\\". Consider providing an indexed geometry.`);\r\n            geo = BufferGeometryUtils.mergeVertices(geo);\r\n        }\r\n\r\n        let positions: Float32Array | null = null;\r\n\r\n        const positionAttribute = geo.getAttribute(\"position\") as BufferAttribute | InterleavedBufferAttribute;\r\n        if (positionAttribute instanceof InterleavedBufferAttribute) {\r\n            const count = positionAttribute.count;\r\n            positions = new Float32Array(count * 3);\r\n            for(let i = 0; i < count; i++) {\r\n                const x = positionAttribute.getX(i);\r\n                const y = positionAttribute.getY(i);\r\n                const z = positionAttribute.getZ(i);\r\n                positions[i * 3] = x;\r\n                positions[i * 3 + 1] = y;\r\n                positions[i * 3 + 2] = z;\r\n            }\r\n        }\r\n        else {\r\n            positions = positionAttribute.array as Float32Array;\r\n        }\r\n        \r\n        // let positions = geo.getAttribute(\"position\").array as Float32Array;\r\n        const indices = geo.index?.array as Uint32Array;\r\n\r\n        // scaling seems not supported yet https://github.com/dimforge/rapier/issues/243\r\n        if (Math.abs(scale.x - 1) > 0.0001 || Math.abs(scale.y - 1) > 0.0001 || Math.abs(scale.z - 1) > 0.0001) {\r\n            const key = geo.uuid + \"_\" + scale.x + \"_\" + scale.y + \"_\" + scale.z + \"_\" + convex;\r\n            if (this._meshCache.has(key)) {\r\n                if (debugPhysics) console.warn(\"Use cached mesh collider\")\r\n                positions = this._meshCache.get(key)!;\r\n            }\r\n            else {\r\n                if (debugPhysics || isDevEnvironment()) console.warn(`Your MeshCollider \\\"${collider.name}\\\" is scaled: consider applying the scale to the collider mesh instead (${scale.x}, ${scale.y}, ${scale.z})`);\r\n                const scaledPositions = new Float32Array(positions.length);\r\n                for (let i = 0; i < positions.length; i += 3) {\r\n                    scaledPositions[i] = positions[i] * scale.x;\r\n                    scaledPositions[i + 1] = positions[i + 1] * scale.y;\r\n                    scaledPositions[i + 2] = positions[i + 2] * scale.z;\r\n                }\r\n                positions = scaledPositions;\r\n                this._meshCache.set(key, scaledPositions);\r\n            }\r\n        }\r\n        const desc = convex ? ColliderDesc.convexHull(positions) : ColliderDesc.trimesh(positions, indices);\r\n        if (desc) {\r\n            this.createCollider(collider, desc);\r\n            // col.setMassProperties(1, { x: 0, y: 0, z: 0 }, { x: 0, y: 0, z: 0 }, { x: 0, y: 0, z: 0, w: 1 });\r\n            // rb?.setTranslation({ x: 0, y: 2, z: 0 });\r\n            // col.setTranslationWrtParent(new Vector3(0,2,0));\r\n\r\n        }\r\n    }\r\n\r\n    updatePhysicsMaterial(col: ICollider) {\r\n        if (!col) return;\r\n        const physicsMaterial = col.sharedMaterial;\r\n        const rapier_collider = col[$bodyKey] as Collider;\r\n        if (!rapier_collider) return;\r\n\r\n        if (physicsMaterial) {\r\n            if (physicsMaterial.bounciness !== undefined)\r\n                rapier_collider.setRestitution(physicsMaterial.bounciness);\r\n\r\n            if (physicsMaterial.bounceCombine !== undefined) {\r\n                switch (physicsMaterial.bounceCombine) {\r\n                    case PhysicsMaterialCombine.Average:\r\n                        rapier_collider.setRestitutionCombineRule(CoefficientCombineRule.Average);\r\n                        break;\r\n                    case PhysicsMaterialCombine.Maximum:\r\n                        rapier_collider.setRestitutionCombineRule(CoefficientCombineRule.Max);\r\n                        break;\r\n                    case PhysicsMaterialCombine.Minimum:\r\n                        rapier_collider.setRestitutionCombineRule(CoefficientCombineRule.Min);\r\n                        break;\r\n                    case PhysicsMaterialCombine.Multiply:\r\n                        rapier_collider.setRestitutionCombineRule(CoefficientCombineRule.Multiply);\r\n                        break;\r\n                }\r\n            }\r\n\r\n            if (physicsMaterial.dynamicFriction !== undefined)\r\n                rapier_collider.setFriction(physicsMaterial.dynamicFriction);\r\n\r\n            if (physicsMaterial.frictionCombine !== undefined) {\r\n                switch (physicsMaterial.frictionCombine) {\r\n                    case PhysicsMaterialCombine.Average:\r\n                        rapier_collider.setFrictionCombineRule(CoefficientCombineRule.Average);\r\n                        break;\r\n                    case PhysicsMaterialCombine.Maximum:\r\n                        rapier_collider.setFrictionCombineRule(CoefficientCombineRule.Max);\r\n                        break;\r\n                    case PhysicsMaterialCombine.Minimum:\r\n                        rapier_collider.setFrictionCombineRule(CoefficientCombineRule.Min);\r\n                        break;\r\n                    case PhysicsMaterialCombine.Multiply:\r\n                        rapier_collider.setFrictionCombineRule(CoefficientCombineRule.Multiply);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Get the rapier body for a Needle component */\r\n    getBody(obj: ICollider | IRigidbody): null | any {\r\n        if (!obj) return null;\r\n        const body = obj[$bodyKey];\r\n        return body;\r\n    }\r\n\r\n    /** Get the Needle Engine component for a rapier object */\r\n    getComponent(rapierObject: object): IComponent | null {\r\n        if (!rapierObject) return null;\r\n        const component = rapierObject[$componentKey];\r\n        return component;\r\n    }\r\n\r\n    private createCollider(collider: ICollider, desc: ColliderDesc) {\r\n        if (!this.world) throw new Error(\"Physics world not initialized\");\r\n        const matrix = this._tempMatrix;\r\n        let rigidBody: RigidBody | undefined = undefined;\r\n        if (!collider.attachedRigidbody) {\r\n            if (debugPhysics) console.log(\"Create collider without rigidbody\", collider.name);\r\n            matrix.makeRotationFromQuaternion(getWorldQuaternion(collider.gameObject));\r\n            matrix.setPosition(getWorldPosition(collider.gameObject));\r\n        }\r\n        else {\r\n            rigidBody = this.getRigidbody(collider, this._tempMatrix);\r\n        }\r\n\r\n        matrix.decompose(this._tempPosition, this._tempQuaternion, this._tempScale);\r\n        this.tryApplyCenter(collider, this._tempPosition);\r\n        desc.setTranslation(this._tempPosition.x, this._tempPosition.y, this._tempPosition.z);\r\n        desc.setRotation(this._tempQuaternion);\r\n        desc.setSensor(collider.isTrigger);\r\n\r\n        // TODO: we might want to update this if the material changes\r\n        const physicsMaterial = collider.sharedMaterial;\r\n        if (physicsMaterial) {\r\n\r\n            if (physicsMaterial.bounciness !== undefined)\r\n                desc.setRestitution(physicsMaterial.bounciness);\r\n\r\n            if (physicsMaterial.bounceCombine !== undefined) {\r\n                switch (physicsMaterial.bounceCombine) {\r\n                    case PhysicsMaterialCombine.Average:\r\n                        desc.setRestitutionCombineRule(CoefficientCombineRule.Average);\r\n                        break;\r\n                    case PhysicsMaterialCombine.Maximum:\r\n                        desc.setRestitutionCombineRule(CoefficientCombineRule.Max);\r\n                        break;\r\n                    case PhysicsMaterialCombine.Minimum:\r\n                        desc.setRestitutionCombineRule(CoefficientCombineRule.Min);\r\n                        break;\r\n                    case PhysicsMaterialCombine.Multiply:\r\n                        desc.setRestitutionCombineRule(CoefficientCombineRule.Multiply);\r\n                        break;\r\n                }\r\n            }\r\n\r\n            if (physicsMaterial.dynamicFriction !== undefined)\r\n                desc.setFriction(physicsMaterial.dynamicFriction);\r\n\r\n            if (physicsMaterial.frictionCombine !== undefined) {\r\n                switch (physicsMaterial.frictionCombine) {\r\n                    case PhysicsMaterialCombine.Average:\r\n                        desc.setFrictionCombineRule(CoefficientCombineRule.Average);\r\n                        break;\r\n                    case PhysicsMaterialCombine.Maximum:\r\n                        desc.setFrictionCombineRule(CoefficientCombineRule.Max);\r\n                        break;\r\n                    case PhysicsMaterialCombine.Minimum:\r\n                        desc.setFrictionCombineRule(CoefficientCombineRule.Min);\r\n                        break;\r\n                    case PhysicsMaterialCombine.Multiply:\r\n                        desc.setFrictionCombineRule(CoefficientCombineRule.Multiply);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        // if we want to use explicit mass properties, we need to set the collider density to 0\r\n        // otherwise rapier will compute the mass properties based on the collider shape and density\r\n        // https://rapier.rs/docs/user_guides/javascript/rigid_bodies#mass-properties\r\n        if (collider.attachedRigidbody?.autoMass === false) {\r\n            desc.setDensity(.000001);\r\n            desc.setMass(.000001);\r\n        }\r\n\r\n        try {\r\n            const col = this.world.createCollider(desc, rigidBody);\r\n            col[$componentKey] = collider;\r\n            collider[$bodyKey] = col;\r\n            col.setActiveEvents(ActiveEvents.COLLISION_EVENTS);\r\n            // We want to receive collisitons between two triggers too\r\n            col.setActiveCollisionTypes(ActiveCollisionTypes.ALL);\r\n            this.objects.push(collider);\r\n            this.bodies.push(col);\r\n\r\n            // set the collider layers\r\n            this.updateColliderCollisionGroups(collider);\r\n\r\n            return col;\r\n        }\r\n        catch (e) {\r\n            console.error(\"Error creating collider \\\"\" + collider.name + \"\\\"\\nError:\", e);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the collision groups of a collider.\r\n     * \r\n     * @param collider - The collider to update.\r\n     */\r\n    private updateColliderCollisionGroups(collider: ICollider) {\r\n        const body = collider[$bodyKey] as Collider;\r\n        const members = collider.membership;\r\n        let memberMask = 0;\r\n        if (members == undefined) {\r\n            memberMask = 0xffff;\r\n        }\r\n        else {\r\n            for (let i = 0; i < members.length; i++) {\r\n                const member = members[i];\r\n                if (member > 31) console.error(`Rapier only supports 32 layers, layer ${member} is not supported`);\r\n                else memberMask |= 1 << Math.floor(member);\r\n            }\r\n        }\r\n\r\n        const mask = collider.filter;\r\n        let filterMask = 0;\r\n        if (mask == undefined) {\r\n            filterMask = 0xffff;\r\n        }\r\n        else {\r\n            for (let i = 0; i < mask.length; i++) {\r\n                const member = mask[i];\r\n                if (member > 31) console.error(`Rapier only supports 32 layers, layer ${member} is not supported`);\r\n                else filterMask |= 1 << Math.floor(member);\r\n            }\r\n        }\r\n        body.setCollisionGroups((memberMask << 16) | filterMask);\r\n    }\r\n\r\n    private getRigidbody(collider: ICollider, _matrix: Matrix4): RigidBody {\r\n\r\n        if (!this.world) throw new Error(\"Physics world not initialized\");\r\n        let rigidBody: RigidBody | null = null;\r\n\r\n        if (collider.attachedRigidbody) {\r\n            const rb = collider.attachedRigidbody;\r\n            rigidBody = rb[$bodyKey];\r\n            if (!rigidBody) {\r\n                const kinematic = rb.isKinematic && !debugColliderPlacement;\r\n                if (debugPhysics)\r\n                    console.log(\"Create rigidbody\", kinematic);\r\n                const rigidBodyDesc = (kinematic ? RAPIER.RigidBodyDesc.kinematicPositionBased() : RAPIER.RigidBodyDesc.dynamic()) as RigidBodyDesc;\r\n                const pos = getWorldPosition(collider.attachedRigidbody.gameObject);\r\n                rigidBodyDesc.setTranslation(pos.x, pos.y, pos.z);\r\n                rigidBodyDesc.setRotation(getWorldQuaternion(collider.attachedRigidbody.gameObject));\r\n                rigidBodyDesc.centerOfMass = new RAPIER.Vector3(rb.centerOfMass.x, rb.centerOfMass.y, rb.centerOfMass.z);\r\n                rigidBody = this.world.createRigidBody(rigidBodyDesc);\r\n                this.bodies.push(rigidBody);\r\n                this.objects.push(rb);\r\n            }\r\n            rigidBody[$componentKey] = rb;\r\n            rb[$bodyKey] = rigidBody;\r\n            this.internalUpdateRigidbodyProperties(rb, rigidBody);\r\n            this.getRigidbodyRelativeMatrix(collider.gameObject, rb.gameObject, _matrix);\r\n            collider[$colliderRigidbody] = rigidBody;\r\n        }\r\n        else {\r\n            const rigidBodyDesc = RAPIER.RigidBodyDesc.kinematicPositionBased();\r\n            const pos = getWorldPosition(collider.gameObject);\r\n            rigidBodyDesc.setTranslation(pos.x, pos.y, pos.z);\r\n            rigidBodyDesc.setRotation(getWorldQuaternion(collider.gameObject));\r\n            rigidBody = this.world.createRigidBody(rigidBodyDesc);\r\n            _matrix.identity();\r\n            rigidBody[$componentKey] = null;\r\n        }\r\n\r\n\r\n        return rigidBody;\r\n    }\r\n\r\n    private internal_getRigidbody(rb: IRigidbody | ICollider): RigidBody | null {\r\n        if ((rb as ICollider).isCollider === true) return rb[$colliderRigidbody] as RigidBody;\r\n        return rb[$bodyKey] as RigidBody;\r\n    }\r\n\r\n    private internalUpdateColliderProperties(col: ICollider, collider: Collider) {\r\n        const shape = collider.shape;\r\n        let sizeHasChanged = false;\r\n        switch (shape.type) {\r\n            // Sphere Collider\r\n            case ShapeType.Ball:\r\n                {\r\n                    const ball = shape as Ball;\r\n                    const sc = col as ISphereCollider;\r\n                    const obj = col.gameObject;\r\n                    const scale = getWorldScale(obj, this._tempPosition);\r\n                    const radius = Math.abs(sc.radius * scale.x);\r\n                    sizeHasChanged = ball.radius !== radius;\r\n                    ball.radius = radius;\r\n                    if (sizeHasChanged) {\r\n                        collider.setShape(ball);\r\n                    }\r\n                    break;\r\n                }\r\n            case ShapeType.Cuboid:\r\n                const cuboid = shape as Cuboid;\r\n                const sc = col as IBoxCollider;\r\n                const obj = col.gameObject;\r\n                const scale = getWorldScale(obj, this._tempPosition);\r\n                const newX = sc.size.x * 0.5 * scale.x;\r\n                const newY = sc.size.y * 0.5 * scale.y;\r\n                const newZ = sc.size.z * 0.5 * scale.z;\r\n                sizeHasChanged = cuboid.halfExtents.x !== newX || cuboid.halfExtents.y !== newY || cuboid.halfExtents.z !== newZ;\r\n                cuboid.halfExtents.x = newX;\r\n                cuboid.halfExtents.y = newY;\r\n                cuboid.halfExtents.z = newZ;\r\n                if (sizeHasChanged) {\r\n                    collider.setShape(cuboid);\r\n                }\r\n                break;\r\n        }\r\n\r\n        if (sizeHasChanged) {\r\n            const rb = col.attachedRigidbody;\r\n            if (rb?.autoMass) {\r\n                const ph = this.getBody(rb) as RigidBody\r\n                ph?.recomputeMassPropertiesFromColliders();\r\n            }\r\n        }\r\n\r\n        this.updateColliderCollisionGroups(col);\r\n\r\n        if (col.isTrigger !== collider.isSensor())\r\n            collider.setSensor(col.isTrigger);\r\n    }\r\n\r\n    private internalUpdateRigidbodyProperties(rb: IRigidbody, rigidbody: RigidBody) {\r\n        // continuous collision detection \r\n        // https://rapier.rs/docs/user_guides/javascript/rigid_bodies#continuous-collision-detection\r\n        rigidbody.enableCcd(rb.collisionDetectionMode !== CollisionDetectionMode.Discrete);\r\n        rigidbody.setLinearDamping(rb.drag);\r\n        rigidbody.setAngularDamping(rb.angularDrag);\r\n        rigidbody.setGravityScale(rb.useGravity ? rb.gravityScale : 0, true);\r\n\r\n        // https://rapier.rs/docs/user_guides/javascript/rigid_bodies#dominance\r\n        if (rb.dominanceGroup <= 127 && rb.dominanceGroup >= -127)\r\n            rigidbody.setDominanceGroup(Math.floor(rb.dominanceGroup))\r\n        else rigidbody.setDominanceGroup(0);\r\n\r\n        if (rb.autoMass) {\r\n            rigidbody.setAdditionalMass(0, false);\r\n            for (let i = 0; i < rigidbody.numColliders(); i++) {\r\n                const col = rigidbody.collider(i);\r\n                col.setDensity(1);\r\n            }\r\n            rigidbody.recomputeMassPropertiesFromColliders();\r\n        }\r\n        else {\r\n            rigidbody.setAdditionalMass(rb.mass, false);\r\n            for (let i = 0; i < rigidbody.numColliders(); i++) {\r\n                const col = rigidbody.collider(i);\r\n                col.setDensity(0.0000001);\r\n            }\r\n            rigidbody.recomputeMassPropertiesFromColliders();\r\n        }\r\n\r\n        // https://rapier.rs/docs/user_guides/javascript/rigid_bodies#mass-properties\r\n        // rigidbody.setAdditionalMass(rb.mass, true);\r\n        // for (let i = 0; i < rigidbody.numColliders(); i++) {\r\n        //     const collider = rigidbody.collider(i);\r\n        //     if (collider) {\r\n        //         collider.setMass(rb.mass);\r\n        //         // const density = rb.mass / collider.shape.computeMassProperties().mass;\r\n        //     }\r\n        // }\r\n\r\n        // lock rotations\r\n        rigidbody.setEnabledRotations(!rb.lockRotationX, !rb.lockRotationY, !rb.lockRotationZ, false);\r\n        rigidbody.setEnabledTranslations(!rb.lockPositionX, !rb.lockPositionY, !rb.lockPositionZ, false);\r\n\r\n        if (rb.isKinematic) {\r\n            rigidbody.setBodyType(RAPIER.RigidBodyType.KinematicPositionBased, false);\r\n        }\r\n        else {\r\n            rigidbody.setBodyType(RAPIER.RigidBodyType.Dynamic, false);\r\n        }\r\n    }\r\n\r\n    // private _lastStepTime: number | undefined = 0;\r\n    private lines?: LineSegments;\r\n\r\n    public step(dt?: number) {\r\n        if (!this.world) return;\r\n        if (!this.enabled) return;\r\n        this._isUpdatingPhysicsWorld = true;\r\n        if (!this.eventQueue) {\r\n            this.eventQueue = new EventQueue(false);\r\n        }\r\n        if (dt === undefined || dt <= 0) {\r\n            this._isUpdatingPhysicsWorld = false;\r\n            return;\r\n        }\r\n        else if (dt !== undefined) {\r\n            // if we make to sudden changes to the timestep the physics can get unstable\r\n            // https://rapier.rs/docs/user_guides/javascript/integration_parameters/#dt\r\n            this.world.timestep = Mathf.lerp(this.world.timestep, dt, 0.8);\r\n        }\r\n        try {\r\n            this.world.step(this.eventQueue);\r\n        }\r\n        catch (e) {\r\n            console.warn(\"Error running physics step\", e);\r\n        }\r\n        this._isUpdatingPhysicsWorld = false;\r\n    }\r\n\r\n    public postStep() {\r\n        if (!this.world) return;\r\n        if (!this.enabled) return;\r\n        this._isUpdatingPhysicsWorld = true;\r\n        this.syncObjects();\r\n        this._isUpdatingPhysicsWorld = false;\r\n\r\n        if (this.eventQueue && !this.collisionHandler) {\r\n            this.collisionHandler = new PhysicsCollisionHandler(this.world, this.eventQueue);\r\n        }\r\n        if (this.collisionHandler) {\r\n            this.collisionHandler.handleCollisionEvents();\r\n            this.collisionHandler.update();\r\n        }\r\n        this.updateDebugRendering(this.world);\r\n    }\r\n\r\n    private updateDebugRendering(world: World) {\r\n        if (debugPhysics || debugColliderPlacement || showColliders || this.debugRenderColliders === true) {\r\n            if (!this.lines) {\r\n                const material = new LineBasicMaterial({\r\n                    color: 0x77dd77,\r\n                    fog: false,\r\n                    // vertexColors: VertexColors\r\n                });\r\n                const geometry = new BufferGeometry();\r\n                this.lines = new LineSegments(geometry, material);\r\n                this.lines.layers.disableAll();\r\n                this.lines.layers.enable(2);\r\n            }\r\n            if (this.lines.parent !== this.context?.scene)\r\n                this.context?.scene.add(this.lines);\r\n            const buffers = world.debugRender();\r\n            this.lines.geometry.setAttribute('position', new BufferAttribute(buffers.vertices, 3));\r\n            this.lines.geometry.setAttribute('color', new BufferAttribute(buffers.colors, 4));\r\n            // If a scene has no colliders at all at the start of the scene\r\n            // the bounding sphere radius will be 0 and the lines will not be rendered\r\n            // so we need to update the bounding sphere (perhaps it's enough to do this once...)\r\n            if (this.context!.time.frame % 30 === 0 || this.lines.geometry.boundingSphere?.radius === 0) {\r\n                this.lines.geometry.computeBoundingSphere();\r\n            }\r\n        }\r\n        else {\r\n            if (this.lines) {\r\n                this.context?.scene.remove(this.lines);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** sync rendered objects with physics world (except for colliders without rigidbody) */\r\n    private syncObjects() {\r\n        if (debugColliderPlacement) return;\r\n        for (let i = 0; i < this.bodies.length; i++) {\r\n            const obj = this.objects[i];\r\n            const body = this.bodies[i] as Collider;\r\n\r\n            // if the collider is not attached to a rigidbody\r\n            // it means that its kinematic so we need to update its position\r\n            const col = (obj as ICollider);\r\n            if (col?.isCollider === true && !col.attachedRigidbody) {\r\n                const rigidbody = body.parent();\r\n                if (rigidbody)\r\n                    this.syncPhysicsBody(obj.gameObject, rigidbody, true, true);\r\n                else\r\n                    this.syncPhysicsBody(obj.gameObject, body, true, true);\r\n                continue;\r\n            }\r\n\r\n\r\n            // sync\r\n            const pos = body.translation();\r\n            const rot = body.rotation();\r\n            if (Number.isNaN(pos.x) || Number.isNaN(rot.x)) {\r\n                if (!col[\"__COLLIDER_NAN\"] && isDevEnvironment()) {\r\n                    console.warn(\"Collider has NaN values\", col.name, col.gameObject, body);\r\n                    col[\"__COLLIDER_NAN\"] = true;\r\n                }\r\n                continue;\r\n            }\r\n\r\n            // make sure to keep the collider offset\r\n            const center = obj[\"center\"] as Vector3;\r\n            if (center && center.isVector3) {\r\n                this._tempQuaternion.set(rot.x, rot.y, rot.z, rot.w);\r\n                const offset = this._tempPosition.copy(center).applyQuaternion(this._tempQuaternion);\r\n                const scale = getWorldScale(obj.gameObject);\r\n                offset.multiply(scale);\r\n                pos.x -= offset.x;\r\n                pos.y -= offset.y;\r\n                pos.z -= offset.z;\r\n            }\r\n            setWorldPositionXYZ(obj.gameObject, pos.x, pos.y, pos.z);\r\n            setWorldQuaternionXYZW(obj.gameObject, rot.x, rot.y, rot.z, rot.w);\r\n        }\r\n    }\r\n\r\n    private syncPhysicsBody(obj: Object3D, body: RigidBody | Collider, translation: boolean, rotation: boolean) {\r\n\r\n        // const bodyType = body.bodyType();\r\n        // const previous = physicsBody.translation();\r\n        // const vel = physicsBody.linvel();\r\n\r\n        if (body instanceof RigidBody) {\r\n            const worldPosition = getWorldPosition(obj, this._tempPosition);\r\n            const worldQuaternion = getWorldQuaternion(obj, this._tempQuaternion);\r\n            const type = body.bodyType();\r\n            switch (type) {\r\n                case RigidBodyType.Fixed:\r\n                case RigidBodyType.KinematicPositionBased:\r\n                case RigidBodyType.KinematicVelocityBased:\r\n                    if (translation)\r\n                        body.setNextKinematicTranslation(worldPosition);\r\n                    if (rotation)\r\n                        body.setNextKinematicRotation(worldQuaternion);\r\n                    break;\r\n                default:\r\n                    if (translation)\r\n                        body.setTranslation(worldPosition, false);\r\n                    if (rotation)\r\n                        body.setRotation(worldQuaternion, false);\r\n                    break;\r\n\r\n            }\r\n        }\r\n        else if (body instanceof Collider) {\r\n            if (obj.matrixWorldNeedsUpdate) {\r\n                obj.updateWorldMatrix(true, false);\r\n            }\r\n            obj.matrixWorld.decompose(this._tempPosition, this._tempQuaternion, this._tempScale);\r\n            const wp = this._tempPosition;\r\n            const wq = this._tempQuaternion;\r\n            // const wp = getWorldPosition(obj, this._tempPosition);\r\n            // const wq = getWorldQuaternion(obj, this._tempQuaternion);\r\n            const collider = body[$componentKey] as ICollider;\r\n            this.tryApplyCenter(collider, wp);\r\n\r\n            // we need to check if translation or rotation have changed, otherwise the physics engine will wakeup rigidbody that are in contact with this collider\r\n            if (translation) {\r\n                const ct = body.translation();\r\n                if (ct.x !== wp.x || ct.y !== wp.y || ct.z !== wp.z)\r\n                    body.setTranslation(wp);\r\n            }\r\n            if (rotation) {\r\n                const cr = body.rotation();\r\n                if (cr.x !== wq.x || cr.y !== wq.y || cr.z !== wq.z || cr.w !== wq.w)\r\n                    body.setRotation(wq);\r\n            }\r\n        }\r\n\r\n        // physicsBody.setBodyType(RAPIER.RigidBodyType.Fixed);\r\n        // physicsBody.setLinvel(vel, false);\r\n\r\n        // update velocity\r\n        // const pos = physicsBody.translation();\r\n        // pos.x -= previous.x;\r\n        // pos.y -= previous.y;\r\n        // pos.z -= previous.z;\r\n        // // threhold\r\n        // const t = 1;\r\n        // const canUpdateVelocity = Math.abs(pos.x) < t && Math.abs(pos.y) < t && Math.abs(pos.z) < t;\r\n        // if (canUpdateVelocity) {\r\n        //     const damping = 1 + this.context.time.deltaTime;\r\n        //     vel.x *= damping;\r\n        //     vel.y *= damping;\r\n        //     vel.z *= damping;\r\n        //     vel.x += pos.x;\r\n        //     vel.y += pos.y;\r\n        //     vel.z += pos.z;\r\n        //     console.log(vel);\r\n        //     physicsBody.setLinvel(vel, true);\r\n        // }\r\n        // else if(debugPhysics) console.warn(\"Movement exceeded threshold, not updating velocity\", pos);\r\n\r\n        // body.setBodyType(bodyType);\r\n    }\r\n\r\n    private readonly _tempCenterPos: Vector3 = new Vector3();\r\n    private readonly _tempCenterVec: Vector3 = new Vector3();\r\n    private readonly _tempCenterQuaternion: Quaternion = new Quaternion();\r\n    private tryApplyCenter(collider: ICollider, targetVector: Vector3) {\r\n        const center = collider.center;\r\n        if (center && collider.gameObject) {\r\n            if (center.x !== 0 || center.y !== 0 || center.z !== 0) {\r\n                // TODO: fix export of center in editor integrations so we dont have to flip here\r\n                this._tempCenterPos.x = center.x;\r\n                this._tempCenterPos.y = center.y;\r\n                this._tempCenterPos.z = center.z;\r\n                getWorldScale(collider.gameObject, this._tempCenterVec);\r\n                this._tempCenterPos.multiply(this._tempCenterVec);\r\n                if (!collider.attachedRigidbody) {\r\n                    getWorldQuaternion(collider.gameObject, this._tempCenterQuaternion);\r\n                    this._tempCenterPos.applyQuaternion(this._tempCenterQuaternion);\r\n                }\r\n                else {\r\n                    this._tempCenterPos.applyQuaternion(collider.gameObject.quaternion);\r\n                }\r\n                targetVector.x += this._tempCenterPos.x;\r\n                targetVector.y += this._tempCenterPos.y;\r\n                targetVector.z += this._tempCenterPos.z;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _matricesBuffer: Matrix4[] = [];\r\n    private getRigidbodyRelativeMatrix(comp: Object3D, rigidbody: Object3D, mat: Matrix4, matrices?: Matrix4[]): Matrix4 {\r\n        // collect all matrices to the rigidbody and then build the rigidbody relative matrix\r\n        if (matrices === undefined) {\r\n            matrices = RapierPhysics._matricesBuffer;\r\n            matrices.length = 0;\r\n        }\r\n        if (comp === rigidbody) {\r\n            const scale = getWorldScale(comp, this._tempPosition);\r\n            mat.makeScale(scale.x, scale.y, scale.z);\r\n            for (let i = matrices.length - 1; i >= 0; i--) {\r\n                mat.multiply(matrices[i]);\r\n            }\r\n            return mat;\r\n        }\r\n        matrices.push(comp.matrix);\r\n        if (comp.parent) {\r\n            this.getRigidbodyRelativeMatrix(comp.parent, rigidbody, mat, matrices);\r\n        }\r\n        return mat;\r\n    }\r\n\r\n    private static centerConnectionPos = { x: 0, y: 0, z: 0 };\r\n    private static centerConnectionRot = { x: 0, y: 0, z: 0, w: 1 };\r\n\r\n\r\n\r\n    addFixedJoint(body1: IRigidbody, body2: IRigidbody) {\r\n        if (!this.world) {\r\n            console.error(\"Physics world not initialized\");\r\n            return;\r\n        }\r\n        const b1 = body1[$bodyKey] as RigidBody;\r\n        const b2 = body2[$bodyKey] as RigidBody;\r\n\r\n        this.calculateJointRelativeMatrices(body1.gameObject, body2.gameObject, this._tempMatrix);\r\n        this._tempMatrix.decompose(this._tempPosition, this._tempQuaternion, this._tempScale);\r\n\r\n        const params = JointData.fixed(\r\n            RapierPhysics.centerConnectionPos, RapierPhysics.centerConnectionRot,\r\n            this._tempPosition, this._tempQuaternion,\r\n        );\r\n        const joint = this.world.createImpulseJoint(params, b1, b2, true);\r\n        if (debugPhysics)\r\n            console.log(\"ADD FIXED JOINT\", joint)\r\n    }\r\n\r\n\r\n    /** The joint prevents any relative movement between two rigid-bodies, except for relative rotations along one axis. This is typically used to simulate wheels, fans, etc. They are characterized by one local anchor as well as one local axis on each rigid-body. */\r\n    addHingeJoint(body1: IRigidbody, body2: IRigidbody, anchor: { x: number, y: number, z: number }, axis: { x: number, y: number, z: number }) {\r\n        if (!this.world) {\r\n            console.error(\"Physics world not initialized\");\r\n            return;\r\n        }\r\n        const b1 = body1[$bodyKey] as RigidBody;\r\n        const b2 = body2[$bodyKey] as RigidBody;\r\n\r\n        this.calculateJointRelativeMatrices(body1.gameObject, body2.gameObject, this._tempMatrix);\r\n        this._tempMatrix.decompose(this._tempPosition, this._tempQuaternion, this._tempScale);\r\n\r\n        const params = RAPIER.JointData.revolute(anchor, this._tempPosition, axis);\r\n        const joint = this.world.createImpulseJoint(params, b1, b2, true);\r\n        if (debugPhysics)\r\n            console.log(\"ADD HINGE JOINT\", joint)\r\n    }\r\n\r\n\r\n    private calculateJointRelativeMatrices(body1: IGameObject, body2: IGameObject, mat: Matrix4) {\r\n        body1.updateWorldMatrix(true, false);\r\n        body2.updateWorldMatrix(true, false);\r\n        const world1 = body1.matrixWorld;\r\n        const world2 = body2.matrixWorld;\r\n        // set scale to 1\r\n        world1.elements[0] = 1;\r\n        world1.elements[5] = 1;\r\n        world1.elements[10] = 1;\r\n        world2.elements[0] = 1;\r\n        world2.elements[5] = 1;\r\n        world2.elements[10] = 1;\r\n        mat.copy(world2).premultiply(world1.invert()).invert();\r\n    }\r\n}\r\n\r\n\r\n\r\n/** responsible of processing collision events for the component system */\r\nclass PhysicsCollisionHandler {\r\n\r\n    readonly world: World;\r\n    readonly eventQueue: EventQueue;\r\n\r\n    constructor(world: World, eventQueue: EventQueue) {\r\n        this.world = world;\r\n        this.eventQueue = eventQueue;\r\n    }\r\n\r\n    private activeCollisions: Array<{ collider: ICollider, component: IComponent, collision: Collision }> = [];\r\n    private activeCollisionsStay: Array<{ collider: ICollider, component: IComponent, collision: Collision }> = [];\r\n    private activeTriggers: Array<{ collider: ICollider, component: IComponent, otherCollider: ICollider }> = [];\r\n\r\n    handleCollisionEvents() {\r\n        if (!this.eventQueue) return;\r\n        if (!this.world) return;\r\n        this.eventQueue.drainCollisionEvents((handle1, handle2, started) => {\r\n            const col1 = this.world!.getCollider(handle1);\r\n            const col2 = this.world!.getCollider(handle2);\r\n            if (!col1 || !col2) return;\r\n            const colliderComponent1 = col1[$componentKey];\r\n            const colliderComponent2 = col2[$componentKey];\r\n            if (debugCollisions)\r\n                console.log(\"EVT\", colliderComponent1.name, colliderComponent2.name, started, col1, col2);\r\n            if (colliderComponent1 && colliderComponent2) {\r\n                if (started) {\r\n                    this.onCollisionStarted(colliderComponent1, col1, colliderComponent2, col2);\r\n                    this.onCollisionStarted(colliderComponent2, col2, colliderComponent1, col1);\r\n                }\r\n                else {\r\n                    this.onCollisionEnded(colliderComponent1, colliderComponent2);\r\n                    this.onCollisionEnded(colliderComponent2, colliderComponent1);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    update() {\r\n        this.onHandleCollisionStay();\r\n    }\r\n\r\n    private onCollisionStarted(self: ICollider, selfBody: Collider, other: ICollider, otherBody: Collider) {\r\n        let collision: Collision | null = null;\r\n\r\n        // if one is a trigger we dont get collisions but want to raise the trigger events\r\n        if (self.isTrigger || other.isTrigger) {\r\n            foreachComponent(self.gameObject, (c: IComponent) => {\r\n                if (c.onTriggerEnter && !c.destroyed) {\r\n                    c.onTriggerEnter(other);\r\n                }\r\n                this.activeTriggers.push({ collider: self, component: c, otherCollider: other });\r\n            });\r\n        }\r\n        else {\r\n            const object = self.gameObject;\r\n            // TODO: we dont respect the flip value here!\r\n            this.world.contactPair(selfBody, otherBody, (manifold, _flipped) => {\r\n                foreachComponent(object, (c: IComponent) => {\r\n                    if (c.destroyed) return;\r\n                    const hasDeclaredEventMethod = c.onCollisionEnter || c.onCollisionStay || c.onCollisionExit;\r\n                    if (hasDeclaredEventMethod || debugCollisions) {\r\n                        if (!collision) {\r\n                            const contacts: Array<ContactPoint> = [];\r\n                            const normal = manifold.normal();\r\n                            for (let i = 0; i < manifold.numSolverContacts(); i++) {\r\n                                // solver points are in world space\r\n                                // https://rapier.rs/docs/user_guides/javascript/advanced_collision_detection_js#the-contact-graph\r\n                                const pt = manifold.solverContactPoint(i);\r\n                                const impulse = manifold.contactImpulse(i);\r\n                                if (pt) {\r\n                                    const dist = manifold.contactDist(i);\r\n                                    const friction = manifold.solverContactFriction(i);\r\n                                    const tangentVelocity = manifold.solverContactTangentVelocity(i);\r\n                                    const contact = new ContactPoint(pt, dist, normal, impulse, friction, tangentVelocity);\r\n                                    contacts.push(contact);\r\n                                    if (debugCollisions) {\r\n                                        Gizmos.DrawDirection(pt, normal, 0xff0000, 3, true);\r\n                                    }\r\n                                }\r\n                            }\r\n                            collision = new Collision(object, other, contacts);\r\n                        }\r\n\r\n                        // we only need to keep track if any event exists\r\n                        if (hasDeclaredEventMethod) {\r\n                            const info = { collider: self, component: c, collision };\r\n\r\n                            this.activeCollisions.push(info);\r\n                            if (c.onCollisionStay) {\r\n                                this.activeCollisionsStay.push(info);\r\n                            }\r\n\r\n                            c.onCollisionEnter?.call(c, collision);\r\n                        }\r\n\r\n                    }\r\n                });\r\n            });\r\n        }\r\n    }\r\n\r\n    private onHandleCollisionStay() {\r\n        for (const active of this.activeCollisionsStay) {\r\n            const c = active.component;\r\n            if (c.destroyed) continue;\r\n            if (c.activeAndEnabled && c.onCollisionStay) {\r\n                if (active.collision.collider.destroyed) continue;\r\n                const arg = active.collision;\r\n                c.onCollisionStay(arg);\r\n            }\r\n        }\r\n        for (const active of this.activeTriggers) {\r\n            const c = active.component;\r\n            if (c.destroyed) continue;\r\n            if (c.activeAndEnabled && c.onTriggerStay) {\r\n                const arg = active.otherCollider;\r\n                if (arg.destroyed) continue;\r\n                c.onTriggerStay(arg);\r\n            }\r\n        }\r\n    }\r\n\r\n    private onCollisionEnded(self: ICollider, other: ICollider) {\r\n        if (self.destroyed || other.destroyed) return;\r\n        for (let i = 0; i < this.activeCollisions.length; i++) {\r\n            const active = this.activeCollisions[i];\r\n            const collider = active.collider;\r\n            if (collider.destroyed || active.collision.collider.destroyed) {\r\n                this.activeCollisions.splice(i, 1);\r\n                i--;\r\n                continue;\r\n            }\r\n            if (collider === self && active.collision.collider === other) {\r\n                const c = active.component;\r\n                this.activeCollisions.splice(i, 1);\r\n                i--;\r\n                if (c.activeAndEnabled && c.onCollisionExit) {\r\n                    const collision = active.collision;\r\n                    c.onCollisionExit(collision);\r\n                }\r\n            }\r\n        }\r\n        for (let i = 0; i < this.activeCollisionsStay.length; i++) {\r\n            const active = this.activeCollisionsStay[i];\r\n            const collider = active.collider;\r\n            if (collider.destroyed || active.collision.collider.destroyed) {\r\n                this.activeCollisionsStay.splice(i, 1);\r\n                i--;\r\n                continue;\r\n            }\r\n            if (collider === self && active.collision.collider === other) {\r\n                const c = active.component;\r\n                this.activeCollisionsStay.splice(i, 1);\r\n                i--;\r\n                if (c.activeAndEnabled && c.onCollisionExit) {\r\n                    const collision = active.collision;\r\n                    c.onCollisionExit(collision);\r\n                }\r\n            }\r\n        }\r\n        for (let i = 0; i < this.activeTriggers.length; i++) {\r\n            const active = this.activeTriggers[i];\r\n            const collider = active.collider;\r\n            if (collider.destroyed || active.otherCollider.destroyed) {\r\n                this.activeTriggers.splice(i, 1);\r\n                i--;\r\n                continue;\r\n            }\r\n            if (collider === self && active.otherCollider === other) {\r\n                const c = active.component;\r\n                this.activeTriggers.splice(i, 1);\r\n                i--;\r\n                if (c.activeAndEnabled && c.onTriggerExit) {\r\n                    const collision = active.otherCollider;\r\n                    c.onTriggerExit(collision);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import { DataTextureLoader,EquirectangularReflectionMapping, Object3D, PerspectiveCamera, Scene, Vector3 } from \"three\";\r\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls.js\";\r\n\r\nimport { AssetReference } from \"./engine_addressables.js\";\r\nimport { getBoundingBox } from \"./engine_three_utils.js\";\r\n\r\ndeclare type ComparisonSceneOptions = {\r\n    /**\r\n     * An array of model urls to load\r\n     */\r\n    files: string[];\r\n    /**\r\n     * Optional dom element to attach the orbit controls to. By default this should be the WebGLRenderer.domElement\r\n     */\r\n    domElement?: HTMLElement;\r\n    /**\r\n     * Can be a .hdr or .exr file url\r\n     */\r\n    environment?: string;\r\n}\r\n\r\n/**\r\n * A collection of utility methods for quickly spinning up test environments\r\n */\r\nexport class TestSceneUtils {\r\n\r\n    /**\r\n     * Use this method to quickly setup a scene to compare multiple models.  \r\n     * @example\r\n     * ```ts\r\n     * const files = [\r\n     *    \"https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb\",\r\n     *   \"https://threejs.org/examples/models/gltf/Lantern/glTF-Binary/Lantern.glb\",\r\n     * ];\r\n     * const { scene, camera } = await TestUtils.createComparisonScene({ files });\r\n     * // this could now be assigned to the Needle Engine Context\r\n     * context.scene = scene;\r\n     * context.mainCamera = camera;\r\n     * ```\r\n     */\r\n    static async createComparisonScene(opts: ComparisonSceneOptions) {\r\n\r\n        const { files } = opts;\r\n\r\n        const promises = Promise.all(files.map(file => new AssetReference(file).loadAssetAsync()));\r\n        const results = await promises;\r\n        const scene = new Scene();\r\n\r\n        let offset = 0;\r\n        for (const result of results) {\r\n            if (result instanceof Object3D) {\r\n                result.position.y = offset;\r\n                scene.add(result);\r\n                const box = getBoundingBox([result]);\r\n                offset += box.getSize(new Vector3()).y;\r\n                offset += .1;\r\n            }\r\n        }\r\n        const camera = new PerspectiveCamera(20);\r\n        scene.add(camera);\r\n\r\n        // Load an environment map\r\n        const environmentUrl = opts.environment || \"https://dl.polyhaven.org/file/ph-assets/HDRIs/exr/1k/studio_small_09_1k.exr\";\r\n        if (environmentUrl) {\r\n            let loader: DataTextureLoader | null = null;\r\n            if (environmentUrl.endsWith(\".hdr\")) {\r\n                const RGBELoader = (await import(\"three/examples/jsm/loaders/RGBELoader.js\")).RGBELoader;\r\n                loader = new RGBELoader();\r\n            }\r\n            else if (environmentUrl.endsWith(\".exr\")) {\r\n                const EXRLoader = (await import(\"three/examples/jsm/loaders/EXRLoader.js\")).EXRLoader;\r\n                loader = new EXRLoader();\r\n            }\r\n            if (loader) {\r\n                const envmap = await loader.loadAsync(environmentUrl).catch((e) => { console.error(e); return null; });\r\n                if (envmap) {\r\n                    envmap.mapping = EquirectangularReflectionMapping;\r\n                    envmap.needsUpdate = true;\r\n                    scene.background = envmap;\r\n                    scene.environment = envmap;\r\n                    scene.backgroundBlurriness = .75;\r\n                }\r\n            }\r\n            else console.warn(\"Unsupported environment map format\", environmentUrl);\r\n        }\r\n\r\n        const box = getBoundingBox(scene.children);\r\n        const center = box.getCenter(new Vector3());\r\n        const size = box.getSize(new Vector3());\r\n        const max = Math.max(size.x, size.y, size.z);\r\n        const distance = max / (2 * Math.tan(Math.PI * camera.fov / 360));\r\n        camera.position.set(center.x, center.y, distance);\r\n        camera.lookAt(center);\r\n\r\n        const orbit = new OrbitControls(camera, opts.domElement || document.body);\r\n        orbit.target = center;\r\n        orbit.update();\r\n\r\n\r\n        const element = (opts.domElement || document.body).getBoundingClientRect();\r\n        camera.aspect = element.width / element.height;\r\n        camera.updateProjectionMatrix();\r\n\r\n        return {\r\n            scene,\r\n            camera\r\n        }\r\n    }\r\n}\r\n", "\r\n\r\nlet exportingStack: number = 0;\r\n\r\n/** @internal */\r\nexport function __isExporting(state: boolean) {\r\n    if (state) {\r\n        exportingStack++;\r\n    } else {\r\n        exportingStack--;\r\n    }\r\n}\r\n\r\n/**\r\n * Returns whether an export process is currently running.\r\n * @returns True if an export process is currently running, false otherwise.\r\n */\r\nexport function isExporting() {\r\n    return exportingStack > 0;\r\n}", "\r\nimport { Object3D, Texture } from 'three';\r\nimport { GLTFExporterPlugin, GLTFWriter } from 'three/examples/jsm/exporters/GLTFExporter.js';\r\n\r\nimport { Gizmos } from '../../engine_gizmos.js';\r\nimport { createFlatTexture } from '../../engine_shaders.js';\r\nimport { RGBAColor } from '../../js-extensions/index.js';\r\n\r\ndeclare type BeforeWriteArgs = { keep: boolean };\r\n\r\nexport abstract class BaseWriter implements GLTFExporterPlugin {\r\n    private readonly writer: GLTFWriter;\r\n    constructor(writer: GLTFWriter) {\r\n        this.writer = writer;\r\n    }\r\n    writeNode(_node: Object3D) { }\r\n}\r\n\r\nexport class GizmoWriter extends BaseWriter {\r\n\r\n    beforeWriteNode(node: Object3D, args: BeforeWriteArgs) {\r\n        if (Gizmos.isGizmo(node)) {\r\n            args.keep = false;\r\n        }\r\n    }\r\n\r\n}\r\n\r\nexport class RenderTextureWriter extends BaseWriter {\r\n\r\n    beforeWriteTexture(texture: Texture, args: BeforeWriteArgs & { newTexture?: Texture }) {\r\n        if (texture.isRenderTargetTexture) {\r\n            args.newTexture = createFlatTexture(new RGBAColor(1, 1, 1, 0))\r\n        }\r\n    }\r\n}", "import { AnimationClip, Object3D } from \"three\";\r\nimport { GLTFExporter, GLTFExporterOptions } from \"three/examples/jsm/exporters/GLTFExporter.js\";\r\n\r\nimport GLTFMeshGPUInstancingExtension from \"../../../include/three/EXT_mesh_gpu_instancing_exporter.js\";\r\nimport { AnimationUtils } from \"../../engine_animation.js\";\r\nimport type { Context } from \"../../engine_setup.js\";\r\nimport { registerExportExtensions } from \"../../extensions/index.js\";\r\nimport { __isExporting } from \"../state.js\";\r\nimport { GizmoWriter as GLTFGizmoWriter, RenderTextureWriter as GLTFRenderTextureWriter } from \"./Writers.js\";\r\n\r\ndeclare type ExportOptions = {\r\n    context: Context,\r\n    scene?: Object3D | Array<Object3D>,\r\n    binary?: boolean,\r\n    animations?: boolean,\r\n    downloadAs?: string,\r\n}\r\n\r\nconst DEFAULT_OPTIONS: Omit<ExportOptions, \"context\" | \"scene\"> = {\r\n    binary: true,\r\n    animations: true,\r\n}\r\n\r\nexport async function exportAsGLTF(_opts: ExportOptions): Promise<ArrayBuffer | Record<string, any>> {\r\n\r\n    if (!_opts.context) {\r\n        throw new Error(\"No context provided to exportAsGLTF\");\r\n    }\r\n\r\n    if (!_opts.scene) {\r\n        _opts.scene = _opts.context.scene;\r\n    }\r\n\r\n    const opts = {\r\n        ...DEFAULT_OPTIONS,\r\n        ..._opts\r\n    } as Required<ExportOptions>;\r\n\r\n    const { context } = opts;\r\n\r\n    const exporter = new GLTFExporter();\r\n    exporter.register(writer => new GLTFMeshGPUInstancingExtension(writer));\r\n    exporter.register(writer => new GLTFGizmoWriter(writer));\r\n    exporter.register(writer => new GLTFRenderTextureWriter(writer));\r\n    registerExportExtensions(exporter, opts.context);\r\n\r\n    const exporterOptions: GLTFExporterOptions = {\r\n        binary: opts.binary,\r\n        animations: collectAnimations(context, opts.scene, []),\r\n    }\r\n    const state = new ExporterState();\r\n\r\n    console.log(\"Exporting GLTF\", exporterOptions);\r\n    state.onBeforeExport(opts);\r\n    __isExporting(true);\r\n    const res = await exporter.parseAsync(opts.scene, exporterOptions).catch((e) => {\r\n        console.error(e);\r\n        return null;\r\n    });\r\n    __isExporting(false);\r\n    state.onAfterExport(opts);\r\n\r\n    if (!res) {\r\n        throw new Error(\"Failed to export GLTF\");\r\n    }\r\n\r\n    if (opts.downloadAs != undefined) {\r\n        let blob: Blob | null = null;\r\n        if (res instanceof ArrayBuffer) {\r\n            blob = new Blob([res], { type: \"application/octet-stream\" });\r\n        }\r\n        else {\r\n            console.error(\"Can not download GLTF as a blob\", res);\r\n        }\r\n\r\n        if (blob) {\r\n            const url = URL.createObjectURL(blob);\r\n            const a = document.createElement(\"a\");\r\n            a.href = url;\r\n            let name = opts.downloadAs;\r\n            if (!name.endsWith(\".glb\") && !name.endsWith(\".gltf\")) {\r\n                name += opts.binary ? \".glb\" : \".gltf\";\r\n            }\r\n            a.download = name;\r\n            a.click();\r\n        }\r\n    }\r\n\r\n    return res;\r\n}\r\n\r\n\r\nconst ACTIONS_WEIGHT_KEY = Symbol(\"needle:weight\");\r\n\r\nclass ExporterState {\r\n\r\n    private readonly _undo: Array<() => void> = [];\r\n\r\n    onBeforeExport(opts: Required<ExportOptions>) {\r\n        opts.context.animations.mixers.forEach(mixer => {\r\n            const actions = AnimationUtils.tryGetActionsFromMixer(mixer);\r\n            if (actions) {\r\n                for (let i = 0; i < actions.length; i++) {\r\n                    const action = actions[i];\r\n                    action[ACTIONS_WEIGHT_KEY] = action.weight;\r\n                    action.weight = 0;\r\n                    this._undo.push(() => { action.weight = action[ACTIONS_WEIGHT_KEY]; });\r\n                }\r\n            }\r\n            mixer.update(0);\r\n        })\r\n    }\r\n\r\n    onAfterExport(_opts: Required<ExportOptions>) {\r\n        this._undo.forEach(fn => fn());\r\n        this._undo.length = 0;\r\n    }\r\n\r\n}\r\n\r\n\r\nfunction collectAnimations(context: Context, scene: Object3D | Array<Object3D>, clips: Array<AnimationClip>): Array<AnimationClip> {\r\n\r\n    // Get all animations that are used by any mixer in the scene\r\n    // technically we might also collect animations here that aren't used by any object in the scene because they're part of another scene\r\n    // But that's a problem for later...\r\n    context.animations.mixers.forEach(mixer => {\r\n        const actions = AnimationUtils.tryGetActionsFromMixer(mixer);\r\n        if (actions) {\r\n            for (let i = 0; i < actions.length; i++) {\r\n                const action = actions[i];\r\n                const clip = action.getClip();\r\n                // TODO: might need to check if the clip is part of the scene that we want to export\r\n                clips.push(clip);\r\n            }\r\n        }\r\n    });\r\n\r\n    // Get all animations that are directly assigned to objects in the scene\r\n    if (!Array.isArray(scene)) scene = [scene];\r\n    for (const obj of scene) {\r\n        AnimationUtils.tryGetAnimationClipsFromObjectHierarchy(obj, clips);\r\n    }\r\n\r\n    // ensure we only have unique clips\r\n    const uniqueClips = new Set(clips);\r\n    return Array.from(uniqueClips);\r\n\r\n}", "import { isDevEnvironment } from \"../debug/index.js\";\r\nimport { iconFontUrl, loadFont } from \"./fonts.js\";\r\nimport { WebXRButtonFactory } from \"./WebXRButtons.js\";\r\n\r\nconst htmlTagName = \"needle-button\";\r\nconst isDev = isDevEnvironment();\r\n\r\n/**\r\n * A <needle-button> can be used to simply add VR, AR or Quicklook buttons to your website without having to write any code.  \r\n * @example\r\n * ```html\r\n * <needle-button ar></needle-button>\r\n * <needle-button vr></needle-button>\r\n * <needle-button quicklook></needle-button>\r\n * ```\r\n * \r\n * @example custom label\r\n * ```html\r\n * <needle-button ar>Start AR</needle-button>\r\n * <needle-button vr>Start VR</needle-button>\r\n * <needle-button quicklook>View in AR</needle-button>\r\n * ```\r\n * \r\n * @example custom styling\r\n * ```html\r\n * <!-- You can either style the element directly or use a CSS stylesheet -->\r\n * <style>\r\n * needle-button {\r\n *    background-color: red;\r\n *   color: white;\r\n * }\r\n * </style>\r\n * <needle-button ar>Start AR</needle-button>\r\n * ```\r\n */\r\nexport class NeedleButtonElement extends HTMLElement {\r\n\r\n    static observedAttributes = [\"ar\", \"vr\", \"quicklook\"];\r\n\r\n    constructor() {\r\n        super();\r\n        this.removeEventListener(\"click\", this.#onclick);\r\n        this.addEventListener(\"click\", this.#onclick);\r\n    }\r\n\r\n    attributeChangedCallback(_name: string, _oldValue: string, _newValue: string) {\r\n        this.#update()\r\n    }\r\n\r\n    #root!: ShadowRoot;\r\n    #slot!: HTMLSlotElement;\r\n    /** These are the default styles that can be overridden by the user from the outside by styling <needle-button> */\r\n    #styles!: HTMLStyleElement;\r\n\r\n    /** This is the button that was generated using one of the factories */\r\n    #button: HTMLButtonElement | undefined;\r\n    /** If AR or VR is requested we create and use the webxr button factory to create a button with default behaviour */\r\n    #webxrfactory: WebXRButtonFactory | undefined;\r\n\r\n    #observer: MutationObserver | undefined;\r\n\r\n    #update() {\r\n        this.#button?.remove();\r\n\r\n\r\n        if (this.getAttribute(\"ar\") != null) {\r\n            this.#webxrfactory ??= new WebXRButtonFactory()\r\n            this.#button = this.#webxrfactory.createARButton();\r\n        }\r\n        else if (this.getAttribute(\"vr\") != null) {\r\n            this.#webxrfactory ??= new WebXRButtonFactory()\r\n            this.#button = this.#webxrfactory.createVRButton();\r\n        }\r\n        else if (this.getAttribute(\"quicklook\") != null) {\r\n            this.#webxrfactory ??= new WebXRButtonFactory()\r\n            this.#button = this.#webxrfactory.createQuicklookButton();\r\n        }\r\n        else {\r\n            if (isDev) {\r\n                console.warn(\"No button type specified for <needle-button>. Use either ar, vr or quicklook attribute.\")\r\n            }\r\n            else{\r\n                console.debug(\"No button type specified for <needle-button>. Use either ar, vr or quicklook attribute.\")\r\n            }\r\n            return;\r\n        }\r\n\r\n        this.#root ??= this.attachShadow({ mode: \"open\" });\r\n        this.#slot ??= document.createElement(\"slot\");\r\n        this.#styles ??= document.createElement(\"style\");\r\n        this.#styles.innerHTML = `\r\n            button {\r\n                all: initial;\r\n                cursor: inherit;\r\n                color: inherit;\r\n                font-family: inherit;\r\n                gap: inherit;\r\n                white-space: nowrap;\r\n            }\r\n        `;\r\n        const hasUnstyledAttribute = this.getAttribute(\"unstyled\") != undefined;\r\n        if (!hasUnstyledAttribute) {\r\n            this.#styles.innerHTML += `\r\n            :host {\r\n                display: inline-block;\r\n                background: rgba(255, 255, 255, .8);\r\n                backdrop-filter: blur(10px);\r\n                width: fit-content;\r\n                transition: background .2s;\r\n\r\n                cursor: pointer;\r\n                padding: 0.4rem .5rem;\r\n                border-radius: 0.8rem;\r\n                color: black;\r\n                background: rgba(245, 245, 245, .8);\r\n                outline: rgba(0,0,0,.05) 1px solid;\r\n            }\r\n            :host(:hover) {\r\n                background: rgba(255, 255, 255, 1);\r\n                transition: background .2s;\r\n            }\r\n            slot {\r\n                display: flex;\r\n                align-items: center;\r\n                justify-content: center;\r\n                gap: .5rem;\r\n            }\r\n`\r\n        }\r\n\r\n        /**\r\n         * We now structure the results as follows:\r\n         * <button>\r\n         *  <slot>\r\n         *      <original_button_content>\r\n         *  </slot>\r\n         * </button> \r\n         */\r\n        this.#slot.innerHTML = this.#button.innerHTML;\r\n        this.#slot.style.cssText = `display: flex; align-items: center; justify-content: center;`\r\n        this.#button.innerHTML = this.#slot.outerHTML;\r\n        this.#root.innerHTML = this.#button.outerHTML;\r\n        this.#root.prepend(this.#styles);\r\n        loadFont(iconFontUrl, { element: this.#root });\r\n\r\n        this.#observer?.disconnect();\r\n        this.#observer ??= new MutationObserver(() => this.#updateVisibility());\r\n        this.#observer.observe(this.#button, { attributes: true });\r\n        if(isDev) {\r\n            console.log(\"Needle Button updated\")\r\n        }\r\n    }\r\n\r\n    #updateVisibility() {\r\n        if (this.#button) {\r\n            if (this.#button.style.display === \"none\") {\r\n                this.style.display = \"none\";\r\n            }\r\n            else if (this.style.display === \"none\") {\r\n                this.style.display = \"\";\r\n            }\r\n        }\r\n    }\r\n\r\n    #onclick = (_ev: MouseEvent) => {\r\n        if (isDev) {\r\n            console.log(\"Needle Button clicked\")\r\n        }\r\n        if (_ev.defaultPrevented) return;\r\n\r\n        if (this.#button) {\r\n            this.#button.click()\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nif (typeof window !== \"undefined\" && !window.customElements.get(htmlTagName))\r\n    window.customElements.define(htmlTagName, NeedleButtonElement);", "import { PerspectiveCamera } from \"three\";\r\n\r\nimport { getCameraController } from \"../engine/engine_camera.js\";\r\nimport { addNewComponent, getOrAddComponent } from \"../engine/engine_components.js\";\r\nimport { Context } from \"../engine/engine_context.js\";\r\nimport { ContextEvent, ContextRegistry } from \"../engine/engine_context_registry.js\";\r\nimport { NeedleEngineHTMLElement } from \"../engine/engine_element.js\";\r\nimport type { ICamera, IContext } from \"../engine/engine_types.js\";\r\nimport { getParam } from \"../engine/engine_utils.js\";\r\nimport { RGBAColor } from \"../engine/js-extensions/index.js\";\r\nimport { Camera, ClearFlags } from \"./Camera.js\";\r\nimport { OrbitControls } from \"./OrbitControls.js\";\r\n\r\nconst debug = getParam(\"debugmissingcamera\");\r\n\r\nContextRegistry.registerCallback(ContextEvent.MissingCamera, (evt) => {\r\n    if (debug) console.warn(\"Creating missing camera\")\r\n    const scene = evt.context.scene;\r\n\r\n    const cameraObject = new PerspectiveCamera();\r\n    cameraObject.name = \"Default Fallback Camera\"\r\n    scene.add(cameraObject);\r\n\r\n    const camInstance = new Camera();\r\n    camInstance.sourceId = evt.files?.[0]?.src ?? \"unknown\"\r\n\r\n    // Set the clearFlags to a skybox if we have one OR if the user set a skybox image attribute\r\n    if(evt.context.domElement.getAttribute(\"skybox-image\")?.length || 0 > 0 || (evt.context as Context).lightmaps.tryGetSkybox(camInstance.sourceId))\r\n        camInstance.clearFlags = ClearFlags.Skybox;\r\n    else \r\n        // TODO provide a nice default skybox\r\n        camInstance.clearFlags = ClearFlags.SolidColor;\r\n    camInstance.backgroundColor = new RGBAColor(0.5, 0.5, 0.5, 1);\r\n    camInstance.fieldOfView = 35;\r\n\r\n    const transparentAttribute = evt.context.domElement.getAttribute(\"transparent\");\r\n    if (transparentAttribute != undefined) {\r\n        camInstance.clearFlags = ClearFlags.Uninitialized;\r\n    }\r\n\r\n    // TODO: can we store the backgroundBlurriness in the gltf file somewhere except inside the camera?\r\n    // e.g. when we export a scene from blender without a camera in the scene\r\n    camInstance.backgroundBlurriness = .2; // same as in blender 0.5\r\n    const cam = addNewComponent(cameraObject, camInstance, true) as ICamera;\r\n\r\n    cameraObject.position.x = 0;\r\n    cameraObject.position.y = 1;\r\n    cameraObject.position.z = 2;\r\n\r\n    const engineElement = evt.context.domElement as NeedleEngineHTMLElement\r\n    // If the camera is missing and the <needle-engine controls> is not set to false, create default camera controls\r\n    // That way we still create controls if the attribute is not added to <needle-engine> at all\r\n    if (engineElement?.cameraControls != false) {\r\n        createDefaultCameraControls(evt.context, cam);\r\n    }\r\n\r\n    return cam;\r\n});\r\n\r\nContextRegistry.registerCallback(ContextEvent.ContextCreated, (evt) => {\r\n    if (!evt.context.mainCamera) {\r\n        if (debug) console.log(\"Will not auto-fit because a default camera exists\");\r\n        return;\r\n    }\r\n\r\n    // check if <needle-engine camera-controls> attribute is present or enabled\r\n    const engineElement = evt.context.domElement as NeedleEngineHTMLElement\r\n    if (engineElement?.cameraControls == true) {\r\n\r\n        // Check if something else already acts as a camera controller\r\n        const existing = getCameraController(evt.context.mainCamera);\r\n        if (existing?.isCameraController == true) {\r\n            if (debug) console.log(\"Will not auto-fit because a camera controller exists\");\r\n            return;\r\n        }\r\n        createDefaultCameraControls(evt.context);\r\n    }\r\n})\r\n\r\nfunction createDefaultCameraControls(context: IContext, cam?: ICamera) {\r\n\r\n    cam = cam ?? context.mainCameraComponent;\r\n    const cameraObject = cam?.gameObject;\r\n    if (debug) console.log(\"Creating default camera controls\", cam?.name)\r\n    if (cameraObject) {\r\n        const orbit = getOrAddComponent(cameraObject, OrbitControls) as OrbitControls;\r\n        orbit.sourceId = cam?.sourceId ?? \"unknown\";\r\n        const autoRotate = context.domElement.getAttribute(\"auto-rotate\");\r\n        orbit.autoRotate = autoRotate !== undefined && autoRotate !== null && (autoRotate != \"0\" && autoRotate?.toLowerCase() != \"false\");\r\n        orbit.autoRotateSpeed = 0.5;\r\n        orbit.autoFit = true;\r\n        if (orbit.autoRotate && autoRotate) {\r\n            const autoRotateValue = parseFloat(autoRotate);\r\n            if (!isNaN(autoRotateValue)) {\r\n                orbit.autoRotateSpeed = autoRotateValue;\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        console.warn(\"Missing camera object, can not add orbit controls\")\r\n    }\r\n}", "import type { GLTF } from \"three/examples/jsm/loaders/GLTFLoader.js\";\r\n\r\nimport { AnimationUtils } from \"../engine/engine_animation.js\";\r\nimport { addComponent } from \"../engine/engine_components.js\";\r\nimport { ContextEvent, ContextRegistry } from \"../engine/engine_context_registry.js\";\r\nimport { Animation } from \"./Animation.js\";\r\nimport { Animator } from \"./Animator.js\";\r\nimport { GameObject } from \"./Component.js\";\r\nimport { PlayableDirector } from \"./timeline/PlayableDirector.js\";\r\n\r\nContextRegistry.registerCallback(ContextEvent.ContextCreated, args => {\r\n    const autoplay = args.context.domElement.getAttribute(\"autoplay\");\r\n    if (autoplay !== undefined && (autoplay === \"\" || autoplay === \"true\" || autoplay === \"1\")) {\r\n        if (args.files) {\r\n            for (const file of args.files) {\r\n                const hasAnimation = GameObject.foreachComponent(file.file.scene, comp => {\r\n                    if (comp.enabled === false) return undefined;\r\n                    if (comp instanceof Animation && comp.playAutomatically || comp instanceof Animator || comp instanceof PlayableDirector && comp.playOnAwake === true) {\r\n                        return true;\r\n                    }\r\n                    else if (comp instanceof Animation) {\r\n                        comp.playAutomatically = true;\r\n                        return true;\r\n                    }\r\n                    else if (comp instanceof PlayableDirector) {\r\n                        comp.playOnAwake = true;\r\n                        return true;\r\n                    }\r\n                    return undefined;\r\n                }, true);\r\n                if (hasAnimation !== true) {\r\n                    AnimationUtils.assignAnimationsFromFile(file.file as GLTF, {\r\n                        createAnimationComponent: (obj, _clip) => {\r\n                            return addComponent(obj, Animation);\r\n                        },\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n});\r\n\r\n\r\n", "import \"./engine/engine_element.js\";\r\nimport \"./engine/engine_setup.js\";\r\nimport \"./engine/engine_audio.js\";\r\nexport * from \"./engine/api.js\";\r\nexport * from \"./engine-components/api.js\";\r\nexport * from \"./engine-components-experimental/api.js\";\r\nexport * from \"./engine-schemes/api.js\";\r\n\r\n// make accessible for external javascript\r\nimport { Context, loadSync, NeedleXRSession, onBeforeRender, onStart, onUpdate } from \"./engine/api.js\";\r\nconst Needle = {\r\n    Context: Context,\r\n    glTF: {\r\n        loadFromURL: loadSync,\r\n    }\r\n};\r\nif (globalThis[\"Needle\"] !== undefined) {\r\n    console.warn(\"Needle Engine is already imported\");\r\n}\r\nglobalThis[\"Needle\"] = Needle;\r\nfunction registerGlobal(obj: object) {\r\n    for (const key in obj) {\r\n        Needle[key] = obj[key];\r\n    }\r\n}\r\nimport * as Component from \"./engine-components/Component.js\";\r\nregisterGlobal(Component);\r\n\r\nimport * as Components from \"./engine-components/codegen/components.js\";\r\nregisterGlobal(Components);\r\n\r\nNeedle[\"onStart\"] = onStart;\r\nNeedle[\"onUpdate\"] = onUpdate;\r\nNeedle[\"onBeforeRender\"] = onBeforeRender;\r\nNeedle[\"NeedleXRSession\"] = NeedleXRSession;\r\n\r\nimport { GameObject } from \"./engine-components/Component.js\";\r\nfor (const method of Object.getOwnPropertyNames(GameObject)) {\r\n    switch (method) {\r\n        case \"prototype\":\r\n        case \"constructor\":\r\n        case \"length\":\r\n        case \"name\":\r\n            continue;\r\n        default:\r\n            Needle[method] = GameObject[method];\r\n            break;\r\n    }\r\n}\r\n\r\n// make three accessible\r\nimport * as THREE from \"three\";\r\nif (!globalThis[\"THREE\"]) {\r\n    globalThis[\"THREE\"] = THREE;\r\n}\r\nelse console.warn(\"Threejs is already imported\");\r\n\r\n"],
  "mappings": "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",
  "names": ["isComponent", "key", "prefix", "sc", "obj", "scale", "box", "debug", "OrbitControls"]
}
