import { Object3D, Quaternion, Vector3 } from 'three';
import type { GuidsMap } from '../../engine/engine_types.js';
import { Behaviour } from '../Component.js';
import * as Models from "./TimelineModels.js";
import * as Tracks from "./TimelineTracks.js";
/**
 * The wrap mode of the {@link PlayableDirector}.
 */
export declare enum DirectorWrapMode {
    Hold = 0,
    Loop = 1,
    None = 2
}
/** How the clip handles time outside its start and end range. */
export declare enum ClipExtrapolation {
    /** No extrapolation is applied. */
    None = 0,
    /** Hold the time at the end value of the clip. */
    Hold = 1,
    /** Repeat time values outside the start/end range. */
    Loop = 2,
    /** Repeat time values outside the start/end range, reversing direction at each loop */
    PingPong = 3,
    /** Time values are passed in without modification, extending beyond the clips range */
    Continue = 4
}
/** @internal */
export type CreateTrackFunction = (director: PlayableDirector, track: Models.TrackModel) => Tracks.TrackHandler | undefined | null;
/**
 * The PlayableDirector component is the main component to control timelines in needle engine.
 * It is used to play, pause, stop and evaluate timelines.
 * Assign a TimelineAsset to the `playableAsset` property to start playing a timeline.
 * @category Animation and Sequencing
 * @group Components
 */
export declare class PlayableDirector extends Behaviour {
    private static createTrackFunctions;
    static registerCreateTrack(type: string, fn: CreateTrackFunction): void;
    playableAsset?: Models.TimelineAssetModel;
    /** Set to true to start playing the timeline when the scene starts */
    playOnAwake?: boolean;
    extrapolationMode: DirectorWrapMode;
    /** @returns true if the timeline is currently playing */
    get isPlaying(): boolean;
    /** @returns true if the timeline is currently paused */
    get isPaused(): boolean;
    /** the current time of the timeline */
    get time(): number;
    set time(value: number);
    /** the duration of the timeline */
    get duration(): number;
    set duration(value: number);
    /** the weight of the timeline. Set to a value below 1 to blend with other timelines */
    get weight(): number;
    set weight(value: number);
    /** the playback speed of the timeline */
    get speed(): number;
    set speed(value: number);
    /** When enabled the timeline will wait for audio tracks to load at the current time before starting to play */
    waitForAudio: boolean;
    private _visibilityChangeEvt?;
    private _clonedPlayableAsset;
    private _speed;
    /** @internal */
    awake(): void;
    /** @internal */
    onEnable(): void;
    /** @internal */
    onDisable(): void;
    /** @internal */
    onDestroy(): void;
    /** @internal */
    rebuildGraph(): void;
    /**
     * Play the timeline from the current time.
     * If the timeline is already playing this method does nothing.
     */
    play(): Promise<void>;
    /**
     * Pause the timeline.
     */
    pause(): void;
    /**
     * Stop the timeline.
     */
    stop(): void;
    /**
     * Evaluate the timeline at the current time. This is useful when you want to manually update the timeline e.g. when the timeline is paused and you set `time` to a new value.
     */
    evaluate(): void;
    /**
     * @returns true if the timeline is valid and has tracks
     */
    isValid(): boolean | undefined;
    /** Iterates over all tracks of the timeline
     * @returns all tracks of the timeline
     */
    forEachTrack(): Generator<Tracks.TrackHandler, void, unknown>;
    /**
     * @returns all animation tracks of the timeline
     */
    get animationTracks(): Tracks.AnimationTrackHandler[];
    /**
     * @returns all audio tracks of the timeline
     */
    get audioTracks(): Tracks.AudioTrackHandler[];
    private _guidsMap?;
    /** @internal */
    resolveGuids(map: GuidsMap): void;
    private _isPlaying;
    private _internalUpdateRoutine;
    private _isPaused;
    /** internal, true during the time stop() is being processed */
    private _isStopping;
    private _time;
    private _duration;
    private _weight;
    private _animationTracks;
    private _audioTracks;
    private _signalTracks;
    private _controlTracks;
    private _customTracks;
    private _allTracks;
    /** should be called after evaluate if the director was playing */
    private invokePauseChangedMethodsOnTracks;
    private invokeStateChangedMethodsOnTracks;
    private internalUpdate;
    /**
     * PlayableDirector lifecycle should always call this instead of "evaluate"
     * @param called_by_user If true the evaluation is called by the user (e.g. via evaluate())
     */
    private internalEvaluate;
    private resolveBindings;
    private findRoot;
    private updateTimelineDuration;
    private setupAndCreateTrackHandlers;
    private setAudioTracksAllowPlaying;
    /** Experimental support for overriding timeline animation data (position or rotation) */
    readonly animationCallbackReceivers: ITimelineAnimationCallbacks[];
    /** Experimental: Receive callbacks for timeline animation. Allows modification of final value */
    registerAnimationCallback(receiver: ITimelineAnimationCallbacks): void;
    /** Experimental: Unregister callbacks for timeline animation. Allows modification of final value */
    unregisterAnimationCallback(receiver: ITimelineAnimationCallbacks): void;
}
/**
 * Experimental interface for receiving timeline animation callbacks. Register at the PlayableDirector
 */
export interface ITimelineAnimationCallbacks {
    /**
    * @param director The director that is playing the timeline
    * @param target The target object that is being animated
    * @param time The current time of the timeline
    * @param rotation The evaluated rotation of the target object at the current time
     */
    onTimelineRotation?(director: PlayableDirector, target: Object3D, time: number, rotation: Quaternion): any;
    /**
    * @param director The director that is playing the timeline
    * @param target The target object that is being animated
    * @param time The current time of the timeline
    * @param position The evaluated position of the target object at the current time
     */
    onTimelinePosition?(director: PlayableDirector, target: Object3D, time: number, position: Vector3): any;
}
