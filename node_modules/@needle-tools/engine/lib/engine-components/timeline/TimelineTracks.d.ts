import { AnimationAction, AnimationClip, AnimationMixer, Audio, AudioListener, Object3D } from "three";
import { Context } from "../../engine/engine_setup.js";
import { AudioSource } from "../AudioSource.js";
import { PlayableDirector } from "./PlayableDirector.js";
import { SignalReceiver } from "./SignalAsset.js";
import * as Models from "./TimelineModels.js";
/**
 * A TrackHandler is responsible for evaluating a specific type of timeline track.
 * A timeline track can be an animation track, audio track, signal track, control track etc and is controlled by a {@link PlayableDirector}.
 */
export declare abstract class TrackHandler {
    director: PlayableDirector;
    track: Models.TrackModel;
    get muted(): boolean;
    set muted(val: boolean);
    forEachClip(backwards?: boolean): IterableIterator<Models.ClipModel>;
    onEnable?(): any;
    onDisable?(): any;
    onDestroy?(): any;
    abstract evaluate(time: number): any;
    onMuteChanged?(): any;
    onPauseChanged?(): any;
    /** invoked when PlayableDirectory playmode state changes (paused, playing, stopped) */
    onStateChanged?(isPlaying: boolean): any;
    getClipTime(time: number, model: Models.ClipModel): number;
    getClipTimeNormalized(time: number, model: Models.ClipModel): number;
    evaluateWeight(time: number, index: number, models: Array<Models.ClipModel>, isActive?: boolean): number;
}
export declare class AnimationTrackHandler extends TrackHandler {
    /** @internal */
    models: Array<Models.ClipModel>;
    /** @internal */
    trackOffset?: Models.TrackOffset;
    /** The object that is being animated. */
    target?: Object3D;
    /** The AnimationMixer, should be shared with the animator if an animator is bound */
    mixer?: AnimationMixer;
    clips: Array<AnimationClip>;
    actions: Array<AnimationAction>;
    /**
     * You can use the weight to blend the timeline animation tracks with multiple animation tracks on the same object.
     * @default 1
     */
    weight: number;
    /** holds data/info about clips differences */
    private _actionOffsets;
    private _didBind;
    private _animator;
    onDisable(): void;
    onDestroy(): void;
    onStateChanged(): void;
    createHooks(clipModel: Models.AnimationClipModel, clip: any): void;
    bind(): void;
    private ensureTrackOffsets;
    private _useclipOffsets;
    private _totalOffsetPosition;
    private _totalOffsetRotation;
    private _totalOffsetPosition2;
    private _totalOffsetRotation2;
    private _summedPos;
    private _tempPos;
    private _summedRot;
    private _tempRot;
    private _clipRotQuat;
    evaluate(time: number): void;
    private createRotationInterpolant;
    private createPositionInterpolant;
}
declare type AudioClipModel = Models.ClipModel & {
    _didTriggerPlay: boolean;
};
export declare class AudioTrackHandler extends TrackHandler {
    models: Array<AudioClipModel>;
    listener: AudioListener;
    audio: Array<Audio>;
    audioContextTimeOffset: Array<number>;
    lastTime: number;
    audioSource?: AudioSource;
    private _audioLoader;
    private getAudioFilePath;
    onAllowAudioChanged(allow: boolean): void;
    addModel(model: Models.ClipModel): void;
    onDisable(): void;
    onDestroy(): void;
    onMuteChanged(): void;
    stop(): void;
    private _playableDirectorResumed;
    onPauseChanged(): void;
    evaluate(time: number): void;
    /** Call to load audio buffer for a specific time in the track. Can be used to preload the timeline audio */
    loadAudio(time: number, lookAhead?: number, lookBehind?: number): Promise<(AudioBuffer | null)[]> | null;
    private isInTimeRange;
    private static _audioBuffers;
    static dispose(): void;
    private handleAudioLoading;
}
export declare class SignalTrackHandler extends TrackHandler {
    models: Models.SignalMarkerModel[];
    didTrigger: boolean[];
    receivers: Array<SignalReceiver | null>;
    evaluate(time: number): void;
}
export declare class ControlTrackHandler extends TrackHandler {
    models: Array<Models.ClipModel>;
    timelines: Array<PlayableDirector | null>;
    resolveSourceObjects(_context: Context): void;
    private _previousActiveModel;
    evaluate(time: number): void;
}
export {};
