import { AnimationClip, KeyframeTrack, Object3D, Quaternion, Vector3 } from "three";
import type { IUSDExporterExtension } from "../Extension.js";
import { USDObject } from "../ThreeUSDZExporter.js";
export interface UsdzAnimation {
    createAnimation(ext: AnimationExtension, model: USDObject, context: any): any;
}
export type AnimationClipCollection = Array<{
    root: Object3D;
    clips: Array<AnimationClip>;
}>;
export declare class RegisteredAnimationInfo {
    private _start?;
    get start(): number;
    get duration(): number;
    get nearestAnimatedRoot(): Object3D | undefined;
    get clipName(): string;
    private ext;
    private root;
    private _nearestAnimatedRoot?;
    private clip;
    speed?: number;
    constructor(ext: AnimationExtension, root: Object3D, clip: AnimationClip | null);
    private static isDescendantOf;
    /** Finds the nearest actually animated object under root based on the tracks in the AnimationClip. */
    getNearestAnimatedRoot(): Object3D<import("three").Object3DEventMap> | undefined;
}
export declare class TransformData {
    clip: AnimationClip | null;
    pos?: KeyframeTrack;
    rot?: KeyframeTrack;
    scale?: KeyframeTrack;
    private root;
    private target;
    private duration;
    private useRootMotion;
    /** This value can theoretically be anything â€“ a value of 1 is good to clearly see animation gaps.
     * For production, a value of 1/60 is enough, since the files can then still properly play back at 60fps.
     */
    static frameRate: number;
    static animationDurationPadding: number;
    static restPoseClipDuration: number;
    constructor(root: Object3D | null, target: Object3D, clip: AnimationClip | null);
    addTrack(track: KeyframeTrack): void;
    getFrames(): number;
    getDuration(): number;
    getSortedTimesArray(generatePos?: boolean, generateRot?: boolean, generateScale?: boolean): number[];
    /**
     * Returns an iterator that yields the values for each time sample.
     * Values are reused objects - if you want to append them to some array
     * instead of processing them right away, clone() them.
     * @param timesArray
     * @param generatePos
     * @param generateRot
     * @param generateScale
     */
    getValues(timesArray: number[], generatePos?: boolean, generateRot?: boolean, generateScale?: boolean): Generator<{
        time: number;
        translation: Vector3;
        rotation: Quaternion;
        scale: Vector3;
        index: number;
    }, void, unknown>;
}
export declare class AnimationExtension implements IUSDExporterExtension {
    get extensionName(): string;
    get animationData(): Map<Object3D<import("three").Object3DEventMap>, TransformData[]>;
    get registeredClips(): IterableIterator<AnimationClip>;
    get animatedRoots(): IterableIterator<Object3D<import("three").Object3DEventMap>>;
    get holdClipMap(): Map<AnimationClip, AnimationClip>;
    /** For each animated object, contains time/pos/rot/scale samples in the format that USD needs,
     *  ready to be written to the .usda file.
     */
    private dict;
    /** Map of all roots (Animation/Animator or scene) and all targets that they animate.
     *  We need that info so that we can ensure that each target has the same number of TransformData entries
     *  so that switching between animations doesn't result in data "leaking" to another clip.
     */
    private rootTargetMap;
    private rootAndClipToRegisteredAnimationMap;
    /** Clips registered for each root */
    private rootToRegisteredClip;
    private lastClipEndTime;
    private clipToStartTime;
    private clipToHoldClip;
    private serializers;
    /** Determines if we inject a rest pose clip for each root - only makes sense for QuickLook */
    injectRestPoses: boolean;
    /** Determines if we inject a PlayAnimationOnClick component with "scenestart" trigger - only makes sense for QuickLook */
    injectImplicitBehaviours: boolean;
    constructor(quickLookCompatible: boolean);
    getStartTimeCode(): number;
    /** Returns the end time code, based on 60 frames per second, for all registered animations.
     * This matches the highest time value in the USDZ file. */
    getEndTimeCode(): number;
    getClipCount(root: Object3D): number;
    getStartTimeByClip(clip: AnimationClip | null): number;
    /** Register an AnimationClip for a specific root object.
     * @param root The root object that the animation clip is targeting.
     * @param clip The animation clip to register. If null, a rest pose is registered.
     * @returns The registered animation info, which contains the start time and duration of the clip.
     */
    registerAnimation(root: Object3D, clip: AnimationClip | null): RegisteredAnimationInfo | null;
    onAfterHierarchy(_context: any): void;
    onAfterBuildDocument(_context: any): void;
    onExportObject(object: any, model: USDObject, _context: any): void;
}
