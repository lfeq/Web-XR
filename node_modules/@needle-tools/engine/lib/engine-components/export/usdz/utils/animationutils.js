import { Object3D } from "three";
import { getParam } from "../../../../engine/engine_utils.js";
import { Animation } from "../../../Animation.js";
import { Animator } from "../../../Animator.js";
import { AudioSource } from "../../../AudioSource.js";
import { GameObject } from "../../../Component.js";
import { PlayAnimationOnClick, PlayAudioOnClick } from "../extensions/behavior/BehaviourComponents.js";
import { ActionBuilder, BehaviorModel, TriggerBuilder } from "../extensions/behavior/BehavioursBuilder.js";
const debug = getParam("debugusdz");
export function registerAnimatorsImplictly(root, ext) {
    // TODO: currently we're simply appending all animations to each other.
    // We are not currently emitting PlayAnimation actions that would make sure
    // that only a specific clip or a set of clips is playing.
    // Better would be to scratch the functionality here entirely, and instead
    // inject PlayAnimationOnStart actions. This way, animations can loop independently, and
    // Animator state chaining would be respected out-of-the-box.
    // For non-QuickLook USDZ export it's still useful to have implicit registration per root.
    // collect animators and their clips
    const animationClips = [];
    const animators = GameObject.getComponentsInChildren(root, Animator);
    const animationComponents = GameObject.getComponentsInChildren(root, Animation);
    const animatorsWithPlayAtStart = new Array();
    const constructedObjects = new Array();
    if (ext.injectImplicitBehaviours) {
        // We're registering animators with implicit PlayAnimationOnClick (with hacked "start" trigger) here.
        for (const animator of animators) {
            if (!animator || !animator.runtimeAnimatorController || !animator.enabled)
                continue;
            const activeState = animator.runtimeAnimatorController.activeState;
            // skip missing data, empty states or motions
            if (!activeState)
                continue;
            if (!activeState.motion || !activeState.motion.clip)
                continue;
            if (activeState.motion.clip.tracks?.length < 1)
                continue;
            // We could skip if the current state has already ended playing
            // but there's an edge case where we'd do this exactly in a transition,
            // and also it's a bit weird when someone has watched the animation in the browser already
            // and then it doesn't play in AR, so this is disabled for now.
            // if (animator.getCurrentStateInfo()?.normalizedTime == 1) continue;
            if (animatorsWithPlayAtStart.includes(animator))
                continue;
            // Create a PlayAnimationOnClick component that will play the animation on start
            // This is a bit hacky right now (we're using the internal "start" trigger)
            const newComponent = new PlayAnimationOnClick();
            newComponent.animator = animator;
            newComponent.stateName = activeState.name;
            newComponent.trigger = "start";
            newComponent.name = "PlayAnimationOnClick_implicitAtStart_" + newComponent.stateName;
            const go = new Object3D();
            GameObject.addComponent(go, newComponent);
            constructedObjects.push(go);
            animatorsWithPlayAtStart.push(animator);
            // the behaviour can be anywhere in the hierarchy
            root.add(go);
        }
        // TODO add Animation handling, otherwise multi-animation files
        // directly loaded from GLB may glitch due to the added rest poses
    }
    else {
        for (const animator of animators) {
            if (!animator || !animator.runtimeAnimatorController || !animator.enabled)
                continue;
            if (debug)
                console.log(animator);
            const clips = [];
            for (const action of animator.runtimeAnimatorController.enumerateActions()) {
                if (debug)
                    console.log(action);
                const clip = action.getClip();
                if (!clips.includes(clip))
                    clips.push(clip);
            }
            animationClips.push({ root: animator.gameObject, clips: clips });
        }
    }
    // TODO once PlayAnimationOnClick can use animation components as well,
    // we can treat them the same as we treat Animators above.
    if (ext.injectImplicitBehaviours) {
        for (const animationComponent of animationComponents) {
            if (!animationComponent || !animationComponent.clip || !animationComponent.enabled)
                continue;
            if (!animationComponent.playAutomatically)
                continue;
            if (animatorsWithPlayAtStart.includes(animationComponent))
                continue;
            // Create a PlayAnimationOnClick component that will play the animation on start
            // This is a bit hacky right now (we're using the internal "start" trigger)
            const newComponent = new PlayAnimationOnClick();
            newComponent.animation = animationComponent;
            newComponent.stateName = animationComponent.clip.name;
            newComponent.trigger = "start";
            newComponent.name = "PlayAnimationOnClick_implicitAtStart_" + newComponent.stateName;
            const go = new Object3D();
            GameObject.addComponent(go, newComponent);
            constructedObjects.push(go);
            animatorsWithPlayAtStart.push(animationComponent);
            // the behaviour can be anywhere in the hierarchy
            root.add(go);
        }
    }
    else {
        for (const animationComponent of animationComponents) {
            if (debug)
                console.log(animationComponent);
            const clips = [];
            for (const clip of animationComponent.animations) {
                if (!clips.includes(clip))
                    clips.push(clip);
            }
            animationClips.push({ root: animationComponent.gameObject, clips: clips });
        }
    }
    if (debug && animationClips?.length > 0)
        console.log("USDZ Animation Clips without behaviours", animationClips);
    for (const pair of animationClips) {
        for (const clip of pair.clips)
            ext.registerAnimation(pair.root, clip);
    }
    return constructedObjects;
}
export function registerAudioSourcesImplictly(root, _ext) {
    const audioSources = GameObject.getComponentsInChildren(root, AudioSource);
    const playAudioOnClicks = GameObject.getComponentsInChildren(root, PlayAudioOnClick);
    const audioWithPlayAtStart = new Array();
    const constructedObjects = new Array();
    if (debug) {
        console.log({ audioSources, playAudioOnClicks });
    }
    // Remove all audio sources that are already referenced from existing PlayAudioOnClick components
    for (const player of playAudioOnClicks) {
        if (!player.target)
            continue;
        const index = audioSources.indexOf(player.target);
        if (index > -1)
            audioSources.splice(index, 1);
    }
    // for the remaning ones, we want to build a PlayAudioOnClick component
    for (const audioSource of audioSources) {
        if (!audioSource || !audioSource.clip)
            continue;
        if (audioSource.volume <= 0)
            continue;
        if (audioWithPlayAtStart.includes(audioSource))
            continue;
        const newComponent = new PlayAudioOnClick();
        newComponent.target = audioSource;
        newComponent.name = "PlayAudioOnClick_implicitAtStart_";
        newComponent.trigger = "start";
        const go = new Object3D();
        GameObject.addComponent(go, newComponent);
        console.log("implicit PlayAudioOnStart", go, newComponent);
        constructedObjects.push(go);
        audioWithPlayAtStart.push(audioSource);
        root.add(go);
    }
    return constructedObjects;
}
export function disableObjectsAtStart(objects) {
    const newComponent = new BehaviorModel("DisableAtStart", TriggerBuilder.sceneStartTrigger(), ActionBuilder.fadeAction(objects, 0, false));
    return newComponent;
}
//# sourceMappingURL=animationutils.js.map