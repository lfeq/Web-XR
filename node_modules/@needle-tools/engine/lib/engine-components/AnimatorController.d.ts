import { AnimationAction, AnimationClip, AnimationMixer } from "three";
import { Context } from "../engine/engine_setup.js";
import type { AnimatorControllerModel, State } from "../engine/extensions/NEEDLE_animator_controller_model.js";
import { AnimatorStateInfo } from "../engine/extensions/NEEDLE_animator_controller_model.js";
import { Animator } from "./Animator.js";
declare type CreateAnimatorControllerOptions = {
    /** Should each animationstate loop */
    looping?: boolean;
    /** Set to false to disable generating transitions between animationclips */
    autoTransition?: boolean;
    /** Set to a positive value in seconds for transition duration between states */
    transitionDuration?: number;
};
/**
 * The AnimatorController is used to control the playback of animations. It is used by the {@link Animator} component.
 * It is using a state machine to control the playback of animations.
 * To create an animator controller use the static method `AnimatorController.createFromClips(clips: AnimationClip[], options: CreateAnimatorControllerOptions)`
*/
export declare class AnimatorController {
    /** Create an animatorcontroller. States are created from the clips array.
     * @param clips the clips to assign to the controller
     * @param options options to control the creation of the controller.
     * @returns the created animator controller
    */
    static createFromClips(clips: AnimationClip[], options?: CreateAnimatorControllerOptions): AnimatorController;
    play(name: string | number, layerIndex?: number, normalizedTime?: number, durationInSec?: number): void;
    reset(): void;
    setBool(name: string | number, value: boolean): void;
    getBool(name: string | number): boolean;
    setFloat(name: string | number, val: number): boolean;
    getFloat(name: string | number): number;
    setInteger(name: string | number, val: number): void;
    getInteger(name: string | number): number;
    setTrigger(name: string | number): void;
    resetTrigger(name: string | number): void;
    getTrigger(name: string | number): boolean;
    isInTransition(): boolean;
    /** Set the speed of the animator controller. Larger values will make the animation play faster. */
    setSpeed(speed: number): void;
    private _speed;
    /**@deprecated use findState */
    FindState(name: string | number | undefined | null): State | null;
    findState(name: string | number | undefined | null): State | null;
    /** Get the current state info
     * @returns the current state info or null if no state is active
    */
    getCurrentStateInfo(): AnimatorStateInfo | null;
    /** Get the current action (shorthand for activeState.motion.action)
     * @returns the current action that is playing. This is the action that is currently transitioning to or playing.
     * If no action is playing null is returned.
     **/
    get currentAction(): AnimationAction | null;
    /** The normalized time of the start state. This is used to determine the start time of the first state. */
    normalizedStartOffset: number;
    /** the animator that this controller is bound to */
    animator?: Animator;
    /** the model that this controller is based on */
    model: AnimatorControllerModel;
    /** Get the context of the animator */
    get context(): Context | undefined | null;
    /** Get the animation mixer that is used to play the animations */
    get mixer(): AnimationMixer;
    /**
     * Clears the animation mixer and unregisters it from the context.
     */
    dispose(): void;
    /** Bind the animator to the controller. Only one animator can be bound to a controller at a time. */
    bind(animator: Animator): void;
    /** Create a clone of the controller. This will clone the model but not the runtime state. */
    clone(): AnimatorController | null;
    /** Called by the animator. This will update the active states and transitions as well as the animation mixer. */
    update(weight: number): void;
    private _mixer;
    private _activeState?;
    /** Get the currently active state playing
     * @returns the currently active state or undefined if no state is active
     **/
    get activeState(): State | undefined;
    constructor(model: AnimatorControllerModel);
    private _activeStates;
    private updateActiveStates;
    private setStartTransition;
    private evaluateTransitions;
    private setTimescale;
    private getState;
    /**
     * These actions have been active previously but not faded out because we entered a state that has no real animation - no duration. In which case we hold the previously active actions until they are faded out.
     */
    private readonly _heldActions;
    private releaseHeldActions;
    private transitionTo;
    private createAction;
    private evaluateCondition;
    private createActions;
    enumerateActions(): Generator<AnimationAction, void, unknown>;
    private rootMotionHandler?;
}
export {};
