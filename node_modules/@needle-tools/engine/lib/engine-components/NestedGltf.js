var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { AssetReference } from "../engine/engine_addressables.js";
import { InstantiateOptions } from "../engine/engine_gameobject.js";
import { InstantiateIdProvider } from "../engine/engine_networking_instantiate.js";
import { serializable } from "../engine/engine_serialization_decorator.js";
import { getParam } from "../engine/engine_utils.js";
import { Behaviour } from "../engine-components/Component.js";
const debug = getParam("debugnestedgltf");
/** The nested gltf is a component that is used to load a gltf file when the component becomes active (start)
 * It will load the gltf file and instantiate it as a child of the parent of the GameObject that has this component
 */
export class NestedGltf extends Behaviour {
    /**
     * A reference to the gltf file that should be loaded
     */
    filePath;
    /**
     * EXPERIMENTAL for cloud asset loading
     */
    loadAssetInParent = true;
    _isLoadingOrDoneLoading = false;
    /** Register a callback that will be called when the progress of the loading changes */
    listenToProgress(evt) {
        this.filePath?.beginListenDownload(evt);
    }
    /** Begin loading the referenced gltf file in filePath */
    preload() {
        this.filePath?.preload();
    }
    /** @internal */
    async start() {
        if (this._isLoadingOrDoneLoading)
            return;
        if (debug)
            console.log(this, this.guid);
        const parent = this.gameObject.parent;
        if (parent) {
            this._isLoadingOrDoneLoading = true;
            const opts = new InstantiateOptions();
            // we need to provide stable guids for creating nested gltfs
            opts.idProvider = new InstantiateIdProvider(this.hash(this.guid));
            opts.parent = this.loadAssetInParent !== false ? parent : this.gameObject;
            this.gameObject.updateMatrix();
            const matrix = this.gameObject.matrix;
            if (debug)
                console.log("Load nested:", this.filePath?.url ?? this.filePath, this.gameObject.position);
            const res = await this.filePath?.instantiate?.call(this.filePath, opts);
            if (debug)
                console.log("Nested loaded:", this.filePath?.url ?? this.filePath, res);
            if (res && this.loadAssetInParent !== false) {
                res.matrixAutoUpdate = false;
                res.matrix.identity();
                res.applyMatrix4(matrix);
                res.matrixAutoUpdate = true;
                res.layers.disableAll();
                res.layers.set(this.layer);
                this.dispatchEvent(new CustomEvent("loaded", { detail: { instance: res, assetReference: this.filePath } }));
            }
            if (debug)
                console.log("Nested loading done:", this.filePath?.url ?? this.filePath, res);
        }
    }
    /** @internal */
    onDestroy() {
        // When the NestedGLTF gets destroyed we assume the loaded glTF is also destroyed
        // meaning the resources, textures etc are disposed
        // When this NestedGLTF would now be loaded again the AssetReference would still be in the loaded state
        // so it would instantiate without textures etc...
        // Perhaps we want to add a dispose callback or event method too?
        // Somehow we have to clean the AssetReference state
        this.filePath?.unload();
    }
    hash(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = str.charCodeAt(i) + ((hash << 5) - hash);
        }
        return hash;
    }
}
__decorate([
    serializable(AssetReference)
], NestedGltf.prototype, "filePath", void 0);
//# sourceMappingURL=NestedGltf.js.map