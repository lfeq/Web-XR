import { Quaternion, Vector3 } from "three";
import { Matrix4 as QMatrix4 } from "three.quarks";
import { CircularBuffer } from "../../engine/engine_utils.js";
import { $particleLife, SubEmitterType } from "./ParticleSystem.js";
const VECTOR_ONE = new Vector3(1, 1, 1);
const VECTOR_Z = new Vector3(0, 0, 1);
const $emitterMatrix = Symbol("emitterMatrix");
export class ParticleSubEmitter {
    system;
    particleSystem;
    subSystem;
    subParticleSystem;
    type = "NeedleParticleSubEmitter";
    emitterType;
    emitterProbability;
    //private matrix_ = new Matrix4();
    q_ = new Quaternion();
    v_ = new Vector3();
    v2_ = new Vector3();
    _emitterMatrix = new QMatrix4();
    _circularBuffer;
    constructor(system, particleSystem, subSystem, subParticleSystem) {
        this.system = system;
        this.particleSystem = particleSystem;
        this.subSystem = subSystem;
        this.subParticleSystem = subParticleSystem;
        if (this.subParticleSystem && this.subParticleSystem) {
            this.subParticleSystem.onlyUsedByOther = true;
        }
        const maxMatrices = 1000;
        this._circularBuffer = new CircularBuffer(() => new QMatrix4(), maxMatrices);
    }
    clone() {
        throw new Error("Method not implemented.");
    }
    initialize(particle) {
        particle.emissionState = {
            burstIndex: 0,
            burstWaveIndex: 0,
            time: 0,
            waitEmiting: 0,
            // matrix: new Matrix4(),
        };
        // particle[$emitterMatrix] = new Matrix4();
        this._emitterMatrix.copy(this.subSystem.matrixWorld).invert().premultiply(this.system.matrixWorld);
        this._emitterMatrix.setPosition(0, 0, 0);
        if (this.emitterType === SubEmitterType.Birth) {
            this.run(particle);
        }
    }
    update(particle, _delta) {
        this.run(particle);
    }
    frameUpdate(_delta) {
    }
    toJSON() {
    }
    reset() {
    }
    run(particle) {
        if (this.subSystem.currentParticles >= this.subSystem.main.maxParticles)
            return;
        if (!this.subParticleSystem || !particle.emissionState)
            return;
        if (this.emitterProbability && Math.random() > this.emitterProbability)
            return;
        const delta = this.system.deltaTime;
        if (this.emitterType === SubEmitterType.Death) {
            let lifeTime = particle.life;
            if (particle[$particleLife] !== undefined)
                lifeTime = particle[$particleLife];
            const willDie = particle.age + delta * 1.2 >= lifeTime;
            if (!willDie)
                return;
            // Just emit all for now, we should probably add a way to get the amount from the subsystem emission module
            const maxAmount = this.subSystem.main.maxParticles - this.subSystem.currentParticles;
            particle.emissionState.waitEmiting = maxAmount;
        }
        // TODO: figure out how to re-use matrices
        const m = new QMatrix4(); // this._circularBuffer.get();// new Matrix4();// particle[$emitterMatrix];
        m.set(1, 0, 0, particle.position.x, 0, 1, 0, particle.position.y, 0, 0, 1, particle.position.z, 0, 0, 0, 1);
        if (!this.particleSystem.worldSpace) {
            m.multiplyMatrices(this._emitterMatrix, m);
        }
        this.subParticleSystem.emit(delta, particle.emissionState, m);
    }
}
//# sourceMappingURL=ParticleSystemSubEmitter.js.map