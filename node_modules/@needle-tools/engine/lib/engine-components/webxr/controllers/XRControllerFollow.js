var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Quaternion, Vector3 } from "three";
import { serializable } from "../../../engine/engine_serialization_decorator.js";
import { getTempVector } from "../../../engine/engine_three_utils.js";
import { Behaviour } from "../../Component.js";
/**
 * Add this script to an object and set `side` to make the object follow a specific controller.
 * @category XR
 * @group Components
 * */
export class XRControllerFollow extends Behaviour {
    // override active and enabled here so that we always receive xr update events
    get activeAndEnabled() {
        return true;
    }
    /** Should this object follow a right hand/controller or left hand/controller.
     * When a number is provided, the controller with that index is followed.
     * @default "none"
     **/
    side = "none";
    /** should it follow controllers (the physics controller)
     * @default true
    */
    controller = true;
    /** should it follow hands (when using hand tracking in WebXR)
     * @default false
    */
    hands = false;
    /** Disable if you don't want this script to modify the object's visibility
     * If enabled the object will be hidden when the configured controller or hand is not available
     * If disabled this script will not modify the object's visibility
     * @default true
     */
    controlVisibility = true;
    /** when true it will use the grip space, otherwise the ray space
     * @default false
    */
    useGripSpace = false;
    /** when enabled the position, rotation and scale of this object will be set to the position it was at when it entered the XR session
     * @default true
    */
    resetTransformAfterXRSession = true;
    _startPosition = new Vector3();
    _startRotation = new Quaternion();
    _startScale = new Vector3();
    /** @internal */
    onEnterXR(_args) {
        this._startPosition.copy(this.gameObject.position);
        this._startRotation.copy(this.gameObject.quaternion);
        this._startScale.copy(this.gameObject.scale);
    }
    /** @internal */
    onUpdateXR(args) {
        // try to get the controller
        const ctrl = args.xr.getController(this.side);
        if (ctrl) {
            // check if this is a hand and hands are allowed
            if (ctrl.hand && !this.hands) {
                if (this.controlVisibility)
                    this.gameObject.visible = false;
                return;
            }
            // check if this is a controller and controllers are allowed
            else if (!this.controller) {
                if (this.controlVisibility)
                    this.gameObject.visible = false;
                return;
            }
            // we're following a controller (or hand)
            if (this.controlVisibility)
                this.gameObject.visible = true;
            if (this.useGripSpace || ctrl.targetRayMode === "transient-pointer") {
                this.gameObject.worldPosition = ctrl.gripWorldPosition;
                this.gameObject.worldQuaternion = ctrl.gripWorldQuaternion;
                this.gameObject.worldScale = getTempVector(ctrl.xr.rigScale, ctrl.xr.rigScale, ctrl.xr.rigScale)
                    .multiply(this._startScale);
            }
            else {
                this.gameObject.worldPosition = ctrl.rayWorldPosition;
                this.gameObject.worldQuaternion = ctrl.rayWorldQuaternion;
                this.gameObject.worldScale = getTempVector(ctrl.xr.rigScale, ctrl.xr.rigScale, ctrl.xr.rigScale)
                    .multiply(this._startScale);
            }
        }
    }
    /** @internal */
    onLeaveXR(_args) {
        if (this.resetTransformAfterXRSession) {
            this.gameObject.position.copy(this._startPosition);
            this.gameObject.quaternion.copy(this._startRotation);
            this.gameObject.scale.copy(this._startScale);
        }
    }
}
__decorate([
    serializable()
], XRControllerFollow.prototype, "side", void 0);
__decorate([
    serializable()
], XRControllerFollow.prototype, "controller", void 0);
__decorate([
    serializable()
], XRControllerFollow.prototype, "hands", void 0);
__decorate([
    serializable()
], XRControllerFollow.prototype, "controlVisibility", void 0);
__decorate([
    serializable()
], XRControllerFollow.prototype, "useGripSpace", void 0);
__decorate([
    serializable()
], XRControllerFollow.prototype, "resetTransformAfterXRSession", void 0);
//# sourceMappingURL=XRControllerFollow.js.map