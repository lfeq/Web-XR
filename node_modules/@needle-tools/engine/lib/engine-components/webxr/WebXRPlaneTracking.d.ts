/// <reference types="webxr" />
import { Group, Mesh } from "three";
import { AssetReference } from "../../engine/engine_addressables.js";
import type { NeedleXREventArgs } from "../../engine/engine_xr.js";
import { MeshCollider } from "../Collider.js";
import { Behaviour } from "../Component.js";
declare type XRMesh = {
    meshSpace: XRSpace;
    lastChangedTime: number;
    vertices: Float32Array;
    indices: Uint32Array;
    semanticLabel?: string;
};
/**
 * Used by {@link WebXRPlaneTracking} to track planes in the real world.
 */
export declare type XRPlaneContext = {
    id: number;
    xrData: (XRPlane & {
        semanticLabel?: string;
    }) | XRMesh;
    timestamp: number;
    mesh?: Mesh | Group;
    collider?: MeshCollider;
};
/**
 * Used by {@link WebXRPlaneTracking} to track planes in the real world.
 */
export declare type WebXRPlaneTrackingEvent = {
    type: "plane-added" | "plane-updated" | "plane-removed";
    context: XRPlaneContext;
};
/**
 * Use this component to track planes and meshes in the real world when in immersive-ar (e.g. on Oculus Quest).
 * @category XR
 * @group Components
 */
export declare class WebXRPlaneTracking extends Behaviour {
    /**
     * Optional: if assigned it will be instantiated per tracked plane/tracked mesh.
     * If not assigned a simple mesh will be used. Use `occluder` to create occlusion meshes that don't render color but only depth.
     */
    dataTemplate?: AssetReference;
    /**
     * If true an occluder material will be applied to the tracked planes/meshes.
     * Note: this will only be applied if dataTemplate is not assigned
     */
    occluder: boolean;
    /**
     * If true the system will try to initiate room capture if no planes are detected.
     */
    initiateRoomCaptureIfNoData: boolean;
    /**
     * If true plane tracking will be enabled
     */
    usePlaneData: boolean;
    /**
     * If true mesh tracking will be enabled
     */
    useMeshData: boolean;
    /** when enabled mesh or plane tracking will also be used in VR */
    runInVR: boolean;
    /**
     * Returns all tracked planes
     */
    get trackedPlanes(): IterableIterator<XRPlaneContext>;
    get trackedMeshes(): IterableIterator<XRPlaneContext>;
    /** @internal */
    onBeforeXR(_mode: XRSessionMode, args: XRSessionInit): void;
    /** @internal */
    onEnterXR(_evt: any): void;
    onLeaveXR(_args: NeedleXREventArgs): void;
    /** @internal */
    onUpdateXR(args: NeedleXREventArgs): void;
    private bounds;
    private center;
    private labelOffset;
    private removeData;
    private _dataId;
    private readonly _allPlanes;
    private readonly _allMeshes;
    private firstTimeNoPlanesDetected;
    private makeOccluder;
    private processFrameData;
    private _flipForwardMatrix;
    private checkIfContextShouldBeConvex;
    private createGeometry;
    private _verticesCache;
    private createMeshGeometry;
    private createPlaneGeometry;
}
export {};
