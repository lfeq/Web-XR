var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Box3Helper, Object3D, PerspectiveCamera, Ray, Vector2, Vector3 } from "three";
import { OrbitControls as ThreeOrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
import { setCameraController } from "../engine/engine_camera.js";
import { Gizmos } from "../engine/engine_gizmos.js";
import { InputEventQueue } from "../engine/engine_input.js";
import { Mathf } from "../engine/engine_math.js";
import { RaycastOptions } from "../engine/engine_physics.js";
import { serializable } from "../engine/engine_serialization_decorator.js";
import { getBoundingBox, getWorldDirection, getWorldPosition, getWorldRotation, setWorldRotation } from "../engine/engine_three_utils.js";
import { DeviceUtilities, getParam } from "../engine/engine_utils.js";
import { Camera } from "./Camera.js";
import { Behaviour, GameObject } from "./Component.js";
import { GroundProjectedEnv } from "./GroundProjection.js";
import { LookAtConstraint } from "./LookAtConstraint.js";
import { SyncedTransform } from "./SyncedTransform.js";
import { EventSystem, EventSystemEvents } from "./ui/EventSystem.js";
import { tryGetUIComponent } from "./ui/Utils.js";
const debug = getParam("debugorbit");
const freeCam = getParam("freecam");
const debugCameraFit = getParam("debugcamerafit");
const smoothcam = getParam("smoothcam");
const disabledKeys = { LEFT: "", UP: "", RIGHT: "", BOTTOM: "" };
let defaultKeys = undefined;
export var OrbitControlsEventsType;
(function (OrbitControlsEventsType) {
    /** Invoked with a CameraTargetReachedEvent */
    OrbitControlsEventsType["CameraTargetReached"] = "target-reached";
})(OrbitControlsEventsType || (OrbitControlsEventsType = {}));
export class CameraTargetReachedEvent extends CustomEvent {
    constructor(ctrls, type) {
        super(OrbitControlsEventsType.CameraTargetReached, {
            detail: {
                controls: ctrls,
                type: type,
            }
        });
    }
}
/** The OrbitControls component is used to control a camera using the [OrbitControls from three.js](https://threejs.org/docs/#examples/en/controls/OrbitControls) library.
 * The three OrbitControls object can be accessed via the `controls` property.
 * The object being controlled by the OrbitControls (usually the camera) can be accessed via the `controllerObject` property.
 * @category Camera Controls
 * @group Components
 */
export class OrbitControls extends Behaviour {
    /**
     * @inheritdoc
     */
    get isCameraController() {
        return true;
    }
    /** The underlying three.js OrbitControls.
     * See {@link https://threejs.org/docs/#examples/en/controls/OrbitControls}
     * @returns {@type ThreeOrbitControls | null}
    */
    get controls() {
        return this._controls;
    }
    /** The object being controlled by the OrbitControls (usually the camera)
     * See {@link https://threejs.org/docs/#examples/en/controls/OrbitControls.object}
     * @returns {@type Object3D | null}
    */
    get controllerObject() {
        return this._cameraObject;
    }
    /** Register callback when user starts interacting with the orbit controls */
    onStartInteraction(callback) {
        this.controls?.addEventListener("start", callback);
    }
    /** When enabled OrbitControls will automatically raycast find a look at target in start
     * @default true
    */
    autoTarget = true;
    /** When enabled the scene will be automatically fitted into the camera view in onEnable
     * @default false
    */
    autoFit = false;
    /** When enabled the camera can be rotated
     * @default true
    */
    enableRotate = true;
    /** When enabled the camera will rotate automatically
     * @default false
    */
    autoRotate = false;
    /** The speed at which the camera will rotate automatically. Will only be used when `autoRotate` is enabled
     * @default 1.0
    */
    autoRotateSpeed = 1.0;
    /** The minimum azimuth angle in radians */
    minAzimuthAngle = Infinity;
    /** The maximum azimuth angle in radians */
    maxAzimuthAngle = Infinity;
    /** The minimum polar angle in radians
     * @default 0
     */
    minPolarAngle = 0;
    /** The maximum polar angle in radians
     * @default Math.PI
     */
    maxPolarAngle = Math.PI;
    /** When enabled the camera can be moved using keyboard keys. The keys are defined in the `controls.keys` property
     * @default false
     */
    enableKeys = false;
    /** When enabled the camera movement will be damped
     * @default true
    */
    enableDamping = true;
    /** The damping factor for the camera movement. For more information see the [three.js documentation](https://threejs.org/docs/#examples/en/controls/OrbitControls.dampingFactor)
     * @default 0.1
     */
    dampingFactor = 0.1;
    /** When enabled the camera can be zoomed
     * @default true
    */
    enableZoom = true;
    /** The minimum zoom level
     * @default 0
     */
    minZoom = 0;
    /** The maximum zoom level
     * @default Infinity
     */
    maxZoom = Infinity;
    /**
     * Sets the zoom speed of the OrbitControls
     * @default 1
     */
    zoomSpeed = 1;
    /**
     * Set to true to enable zooming to the cursor position.
     * @default false
     */
    zoomToCursor = false;
    /** When enabled the camera can be panned
     * @default true
     */
    enablePan = true;
    /** Assigning a {@link LookAtConstraint} will make the camera look at the constraint source
     * @default null
    */
    lookAtConstraint = null;
    /** The weight of the first lookAtConstraint source
     * @default 1
    */
    lookAtConstraint01 = 1;
    /** If true user input interrupts the camera from animating to a target
     * @default true
    */
    allowInterrupt = true;
    /** If true the camera will focus on the target when the middle mouse button is clicked */
    middleClickToFocus = true;
    /** If true the camera will focus on the target when the left mouse button is double clicked
     * @default true
     */
    doubleClickToFocus = true;
    /**
     * When enabled the camera will fit the scene to the camera view when the background is clicked the specified number of times within a short time
     * @default 2
     */
    clickBackgroundToFitScene = 2;
    /**
     * @internal If true debug information will be logged to the console
     * @default false
     */
    debugLog = false;
    /**
     * @deprecated use `targetLerpDuration` instead
     * ~~The speed at which the camera target and the camera will be lerping to their destinations (if set via script or user input)~~
     * */
    get targetLerpSpeed() { return 5; }
    set targetLerpSpeed(v) { this.targetLerpDuration = 1 / v; }
    /** The duration in seconds it takes for the camera look ad and position lerp to reach their destination (when set via `setCameraTargetPosition` and `setLookTargetPosition`)
     * @default 1
     */
    targetLerpDuration = 1;
    _controls = null;
    _cameraObject = null;
    _lookTargetLerpActive = false;
    _lookTargetStartPosition = new Vector3();
    _lookTargetEndPosition = new Vector3();
    _lookTargetLerp01 = 0;
    _lookTargetLerpDuration = 0;
    _cameraLerpActive = false;
    _cameraStartPosition = new Vector3();
    _cameraEndPosition = new Vector3();
    _cameraLerp01 = 0;
    _cameraLerpDuration = 0;
    _fovLerpActive = false;
    _fovLerpStartValue = 0;
    _fovLerpEndValue = 0;
    _fovLerp01 = 0;
    _fovLerpDuration = 0;
    _inputs = 0;
    _enableTime = 0; // use to disable double click when double clicking on UI
    _startedListeningToKeyEvents = false;
    _eventSystem;
    _afterHandleInputFn;
    _camera = null;
    _syncedTransform;
    _didSetTarget = 0;
    targetElement = null;
    /** @internal */
    awake() {
        if (debug)
            console.debug("OrbitControls", this);
        this._didSetTarget = 0;
        this._startedListeningToKeyEvents = false;
    }
    /** @internal */
    start() {
        this._eventSystem = EventSystem.get(this.context) ?? undefined;
        if (this._eventSystem) {
            this._afterHandleInputFn = this.afterHandleInput.bind(this);
            this._eventSystem.addEventListener(EventSystemEvents.AfterHandleInput, this._afterHandleInputFn);
        }
    }
    /** @internal */
    onDestroy() {
        this._controls?.dispose();
        this._eventSystem?.removeEventListener(EventSystemEvents.AfterHandleInput, this._afterHandleInputFn);
    }
    /** @internal */
    onEnable() {
        this._didSetTarget = 0;
        this._enableTime = this.context.time.time;
        const cameraComponent = GameObject.getComponent(this.gameObject, Camera);
        this._camera = cameraComponent;
        let cam = cameraComponent?.threeCamera;
        if (!cam && this.gameObject instanceof PerspectiveCamera) {
            cam = this.gameObject;
        }
        if (cam)
            setCameraController(cam, this, true);
        if (!this._controls && cam instanceof PerspectiveCamera) {
            this._cameraObject = cam;
            // Using the parent if possible to make it possible to disable input on the canvas
            // for having HTML content behind it and still receive input
            const element = this.targetElement ?? this.context.renderer.domElement;
            // HACK: workaround for three orbit controls forcing an update when being created....
            const mat = cam?.quaternion.clone();
            this._controls = new ThreeOrbitControls(cam, element);
            cam?.quaternion.copy(mat);
            if (defaultKeys === undefined)
                defaultKeys = { ...this._controls.keys };
        }
        if (this._controls) {
            if (freeCam) {
                this.enablePan = true;
                this.enableZoom = true;
                this.middleClickToFocus = true;
                if (DeviceUtilities.isMobileDevice())
                    this.doubleClickToFocus = true;
            }
            this._controls.addEventListener("start", this.onControlsChangeStarted);
            if (!this._startedListeningToKeyEvents && this.enableKeys) {
                this._startedListeningToKeyEvents = true;
                this._controls.listenToKeyEvents(this.context.domElement);
            }
            else {
                try {
                    this._controls.stopListenToKeyEvents();
                }
                catch { /** this fails if we never listened to key events... */ }
            }
        }
        this._syncedTransform = GameObject.getComponent(this.gameObject, SyncedTransform) ?? undefined;
        this.context.pre_render_callbacks.push(this.__onPreRender);
        this._activePointerEvents = [];
        this.context.input.addEventListener("pointerdown", this._onPointerDown, { queue: InputEventQueue.Early });
        this.context.input.addEventListener("pointerup", this._onPointerUp, { queue: InputEventQueue.Early });
        this.context.input.addEventListener("pointerup", this._onPointerUpLate, { queue: InputEventQueue.Late });
    }
    /** @internal */
    onDisable() {
        if (this._camera?.threeCamera) {
            setCameraController(this._camera.threeCamera, this, false);
        }
        if (this._controls) {
            this._controls.enabled = false;
            this._controls.autoRotate = false;
            this._controls.removeEventListener("start", this.onControlsChangeStarted);
            try {
                this._controls.stopListenToKeyEvents();
            }
            catch { /** this fails if we never listened to key events... */ }
            this._startedListeningToKeyEvents = false;
        }
        this._activePointerEvents.length = 0;
        this.context.input.removeEventListener("pointerdown", this._onPointerDown);
        this.context.input.removeEventListener("pointerup", this._onPointerUp);
        this.context.input.removeEventListener("pointerup", this._onPointerUpLate);
    }
    _activePointerEvents;
    _lastTimeClickOnBackground = -1;
    _clickOnBackgroundCount = 0;
    _onPointerDown = (_evt) => {
        this._activePointerEvents.push(_evt);
    };
    _onPointerUp = (evt) => {
        // make sure we cleanup the active pointer events
        for (let i = this._activePointerEvents.length - 1; i >= 0; i--) {
            const registered = this._activePointerEvents[i];
            if (registered.pointerId === evt.pointerId && registered.button === evt.button) {
                this._activePointerEvents.splice(i, 1);
                break;
            }
        }
        if (this.clickBackgroundToFitScene > 0 && evt.isClick && evt.button === 0) {
            // it's possible that we didnt raycast in this frame
            if (!evt.hasRay) {
                evt.intersections.push(...this.context.physics.raycast());
            }
            if (evt.intersections.length <= 0) {
                const dt = this.context.time.time - this._lastTimeClickOnBackground;
                this._lastTimeClickOnBackground = this.context.time.time;
                if (this.clickBackgroundToFitScene <= 1 || dt < this.clickBackgroundToFitScene * .15) {
                    this._clickOnBackgroundCount += 1;
                    if (this._clickOnBackgroundCount >= this.clickBackgroundToFitScene - 1)
                        this.fitCamera(this.context.scene.children, {
                            immediate: false
                        });
                }
                else {
                    this._clickOnBackgroundCount = 0;
                }
            }
            if (debug)
                console.log(this.clickBackgroundToFitScene, evt.intersections.length, this._clickOnBackgroundCount);
        }
    };
    _onPointerUpLate = (evt) => {
        if (this.doubleClickToFocus && evt.isDoubleClick && !evt.used) {
            this.setTargetFromRaycast();
        }
    };
    onControlsChangeStarted = () => {
        if (this._syncedTransform) {
            this._syncedTransform.requestOwnership();
        }
    };
    _shouldDisable = false;
    afterHandleInput(evt) {
        if (evt.detail.args.pointerId === 0) {
            if (evt.detail.args.isDown) {
                if (this._controls && this._eventSystem) {
                    this._shouldDisable = this._eventSystem.hasActiveUI;
                }
            }
            else if (!evt.detail.args.isPressed || evt.detail.args.isUp) {
                this._shouldDisable = false;
            }
        }
    }
    /** @internal */
    onBeforeRender() {
        if (!this._controls)
            return;
        if (this._cameraObject !== this.context.mainCamera) {
            this._controls.enabled = false;
            return;
        }
        this._controls.enabled = true;
        if (this.context.input.getPointerDown(1) || this.context.input.getPointerDown(2) || this.context.input.mouseWheelChanged || (this.context.input.getPointerPressed(0) && this.context.input.getPointerPositionDelta(0)?.length() || 0 > .1)) {
            this._inputs += 1;
        }
        if (this._inputs > 0 && this.allowInterrupt) {
            // if a user has disabled rotation but enabled auto rotate we don't want to change it when we receive input
            if (this.enableRotate) {
                this.autoRotate = false;
            }
            this._cameraLerpActive = false;
            this._lookTargetLerpActive = false;
        }
        this._inputs = 0;
        if (this.autoTarget) {
            // we want to wait one frame so all matrixWorlds are updated
            // otherwise raycasting will not work correctly
            if (this._didSetTarget++ === 0) {
                const camGo = GameObject.getComponent(this.gameObject, Camera);
                if (camGo && !this.setLookTargetFromConstraint()) {
                    if (this.debugLog)
                        console.log("NO TARGET");
                    const worldPosition = getWorldPosition(camGo.threeCamera);
                    // Handle case where the camera is in 0 0 0 of the scene
                    // if the look at target is set to the camera position we can't move at all anymore
                    const distanceToCenter = Math.max(.01, worldPosition.length());
                    const forward = new Vector3(0, 0, -distanceToCenter).applyMatrix4(camGo.threeCamera.matrixWorld);
                    this.setLookTargetPosition(forward, true);
                }
                if (!this.setLookTargetFromConstraint()) {
                    const opts = new RaycastOptions();
                    // center of the screen:
                    opts.screenPoint = new Vector2(0, 0);
                    opts.lineThreshold = 0.1;
                    const hits = this.context.physics.raycast(opts);
                    if (hits.length > 0) {
                        this.setLookTargetPosition(hits[0].point, true);
                    }
                    if (debugCameraFit)
                        console.log("OrbitControls hits", ...hits);
                }
            }
        }
        const focusAtPointer = (this.middleClickToFocus && this.context.input.getPointerClicked(1));
        if (focusAtPointer) {
            this.setTargetFromRaycast();
        }
        if (this._lookTargetLerpActive || this._cameraLerpActive || this._fovLerpActive) {
            // lerp the camera
            if (this._cameraLerpActive && this._cameraObject) {
                this._cameraLerp01 += this.context.time.deltaTime / this._cameraLerpDuration;
                if (this._cameraLerp01 >= 1) {
                    this._cameraObject.position.copy(this._cameraEndPosition);
                    this._cameraLerpActive = false;
                    this.dispatchEvent(new CameraTargetReachedEvent(this, "camera"));
                }
                else {
                    const t = Mathf.easeInOutCubic(this._cameraLerp01);
                    this._cameraObject.position.lerpVectors(this._cameraStartPosition, this._cameraEndPosition, t);
                }
            }
            // lerp the look target
            if (this._lookTargetLerpActive) {
                this._lookTargetLerp01 += this.context.time.deltaTime / this._lookTargetLerpDuration;
                if (this._lookTargetLerp01 >= 1) {
                    this._controls.target.copy(this._lookTargetEndPosition);
                    this._lookTargetLerpActive = false;
                    this.dispatchEvent(new CameraTargetReachedEvent(this, "lookat"));
                }
                else {
                    const t = Mathf.easeInOutCubic(this._lookTargetLerp01);
                    this._controls.target.lerpVectors(this._lookTargetStartPosition, this._lookTargetEndPosition, t);
                }
            }
            // lerp the fov
            if (this._fovLerpActive && this._cameraObject) {
                const cam = this._cameraObject;
                this._fovLerp01 += this.context.time.deltaTime / this._fovLerpDuration;
                if (this._fovLerp01 >= 1) {
                    cam.fov = this._fovLerpEndValue;
                    this._fovLerpActive = false;
                }
                else {
                    const t = Mathf.easeInOutCubic(this._fovLerp01);
                    cam.fov = Mathf.lerp(this._fovLerpStartValue, this._fovLerpEndValue, t);
                }
                cam.updateProjectionMatrix();
            }
        }
        if (this._controls) {
            if (this.debugLog)
                this._controls.domElement = this.context.renderer.domElement;
            this._controls.enabled = !this._shouldDisable && this._camera === this.context.mainCameraComponent && !this.context.isInXR && !this._activePointerEvents.some(e => e.used);
            this._controls.keys = this.enableKeys ? defaultKeys : disabledKeys;
            this._controls.autoRotate = this.autoRotate;
            this._controls.autoRotateSpeed = this.autoRotateSpeed;
            this._controls.enableZoom = this.enableZoom;
            this._controls.zoomSpeed = this.zoomSpeed;
            this._controls.zoomToCursor = this.zoomToCursor;
            this._controls.enableDamping = this.enableDamping;
            this._controls.dampingFactor = this.dampingFactor;
            this._controls.enablePan = this.enablePan;
            this._controls.enableRotate = this.enableRotate;
            this._controls.minAzimuthAngle = this.minAzimuthAngle;
            this._controls.maxAzimuthAngle = this.maxAzimuthAngle;
            this._controls.minPolarAngle = this.minPolarAngle;
            this._controls.maxPolarAngle = this.maxPolarAngle;
            // set the min/max zoom if it's not a free cam
            if (!freeCam) {
                if (this._camera?.threeCamera?.type === "PerspectiveCamera") {
                    this._controls.minDistance = this.minZoom;
                    this._controls.maxDistance = this.maxZoom;
                    this._controls.minZoom = 0;
                    this._controls.maxZoom = Infinity;
                }
                else {
                    this._controls.minDistance = 0;
                    this._controls.maxDistance = Infinity;
                    this._controls.minZoom = this.minZoom;
                    this._controls.maxZoom = this.maxZoom;
                }
            }
            if (typeof smoothcam === "number" || smoothcam === true) {
                this._controls.enableDamping = true;
                const factor = typeof smoothcam === "number" ? smoothcam : .99;
                this._controls.dampingFactor = Math.max(.001, 1 - Math.min(1, factor));
            }
            if (!this.allowInterrupt) {
                if (this._lookTargetLerpActive) {
                    this._controls.enablePan = false;
                }
                if (this._cameraLerpActive) {
                    this._controls.enableRotate = false;
                    this._controls.autoRotate = false;
                }
                if (this._lookTargetLerpActive || this._cameraLerpActive) {
                    this._controls.enableZoom = false;
                }
            }
            // this._controls.zoomToCursor = this.zoomToCursor;
            if (!this.context.isInXR) {
                if (!freeCam && this.lookAtConstraint?.locked)
                    this.setLookTargetFromConstraint(0, this.lookAtConstraint01);
                this._controls.update(this.context.time.deltaTime);
                if (debug) {
                    Gizmos.DrawWireSphere(this._controls.target, 0.1, 0x00ff00);
                }
            }
        }
    }
    __onPreRender = () => {
        // We call this only once when the camera becomes active and use the engine pre_render_callbacks because they are run 
        // after all scripts have been executed
        const index = this.context.pre_render_callbacks.indexOf(this.__onPreRender);
        if (index >= 0) {
            this.context.pre_render_callbacks.splice(index, 1);
        }
        if (this.autoFit) {
            // we don't want to autofit again if the component is disabled and re-enabled
            this.autoFit = false;
            this.fitCamera({
                centerCamera: "y",
                immediate: true,
                objects: this.scene.children,
            });
        }
    };
    /**
     * Sets camera target position and look direction. Does perform a raycast in the forward direction of the passed in object to find an orbit point
     */
    setCameraAndLookTarget(target) {
        if (!target || !(target instanceof Object3D))
            return;
        const worldPosition = getWorldPosition(target);
        const forward = getWorldDirection(target);
        this.setTargetFromRaycast(new Ray(worldPosition, forward));
        this.setCameraTargetPosition(worldPosition);
    }
    /** Moves the camera to position smoothly.
     * @param position The position in local space of the controllerObject to move the camera to. If null the camera will stop lerping to the target.
     * @param immediateOrDuration If true the camera will move immediately to the new position, otherwise it will lerp. If a number is passed in it will be used as the duration of the lerp.
    */
    setCameraTargetPosition(position, immediateOrDuration = false) {
        if (!position)
            return;
        if (position instanceof Object3D) {
            position = getWorldPosition(position);
        }
        if (!this._cameraEndPosition)
            this._cameraEndPosition = new Vector3();
        this._cameraEndPosition.copy(position);
        if (immediateOrDuration === true) {
            this._cameraLerpActive = false;
            if (this._cameraObject) {
                this._cameraObject.position.copy(this._cameraEndPosition);
            }
        }
        else if (this._cameraObject) {
            this._cameraLerpActive = true;
            this._cameraLerp01 = 0;
            this._cameraStartPosition.copy(this._cameraObject?.position);
            if (typeof immediateOrDuration === "number") {
                this._cameraLerpDuration = immediateOrDuration;
            }
            else
                this._cameraLerpDuration = this.targetLerpDuration;
        }
    }
    /** True while the camera position is being lerped */
    get cameraLerpActive() { return this._cameraLerpActive; }
    /** Call to stop camera position lerping */
    stopCameraLerp() {
        this._cameraLerpActive = false;
    }
    setFieldOfView(fov, immediateOrDuration = false) {
        if (!this._controls)
            return;
        if (typeof fov !== "number")
            return;
        const cam = this._camera?.threeCamera;
        if (!cam)
            return;
        if (immediateOrDuration === true) {
            cam.fov = fov;
        }
        else {
            this._fovLerpActive = true;
            this._fovLerp01 = 0;
            this._fovLerpStartValue = cam.fov;
            this._fovLerpEndValue = fov;
            if (typeof immediateOrDuration === "number") {
                this._fovLerpDuration = immediateOrDuration;
            }
            else
                this._fovLerpDuration = this.targetLerpDuration;
        }
    }
    /** Moves the camera look-at target to a position smoothly.
     * @param position The position in world space to move the camera target to. If null the camera will stop lerping to the target.
     * @param immediateOrDuration If true the camera target will move immediately to the new position, otherwise it will lerp. If a number is passed in it will be used as the duration of the lerp.
    */
    setLookTargetPosition(position = null, immediateOrDuration = false) {
        if (!this._controls)
            return;
        if (!position)
            return;
        if (position instanceof Object3D) {
            position = getWorldPosition(position);
        }
        this._lookTargetEndPosition.copy(position);
        // if a user calls setLookTargetPosition we don't want to perform autoTarget in onBeforeRender (and override whatever the user set here)
        this._didSetTarget++;
        if (debug) {
            console.warn("OrbitControls: setLookTargetPosition", position, immediateOrDuration);
            Gizmos.DrawWireSphere(this._lookTargetEndPosition, .2, 0xff0000, 2);
        }
        if (immediateOrDuration === true) {
            this._controls.target.copy(this._lookTargetEndPosition);
        }
        else {
            this._lookTargetLerpActive = true;
            this._lookTargetLerp01 = 0;
            this._lookTargetStartPosition.copy(this._controls.target);
            if (typeof immediateOrDuration === "number") {
                this._lookTargetLerpDuration = immediateOrDuration;
            }
            else
                this._lookTargetLerpDuration = this.targetLerpDuration;
        }
    }
    /** True while the camera look target is being lerped */
    get lookTargetLerpActive() { return this._lookTargetLerpActive; }
    /** Call to stop camera look target lerping */
    stopLookTargetLerp() {
        this._lookTargetLerpActive = false;
    }
    /** Sets the look at target from an assigned lookAtConstraint source by index
     * @param index The index of the source to use
     * @param t The interpolation factor between the current look at target and the new target
    */
    setLookTargetFromConstraint(index = 0, t = 1) {
        if (!this._controls)
            return false;
        const sources = this.lookAtConstraint?.sources;
        if (sources && sources.length > 0) {
            const target = sources[index];
            if (target) {
                target.getWorldPosition(this._lookTargetEndPosition);
                this.lerpLookTarget(this._lookTargetEndPosition, t);
                return true;
            }
        }
        return false;
    }
    /** @deprecated use `controls.target.lerp(position, delta)` */
    lerpTarget(position, delta) { return this.lerpLookTarget(position, delta); }
    lerpLookTarget(position, delta) {
        if (!this._controls)
            return;
        if (delta >= 1)
            this._controls.target.copy(position);
        else
            this._controls.target.lerp(position, delta);
    }
    setTargetFromRaycast(ray) {
        if (!this.controls)
            return;
        const rc = ray ? this.context.physics.raycastFromRay(ray) : this.context.physics.raycast();
        for (const hit of rc) {
            if (hit.distance > 0 && GameObject.isActiveInHierarchy(hit.object)) {
                const uiComponent = tryGetUIComponent(hit.object);
                if (uiComponent) {
                    const canvas = uiComponent.canvas;
                    if (canvas?.screenspace) {
                        break;
                    }
                }
                this.setLookTargetPosition(hit.point);
                // if (this.context.mainCamera) {
                //     const pos = getWorldPosition(this.context.mainCamera);
                //     const cameraTarget = pos.clone().sub(this.controls.target).add(this._lookTargetEndPosition);
                //     this._cameraObject?.parent?.worldToLocal(cameraTarget);
                //     this.setCameraTargetPosition(cameraTarget);
                // }
                break;
            }
        }
    }
    fitCamera(objectsOrOptions, options) {
        if (this.context.isInXR) {
            // camera fitting in XR is not supported
            return;
        }
        let objects = undefined;
        // If the user passed in an array as first argument
        if (Array.isArray(objectsOrOptions)) {
            objects = objectsOrOptions;
        }
        // If the user passed in an object as first argument
        else if (objectsOrOptions && "type" in objectsOrOptions) {
            objects = objectsOrOptions.children;
        }
        // If the user passed in an object as first argument and options as second argument
        else if (objectsOrOptions && "objects" in objectsOrOptions) {
            objects = objectsOrOptions?.objects;
            options = objectsOrOptions;
        }
        // Ensure objects are setup correctly
        if (objects && !Array.isArray(objects)) {
            objects = objects.children;
        }
        if (!Array.isArray(objects) || objects && objects.length <= 0) {
            objects = this.context.scene.children;
        }
        // Make sure there's anything to fit to
        if (!Array.isArray(objects) || objects.length <= 0) {
            console.warn("No objects to fit camera to...");
            return;
        }
        const camera = this._cameraObject;
        const controls = this._controls;
        if (!camera || !controls) {
            console.warn("No camera or controls found to fit camera to objects...");
            return;
        }
        if (!options)
            options = {};
        const { immediate = false, centerCamera = "y", cameraNearFar = "auto", fitOffset = 1.1, fov = camera?.fov } = options;
        const size = new Vector3();
        const center = new Vector3();
        // TODO would be much better to calculate the bounds in camera space instead of world space - 
        // we would get proper view-dependant fit.
        // Right now it's independent from where the camera is actually looking from,
        // and thus we're just getting some maximum that will work for sure.
        const box = getBoundingBox(objects, undefined, this._camera?.threeCamera?.layers);
        const boxCopy = box.clone();
        camera.updateMatrixWorld();
        camera.updateProjectionMatrix();
        box.getCenter(center);
        const box_size = new Vector3();
        box.getSize(box_size);
        // project this box into camera space
        box.applyMatrix4(camera.matrixWorldInverse);
        box.getSize(size);
        box.setFromCenterAndSize(center, size);
        if (Number.isNaN(size.x) || Number.isNaN(size.y) || Number.isNaN(size.z)) {
            console.warn("Camera fit size resultet in NaN", camera, box, [...objects]);
            return;
        }
        if (size.length() <= 0.0000000001) {
            if (debugCameraFit)
                console.warn("Camera fit size is zero", box, [...objects]);
            return;
        }
        const verticalFov = options.fov || camera.fov;
        const horizontalFov = 2 * Math.atan(Math.tan(verticalFov * Math.PI / 360 / 2) * camera.aspect) / Math.PI * 360;
        const fitHeightDistance = size.y / (2 * Math.atan(Math.PI * verticalFov / 360));
        const fitWidthDistance = size.x / (2 * Math.atan(Math.PI * horizontalFov / 360));
        const distance = fitOffset * Math.max(fitHeightDistance, fitWidthDistance) + size.z / 2;
        if (debugCameraFit) {
            console.log("Fit camera to objects", { fitHeightDistance, fitWidthDistance, distance, verticalFov, horizontalFov });
        }
        this.maxZoom = distance * 10;
        this.minZoom = distance * 0.01;
        const verticalOffset = 0.05;
        const lookAt = center.clone();
        lookAt.y -= size.y * verticalOffset;
        this.setLookTargetPosition(lookAt, immediate);
        this.setFieldOfView(options.fov, immediate);
        this.autoTarget = false;
        if (cameraNearFar == undefined || cameraNearFar == "auto") {
            // Check if the scene has a GroundProjectedEnv and include the scale to the far plane so that it doesnt cut off
            const groundprojection = GameObject.findObjectOfType(GroundProjectedEnv);
            const groundProjectionRadius = groundprojection ? groundprojection.radius : 0;
            const boundsMax = Math.max(box_size.x, box_size.y, box_size.z, groundProjectionRadius);
            // TODO: this doesnt take the Camera component nearClipPlane into account
            camera.near = (distance / 100);
            camera.far = boundsMax + distance * 10;
            // adjust maxZoom so that the ground projection radius is always inside
            if (groundprojection) {
                this.maxZoom = Math.max(Math.min(this.maxZoom, groundProjectionRadius * 0.5), distance);
            }
        }
        // ensure we're not clipping out of the current zoom level just because we're fitting
        const currentZoom = controls.getDistance();
        if (currentZoom < this.minZoom)
            this.minZoom = currentZoom * 0.9;
        if (currentZoom > this.maxZoom)
            this.maxZoom = currentZoom * 1.1;
        camera.updateMatrixWorld();
        camera.updateProjectionMatrix();
        const cameraWp = getWorldPosition(camera);
        const direction = center.clone();
        direction.sub(cameraWp);
        if (centerCamera === "y")
            direction.y = 0;
        direction.normalize();
        direction.multiplyScalar(distance);
        if (centerCamera === "y")
            direction.y += -verticalOffset * 4 * distance;
        let cameraLocalPosition = center.clone().sub(direction);
        if (camera.parent) {
            cameraLocalPosition = camera.parent.worldToLocal(cameraLocalPosition);
        }
        this.setCameraTargetPosition(cameraLocalPosition, immediate);
        if (debugCameraFit) {
            const helper = new Box3Helper(box);
            this.context.scene.add(helper);
            setWorldRotation(helper, getWorldRotation(camera));
            setTimeout(() => {
                this.context.scene.remove(helper);
            }, 10_000);
            Gizmos.DrawWireBox3(boxCopy, 0x00ff00, 10);
            if (!this._haveAttachedKeyboardEvents) {
                this._haveAttachedKeyboardEvents = true;
                document.body.addEventListener("keydown", (e) => {
                    if (e.code === "KeyF") {
                        // random fov for easier debugging of fov-based fitting
                        let fov = undefined;
                        if (this._cameraObject instanceof PerspectiveCamera)
                            fov = (Math.random() * Math.random()) * 170 + 10;
                        this.fitCamera({ objects, fitOffset, immediate: false, fov });
                    }
                    if (e.code === "KeyV") {
                        if (this._cameraObject instanceof PerspectiveCamera)
                            this._cameraObject.fov = 60;
                    }
                });
            }
        }
        controls.update();
    }
    _haveAttachedKeyboardEvents = false;
}
__decorate([
    serializable()
], OrbitControls.prototype, "autoTarget", void 0);
__decorate([
    serializable()
], OrbitControls.prototype, "autoFit", void 0);
__decorate([
    serializable()
], OrbitControls.prototype, "enableRotate", void 0);
__decorate([
    serializable()
], OrbitControls.prototype, "autoRotate", void 0);
__decorate([
    serializable()
], OrbitControls.prototype, "autoRotateSpeed", void 0);
__decorate([
    serializable()
], OrbitControls.prototype, "minAzimuthAngle", void 0);
__decorate([
    serializable()
], OrbitControls.prototype, "maxAzimuthAngle", void 0);
__decorate([
    serializable()
], OrbitControls.prototype, "minPolarAngle", void 0);
__decorate([
    serializable()
], OrbitControls.prototype, "maxPolarAngle", void 0);
__decorate([
    serializable()
], OrbitControls.prototype, "enableKeys", void 0);
__decorate([
    serializable()
], OrbitControls.prototype, "enableDamping", void 0);
__decorate([
    serializable()
], OrbitControls.prototype, "dampingFactor", void 0);
__decorate([
    serializable()
], OrbitControls.prototype, "enableZoom", void 0);
__decorate([
    serializable()
], OrbitControls.prototype, "minZoom", void 0);
__decorate([
    serializable()
], OrbitControls.prototype, "maxZoom", void 0);
__decorate([
    serializable()
], OrbitControls.prototype, "zoomSpeed", void 0);
__decorate([
    serializable()
], OrbitControls.prototype, "enablePan", void 0);
__decorate([
    serializable(LookAtConstraint)
], OrbitControls.prototype, "lookAtConstraint", void 0);
__decorate([
    serializable()
], OrbitControls.prototype, "lookAtConstraint01", void 0);
__decorate([
    serializable()
], OrbitControls.prototype, "allowInterrupt", void 0);
__decorate([
    serializable()
], OrbitControls.prototype, "middleClickToFocus", void 0);
__decorate([
    serializable()
], OrbitControls.prototype, "doubleClickToFocus", void 0);
__decorate([
    serializable()
], OrbitControls.prototype, "clickBackgroundToFitScene", void 0);
__decorate([
    serializable()
], OrbitControls.prototype, "targetLerpDuration", void 0);
//# sourceMappingURL=OrbitControls.js.map