import { isDevEnvironment } from "../debug/index.js";
import { isResourceTrackingEnabled } from "../engine_assetdatabase.js";
import { getParam } from "../engine_utils.js";
import { NEEDLE_lightmaps } from "../extensions/NEEDLE_lightmaps.js";
import { EXT_texture_exr } from "./EXT_texture_exr.js";
import { NEEDLE_components } from "./NEEDLE_components.js";
import { NEEDLE_gameobject_data } from "./NEEDLE_gameobject_data.js";
import { NEEDLE_lighting_settings } from "./NEEDLE_lighting_settings.js";
import { NEEDLE_persistent_assets } from "./NEEDLE_persistent_assets.js";
import { NEEDLE_progressive } from "./NEEDLE_progressive.js";
import { NEEDLE_render_objects } from "./NEEDLE_render_objects.js";
import { NEEDLE_techniques_webgl } from "./NEEDLE_techniques_webgl.js";
import { InternalUsageTrackerPlugin } from "./usage_tracker.js";
const debug = getParam("debugextensions");
// lazily import the GLTFAnimationPointerExtension in case it doesnt exist (e.g. using vanilla three)
let GLTFAnimationPointerExtension;
const KHR_ANIMATIONPOINTER_IMPORT = import("three/examples/jsm/loaders/GLTFLoaderAnimationPointer.js").then(async (mod) => {
    GLTFAnimationPointerExtension = mod.GLTFAnimationPointerExtension;
    return GLTFAnimationPointerExtension;
}).catch(e => {
    console.warn("Failed to import GLTFLoaderAnimationPointer. Please use @needle-tools/three for full KHR_animation support", e);
});
/**
 * Registered custom glTF extension plugins
 */
const _plugins = new Array();
/** Register callbacks for registering custom gltf importer or exporter plugins */
export function addCustomExtensionPlugin(ext) {
    if (!_plugins.includes(ext)) {
        _plugins.push(ext);
    }
}
/** Unregister callbacks for registering custom gltf importer or exporter plugins */
export function removeCustomImportExtensionType(ext) {
    const index = _plugins.indexOf(ext);
    if (index >= 0)
        _plugins.splice(index, 1);
}
/** Registers the Needle Engine components extension */
export function registerComponentExtension(loader) {
    const ext = new NEEDLE_components();
    loader.register(p => {
        ext.parser = p;
        return ext;
    });
    return ext;
}
class PointerResolver {
    resolvePath(path) {
        if (path.includes('/extensions/builtin_components/'))
            return path.replace('/extensions/builtin_components/', '/userData/components/');
        if (path.includes('extensions/builtin_components/'))
            return path.replace('extensions/builtin_components/', '/userData/components/');
        return path;
    }
}
export async function registerExtensions(loader, context, url) {
    // Make sure to remove any url parameters from the sourceId (because the source id in the renderer does not have a ?v=xxx so it will not be able to register the resolved lightmap otherwise)
    const idEnd = url.indexOf("?");
    if (idEnd >= 0)
        url = url.substring(0, idEnd);
    loader.register(p => new NEEDLE_gameobject_data(p));
    loader.register(p => new NEEDLE_persistent_assets(p));
    loader.register(p => new NEEDLE_lightmaps(p, context.lightmaps, url));
    loader.register(p => new NEEDLE_lighting_settings(p, url, context));
    loader.register(p => new NEEDLE_techniques_webgl(p, url));
    loader.register(p => new NEEDLE_render_objects(p, url));
    loader.register(p => new NEEDLE_progressive(p, url));
    loader.register(p => new EXT_texture_exr(p));
    if (isResourceTrackingEnabled())
        loader.register(p => new InternalUsageTrackerPlugin(p));
    await KHR_ANIMATIONPOINTER_IMPORT.catch(_ => { });
    loader.register(p => {
        if (GLTFAnimationPointerExtension) {
            const ext = new GLTFAnimationPointerExtension(p);
            const setPointerResolverFunction = ext.setAnimationPointerResolver;
            setPointerResolverFunction.bind(ext)(new PointerResolver());
            return ext;
        }
        else {
            if (debug || isDevEnvironment())
                console.error("Missing KHR_animation_pointer extension...");
            return {
                name: "KHR_animation_pointer_NOT_AVAILABLE"
            };
        }
    });
    for (const plugin of _plugins) {
        if (plugin.onImport)
            plugin.onImport(loader, url, context);
    }
}
export function registerExportExtensions(exp, context) {
    for (const ext of _plugins)
        if (ext.onExport)
            ext.onExport(exp, context);
}
/** @internal */
export function invokeAfterImportPluginHooks(url, gltf, context) {
    for (const ext of _plugins)
        if (ext.onLoaded)
            ext.onLoaded(url, gltf, context);
}
//# sourceMappingURL=extensions.js.map