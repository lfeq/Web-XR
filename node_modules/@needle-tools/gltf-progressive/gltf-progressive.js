var Ve = Object.defineProperty;
var Ne = (o, t, e) => t in o ? Ve(o, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : o[t] = e;
var d = (o, t, e) => (Ne(o, typeof t != "symbol" ? t + "" : t, e), e), Te = (o, t, e) => {
  if (!t.has(o))
    throw TypeError("Cannot " + e);
};
var m = (o, t, e) => (Te(o, t, "read from private field"), e ? e.call(o) : t.get(o)), K = (o, t, e) => {
  if (t.has(o))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(o) : t.set(o, e);
}, U = (o, t, e, s) => (Te(o, t, "write to private field"), s ? s.call(o, e) : t.set(o, e), e);
import { BufferGeometry as ge, Mesh as H, Material as We, Texture as se, TextureLoader as qe, Matrix4 as Ae, Clock as Xe, MeshStandardMaterial as Ke, Sphere as Ye, Box3 as Ee, Vector3 as z } from "three";
import { GLTFLoader as be } from "three/examples/jsm/loaders/GLTFLoader.js";
import { MeshoptDecoder as He } from "three/examples/jsm/libs/meshopt_decoder.module.js";
import { DRACOLoader as Je } from "three/examples/jsm/loaders/DRACOLoader.js";
import { KTX2Loader as Qe } from "three/examples/jsm/loaders/KTX2Loader.js";
const Ie = "";
globalThis.GLTF_PROGRESSIVE_VERSION = Ie;
console.debug(`[gltf-progressive] version ${Ie}`);
let j = "https://www.gstatic.com/draco/versioned/decoders/1.5.7/", ae = "https://www.gstatic.com/basis-universal/versioned/2021-04-15-ba1c3e4/";
const Ze = j, je = ae;
fetch(j + "draco_decoder.js", { method: "head" }).catch((o) => {
  j === Ze && (j = "./include/draco/"), ae === je && (ae = "./include/ktx2/");
});
function Lt(o) {
  j = o;
}
function xt(o) {
  ae = o;
}
let Q, he, Z;
function Re(o) {
  return Q || (Q = new Je(), Q.setDecoderPath(j), Q.setDecoderConfig({ type: "js" })), Z || (Z = new Qe(), Z.setTranscoderPath(ae)), he || (he = He), o ? Z.detectSupport(o) : o !== null && console.warn("No renderer provided to detect ktx2 support - loading KTX2 textures might fail"), { dracoLoader: Q, ktx2Loader: Z, meshoptDecoder: he };
}
function Ge(o) {
  o.dracoLoader || o.setDRACOLoader(Q), o.ktx2Loader || o.setKTX2Loader(Z), o.meshoptDecoder || o.setMeshoptDecoder(he);
}
const Oe = /* @__PURE__ */ new WeakMap();
function et(o, t) {
  let e = Oe.get(o);
  e ? e = Object.assign(e, t) : e = t, Oe.set(o, e);
}
const Me = be.prototype.load;
function tt(...o) {
  const t = Oe.get(this);
  let e = o[0];
  const s = new URL(e, window.location.href);
  if (s.hostname.endsWith("needle.tools")) {
    const r = (t == null ? void 0 : t.progressive) !== void 0 ? t.progressive : !0, i = t != null && t.usecase ? t.usecase : "default";
    r ? this.requestHeader.Accept = `*/*;progressive=allowed;usecase=${i}` : this.requestHeader.Accept = `*/*;usecase=${i}`, e = s.toString();
  }
  return o[0] = e, Me == null ? void 0 : Me.call(this, ...o);
}
be.prototype.load = tt;
le("debugprogressive");
function le(o) {
  if (typeof window > "u")
    return !1;
  const e = new URL(window.location.href).searchParams.get(o);
  return e == null || e === "0" || e === "false" ? !1 : e === "" ? !0 : e;
}
function st(o, t) {
  if (t === void 0 || t.startsWith("./") || t.startsWith("http") || o === void 0)
    return t;
  const e = o.lastIndexOf("/");
  if (e >= 0) {
    const s = o.substring(0, e + 1);
    for (; s.endsWith("/") && t.startsWith("/"); )
      t = t.substring(1);
    return s + t;
  }
  return t;
}
let re;
function rt() {
  return re !== void 0 || (re = /iPhone|iPad|iPod|Android|IEMobile/i.test(navigator.userAgent), le("debugprogressive") && console.log("[glTF Progressive]: isMobileDevice", re)), re;
}
const _e = Symbol("needle:raycast-mesh");
function me(o) {
  return (o == null ? void 0 : o[_e]) instanceof ge ? o[_e] : null;
}
function it(o, t) {
  if ((o.type === "Mesh" || o.type === "SkinnedMesh") && !me(o)) {
    const s = nt(t);
    s.userData = { isRaycastMesh: !0 }, o[_e] = s;
  }
}
function Mt(o = !0) {
  if (o) {
    if (ie)
      return;
    const t = ie = H.prototype.raycast;
    H.prototype.raycast = function(e, s) {
      const n = this, r = me(n);
      let i;
      r && n.isMesh && (i = n.geometry, n.geometry = r), t.call(this, e, s), i && (n.geometry = i);
    };
  } else {
    if (!ie)
      return;
    H.prototype.raycast = ie, ie = null;
  }
}
let ie = null;
function nt(o) {
  const t = new ge();
  for (const e in o.attributes)
    t.setAttribute(e, o.getAttribute(e));
  return t.setIndex(o.getIndex()), t;
}
const Y = new Array(), V = "NEEDLE_progressive", L = le("debugprogressive"), De = Symbol("needle-progressive-texture"), oe = /* @__PURE__ */ new Map(), Se = /* @__PURE__ */ new Set();
if (L) {
  let o = function() {
    t += 1, console.log("Toggle LOD level", t, oe), oe.forEach((n, r) => {
      for (const i of n.keys) {
        const a = r[i];
        if (a != null) {
          if (a.isBufferGeometry === !0) {
            const l = _.getMeshLODInformation(a), u = l ? Math.min(t, l.lods.length) : 0;
            r["DEBUG:LOD"] = t, _.assignMeshLOD(r, u), l && (e = Math.max(e, l.lods.length - 1));
          } else if (r.isMaterial === !0) {
            r["DEBUG:LOD"] = t, _.assignTextureLOD(r, t);
            break;
          }
        }
      }
    }), t >= e && (t = -1);
  }, t = -1, e = 2, s = !1;
  window.addEventListener("keyup", (n) => {
    n.key === "p" && o(), n.key === "w" && (s = !s, Se && Se.forEach((r) => {
      r.name != "BackgroundCubeMaterial" && r.glyphMap == null && "wireframe" in r && (r.wireframe = s);
    }));
  });
}
function Pe(o, t, e) {
  var n;
  if (!L)
    return;
  oe.has(o) || oe.set(o, { keys: [], sourceId: e });
  const s = oe.get(o);
  ((n = s == null ? void 0 : s.keys) == null ? void 0 : n.includes(t)) == !1 && s.keys.push(t);
}
const v = class {
  constructor(t, e) {
    d(this, "parser");
    d(this, "url");
    d(this, "_isLoadingMesh");
    d(this, "loadMesh", (t) => {
      var s, n;
      if (this._isLoadingMesh)
        return null;
      const e = (n = (s = this.parser.json.meshes[t]) == null ? void 0 : s.extensions) == null ? void 0 : n[V];
      return e ? (this._isLoadingMesh = !0, this.parser.getDependency("mesh", t).then((r) => {
        var i;
        return this._isLoadingMesh = !1, r && v.registerMesh(this.url, e.guid, r, (i = e.lods) == null ? void 0 : i.length, void 0, e), r;
      })) : null;
    });
    L && console.log("Progressive extension registered for", e), this.parser = t, this.url = e;
  }
  /** The name of the extension */
  get name() {
    return V;
  }
  static getMeshLODInformation(t) {
    const e = this.getAssignedLODInformation(t);
    return e != null && e.key ? this.lodInfos.get(e.key) : null;
  }
  static getMaterialMinMaxLODsCount(t, e) {
    const s = this, n = "LODS:minmax", r = t[n];
    if (r != null)
      return r;
    if (e || (e = {
      min_count: 1 / 0,
      max_count: 0,
      lods: []
    }), Array.isArray(t)) {
      for (const a of t)
        this.getMaterialMinMaxLODsCount(a, e);
      return t[n] = e, e;
    }
    if (L === "verbose" && console.log("getMaterialMinMaxLODsCount", t), t.type === "ShaderMaterial" || t.type === "RawShaderMaterial") {
      const a = t;
      for (const l of Object.keys(a.uniforms)) {
        const u = a.uniforms[l].value;
        (u == null ? void 0 : u.isTexture) === !0 && i(u, e);
      }
    } else if (t.isMaterial)
      for (const a of Object.keys(t)) {
        const l = t[a];
        (l == null ? void 0 : l.isTexture) === !0 && i(l, e);
      }
    return t[n] = e, e;
    function i(a, l) {
      const u = s.getAssignedLODInformation(a);
      if (u) {
        const c = s.lodInfos.get(u.key);
        if (c && c.lods) {
          l.min_count = Math.min(l.min_count, c.lods.length), l.max_count = Math.max(l.max_count, c.lods.length);
          for (let g = 0; g < c.lods.length; g++) {
            const p = c.lods[g];
            p.width && (l.lods[g] = l.lods[g] || { min_height: 1 / 0, max_height: 0 }, l.lods[g].min_height = Math.min(l.lods[g].min_height, p.height), l.lods[g].max_height = Math.max(l.lods[g].max_height, p.height));
          }
        }
      }
    }
  }
  /** Check if a LOD level is available for a mesh or a texture
   * @param obj the mesh or texture to check
   * @param level the level of detail to check for (0 is the highest resolution). If undefined, the function checks if any LOD level is available
   * @returns true if the LOD level is available (or if any LOD level is available if level is undefined)
   */
  static hasLODLevelAvailable(t, e) {
    var r;
    if (Array.isArray(t)) {
      for (const i of t)
        if (this.hasLODLevelAvailable(i, e))
          return !0;
      return !1;
    }
    if (t.isMaterial === !0) {
      for (const i of Object.keys(t)) {
        const a = t[i];
        if (a && a.isTexture && this.hasLODLevelAvailable(a, e))
          return !0;
      }
      return !1;
    } else if (t.isGroup === !0) {
      for (const i of t.children)
        if (i.isMesh === !0 && this.hasLODLevelAvailable(i, e))
          return !0;
    }
    let s, n;
    if (t.isMesh ? s = t.geometry : (t.isBufferGeometry || t.isTexture) && (s = t), s && (r = s == null ? void 0 : s.userData) != null && r.LODS) {
      const i = s.userData.LODS;
      if (n = this.lodInfos.get(i.key), e === void 0)
        return n != null;
      if (n)
        return Array.isArray(n.lods) ? e < n.lods.length : e === 0;
    }
    return !1;
  }
  /** Load a different resolution of a mesh (if available)
   * @param context the context
   * @param source the sourceid of the file from which the mesh is loaded (this is usually the component's sourceId)
   * @param mesh the mesh to load the LOD for
   * @param level the level of detail to load (0 is the highest resolution)
   * @returns a promise that resolves to the mesh with the requested LOD level
   * @example
   * ```javascript
   * const mesh = this.gameObject as Mesh;
   * NEEDLE_progressive.assignMeshLOD(context, sourceId, mesh, 1).then(mesh => {
   *    console.log("Mesh with LOD level 1 loaded", mesh);
   * });
   * ```
   */
  static assignMeshLOD(t, e) {
    var s;
    if (!t)
      return Promise.resolve(null);
    if (t instanceof H || t.isMesh === !0) {
      const n = t.geometry, r = this.getAssignedLODInformation(n);
      if (!r)
        return Promise.resolve(null);
      for (const i of Y)
        (s = i.onBeforeGetLODMesh) == null || s.call(i, t, e);
      return t["LOD:requested level"] = e, v.getOrLoadLOD(n, e).then((i) => {
        if (Array.isArray(i)) {
          const a = r.index || 0;
          i = i[a];
        }
        return t["LOD:requested level"] === e && (delete t["LOD:requested level"], i && n != i && ((i == null ? void 0 : i.isBufferGeometry) ? (t.geometry = i, L && Pe(t, "geometry", r.url)) : L && console.error("Invalid LOD geometry", i))), i;
      }).catch((i) => (console.error("Error loading mesh LOD", t, i), null));
    } else
      L && console.error("Invalid call to assignMeshLOD: Request mesh LOD but the object is not a mesh", t);
    return Promise.resolve(null);
  }
  static assignTextureLOD(t, e = 0) {
    if (!t)
      return Promise.resolve(null);
    if (t.isMesh === !0) {
      const s = t;
      if (Array.isArray(s.material)) {
        const n = new Array();
        for (const r of s.material) {
          const i = this.assignTextureLOD(r, e);
          n.push(i);
        }
        return Promise.all(n).then((r) => {
          const i = new Array();
          for (const a of r)
            Array.isArray(a) && i.push(...a);
          return i;
        });
      } else
        return this.assignTextureLOD(s.material, e);
    }
    if (t instanceof We || t.isMaterial === !0) {
      const s = t, n = [], r = new Array();
      if (L && Se.add(s), s.uniforms && (s.isRawShaderMaterial || s.isShaderMaterial === !0)) {
        const i = s;
        for (const a of Object.keys(i.uniforms)) {
          const l = i.uniforms[a].value;
          if ((l == null ? void 0 : l.isTexture) === !0) {
            const u = this.assignTextureLODForSlot(l, e, s, a).then((c) => (c && i.uniforms[a].value != c && (i.uniforms[a].value = c, i.uniformsNeedUpdate = !0), c));
            n.push(u), r.push(a);
          }
        }
      } else
        for (const i of Object.keys(s)) {
          const a = s[i];
          if ((a == null ? void 0 : a.isTexture) === !0) {
            const l = this.assignTextureLODForSlot(a, e, s, i);
            n.push(l), r.push(i);
          }
        }
      return Promise.all(n).then((i) => {
        const a = new Array();
        for (let l = 0; l < i.length; l++) {
          const u = i[l], c = r[l];
          u && u.isTexture === !0 ? a.push({ material: s, slot: c, texture: u, level: e }) : a.push({ material: s, slot: c, texture: null, level: e });
        }
        return a;
      });
    }
    if (t instanceof se || t.isTexture === !0) {
      const s = t;
      return this.assignTextureLODForSlot(s, e, null, null);
    }
    return Promise.resolve(null);
  }
  static assignTextureLODForSlot(t, e, s, n) {
    return (t == null ? void 0 : t.isTexture) !== !0 ? Promise.resolve(null) : n === "glyphMap" ? Promise.resolve(t) : v.getOrLoadLOD(t, e).then((r) => {
      if (Array.isArray(r))
        return null;
      if ((r == null ? void 0 : r.isTexture) === !0) {
        if (r != t) {
          if (s && n) {
            const i = s[n];
            if (i) {
              const a = this.getAssignedLODInformation(i);
              if (a && (a == null ? void 0 : a.level) < e)
                return L === "verbose" && console.warn("Assigned texture level is already higher: ", a.level, e, s, i, r), null;
            }
            s[n] = r;
          }
          if (L && n && s) {
            const i = this.getAssignedLODInformation(t);
            i && Pe(s, n, i.url);
          }
        }
        return r;
      } else
        L == "verbose" && console.warn("No LOD found for", t, e);
      return null;
    }).catch((r) => (console.error("Error loading LOD", t, r), null));
  }
  afterRoot(t) {
    var e, s;
    return L && console.log("AFTER", this.url, t), (e = this.parser.json.textures) == null || e.forEach((n, r) => {
      var i;
      if (n != null && n.extensions) {
        const a = n == null ? void 0 : n.extensions[V];
        if (a) {
          if (!a.lods) {
            L && console.warn("Texture has no LODs", a);
            return;
          }
          let l = !1;
          for (const u of this.parser.associations.keys())
            if (u.isTexture === !0) {
              const c = this.parser.associations.get(u);
              (c == null ? void 0 : c.textures) === r && (l = !0, v.registerTexture(this.url, u, (i = a.lods) == null ? void 0 : i.length, r, a));
            }
          l || this.parser.getDependency("texture", r).then((u) => {
            var c;
            u && v.registerTexture(this.url, u, (c = a.lods) == null ? void 0 : c.length, r, a);
          });
        }
      }
    }), (s = this.parser.json.meshes) == null || s.forEach((n, r) => {
      if (n != null && n.extensions) {
        const i = n == null ? void 0 : n.extensions[V];
        if (i && i.lods) {
          for (const a of this.parser.associations.keys())
            if (a.isMesh) {
              const l = this.parser.associations.get(a);
              (l == null ? void 0 : l.meshes) === r && v.registerMesh(this.url, i.guid, a, i.lods.length, l.primitives, i);
            }
        }
      }
    }), null;
  }
  static async getOrLoadLOD(t, e) {
    var a, l, u, c;
    const s = L == "verbose", n = t.userData.LODS;
    if (!n)
      return null;
    const r = n == null ? void 0 : n.key;
    let i;
    if (t.isTexture === !0) {
      const g = t;
      g.source && g.source[De] && (i = g.source[De]);
    }
    if (i || (i = v.lodInfos.get(r)), i) {
      if (e > 0) {
        let M = !1;
        const w = Array.isArray(i.lods);
        if (w && e >= i.lods.length ? M = !0 : w || (M = !0), M)
          return this.lowresCache.get(r);
      }
      const g = Array.isArray(i.lods) ? (a = i.lods[e]) == null ? void 0 : a.path : i.lods;
      if (!g)
        return L && !i["missing:uri"] && (i["missing:uri"] = !0, console.warn("Missing uri for progressive asset for LOD " + e, i)), null;
      const p = st(n.url, g);
      if (p.endsWith(".glb") || p.endsWith(".gltf")) {
        if (!i.guid)
          return console.warn("missing pointer for glb/gltf texture", i), null;
        const M = p + "_" + i.guid, w = this.previouslyLoaded.get(M);
        if (w !== void 0) {
          s && console.log(`LOD ${e} was already loading/loaded: ${M}`);
          let h = await w.catch((F) => (console.error(`Error loading LOD ${e} from ${p}
`, F), null)), B = !1;
          if (h == null || (h instanceof se && t instanceof se ? (l = h.image) != null && l.data || (u = h.source) != null && u.data ? h = this.copySettings(t, h) : (B = !0, this.previouslyLoaded.delete(M)) : h instanceof ge && t instanceof ge && ((c = h.attributes.position) != null && c.array || (B = !0, this.previouslyLoaded.delete(M)))), !B)
            return h;
        }
        const x = i, $ = new Promise(async (h, B) => {
          const F = new be();
          Ge(F), L && (await new Promise((A) => setTimeout(A, 1e3)), s && console.warn("Start loading (delayed) " + p, x.guid));
          let k = p;
          if (x && Array.isArray(x.lods)) {
            const A = x.lods[e];
            A.hash && (k += "?v=" + A.hash);
          }
          const S = await F.loadAsync(k).catch((A) => (console.error(`Error loading LOD ${e} from ${p}
`, A), null));
          if (!S)
            return null;
          const q = S.parser;
          s && console.log("Loading finished " + p, x.guid);
          let T = 0;
          if (S.parser.json.textures) {
            let A = !1;
            for (const f of S.parser.json.textures) {
              if (f != null && f.extensions) {
                const y = f == null ? void 0 : f.extensions[V];
                if (y != null && y.guid && y.guid === x.guid) {
                  A = !0;
                  break;
                }
              }
              T++;
            }
            if (A) {
              let f = await q.getDependency("texture", T);
              return f && v.assignLODInformation(n.url, f, r, e, void 0, void 0), s && console.log('change "' + t.name + '" → "' + f.name + '"', p, T, f, M), t instanceof se && (f = this.copySettings(t, f)), f && (f.guid = x.guid), h(f);
            } else
              L && console.warn("Could not find texture with guid", x.guid, S.parser.json);
          }
          if (T = 0, S.parser.json.meshes) {
            let A = !1;
            for (const f of S.parser.json.meshes) {
              if (f != null && f.extensions) {
                const y = f == null ? void 0 : f.extensions[V];
                if (y != null && y.guid && y.guid === x.guid) {
                  A = !0;
                  break;
                }
              }
              T++;
            }
            if (A) {
              const f = await q.getDependency("mesh", T), y = x;
              if (s && console.log(`Loaded Mesh "${f.name}"`, p, T, f, M), f.isMesh === !0) {
                const O = f.geometry;
                return v.assignLODInformation(n.url, O, r, e, void 0, y.density), h(O);
              } else {
                const O = new Array();
                for (let b = 0; b < f.children.length; b++) {
                  const E = f.children[b];
                  if (E.isMesh === !0) {
                    const X = E.geometry;
                    v.assignLODInformation(n.url, X, r, e, b, y.density), O.push(X);
                  }
                }
                return h(O);
              }
            } else
              L && console.warn("Could not find mesh with guid", x.guid, S.parser.json);
          }
          return h(null);
        });
        return this.previouslyLoaded.set(M, $), await $;
      } else if (t instanceof se) {
        s && console.log("Load texture from uri: " + p);
        const w = await new qe().loadAsync(p);
        return w ? (w.guid = i.guid, w.flipY = !1, w.needsUpdate = !0, w.colorSpace = t.colorSpace, s && console.log(i, w)) : L && console.warn("failed loading", p), w;
      }
    } else
      L && console.warn(`Can not load LOD ${e}: no LOD info found for "${r}" ${t.name}`, t.type);
    return null;
  }
  static assignLODInformation(t, e, s, n, r, i) {
    if (!e)
      return;
    e.userData || (e.userData = {});
    const a = new ot(t, s, n, r, i);
    e.userData.LODS = a;
  }
  static getAssignedLODInformation(t) {
    var e;
    return ((e = t == null ? void 0 : t.userData) == null ? void 0 : e.LODS) || null;
  }
  // private static readonly _copiedTextures: WeakMap<Texture, Texture> = new Map();
  static copySettings(t, e) {
    return e = e.clone(), L && console.warn(`Copying texture settings
`, t.uuid, `
`, e.uuid), e.offset = t.offset, e.repeat = t.repeat, e.colorSpace = t.colorSpace, e.magFilter = t.magFilter, e.minFilter = t.minFilter, e.wrapS = t.wrapS, e.wrapT = t.wrapT, e.flipY = t.flipY, e.anisotropy = t.anisotropy, e.mipmaps || (e.generateMipmaps = t.generateMipmaps), e;
  }
};
let _ = v;
/**
 * Register a texture with LOD information
 */
d(_, "registerTexture", (t, e, s, n, r) => {
  if (L && console.log("> Progressive: register texture", n, e.name, e.uuid, e, r), !e) {
    L && console.error("gltf-progressive: Register texture without texture");
    return;
  }
  e.source && (e.source[De] = r);
  const i = r.guid;
  v.assignLODInformation(t, e, i, s, n, void 0), v.lodInfos.set(i, r), v.lowresCache.set(i, e);
}), /**
 * Register a mesh with LOD information
 */
d(_, "registerMesh", (t, e, s, n, r, i) => {
  var u;
  L && console.log("> Progressive: register mesh", r, s.name, i, s.uuid, s);
  const a = s.geometry;
  if (!a) {
    L && console.warn("gltf-progressive: Register mesh without geometry");
    return;
  }
  a.userData || (a.userData = {}), v.assignLODInformation(t, a, e, n, r, i.density), v.lodInfos.set(e, i);
  let l = v.lowresCache.get(e);
  l ? l.push(s.geometry) : l = [s.geometry], v.lowresCache.set(e, l), n > 0 && !me(s) && it(s, a);
  for (const c of Y)
    (u = c.onRegisteredNewMesh) == null || u.call(c, s, i);
}), /** A map of key = asset uuid and value = LOD information */
d(_, "lodInfos", /* @__PURE__ */ new Map()), /** cache of already loaded mesh lods */
d(_, "previouslyLoaded", /* @__PURE__ */ new Map()), /** this contains the geometry/textures that were originally loaded */
d(_, "lowresCache", /* @__PURE__ */ new Map());
class ot {
  constructor(t, e, s, n, r) {
    d(this, "url");
    /** the key to lookup the LOD information */
    d(this, "key");
    d(this, "level");
    /** For multi objects (e.g. a group of meshes) this is the index of the object */
    d(this, "index");
    /** the mesh density */
    d(this, "density");
    this.url = t, this.key = e, this.level = s, n != null && (this.index = n), r != null && (this.density = r);
  }
}
const I = le("debugprogressive"), at = le("noprogressive"), we = Symbol("Needle:LODSManager"), ve = Symbol("Needle:LODState"), J = Symbol("Needle:CurrentLOD"), R = { mesh_lod: -1, texture_lod: -1 };
var C, N, pe, ee, te, ye, W;
const P = class {
  // readonly plugins: NEEDLE_progressive_plugin[] = [];
  constructor(t, e) {
    d(this, "context");
    d(this, "renderer");
    d(this, "projectionScreenMatrix", new Ae());
    /**
     * The target triangle density is the desired max amount of triangles on screen when the mesh is filling the screen.  
     * @default 200_000
     */
    d(this, "targetTriangleDensity", 2e5);
    /**
     * The update interval in frames. If set to 0, the LODs will be updated every frame. If set to 2, the LODs will be updated every second frame, etc.
     * @default "auto"
     */
    d(this, "updateInterval", "auto");
    K(this, C, 1);
    /**
     * If set to true, the LODsManager will not update the LODs.
     * @default false
     */
    d(this, "pause", !1);
    /**
     * When set to true the LODsManager will not update the LODs. This can be used to manually update the LODs using the `update` method.  
     * Otherwise the LODs will be updated automatically when the renderer renders the scene.
     * @default false
     */
    d(this, "manual", !1);
    d(this, "_lodchangedlisteners", []);
    K(this, N, void 0);
    K(this, pe, new Xe());
    K(this, ee, 0);
    K(this, te, 0);
    K(this, ye, 0);
    K(this, W, 0);
    d(this, "_fpsBuffer", [60, 60, 60, 60, 60]);
    // private testIfLODLevelsAreAvailable() {
    d(this, "_sphere", new Ye());
    d(this, "_tempBox", new Ee());
    d(this, "_tempBox2", new Ee());
    d(this, "tempMatrix", new Ae());
    d(this, "_tempWorldPosition", new z());
    d(this, "_tempBoxSize", new z());
    d(this, "_tempBox2Size", new z());
    this.renderer = t, this.context = { ...e };
  }
  /** @internal */
  static getObjectLODState(t) {
    return t[ve];
  }
  static addPlugin(t) {
    Y.push(t);
  }
  static removePlugin(t) {
    const e = Y.indexOf(t);
    e >= 0 && Y.splice(e, 1);
  }
  /**
   * Gets the LODsManager for the given renderer. If the LODsManager does not exist yet, it will be created.  
   * @param renderer The renderer to get the LODsManager for.
   * @returns The LODsManager instance.
   */
  static get(t, e) {
    if (t[we])
      return console.debug("[gltf-progressive] LODsManager already exists for this renderer"), t[we];
    const s = new P(t, {
      engine: "unknown",
      ...e
    });
    return t[we] = s, s;
  }
  /** @deprecated use static `LODsManager.addPlugin()` method. This getter will be removed in later versions */
  get plugins() {
    return Y;
  }
  addEventListener(t, e) {
    t === "changed" && this._lodchangedlisteners.push(e);
  }
  removeEventListener(t, e) {
    if (t === "changed") {
      const s = this._lodchangedlisteners.indexOf(e);
      s >= 0 && this._lodchangedlisteners.splice(s, 1);
    }
  }
  /**
   * Enable the LODsManager. This will replace the render method of the renderer with a method that updates the LODs.
   */
  enable() {
    if (m(this, N))
      return;
    console.debug("[gltf-progressive] Enabling LODsManager for renderer");
    let t = 0;
    U(this, N, this.renderer.render);
    const e = this;
    Re(this.renderer), this.renderer.render = function(s, n) {
      const r = e.renderer.getRenderTarget();
      (r == null || "isXRRenderTarget" in r && r.isXRRenderTarget) && (t = 0, U(e, ee, m(e, ee) + 1), U(e, te, m(e, pe).getDelta()), U(e, ye, m(e, ye) + m(e, te)), e._fpsBuffer.shift(), e._fpsBuffer.push(1 / m(e, te)), U(e, W, e._fpsBuffer.reduce((a, l) => a + l) / e._fpsBuffer.length), I && m(e, ee) % 200 === 0 && console.log("FPS", Math.round(m(e, W)), "Interval:", m(e, C)));
      const i = t++;
      m(e, N).call(this, s, n), e.onAfterRender(s, n, i);
    };
  }
  disable() {
    m(this, N) && (console.debug("[gltf-progressive] Disabling LODsManager for renderer"), this.renderer.render = m(this, N), U(this, N, void 0));
  }
  update(t, e) {
    this.internalUpdate(t, e);
  }
  onAfterRender(t, e, s) {
    if (this.pause)
      return;
    const r = this.renderer.renderLists.get(t, 0).opaque;
    let i = !0;
    if (r.length === 1) {
      const a = r[0].material;
      (a.name === "EffectMaterial" || a.name === "CopyShader") && (i = !1);
    }
    if ((e.parent && e.parent.type === "CubeCamera" || s >= 1 && e.type === "OrthographicCamera") && (i = !1), i) {
      if (at || (this.updateInterval === "auto" ? m(this, W) < 40 && m(this, C) < 10 ? (U(this, C, m(this, C) + 1), I && console.warn("↓ Reducing LOD updates", m(this, C), m(this, W).toFixed(0))) : m(this, W) >= 60 && m(this, C) > 1 && (U(this, C, m(this, C) - 1), I && console.warn("↑ Increasing LOD updates", m(this, C), m(this, W).toFixed(0))) : U(this, C, this.updateInterval), m(this, C) > 0 && m(this, ee) % m(this, C) != 0))
        return;
      this.internalUpdate(t, e);
    }
  }
  /**
   * Update LODs in a scene
   */
  internalUpdate(t, e) {
    var l, u;
    const s = this.renderer.renderLists.get(t, 0), n = s.opaque;
    this.projectionScreenMatrix.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse);
    const r = this.targetTriangleDensity;
    for (const c of n) {
      if (c.material && (((l = c.geometry) == null ? void 0 : l.type) === "BoxGeometry" || ((u = c.geometry) == null ? void 0 : u.type) === "BufferGeometry") && (c.material.name === "SphericalGaussianBlur" || c.material.name == "BackgroundCubeMaterial" || c.material.name === "CubemapFromEquirect" || c.material.name === "EquirectangularToCubeUV")) {
        I && (c.material["NEEDLE_PROGRESSIVE:IGNORE-WARNING"] || (c.material["NEEDLE_PROGRESSIVE:IGNORE-WARNING"] = !0, console.warn("Ignoring skybox or BLIT object", c, c.material.name, c.material.type)));
        continue;
      }
      switch (c.material.type) {
        case "LineBasicMaterial":
        case "LineDashedMaterial":
        case "PointsMaterial":
        case "ShadowMaterial":
        case "MeshDistanceMaterial":
        case "MeshDepthMaterial":
          continue;
      }
      if (I === "color" && c.material && !c.object.progressive_debug_color) {
        c.object.progressive_debug_color = !0;
        const p = Math.random() * 16777215, M = new Ke({ color: p });
        c.object.material = M;
      }
      const g = c.object;
      (g instanceof H || g.isMesh) && this.updateLODs(t, e, g, r);
    }
    const i = s.transparent;
    for (const c of i) {
      const g = c.object;
      (g instanceof H || g.isMesh) && this.updateLODs(t, e, g, r);
    }
    const a = s.transmissive;
    for (const c of a) {
      const g = c.object;
      (g instanceof H || g.isMesh) && this.updateLODs(t, e, g, r);
    }
  }
  /** Update the LOD levels for the renderer. */
  updateLODs(t, e, s, n) {
    var a, l;
    s.userData || (s.userData = {});
    let r = s[ve];
    if (r || (r = new lt(), s[ve] = r), r.frames++ < 2)
      return;
    for (const u of Y)
      (a = u.onBeforeUpdateLOD) == null || a.call(u, this.renderer, t, e, s);
    this.calculateLodLevel(e, s, r, n, R), R.mesh_lod = Math.round(R.mesh_lod), R.texture_lod = Math.round(R.texture_lod), R.mesh_lod >= 0 && this.loadProgressiveMeshes(s, R.mesh_lod);
    let i = R.texture_lod;
    if (s.material && i >= 0) {
      const u = s["DEBUG:LOD"];
      u != null && (i = u), this.loadProgressiveTextures(s.material, i);
    }
    for (const u of Y)
      (l = u.onAfterUpdatedLOD) == null || l.call(u, this.renderer, t, e, s, R);
    r.lastLodLevel_Mesh = R.mesh_lod, r.lastLodLevel_Texture = R.texture_lod;
  }
  /** Load progressive textures for the given material
   * @param material the material to load the textures for
   * @param level the LOD level to load. Level 0 is the best quality, higher levels are lower quality
   * @returns Promise with true if the LOD was loaded, false if not
   */
  loadProgressiveTextures(t, e) {
    if (!t)
      return;
    if (Array.isArray(t)) {
      for (const n of t)
        this.loadProgressiveTextures(n, e);
      return;
    }
    let s = !1;
    (t[J] === void 0 || e < t[J]) && (s = !0), s && (t[J] = e, _.assignTextureLOD(t, e).then((n) => {
      this._lodchangedlisteners.forEach((r) => r({ type: "texture", level: e, object: t }));
    }));
  }
  /** Load progressive meshes for the given mesh
   * @param mesh the mesh to load the LOD for
   * @param index the index of the mesh if it's part of a group
   * @param level the LOD level to load. Level 0 is the best quality, higher levels are lower quality
   * @returns Promise with true if the LOD was loaded, false if not
   */
  loadProgressiveMeshes(t, e) {
    if (!t)
      return Promise.resolve(null);
    if (t[J] !== e) {
      t[J] = e;
      const s = t.geometry;
      return _.assignMeshLOD(t, e).then((n) => (n && t[J] == e && s != t.geometry && this._lodchangedlisteners.forEach((r) => r({ type: "mesh", level: e, object: t })), n));
    }
    return Promise.resolve(null);
  }
  static isInside(t, e) {
    const s = t.min, n = t.max, r = (s.x + n.x) * 0.5, i = (s.y + n.y) * 0.5;
    return this._tempPtInside.set(r, i, s.z).applyMatrix4(e).z < 0;
  }
  calculateLodLevel(t, e, s, n, r) {
    var $;
    if (!e) {
      r.mesh_lod = -1, r.texture_lod = -1;
      return;
    }
    if (!t) {
      r.mesh_lod = -1, r.texture_lod = -1;
      return;
    }
    let a = 10 + 1, l = !1;
    if (I && e["DEBUG:LOD"] != null)
      return e["DEBUG:LOD"];
    const u = _.getMeshLODInformation(e.geometry), c = u == null ? void 0 : u.lods, g = c && c.length > 0, p = _.getMaterialMinMaxLODsCount(e.material), M = (p == null ? void 0 : p.min_count) != 1 / 0 && p.min_count > 0 && p.max_count > 0;
    if (!g && !M) {
      r.mesh_lod = 0, r.texture_lod = 0;
      return;
    }
    g || (l = !0, a = 0);
    const w = this.renderer.domElement.clientHeight || this.renderer.domElement.height;
    let x = e.geometry.boundingBox;
    if (e.type === "SkinnedMesh") {
      const D = e;
      if (!D.boundingBox)
        D.computeBoundingBox();
      else if (s.frames % 30 === 0) {
        const h = me(D), B = D.geometry;
        h && (D.geometry = h), D.computeBoundingBox(), D.geometry = B;
      }
      x = D.boundingBox;
    }
    if (x && t.isPerspectiveCamera) {
      const D = t;
      if (e.geometry.attributes.color && e.geometry.attributes.color.count < 100 && e.geometry.boundingSphere) {
        this._sphere.copy(e.geometry.boundingSphere), this._sphere.applyMatrix4(e.matrixWorld);
        const f = t.getWorldPosition(this._tempWorldPosition);
        if (this._sphere.containsPoint(f)) {
          r.mesh_lod = 0, r.texture_lod = 0;
          return;
        }
      }
      if (this._tempBox.copy(x), this._tempBox.applyMatrix4(e.matrixWorld), P.isInside(this._tempBox, this.projectionScreenMatrix)) {
        r.mesh_lod = 0, r.texture_lod = 0;
        return;
      }
      if (this._tempBox.applyMatrix4(this.projectionScreenMatrix), this.renderer.xr.enabled && D.fov > 70) {
        const f = this._tempBox.min, y = this._tempBox.max;
        let O = f.x, b = f.y, E = y.x, X = y.y;
        const ce = 2, Le = 1.5, ue = (f.x + y.x) * 0.5, fe = (f.y + y.y) * 0.5;
        O = (O - ue) * ce + ue, b = (b - fe) * ce + fe, E = (E - ue) * ce + ue, X = (X - fe) * ce + fe;
        const Ue = O < 0 && E > 0 ? 0 : Math.min(Math.abs(f.x), Math.abs(y.x)), ze = b < 0 && X > 0 ? 0 : Math.min(Math.abs(f.y), Math.abs(y.y)), xe = Math.max(Ue, ze);
        s.lastCentrality = (Le - xe) * (Le - xe) * (Le - xe);
      } else
        s.lastCentrality = 1;
      const h = this._tempBox.getSize(this._tempBoxSize);
      h.multiplyScalar(0.5), screen.availHeight > 0 && w > 0 && h.multiplyScalar(w / screen.availHeight), h.x *= D.aspect;
      const B = t.matrixWorldInverse, F = this._tempBox2;
      F.copy(x), F.applyMatrix4(e.matrixWorld), F.applyMatrix4(B);
      const k = F.getSize(this._tempBox2Size), S = Math.max(k.x, k.y);
      if (Math.max(h.x, h.y) != 0 && S != 0 && (h.z = k.z / Math.max(k.x, k.y) * Math.max(h.x, h.y)), s.lastScreenCoverage = Math.max(h.x, h.y, h.z), s.lastScreenspaceVolume.copy(h), s.lastScreenCoverage *= s.lastCentrality, I && P.debugDrawLine) {
        const f = this.tempMatrix.copy(this.projectionScreenMatrix);
        f.invert();
        const y = P.corner0, O = P.corner1, b = P.corner2, E = P.corner3;
        y.copy(this._tempBox.min), O.copy(this._tempBox.max), O.x = y.x, b.copy(this._tempBox.max), b.y = y.y, E.copy(this._tempBox.max);
        const X = (y.z + E.z) * 0.5;
        y.z = O.z = b.z = E.z = X, y.applyMatrix4(f), O.applyMatrix4(f), b.applyMatrix4(f), E.applyMatrix4(f), P.debugDrawLine(y, O, 255), P.debugDrawLine(y, b, 255), P.debugDrawLine(O, E, 255), P.debugDrawLine(b, E, 255);
      }
      let T = 999;
      if (c && s.lastScreenCoverage > 0) {
        for (let f = 0; f < c.length; f++)
          if (c[f].density / s.lastScreenCoverage < n) {
            T = f;
            break;
          }
      }
      T < a && (a = T, l = !0);
    }
    if (l ? r.mesh_lod = a : r.mesh_lod = s.lastLodLevel_Mesh, I && r.mesh_lod != s.lastLodLevel_Mesh) {
      const h = c == null ? void 0 : c[r.mesh_lod];
      h && console.log(`Mesh LOD changed: ${s.lastLodLevel_Mesh} → ${r.mesh_lod} (${h.density.toFixed(0)}) - ${e.name}`);
    }
    if (M) {
      const D = "saveData" in globalThis.navigator && globalThis.navigator.saveData === !0;
      if (s.lastLodLevel_Texture < 0) {
        if (r.texture_lod = p.max_count - 1, I) {
          const h = p.lods[p.max_count - 1];
          I && console.log(`First Texture LOD ${r.texture_lod} (${h.max_height}px) - ${e.name}`);
        }
      } else {
        const h = s.lastScreenspaceVolume.x + s.lastScreenspaceVolume.y + s.lastScreenspaceVolume.z;
        let B = s.lastScreenCoverage * 4;
        (($ = this.context) == null ? void 0 : $.engine) === "model-viewer" && (B *= 1.5);
        const k = w / window.devicePixelRatio * B;
        for (let S = p.lods.length - 1; S >= 0; S--) {
          let q = p.lods[S];
          if (!(D && q.max_height >= 2048) && !(rt() && q.max_height > 4096) && q.max_height > k) {
            if (r.texture_lod = S, r.texture_lod < s.lastLodLevel_Texture) {
              const T = q.max_height;
              I && console.log(`Texture LOD changed: ${s.lastLodLevel_Texture} → ${r.texture_lod} = ${T}px 
Screensize: ${k.toFixed(0)}px, Coverage: ${(100 * s.lastScreenCoverage).toFixed(2)}%, Volume ${h.toFixed(1)} 
${e.name}`);
            }
            break;
          }
        }
      }
    } else
      r.texture_lod = 0;
  }
};
let G = P;
C = new WeakMap(), N = new WeakMap(), pe = new WeakMap(), ee = new WeakMap(), te = new WeakMap(), ye = new WeakMap(), W = new WeakMap(), /** Assign a function to draw debug lines for the LODs. This function will be called with the start and end position of the line and the color of the line when the `debugprogressive` query parameter is set.
 */
d(G, "debugDrawLine"), d(G, "corner0", new z()), d(G, "corner1", new z()), d(G, "corner2", new z()), d(G, "corner3", new z()), d(G, "_tempPtInside", new z());
class lt {
  constructor() {
    d(this, "frames", 0);
    d(this, "lastLodLevel_Mesh", -1);
    d(this, "lastLodLevel_Texture", -1);
    d(this, "lastScreenCoverage", 0);
    d(this, "lastScreenspaceVolume", new z());
    d(this, "lastCentrality", 0);
  }
}
const Ce = Symbol("NEEDLE_mesh_lod"), de = Symbol("NEEDLE_texture_lod");
let ne = null;
function $e() {
  const o = ct();
  o && (o.mapURLs(function(t) {
    return Be(), t;
  }), Be(), ne == null || ne.disconnect(), ne = new MutationObserver((t) => {
    t.forEach((e) => {
      e.addedNodes.forEach((s) => {
        s instanceof HTMLElement && s.tagName.toLowerCase() === "model-viewer" && Fe(s);
      });
    });
  }), ne.observe(document, { childList: !0, subtree: !0 }));
}
function ct() {
  if (typeof customElements > "u")
    return null;
  const o = customElements.get("model-viewer");
  return o || (customElements.whenDefined("model-viewer").then(() => {
    console.debug("[gltf-progressive] model-viewer defined"), $e();
  }), null);
}
function Be() {
  if (typeof document > "u")
    return;
  document.querySelectorAll("model-viewer").forEach((t) => {
    Fe(t);
  });
}
const ke = /* @__PURE__ */ new WeakSet();
let ut = 0;
function Fe(o) {
  if (!o || ke.has(o))
    return null;
  ke.add(o), console.debug("[gltf-progressive] found new model-viewer..." + ++ut + `
`, o.getAttribute("src"));
  let t = null, e = null, s = null;
  for (let n = o; n != null; n = Object.getPrototypeOf(n)) {
    const r = Object.getOwnPropertySymbols(n), i = r.find((u) => u.toString() == "Symbol(renderer)"), a = r.find((u) => u.toString() == "Symbol(scene)"), l = r.find((u) => u.toString() == "Symbol(needsRender)");
    !t && i != null && (t = o[i].threeRenderer), !e && a != null && (e = o[a]), !s && l != null && (s = o[l]);
  }
  if (t && e) {
    let n = function() {
      if (s) {
        let i = 0, a = setInterval(() => {
          if (i++ > 5) {
            clearInterval(a);
            return;
          }
          s == null || s.call(o);
        }, 300);
      }
    };
    console.debug("[gltf-progressive] setup model-viewer");
    const r = G.get(t, { engine: "model-viewer" });
    return G.addPlugin(new ft()), r.enable(), r.addEventListener("changed", () => {
      s == null || s.call(o);
    }), o.addEventListener("model-visibility", (i) => {
      i.detail.visible && (s == null || s.call(o));
    }), o.addEventListener("load", () => {
      n();
    }), () => {
      r.disable();
    };
  }
  return null;
}
class ft {
  constructor() {
    d(this, "_didWarnAboutMissingUrl", !1);
  }
  onBeforeUpdateLOD(t, e, s, n) {
    this.tryParseMeshLOD(e, n), this.tryParseTextureLOD(e, n);
  }
  getUrl(t) {
    if (!t)
      return null;
    let e = t.getAttribute("src");
    return e || (e = t.src), e || (this._didWarnAboutMissingUrl || console.warn("No url found in modelviewer", t), this._didWarnAboutMissingUrl = !0), e;
  }
  tryGetCurrentGLTF(t) {
    return t._currentGLTF;
  }
  tryGetCurrentModelViewer(t) {
    return t.element;
  }
  tryParseTextureLOD(t, e) {
    if (e[de] == !0)
      return;
    e[de] = !0;
    const s = this.tryGetCurrentGLTF(t), n = this.tryGetCurrentModelViewer(t), r = this.getUrl(n);
    if (r && s && e.material) {
      let i = function(l) {
        var c, g, p;
        if (l[de] == !0)
          return;
        l[de] = !0, l.userData && (l.userData.LOD = -1);
        const u = Object.keys(l);
        for (let M = 0; M < u.length; M++) {
          const w = u[M], x = l[w];
          if ((x == null ? void 0 : x.isTexture) === !0) {
            const $ = (g = (c = x.userData) == null ? void 0 : c.associations) == null ? void 0 : g.textures;
            if ($ == null)
              continue;
            const D = s.parser.json.textures[$];
            if (!D) {
              console.warn("Texture data not found for texture index " + $);
              continue;
            }
            if ((p = D == null ? void 0 : D.extensions) != null && p[V]) {
              const h = D.extensions[V];
              h && r && _.registerTexture(r, x, h.lods.length, $, h);
            }
          }
        }
      };
      const a = e.material;
      if (Array.isArray(a))
        for (const l of a)
          i(l);
      else
        i(a);
    }
  }
  tryParseMeshLOD(t, e) {
    var i, a;
    if (e[Ce] == !0)
      return;
    e[Ce] = !0;
    const s = this.tryGetCurrentModelViewer(t), n = this.getUrl(s);
    if (!n)
      return;
    const r = (a = (i = e.userData) == null ? void 0 : i.gltfExtensions) == null ? void 0 : a[V];
    if (r && n) {
      const l = e.uuid;
      _.registerMesh(n, l, e, 0, r.lods.length, r);
    }
  }
}
function Dt(o, t, e, s) {
  Re(t), Ge(e), et(e, {
    progressive: !0,
    ...s == null ? void 0 : s.hints
  }), e.register((r) => new _(r, o));
  const n = G.get(t);
  return (s == null ? void 0 : s.enableLODsManager) !== !1 && n.enable(), n;
}
$e();
export {
  V as EXTENSION_NAME,
  G as LODsManager,
  _ as NEEDLE_progressive,
  Ie as VERSION,
  Ge as addDracoAndKTX2Loaders,
  et as configureLoader,
  Re as createLoaders,
  me as getRaycastMesh,
  $e as patchModelViewer,
  it as registerRaycastMesh,
  Lt as setDracoDecoderLocation,
  xt as setKTX2TranscoderLocation,
  Dt as useNeedleProgressive,
  Mt as useRaycastMeshes
};
