import { BufferGeometry, Material, Mesh, Texture } from "three";
import { type GLTF, type GLTFLoaderPlugin, GLTFParser } from "three/examples/jsm/loaders/GLTFLoader.js";
export declare const EXTENSION_NAME = "NEEDLE_progressive";
declare type NEEDLE_progressive_model_LOD = {
    path: string;
    hash?: string;
};
/** This is the data structure we have in the NEEDLE_progressive extension */
declare type NEEDLE_progressive_model = {
    guid: string;
    lods: Array<NEEDLE_progressive_model_LOD>;
};
export declare type NEEDLE_progressive_texture_model = NEEDLE_progressive_model & {
    lods: Array<NEEDLE_progressive_model_LOD & {
        width: number;
        height: number;
    }>;
};
export declare type NEEDLE_progressive_mesh_model = NEEDLE_progressive_model & {
    density: number;
    lods: Array<NEEDLE_progressive_model_LOD & {
        density: number;
        indexCount: number;
        vertexCount: number;
    }>;
};
/**
 * This is the result of a progressive texture loading event for a material's texture slot in {@link NEEDLE_progressive.assignTextureLOD}
 * @internal
 */
export declare type ProgressiveMaterialTextureLoadingResult = {
    /** the material the progressive texture was loaded for */
    material: Material;
    /** the slot in the material where the texture was loaded */
    slot: string;
    /** the texture that was loaded (if any) */
    texture: Texture | null;
    /** the level of detail that was loaded */
    level: number;
};
declare type TextureLODsMinMaxInfo = {
    min_count: number;
    max_count: number;
    lods: Array<{
        min_height: number;
        max_height: number;
    }>;
};
/**
 * The NEEDLE_progressive extension for the GLTFLoader is responsible for loading progressive LODs for meshes and textures.
 * This extension can be used to load different resolutions of a mesh or texture at runtime (e.g. for LODs or progressive textures).
 * @example
 * ```javascript
 * const loader = new GLTFLoader();
 * loader.register(new NEEDLE_progressive());
 * loader.load("model.glb", (gltf) => {
 *    const mesh = gltf.scene.children[0] as Mesh;
 *   NEEDLE_progressive.assignMeshLOD(context, sourceId, mesh, 1).then(mesh => {
 *     console.log("Mesh with LOD level 1 loaded", mesh);
 *  });
 * });
 * ```
 */
export declare class NEEDLE_progressive implements GLTFLoaderPlugin {
    /** The name of the extension */
    get name(): string;
    static getMeshLODInformation(geo: BufferGeometry): NEEDLE_progressive_mesh_model | null;
    static getMaterialMinMaxLODsCount(material: Material | Material[], minmax?: TextureLODsMinMaxInfo): TextureLODsMinMaxInfo;
    /** Check if a LOD level is available for a mesh or a texture
     * @param obj the mesh or texture to check
     * @param level the level of detail to check for (0 is the highest resolution). If undefined, the function checks if any LOD level is available
     * @returns true if the LOD level is available (or if any LOD level is available if level is undefined)
     */
    static hasLODLevelAvailable(obj: Mesh | BufferGeometry | Texture | Material | Material[], level?: number): boolean;
    /** Load a different resolution of a mesh (if available)
     * @param context the context
     * @param source the sourceid of the file from which the mesh is loaded (this is usually the component's sourceId)
     * @param mesh the mesh to load the LOD for
     * @param level the level of detail to load (0 is the highest resolution)
     * @returns a promise that resolves to the mesh with the requested LOD level
     * @example
     * ```javascript
     * const mesh = this.gameObject as Mesh;
     * NEEDLE_progressive.assignMeshLOD(context, sourceId, mesh, 1).then(mesh => {
     *    console.log("Mesh with LOD level 1 loaded", mesh);
     * });
     * ```
     */
    static assignMeshLOD(mesh: Mesh, level: number): Promise<BufferGeometry | null>;
    /** Load a different resolution of a texture (if available)
     * @param context the context
     * @param source the sourceid of the file from which the texture is loaded (this is usually the component's sourceId)
     * @param materialOrTexture the material or texture to load the LOD for (if passing in a material all textures in the material will be loaded)
     * @param level the level of detail to load (0 is the highest resolution) - currently only 0 is supported
     * @returns a promise that resolves to the material or texture with the requested LOD level
     */
    static assignTextureLOD(materialOrTexture: Material, level: number): Promise<Array<ProgressiveMaterialTextureLoadingResult> | null>;
    static assignTextureLOD(materialOrTexture: Mesh, level: number): Promise<Array<ProgressiveMaterialTextureLoadingResult> | null>;
    static assignTextureLOD(materialOrTexture: Texture, level: number): Promise<Texture | null>;
    private static assignTextureLODForSlot;
    private readonly parser;
    private readonly url;
    constructor(parser: GLTFParser, url: string);
    private _isLoadingMesh;
    loadMesh: (meshIndex: number) => Promise<any> | null;
    afterRoot(gltf: GLTF): null;
    /**
     * Register a texture with LOD information
     */
    static registerTexture: (url: string, tex: Texture, level: number, index: number, ext: NEEDLE_progressive_texture_model) => void;
    /**
     * Register a mesh with LOD information
     */
    static registerMesh: (url: string, key: string, mesh: Mesh, level: number, index: number | undefined, ext: NEEDLE_progressive_mesh_model) => void;
    /** A map of key = asset uuid and value = LOD information */
    private static readonly lodInfos;
    /** cache of already loaded mesh lods */
    private static readonly previouslyLoaded;
    /** this contains the geometry/textures that were originally loaded */
    private static readonly lowresCache;
    private static getOrLoadLOD;
    private static assignLODInformation;
    private static getAssignedLODInformation;
    private static copySettings;
}
export {};
