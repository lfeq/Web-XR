import { Camera, Material, Matrix4, Object3D, Scene, Texture, Vector3, WebGLRenderer } from "three";
import { NEEDLE_progressive_plugin } from "./plugins/plugin.js";
export type LODManagerContext = {
    engine: "three" | "needle-engine" | "model-viewer" | "react-three-fiber" | "unknown";
};
export declare type LOD_Results = {
    mesh_lod: number;
    texture_lod: number;
};
declare type LODChangedEventListener = (args: {
    type: "mesh" | "texture";
    level: number;
    object: Object3D | Material | Texture;
}) => void;
/**
 * The LODsManager class is responsible for managing the LODs and progressive assets in the scene. It will automatically update the LODs based on the camera position, screen coverage and mesh density of the objects.
 * It must be enabled by calling the `enable` method.
 *
 * Instead of using the LODs manager directly you can also call `useNeedleProgressive` to enable progressive loading for a GLTFLoader
 *
 * ### Plugins
 * Use {@link LODsManager.addPlugin} to add a plugin to the LODsManager. A plugin can be used to hook into the LOD update process and modify the LOD levels or perform other actions.
 *
 * @example Adding a LODsManager to a Three.js scene:
 * ```ts
 * import { LODsManager } from "@needle-tools/gltf-progressive";
 * import { WebGLRenderer, Scene, Camera, Mesh } from "three";
 *
 * const renderer = new WebGLRenderer();
 * const lodsManager = LODsManager.get(renderer);
 * lodsManager.enable();
 * ```
 *
 * @example Using the LODsManager with a GLTFLoader:
 * ```ts
 * import { useNeedleProgressive } from "@needle-tools/gltf-progressive";
 * import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";
 *
 * const url = 'https://yourdomain.com/yourmodel.glb';
 * const loader = new GLTFLoader();
 * const lodsManager = useNeedleProgressive(url, renderer, loader);
 * ```
 */
export declare class LODsManager {
    #private;
    /** Assign a function to draw debug lines for the LODs. This function will be called with the start and end position of the line and the color of the line when the `debugprogressive` query parameter is set.
     */
    static debugDrawLine?: (a: Vector3, b: Vector3, color: number) => void;
    /** @internal */
    static getObjectLODState(object: Object3D): LOD_state | undefined;
    static addPlugin(plugin: NEEDLE_progressive_plugin): void;
    static removePlugin(plugin: NEEDLE_progressive_plugin): void;
    /**
     * Gets the LODsManager for the given renderer. If the LODsManager does not exist yet, it will be created.
     * @param renderer The renderer to get the LODsManager for.
     * @returns The LODsManager instance.
     */
    static get(renderer: WebGLRenderer, context?: LODManagerContext): LODsManager;
    private readonly context;
    readonly renderer: WebGLRenderer;
    readonly projectionScreenMatrix: Matrix4;
    /** @deprecated use static `LODsManager.addPlugin()` method. This getter will be removed in later versions */
    get plugins(): NEEDLE_progressive_plugin[];
    /**
     * The target triangle density is the desired max amount of triangles on screen when the mesh is filling the screen.
     * @default 200_000
     */
    targetTriangleDensity: number;
    /**
     * The update interval in frames. If set to 0, the LODs will be updated every frame. If set to 2, the LODs will be updated every second frame, etc.
     * @default "auto"
     */
    updateInterval: "auto" | number;
    /**
     * If set to true, the LODsManager will not update the LODs.
     * @default false
     */
    pause: boolean;
    /**
     * When set to true the LODsManager will not update the LODs. This can be used to manually update the LODs using the `update` method.
     * Otherwise the LODs will be updated automatically when the renderer renders the scene.
     * @default false
     */
    manual: boolean;
    private readonly _lodchangedlisteners;
    addEventListener(evt: "changed", listener: LODChangedEventListener): void;
    removeEventListener(evt: "changed", listener: LODChangedEventListener): void;
    private constructor();
    private _fpsBuffer;
    /**
     * Enable the LODsManager. This will replace the render method of the renderer with a method that updates the LODs.
     */
    enable(): void;
    disable(): void;
    update(scene: Scene, camera: Camera): void;
    private onAfterRender;
    /**
     * Update LODs in a scene
     */
    private internalUpdate;
    /** Update the LOD levels for the renderer. */
    private updateLODs;
    /** Load progressive textures for the given material
     * @param material the material to load the textures for
     * @param level the LOD level to load. Level 0 is the best quality, higher levels are lower quality
     * @returns Promise with true if the LOD was loaded, false if not
     */
    private loadProgressiveTextures;
    /** Load progressive meshes for the given mesh
     * @param mesh the mesh to load the LOD for
     * @param index the index of the mesh if it's part of a group
     * @param level the LOD level to load. Level 0 is the best quality, higher levels are lower quality
     * @returns Promise with true if the LOD was loaded, false if not
     */
    private loadProgressiveMeshes;
    private readonly _sphere;
    private readonly _tempBox;
    private readonly _tempBox2;
    private readonly tempMatrix;
    private readonly _tempWorldPosition;
    private readonly _tempBoxSize;
    private readonly _tempBox2Size;
    private static corner0;
    private static corner1;
    private static corner2;
    private static corner3;
    private static readonly _tempPtInside;
    private static isInside;
    private calculateLodLevel;
}
declare class LOD_state {
    frames: number;
    lastLodLevel_Mesh: number;
    lastLodLevel_Texture: number;
    lastScreenCoverage: number;
    readonly lastScreenspaceVolume: Vector3;
    lastCentrality: number;
}
export {};
