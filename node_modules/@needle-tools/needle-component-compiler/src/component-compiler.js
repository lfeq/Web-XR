"use strict";
exports.__esModule = true;
exports.run = exports.compile = void 0;
var fs_1 = require("fs");
var ts = require("typescript");
var fs = require("fs");
var path = require("path");
var types = require("./types");
var dict = types.dict;
// add either of these two comments above a class to enforce code gen or disable it for the next class
var exportNextClassCommand = "@generate-component";
var dontExportNextClassCommand = "@dont-generate-component";
// add above field to add [SerializeField] attribute
var serializeCommand = "@serializeField";
var dontSerializeCommand = "@nonSerialized";
// https://regex101.com/r/ltpcKT/2
var typePattern = new RegExp("@type ?(?<type>.+)");
var ifdefPattern = new RegExp("@ifdef ?(?<ifdef>.+)");
var CODEGEN_MARKER_START = "// NEEDLE_CODEGEN_START";
var CODEGEN_MARKER_END = "// NEEDLE_CODEGEN_END";
var allowDebugLogs = true;
// will be set to true when e.g. a comment for export is found
var exportNextClass = false;
var dontExportNextClass = false;
var serializeField = false;
var dontSerialize = false;
var typesFileContent = undefined;
// const exportDir = "../dist";
var commentStarts = [];
var contexts = [];
var lastTypeFound = null;
var ifdefSections = [];
function resetAllState() {
    exportNextClass = false;
    dontExportNextClass = false;
    serializeField = false;
    dontSerialize = false;
    typesFileContent = undefined;
    commentStarts.length = 0;
    contexts.length = 0;
    lastTypeFound = null;
    ifdefSections.length = 0;
}
function resetExportNextClass() {
    dontExportNextClass = false;
    exportNextClass = false;
}
function tryGetKnownType(str) {
    if (typesFileContent === undefined) {
        typesFileContent = null;
        var filePath = path.dirname(__dirname) + "/src/types.json";
        if (fs.existsSync(filePath)) {
            if (allowDebugLogs)
                console.log("Reading types file");
            var content = fs.readFileSync(filePath, "utf8");
            typesFileContent = JSON.parse(content);
        }
    }
    if (typesFileContent) {
        var fullType = typesFileContent[str];
        if (fullType && allowDebugLogs)
            console.log(fullType);
        return fullType;
    }
    return null;
}
// https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API
var ExportContext = /** @class */ (function () {
    function ExportContext(outputDir, fileName) {
        this.classEnd = -1;
        this.indentLevel = 0;
        this.emitMethodContextMenu = null;
        this.emitTooltip = null;
        this.outputDir = outputDir;
        this.fileName = fileName;
        this.reset();
    }
    ExportContext.prototype.onBeforeField = function (name) {
        if (this.emitTooltip) {
            this.appendLine("[UnityEngine.Tooltip(\"" + this.emitTooltip.trim().replace("\"", "'") + "\")]");
            this.emitTooltip = undefined;
        }
    };
    ExportContext.prototype.onBeforeMethod = function (name) {
        if (this.emitMethodContextMenu !== undefined) {
            var contextMenuText = this.emitMethodContextMenu === null ? name : this.emitMethodContextMenu;
            this.appendLine("[UnityEngine.ContextMenu(\"" + contextMenuText + "\")]");
            this.emitMethodContextMenu = undefined;
        }
    };
    ExportContext.prototype.append = function (text) {
        for (var i = 0; i < this.indentLevel; i++)
            text = "\t" + text;
        this.textBuffer += text;
        this.emitMethodContextMenu = undefined;
    };
    ExportContext.prototype.appendLine = function (text) {
        this.append(text + "\n");
    };
    ExportContext.prototype.flush = function () {
        if (this.textBuffer.length <= 0) {
            return;
        }
        this.textBuffer = CODEGEN_MARKER_START + "\n" + this.textBuffer + "\n" + CODEGEN_MARKER_END;
        var code = this.textBuffer;
        if (this.outputDir !== null) {
            if (!fs.existsSync(this.outputDir))
                fs.mkdirSync(this.outputDir);
            var dir = this.outputDir + "/";
            var path_1 = dir + this.fileName;
            code = this.replaceGeneratedCodeSection(path_1, code);
            if (allowDebugLogs)
                console.log("Write to " + path_1);
            fs.writeFileSync(path_1, code);
        }
        else {
            console.log("No output dir specified");
        }
        this.reset();
        return code;
    };
    ExportContext.prototype.reset = function () {
        this.textBuffer = "";
        this.classEnd = -1;
    };
    ExportContext.prototype.replaceGeneratedCodeSection = function (path, code) {
        if (fs.existsSync(path)) {
            var existing = fs.readFileSync(path, "utf8");
            var regex = new RegExp("(?<before>.*?)\/\/ ?NEEDLE_CODEGEN_START.+\/\/ ?NEEDLE_CODEGEN_END(?<after>.*)", "s");
            var matches = regex.exec(existing);
            if (matches === null || matches === void 0 ? void 0 : matches.groups) {
                if (allowDebugLogs)
                    console.log("Found codegen sections");
                var before_1 = matches.groups.before;
                var after_1 = matches.groups.after;
                return before_1 + code + after_1;
            }
        }
        return code;
    };
    return ExportContext;
}());
function compile(code, fileName, outputDir, debugLogs) {
    if (debugLogs === void 0) { debugLogs = true; }
    resetAllState();
    allowDebugLogs = debugLogs;
    // Parse a file
    var sourceFile = ts.createSourceFile(fileName, code, ts.ScriptTarget.ES2015, true);
    var prog = ts.createProgram([fileName], {});
    // delint it
    return run(prog, outputDir, sourceFile);
}
exports.compile = compile;
function run(program, outputDir, sourceFile) {
    if (outputDir !== null && !fs.existsSync(outputDir)) {
        console.error("Output directory does not exist: \"" + outputDir + "\"");
        return;
    }
    var results = [];
    traverseFile(sourceFile);
    function traverseFile(node) {
        visit(node);
        ts.forEachChild(node, traverseFile);
    }
    return results;
    function visit(node) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        var context = contexts.length > 0 ? contexts[contexts.length - 1] : null;
        if (context) {
            if ((context === null || context === void 0 ? void 0 : context.classEnd) > 0 && node.pos >= (context === null || context === void 0 ? void 0 : context.classEnd)) {
                while (context.indentLevel > 0) {
                    context.indentLevel -= 1;
                    context.append("}\n");
                }
                var code = context.flush();
                results.push(code);
                context = null;
                contexts.pop();
            }
        }
        if (allowDebugLogs)
            console.log("\t", ts.SyntaxKind[node.kind]);
        var commentRanges = ts.getLeadingCommentRanges(sourceFile.getFullText(), node.getFullStart());
        if (commentRanges === null || commentRanges === void 0 ? void 0 : commentRanges.length) {
            for (var _i = 0, commentRanges_1 = commentRanges; _i < commentRanges_1.length; _i++) {
                var r = commentRanges_1[_i];
                // avoid emitting comments multiple times
                if (commentStarts.includes(r.pos))
                    continue;
                commentStarts.push(r.pos);
                var comment = node.getSourceFile().getFullText().slice(r.pos, r.end);
                console.log(comment);
                if (context) {
                    // https://regex101.com/r/ud4oev/1
                    var emitContextMenu = comment.match("(\/{2,}|\/\*) {0,}@contextmenu {1,}(?<text>[a-zA-Z 0-9]+)?");
                    if (emitContextMenu) {
                        context.emitMethodContextMenu = (_b = (_a = emitContextMenu.groups) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : null;
                    }
                    // https://regex101.com/r/Sa6Q8T/3
                    var emitTooltip = comment.match("\/{2,} {0,}(@tooltip) *?(?<text>.+)");
                    if (emitTooltip) {
                        console.log((_c = emitTooltip.groups) === null || _c === void 0 ? void 0 : _c.text);
                        context.emitTooltip = (_e = (_d = emitTooltip.groups) === null || _d === void 0 ? void 0 : _d.text) !== null && _e !== void 0 ? _e : null;
                    }
                    else if (comment.includes(serializeCommand))
                        serializeField = true;
                    else if (comment.includes(dontSerializeCommand))
                        dontSerialize = true;
                }
                if (comment.includes(exportNextClassCommand))
                    exportNextClass = true;
                if (comment.includes(dontExportNextClassCommand))
                    dontExportNextClass = true;
                var typeMatch = typePattern.exec(comment);
                if (typeMatch && typeMatch.groups) {
                    // for some reason our regex does also match surrounding ( ) even tho: https://regex101.com/r/PoWK6V/1
                    // so we remove them
                    var type = typeMatch.groups["type"];
                    type = type.replace(/\(/, "").replace(/\)/, "");
                    if (allowDebugLogs)
                        console.log("Found type: ", type);
                    lastTypeFound = type;
                }
                var ifdefMatch = ifdefPattern.exec(comment);
                if (ifdefMatch && ifdefMatch.groups) {
                    var ifdef = ifdefMatch.groups["ifdef"];
                    if (ifdef)
                        ifdefSections.push(ifdef);
                }
            }
        }
        var skip = dontSerialize;
        switch (node.kind) {
            // Namespace
            // case ts.SyntaxKind.ModuleDeclaration:
            //     const mod = node as ts.ModuleDeclaration;
            //     console.log(ts.SyntaxKind[mod.getChildAt(1).kind])
            //     const type = mod.getChildAt(1) as ts.Identifier;
            //     console.log("MODULE", type.text)
            //     break;
            // case ts.SyntaxKind.Identifier:
            //     break;
            // case ts.SyntaxKind.ClassDeclaration:
            // case ts.SyntaxKind.SingleLineCommentTrivia:
            //     console.log("comment: " + node.getText())
            //     break;
            case ts.SyntaxKind.Decorator:
                break;
            case ts.SyntaxKind.MethodDeclaration:
                lastTypeFound = null;
                serializeField = false;
                dontSerialize = false;
                resetExportNextClass();
                if (!context)
                    break;
                // TODO: always emit at least OnEnable method per class so generated components have toggle in editor
                var meth = node;
                // const isCoroutine = func.asteriskToken;
                if (!skip && meth.name) {
                    var pub_1 = shouldEmitMethod(meth);
                    if (!pub_1)
                        return;
                    var paramsStr = "";
                    for (var _k = 0, _l = meth.parameters; _k < _l.length; _k++) {
                        var param = _l[_k];
                        if (!param || !param.name)
                            continue;
                        if (paramsStr.length > 0)
                            paramsStr += ", ";
                        var type = tryResolveTypeRecursive(param);
                        if (type === undefined)
                            type = "object";
                        var paramName = "";
                        var paramNameKind = param.name.kind;
                        switch (paramNameKind) {
                            case ts.SyntaxKind.ObjectBindingPattern:
                                paramName = "obj";
                                break;
                            default:
                                paramName = param.name.getText();
                                break;
                        }
                        paramsStr += type + " @" + paramName;
                    }
                    var methodName = meth.name.getText();
                    switch (methodName) {
                        case "onEnable":
                            methodName = "OnEnable";
                            break;
                        case "onDisable":
                            methodName = "OnDisable";
                            break;
                    }
                    context.onBeforeMethod(methodName);
                    // let visibility = pub ? "public" : "private";
                    context.append("public void " + methodName + "(" + paramsStr + "){}\n");
                }
                break;
            case ts.SyntaxKind.SetAccessor:
            case ts.SyntaxKind.PropertyDeclaration:
                resetExportNextClass();
                if (!context)
                    break;
                if (allowDebugLogs)
                    console.log("Found variable", ts.SyntaxKind[node.kind], "\n", node.getText());
                var vardec = node;
                var varName = "@" + vardec.name.getText();
                var pub = shouldEmitMethod(vardec);
                var visibility = pub ? "public" : "private";
                var isAccessible = pub;
                dontSerialize = false;
                if (serializeField) {
                    if (allowDebugLogs)
                        console.log("[SerializeField]");
                    context.appendLine("[UnityEngine.SerializeField]");
                    isAccessible = true;
                }
                else if (skip)
                    isAccessible = false;
                if (!isAccessible) {
                    if (allowDebugLogs)
                        console.log("Skip because not public or serializeable");
                    break;
                }
                var name_1 = vardec.name.getText();
                if (allowDebugLogs)
                    console.log("Variable:", name_1);
                if (name_1.startsWith("\"@") || name_1.startsWith("\"$") || name_1.startsWith("$"))
                    break;
                var typeString = lastTypeFound !== null && lastTypeFound !== void 0 ? lastTypeFound : tryResolveTypeRecursive(node);
                var postFix = "";
                var typeName = (_f = vardec.type) === null || _f === void 0 ? void 0 : _f.getText();
                var shouldCommentTheLine = typeString === undefined;
                if (typeString === undefined) {
                    postFix = " → Could not resolve C# type";
                }
                var assignment = "";
                if (typeString !== undefined) {
                    for (var _m = 0, _o = node.getChildren(); _m < _o.length; _m++) {
                        var ch = _o[_m];
                        switch (ch.kind) {
                            default:
                                // console.log("Unknown assignment:", ts.SyntaxKind[ch.kind]);
                                break;
                            case ts.SyntaxKind.NewExpression:
                                assignment = " = " + getTypeForAssignment(ch, typeString);
                                break;
                            case ts.SyntaxKind.FalseKeyword:
                            case ts.SyntaxKind.TrueKeyword:
                                assignment = " = " + ch.getText();
                                break;
                            case ts.SyntaxKind.StringLiteral:
                                var str = ch;
                                assignment = " = \"" + str.text + "\"";
                                break;
                            case ts.SyntaxKind.FirstLiteralToken:
                                var lit = ch;
                                assignment = " = " + lit.text;
                                if (ts.isNumericLiteral(lit))
                                    assignment += "f";
                                break;
                            case ts.SyntaxKind.ArrayLiteralExpression:
                                var arr = ch;
                                assignment = " = new " + typeString;
                                // if (arr.elements.length > 0) {
                                assignment += "{" + arr.elements.map(function (e) { return " " + getTypeForAssignment(e); }) + " }";
                                // }
                                break;
                        }
                    }
                }
                var requireEndIf = false;
                if (ifdefSections.length > 0) {
                    requireEndIf = true;
                    context.appendLine("#ifdef " + ifdefSections.pop());
                }
                if (typeString === undefined)
                    typeString = typeName;
                if (typeString === "[]") {
                    if (allowDebugLogs)
                        console.log("Unknown array type for \"" + varName + " " + typeName + "\" - your type is probably not known (did you just create it this session?) and you might need to regenerate the Typemap in Unity. Go to \"Needle Engine/Internal/Generate Type Map for component compiler");
                    // typeString = "object[]";
                    // assignment = " = new object[0]";
                    shouldCommentTheLine = true;
                }
                context.onBeforeField(varName);
                if (allowDebugLogs)
                    console.log("EMIT member: \"" + typeString + "\" " + varName, assignment, "Last type found:", lastTypeFound);
                var prefix = shouldCommentTheLine ? "// " : "";
                var isUnityEditorType = typeString === null || typeString === void 0 ? void 0 : typeString.includes("UnityEditor");
                if (isUnityEditorType) {
                    context.appendLine("#if UNITY_EDITOR");
                }
                context.append(prefix + visibility + " " + typeString + " " + varName + assignment + ";" + postFix + "\n");
                if (isUnityEditorType) {
                    context.appendLine("#endif");
                }
                lastTypeFound = null;
                if (requireEndIf) {
                    context.appendLine("#endif");
                }
                break;
            case ts.SyntaxKind.ClassDeclaration:
                serializeField = false;
                var dec = node;
                // a class must inherit a component
                var inheritsComponent = testInheritsComponent(node);
                if (!dontExportNextClass && (lastTypeFound || exportNextClass || inheritsComponent)) {
                    resetExportNextClass();
                    var name_2 = (_g = dec.name) === null || _g === void 0 ? void 0 : _g.escapedText;
                    if (allowDebugLogs)
                        console.log("Found class: ", name_2);
                    var namespace = (_h = tryParseNamespace(node)) !== null && _h !== void 0 ? _h : "Needle.Typescript.GeneratedComponents";
                    if (allowDebugLogs)
                        console.log("NAMESPACE", namespace);
                    var newContext = new ExportContext(outputDir, name_2 + ".cs");
                    newContext.appendLine("// auto generated code - do not edit directly");
                    newContext.appendLine("");
                    newContext.appendLine("#pragma warning disable");
                    newContext.appendLine("");
                    newContext.appendLine("namespace " + namespace);
                    newContext.appendLine("{");
                    newContext.indentLevel += 1;
                    // newContext.appendLine("// source: " + path.resolve(sourceFile.fileName));
                    var typeName_1 = "UnityEngine.MonoBehaviour";
                    if (typeof inheritsComponent === "string")
                        typeName_1 = inheritsComponent;
                    if (lastTypeFound)
                        typeName_1 = lastTypeFound;
                    if (allowDebugLogs)
                        console.log(name_2 + " inherits " + typeName_1);
                    var modifiers = "";
                    if (dec.modifiers) {
                        for (var _p = 0, _q = dec.modifiers; _p < _q.length; _p++) {
                            var mod = _q[_p];
                            switch (mod.getText()) {
                                case "abstract":
                                    modifiers += " abstract";
                                    if (allowDebugLogs)
                                        console.log(name_2 + " is abstract");
                                    break;
                            }
                        }
                    }
                    modifiers += " partial";
                    newContext.appendLine("public " + modifiers.trim() + " class " + name_2 + " : " + typeName_1);
                    newContext.appendLine("{");
                    newContext.indentLevel += 1;
                    newContext.classEnd = dec.end;
                    contexts.push(newContext);
                }
                else {
                    if (allowDebugLogs)
                        console.log("Class type is unknown and will not generate a component: ", (_j = dec.name) === null || _j === void 0 ? void 0 : _j.escapedText);
                }
                lastTypeFound = null;
                break;
        }
        function testInheritsComponent(node) {
            switch (node.kind) {
                case ts.SyntaxKind.ClassDeclaration:
                    var dec = node;
                    if (dec.heritageClauses) {
                        for (var _i = 0, _a = dec.heritageClauses; _i < _a.length; _i++) {
                            var h = _a[_i];
                            if (h.types.length <= 0)
                                continue;
                            for (var _b = 0, _c = h.types; _b < _c.length; _b++) {
                                var type = _c[_b];
                                // const symbol = program.getTypeChecker().getSymbolAtLocation(type.expression);
                                // console.log(symbol);
                                var text = type.expression.getText();
                                if (text === "Component")
                                    return true;
                                if (text === "Behaviour")
                                    return true;
                                var known = tryGetKnownType(text);
                                if (known)
                                    return known;
                            }
                        }
                    }
                    return false;
            }
            return false;
        }
        function getTypeForAssignment(node, typeString) {
            // console.log("-------------------\nAssign", ts.SyntaxKind[node.kind]);
            switch (node.kind) {
                case ts.SyntaxKind.FirstLiteralToken:
                    return node.getText();
                case ts.SyntaxKind.NewExpression:
                    var type = undefined;
                    var args = undefined;
                    for (var _i = 0, _a = node.getChildren(); _i < _a.length; _i++) {
                        var ch = _a[_i];
                        var text = ch.getText();
                        console.log("child", ts.SyntaxKind[ch.kind], text);
                        switch (ch.kind) {
                            case ts.SyntaxKind.Identifier:
                            case ts.SyntaxKind.PropertyAccessExpression:
                                type = tryGetTypeFromText(text);
                                break;
                            case ts.SyntaxKind.SyntaxList:
                                for (var _b = 0, _c = ch.getChildren(); _b < _c.length; _b++) {
                                    var arg = _c[_b];
                                    if (args === undefined)
                                        args = "";
                                    var res = getTypeForAssignment(arg, typeString);
                                    // handle floats being assigned with "f" suffix
                                    if (Number.parseFloat(res) >= 0) {
                                        args += res + "f";
                                    }
                                    else {
                                        args += res;
                                        if (res === ",")
                                            args += " ";
                                    }
                                }
                                break;
                        }
                    }
                    if (!args)
                        args = "";
                    if (type || typeString) {
                        if (typeString) {
                            console.log("Override type", type, typeString);
                            type = typeString;
                        }
                        return "new " + type + "(" + args + ")";
                    }
                    // const expType = node.getChildren().find(c => c.kind === ts.SyntaxKind.Identifier);
                    break;
            }
            var str = node.getText();
            if (allowDebugLogs)
                console.log("Unknown assignment:", str, ts.SyntaxKind[node.kind]);
            return str;
        }
        function shouldEmitMethod(node) {
            if (node.kind === ts.SyntaxKind.PublicKeyword) {
                return true;
            }
            else if (node.kind === ts.SyntaxKind.PrivateKeyword || node.kind === ts.SyntaxKind.ProtectedKeyword) {
                return false;
            }
            // check if its static
            else if (node.kind === ts.SyntaxKind.StaticKeyword) {
                return false;
            }
            // check if its abstract
            else if (node.kind === ts.SyntaxKind.AbstractKeyword) {
                return false;
            }
            for (var _i = 0, _a = node.getChildren(); _i < _a.length; _i++) {
                var ch = _a[_i];
                if (!shouldEmitMethod(ch))
                    return false;
            }
            return true;
        }
        function tryParseNamespace(node, namespace) {
            // console.log("TRAVERSE - " + ts.SyntaxKind[node.kind]);
            switch (node.kind) {
                case ts.SyntaxKind.ModuleDeclaration:
                    for (var _i = 0, _a = node.getChildren(); _i < _a.length; _i++) {
                        var ch = _a[_i];
                        // console.log("-- TRAVERSE - " + ts.SyntaxKind[ch.kind]);
                        switch (ch.kind) {
                            case ts.SyntaxKind.Identifier:
                                var id = ch;
                                if (id.text) {
                                    if (!namespace)
                                        namespace = "";
                                    namespace = id.text + (namespace ? "." : "") + namespace;
                                }
                                break;
                        }
                    }
                    break;
            }
            if (node.parent) {
                return tryParseNamespace(node.parent, namespace);
            }
            return namespace;
        }
        function tryGetTypeFromText(typeName) {
            // if a type is imported via some namespace e.g. THREE.AnimationClip
            // we want to remove that namespace / import name
            var separatorIndex = typeName.lastIndexOf(".");
            if (separatorIndex > 0) {
                var newName = typeName.substring(separatorIndex + 1);
                if (allowDebugLogs)
                    console.log("Remove import name from type: \"" + typeName + "\" → \"" + newName + "\"");
                typeName = newName;
            }
            var res = dict[typeName];
            if (res === undefined) {
                switch (typeName) {
                    case "Array":
                        break;
                    default:
                        var knownType = tryGetKnownType(typeName);
                        res = knownType !== null && knownType !== void 0 ? knownType : undefined;
                        break;
                }
            }
            // console.log(typeName, res);
            return res;
        }
        function tryResolveTypeRecursive(node) {
            if (!node)
                return undefined;
            // skip decorators (e.g. @serializable() may break array generation)
            if (node.kind === ts.SyntaxKind.Decorator)
                return undefined;
            var typeName = node === null || node === void 0 ? void 0 : node.getText();
            var varDec = node;
            if (varDec.type) {
                typeName = varDec.type.getText();
            }
            var res = undefined;
            // if it's a { x: number } inline object type:
            if (typeName.startsWith("{")) {
                // check if it has XYZW we assume it's a vector
                var hasX = typeName.includes("x");
                var hasY = typeName.includes("y");
                var hasZ = typeName.includes("z");
                var hasW = typeName.includes("w");
                if (hasX && hasY && hasZ && hasW) {
                    return tryGetTypeFromText("Vector4");
                }
                else if (hasX && hasY && hasZ) {
                    return tryGetTypeFromText("Vector3");
                }
                else if (hasX && hasY) {
                    return tryGetTypeFromText("Vector2");
                }
                return "object";
            }
            // const kindName = ts.SyntaxKind[node.kind];
            // console.log("Unknown type: " + typeName);
            switch (node.kind) {
                case ts.SyntaxKind.ObjectBindingPattern:
                    res = "object";
                    break;
                // case ts.SyntaxKind.SyntaxList:
                //     const list = node as ts.SyntaxList;
                //     for (const ch of list._children) {
                //         res = tryResolveTypeRecursive(ch);
                //     }
                //     break;
                case ts.SyntaxKind.UnionType:
                    var union = node;
                    for (var _i = 0, _a = union.types; _i < _a.length; _i++) {
                        var t = _a[_i];
                        res = tryResolveTypeRecursive(t);
                        if (res !== undefined)
                            return res;
                    }
                    break;
                case ts.SyntaxKind.ArrayType:
                    res = "[]";
                    break;
                case ts.SyntaxKind.TypeReference:
                    var typeRef = node;
                    var typeName_2 = typeRef.typeName.getText();
                    if (allowDebugLogs)
                        console.log("TypeReference:", typeName_2);
                    switch (typeName_2) {
                        case "Array":
                            break;
                        default:
                            return tryGetTypeFromText(typeName_2);
                    }
                    // return res;
                    break;
                case ts.SyntaxKind.BooleanKeyword:
                case ts.SyntaxKind.NumberKeyword:
                case ts.SyntaxKind.StringKeyword:
                case ts.SyntaxKind.ObjectKeyword:
                    var keyword = node.getText();
                    // the basic keywords are declared in the static dictionary
                    // no need for a complex lookup
                    res = dict[keyword];
                    break;
                case ts.SyntaxKind.Identifier:
                    var id = node;
                    switch (id.text) {
                        // if we have an array we dont want to use the System.Array as a type but just make it to the array syntax
                        case "Array":
                            res = "[]";
                            break;
                        default:
                            // console.log(id.text);
                            // res = tryGetTypeFromText(id.text);
                            break;
                    }
                    break;
            }
            var isInGenericDeclaration = false;
            for (var _b = 0, _c = node.getChildren(); _b < _c.length; _b++) {
                var child = _c[_b];
                // Fix https://linear.app/needle/issue/NE-4423
                if (child.kind === ts.SyntaxKind.Block) {
                    if (allowDebugLogs)
                        console.log("Skip block");
                    continue;
                }
                if (allowDebugLogs)
                    console.log("Child type: " + ts.SyntaxKind[child.kind]);
                var isGenericStart = false;
                var isAssignment = false;
                switch (child.kind) {
                    case ts.SyntaxKind.FirstAssignment:
                        isAssignment = true;
                        break;
                    case ts.SyntaxKind.FirstBinaryOperator:
                        // console.log("Generic start: " + child.getText());
                        isInGenericDeclaration = true;
                        isGenericStart = true;
                        break;
                    case ts.SyntaxKind.GreaterThanGreaterThanToken:
                        isInGenericDeclaration = false;
                        // console.log("Generic end: " + child.getText());
                        break;
                }
                // if (isAssignment) break;
                var childResult = tryResolveTypeRecursive(child);
                if (childResult !== undefined) {
                    if (res === undefined)
                        res = "";
                    if (allowDebugLogs)
                        console.log("Child: " + ts.SyntaxKind[child.kind] + " → " + childResult);
                    // if the thing is a generic return as generic result
                    if (isInGenericDeclaration && !res.includes("[]")) {
                        res = "<" + childResult + ">";
                    }
                    // we got a generic result, these need to be appended
                    else if (childResult.startsWith("<")) {
                        res += childResult;
                    }
                    // concat default
                    else
                        res = childResult + res;
                }
            }
            // if (ts.isTypeReferenceNode(node)) {
            //     const typeRef = node as ts.TypeReferenceNode;
            //     const typeName = typeRef.typeName.getText();
            //     switch (typeName) {
            //         case "Array":
            //             res += "[]";
            //             return res;
            //     }
            // }
            return res;
        }
    }
}
exports.run = run;
if (process) {
    if (process.argv.length < 4) {
        console.error("Missing args, call with: <output_dir> <input_files>");
    }
    else {
        var outputDir_1 = process.argv[2];
        var fileNames = process.argv.slice(3);
        fileNames.forEach(function (fileName) {
            try {
                if (!fs.existsSync(fileName)) {
                    console.error("File not found: " + fileName);
                }
                else {
                    var code = (0, fs_1.readFileSync)(fileName).toString();
                    compile(code, fileName, outputDir_1);
                }
            }
            catch (e) {
                console.error(e);
            }
        });
    }
}
