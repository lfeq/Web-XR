import { readFileSync } from "fs";
import * as ts from "typescript";
import * as fs from "fs";
import * as path from 'path';

import * as types from "./types";
const dict = types.dict;

// add either of these two comments above a class to enforce code gen or disable it for the next class
const exportNextClassCommand = "@generate-component";
const dontExportNextClassCommand = "@dont-generate-component";
// add above field to add [SerializeField] attribute
const serializeCommand = "@serializeField";
const dontSerializeCommand = "@nonSerialized";
// https://regex101.com/r/ltpcKT/2
const typePattern = new RegExp("@type ?(?<type>.+)");
const ifdefPattern = new RegExp("@ifdef ?(?<ifdef>.+)")

const CODEGEN_MARKER_START = "// NEEDLE_CODEGEN_START";
const CODEGEN_MARKER_END = "// NEEDLE_CODEGEN_END";

let allowDebugLogs = true;

// will be set to true when e.g. a comment for export is found
let exportNextClass: boolean = false;
let dontExportNextClass: boolean = false;
let serializeField: boolean = false;
let dontSerialize: boolean = false;
let typesFileContent: object | undefined | null = undefined;

// const exportDir = "../dist";
const commentStarts: Array<number> = [];
const contexts: ExportContext[] = [];
let lastTypeFound: string | null = null;
let ifdefSections: string[] = [];

function resetAllState() {
    exportNextClass = false;
    dontExportNextClass = false;
    serializeField = false;
    dontSerialize = false;
    typesFileContent = undefined;

    commentStarts.length = 0;
    contexts.length = 0;
    lastTypeFound = null;
    ifdefSections.length = 0;
}

function resetExportNextClass() {
    dontExportNextClass = false;
    exportNextClass = false;
}

function tryGetKnownType(str: string): string | null {
    if (typesFileContent === undefined) {
        typesFileContent = null;
        const filePath = path.dirname(__dirname) + "/src/types.json";
        if (fs.existsSync(filePath)) {
            if (allowDebugLogs)
                console.log("Reading types file");
            const content = fs.readFileSync(filePath, "utf8");
            typesFileContent = JSON.parse(content);
        }
    }

    if (typesFileContent) {
        const fullType = typesFileContent[str];
        if (fullType && allowDebugLogs)
            console.log(fullType);
        return fullType;
    }
    return null;
}

// https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API


class ExportContext {
    outputDir: string | null;
    fileName: string;
    textBuffer: string;
    classEnd: number = -1;
    indentLevel: number = 0;

    constructor(outputDir: string | null, fileName: string) {
        this.outputDir = outputDir;
        this.fileName = fileName;
        this.reset();
    }

    emitMethodContextMenu: string | null | undefined = null;
    emitTooltip: string | null | undefined = null;

    onBeforeField(name: string) {
        if (this.emitTooltip) {
            this.appendLine("[UnityEngine.Tooltip(\"" + this.emitTooltip.trim().replace("\"", "'") + "\")]");
            this.emitTooltip = undefined;
        }
    }

    onBeforeMethod(name: string) {
        if (this.emitMethodContextMenu !== undefined) {
            const contextMenuText = this.emitMethodContextMenu === null ? name : this.emitMethodContextMenu;
            this.appendLine("[UnityEngine.ContextMenu(\"" + contextMenuText + "\")]");
            this.emitMethodContextMenu = undefined;
        }
    }

    append(text: string) {
        for (let i = 0; i < this.indentLevel; i++)
            text = "\t" + text;
        this.textBuffer += text;
        this.emitMethodContextMenu = undefined;
    }

    appendLine(text: string) {
        this.append(text + "\n");
    }

    flush(): string {
        if (this.textBuffer.length <= 0) {
            return;
        }
        this.textBuffer = CODEGEN_MARKER_START + "\n" + this.textBuffer + "\n" + CODEGEN_MARKER_END;
        let code = this.textBuffer;
        if (this.outputDir !== null) {
            if (!fs.existsSync(this.outputDir))
                fs.mkdirSync(this.outputDir);
            const dir = this.outputDir + "/";
            const path = dir + this.fileName;
            code = this.replaceGeneratedCodeSection(path, code);
            if (allowDebugLogs)
                console.log("Write to " + path);
            fs.writeFileSync(path, code);
        }
        else {
            console.log("No output dir specified");
        }
        this.reset();
        return code;
    }

    reset() {
        this.textBuffer = "";
        this.classEnd = -1;
    }

    private replaceGeneratedCodeSection(path: string, code: string) {
        if (fs.existsSync(path)) {
            const existing = fs.readFileSync(path, "utf8");
            const regex = new RegExp("(?<before>.*?)\/\/ ?NEEDLE_CODEGEN_START.+\/\/ ?NEEDLE_CODEGEN_END(?<after>.*)", "s");
            const matches = regex.exec(existing);
            if (matches?.groups) {
                if (allowDebugLogs)
                    console.log("Found codegen sections")
                const before = matches.groups.before;
                const after = matches.groups.after;
                return before + code + after;
            }
        }
        return code;
    }
}

export function compile(code: string, fileName: string, outputDir: string | null, debugLogs: boolean = true): string[] {

    resetAllState();
    allowDebugLogs = debugLogs;

    // Parse a file
    const sourceFile = ts.createSourceFile(
        fileName,
        code,
        ts.ScriptTarget.ES2015,
        true, /*setParentNodes */
    );

    const prog = ts.createProgram([fileName], {});

    // delint it
    return run(prog, outputDir, sourceFile);
}

export function run(program: ts.Program, outputDir: string | null, sourceFile: ts.SourceFile): string[] {

    if (outputDir !== null && !fs.existsSync(outputDir)) {
        console.error("Output directory does not exist: \"" + outputDir + "\"");
        return;
    }

    const results: string[] = [];

    traverseFile(sourceFile);
    function traverseFile(node: ts.Node) {

        visit(node);
        ts.forEachChild(node, traverseFile);
    }

    return results;

    function visit(node: ts.Node) {
        let context: ExportContext | null = contexts.length > 0 ? contexts[contexts.length - 1] : null;

        if (context) {
            if (context?.classEnd > 0 && node.pos >= context?.classEnd) {
                while (context.indentLevel > 0) {
                    context.indentLevel -= 1;
                    context.append("}\n");
                }
                const code = context.flush();
                results.push(code);
                context = null;
                contexts.pop();
            }
        }
        if (allowDebugLogs)
            console.log("\t", ts.SyntaxKind[node.kind]);

        const commentRanges = ts.getLeadingCommentRanges(
            sourceFile.getFullText(),
            node.getFullStart());
        if (commentRanges?.length) {
            for (const r of commentRanges) {
                // avoid emitting comments multiple times
                if (commentStarts.includes(r.pos)) continue;
                commentStarts.push(r.pos);
                const comment = node.getSourceFile().getFullText().slice(r.pos, r.end);
                console.log(comment);
                if (context) {
                    // https://regex101.com/r/ud4oev/1
                    const emitContextMenu = comment.match("(\/{2,}|\/\*) {0,}@contextmenu {1,}(?<text>[a-zA-Z 0-9]+)?");
                    if (emitContextMenu) {
                        context.emitMethodContextMenu = emitContextMenu.groups?.text ?? null;
                    }
                    // https://regex101.com/r/Sa6Q8T/3
                    const emitTooltip = comment.match("\/{2,} {0,}(@tooltip) *?(?<text>.+)");
                    if (emitTooltip) {
                        console.log(emitTooltip.groups?.text);
                        context.emitTooltip = emitTooltip.groups?.text ?? null;
                    }
                    else if (comment.includes(serializeCommand))
                        serializeField = true;
                    else if (comment.includes(dontSerializeCommand))
                        dontSerialize = true;
                }
                if (comment.includes(exportNextClassCommand))
                    exportNextClass = true;
                if (comment.includes(dontExportNextClassCommand))
                    dontExportNextClass = true;
                const typeMatch = typePattern.exec(comment);
                if (typeMatch && typeMatch.groups) {
                    // for some reason our regex does also match surrounding ( ) even tho: https://regex101.com/r/PoWK6V/1
                    // so we remove them
                    let type = typeMatch.groups["type"];
                    type = type.replace(/\(/, "").replace(/\)/, "");
                    if (allowDebugLogs)
                        console.log("Found type: ", type);
                    lastTypeFound = type;
                }

                const ifdefMatch = ifdefPattern.exec(comment);
                if (ifdefMatch && ifdefMatch.groups) {
                    const ifdef = ifdefMatch.groups["ifdef"];
                    if (ifdef)
                        ifdefSections.push(ifdef);
                }
            }
        }

        const skip = dontSerialize;
        switch (node.kind) {
            // Namespace
            // case ts.SyntaxKind.ModuleDeclaration:
            //     const mod = node as ts.ModuleDeclaration;
            //     console.log(ts.SyntaxKind[mod.getChildAt(1).kind])
            //     const type = mod.getChildAt(1) as ts.Identifier;
            //     console.log("MODULE", type.text)
            //     break;
            // case ts.SyntaxKind.Identifier:
            //     break;
            // case ts.SyntaxKind.ClassDeclaration:
            // case ts.SyntaxKind.SingleLineCommentTrivia:
            //     console.log("comment: " + node.getText())
            //     break;
            case ts.SyntaxKind.Decorator:
                break;
            case ts.SyntaxKind.MethodDeclaration:
                lastTypeFound = null;
                serializeField = false;
                dontSerialize = false;
                resetExportNextClass();
                if (!context) break;
                // TODO: always emit at least OnEnable method per class so generated components have toggle in editor
                const meth = node as ts.MethodDeclaration;
                // const isCoroutine = func.asteriskToken;
                if (!skip && meth.name) {
                    const pub = shouldEmitMethod(meth);
                    if (!pub) return;

                    let paramsStr = "";
                    for (let param of meth.parameters) {
                        if (!param || !param.name) continue;
                        if (paramsStr.length > 0) paramsStr += ", ";
                        let type = tryResolveTypeRecursive(param);
                        if (type === undefined) type = "object";
                        let paramName = "";
                        const paramNameKind = param.name.kind;
                        switch (paramNameKind) {
                            case ts.SyntaxKind.ObjectBindingPattern:
                                paramName = "obj"
                                break;
                            default:
                                paramName = param.name.getText();
                                break;
                        }
                        paramsStr += type + " @" + paramName;
                    }
                    let methodName = meth.name.getText();
                    switch (methodName) {
                        case "onEnable": methodName = "OnEnable"; break;
                        case "onDisable": methodName = "OnDisable"; break;
                    }
                    context.onBeforeMethod(methodName);
                    // let visibility = pub ? "public" : "private";
                    context.append("public void " + methodName + "(" + paramsStr + "){}\n");
                }
                break;


            case ts.SyntaxKind.SetAccessor:
            case ts.SyntaxKind.PropertyDeclaration:
                resetExportNextClass();
                if (!context) break;
                if (allowDebugLogs)
                    console.log("Found variable", ts.SyntaxKind[node.kind], "\n", node.getText());
                const vardec = node as ts.VariableDeclaration;

                const varName = "@" + vardec.name.getText();
                const pub = shouldEmitMethod(vardec);
                const visibility = pub ? "public" : "private";
                let isAccessible = pub;
                dontSerialize = false;
                if (serializeField) {
                    if (allowDebugLogs)
                        console.log("[SerializeField]");
                    context.appendLine("[UnityEngine.SerializeField]");
                    isAccessible = true;
                }
                else if (skip)
                    isAccessible = false;

                if (!isAccessible) {
                    if (allowDebugLogs)
                        console.log("Skip because not public or serializeable")
                    break;
                }

                const name = vardec.name.getText();
                if (allowDebugLogs)
                    console.log("Variable:", name);
                if (name.startsWith("\"@") || name.startsWith("\"$") || name.startsWith("$")) break;
                let typeString = lastTypeFound ?? tryResolveTypeRecursive(node);
                let postFix = "";
                let typeName = vardec.type?.getText();
                let shouldCommentTheLine = typeString === undefined;
                if (typeString === undefined) {
                    postFix = " → Could not resolve C# type";
                }
                let assignment = "";
                if (typeString !== undefined) {
                    for (const ch of node.getChildren()) {
                        switch (ch.kind) {
                            default:
                                // console.log("Unknown assignment:", ts.SyntaxKind[ch.kind]);
                                break;
                            case ts.SyntaxKind.NewExpression:
                                assignment = " = " + getTypeForAssignment(ch, typeString);
                                break;
                            case ts.SyntaxKind.FalseKeyword:
                            case ts.SyntaxKind.TrueKeyword:
                                assignment = " = " + ch.getText();
                                break;
                            case ts.SyntaxKind.StringLiteral:
                                const str = ch as ts.StringLiteral;
                                assignment = " = \"" + str.text + "\"";
                                break;
                            case ts.SyntaxKind.FirstLiteralToken:
                                const lit = ch as ts.LiteralExpression;
                                assignment = " = " + lit.text;
                                if (ts.isNumericLiteral(lit))
                                    assignment += "f";
                                break;
                            case ts.SyntaxKind.ArrayLiteralExpression:
                                const arr = ch as ts.ArrayLiteralExpression;
                                assignment = " = new " + typeString;
                                // if (arr.elements.length > 0) {
                                assignment += "{" + arr.elements.map(e => " " + getTypeForAssignment(e)) + " }";
                                // }
                                break;
                        }
                    }
                }
                let requireEndIf = false;
                if (ifdefSections.length > 0) {
                    requireEndIf = true;
                    context.appendLine("#ifdef " + ifdefSections.pop());
                }
                if (typeString === undefined) typeString = typeName;
                if (typeString === "[]") {
                    if (allowDebugLogs)
                        console.log("Unknown array type for \"" + varName + " " + typeName + "\" - your type is probably not known (did you just create it this session?) and you might need to regenerate the Typemap in Unity. Go to \"Needle Engine/Internal/Generate Type Map for component compiler")
                    // typeString = "object[]";
                    // assignment = " = new object[0]";
                    shouldCommentTheLine = true;
                }
                context.onBeforeField(varName);
                if (allowDebugLogs)
                    console.log("EMIT member: \"" + typeString + "\" " + varName, assignment, "Last type found:", lastTypeFound);
                const prefix = shouldCommentTheLine ? "// " : "";
                const isUnityEditorType = typeString?.includes("UnityEditor");
                if (isUnityEditorType) {
                    context.appendLine("#if UNITY_EDITOR");
                }
                context.append(prefix + visibility + " " + typeString + " " + varName + assignment + ";" + postFix + "\n");
                if (isUnityEditorType) {
                    context.appendLine("#endif");
                }
                lastTypeFound = null;
                if (requireEndIf) {
                    context.appendLine("#endif");
                }
                break;

            case ts.SyntaxKind.ClassDeclaration:
                serializeField = false;
                const dec = <ts.ClassDeclaration>node;
                // a class must inherit a component
                const inheritsComponent = testInheritsComponent(node);
                if (!dontExportNextClass && (lastTypeFound || exportNextClass || inheritsComponent)) {
                    resetExportNextClass();
                    const name = dec.name?.escapedText;
                    if (allowDebugLogs)
                        console.log("Found class: ", name);
                    const namespace = tryParseNamespace(node) ?? "Needle.Typescript.GeneratedComponents";
                    if (allowDebugLogs)
                        console.log("NAMESPACE", namespace);
                    const newContext = new ExportContext(outputDir, name + ".cs");
                    newContext.appendLine("// auto generated code - do not edit directly");
                    newContext.appendLine("");
                    newContext.appendLine("#pragma warning disable");
                    newContext.appendLine("");
                    newContext.appendLine("namespace " + namespace);
                    newContext.appendLine("{");
                    newContext.indentLevel += 1;
                    // newContext.appendLine("// source: " + path.resolve(sourceFile.fileName));
                    let typeName = "UnityEngine.MonoBehaviour";
                    if (typeof inheritsComponent === "string") typeName = inheritsComponent;
                    if (lastTypeFound) typeName = lastTypeFound;
                    if (allowDebugLogs)
                        console.log(name + " inherits " + typeName);
                    let modifiers = "";
                    if (dec.modifiers) {
                        for (const mod of dec.modifiers) {
                            switch (mod.getText()) {
                                case "abstract":
                                    modifiers += " abstract";
                                    if (allowDebugLogs)
                                        console.log(name + " is abstract");
                                    break;
                            }
                        }
                    }
                    modifiers += " partial";
                    newContext.appendLine("public " + modifiers.trim() + " class " + name + " : " + typeName);
                    newContext.appendLine("{");
                    newContext.indentLevel += 1;
                    newContext.classEnd = dec.end;
                    contexts.push(newContext);
                }
                else {
                    if (allowDebugLogs)
                        console.log("Class type is unknown and will not generate a component: ", dec.name?.escapedText);
                }
                lastTypeFound = null;
                break;
        }

        function testInheritsComponent(node: ts.Node): boolean | string {
            switch (node.kind) {
                case ts.SyntaxKind.ClassDeclaration:
                    const dec = <ts.ClassDeclaration>node;
                    if (dec.heritageClauses) {
                        for (const h of dec.heritageClauses) {
                            if (h.types.length <= 0) continue;
                            for (const type of h.types) {
                                // const symbol = program.getTypeChecker().getSymbolAtLocation(type.expression);
                                // console.log(symbol);
                                const text = type.expression.getText();
                                if (text === "Component") return true;
                                if (text === "Behaviour") return true;
                                const known = tryGetKnownType(text);
                                if (known) return known;
                            }
                        }
                    }
                    return false;
            }
            return false;
        }

        function getTypeForAssignment(node: ts.Node, typeString?: string) {
            // console.log("-------------------\nAssign", ts.SyntaxKind[node.kind]);
            switch (node.kind) {
                case ts.SyntaxKind.FirstLiteralToken:
                    return node.getText();
                case ts.SyntaxKind.NewExpression:
                    let type: string | undefined = undefined;
                    let args: string | undefined = undefined;
                    for (const ch of node.getChildren()) {
                        const text = ch.getText();
                        console.log("child", ts.SyntaxKind[ch.kind], text);
                        switch (ch.kind) {
                            case ts.SyntaxKind.Identifier:
                            case ts.SyntaxKind.PropertyAccessExpression:
                                type = tryGetTypeFromText(text);
                                break;
                            case ts.SyntaxKind.SyntaxList:
                                for (const arg of ch.getChildren()) {
                                    if (args === undefined) args = "";
                                    const res = getTypeForAssignment(arg, typeString);
                                    // handle floats being assigned with "f" suffix
                                    if (Number.parseFloat(res) >= 0) {
                                        args += res + "f";
                                    }
                                    else {
                                        args += res;
                                        if (res === ",") args += " ";
                                    }
                                }
                                break;
                        }
                    }
                    if (!args) args = "";
                    if (type || typeString) {
                        if (typeString) {
                            console.log("Override type", type, typeString)
                            type = typeString;
                        }
                        return "new " + type + "(" + args + ")";
                    }
                    // const expType = node.getChildren().find(c => c.kind === ts.SyntaxKind.Identifier);
                    break;
            }

            const str = node.getText();
            if (allowDebugLogs)
                console.log("Unknown assignment:", str, ts.SyntaxKind[node.kind]);
            return str;
        }

        function shouldEmitMethod(node: ts.Node): boolean {
            if (node.kind === ts.SyntaxKind.PublicKeyword) {
                return true;
            }
            else if (node.kind === ts.SyntaxKind.PrivateKeyword || node.kind === ts.SyntaxKind.ProtectedKeyword) {
                return false;
            }
            // check if its static
            else if (node.kind === ts.SyntaxKind.StaticKeyword) {
                return false;
            }
            // check if its abstract
            else if (node.kind === ts.SyntaxKind.AbstractKeyword) {
                return false;
            }

            for (const ch of node.getChildren()) {
                if (!shouldEmitMethod(ch)) return false;
            }
            return true;
        }

        function tryParseNamespace(node: ts.Node, namespace?: string): string | null | undefined {
            // console.log("TRAVERSE - " + ts.SyntaxKind[node.kind]);
            switch (node.kind) {
                case ts.SyntaxKind.ModuleDeclaration:
                    for (const ch of node.getChildren()) {
                        // console.log("-- TRAVERSE - " + ts.SyntaxKind[ch.kind]);
                        switch (ch.kind) {
                            case ts.SyntaxKind.Identifier:
                                const id = ch as ts.Identifier;
                                if (id.text) {
                                    if (!namespace) namespace = "";
                                    namespace = id.text + (namespace ? "." : "") + namespace;
                                }
                                break;
                        }
                    }
                    break;
            }
            if (node.parent) {
                return tryParseNamespace(node.parent, namespace);
            }
            return namespace;
        }

        function tryGetTypeFromText(typeName: string) {

            // if a type is imported via some namespace e.g. THREE.AnimationClip
            // we want to remove that namespace / import name
            const separatorIndex = typeName.lastIndexOf(".");
            if (separatorIndex > 0) {
                let newName = typeName.substring(separatorIndex + 1);
                if (allowDebugLogs)
                    console.log("Remove import name from type: \"" + typeName + "\" → \"" + newName + "\"");
                typeName = newName;
            }

            let res = dict[typeName];
            if (res === undefined) {
                switch (typeName) {
                    case "Array":
                        break;
                    default:
                        const knownType = tryGetKnownType(typeName);
                        res = knownType ?? undefined;
                        break;
                }
            }
            // console.log(typeName, res);
            return res;
        }

        function tryResolveTypeRecursive(node: ts.Node | ts.VariableDeclaration): string | undefined {
            if (!node) return undefined;

            // skip decorators (e.g. @serializable() may break array generation)
            if (node.kind === ts.SyntaxKind.Decorator)
                return undefined;

            let typeName = node?.getText();

            const varDec: ts.VariableDeclaration = node as ts.VariableDeclaration;
            if (varDec.type) {
                typeName = varDec.type.getText();
            }

            let res: string | undefined = undefined;

            // if it's a { x: number } inline object type:
            if (typeName.startsWith("{")) {
                // check if it has XYZW we assume it's a vector
                const hasX = typeName.includes("x");
                const hasY = typeName.includes("y");
                const hasZ = typeName.includes("z");
                const hasW = typeName.includes("w");
                if (hasX && hasY && hasZ && hasW) {
                    return tryGetTypeFromText("Vector4");
                }
                else if (hasX && hasY && hasZ) {
                    return tryGetTypeFromText("Vector3");
                }
                else if (hasX && hasY) {
                    return tryGetTypeFromText("Vector2");
                }

                return "object";
            }

            // const kindName = ts.SyntaxKind[node.kind];
            // console.log("Unknown type: " + typeName);

            switch (node.kind) {
                case ts.SyntaxKind.ObjectBindingPattern:
                    res = "object";
                    break;
                // case ts.SyntaxKind.SyntaxList:
                //     const list = node as ts.SyntaxList;
                //     for (const ch of list._children) {
                //         res = tryResolveTypeRecursive(ch);
                //     }
                //     break;
                case ts.SyntaxKind.UnionType:
                    const union = node as ts.UnionTypeNode;
                    for (const t of union.types) {
                        res = tryResolveTypeRecursive(t);
                        if (res !== undefined) return res;
                    }
                    break;

                case ts.SyntaxKind.ArrayType:
                    res = "[]";
                    break;

                case ts.SyntaxKind.TypeReference:
                    const typeRef = node as ts.TypeReferenceNode;
                    const typeName = typeRef.typeName.getText();
                    if (allowDebugLogs)
                        console.log("TypeReference:", typeName);
                    switch (typeName) {
                        case "Array":
                            break;
                        default:
                            return tryGetTypeFromText(typeName);
                    }
                    // return res;
                    break;

                case ts.SyntaxKind.BooleanKeyword:
                case ts.SyntaxKind.NumberKeyword:
                case ts.SyntaxKind.StringKeyword:
                case ts.SyntaxKind.ObjectKeyword:
                    const keyword = node.getText();
                    // the basic keywords are declared in the static dictionary
                    // no need for a complex lookup
                    res = dict[keyword];
                    break;

                case ts.SyntaxKind.Identifier:
                    const id = node as ts.Identifier;
                    switch (id.text) {
                        // if we have an array we dont want to use the System.Array as a type but just make it to the array syntax
                        case "Array":
                            res = "[]";
                            break;
                        default:
                            // console.log(id.text);
                            // res = tryGetTypeFromText(id.text);
                            break;
                    }
                    break;
            }

            let isInGenericDeclaration = false;
            for (const child of node.getChildren()) {
                

                // Fix https://linear.app/needle/issue/NE-4423
                if (child.kind === ts.SyntaxKind.Block) {
                    if(allowDebugLogs) console.log("Skip block");
                    continue;
                }

                if(allowDebugLogs) console.log("Child type: " + ts.SyntaxKind[child.kind]);
                let isGenericStart = false;
                let isAssignment = false;
                switch (child.kind) {
                    case ts.SyntaxKind.FirstAssignment:
                        isAssignment = true;
                        break;
                    case ts.SyntaxKind.FirstBinaryOperator:
                        // console.log("Generic start: " + child.getText());
                        isInGenericDeclaration = true;
                        isGenericStart = true;
                        break;
                    case ts.SyntaxKind.GreaterThanGreaterThanToken:
                        isInGenericDeclaration = false;
                        // console.log("Generic end: " + child.getText());
                        break;
                }
                // if (isAssignment) break;
                const childResult = tryResolveTypeRecursive(child);
                if (childResult !== undefined) {
                    if (res === undefined) res = "";
                    if (allowDebugLogs)
                        console.log("Child: " + ts.SyntaxKind[child.kind] + " → " + childResult);
                    // if the thing is a generic return as generic result
                    if (isInGenericDeclaration && !res.includes("[]")) {
                        res = "<" + childResult + ">";
                    }
                    // we got a generic result, these need to be appended
                    else if (childResult.startsWith("<")) {
                        res += childResult;
                    }
                    // concat default
                    else
                        res = childResult + res;
                }
            }

            // if (ts.isTypeReferenceNode(node)) {
            //     const typeRef = node as ts.TypeReferenceNode;
            //     const typeName = typeRef.typeName.getText();
            //     switch (typeName) {
            //         case "Array":
            //             res += "[]";
            //             return res;
            //     }
            // }

            return res;
        }
    }
}


if (process) {

    if (process.argv.length < 4) {
        console.error("Missing args, call with: <output_dir> <input_files>");
    }
    else {
        const outputDir = process.argv[2];
        const fileNames = process.argv.slice(3);
        fileNames.forEach(fileName => {
            try {
                if (!fs.existsSync(fileName)) {
                    console.error("File not found: " + fileName);
                }
                else {
                    const code = readFileSync(fileName).toString();
                    compile(code, fileName, outputDir);
                }
            }
            catch (e) {
                console.error(e);
            }
        });
    }
}