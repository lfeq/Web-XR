import FtpDeploy from "ftp-deploy";
import { error, log, warning } from "../utils/log.js";
import { isAbsolute, join } from "path";
import { Client } from "basic-ftp";
import { getOSTempDirectory } from "../utils/path-utils.js";
import { existsSync, mkdirSync, readFileSync, rmSync } from "fs";
import crypto from "crypto";
/**
 * Uploads a file or directory to an FTP server
 * @param server The server to upload to
 * @param username The username to use for the connection
 * @param password The password to use for the connection
 * @param remotepath The path on the server to upload to
 * @param localpath The path of the file or directory to upload
 * @param sftp Whether to use SFTP or not
 * @param delete_remote Whether to delete files on the server that are not present locally
 * @param port The port to use for the connection
 * @param only_changed Whether to only upload files that have changed (default true)
 */
export async function upload_to_ftp(server, username, password, remotepath, localpath, sftp, delete_remote, port, only_changed = true) {
    // console.log("upload_to_ftp", server, username, password, remotepath, localpath, "SFTP", sftp, "Delete", delete_remote);
    const ignorePatterns = [
        'node_modules/**',
        '.git/**',
    ];
    if (only_changed) {
        try {
            const serverinfo = await queryLastBuildInfo({ server, username, password, remotepath, localpath, sftp })
                .catch(err => { warning("Querying last build info failed: " + err.message); return { ignore: [] }; });
            if (serverinfo.ignore?.length > 0) {
                console.log(`${serverinfo.ignore.length} files have not changed and do not need to be reuploaded`);
                ignorePatterns.push(...serverinfo.ignore);
            }
        }
        catch (err) {
            error("Error querying last build info: " + err.message);
        }
    }
    // TODO: if localpath is a file we should set include pattern to the filename and localpath to the directory
    const includePatterns = ['*', '**/*', '.*'];
    // make sure the local path is either absolute or relative to the working directory
    if (!isAbsolute(localpath)) {
        localpath = join(process.cwd(), localpath);
    }
    const ftpDeploy = new FtpDeploy();
    const config = {
        user: username,
        password: password,
        host: server,
        port: port,
        localRoot: localpath,
        remoteRoot: remotepath,
        include: includePatterns,
        exclude: ignorePatterns,
        deleteRemote: delete_remote,
        forcePasv: true,
        sftp: sftp,
    };
    // ftpDeploy.on('uploading', function (data) {
    //     console.log("Uploading: " + data.filename);
    // });
    const startTime = Date.now();
    let lastTimePercentLogged = Date.now();
    ftpDeploy.on("uploaded", function (data) {
        if (Date.now() - lastTimePercentLogged < 1000)
            return;
        lastTimePercentLogged = Date.now();
        const prog01 = data.transferredFileCount / data.totalFilesCount;
        const timeLeft = (Date.now() - startTime) / prog01 - (Date.now() - startTime);
        const secLeft = timeLeft / 1000;
        let timeLeftStr = secLeft.toFixed(0) + " sec";
        if (secLeft > 60) {
            timeLeftStr = (secLeft / 60).toFixed(1) + " min";
        }
        console.log(`Uploaded ${data.transferredFileCount} of ${data.totalFilesCount} files \t â†’ ${(prog01 * 100).toFixed(1)} %, approx ${timeLeftStr} until done. File: ${data.filename}`);
    });
    ftpDeploy.on("upload-error", function (data) {
        error("Upload error: " + data.err);
    });
    console.log("Begin uploading...");
    await ftpDeploy.deploy(config).catch(err => {
        error(err.message);
        if (err.message.includes("Connection lost before handshake")) {
            error("Make sure your server exists and your connection details are correct (e.g. make sure FTP or SFTP settings are correct)");
        }
    });
    log("Upload complete");
}
async function queryLastBuildInfo(args) {
    const res = {
        ignore: []
    };
    console.log("Querying last build info...");
    const client = new Client();
    await client.access({
        host: args.server,
        user: args.username,
        password: args.password,
        secure: args.sftp,
    });
    client.ftp.verbose = false;
    const files = await client.list(args.remotepath).catch(err => {
        // if the directory doesnt exist yet
        if (err.code == 450) {
            warning("Query buildinfo.json: Could not list files on server. Directory does not exist or is empty.");
            return [];
        }
        throw err;
    });
    for (const file of files) {
        const name = file.name;
        switch (name) {
            // check if the server contains a needle.buildinfo.json file
            case "needle.buildinfo.json":
                // if yes download it and check if the hash of the local file has changed
                const fullremotepath = args.remotepath + "/" + name;
                const tempfilepath = getOSTempDirectory();
                if (!existsSync(tempfilepath))
                    mkdirSync(tempfilepath, { recursive: true });
                const localpath = tempfilepath + "/needle-buildinfo.json";
                if (existsSync(localpath))
                    rmSync(localpath);
                console.log(`Downloading ${fullremotepath} to ${localpath}...`);
                await client.downloadTo(localpath, fullremotepath);
                if (existsSync(localpath)) {
                    const content = readFileSync(localpath, "utf-8");
                    const buildInfo = JSON.parse(content);
                    if (buildInfo.files) {
                        for (const file of buildInfo.files) {
                            if (file.hash) {
                                const localPath = args.localpath + "/" + file.path;
                                if (existsSync(localPath)) {
                                    const sha256 = crypto.createHash('sha256');
                                    const hash = sha256.update(readFileSync(localPath)).digest('hex');
                                    if (hash === file.hash) {
                                        console.log(`INFO: File is up to date and does not need to be reuploaded: \"${file.path}\"`);
                                        res.ignore.push(file.path);
                                    }
                                }
                            }
                        }
                    }
                }
                break;
        }
    }
    return res;
}
