import { existsSync, readFileSync, writeFileSync, readdirSync, rmSync } from "fs";
import path from "path";
import { error, log, warning } from "../utils/log.js";
import { execSync } from "child_process";
import { isWin } from "../utils/platform.js";
import { isMac } from "../utils/platform.js";
import { findGitDirectory } from "../utils/git.js";
import os from "os";
export async function publishFolderToGithubPages(folderToPublish, repoURL) {
    try {
        execSync('git --version', { stdio: 'inherit' });
    }
    catch (e) {
        error("Could not find git. Please install git and try again.");
        return;
    }
    if (repoURL?.length && (!repoURL.includes('github.com') && !repoURL.includes("github.io"))) {
        error("Please specify a github repository url. Invalid url: " + repoURL);
        return;
    }
    const originalFolder = folderToPublish;
    let projectDirectory = null;
    const gitDirectory = findGitDirectory(folderToPublish);
    if (!gitDirectory) {
        warning("Could not find git directory for " + folderToPublish);
        if (process.env.TEMP && existsSync(process.env.TEMP)) {
            const tempPath = process.env.TEMP;
            projectDirectory = tempPath;
            console.log("Use temp path: \"" + tempPath + "\"");
        }
        else {
            // get OS specific temp directory
            projectDirectory = os.tmpdir();
            warning("Could not find git or temp directory (set the TEMP process environment variable or setup your project inside a git repository). We couldn't find a git directory in any of the parent folders of \"" + path.resolve(folderToPublish) + "\" so a temporary directory will be used in \"" + projectDirectory + "\"");
        }
    }
    else {
        console.log("Found git directory: \"" + path.resolve(gitDirectory) + "\"");
        projectDirectory = gitDirectory;
    }
    let projectName = path.basename(folderToPublish);
    // check if the folder has a needle.config.json
    const needleConfigPath = path.join(folderToPublish, 'needle.config.json');
    if (existsSync(needleConfigPath)) {
        const content = readFileSync(needleConfigPath).toString();
        const needleConfig = JSON.parse(content);
        if (needleConfig.buildDirectory) {
            console.log("Found build directory from needle.config in " + folderToPublish + " set to " + needleConfig.buildDirectory);
            folderToPublish = path.join(folderToPublish, needleConfig.buildDirectory);
        }
    }
    // Make sure files are not gzipped in folderToPublish
    const files = readdirSync(folderToPublish);
    for (const file of files) {
        if (file.endsWith('.gz')) {
            error("Can not publish to github because files are gzipped in \"" + folderToPublish + "\". Please make sure to disable gzip compression.");
            return;
        }
    }
    console.log("Will publish " + folderToPublish + " to github pages");
    // Set working directory to git directory
    let originalRemoteInfo = false;
    let commitSha = undefined;
    if (gitDirectory) {
        const relativePath = path.relative(gitDirectory, folderToPublish);
        console.log("Relative path: " + relativePath);
        process.chdir(gitDirectory);
        try {
            const originalRemote = execSync('git config --get remote.origin.url', { stdio: 'inherit' }).toString().trim();
            originalRemoteInfo = getUserAndRepositoryNameFromUrl(originalRemote);
            // get current commit sha
            commitSha = execSync('git rev-parse HEAD').toString().trim();
            // get remote URL
            if (!repoURL) {
                repoURL = execSync('git config --get remote.origin.url').toString().trim();
            }
        }
        catch (e) {
            console.log("WARN: Received \"" + e.message + "\" in git repository at " + gitDirectory);
            ;
        }
    }
    if (!repoURL) {
        error("Could not find remote url. Please specify a github repository url. Invalid url: " + repoURL);
        return;
    }
    console.log("Remote: " + repoURL);
    const matches = getUserAndRepositoryNameFromUrl(repoURL);
    if (matches === false) {
        error("Could not parse remote url: " + repoURL);
        return;
    }
    const userNameFromRemote = matches.user;
    let repoNameFromRemote = matches.repo;
    if (repoURL.includes("github.io")) {
        repoURL = `https://github.com/${userNameFromRemote}/${repoNameFromRemote}`;
    }
    console.log("Github pages url: " + `https://${userNameFromRemote}.github.io/${repoNameFromRemote}`);
    // create a temp folder
    const tempFolder = path.join(projectDirectory, 'temp-needle-deploy-to-github~');
    // clear the folder if it exists
    if (existsSync(tempFolder)) {
        console.log("Clear temp folder: " + tempFolder);
        rmSync(tempFolder, { recursive: true, force: true });
    }
    if (!existsSync(tempFolder)) {
        console.log("Create temp folder: " + tempFolder);
        execSync('mkdir \"' + tempFolder + "\"");
    }
    // copy the folder to publish to the temp folder
    console.log("Copy " + folderToPublish + " to " + tempFolder);
    // check if we're on windows:
    if (isWin()) {
        execSync('xcopy \"' + folderToPublish + '\" \"' + tempFolder + '\" /E /I /H');
    }
    else if (isMac()) {
        // when the foldername doesn't end with a slash, the folder itself is copied, otherwise the content
        const ensureEndsWithSlashName = folderToPublish.endsWith('/') ? folderToPublish : folderToPublish + '/';
        execSync('cp -R \"' + ensureEndsWithSlashName + '\" \"' + tempFolder + "\"");
    }
    else {
        error("Unsupported platform: " + process.platform);
        return;
    }
    // Disable Jekyll on GitHub Pages
    const noJekyllPath = path.join(tempFolder, '.nojekyll');
    if (!existsSync(noJekyllPath)) {
        writeFileSync(noJekyllPath, "");
    }
    // Set working directory to temp directory
    process.chdir(tempFolder);
    // create a temporary git repository
    execSync('git init');
    // add remote
    execSync('git remote add origin ' + repoURL);
    // checkout gh-pages
    execSync('git checkout -b gh-pages');
    // add all files
    execSync('git add .');
    // commit with message and sha in description
    let description = `From ${commitSha}`;
    if (originalRemoteInfo !== false) {
        const gitCommitUrl = `https://github.com/${originalRemoteInfo.user}/${originalRemoteInfo.repo}/commit/${commitSha}`;
        description = `Commit: ${gitCommitUrl}`;
    }
    execSync(`git commit -m "Publish to Github Pages with Needle: ${projectName}" -m "${description}"`);
    // push
    execSync('git push origin gh-pages --force');
    // set to previous dir
    process.chdir(projectDirectory);
    // delete temp folder
    console.log("Remove temp directory " + tempFolder);
    rmSync(tempFolder, { recursive: true, force: true });
    if (repoNameFromRemote.endsWith(".git"))
        repoNameFromRemote = repoNameFromRemote.substring(0, repoNameFromRemote.length - 4);
    log(`Successfully published to github pages at https://${userNameFromRemote}.github.io/${repoNameFromRemote}`);
}
function getUserAndRepositoryNameFromUrl(url) {
    let matches = url.match(/github\.com[:\/](?<user>.*)\/(?<repo>.*)/);
    if (!matches) {
        matches = url.match(/\/\/(?<user>.*)\.github\.io\/(?<repo>.+?)($|\/)/);
    }
    if (!matches) {
        error("Could not parse remote url: " + url);
        return false;
    }
    return {
        user: matches.groups.user,
        repo: matches.groups.repo
    };
}
// code for stashing temporarely
// check if git has unstaged changes
// const status = execSync('git status --porcelain').toString().trim();
// if (status.length > 0) {
//     // check if there are any changes to the folder we want to publish
//     const lines = status.split('\n');
//     console.log(status);
//     const changes = lines.filter(line => line.startsWith(' M ' + relativePath));
//     if (changes.length <= 0) {
//         console.log("Stash changes as \"needle-deploy-to-github-pages\"")
//         execSync('git stash push -m needle-deploy-to-github-pages ' + relativePath);
//     }
// }
// // apply stash named needle-deploy-to-github-pages
// const stashList = execSync('git stash list').toString();
// const stashLines = stashList.split('\n');
// const deployStash = stashLines.find(line => line.endsWith('needle-deploy-to-github-pages'));
// if (deployStash) {
//     console.log("Found deploy stash \"" + deployStash + "\" - apply and remove the stash");
//     const id = deployStash.split(':')[0];
//     execSync('git stash apply ' + id);
//     execSync('git stash drop ' + id);
// }
