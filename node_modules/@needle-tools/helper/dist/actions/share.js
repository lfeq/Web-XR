import { existsSync, readdirSync, statSync } from "fs";
import fetch, { fileFromSync } from "node-fetch";
import { openUrlInDefaultBrowser } from "../utils/url.js";
import { error, log } from "../utils/log.js";
import { exit } from "process";
import crypto from "crypto";
const _storageServer = "https://needle-engine-file-service-r26roub2hq-lz.a.run.app";
const _existsEndpoint = "/api/v1/files/exists";
const _uploadEndpoint = "/api/v1/files/upload";
const _uploadRequestEndpoint = "/api/v1/files/request-upload-url";
const _uploadFinishedEndpoint = "/api/v1/files/register-uploaded";
const _view = "https://needle-share-r26roub2hq-ew.a.run.app/v1";
/**
 * Uploads all .glb files in the given directory to the storage server.
 * @param assetsDirectory The directory to upload from.
 * @param storageUrl Optional: The BASE URL of the storage server.
 */
export async function share(opts) {
    let { id, assetsDirectory, storageUrl, access_token, open } = opts;
    if (!storageUrl) {
        storageUrl = _storageServer;
    }
    if (!access_token) {
        error("No access token provided.");
        exit(1);
    }
    if (!assetsDirectory || !existsSync(assetsDirectory)) {
        error("Directory does not exist: " + assetsDirectory);
        exit(1);
    }
    const files = readdirSync(assetsDirectory);
    let project_id = null;
    const uploadEndpoint = storageUrl + _uploadEndpoint;
    const existsEndpoint = storageUrl + _existsEndpoint;
    for (const fileName of files) {
        const filePath = assetsDirectory + "/" + fileName;
        const fileStat = statSync(filePath);
        if (fileStat.isDirectory()) {
            continue;
        }
        else {
            log(`Attempt uploading \"${fileName}\"`);
            try {
                const bin = fileFromSync(filePath, "application/octet-stream");
                const buffer = Buffer.from(await bin.arrayBuffer());
                const sha1 = await crypto.createHash("sha1").update(buffer).digest("hex");
                const existsRes = await fetch(existsEndpoint, {
                    method: "POST",
                    headers: {
                        "id": id,
                        "filename": fileName,
                        "access-token": access_token,
                        "hash": sha1
                    }
                });
                if (existsRes.ok) {
                    log(`\"${fileName}\" already exists`);
                    const resId = await existsRes.text();
                    if (resId) {
                        project_id = resId;
                    }
                    continue;
                }
                let uploadUrl = uploadEndpoint;
                let uploadMethod = "POST";
                // if file is bigger than 32 mb we need to request a presigned upload url
                const isLargeFile = buffer.byteLength > 30 * 1024 * 1024;
                if (isLargeFile) {
                    log(`Request upload url for large file: ${(buffer.byteLength / 1024 / 1024).toFixed(2)} MB, ${fileName}`);
                    uploadUrl = storageUrl + _uploadRequestEndpoint;
                    const uploadRequestRes = await fetch(uploadUrl, {
                        method: "POST",
                        headers: {
                            "id": id,
                            "filename": fileName,
                            "access-token": access_token
                        }
                    });
                    /** @type {{url:string}} */
                    const json = JSON.parse(await uploadRequestRes.text());
                    uploadUrl = json.url;
                    project_id = json.id;
                    uploadMethod = "PUT";
                    log("Received presigned upload url");
                }
                // perform upload request
                // the upload url is either the needle fileservice or a presigned url
                // for presigned urls we upload the file with a PUT request
                log(`Uploading ${fileName}`);
                let uploadResult = await fetch(uploadUrl, {
                    method: uploadMethod,
                    body: bin,
                    headers: {
                        "id": id,
                        "filename": fileName,
                        "access-token": access_token
                    }
                }).catch(err => {
                    error(`Upload failed or rejected, message \"${err.message}\", file \"${filePath}\"`);
                    return err;
                });
                if (!uploadResult.ok) {
                    if (uploadResult.status === 413) {
                        error(`Upload rejected because file is too large ${(buffer.byteLength / 1024 / 1024).toFixed(2)} MB, \"${filePath}\"`);
                    }
                    else
                        error(`Upload failed or rejected, status ${uploadResult.status}, message \"${await uploadResult.text()}\", file \"${filePath}\"`);
                    break;
                }
                else {
                    if (isLargeFile) {
                        log(`Large file upload finished \"${filePath}\"`);
                        console.log("UPLOADED@" + fileName);
                        // Notify the server that the upload has completed:
                        const uploadFinishedUrl = storageUrl + _uploadFinishedEndpoint;
                        const uploadRequestRes = await fetch(uploadFinishedUrl, {
                            method: "POST",
                            headers: {
                                "id": id,
                                "filename": fileName,
                                "access-token": access_token,
                                "filesize": buffer.byteLength.toString(),
                                "filetype": "model/gltf-binary",
                            }
                        }).catch(err => err);
                        if (!uploadRequestRes.ok) {
                            error(`Upload failed or rejected, status ${uploadRequestRes.status}, message \"${await uploadRequestRes.text()}\", file \"${filePath}\"`);
                            continue;
                        }
                        else {
                            console.log("Successfully notified server");
                        }
                    }
                    else {
                        const resId = await uploadResult.text();
                        console.log("UPLOADED@" + fileName);
                        if (resId) {
                            project_id = resId;
                        }
                    }
                }
            }
            catch (e) {
                error(`ERROR uploading file \"${e.message}\", file \"${filePath}\"`);
                break;
            }
        }
    }
    const liveUrl = _view + "/" + project_id;
    if (project_id)
        console.log("LIVE@" + liveUrl);
    if (open) {
        if (!project_id) {
            error("Can not open: No files were uploaded.");
            return;
        }
        openUrlInDefaultBrowser(liveUrl);
    }
}
