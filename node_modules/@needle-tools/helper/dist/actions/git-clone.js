import { execSync } from "child_process";
import { error, log, warning } from "../utils/log.js";
import { existsSync, mkdirSync, readdirSync, unlinkSync } from "fs";
import StreamZip from "node-stream-zip";
import { deleteFolderRecursive, moveDirectory } from "../utils/file-utils.js";
function getRepositoryName(url) {
    if (url.includes("github.com")) {
        if (url.includes("/tree/")) {
            url = url.split("/tree/")[0];
        }
        else if (url.includes("/commit/")) {
            url = url.split("/commit/")[0];
        }
    }
    let repositoryName = url.split("/").pop();
    repositoryName = repositoryName.split("?")[0];
    return repositoryName;
}
function getRepositoryInfo(url) {
    const res = {
        url: url,
        name: getRepositoryName(url),
        branch: undefined,
        commit: undefined,
    };
    if (url.includes("github.com")) {
        const isTree = url.includes("/tree/");
        if (isTree) {
            const split = url.split("/tree/");
            res.url = split[0];
            res.branch = split[1];
            // a /tree/ url can also contain a commit sha:
            // TODO: add regex
        }
        const isCommit = url.includes("/commit/");
        if (isCommit) {
            const split = url.split("/commit/");
            res.url = split[0];
            res.commit = split[1];
        }
    }
    return res;
}
/** Clones or downloads a repository. Fallback to download if git is not installed
 * @param url The url of the repository
 * @param targetfolder The target folder to clone into
 * @param recursive If true, submodules will be cloned as well (only works for clone if GIT is installed)
 */
export async function cloneRepository(url, targetfolder, recursive = true) {
    if (!targetfolder) {
        // const processDir = process.cwd();
        error("Can not pull repository - No target folder specified. Please specify a target folder.");
        return false;
    }
    // check if git is installed
    try {
        execSync("git --version", { stdio: 'ignore' });
    }
    catch (err) {
        warning("Can not pull repository - Git is not installed - will try downloading repository instead");
        return downloadRepository(url, targetfolder);
    }
    // if the directory is empty we directly clone into that
    let directoryIsEmpty = true;
    if (existsSync(targetfolder)) {
        directoryIsEmpty = readdirSync(targetfolder).length === 0;
    }
    // otherwise if it's not empty we create a subfolder named like the repository
    if (!directoryIsEmpty) {
        targetfolder += "/" + getRepositoryName(url);
    }
    if (!existsSync(targetfolder)) {
        mkdirSync(targetfolder, { recursive: true });
    }
    const files = readdirSync(targetfolder);
    // if (files.length > 0) {
    //     const repositoryName = url.split("/").pop();
    //     if (repositoryName) {
    //         targetfolder += "/" + repositoryName;
    //         if (!existsSync(targetfolder)) {
    //             mkdirSync(targetfolder, { recursive: true });
    //         }
    //     }
    // }
    try {
        // clone into target folder
        let pullCommand = "git clone";
        const info = getRepositoryInfo(url);
        // a git url can contain a branch name after a #
        if (info.branch) {
            pullCommand += " --branch " + info.branch;
        }
        let pullUrl = info.url;
        pullUrl = pullUrl.split("?")[0];
        pullCommand += " \"" + pullUrl + "\"";
        pullCommand += " .";
        if (recursive)
            pullCommand += " --recurse-submodules";
        log("Pulling repository with command: " + pullCommand);
        execSync(pullCommand, { cwd: targetfolder, stdio: 'inherit' });
        if (info.commit) {
            const checkoutCommand = "git -c advice.detachedHead=false checkout " + info.commit;
            log("Checking out commit with command: " + checkoutCommand);
            execSync(checkoutCommand, { cwd: targetfolder, stdio: 'inherit' });
        }
        handlePath(targetfolder, url);
        log(`Sucessfully cloned repository into \"${targetfolder}\"`);
        return true;
    }
    catch (err) {
        if (files.length > 0) {
            error(`Could not pull repository into existing folder at \"${targetfolder}\": Please specify an empty target folder.`);
        }
        else
            error("Could not pull repository: " + err.message);
        return false;
    }
}
export async function downloadRepository(url, targetFolder) {
    // Download https://github.com/<user>/<name>/archive/refs/heads/<branch>.zip
    // Branch url https://github.com/<user>/<name>/archive/refs/heads/<branch-path>.zip
    targetFolder += "/" + getRepositoryName(url);
    if (!existsSync(targetFolder)) {
        mkdirSync(targetFolder, { recursive: true });
    }
    const info = getRepositoryInfo(url);
    let downloadUrl = info.url;
    downloadUrl = downloadUrl.replace("https://github.com/", "https://api.github.com/repos/") + "/zipball";
    if (info.branch) {
        downloadUrl += "/" + info.branch;
    }
    const zipPath = targetFolder + "/repository.zip";
    const downloadCommand = "curl -L " + downloadUrl + " --output \"" + zipPath + "\"";
    log("Downloading repository with command: " + downloadCommand);
    try {
        execSync(downloadCommand, { stdio: 'inherit' });
        const zip = new StreamZip.async({ file: zipPath });
        const entries = await zip.entries();
        // Expecting the github directory as the first entry 
        // We extract it like that because github zips contain a folder with the content
        // but we want to extract in the target directory directly
        const firstEntry = Object.values(entries)[0];
        const entryDirectoryName = firstEntry.name.split("/")[0];
        for (const entry of Object.keys(entries)) {
            const value = entries[entry];
            value.name = value.name.substring(entryDirectoryName.length + 1);
            const targetPath = targetFolder + "/" + value.name;
            if (value.isDirectory && !existsSync(targetPath)) {
                mkdirSync(targetPath, { recursive: true });
            }
            await zip.extract(value, targetFolder + "/" + value.name);
        }
        await zip.close();
        handlePath(targetFolder, url);
        log(`Sucessfully downloaded repository to \"${targetFolder}\"`);
        return true;
    }
    catch (err) {
        error("Could not download repository: " + err.message);
        return false;
    }
    finally {
        if (existsSync(zipPath))
            unlinkSync(zipPath);
    }
}
function handlePath(directory, url) {
    const _url = new URL(url);
    const path = _url.searchParams.get("path");
    if (!path) {
        console.log("No \"path\" specified: You can specify a subfolder in your repository by adding a \"?path=<path>\" query parameter to the url.");
        return;
    }
    const dirWithPath = directory + "/" + path;
    if (!existsSync(dirWithPath)) {
        error("Could not find path \"" + path + "\" in " + directory);
        return;
    }
    const tempPath = directory + "/../temp-" + Date.now();
    mkdirSync(tempPath, { recursive: true });
    moveDirectory(dirWithPath, tempPath);
    deleteFolderRecursive(directory);
    moveDirectory(tempPath, directory);
    console.log("Using subfolder \"" + path + "\"");
}
