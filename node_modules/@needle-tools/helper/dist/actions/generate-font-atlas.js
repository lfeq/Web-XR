import generateBMFont from 'msdf-bmfont-xml';
import fs, { writeFileSync } from 'fs';
import path from 'path';
// https://soimy.github.io/msdf-bmfont-xml/#module-usage-examples
export function generateFontAtlas(fontPath, outputDir, charsetPath) {
    if (!fontPath || !fs.existsSync(fontPath)) {
        console.error(`Missing font path. Please call this script with a path to a font file. Called with: \"${fontPath}\"`);
        return Promise.resolve(false);
    }
    if (!outputDir || !fs.existsSync(outputDir)) {
        console.error(`Missing output directory, please provide an output directory as the second argument. Called with: \"${outputDir}\"`);
        return Promise.resolve(false);
    }
    let message = `Generate font texture \"${fontPath}\" to \"${outputDir}\"`;
    let charset = null;
    if (charsetPath) {
        if (fs.existsSync(charsetPath)) {
            message += " using chars from \"" + charsetPath + "\"";
            charset = fs.readFileSync(charsetPath, 'utf8');
            console.log("charset: ", charset);
            if (charset.length <= 0) {
                console.warn("WARN: Charset file is empty, using default charset");
                charset = null;
            }
        }
        else {
            message += " using default charset (provided charset path does not exist)";
        }
    }
    console.log(message);
    const opts = {
        outputType: "json",
        fieldType: "msdf",
        textureSize: [4096, 4096],
        smartSize: true,
        // rtl: true, // use RTL(Arabic/Persian) charators fix,
        charset: undefined,
    };
    if (charset?.length)
        opts.charset = charset;
    else
        delete opts.charset;
    return new Promise((res, rej) => {
        generateBMFont(fontPath, opts, (error, textures, font) => {
            if (error) {
                console.error("Error generating font atlas: " + error);
                return rej(error);
            }
            if (font.data?.length <= 0) {
                console.error("WARN: Failed to generate font data - generated empty font data...");
                return res(false);
            }
            console.log("Generated font atlas with " + textures.length + " texture(s) and " + font.data.length + " bytes of font data");
            for (let i = 0; i < textures.length; i++) {
                const texture = textures[i];
                const directory = path.dirname(texture.filename);
                // remove the directory from the filename, we can not rely on path.parse because it fails if the filename contains a dot
                const fileName = texture.filename.substring(directory.length) + ".png";
                const outputPath = outputDir + "/" + fileName;
                console.log("Write to", outputPath);
                if (i > 0)
                    console.log("WARN: Multiple font textures generated but they will override each other. You have currently " + charset?.length + " characters configured. Maybe too many?");
                writeFileSync(outputPath, texture.texture);
            }
            const fileName = path.parse(font.filename).name;
            const name = outputDir + "/" + fileName + "-msdf.json";
            writeFileSync(name, font.data);
            res(true);
        });
    });
}
