import { copyFileSync, existsSync, mkdirSync, readFileSync, readdirSync, writeFileSync } from "fs";
import { error, log } from "../utils/log.js";
import { cpus, homedir, machine, tmpdir, totalmem, userInfo } from "os";
import { zip } from "./zip.js";
import { uploadBugReport } from "./upload-to-filestorage.js";
import { copyRecursive } from "../utils/file-utils.js";
export async function generateBugReport(file, editorPath, url, extra, description) {
    console.log(file);
    if (!file || file.length === 0) {
        console.error("No file specified. Use --file <file>");
        process.exit(1);
    }
    file = file.replace(/\\/g, "/");
    const fileName = file.split("/").pop();
    const filenameWithoutExtension = fileName?.split(".").shift();
    const isBlender = file.endsWith(".blend");
    let tempDirectory = tmpdir() + "/Needle/BugReports/";
    if (isBlender)
        tempDirectory += "Blender-";
    if (filenameWithoutExtension)
        tempDirectory += filenameWithoutExtension + "-";
    tempDirectory += Date.now();
    if (!existsSync(tempDirectory)) {
        mkdirSync(tempDirectory, { recursive: true });
    }
    console.log("Generate bugreport in: " + tempDirectory);
    try {
        const systemInformationString = await gatherSystemInformation();
        const info = {
            description: systemInformationString
        };
        if (description) {
            info.description += "\n## Description:\n" + description;
        }
        let editorName = "";
        if (isBlender) {
            editorName = "Blender";
            await generateBlenderBugReport(info, file, tempDirectory, editorPath);
        }
        else {
            error("Only blender files are supported at the moment");
            process.exit(1);
        }
        if (extra) {
            for (let i = 0; i < extra.length; i++) {
                let dirOrFile = extra[i];
                const dirOrFileExists = existsSync(dirOrFile);
                if (!dirOrFileExists) {
                    error("Extra file or directory does not exist: " + dirOrFile);
                    continue;
                }
                dirOrFile = dirOrFile.replaceAll("\\", "/");
                // remove trailing slashes
                while (dirOrFile.endsWith("/"))
                    dirOrFile = dirOrFile.substring(0, dirOrFile.length - 1);
                copyRecursive(dirOrFile, tempDirectory + "/extra/" + i);
            }
        }
        // write system information to file
        const systemInformationFile = tempDirectory + "/system-information.txt";
        writeFileSync(systemInformationFile, systemInformationString);
        await zipAndUpload(tempDirectory, url, editorName, info);
    }
    finally {
        // if (existsSync(tempDirectory)) {
        //     rmSync(tempDirectory, { recursive: true });
        // }
    }
}
/** returns path to zip */
async function generateBlenderBugReport(info, file, tempDirectory, editorPath) {
    if (existsSync(file)) {
        info.description = "File: \"" + file + "\"\n" + info.description;
        file = file.replaceAll("\\", "/");
        const fileName = file.split("/").pop();
        copyFileSync(file, tempDirectory + "/" + fileName);
        // check if a crash file for the scene exists on windows:
        if (process.platform === "win32") {
            console.log(file);
            const filenameWithoutExtension = file.split("/").pop()?.split(".").shift();
            const crashFile = tmpdir() + "/" + filenameWithoutExtension + ".crash.txt";
            console.log(crashFile);
            if (existsSync(crashFile)) {
                copyFileSync(crashFile, tempDirectory + "/" + filenameWithoutExtension + ".crash.txt");
                try {
                    const crashLogFirstLine = readFileSync(crashFile).toString().split("\n").shift();
                    if (crashLogFirstLine?.length > 0) {
                        const blenderVersionStart = crashLogFirstLine.indexOf("Blender ");
                        const blenderVersionEnd = crashLogFirstLine.indexOf(", ", blenderVersionStart + 8);
                        const blenderVersion = crashLogFirstLine.substring(blenderVersionStart, blenderVersionEnd);
                        info.description = blenderVersion + "\n" + info.description;
                        if (!info.editor) {
                            info.editor = blenderVersion;
                        }
                    }
                }
                catch (e) {
                    console.error(e);
                }
            }
        }
    }
    else {
        info.description = "File does not exist: \"" + file + "\"\n" + info.description;
    }
    if (editorPath && editorPath.length > 0) {
        // copy blender logs
    }
    const needleLogPathForBlender = tmpdir() + "/Needle/Blender";
    if (existsSync(needleLogPathForBlender)) {
        copyRecursive(needleLogPathForBlender, tempDirectory + "/needle-blender-logs");
    }
}
async function zipAndUpload(tempDirectory, url, editorName, info) {
    // check if directory exists and is not empty
    if (!existsSync(tempDirectory)) {
        error("Temp directory does not exist");
        process.exit(1);
    }
    const files = readdirSync(tempDirectory);
    if (files.length === 0) {
        error("Temp directory is empty");
        process.exit(1);
    }
    console.log(files);
    if (!url || url.length === 0) {
        const getUrl = await fetch("https://urls.needle.tools/bugreport-endpoint");
        url = await getUrl.text();
        log("Queried upload url: " + url);
        if (!url) {
            console.error("No url specified and failed to query bugreport URL. You can use --url <url>. This must be the server endpoint");
            process.exit(1);
        }
    }
    // zip directory
    const finalPath = await zip(tempDirectory, tempDirectory);
    console.log(finalPath);
    // TODO UPLOAD
    const systemUserName = userInfo().username;
    uploadBugReport(url, finalPath, editorName, systemUserName, info.description);
}
async function gatherSystemInformation() {
    let res = "";
    res += "User: " + userInfo().username + "\n";
    res += "Node: " + process.version + "\n";
    res += "CPU: " + cpus()[0]?.model?.trim() + "\n";
    res += "Cores: " + cpus().length + "\n";
    res += "Memory: " + (totalmem() / 1024 / 1024 / 1024).toFixed(2) + " GB\n";
    res += "OS: " + process.platform + "\n";
    res += "Machine: " + machine() + "\n";
    res += "Home: " + homedir() + "\n";
    return res;
}
