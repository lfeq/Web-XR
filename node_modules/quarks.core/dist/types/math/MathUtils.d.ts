import { Quaternion } from './Quaternion';
import { EulerOrder } from './Euler';
declare const DEG2RAD: number;
declare const RAD2DEG: number;
declare function generateUUID(): string;
declare function clamp(value: number, min: number, max: number): number;
declare function euclideanModulo(n: number, m: number): number;
declare function mapLinear(x: number, a1: number, a2: number, b1: number, b2: number): number;
declare function inverseLerp(x: number, y: number, value: number): number;
declare function lerp(x: number, y: number, t: number): number;
declare function damp(x: number, y: number, lambda: number, dt: number): number;
declare function pingpong(x: number, length?: number): number;
declare function smoothstep(x: number, min: number, max: number): number;
declare function smootherstep(x: number, min: number, max: number): number;
declare function randInt(low: number, high: number): number;
declare function randFloat(low: number, high: number): number;
declare function randFloatSpread(range: number): number;
declare function seededRandom(s: number): number;
declare function degToRad(degrees: number): number;
declare function radToDeg(radians: number): number;
declare function isPowerOfTwo(value: number): boolean;
declare function ceilPowerOfTwo(value: number): number;
declare function floorPowerOfTwo(value: number): number;
declare function setQuaternionFromProperEuler(q: Quaternion, a: number, b: number, c: number, order: EulerOrder): void;
declare function denormalize(value: number, array: number[]): number;
declare function normalize(value: number, array: number[]): number;
declare const MathUtils: {
    DEG2RAD: number;
    RAD2DEG: number;
    generateUUID: typeof generateUUID;
    clamp: typeof clamp;
    euclideanModulo: typeof euclideanModulo;
    mapLinear: typeof mapLinear;
    inverseLerp: typeof inverseLerp;
    lerp: typeof lerp;
    damp: typeof damp;
    pingpong: typeof pingpong;
    smoothstep: typeof smoothstep;
    smootherstep: typeof smootherstep;
    randInt: typeof randInt;
    randFloat: typeof randFloat;
    randFloatSpread: typeof randFloatSpread;
    seededRandom: typeof seededRandom;
    degToRad: typeof degToRad;
    radToDeg: typeof radToDeg;
    isPowerOfTwo: typeof isPowerOfTwo;
    ceilPowerOfTwo: typeof ceilPowerOfTwo;
    floorPowerOfTwo: typeof floorPowerOfTwo;
    setQuaternionFromProperEuler: typeof setQuaternionFromProperEuler;
    normalize: typeof normalize;
    denormalize: typeof denormalize;
};
export { DEG2RAD, RAD2DEG, generateUUID, clamp, euclideanModulo, mapLinear, inverseLerp, lerp, damp, pingpong, smoothstep, smootherstep, randInt, randFloat, randFloatSpread, seededRandom, degToRad, radToDeg, isPowerOfTwo, ceilPowerOfTwo, floorPowerOfTwo, setQuaternionFromProperEuler, normalize, denormalize, MathUtils };
//# sourceMappingURL=MathUtils.d.ts.map